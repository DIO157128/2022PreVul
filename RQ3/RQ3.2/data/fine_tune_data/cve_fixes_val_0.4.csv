,source,target
0,"CWE-400 static int session_new ( nghttp2_session * * session_ptr , const nghttp2_session_callbacks * callbacks , void * user_data , int server , const nghttp2_option * option , nghttp2_mem * mem ) { int rv ; size_t nbuffer ; size_t max_deflate_dynamic_table_size = NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE ; if ( mem == NULL ) { mem = nghttp2_mem_default ( ) ; } * session_ptr = nghttp2_mem_calloc ( mem , 1 , sizeof ( nghttp2_session ) ) ; if ( * session_ptr == NULL ) { rv = NGHTTP2_ERR_NOMEM ; goto fail_session ; } ( * session_ptr ) -> mem = * mem ; mem = & ( * session_ptr ) -> mem ; nghttp2_stream_init ( & ( * session_ptr ) -> root , 0 , NGHTTP2_STREAM_FLAG_NONE , NGHTTP2_STREAM_IDLE , NGHTTP2_DEFAULT_WEIGHT , 0 , 0 , NULL , mem ) ; ( * session_ptr ) -> remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> recv_window_size = 0 ; ( * session_ptr ) -> consumed_size = 0 ; ( * session_ptr ) -> recv_reduction = 0 ; ( * session_ptr ) -> local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> goaway_flags = NGHTTP2_GOAWAY_NONE ; ( * session_ptr ) -> local_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> remote_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> pending_local_max_concurrent_stream = NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ; ( * session_ptr ) -> pending_enable_push = 1 ; if ( server ) { ( * session_ptr ) -> server = 1 ; } init_settings ( & ( * session_ptr ) -> remote_settings ) ; init_settings ( & ( * session_ptr ) -> local_settings ) ; ( * session_ptr ) -> max_incoming_reserved_streams = NGHTTP2_MAX_INCOMING_RESERVED_STREAMS ; ( * session_ptr ) -> remote_settings . max_concurrent_streams = 100 ; ( * session_ptr ) -> max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN ; ( * session_ptr ) -> max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; <S2SV_StartBug> if ( option ) { <S2SV_EndBug> if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ; } if ( option -> opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS ) { ( * session_ptr ) -> remote_settings . max_concurrent_streams = option -> peer_max_concurrent_streams ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS ) { ( * session_ptr ) -> max_incoming_reserved_streams = option -> max_reserved_remote_streams ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC ) && option -> no_recv_client_magic ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING ) && option -> no_http_messaging ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING ; } if ( option -> opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES ) { memcpy ( ( * session_ptr ) -> user_recv_ext_types , option -> user_recv_ext_types , sizeof ( ( * session_ptr ) -> user_recv_ext_types ) ) ; } if ( option -> opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES ) { ( * session_ptr ) -> builtin_recv_ext_types = option -> builtin_recv_ext_types ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK ) && option -> no_auto_ping_ack ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH ) { ( * session_ptr ) -> max_send_header_block_length = option -> max_send_header_block_length ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE ) { max_deflate_dynamic_table_size = option -> max_deflate_dynamic_table_size ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS ) && option -> no_closed_streams ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK ) { ( * session_ptr ) -> max_outbound_ack = option -> max_outbound_ack ; } <S2SV_StartBug> } <S2SV_EndBug> rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ; if ( rv != 0 ) { goto fail_hd_deflater ; } rv = nghttp2_hd_inflate_init ( & ( * session_ptr ) -> hd_inflater , mem ) ; if ( rv != 0 ) { goto fail_hd_inflater ; } rv = nghttp2_map_init ( & ( * session_ptr ) -> streams , mem ) ; if ( rv != 0 ) { goto fail_map ; } nbuffer = ( ( * session_ptr ) -> max_send_header_block_length + NGHTTP2_FRAMEBUF_CHUNKLEN - 1 ) / NGHTTP2_FRAMEBUF_CHUNKLEN ; if ( nbuffer == 0 ) { nbuffer = 1 ; } rv = nghttp2_bufs_init3 ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_FRAMEBUF_CHUNKLEN , nbuffer , 1 , NGHTTP2_FRAME_HDLEN + 1 , mem ) ; if ( rv != 0 ) { goto fail_aob_framebuf ; } active_outbound_item_reset ( & ( * session_ptr ) -> aob , mem ) ; ( * session_ptr ) -> callbacks = * callbacks ; ( * session_ptr ) -> user_data = user_data ; session_inbound_frame_reset ( * session_ptr ) ; if ( nghttp2_enable_strict_preface ) { nghttp2_inbound_frame * iframe = & ( * session_ptr ) -> iframe ; if ( server && ( ( * session_ptr ) -> opt_flags & NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ) == 0 ) { iframe -> state = NGHTTP2_IB_READ_CLIENT_MAGIC ; iframe -> payloadleft = NGHTTP2_CLIENT_MAGIC_LEN ; } else { iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } if ( ! server ) { ( * session_ptr ) -> aob . state = NGHTTP2_OB_SEND_CLIENT_MAGIC ; nghttp2_bufs_add ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_CLIENT_MAGIC , NGHTTP2_CLIENT_MAGIC_LEN ) ; } } return 0 ; fail_aob_framebuf : nghttp2_map_free ( & ( * session_ptr ) -> streams ) ; fail_map : nghttp2_hd_inflate_free ( & ( * session_ptr ) -> hd_inflater ) ; fail_hd_inflater : nghttp2_hd_deflate_free ( & ( * session_ptr ) -> hd_deflater ) ; fail_hd_deflater : nghttp2_mem_free ( mem , * session_ptr ) ; fail_session : return rv ; }
","<S2SV_ModStart> = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; ( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ; <S2SV_ModStart> max_outbound_ack ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) { ( * session_ptr ) -> max_settings = option -> max_settings ; }
"
1,"CWE-77 <S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> { static const char quote [ ] = ""\\""\\\\"" ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }
","<S2SV_ModStart> char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char *
"
2,"CWE-59 void w3m_exit ( int i ) { # ifdef USE_MIGEMO init_migemo ( ) ; # endif stopDownload ( ) ; deleteFiles ( ) ; # ifdef USE_SSL free_ssl_ctx ( ) ; # endif disconnectFTP ( ) ; # ifdef USE_NNTP disconnectNews ( ) ; # endif # ifdef __MINGW32_VERSION WSACleanup ( ) ; # endif <S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , ""Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n"" , tmp_dir ) ; exit ( 1 ) ; } # endif
"
3,"CWE-000 void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ; if ( t < 0 ) { t = 0 ; } days = t / 86400 ; <S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> wday = ( 4 + days ) % 7 ; hour = sec / 3600 ; sec %= 3600 ; min = sec / 60 ; sec %= 60 ; days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }
","<S2SV_ModStart> % 86400 ; if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; }
"
4,"CWE-416 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
"
5,"CWE-119 <S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> uint8_t buf [ 32 ] ; int is_raw = 0 ; vpx_codec_stream_info_t si ; si . sz = sizeof ( si ) ; if ( fread ( buf , 1 , 32 , input -> file ) == 32 ) { int i ; if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> buf + 4 , 32 - 4 , & si ) ) { is_raw = 1 ; input -> fourcc = decoder -> fourcc ; input -> width = si . w ; input -> height = si . h ; input -> framerate . numerator = 30 ; input -> framerate . denominator = 1 ; break ; } } } } rewind ( input -> file ) ; return is_raw ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ,
"
6,"CWE-119 static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case TRACKPAD_REPORT_ID : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; <S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case MOUSE_REPORT_ID : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case DOUBLE_REPORT_ID : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == USB_DEVICE_ID_APPLE_MAGICMOUSE ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , REL_X , x ) ; input_report_rel ( input , REL_Y , y ) ; } else { input_report_key ( input , BTN_MOUSE , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }
","<S2SV_ModStart> / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; }
"
7,"CWE-362 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }
","<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;
"
8,"CWE-399 void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n"" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( ""%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n"" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } <S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }
","<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :
"
9,"CWE-125 int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 1 ) ; if ( bp [ hlen ] & 0xf0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ; hlen += 1 ; hlen += 1 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 16 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
"
10,"CWE-190 static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }
","<S2SV_ModStart> * pRet ; sqlite3_int64 <S2SV_ModEnd> nByte = sizeof <S2SV_ModStart> ( 2 * ( sqlite3_int64 ) <S2SV_ModStart> MatchinfoBuffer ) ; sqlite3_int64 nStr = <S2SV_ModEnd> strlen ( zMatchinfo <S2SV_ModStart> ; pRet = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
"
11,"CWE-20 error_t rawSocketSendIpPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; NetInterface * interface ; IpPseudoHeader pseudoHeader ; NetTxAncillary ancillary ; <S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> buffer = ipAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; do { error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( error ) break ; # if ( IPV4_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv4Addr ) ) { Ipv4Addr srcIpAddr ; error = ipv4SelectSourceAddr ( & interface , message -> destIpAddr . ipv4Addr , & srcIpAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader . ipv4Data . srcAddr = srcIpAddr ; pseudoHeader . ipv4Data . destAddr = message -> destIpAddr . ipv4Addr ; pseudoHeader . ipv4Data . reserved = 0 ; pseudoHeader . ipv4Data . protocol = socket -> protocol ; pseudoHeader . ipv4Data . length = htons ( message -> length ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv6Addr ) ) { error = ipv6SelectSourceAddr ( & interface , & message -> destIpAddr . ipv6Addr , & pseudoHeader . ipv6Data . srcAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader . ipv6Data . destAddr = message -> destIpAddr . ipv6Addr ; pseudoHeader . ipv6Data . length = htonl ( message -> length ) ; pseudoHeader . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader . ipv6Data . nextHeader = socket -> protocol ; } else # endif { error = ERROR_FAILURE ; break ; } ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif error = ipSendDatagram ( interface , & pseudoHeader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netBufferFree ( buffer ) ; return error ; }
","<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer
"
12,"CWE-264 int udpv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <S2SV_StartBug> struct ipv6_txoptions * opt = NULL ; <S2SV_EndBug> struct ip6_flowlabel * flowlabel = NULL ; struct flowi6 fl6 ; struct dst_entry * dst ; int addr_len = msg -> msg_namelen ; int ulen = len ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int err ; int connected = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ; if ( sin6 ) { if ( addr_len < offsetof ( struct sockaddr , sa_data ) ) return - EINVAL ; switch ( sin6 -> sin6_family ) { case AF_INET6 : if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; break ; case AF_INET : goto do_udp_sendmsg ; case AF_UNSPEC : msg -> msg_name = sin6 = NULL ; msg -> msg_namelen = addr_len = 0 ; daddr = NULL ; break ; default : return - EINVAL ; } } else if ( ! up -> pending ) { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; } else daddr = NULL ; if ( daddr ) { if ( ipv6_addr_v4mapped ( daddr ) ) { struct sockaddr_in sin ; sin . sin_family = AF_INET ; sin . sin_port = sin6 ? sin6 -> sin6_port : inet -> inet_dport ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; msg -> msg_name = & sin ; msg -> msg_namelen = sizeof ( sin ) ; do_udp_sendmsg : if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; return udp_sendmsg ( sk , msg , len ) ; } } if ( up -> pending == AF_INET ) return udp_sendmsg ( sk , msg , len ) ; if ( len > INT_MAX - sizeof ( struct udphdr ) ) return - EMSGSIZE ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET6 ) ) { release_sock ( sk ) ; return - EAFNOSUPPORT ; } dst = NULL ; goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( sin6 ) { if ( sin6 -> sin6_port == 0 ) return - EINVAL ; fl6 . fl6_dport = sin6 -> sin6_port ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; fl6 . fl6_dport = inet -> inet_dport ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; connected = 1 ; } if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> sticky_pktinfo . ipi6_ifindex ; fl6 . flowi6_mark = sk -> sk_mark ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( * opt ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; connected = 0 ; } <S2SV_StartBug> if ( ! opt ) <S2SV_EndBug> opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; fl6 . fl6_sport = inet -> inet_sport ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( final_p ) connected = 0 ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) { fl6 . flowi6_oif = np -> mcast_oif ; connected = 0 ; } else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_sk_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( ! corkreq ) { struct sk_buff * skb ; skb = ip6_make_skb ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; err = PTR_ERR ( skb ) ; if ( ! IS_ERR_OR_NULL ( skb ) ) err = udp_v6_send_skb ( skb , & fl6 ) ; goto release_dst ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; net_dbg_ratelimited ( ""udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n"" ) ; err = - EINVAL ; goto out ; } up -> pending = AF_INET6 ; do_append_data : if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; up -> len += ulen ; err = ip6_append_data ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags , dontfrag ) ; if ( err ) udp_v6_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_v6_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; if ( err > 0 ) err = np -> recverr ? net_xmit_errno ( err ) : 0 ; release_sock ( sk ) ; release_dst : if ( dst ) { if ( connected ) { ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; } else { dst_release ( dst ) ; } dst = NULL ; } out : dst_release ( dst ) ; <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }
","<S2SV_ModStart> ipv6_txoptions * opt = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
"
13,"CWE-770 rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( ""client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( ""server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n"" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } buffer = malloc ( msg . sct . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Open\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Close\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : <S2SV_StartBug> buffer = malloc ( msg . tc . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( ""Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n"" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }
","<S2SV_ModStart> ; default : if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ;
"
14,"CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
","<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
"
15,"CWE-125 int ares_parse_a_reply ( const unsigned char * abuf , int alen , struct hostent * * host ) { unsigned int qdcount , ancount ; int status , i , rr_type , rr_class , rr_len , naddrs ; long int len ; int naliases ; const unsigned char * aptr ; char * hostname , * rr_name , * rr_data , * * aliases ; struct in_addr * addrs ; struct hostent * hostent ; * host = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; addrs = malloc ( ancount * sizeof ( struct in_addr ) ) ; if ( ! addrs ) { free ( hostname ) ; return ARES_ENOMEM ; } aliases = malloc ( ( ancount + 1 ) * sizeof ( char * ) ) ; if ( ! aliases ) { free ( hostname ) ; free ( addrs ) ; return ARES_ENOMEM ; } naddrs = 0 ; naliases = 0 ; for ( i = 0 ; i < ( int ) ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) break ; aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; <S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) { memcpy ( & addrs [ naddrs ] , aptr , sizeof ( struct in_addr ) ) ; naddrs ++ ; status = ARES_SUCCESS ; } if ( rr_class == C_IN && rr_type == T_CNAME ) { aliases [ naliases ] = rr_name ; naliases ++ ; status = ares_expand_name ( aptr , abuf , alen , & rr_data , & len ) ; if ( status != ARES_SUCCESS ) break ; free ( hostname ) ; hostname = rr_data ; } else free ( rr_name ) ; aptr += rr_len ; if ( aptr > abuf + alen ) { status = ARES_EBADRESP ; break ; } } if ( status == ARES_SUCCESS && naddrs == 0 ) status = ARES_ENODATA ; if ( status == ARES_SUCCESS ) { aliases [ naliases ] = NULL ; hostent = malloc ( sizeof ( struct hostent ) ) ; if ( hostent ) { hostent -> h_addr_list = malloc ( ( naddrs + 1 ) * sizeof ( char * ) ) ; if ( hostent -> h_addr_list ) { hostent -> h_name = hostname ; hostent -> h_aliases = aliases ; hostent -> h_addrtype = AF_INET ; hostent -> h_length = sizeof ( struct in_addr ) ; for ( i = 0 ; i < naddrs ; i ++ ) hostent -> h_addr_list [ i ] = ( char * ) & addrs [ i ] ; hostent -> h_addr_list [ naddrs ] = NULL ; * host = hostent ; return ARES_SUCCESS ; } free ( hostent ) ; } status = ARES_ENOMEM ; } for ( i = 0 ; i < naliases ; i ++ ) free ( aliases [ i ] ) ; free ( aliases ) ; free ( addrs ) ; free ( hostname ) ; return status ; }
","<S2SV_ModStart> += RRFIXEDSZ ; if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; }
"
16,"CWE-269 uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }
","<S2SV_ModStart> uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
"
17,"CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }
","<S2SV_ModStart> objp ) ; * objp = NULL ;
"
18,"CWE-119 void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }
","<S2SV_ModStart> alarm_timer ) ; btif_config_write ( <S2SV_ModEnd> ) ; }
"
19,"CWE-200 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
","<S2SV_ModStart> |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
"
20,"CWE-189 static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
","<S2SV_ModStart> <= w - ( int )
"
21,"CWE-119 static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; rc -> frames_since_golden = 0 ; <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 1 ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> rc -> source_alt_ref_pending
"
22,"CWE-119 static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? ""POST"" : ""GET"" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , ""Received<S2SV_blank>method:<S2SV_blank>%s\\n"" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , ""Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\n"" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , ""Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\n"" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , ""Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\n"" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , ""Requested<S2SV_blank>resource:<S2SV_blank>%s\\n"" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\0' ; if ( av_strncasecmp ( version , ""HTTP/"" , 5 ) ) { av_log ( h , AV_LOG_ERROR , ""Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\n"" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , ""HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\n"" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , ""http_code=%d\\n"" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , ""Location"" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , ""Content-Range"" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , ""Accept-Ranges"" ) && ! strncmp ( p , ""bytes"" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , ""Transfer-Encoding"" ) && ! av_strncasecmp ( p , ""chunked"" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'%s\'\\n"" , p ) ; } else if ( ! av_strcasecmp ( tag , ""Icy-MetaInt"" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , ""Icy-"" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , ""Content-Encoding"" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }
","<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,
"
23,"CWE-787 static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt )
"
24,"CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }
","<S2SV_ModStart> : kfree ( req ) ; kfree (
"
25,"CWE-000 static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; } <S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }
","<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
"
26,"CWE-416 int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> ; } } io -> io_cleanup = port_cleanup ;
"
27,"CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
"
28,"CWE-189 static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n"" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n"" ) ; goto fail2 ; } <S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n"" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }
","<S2SV_ModStart> fail2 ; } BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; }
"
29,"CWE-125 int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , ""\\n"" , 1 ) ; return 1 ; }
","<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , ""%s\\n"" , obj_txt <S2SV_ModEnd> ) ; return
"
30,"CWE-787 SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( ""selReadStream"" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file"" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( ""invalid<S2SV_blank>sel<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n"" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""dimensions<S2SV_blank>not<S2SV_blank>read"" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""sel<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , ""%1d"" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , ""\\n"" ) ; } ignore = fscanf ( fp , ""\\n"" ) ; LEPT_FREE ( selname ) ; return sel ; }
","<S2SV_ModStart> char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> , selname )
"
31,"CWE-20 int auth_password ( Authctxt * authctxt , const char * password ) { struct passwd * pw = authctxt -> pw ; int result , ok = authctxt -> valid ; # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) static int expire_checked = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ; # endif if ( * password == '\\0' && options . permit_empty_passwd == 0 ) return 0 ; # ifdef KRB5 if ( options . kerberos_authentication == 1 ) { int ret = auth_krb5_password ( authctxt , password ) ; if ( ret == 1 || ret == 0 ) return ret && ok ; } # endif # ifdef HAVE_CYGWIN { HANDLE hToken = cygwin_logon_user ( pw , password ) ; if ( hToken == INVALID_HANDLE_VALUE ) return 0 ; cygwin_set_impersonation_token ( hToken ) ; return ok ; } # endif # ifdef USE_PAM if ( options . use_pam ) return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; # endif # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) if ( ! expire_checked ) { expire_checked = 1 ; if ( auth_shadow_pwexpired ( authctxt ) ) authctxt -> force_pwchange = 1 ; } # endif result = sys_auth_passwd ( authctxt , password ) ; if ( authctxt -> force_pwchange ) disable_forwarding ( ) ; return ( result && ok ) ; }
","<S2SV_ModStart> ; # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
"
32,"CWE-476 static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( ""no<S2SV_blank>spare<S2SV_blank>slots\\n"" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( ""have<S2SV_blank>meta\\n"" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( ""only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n"" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; <S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> } split_node : pr_devel ( ""split<S2SV_blank>node\\n"" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( ""do_split_node\\n"" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( ""same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n"" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( ""filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n"" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n"" , __func__ ) ; return true ; <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n"" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( ""all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n"" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( ""skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n"" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( ""blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n"" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }
","<S2SV_ModStart> goto all_leaves_cluster_together ; pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> ; } split_node <S2SV_ModStart> return true ; <S2SV_ModEnd> all_leaves_cluster_together : pr_devel
"
33,"CWE-000 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } if
"
34,"CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line
"
35,"CWE-000 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>found"" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone_prinicipal = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_prependmsg ( context , ost , st , _ ( ""\'%s\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone_prinicipal = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { int dnlen = 0 , subtreelen = 0 ; char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { ""krbticketpolicyreference"" , ""krbprincipalname"" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; <S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> goto cleanup ; if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastPwdChange"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbExtraData"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } for ( j = 0 ; ber_tl_data [ j ] != NULL ; j ++ ) { free ( ber_tl_data [ j ] -> bv_val ) ; free ( ber_tl_data [ j ] ) ; } free ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastAdminUnlock"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , ""objectclass"" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( ""ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>"" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbObjectReferences"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone_prinicipal == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = ""krbprincipal"" ; strval [ 1 ] = ""krbprincipalaux"" ; strval [ 2 ] = ""krbTicketPolicyAux"" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { ""krbprincipalaux"" , ""krbTicketPolicyAux"" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , ""objectclass"" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }
","<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !
"
36,"CWE-125 int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 ""grammar.y"" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 ""grammar.c"" break ; case 9 : # line 242 ""grammar.y"" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 ""grammar.c"" break ; case 10 : # line 251 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 ""grammar.c"" break ; case 11 : # line 259 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 ""grammar.c"" break ; case 12 : # line 274 ""grammar.y"" { ( yyval . meta ) = NULL ; } # line 1709 ""grammar.c"" break ; case 13 : # line 278 ""grammar.y"" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 ""grammar.c"" break ; case 14 : # line 305 ""grammar.y"" { ( yyval . string ) = NULL ; } # line 1744 ""grammar.c"" break ; case 15 : # line 309 ""grammar.y"" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 ""grammar.c"" break ; case 17 : # line 340 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 1777 ""grammar.c"" break ; case 18 : # line 341 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 ""grammar.c"" break ; case 19 : # line 346 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 ""grammar.c"" break ; case 20 : # line 347 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 ""grammar.c"" break ; case 21 : # line 353 ""grammar.y"" { ( yyval . c_string ) = NULL ; } # line 1803 ""grammar.c"" break ; case 22 : # line 357 ""grammar.y"" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 ""grammar.c"" break ; case 23 : # line 375 ""grammar.y"" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 ""grammar.c"" break ; case 24 : # line 388 ""grammar.y"" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 ""grammar.c"" break ; case 25 : # line 424 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 ""grammar.c"" break ; case 26 : # line 425 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 ""grammar.c"" break ; case 27 : # line 431 ""grammar.y"" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 ""grammar.c"" break ; case 28 : # line 447 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 ""grammar.c"" break ; case 29 : # line 460 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 ""grammar.c"" break ; case 30 : # line 473 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 ""grammar.c"" break ; case 31 : # line 486 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 ""grammar.c"" break ; case 32 : # line 502 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 ""grammar.c"" break ; case 33 : # line 503 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 ""grammar.c"" break ; case 34 : # line 509 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 ""grammar.c"" break ; case 35 : # line 513 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 ""grammar.c"" break ; case 36 : # line 524 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 ""grammar.c"" break ; case 37 : # line 528 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 ""grammar.c"" break ; case 38 : # line 540 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 ""grammar.c"" break ; case 39 : # line 553 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 2053 ""grammar.c"" break ; case 40 : # line 554 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 ""grammar.c"" break ; case 41 : # line 559 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 ""grammar.c"" break ; case 42 : # line 560 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 ""grammar.c"" break ; case 43 : # line 561 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 ""grammar.c"" break ; case 44 : # line 562 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 ""grammar.c"" break ; case 45 : # line 568 ""grammar.y"" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 ""grammar.c"" break ; case 46 : # line 653 ""grammar.y"" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 ""grammar.c"" break ; case 47 : # line 699 ""grammar.y"" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , ""dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 ""grammar.c"" break ; case 48 : # line 757 ""grammar.y"" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 ""grammar.c"" break ; case 49 : # line 801 ""grammar.y"" { ( yyval . c_string ) = yr_strdup ( """" ) ; } # line 2334 ""grammar.c"" break ; case 50 : # line 802 ""grammar.y"" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 ""grammar.c"" break ; case 51 : # line 807 ""grammar.y"" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> ERROR_IF ( ( yyval . c_string ) == NULL ) ; } <S2SV_StartBug> # line 2369 ""grammar.c"" <S2SV_EndBug> break ; case 52 : <S2SV_StartBug> # line 832 ""grammar.y"" <S2SV_EndBug> { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } <S2SV_StartBug> # line 2405 ""grammar.c"" <S2SV_EndBug> break ; case 53 : <S2SV_StartBug> # line 868 ""grammar.y"" <S2SV_EndBug> { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } <S2SV_StartBug> # line 2451 ""grammar.c"" <S2SV_EndBug> break ; case 54 : <S2SV_StartBug> # line 914 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , ""Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation."" , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2474 ""grammar.c"" <S2SV_EndBug> break ; case 55 : <S2SV_StartBug> # line 936 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2487 ""grammar.c"" <S2SV_EndBug> break ; case 56 : <S2SV_StartBug> # line 945 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2500 ""grammar.c"" <S2SV_EndBug> break ; case 57 : <S2SV_StartBug> # line 954 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""matches"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , ""matches"" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2519 ""grammar.c"" <S2SV_EndBug> break ; case 58 : <S2SV_StartBug> # line 969 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2535 ""grammar.c"" <S2SV_EndBug> break ; case 59 : <S2SV_StartBug> # line 981 ""grammar.y"" <S2SV_EndBug> { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2553 ""grammar.c"" <S2SV_EndBug> break ; case 60 : <S2SV_StartBug> # line 995 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""at"" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2570 ""grammar.c"" <S2SV_EndBug> break ; case 61 : <S2SV_StartBug> # line 1008 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2585 ""grammar.c"" <S2SV_EndBug> break ; case 62 : <S2SV_StartBug> # line 1019 ""grammar.y"" <S2SV_EndBug> { if ( compiler -> loop_depth > 0 ) { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } <S2SV_StartBug> } <S2SV_EndBug> # line 2597 ""grammar.c"" break ; case 63 : <S2SV_StartBug> # line 1027 ""grammar.y"" <S2SV_EndBug> { int var_index ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2631 ""grammar.c"" <S2SV_EndBug> break ; case 64 : <S2SV_StartBug> # line 1057 ""grammar.y"" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2670 ""grammar.c"" <S2SV_EndBug> break ; case 65 : <S2SV_StartBug> # line 1092 ""grammar.y"" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2753 ""grammar.c"" <S2SV_EndBug> break ; case 66 : <S2SV_StartBug> # line 1171 ""grammar.y"" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2787 ""grammar.c"" <S2SV_EndBug> break ; case 67 : <S2SV_StartBug> # line 1201 ""grammar.y"" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2840 ""grammar.c"" <S2SV_EndBug> break ; case 68 : <S2SV_StartBug> # line 1250 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2850 ""grammar.c"" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1256 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2860 ""grammar.c"" <S2SV_EndBug> break ; case 70 : <S2SV_StartBug> # line 1262 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2890 ""grammar.c"" <S2SV_EndBug> break ; case 71 : <S2SV_StartBug> # line 1288 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2930 ""grammar.c"" <S2SV_EndBug> break ; case 72 : <S2SV_StartBug> # line 1324 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2959 ""grammar.c"" <S2SV_EndBug> break ; case 73 : <S2SV_StartBug> # line 1349 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2999 ""grammar.c"" <S2SV_EndBug> break ; case 74 : <S2SV_StartBug> # line 1385 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3012 ""grammar.c"" <S2SV_EndBug> break ; case 75 : <S2SV_StartBug> # line 1394 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3025 ""grammar.c"" <S2SV_EndBug> break ; case 76 : <S2SV_StartBug> # line 1403 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3038 ""grammar.c"" <S2SV_EndBug> break ; case 77 : <S2SV_StartBug> # line 1412 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3051 ""grammar.c"" <S2SV_EndBug> break ; case 78 : <S2SV_StartBug> # line 1421 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""=="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3064 ""grammar.c"" <S2SV_EndBug> break ; case 79 : <S2SV_StartBug> # line 1430 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""!="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3077 ""grammar.c"" <S2SV_EndBug> break ; case 80 : <S2SV_StartBug> # line 1439 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3085 ""grammar.c"" <S2SV_EndBug> break ; case 81 : <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3093 ""grammar.c"" <S2SV_EndBug> break ; case 82 : <S2SV_StartBug> # line 1450 ""grammar.y"" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } <S2SV_StartBug> # line 3099 ""grammar.c"" <S2SV_EndBug> break ; case 83 : <S2SV_StartBug> # line 1451 ""grammar.y"" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_StartBug> # line 3105 ""grammar.c"" <S2SV_EndBug> break ; case 84 : <S2SV_StartBug> # line 1457 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>lower<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>upper<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3127 ""grammar.c"" <S2SV_EndBug> break ; case 85 : <S2SV_StartBug> # line 1479 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3143 ""grammar.c"" <S2SV_EndBug> break ; case 86 : <S2SV_StartBug> # line 1491 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3158 ""grammar.c"" <S2SV_EndBug> break ; case 87 : <S2SV_StartBug> # line 1506 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3167 ""grammar.c"" <S2SV_EndBug> break ; case 89 : <S2SV_StartBug> # line 1512 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , ""$*"" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3178 ""grammar.c"" <S2SV_EndBug> break ; case 92 : <S2SV_StartBug> # line 1529 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3189 ""grammar.c"" <S2SV_EndBug> break ; case 93 : <S2SV_StartBug> # line 1536 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3200 ""grammar.c"" <S2SV_EndBug> break ; case 95 : <S2SV_StartBug> # line 1548 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3208 ""grammar.c"" <S2SV_EndBug> break ; case 96 : <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } <S2SV_StartBug> # line 3216 ""grammar.c"" <S2SV_EndBug> break ; case 97 : <S2SV_StartBug> # line 1560 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3224 ""grammar.c"" <S2SV_EndBug> break ; case 98 : <S2SV_StartBug> # line 1564 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3238 ""grammar.c"" <S2SV_EndBug> break ; case 99 : <S2SV_StartBug> # line 1574 ""grammar.y"" <S2SV_EndBug> { yywarning ( yyscanner , ""Using<S2SV_blank>deprecated<S2SV_blank>\\""entrypoint\\""<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\""entry_point\\""<S2SV_blank>"" ""function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead."" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3256 ""grammar.c"" <S2SV_EndBug> break ; case 100 : <S2SV_StartBug> # line 1588 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3276 ""grammar.c"" <S2SV_EndBug> break ; case 101 : <S2SV_StartBug> # line 1604 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3290 ""grammar.c"" <S2SV_EndBug> break ; case 102 : <S2SV_StartBug> # line 1614 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3303 ""grammar.c"" <S2SV_EndBug> break ; case 103 : <S2SV_StartBug> # line 1623 ""grammar.y"" <S2SV_EndBug> { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3332 ""grammar.c"" <S2SV_EndBug> break ; case 104 : <S2SV_StartBug> # line 1648 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3348 ""grammar.c"" <S2SV_EndBug> break ; case 105 : <S2SV_StartBug> # line 1660 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3364 ""grammar.c"" <S2SV_EndBug> break ; case 106 : <S2SV_StartBug> # line 1672 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3384 ""grammar.c"" <S2SV_EndBug> break ; case 107 : <S2SV_StartBug> # line 1688 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3400 ""grammar.c"" <S2SV_EndBug> break ; case 108 : <S2SV_StartBug> # line 1700 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3420 ""grammar.c"" <S2SV_EndBug> break ; case 109 : <S2SV_StartBug> # line 1716 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , ""wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\""%s\\"""" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3469 ""grammar.c"" <S2SV_EndBug> break ; case 110 : <S2SV_StartBug> # line 1761 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3492 ""grammar.c"" <S2SV_EndBug> break ; case 111 : <S2SV_StartBug> # line 1780 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""+"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3514 ""grammar.c"" <S2SV_EndBug> break ; case 112 : <S2SV_StartBug> # line 1798 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""-"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3536 ""grammar.c"" <S2SV_EndBug> break ; case 113 : <S2SV_StartBug> # line 1816 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""*"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3558 ""grammar.c"" <S2SV_EndBug> break ; case 114 : <S2SV_StartBug> # line 1834 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""\\\\"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3588 ""grammar.c"" <S2SV_EndBug> break ; case 115 : <S2SV_StartBug> # line 1860 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3610 ""grammar.c"" <S2SV_EndBug> break ; case 116 : <S2SV_StartBug> # line 1878 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3624 ""grammar.c"" <S2SV_EndBug> break ; case 117 : <S2SV_StartBug> # line 1888 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3638 ""grammar.c"" <S2SV_EndBug> break ; case 118 : <S2SV_StartBug> # line 1898 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3652 ""grammar.c"" <S2SV_EndBug> break ; case 119 : <S2SV_StartBug> # line 1908 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""~"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3666 ""grammar.c"" <S2SV_EndBug> break ; case 120 : <S2SV_StartBug> # line 1918 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3680 ""grammar.c"" <S2SV_EndBug> break ; case 121 : <S2SV_StartBug> # line 1928 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> break ; case 122 : <S2SV_StartBug> # line 1938 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3702 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3706 ""grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }
","<S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2371 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 834 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2409 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 872 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 2455 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 918 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 2478 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 940 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2491 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 949 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2504 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 958 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2523 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 973 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2539 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 985 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2557 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 999 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2574 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1012 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2589 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1023 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> NULL ; } YYERROR ; } # line 2603 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1033 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2637 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1063 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2676 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1098 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2759 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1177 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2793 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1207 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2846 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1256 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> } # line 2856 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1262 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> } # line 2866 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1268 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2896 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1294 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2936 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1330 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2965 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1355 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 3005 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1391 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3018 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1400 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3031 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1409 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3044 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1418 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3057 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1427 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3070 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1436 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3083 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1445 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3091 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1449 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3099 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1456 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3105 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1457 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3111 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1463 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3133 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1485 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3149 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1497 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3164 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1512 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3173 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1518 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3184 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1535 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3195 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1542 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3206 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1554 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3214 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1558 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3222 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1566 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3230 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1570 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3244 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1580 <S2SV_ModEnd> ""grammar.y"" { yywarning <S2SV_ModStart> } # line 3262 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1594 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3282 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1610 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3296 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1620 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3309 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1629 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 3338 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1654 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3354 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1666 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3370 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1678 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3390 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1694 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3406 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1706 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3426 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1722 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3475 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1767 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3498 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1786 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3520 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1804 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3542 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1822 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3564 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1840 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3594 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1866 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3616 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1884 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3630 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1894 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3644 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1904 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3658 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1914 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3672 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1924 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3686 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1934 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3700 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1944 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3708 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> ; # line 3712 <S2SV_ModEnd> ""grammar.c"" default :
"
37,"CWE-362 static ssize_t n_tty_write ( struct tty_struct * tty , struct file * file , const unsigned char * buf , size_t nr ) { const unsigned char * b = buf ; DECLARE_WAITQUEUE ( wait , current ) ; int c ; ssize_t retval = 0 ; if ( L_TOSTOP ( tty ) && file -> f_op -> write != redirected_tty_write ) { retval = tty_check_change ( tty ) ; if ( retval ) return retval ; } down_read ( & tty -> termios_rwsem ) ; process_echoes ( tty ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; while ( 1 ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( signal_pending ( current ) ) { retval = - ERESTARTSYS ; break ; } if ( tty_hung_up_p ( file ) || ( tty -> link && ! tty -> link -> count ) ) { retval = - EIO ; break ; } if ( O_OPOST ( tty ) ) { while ( nr > 0 ) { ssize_t num = process_output_block ( tty , b , nr ) ; if ( num < 0 ) { if ( num == - EAGAIN ) break ; retval = num ; goto break_out ; } b += num ; nr -= num ; if ( nr == 0 ) break ; c = * b ; if ( process_output ( c , tty ) < 0 ) break ; b ++ ; nr -- ; } if ( tty -> ops -> flush_chars ) tty -> ops -> flush_chars ( tty ) ; } else { <S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> if ( c < 0 ) { retval = c ; goto break_out ; } if ( ! c ) break ; b += c ; nr -= c ; } } if ( ! nr ) break ; if ( file -> f_flags & O_NONBLOCK ) { retval = - EAGAIN ; break ; } up_read ( & tty -> termios_rwsem ) ; schedule ( ) ; down_read ( & tty -> termios_rwsem ) ; } break_out : __set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( b - buf != nr && tty -> fasync ) set_bit ( TTY_DO_WRITE_WAKEUP , & tty -> flags ) ; up_read ( & tty -> termios_rwsem ) ; return ( b - buf ) ? b - buf : retval ; }
","<S2SV_ModStart> } else { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> 0 ) { mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> b , nr ) ; mutex_unlock ( & ldata -> output_lock
"
38,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else
"
39,"CWE-362 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }
","<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
"
40,"CWE-264 static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; <S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> }
","<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
"
41,"CWE-119 void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; <S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }
","<S2SV_ModStart> ; int filt_mid <S2SV_ModEnd> ; int filt_low <S2SV_ModStart> -> frame_to_show ; memset <S2SV_ModEnd> ( ss_err ,
"
42,"CWE-119 void uwbd_stop ( struct uwb_rc * rc ) <S2SV_StartBug> { <S2SV_EndBug> kthread_stop ( rc -> uwbd . task ) ; uwbd_flush ( rc ) ; }
","<S2SV_ModStart> rc ) { if ( rc -> uwbd . task )
"
43,"CWE-416 static void * __ns_get_path ( struct path * path , struct ns_common * ns ) { struct vfsmount * mnt = nsfs_mnt ; struct qstr qname = { . name = """" , } ; struct dentry * dentry ; struct inode * inode ; unsigned long d ; rcu_read_lock ( ) ; d = atomic_long_read ( & ns -> stashed ) ; if ( ! d ) goto slow ; dentry = ( struct dentry * ) d ; if ( ! lockref_get_not_dead ( & dentry -> d_lockref ) ) goto slow ; rcu_read_unlock ( ) ; ns -> ops -> put ( ns ) ; got_it : path -> mnt = mntget ( mnt ) ; path -> dentry = dentry ; return NULL ; slow : rcu_read_unlock ( ) ; inode = new_inode_pseudo ( mnt -> mnt_sb ) ; if ( ! inode ) { ns -> ops -> put ( ns ) ; return ERR_PTR ( - ENOMEM ) ; } inode -> i_ino = ns -> inum ; inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; inode -> i_flags |= S_IMMUTABLE ; inode -> i_mode = S_IFREG | S_IRUGO ; inode -> i_fop = & ns_file_operations ; inode -> i_private = ns ; dentry = d_alloc_pseudo ( mnt -> mnt_sb , & qname ) ; if ( ! dentry ) { iput ( inode ) ; return ERR_PTR ( - ENOMEM ) ; } d_instantiate ( dentry , inode ) ; <S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ; if ( d ) { d_delete ( dentry ) ; dput ( dentry ) ; cpu_relax ( ) ; return ERR_PTR ( - EAGAIN ) ; } goto got_it ; }
","<S2SV_ModStart> ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
"
44,"CWE-264 static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
"
45,"CWE-400 static void xen_irq_lateeoi_locked ( struct irq_info * info ) { evtchn_port_t evtchn ; <S2SV_StartBug> evtchn = info -> evtchn ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VALID_EVTCHN ( evtchn ) ) <S2SV_EndBug> return ; unmask_evtchn ( evtchn ) ; }
","<S2SV_ModStart> evtchn_port_t evtchn ; unsigned int cpu ; <S2SV_ModStart> ( evtchn ) || ! list_empty ( & info -> eoi_list ) ) return ; cpu = info -> eoi_cpu ; if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) { lateeoi_list_add ( info ) ; return ; } info -> eoi_time = 0 <S2SV_ModEnd> ; unmask_evtchn (
"
46,"CWE-125 static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : cctx -> key_set = 0 ; cctx -> iv_set = 0 ; cctx -> L = 8 ; cctx -> M = 12 ; cctx -> tag_set = 0 ; cctx -> len_set = 0 ; cctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; cctx -> tls_aad_len = arg ; { uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; <S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return cctx -> M ; case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ; case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ; cctx -> L = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ; if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ; if ( ptr ) { cctx -> tag_set = 1 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; } cctx -> M = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ; if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ; cctx -> tag_set = 0 ; cctx -> iv_set = 0 ; cctx -> len_set = 0 ; return 1 ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; if ( cctx -> ccm . key ) { if ( cctx -> ccm . key != & cctx -> ks ) return 0 ; cctx_out -> ccm . key = & cctx_out -> ks ; } return 1 ; } default : return - 1 ; } }
","<S2SV_ModStart> 1 ] ; if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> -> M ; }
"
47,"CWE-20 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
"
48,"CWE-119 static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }
","<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree (
"
49,"CWE-000 WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>profile_idc"" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>u4_level_idc"" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>seq_parameter_set_id"" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; * ps_seq = ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; if ( NULL == ps_dec -> ps_cur_sps ) ps_dec -> ps_cur_sps = ps_seq ; ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_frame_num_minus4"" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_order_cnt_type"" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4"" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>delta_pic_order_always_zero_flag"" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_non_ref_pic"" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_top_to_bottom_field"" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle"" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_ref_frame"" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames"" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag"" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_width_in_mbs_minus1"" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_mbs_only_flag"" , u1_frm ) ; if ( ! u1_frm ) { u2_pic_ht <<= 1 ; ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>direct_8x8_inference_flag"" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_flag"" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_left_offset"" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_right_offset"" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_top_offset"" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_bottom_offset"" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>vui_parameters_present_flag"" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; WORD32 i4_cropped_ht , i4_cropped_wd ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } <S2SV_StartBug> ps_dec -> u2_disp_height = i4_cropped_ht ; <S2SV_EndBug> ps_dec -> u2_disp_width = i4_cropped_wd ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; return OK ; }
","<S2SV_ModStart> IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
"
50,"CWE-327 int wc_SignatureGenerate ( enum wc_HashType hash_type , enum wc_SignatureType sig_type , const byte * data , word32 data_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , WC_RNG * rng ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> word32 hash_len , hash_enc_len ; # ifdef WOLFSSL_SMALL_STACK byte * hash_data ; # else byte hash_data [ MAX_DER_DIGEST_SZ ] ; # endif if ( data == NULL || data_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) { return BAD_FUNC_ARG ; } if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ; return BAD_FUNC_ARG ; } ret = wc_HashGetDigestSize ( hash_type ) ; if ( ret < 0 ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len"" ) ; return ret ; } hash_enc_len = hash_len = ret ; # if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { hash_enc_len += MAX_DER_DIGEST_ASN_SZ ; } # endif # ifdef WOLFSSL_SMALL_STACK hash_data = ( byte * ) XMALLOC ( hash_enc_len , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; if ( hash_data == NULL ) { return MEMORY_E ; } # endif <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> if ( ret == 0 ) { if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { # if defined ( NO_RSA ) || defined ( NO_ASN ) || defined ( WOLFSSL_RSA_PUBLIC_ONLY ) ret = SIG_TYPE_E ; # else ret = wc_SignatureDerEncode ( hash_type , hash_data , hash_len , & hash_enc_len ) ; # endif } if ( ret == 0 ) { ret = wc_SignatureGenerateHash ( hash_type , sig_type , <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug> # ifdef WOLFSSL_SMALL_STACK XFREE ( hash_data , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; # endif return ret ; }
","<S2SV_ModStart> rng ) { return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> , data , <S2SV_ModStart> , data_len , sig , <S2SV_ModEnd> sig_len , key <S2SV_ModStart> key_len , rng , 1 <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
51,"CWE-20 static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , struct inode * inode , int flags ) { int symlink_len = 0 ; int cnt , sig ; unsigned int reloc_block ; struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; if ( flags & RR_REGARD_XA ) { rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : <S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block ; reloc = isofs_iget_reloc ( inode -> i_sb , reloc_block , 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
","<S2SV_ModStart> 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;
"
52,"CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->
"
53,"CWE-400 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_sc ( regs , opcode ) ; } return - 1 ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
"
54,"CWE-400 static int swp_handler ( struct pt_regs * regs , unsigned int instr ) { unsigned int address , destreg , data , type ; unsigned int res = 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> if ( current -> pid != previous_pid ) { pr_debug ( ""\\""%s\\""<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\n"" , current -> comm , ( unsigned long ) current -> pid ) ; previous_pid = current -> pid ; } address = regs -> uregs [ EXTRACT_REG_NUM ( instr , RN_OFFSET ) ] ; data = regs -> uregs [ EXTRACT_REG_NUM ( instr , RT2_OFFSET ) ] ; destreg = EXTRACT_REG_NUM ( instr , RT_OFFSET ) ; type = instr & TYPE_SWPB ; pr_debug ( ""addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\n"" , EXTRACT_REG_NUM ( instr , RN_OFFSET ) , address , destreg , EXTRACT_REG_NUM ( instr , RT2_OFFSET ) , data ) ; if ( ! access_ok ( VERIFY_WRITE , ( address & ~ 3 ) , 4 ) ) { pr_debug ( ""SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\n"" , ( void * ) address ) ; res = - EFAULT ; } else { res = emulate_swpX ( address , & data , type ) ; } if ( res == 0 ) { regs -> ARM_pc += 4 ; regs -> uregs [ destreg ] = data ; } else if ( res == - EFAULT ) { set_segfault ( regs , address ) ; } return 0 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs
"
55,"CWE-000 MagickExport const char * GetMagickFeatures ( void ) { return ""DPC"" <S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif <S2SV_StartBug> ; <S2SV_EndBug> }
","<S2SV_ModStart> if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> # endif # <S2SV_ModStart> MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif
"
56,"CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }
","<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;
"
57,"CWE-835 ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) { struct sock * sk = sock -> sk ; struct tcp_splice_state tss = { . pipe = pipe , . len = len , . flags = flags , } ; long timeo ; ssize_t spliced ; int ret ; sock_rps_record_flow ( sk ) ; if ( unlikely ( * ppos ) ) return - ESPIPE ; ret = spliced = 0 ; lock_sock ( sk ) ; timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; while ( tss . len ) { ret = __tcp_splice_read ( sk , & tss ) ; if ( ret < 0 ) break ; else if ( ! ret ) { if ( spliced ) break ; if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { ret = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) ret = - ENOTCONN ; break ; } if ( ! timeo ) { ret = - EAGAIN ; break ; } <S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> if ( signal_pending ( current ) ) { ret = sock_intr_errno ( timeo ) ; break ; } continue ; } tss . len -= ret ; spliced += ret ; if ( ! timeo ) break ; release_sock ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || signal_pending ( current ) ) break ; } release_sock ( sk ) ; if ( spliced ) return spliced ; return ret ; }
","<S2SV_ModStart> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
"
58,"CWE-000 static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
"
59,"CWE-119 int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }
","<S2SV_ModStart> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> iterator -> _rtheader + sizeof ( uint32_t )
"
60,"CWE-125 int obj2ast_withitem ( PyObject * obj , withitem_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty context_expr ; expr_ty optional_vars ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & context_expr , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_optional_vars ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_optional_vars ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & optional_vars , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { optional_vars = NULL ; } * out = withitem ( context_expr , optional_vars , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_context_expr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & context_expr , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; optional_vars = NULL ; } else { int res ; <S2SV_ModStart> tmp , & optional_vars <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out =
"
61,"CWE-20 static int ssl_scan_clienthello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int type ; int renegotiate_seen = 0 ; PACKET extensions ; * al = SSL_AD_DECODE_ERROR ; s -> servername_done = 0 ; s -> tlsext_status_type = - 1 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; s -> s3 -> alpn_selected_len = 0 ; OPENSSL_free ( s -> s3 -> alpn_proposed ) ; s -> s3 -> alpn_proposed = NULL ; s -> s3 -> alpn_proposed_len = 0 ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif # ifndef OPENSSL_NO_EC if ( s -> options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG ) ssl_check_for_safari ( s , pkt ) ; # endif OPENSSL_free ( s -> s3 -> tmp . peer_sigalgs ) ; s -> s3 -> tmp . peer_sigalgs = NULL ; <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> # ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ; s -> srp_ctx . login = NULL ; # endif s -> srtp_profile = NULL ; if ( PACKET_remaining ( pkt ) == 0 ) goto ri_check ; if ( ! PACKET_as_length_prefixed_2 ( pkt , & extensions ) ) return 0 ; if ( ! tls1_check_duplicate_extensions ( & extensions ) ) return 0 ; while ( PACKET_get_net_2 ( & extensions , & type ) ) { PACKET extension ; if ( ! PACKET_get_length_prefixed_2 ( & extensions , & extension ) ) return 0 ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { unsigned int servname_type ; PACKET sni , hostname ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) { return 0 ; } if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) { return 0 ; } if ( ! s -> hit ) { if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( PACKET_contains_zero_byte ( & hostname ) ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> servername_done = 1 ; } else { s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ; } } # ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) { PACKET srp_I ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ; if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ; if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { PACKET ec_point_format_list ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } else if ( type == TLSEXT_TYPE_elliptic_curves ) { PACKET elliptic_curve_list ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } else if ( type == TLSEXT_TYPE_signature_algorithms ) { PACKET supported_sig_algs ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) { return 0 ; } } } else if ( type == TLSEXT_TYPE_status_request ) { if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) { return 0 ; } # ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) { const unsigned char * ext_data ; PACKET responder_id_list , exts ; if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } while ( PACKET_remaining ( & responder_id_list ) > 0 ) { OCSP_RESPID * id ; PACKET responder_id ; const unsigned char * id_data ; if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) { return 0 ; } id_data = PACKET_data ( & responder_id ) ; id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ; if ( id == NULL ) return 0 ; if ( id_data != PACKET_end ( & responder_id ) ) { OCSP_RESPID_free ( id ) ; return 0 ; } if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) { OCSP_RESPID_free ( id ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ; if ( PACKET_remaining ( & exts ) > 0 ) { ext_data = PACKET_data ( & exts ) ; sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ; s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ; if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) { return 0 ; } } } else # endif { s -> tlsext_status_type = - 1 ; } } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) { if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ; } # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> else if ( ! s -> hit ) { if ( custom_ext_parse ( s , 1 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , al ) <= 0 ) return 0 ; } } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } ri_check : if ( ! renegotiate_seen && s -> renegotiate && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } return 1 ; }
","<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
"
62,"CWE-264 static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
"
63,"CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
"
64,"CWE-20 error_t udpProcessDatagram ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { error_t error ; uint_t i ; size_t length ; UdpHeader * header ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; if ( length < sizeof ( UdpHeader ) ) { MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_INVALID_HEADER ; } header = netBufferAt ( buffer , offset ) ; if ( header == NULL ) return ERROR_FAILURE ; TRACE_INFO ( ""UDP<S2SV_blank>datagram<S2SV_blank>received<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , length ) ; udpDumpHeader ( header ) ; if ( header -> checksum != 0x0000 || pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( ipCalcUpperLayerChecksumEx ( pseudoHeader -> data , pseudoHeader -> length , buffer , offset , length ) != 0x0000 ) { TRACE_WARNING ( ""Wrong<S2SV_blank>UDP<S2SV_blank>header<S2SV_blank>checksum!\\r\\n"" ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_WRONG_CHECKSUM ; } } for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_DGRAM ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> localPort == 0 || socket -> localPort != ntohs ( header -> destPort ) ) continue ; if ( socket -> remotePort != 0 && socket -> remotePort != ntohs ( header -> srcPort ) ) continue ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else # endif { continue ; } break ; } offset += sizeof ( UdpHeader ) ; length -= sizeof ( UdpHeader ) ; if ( i >= SOCKET_MAX_COUNT ) { error = udpInvokeRxCallback ( interface , pseudoHeader , header , buffer , offset , ancillary ) ; return error ; } if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= UDP_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = ntohs ( header -> srcPort ) ; <S2SV_EndBug> # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; } # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; } # endif queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; udpUpdateEvents ( socket ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER64 ( udpHCInDatagrams , 1 ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
"
65,"CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> flag & CL_UNPRIVILEGED <S2SV_ModStart> & CL_UNPRIVILEGED ) { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> ( mnt -> <S2SV_ModStart> mnt_flags & MNT_READONLY <S2SV_ModEnd> ) mnt -> <S2SV_ModStart> ; if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if (
"
66,"CWE-908 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( ""%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!"" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , ""desc"" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( ""format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g"" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( ""packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames"" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( ""channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d"" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , ""lpcm"" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point"" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""chan"" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( ""this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( ""channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( ""%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!"" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( ""chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d"" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( ""warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d"" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = ""12345678"" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\""%s\\""\\n"" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( ""problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)"" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> if ( ! desc_chunk || !
"
67,"CWE-000 static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; <S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) { data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; data_len = PAGE_ALIGN ( data_len ) ; BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ; } skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err , PAGE_ALLOC_COSTLY_ORDER ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( & scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> unix_state_unlock ( other ) ; sock_put ( other ) ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> if ( unix_peer ( sk ) == other ) { <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> err = - EAGAIN ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other ) ; sock_put ( other ) ; scm_destroy ( & scm ) ; return len ; out_unlock : <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( & scm ) ; return err ; }
","<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;
"
68,"CWE-787 static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , ""%d<S2SV_blank>bytes<S2SV_blank>left\\n"" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , ""chunk<S2SV_blank>too<S2SV_blank>big\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , ""png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n"" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ; if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : case MKTAG ( 't' , 'E' , 'X' , 't' ) : case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : case MKTAG ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto skip_tag ; } } switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) goto fail ; break ; case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) goto fail ; break ; case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) goto fail ; decode_next_dat = 1 ; break ; case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ! decode_next_dat ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_get_be32 ( & s -> gb ) ; length -= 4 ; case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) goto skip_tag ; if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) goto fail ; break ; case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : if ( decode_plte_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'R' , 'N' , 'S' ) : if ( decode_trns_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'E' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 'z' , 'T' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { int mode = bytestream2_get_byte ( & s -> gb ) ; AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; if ( ! stereo3d ) goto fail ; if ( mode == 0 || mode == 1 ) { stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; } else { av_log ( avctx , AV_LOG_WARNING , ""Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n"" , mode ) ; } bytestream2_skip ( & s -> gb , 4 ) ; break ; } case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) av_log ( avctx , AV_LOG_ERROR , ""IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n"" ) ; if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_skip ( & s -> gb , 4 ) ; goto exit_loop ; default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ; break ; } } exit_loop : if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( s -> bits_per_pixel <= 4 ) handle_small_bpp ( s , p ) ; if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; size_t raw_bpp = s -> bpp - byte_depth ; unsigned x , y ; <S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; for ( x = s -> width ; x > 0 ; -- x ) { uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; } else { memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; } } } } if ( s -> last_picture . f -> data [ 0 ] ) { if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( ""MPNG"" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format ) { if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) handle_p_frame_png ( s , p ) ; else if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) goto fail ; } } ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; av_frame_set_metadata ( p , metadata ) ; metadata = NULL ; return 0 ; fail : av_dict_free ( & metadata ) ; ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; return ret ; }
","<S2SV_ModStart> , y ; av_assert0 ( s -> bit_depth > 1 ) ;
"
69,"CWE-190 <S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> const char * cbuf = buf ; # ifdef __APPLE__ int flags = 0 ; # else int flags = MSG_NOSIGNAL ; # endif while ( len ) { <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> if ( sent == - 1 ) { if ( errno == EPIPE ) conn -> connected = 0 ; __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = send
"
70,"CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ; <S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , ""--version"" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( ""prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed"" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( ""--cap-add<S2SV_blank>in<S2SV_blank>setuid<S2SV_blank>mode<S2SV_blank>can<S2SV_blank>be<S2SV_blank>used<S2SV_blank>only<S2SV_blank>by<S2SV_blank>root"" ) ; if ( opt_userns_block_fd != - 1 && ! opt_unshare_user ) die ( ""--userns-block-fd<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( opt_userns_block_fd != - 1 && opt_info_fd == - 1 ) die ( ""--userns-block-fd<S2SV_blank>requires<S2SV_blank>--info-fd"" ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # ifdef ENABLE_REQUIRE_USERNS if ( is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # endif if ( opt_unshare_user_try && stat ( ""/proc/self/ns/user"" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( ""/sys/module/user_namespace/parameters/enable"" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , ""/sys/module/user_namespace/parameters/enable"" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( stat ( ""/proc/sys/user/max_user_namespaces"" , & sbuf ) == 0 ) { cleanup_free char * max_user_ns = NULL ; max_user_ns = load_file_at ( AT_FDCWD , ""/proc/sys/user/max_user_namespaces"" ) ; if ( max_user_ns != NULL && strcmp ( max_user_ns , ""0\\n"" ) == 0 ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( ""Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n"" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( ""Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( ""Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( ""Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts"" ) ; if ( opt_as_pid_1 && ! opt_unshare_pid ) die ( ""Specifying<S2SV_blank>--as-pid-1<S2SV_blank>requires<S2SV_blank>--unshare-pid"" ) ; if ( opt_as_pid_1 && lock_files != NULL ) die ( ""Specifying<S2SV_blank>--as-pid-1<S2SV_blank>and<S2SV_blank>--lock-file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>permitted"" ) ; proc_fd = open ( ""/proc"" , O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>open<S2SV_blank>/proc"" ) ; <S2SV_StartBug> base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; <S2SV_EndBug> if ( ensure_dir ( base_path , 0755 ) ) { free ( base_path ) ; base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ; if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ; } __debug__ ( ( ""creating<S2SV_blank>new<S2SV_blank>namespace\\n"" ) ) ; if ( opt_unshare_pid && ! opt_as_pid_1 ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) { if ( errno == ENOENT ) die ( ""Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it"" ) ; else die_with_error ( ""stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed"" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; if ( opt_json_status_fd != - 1 ) { int ret ; ret = pipe2 ( setup_finished_pipe , O_CLOEXEC ) ; if ( ret == - 1 ) die_with_error ( ""pipe2()"" ) ; } pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems."" ) ; else if ( errno == EPERM && ! is_privileged ) die ( ""No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'."" ) ; } die_with_error ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed"" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( FALSE ) ; handle_die_with_parent ( ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i\\n}\\n"" , pid ) ; dump_info ( opt_info_fd , output , TRUE ) ; close ( opt_info_fd ) ; } if ( opt_json_status_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{<S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i<S2SV_blank>}\\n"" , pid ) ; dump_info ( opt_json_status_fd , output , TRUE ) ; } if ( opt_userns_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_userns_block_fd , b , 1 ) ) ; close ( opt_userns_block_fd ) ; } val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; return monitor_child ( event_fd , pid , setup_finished_pipe [ 0 ] ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; if ( opt_json_status_fd != - 1 ) close ( opt_json_status_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net ) loopback_setup ( ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave"" ) ; if ( mount ( ""tmpfs"" , base_path , ""tmpfs"" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs"" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( ""chdir<S2SV_blank>base_path"" ) ; if ( mkdir ( ""newroot"" , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>newroot<S2SV_blank>failed"" ) ; if ( mount ( ""newroot"" , ""newroot"" , NULL , MS_MGC_VAL | MS_BIND | MS_REC , NULL ) < 0 ) die_with_error ( ""setting<S2SV_blank>up<S2SV_blank>newroot<S2SV_blank>bind"" ) ; if ( mkdir ( ""oldroot"" , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>oldroot<S2SV_blank>failed"" ) ; if ( pivot_root ( base_path , ""oldroot"" ) ) die_with_error ( ""pivot_root"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)"" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( ""Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket"" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper"" ) ; if ( child == 0 ) { drop_privs ( FALSE ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( ""Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket"" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } close_ops_fd ( ) ; if ( mount ( ""oldroot"" , ""oldroot"" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate"" ) ; if ( umount2 ( ""oldroot"" , MNT_DETACH ) ) die_with_error ( ""unmount<S2SV_blank>old<S2SV_blank>root"" ) ; { cleanup_fd int oldrootfd = open ( ""/"" , O_DIRECTORY | O_RDONLY ) ; if ( oldrootfd < 0 ) die_with_error ( ""can\'t<S2SV_blank>open<S2SV_blank>/"" ) ; if ( chdir ( ""/newroot"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/newroot"" ) ; if ( pivot_root ( ""."" , ""."" ) != 0 ) die_with_error ( ""pivot_root(/newroot)"" ) ; if ( fchdir ( oldrootfd ) < 0 ) die_with_error ( ""fchdir<S2SV_blank>to<S2SV_blank>oldroot"" ) ; if ( umount2 ( ""."" , MNT_DETACH ) < 0 ) die_with_error ( ""umount<S2SV_blank>old<S2SV_blank>root"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/"" ) ; } if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) && opt_userns_block_fd == - 1 ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( ""unshare<S2SV_blank>user<S2SV_blank>ns"" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } drop_privs ( ! is_privileged ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_block_fd , b , 1 ) ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( ""Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data"" ) ; if ( seccomp_len % 8 != 0 ) die ( ""Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8"" ) ; seccomp_prog . len = seccomp_len / 8 ; seccomp_prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; } umask ( old_umask ) ; new_cwd = ""/"" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s"" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( ""HOME"" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( ""PWD"" , new_cwd , 1 ) ; free ( old_cwd ) ; if ( opt_new_session && setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ; __debug__ ( ( ""forking<S2SV_blank>for<S2SV_blank>child\\n"" ) ) ; if ( ! opt_as_pid_1 && ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1"" ) ; if ( pid != 0 ) { drop_all_caps ( FALSE ) ; { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid , seccomp_data != NULL ? & seccomp_prog : NULL ) ; } } __debug__ ( ( ""launch<S2SV_blank>executable<S2SV_blank>%s\\n"" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( ! opt_as_pid_1 ) { if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; } unblock_sigchild ( ) ; handle_die_with_parent ( ) ; if ( ! is_privileged ) set_ambient_capabilities ( ) ; if ( seccomp_data != NULL && prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & seccomp_prog ) != 0 ) die_with_error ( ""prctl(PR_SET_SECCOMP)"" ) ; if ( setup_finished_pipe [ 1 ] != - 1 ) { char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; } if ( execvp ( argv [ 0 ] , argv ) == - 1 ) { if ( setup_finished_pipe [ 1 ] != - 1 ) { int saved_errno = errno ; char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; errno = saved_errno ; } die_with_error ( ""execvp<S2SV_blank>%s"" , argv [ 0 ] ) ; } return 0 ; }
","<S2SV_ModStart> mode_t old_umask ; const <S2SV_ModEnd> char * base_path <S2SV_ModStart> ; base_path = ""/tmp"" ; <S2SV_ModEnd> __debug__ ( (
"
71,"CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
","<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
"
72,"CWE-119 static EAS_RESULT PushcdlStack ( EAS_U32 * pStack , EAS_INT * pStackPtr , EAS_U32 value ) { <S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> * pStackPtr = * pStackPtr + 1 ; pStack [ * pStackPtr ] = value ; return EAS_SUCCESS ; }
","<S2SV_ModStart> * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ; <S2SV_ModEnd> return EAS_ERROR_FILE_FORMAT ; <S2SV_ModStart> return EAS_ERROR_FILE_FORMAT ; }
"
73,"CWE-119 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }
","<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
"
74,"CWE-119 static int fwnet_incoming_packet ( struct fwnet_device * dev , __be32 * buf , int len , int source_node_id , int generation , bool is_broadcast ) { struct sk_buff * skb ; struct net_device * net = dev -> netdev ; struct rfc2734_header hdr ; unsigned lf ; unsigned long flags ; struct fwnet_peer * peer ; struct fwnet_partial_datagram * pd ; int fg_off ; int dg_size ; u16 datagram_label ; int retval ; u16 ether_type ; <S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> lf = fwnet_get_hdr_lf ( & hdr ) ; if ( lf == RFC2374_HDR_UNFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; buf ++ ; len -= RFC2374_UNFRAG_HDR_SIZE ; skb = dev_alloc_skb ( len + LL_RESERVED_SPACE ( net ) ) ; if ( unlikely ( ! skb ) ) { net -> stats . rx_dropped ++ ; return - ENOMEM ; } skb_reserve ( skb , LL_RESERVED_SPACE ( net ) ) ; memcpy ( skb_put ( skb , len ) , buf , len ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , is_broadcast , ether_type ) ; } <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> buf += 2 ; len -= RFC2374_FRAG_HDR_SIZE ; if ( lf == RFC2374_HDR_FIRSTFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; fg_off = 0 ; } else { ether_type = 0 ; fg_off = fwnet_get_hdr_fg_off ( & hdr ) ; } datagram_label = fwnet_get_hdr_dgl ( & hdr ) ; dg_size = fwnet_get_hdr_dg_size ( & hdr ) ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ; if ( ! peer ) { retval = - ENOENT ; goto fail ; } pd = fwnet_pd_find ( peer , datagram_label ) ; if ( pd == NULL ) { while ( peer -> pdg_size >= FWNET_MAX_FRAGMENTS ) { fwnet_pd_delete ( list_first_entry ( & peer -> pd_list , struct fwnet_partial_datagram , pd_link ) ) ; peer -> pdg_size -- ; } pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { retval = - ENOMEM ; goto fail ; } peer -> pdg_size ++ ; } else { if ( fwnet_frag_overlap ( pd , fg_off , len ) || pd -> datagram_size != dg_size ) { fwnet_pd_delete ( pd ) ; pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } else { if ( ! fwnet_pd_update ( peer , pd , buf , fg_off , len ) ) { fwnet_pd_delete ( pd ) ; peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } } if ( lf == RFC2374_HDR_FIRSTFRAG ) pd -> ether_type = ether_type ; if ( fwnet_pd_is_complete ( pd ) ) { ether_type = pd -> ether_type ; peer -> pdg_size -- ; skb = skb_get ( pd -> skb ) ; fwnet_pd_delete ( pd ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , false , ether_type ) ; } retval = 0 ; fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ; return retval ; }
","<S2SV_ModStart> u16 ether_type ; if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> ) ; } if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> hdr ) ; if ( fg_off + len > dg_size ) return 0 ;
"
75,"CWE-189 native_handle_t * native_handle_create ( int numFds , int numInts ) { <S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> if ( h ) { h -> version = sizeof ( native_handle_t ) ; h -> numFds = numFds ; h -> numInts = numInts ; } return h ; }
","<S2SV_ModStart> numInts ) { if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = <S2SV_ModEnd> sizeof ( native_handle_t <S2SV_ModStart> native_handle_t ) + ( <S2SV_ModStart> + numInts ) ) ; native_handle_t * h = malloc ( mallocSize
"
76,"CWE-119 static int dalvik_disassemble ( RAsm * a , RAsmOp * op , const ut8 * buf , int len ) { int vA , vB , vC , payload = 0 , i = ( int ) buf [ 0 ] ; int size = dalvik_opcodes [ i ] . len ; char str [ 1024 ] , * strasm ; ut64 offset ; const char * flag_str ; op -> buf_asm [ 0 ] = 0 ; if ( buf [ 0 ] == 0x00 ) { switch ( buf [ 1 ] ) { case 0x01 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; int first_key = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> size = 8 ; payload = 2 * ( array_size * 2 ) ; len = 0 ; } break ; case 0x02 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> size = 4 ; payload = 2 * ( array_size * 4 ) ; len = 0 ; } break ; case 0x03 : if ( len > 7 ) { unsigned short elem_width = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; unsigned int array_size = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""fill-array-data-payload<S2SV_blank>%d,<S2SV_blank>%d"" , elem_width , array_size ) ; payload = 2 * ( ( array_size * elem_width + 1 ) / 2 ) ; } size = 8 ; len = 0 ; break ; default : break ; } } strasm = NULL ; if ( size <= len ) { strncpy ( op -> buf_asm , dalvik_opcodes [ i ] . name , sizeof ( op -> buf_asm ) - 1 ) ; strasm = strdup ( op -> buf_asm ) ; size = dalvik_opcodes [ i ] . len ; switch ( dalvik_opcodes [ i ] . fmt ) { case fmtop : break ; case fmtopvAvB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAAAvBBBB : vA = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vB = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAA : vA = ( int ) buf [ 1 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAcB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB : vA = ( int ) buf [ 1 ] ; { short sB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; } break ; case fmtopvAAcBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ; if ( buf [ 0 ] == 0x17 ) { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x"" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08x"" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB0000 : vA = ( int ) buf [ 1 ] ; vB = 0 | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; if ( buf [ 0 ] == 0x19 ) { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x"" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08x"" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBBBBBBBBBBBBBB : vA = ( int ) buf [ 1 ] ; # define llint long long int llint lB = ( llint ) buf [ 2 ] | ( ( llint ) buf [ 3 ] << 8 ) | ( ( llint ) buf [ 4 ] << 16 ) | ( ( llint ) buf [ 5 ] << 24 ) | ( ( llint ) buf [ 6 ] << 32 ) | ( ( llint ) buf [ 7 ] << 40 ) | ( ( llint ) buf [ 8 ] << 48 ) | ( ( llint ) buf [ 9 ] << 56 ) ; # undef llint <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBvCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBcCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBcCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAA : vA = ( char ) buf [ 1 ] ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAA : vA = ( short ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , a -> pc + ( vB * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAAAAAA : vA = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBpCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , a -> pc + vB ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineI : vA = ( int ) ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; * str = 0 ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineIR : case fmtoptinvokeVSR : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeVS : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> break ; } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x1a ) { offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } } else if ( buf [ 0 ] == 0x1c || buf [ 0 ] == 0x1f || buf [ 0 ] == 0x22 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptopvAvBoCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 'o' , vC ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 't' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBtCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x20 || buf [ 0 ] == 0x23 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 5 ] | ( buf [ 4 ] << 8 ) | ( buf [ 3 ] << 16 ) | ( buf [ 2 ] << 24 ) ) ; offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvCCCCmBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; if ( buf [ 0 ] == 0x25 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvXtBBBB : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; case 5 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; if ( buf [ 0 ] == 0x24 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeI : case fmtoptinvokeIR : case fmt00 : default : strcpy ( op -> buf_asm , ""invalid<S2SV_blank>"" ) ; free ( strasm ) ; strasm = NULL ; size = 2 ; } if ( strasm ) { strncpy ( op -> buf_asm , strasm , sizeof ( op -> buf_asm ) - 1 ) ; op -> buf_asm [ sizeof ( op -> buf_asm ) - 1 ] = 0 ; } else { strcpy ( op -> buf_asm , ""invalid"" ) ; } } else if ( len > 0 ) { strcpy ( op -> buf_asm , ""invalid<S2SV_blank>"" ) ; op -> size = len ; size = len ; } op -> payload = payload ; size += payload ; op -> size = size ; free ( strasm ) ; return size ; }
","<S2SV_ModStart> 24 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> -> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModStart> 8 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> op -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 1 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i"" , <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , <S2SV_ModStart> # undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>[%04x]"" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>[%04x]"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>method+%i"" ,
"
77,"CWE-000 static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }
","<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
"
78,"CWE-119 char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
"
79,"CWE-119 <S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fadst16_8col ( in0 ) ; fadst16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
80,"CWE-119 int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ; # if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; } # else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; # endif if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> act_size > MT_PACKET_LEN <S2SV_ModStart> act_size > MT_PACKET_LEN - packet -> size
"
81,"CWE-119 void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }
","<S2SV_ModStart> common ) ; memcpy <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & cpi
"
82,"CWE-189 static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , ""copy_from_user<S2SV_blank>error\\n"" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n"" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
","<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending
"
83,"CWE-200 inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'"" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = ""0.6"" , * google_reqId = ""0"" , * google_sig = ""0"" , * google_out = ""json"" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , ""?&"" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , ""="" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'"" , w -> id , name , value ) ; if ( ! strcmp ( name , ""chart"" ) ) chart = value ; else if ( ! strcmp ( name , ""dimension"" ) || ! strcmp ( name , ""dim"" ) || ! strcmp ( name , ""dimensions"" ) || ! strcmp ( name , ""dims"" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , ""|"" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , ""after"" ) ) after_str = value ; else if ( ! strcmp ( name , ""before"" ) ) before_str = value ; else if ( ! strcmp ( name , ""points"" ) ) points_str = value ; else if ( ! strcmp ( name , ""gtime"" ) ) group_time_str = value ; else if ( ! strcmp ( name , ""group"" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , ""format"" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , ""options"" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , ""callback"" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , ""filename"" ) ) { outFileName = value ; } else if ( ! strcmp ( name , ""tqx"" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , "";"" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , "":"" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , ""version"" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , ""reqId"" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , ""sig"" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , ""out"" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , ""responseHandler"" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , ""outFileName"" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , ""Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>"" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'"" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : """" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , outFileName ) ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'"" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""google.visualization.Query.setResponse"" ; debug ( D_WEB_CLIENT_ACCESS , ""%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'"" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:"" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""callback"" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , ""("" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , ""});"" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});"" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , "");"" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }
","<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
"
84,"CWE-665 int main ( int argc , char * * argv ) { int result ; int error = FALSE ; int display_license = FALSE ; int display_help = FALSE ; int c = 0 ; struct tm * tm , tm_s ; time_t now ; char datestring [ 256 ] ; nagios_macros * mac ; const char * worker_socket = NULL ; int i ; # ifdef HAVE_SIGACTION struct sigaction sig_action ; # endif # ifdef HAVE_GETOPT_H int option_index = 0 ; static struct option long_options [ ] = { { ""help"" , no_argument , 0 , 'h' } , { ""version"" , no_argument , 0 , 'V' } , { ""license"" , no_argument , 0 , 'V' } , { ""verify-config"" , no_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""test-scheduling"" , no_argument , 0 , 's' } , { ""precache-objects"" , no_argument , 0 , 'p' } , { ""use-precached-objects"" , no_argument , 0 , 'u' } , { ""enable-timing-point"" , no_argument , 0 , 'T' } , { ""worker"" , required_argument , 0 , 'W' } , { 0 , 0 , 0 , 0 } } ; # define getopt ( argc , argv , o ) getopt_long ( argc , argv , o , long_options , & option_index ) # endif memset ( & loadctl , 0 , sizeof ( loadctl ) ) ; mac = get_global_macros ( ) ; if ( argc < 2 ) error = TRUE ; while ( 1 ) { c = getopt ( argc , argv , ""+hVvdspuxTW"" ) ; if ( c == - 1 || c == EOF ) break ; switch ( c ) { case '?' : case 'h' : display_help = TRUE ; break ; case 'V' : display_license = TRUE ; break ; case 'v' : verify_config ++ ; break ; case 's' : test_scheduling = TRUE ; break ; case 'd' : daemon_mode = TRUE ; break ; case 'p' : precache_objects = TRUE ; break ; case 'u' : use_precached_objects = TRUE ; break ; case 'T' : enable_timing_point = TRUE ; break ; case 'W' : worker_socket = optarg ; break ; case 'x' : printf ( ""Warning:<S2SV_blank>-x<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>and<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed\\n"" ) ; break ; default : break ; } } # ifdef DEBUG_MEMORY mtrace ( ) ; # endif if ( worker_socket ) { exit ( nagios_core_worker ( worker_socket ) ) ; } init_main_cfg_vars ( 1 ) ; init_shared_cfg_vars ( 1 ) ; if ( daemon_mode == FALSE ) { printf ( ""\\nNagios<S2SV_blank>Core<S2SV_blank>%s\\n"" , PROGRAM_VERSION ) ; printf ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2009-present<S2SV_blank>Nagios<S2SV_blank>Core<S2SV_blank>Development<S2SV_blank>Team<S2SV_blank>and<S2SV_blank>Community<S2SV_blank>Contributors\\n"" ) ; printf ( ""Copyright<S2SV_blank>(c)<S2SV_blank>1999-2009<S2SV_blank>Ethan<S2SV_blank>Galstad\\n"" ) ; printf ( ""Last<S2SV_blank>Modified:<S2SV_blank>%s\\n"" , PROGRAM_MODIFICATION_DATE ) ; printf ( ""License:<S2SV_blank>GPL\\n\\n"" ) ; printf ( ""Website:<S2SV_blank>https://www.nagios.org\\n"" ) ; } if ( display_license == TRUE ) { printf ( ""This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\n"" ) ; printf ( ""it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>version<S2SV_blank>2<S2SV_blank>as\\n"" ) ; printf ( ""published<S2SV_blank>by<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software<S2SV_blank>Foundation.\\n\\n"" ) ; printf ( ""This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>distributed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hope<S2SV_blank>that<S2SV_blank>it<S2SV_blank>will<S2SV_blank>be<S2SV_blank>useful,\\n"" ) ; printf ( ""but<S2SV_blank>WITHOUT<S2SV_blank>ANY<S2SV_blank>WARRANTY;<S2SV_blank>without<S2SV_blank>even<S2SV_blank>the<S2SV_blank>implied<S2SV_blank>warranty<S2SV_blank>of\\n"" ) ; printf ( ""MERCHANTABILITY<S2SV_blank>or<S2SV_blank>FITNESS<S2SV_blank>FOR<S2SV_blank>A<S2SV_blank>PARTICULAR<S2SV_blank>PURPOSE.<S2SV_blank><S2SV_blank>See<S2SV_blank>the\\n"" ) ; printf ( ""GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>for<S2SV_blank>more<S2SV_blank>details.\\n\\n"" ) ; printf ( ""You<S2SV_blank>should<S2SV_blank>have<S2SV_blank>received<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License\\n"" ) ; printf ( ""along<S2SV_blank>with<S2SV_blank>this<S2SV_blank>program;<S2SV_blank>if<S2SV_blank>not,<S2SV_blank>write<S2SV_blank>to<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software\\n"" ) ; printf ( ""Foundation,<S2SV_blank>Inc.,<S2SV_blank>675<S2SV_blank>Mass<S2SV_blank>Ave,<S2SV_blank>Cambridge,<S2SV_blank>MA<S2SV_blank>02139,<S2SV_blank>USA.\\n\\n"" ) ; exit ( OK ) ; } if ( optind >= argc ) error = TRUE ; if ( error == TRUE || display_help == TRUE ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><main_config_file>\\n"" , argv [ 0 ] ) ; printf ( ""\\n"" ) ; printf ( ""Options:\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--verify-config<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>all<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>(-v<S2SV_blank>-v<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info)\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--test-scheduling<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Shows<S2SV_blank>projected/recommended<S2SV_blank>check<S2SV_blank>scheduling<S2SV_blank>and<S2SV_blank>other\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>diagnostic<S2SV_blank>info<S2SV_blank>based<S2SV_blank>on<S2SV_blank>the<S2SV_blank>current<S2SV_blank>configuration<S2SV_blank>files.\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-T,<S2SV_blank>--enable-timing-point<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>timed<S2SV_blank>commentary<S2SV_blank>on<S2SV_blank>initialization\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--dont-verify-paths<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Deprecated<S2SV_blank>(Don\'t<S2SV_blank>check<S2SV_blank>for<S2SV_blank>circular<S2SV_blank>object<S2SV_blank>paths)\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--precache-objects<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Precache<S2SV_blank>object<S2SV_blank>configuration\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--use-precached-objects<S2SV_blank><S2SV_blank>Use<S2SV_blank>precached<S2SV_blank>object<S2SV_blank>config<S2SV_blank>file\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--daemon<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Starts<S2SV_blank>Nagios<S2SV_blank>in<S2SV_blank>daemon<S2SV_blank>mode,<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>as<S2SV_blank>a<S2SV_blank>foreground<S2SV_blank>process\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-W,<S2SV_blank>--worker<S2SV_blank>/path/to/socket<S2SV_blank>Act<S2SV_blank>as<S2SV_blank>a<S2SV_blank>worker<S2SV_blank>for<S2SV_blank>an<S2SV_blank>already<S2SV_blank>running<S2SV_blank>daemon\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""Visit<S2SV_blank>the<S2SV_blank>Nagios<S2SV_blank>website<S2SV_blank>at<S2SV_blank>https://www.nagios.org/<S2SV_blank>for<S2SV_blank>bug<S2SV_blank>fixes,<S2SV_blank>new\\n"" ) ; printf ( ""releases,<S2SV_blank>online<S2SV_blank>documentation,<S2SV_blank>FAQs,<S2SV_blank>information<S2SV_blank>on<S2SV_blank>subscribing<S2SV_blank>to\\n"" ) ; printf ( ""the<S2SV_blank>mailing<S2SV_blank>lists,<S2SV_blank>and<S2SV_blank>commercial<S2SV_blank>support<S2SV_blank>options<S2SV_blank>for<S2SV_blank>Nagios.\\n"" ) ; printf ( ""\\n"" ) ; exit ( ERROR ) ; } config_file = nspath_absolute ( argv [ optind ] , NULL ) ; if ( config_file == NULL ) { printf ( ""Error<S2SV_blank>allocating<S2SV_blank>memory.\\n"" ) ; exit ( ERROR ) ; } config_file_dir = nspath_absolute_dirname ( config_file , NULL ) ; # ifdef HAVE_SIGACTION sig_action . sa_sigaction = NULL ; sig_action . sa_handler = handle_sigxfsz ; sigfillset ( & sig_action . sa_mask ) ; sig_action . sa_flags = SA_NODEFER | SA_RESTART ; sigaction ( SIGXFSZ , & sig_action , NULL ) ; # else signal ( SIGXFSZ , handle_sigxfsz ) ; # endif if ( verify_config || test_scheduling || precache_objects ) { reset_variables ( ) ; set_loadctl_defaults ( ) ; if ( verify_config ) printf ( ""Reading<S2SV_blank>configuration<S2SV_blank>data...\\n"" ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file!\\n\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>okay...\\n"" ) ; if ( ( result = drop_privileges ( nagios_user , nagios_group ) ) == ERROR ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ; exit ( EXIT_FAILURE ) ; } if ( ! verify_config && test_configured_paths ( ) == ERROR ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>path<S2SV_blank>problems<S2SV_blank>detected.<S2SV_blank>Aborting.\\n"" ) ; exit ( EXIT_FAILURE ) ; } result = read_all_object_data ( config_file ) ; if ( result != OK ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files!\\n\\n"" ) ; if ( ! strstr ( config_file , ""nagios.cfg"" ) ) { printf ( ""\\n***><S2SV_blank>The<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>looks<S2SV_blank>suspicious...\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>are<S2SV_blank>specifying<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>MAIN<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>on\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>and<S2SV_blank>not<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>another<S2SV_blank>configuration<S2SV_blank>file.<S2SV_blank><S2SV_blank>The\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>typically<S2SV_blank>\'%s\'\\n"" , DEFAULT_CONFIG_FILE ) ; } printf ( ""\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>processing<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files...\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files<S2SV_blank>okay...\\n\\n"" ) ; printf ( ""Running<S2SV_blank>pre-flight<S2SV_blank>check<S2SV_blank>on<S2SV_blank>configuration<S2SV_blank>data...\\n\\n"" ) ; } result = pre_flight_check ( ) ; if ( result != OK ) { printf ( ""\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check...\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( ""\\nThings<S2SV_blank>look<S2SV_blank>okay<S2SV_blank>-<S2SV_blank>No<S2SV_blank>serious<S2SV_blank>problems<S2SV_blank>were<S2SV_blank>detected<S2SV_blank>during<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check\\n"" ) ; } if ( test_scheduling == TRUE ) { init_event_queue ( ) ; timing_point ( ""Done<S2SV_blank>initializing<S2SV_blank>event<S2SV_blank>queue\\n"" ) ; initialize_retention_data ( config_file ) ; read_initial_state_information ( ) ; timing_point ( ""Retention<S2SV_blank>data<S2SV_blank>and<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>parsed\\n"" ) ; init_timing_loop ( ) ; timing_point ( ""Timing<S2SV_blank>loop<S2SV_blank>initialized\\n"" ) ; display_scheduling_info ( ) ; } if ( precache_objects ) { result = fcache_objects ( object_precache_file ) ; timing_point ( ""Done<S2SV_blank>precaching<S2SV_blank>objects\\n"" ) ; if ( result == OK ) { printf ( ""Object<S2SV_blank>precache<S2SV_blank>file<S2SV_blank>created:\\n%s\\n"" , object_precache_file ) ; } else { printf ( ""Failed<S2SV_blank>to<S2SV_blank>precache<S2SV_blank>objects<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s\\n"" , object_precache_file , strerror ( errno ) ) ; } } cleanup ( ) ; timing_point ( ""Exiting\\n"" ) ; neb_free_module_list ( ) ; free ( config_file_dir ) ; free ( config_file ) ; exit ( result ) ; } else { if ( strchr ( argv [ 0 ] , '/' ) ) nagios_binary_path = nspath_absolute ( argv [ 0 ] , NULL ) ; else nagios_binary_path = strdup ( argv [ 0 ] ) ; if ( ! nagios_binary_path ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>nagios_binary_path\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! ( nagios_iobs = iobroker_create ( ) ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>IO<S2SV_blank>broker<S2SV_blank>set:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } do { wproc_num_workers_spawned = wproc_num_workers_online = 0 ; caught_signal = sigshutdown = FALSE ; sig_id = 0 ; reset_variables ( ) ; timing_point ( ""Variables<S2SV_blank>reset\\n"" ) ; nagios_pid = ( int ) getpid ( ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { logit ( NSLOG_CONFIG_ERROR , TRUE , ""Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>process<S2SV_blank>config<S2SV_blank>file<S2SV_blank>\'%s\'.<S2SV_blank>Aborting\\n"" , config_file ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""Main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>read\\n"" ) ; program_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_PROCESSSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_PROCESSSTARTTIME ] , ""%llu"" , ( unsigned long long ) program_start ) ; <S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ; cleanup ( ) ; exit ( ERROR ) ; } if ( test_path_access ( nagios_binary_path , X_OK ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>access()<S2SV_blank>%s:<S2SV_blank>%s\\n"" , nagios_binary_path , strerror ( errno ) ) ; logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Spawning<S2SV_blank>workers<S2SV_blank>will<S2SV_blank>be<S2SV_blank>impossible.<S2SV_blank>Aborting.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( test_configured_paths ( ) == ERROR ) { <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> } if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } logit ( NSLOG_PROCESS_INFO , TRUE , ""Nagios<S2SV_blank>%s<S2SV_blank>starting...<S2SV_blank>(PID=%d)\\n"" , PROGRAM_VERSION , ( int ) getpid ( ) ) ; now = time ( NULL ) ; tm = localtime_r ( & now , & tm_s ) ; strftime ( datestring , sizeof ( datestring ) , ""%a<S2SV_blank>%b<S2SV_blank>%d<S2SV_blank>%H:%M:%S<S2SV_blank>%Z<S2SV_blank>%Y"" , tm ) ; logit ( NSLOG_PROCESS_INFO , TRUE , ""Local<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s"" , datestring ) ; write_log_file_info ( NULL ) ; open_debug_log ( ) ; # ifdef USE_EVENT_BROKER neb_init_modules ( ) ; neb_init_callback_list ( ) ; # endif timing_point ( ""NEB<S2SV_blank>module<S2SV_blank>API<S2SV_blank>initialized\\n"" ) ; setup_sighandler ( ) ; if ( qh_init ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) != OK ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>query<S2SV_blank>handler.<S2SV_blank>Aborting\\n"" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""Query<S2SV_blank>handler<S2SV_blank>initialized\\n"" ) ; nerd_init ( ) ; timing_point ( ""NERD<S2SV_blank>initialized\\n"" ) ; if ( init_workers ( num_check_workers ) < 0 ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>workers.<S2SV_blank>Aborting\\n"" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""%u<S2SV_blank>workers<S2SV_blank>spawned\\n"" , wproc_num_workers_spawned ) ; i = 0 ; while ( i < 50 && wproc_num_workers_online < wproc_num_workers_spawned ) { iobroker_poll ( nagios_iobs , 50 ) ; i ++ ; } timing_point ( ""%u<S2SV_blank>workers<S2SV_blank>connected\\n"" , wproc_num_workers_online ) ; set_loadctl_defaults ( ) ; # ifdef USE_EVENT_BROKER if ( neb_load_all_modules ( ) != OK ) { logit ( NSLOG_CONFIG_ERROR , ERROR , ""Error:<S2SV_blank>Module<S2SV_blank>loading<S2SV_blank>failed.<S2SV_blank>Aborting.\\n"" ) ; if ( daemon_dumps_core ) neb_unload_all_modules ( NEBMODULE_FORCE_UNLOAD , NEBMODULE_NEB_SHUTDOWN ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""Modules<S2SV_blank>loaded\\n"" ) ; broker_program_state ( NEBTYPE_PROCESS_PRELAUNCH , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; timing_point ( ""First<S2SV_blank>callback<S2SV_blank>made\\n"" ) ; # endif if ( result == OK ) result = read_all_object_data ( config_file ) ; if ( result != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>files.<S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; else { if ( ( result = pre_flight_check ( ) ) != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check.<S2SV_blank><S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\\n"" , ( int ) getpid ( ) ) ; } if ( result != OK ) { if ( sigrestart == TRUE ) { cleanup_status_data ( TRUE ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_PROCESS_INITIATED , NEBATTR_SHUTDOWN_ABNORMAL , NULL ) ; # endif cleanup ( ) ; exit ( ERROR ) ; } timing_point ( ""Object<S2SV_blank>configuration<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>understood\\n"" ) ; fcache_objects ( object_cache_file ) ; timing_point ( ""Objects<S2SV_blank>cached\\n"" ) ; init_event_queue ( ) ; timing_point ( ""Event<S2SV_blank>queue<S2SV_blank>initialized\\n"" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_START , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif if ( sigrestart == FALSE ) { initialize_status_data ( config_file ) ; timing_point ( ""Status<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; } initialize_downtime_data ( ) ; timing_point ( ""Downtime<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; initialize_retention_data ( config_file ) ; timing_point ( ""Retention<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; read_initial_state_information ( ) ; timing_point ( ""Initial<S2SV_blank>state<S2SV_blank>information<S2SV_blank>read\\n"" ) ; initialize_comment_data ( ) ; timing_point ( ""Comment<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; initialize_performance_data ( config_file ) ; timing_point ( ""Performance<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; init_timing_loop ( ) ; timing_point ( ""Event<S2SV_blank>timing<S2SV_blank>loop<S2SV_blank>initialized\\n"" ) ; init_check_stats ( ) ; timing_point ( ""check<S2SV_blank>stats<S2SV_blank>initialized\\n"" ) ; check_for_nagios_updates ( FALSE , TRUE ) ; timing_point ( ""Update<S2SV_blank>check<S2SV_blank>concluded\\n"" ) ; update_all_status_data ( ) ; timing_point ( ""Status<S2SV_blank>data<S2SV_blank>updated\\n"" ) ; log_host_states ( INITIAL_STATES , NULL ) ; log_service_states ( INITIAL_STATES , NULL ) ; timing_point ( ""Initial<S2SV_blank>states<S2SV_blank>logged\\n"" ) ; sigrestart = FALSE ; launch_command_file_worker ( ) ; timing_point ( ""Command<S2SV_blank>file<S2SV_blank>worker<S2SV_blank>launched\\n"" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPSTART , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif event_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_EVENTSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_EVENTSTARTTIME ] , ""%llu"" , ( unsigned long long ) event_start ) ; timing_point ( ""Entering<S2SV_blank>event<S2SV_blank>execution<S2SV_blank>loop\\n"" ) ; event_execution_loop ( ) ; qh_deinit ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) ; if ( caught_signal == TRUE ) { if ( sig_id == SIGHUP ) logit ( NSLOG_PROCESS_INFO , TRUE , ""Caught<S2SV_blank>SIGHUP,<S2SV_blank>restarting...\\n"" ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPEND , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; if ( sigshutdown == TRUE ) broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_USER_INITIATED , NEBATTR_SHUTDOWN_NORMAL , NULL ) ; else if ( sigrestart == TRUE ) broker_program_state ( NEBTYPE_PROCESS_RESTART , NEBFLAG_USER_INITIATED , NEBATTR_RESTART_NORMAL , NULL ) ; # endif save_state_information ( FALSE ) ; cleanup_retention_data ( ) ; cleanup_performance_data ( ) ; cleanup_downtime_data ( ) ; if ( sigrestart == FALSE ) { cleanup_status_data ( TRUE ) ; } free_worker_memory ( WPROC_FORCE ) ; if ( sigshutdown == TRUE ) { iobroker_destroy ( nagios_iobs , IOBROKER_CLOSE_SOCKETS ) ; nagios_iobs = NULL ; logit ( NSLOG_PROCESS_INFO , TRUE , ""Successfully<S2SV_blank>shutdown...<S2SV_blank>(PID=%d)\\n"" , ( int ) getpid ( ) ) ; } cleanup ( ) ; close_debug_log ( ) ; } while ( sigrestart == TRUE && sigshutdown == FALSE ) ; if ( daemon_mode == TRUE ) unlink ( lock_file ) ; my_free ( lock_file ) ; my_free ( config_file ) ; my_free ( config_file_dir ) ; my_free ( nagios_binary_path ) ; } return OK ; }
","<S2SV_ModStart> ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; }
"
85,"CWE-119 void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }
","<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
"
86,"CWE-362 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; if ( task ) { err = mutex_lock_interruptible ( & task -> signal -> cred_guard_mutex ) ; if ( err ) goto err_cpus ; err = - EACCES ; if ( ! ptrace_may_access ( task , PTRACE_MODE_READ_REALCREDS ) ) goto err_cred ; } if ( flags & PERF_FLAG_PID_CGROUP ) cgroup_fd = pid ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL , cgroup_fd ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cred ; } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - EOPNOTSUPP ; goto err_alloc ; } } pmu = event -> pmu ; if ( attr . use_clockid ) { err = perf_event_set_clock ( event , attr . clockid ) ; if ( err ) goto err_alloc ; } if ( pmu -> task_ctx_nr == perf_sw_context ) event -> event_caps |= PERF_EV_CAP_SOFTWARE ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( ( pmu -> capabilities & PERF_PMU_CAP_EXCLUSIVE ) && group_leader ) { err = - EBUSY ; goto err_context ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( group_leader -> clock != event -> clock ) goto err_context ; if ( move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu ) goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; event_file = NULL ; goto err_context ; } if ( move_group ) { <S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; if ( gctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } <S2SV_StartBug> } else { <S2SV_EndBug> mutex_lock ( & ctx -> mutex ) ; } if ( ctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } if ( ! perf_event_validate_size ( event ) ) { err = - E2BIG ; goto err_locked ; } if ( ! exclusive_event_installable ( event , ctx ) ) { WARN_ON_ONCE ( move_group ) ; err = - EBUSY ; goto err_locked ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { perf_remove_from_context ( group_leader , 0 ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , 0 ) ; put_ctx ( gctx ) ; } synchronize_rcu ( ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_event__state_init ( sibling ) ; perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } perf_event__state_init ( group_leader ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; put_ctx ( gctx ) ; } perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; event -> owner = current ; perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; if ( task ) { mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; put_task_struct ( task ) ; } put_online_cpus ( ) ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_locked : if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; fput ( event_file ) ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : if ( ! event_file ) free_event ( event ) ; err_cred : if ( task ) mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }
","<S2SV_ModStart> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if <S2SV_ModStart> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock
"
87,"CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
"
88,"CWE-119 int main ( int argc , const char * * argv_ ) { int pass ; vpx_image_t raw ; <S2SV_StartBug> int frame_avail , got_data ; <S2SV_EndBug> <S2SV_StartBug> struct VpxInputContext input = { 0 } ; <S2SV_EndBug> struct VpxEncoderConfig global ; struct stream_state * streams = NULL ; char * * argv , * * argi ; uint64_t cx_time = 0 ; int stream_cnt = 0 ; int res = 0 ; <S2SV_StartBug> exec_name = argv_ [ 0 ] ; <S2SV_EndBug> if ( argc < 3 ) usage_exit ( ) ; input . framerate . numerator = 30 ; input . framerate . denominator = 1 ; <S2SV_StartBug> input . use_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> input . only_i420 = 1 ; <S2SV_EndBug> argv = argv_dup ( argc - 1 , argv_ + 1 ) ; <S2SV_StartBug> parse_global_config ( & global , argv ) ; <S2SV_EndBug> { struct stream_state * stream = NULL ; do { stream = new_stream ( & global , stream ) ; stream_cnt ++ ; if ( ! streams ) streams = stream ; } while ( parse_stream_params ( & global , stream , argv ) ) ; } for ( argi = argv ; * argi ; argi ++ ) if ( argi [ 0 ] [ 0 ] == '-' && argi [ 0 ] [ 1 ] ) die ( ""Error:<S2SV_blank>Unrecognized<S2SV_blank>option<S2SV_blank>%s\\n"" , * argi ) ; FOREACH_STREAM ( check_encoder_config ( global . disable_warning_prompt , & global , & stream -> config . cfg ) ; ) ; input . filename = argv [ 0 ] ; if ( ! input . filename ) usage_exit ( ) ; if ( global . codec -> fourcc == VP9_FOURCC ) input . only_i420 = 0 ; for ( pass = global . pass ? global . pass - 1 : 0 ; pass < global . passes ; pass ++ ) { int frames_in = 0 , seen_frames = 0 ; int64_t estimated_time_left = - 1 ; int64_t average_rate = - 1 ; <S2SV_StartBug> off_t lagged_count = 0 ; <S2SV_EndBug> open_input_file ( & input ) ; <S2SV_StartBug> if ( ! input . width || ! input . height ) <S2SV_EndBug> FOREACH_STREAM ( { if ( stream -> config . cfg . g_w && stream -> config . cfg . g_h ) { input . width = stream -> config . cfg . g_w ; input . height = stream -> config . cfg . g_h ; break ; } <S2SV_StartBug> } ) ; <S2SV_EndBug> if ( ! input . width || ! input . height ) fatal ( ""Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>"" <S2SV_StartBug> ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ; <S2SV_EndBug> FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ; FOREACH_STREAM ( validate_stream_config ( stream , & global ) ) ; if ( global . pass && global . passes == 2 ) FOREACH_STREAM ( { if ( ! stream -> config . stats_fn ) die ( ""Stream<S2SV_blank>%d:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>--fpf<S2SV_blank>when<S2SV_blank>--pass=%d"" ""<S2SV_blank>and<S2SV_blank>--passes=2\\n"" , stream -> index , global . pass ) ; } ) ; # if ! CONFIG_WEBM_IO FOREACH_STREAM ( { stream -> config . write_webm = 0 ; warn ( ""vpxenc<S2SV_blank>was<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>WebM<S2SV_blank>container<S2SV_blank>support."" ""Producing<S2SV_blank>IVF<S2SV_blank>output"" ) ; } ) ; # endif if ( ! global . have_framerate ) { global . framerate . num = input . framerate . numerator ; global . framerate . den = input . framerate . denominator ; } FOREACH_STREAM ( set_default_kf_interval ( stream , & global ) ) ; if ( global . verbose && pass == 0 ) FOREACH_STREAM ( show_stream_config ( stream , & global , & input ) ) ; if ( pass == ( global . pass ? global . pass - 1 : 0 ) ) { if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , 0 , sizeof ( raw ) ) ; else vpx_img_alloc ( & raw , <S2SV_StartBug> input . use_i420 ? VPX_IMG_FMT_I420 <S2SV_EndBug> : VPX_IMG_FMT_YV12 , input . width , input . height , 32 ) ; FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global . framerate ) ) ; } FOREACH_STREAM ( setup_pass ( stream , & global , pass ) ) ; <S2SV_StartBug> FOREACH_STREAM ( open_output_file ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ; <S2SV_EndBug> frame_avail = 1 ; got_data = 0 ; while ( frame_avail || got_data ) { struct vpx_usec_timer timer ; if ( ! global . limit || frames_in < global . limit ) { frame_avail = read_frame ( & input , & raw ) ; if ( frame_avail ) frames_in ++ ; seen_frames = frames_in > global . skip_frames ? frames_in - global . skip_frames : 0 ; if ( ! global . quiet ) { float fps = usec_to_fps ( cx_time , seen_frames ) ; fprintf ( stderr , ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>"" , pass + 1 , global . passes ) ; if ( stream_cnt == 1 ) fprintf ( stderr , ""frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>"" , frames_in , streams -> frames_out , ( int64_t ) streams -> nbytes ) ; else fprintf ( stderr , ""frame<S2SV_blank>%4d<S2SV_blank>"" , frames_in ) ; fprintf ( stderr , ""%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>%.2f<S2SV_blank>%s<S2SV_blank>"" , cx_time > 9999999 ? cx_time / 1000 : cx_time , cx_time > 9999999 ? ""ms"" : ""us"" , fps >= 1.0 ? fps : fps * 60 , fps >= 1.0 ? ""fps"" : ""fpm"" ) ; print_time ( ""ETA"" , estimated_time_left ) ; <S2SV_StartBug> fprintf ( stderr , ""\\033[K"" ) ; <S2SV_EndBug> } } else frame_avail = 0 ; <S2SV_StartBug> if ( frames_in > global . skip_frames ) { <S2SV_EndBug> vpx_usec_timer_start ( & timer ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? & raw : NULL , frames_in ) ) ; <S2SV_StartBug> vpx_usec_timer_mark ( & timer ) ; <S2SV_EndBug> cx_time += vpx_usec_timer_elapsed ( & timer ) ; FOREACH_STREAM ( update_quantizer_histogram ( stream ) ) ; got_data = 0 ; FOREACH_STREAM ( get_cx_data ( stream , & global , & got_data ) ) ; <S2SV_StartBug> if ( ! got_data && input . length && ! streams -> frames_out ) { <S2SV_EndBug> lagged_count = global . limit ? seen_frames : ftello ( input . file ) ; } else if ( input . length ) { int64_t remaining ; int64_t rate ; if ( global . limit ) { <S2SV_StartBug> off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ; <S2SV_EndBug> rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ; remaining = 1000 * ( global . limit - global . skip_frames - seen_frames + lagged_count ) ; } else { <S2SV_StartBug> off_t input_pos = ftello ( input . file ) ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos_lagged = input_pos - lagged_count ; <S2SV_EndBug> <S2SV_StartBug> int64_t limit = input . length ; <S2SV_EndBug> rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ; remaining = limit - input_pos + lagged_count ; } average_rate = ( average_rate <= 0 ) ? rate : ( average_rate * 7 + rate ) / 8 ; estimated_time_left = average_rate ? remaining / average_rate : - 1 ; } if ( got_data && global . test_decode != TEST_DECODE_OFF ) FOREACH_STREAM ( test_decode ( stream , global . test_decode , global . codec ) ) ; } fflush ( stdout ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( stream_cnt > 1 ) fprintf ( stderr , ""\\n"" ) ; <S2SV_StartBug> if ( ! global . quiet ) <S2SV_EndBug> FOREACH_STREAM ( fprintf ( stderr , <S2SV_StartBug> ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7lub/f<S2SV_blank>%7"" PRId64 ""b/s"" <S2SV_EndBug> ""<S2SV_blank>%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\033[K\\n"" , pass + 1 , global . passes , frames_in , stream -> frames_out , ( int64_t ) stream -> nbytes , <S2SV_StartBug> seen_frames ? ( unsigned long ) ( stream -> nbytes * 8 / seen_frames ) : 0 , <S2SV_EndBug> seen_frames ? ( int64_t ) stream -> nbytes * 8 * ( int64_t ) global . framerate . num / global . framerate . den / seen_frames : 0 , stream -> cx_time > 9999999 ? stream -> cx_time / 1000 : stream -> cx_time , stream -> cx_time > 9999999 ? ""ms"" : ""us"" , <S2SV_StartBug> usec_to_fps ( stream -> cx_time , seen_frames ) ) ; <S2SV_EndBug> ) ; if ( global . show_psnr ) <S2SV_StartBug> FOREACH_STREAM ( show_psnr ( stream ) ) ; <S2SV_EndBug> FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ; if ( global . test_decode != TEST_DECODE_OFF ) { FOREACH_STREAM ( vpx_codec_destroy ( & stream -> decoder ) ) ; } close_input_file ( & input ) ; if ( global . test_decode == TEST_DECODE_FATAL ) { FOREACH_STREAM ( res |= stream -> mismatch_seen ) ; } FOREACH_STREAM ( close_output_file ( stream , global . codec -> fourcc ) ) ; <S2SV_StartBug> FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ; <S2SV_EndBug> if ( global . pass ) break ; } if ( global . show_q_hist_buckets ) FOREACH_STREAM ( show_q_histogram ( stream -> counts , global . show_q_hist_buckets ) ) ; if ( global . show_rate_hist_buckets ) FOREACH_STREAM ( show_rate_histogram ( stream -> rate_hist , & stream -> config . cfg , global . show_rate_hist_buckets ) ) ; FOREACH_STREAM ( destroy_rate_histogram ( stream -> rate_hist ) ) ; # if CONFIG_INTERNAL_STATS if ( ! ( global . pass == 1 && global . passes == 2 ) ) FOREACH_STREAM ( { FILE * f = fopen ( ""opsnr.stt"" , ""a"" ) ; if ( stream -> mismatch_seen ) { fprintf ( f , ""First<S2SV_blank>mismatch<S2SV_blank>occurred<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>%d\\n"" , stream -> mismatch_seen ) ; } else { fprintf ( f , ""No<S2SV_blank>mismatch<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>recon<S2SV_blank>buffers\\n"" ) ; } fclose ( f ) ; <S2SV_StartBug> } ) ; <S2SV_EndBug> # endif vpx_img_free ( & raw ) ; free ( argv ) ; free ( streams ) ; return res ? EXIT_FAILURE : EXIT_SUCCESS ; }
","<S2SV_ModStart> vpx_image_t raw ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ; int allocated_raw_shift = 0 ; int use_16bit_internal = 0 ; int input_shift = 0 ; # endif <S2SV_ModStart> struct VpxInputContext input <S2SV_ModEnd> ; struct VpxEncoderConfig <S2SV_ModStart> = 0 ; memset ( & input , 0 , sizeof ( input ) ) ; <S2SV_ModStart> ; input . only_i420 <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ; input . bit_depth = 0 <S2SV_ModEnd> ; argv = <S2SV_ModStart> argv ) ; switch ( global . color_type ) { case I420 : input . fmt = VPX_IMG_FMT_I420 ; break ; case I422 : input . fmt = VPX_IMG_FMT_I422 ; break ; case I444 : input . fmt = VPX_IMG_FMT_I444 ; break ; case I440 : input . fmt = VPX_IMG_FMT_I440 ; break ; case YV12 : input . fmt = VPX_IMG_FMT_YV12 ; break ; } <S2SV_ModStart> - 1 ; int64_t <S2SV_ModEnd> lagged_count = 0 <S2SV_ModStart> . height ) { <S2SV_ModStart> } ) ; } <S2SV_ModStart> ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ; if ( ! input . bit_depth ) { FOREACH_STREAM ( { if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ; else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ; } ) ; if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ; } else { FOREACH_STREAM ( { stream -> config . cfg . g_input_bit_depth = input . bit_depth ; } ) ; } <S2SV_ModStart> & raw , input . fmt , <S2SV_ModEnd> input . width <S2SV_ModStart> , & global , & input . pixel_aspect_ratio <S2SV_ModStart> ) ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , ""vp9"" ) == 0 || strcmp ( global . codec -> name , ""vp10"" ) == 0 ) { FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) { use_16bit_internal = 1 ; } if ( stream -> config . cfg . g_profile == 0 ) { input_shift = 0 ; } else { input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ; } } ) ; } # endif <S2SV_ModStart> estimated_time_left ) ; <S2SV_ModEnd> } } else <S2SV_ModStart> skip_frames ) { # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ; if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) { assert ( use_16bit_internal ) ; if ( ! allocated_raw_shift ) { vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ; allocated_raw_shift = 1 ; } vpx_img_upshift ( & raw_shift , & raw , input_shift ) ; frame_to_encode = & raw_shift ; } else { frame_to_encode = & raw ; } vpx_usec_timer_start ( & timer ) ; if ( use_16bit_internal ) { assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ; FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ; else assert ( 0 ) ; } ) ; } else { assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ; } # else <S2SV_ModStart> ) ) ; # endif <S2SV_ModStart> . length && streams != NULL && <S2SV_ModStart> limit ) { const int64_t <S2SV_ModEnd> frame_in_lagged = ( <S2SV_ModStart> } else { const int64_t <S2SV_ModEnd> input_pos = ftello <S2SV_ModStart> file ) ; const int64_t <S2SV_ModEnd> input_pos_lagged = input_pos <S2SV_ModStart> - lagged_count ; const <S2SV_ModStart> stdout ) ; if ( ! global . quiet ) fprintf ( stderr , ""\\033[K"" ) ; <S2SV_ModStart> . quiet ) { <S2SV_ModStart> , ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7"" PRId64 ""b/f<S2SV_blank>%7"" <S2SV_ModEnd> PRId64 ""b/s"" ""<S2SV_blank>%7"" <S2SV_ModStart> seen_frames ? ( int64_t <S2SV_ModEnd> ) ( stream <S2SV_ModStart> seen_frames ) ) ) ; } <S2SV_ModEnd> if ( global <S2SV_ModStart> . show_psnr ) { if ( global . codec -> fourcc == VP9_FOURCC ) { FOREACH_STREAM ( <S2SV_ModEnd> show_psnr ( stream <S2SV_ModStart> show_psnr ( stream , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ; } else { FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ; } } <S2SV_ModEnd> FOREACH_STREAM ( vpx_codec_destroy <S2SV_ModStart> ) ) ; # if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ; # endif <S2SV_ModStart> ) ; } ) ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift
"
89,"CWE-125 int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
"
90,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }
","<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
"
91,"CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; <S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }
","<S2SV_ModStart> ; ue -> card = card ; ue ->
"
92,"CWE-119 int cdc_parse_cdc_header ( struct usb_cdc_parsed_header * hdr , struct usb_interface * intf , u8 * buffer , int buflen ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_header_desc * header = NULL ; struct usb_cdc_ether_desc * ether = NULL ; struct usb_cdc_mdlm_detail_desc * detail = NULL ; struct usb_cdc_mdlm_desc * desc = NULL ; unsigned int elength ; int cnt = 0 ; memset ( hdr , 0x00 , sizeof ( struct usb_cdc_parsed_header ) ) ; hdr -> phonet_magic_present = false ; while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage<S2SV_blank>byte\\n"" ) ; elength = 1 ; <S2SV_StartBug> goto next_desc ; <S2SV_EndBug> } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage\\n"" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n"" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; hdr -> usb_cdc_country_functional_desc = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : if ( elength != sizeof ( struct usb_cdc_header_desc ) ) goto next_desc ; if ( header ) return - EINVAL ; header = ( struct usb_cdc_header_desc * ) buffer ; break ; case USB_CDC_ACM_TYPE : if ( elength < sizeof ( struct usb_cdc_acm_descriptor ) ) goto next_desc ; hdr -> usb_cdc_acm_descriptor = ( struct usb_cdc_acm_descriptor * ) buffer ; break ; case USB_CDC_ETHERNET_TYPE : if ( elength != sizeof ( struct usb_cdc_ether_desc ) ) goto next_desc ; if ( ether ) return - EINVAL ; ether = ( struct usb_cdc_ether_desc * ) buffer ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < sizeof ( struct usb_cdc_call_mgmt_descriptor ) ) goto next_desc ; hdr -> usb_cdc_call_mgmt_descriptor = ( struct usb_cdc_call_mgmt_descriptor * ) buffer ; break ; case USB_CDC_DMM_TYPE : if ( elength < sizeof ( struct usb_cdc_dmm_desc ) ) goto next_desc ; hdr -> usb_cdc_dmm_desc = ( struct usb_cdc_dmm_desc * ) buffer ; break ; case USB_CDC_MDLM_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_desc * ) ) goto next_desc ; if ( desc ) return - EINVAL ; desc = ( struct usb_cdc_mdlm_desc * ) buffer ; break ; case USB_CDC_MDLM_DETAIL_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_detail_desc * ) ) goto next_desc ; if ( detail ) return - EINVAL ; detail = ( struct usb_cdc_mdlm_detail_desc * ) buffer ; break ; case USB_CDC_NCM_TYPE : if ( elength < sizeof ( struct usb_cdc_ncm_desc ) ) goto next_desc ; hdr -> usb_cdc_ncm_desc = ( struct usb_cdc_ncm_desc * ) buffer ; break ; case USB_CDC_MBIM_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_desc ) ) goto next_desc ; hdr -> usb_cdc_mbim_desc = ( struct usb_cdc_mbim_desc * ) buffer ; break ; case USB_CDC_MBIM_EXTENDED_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_extended_desc ) ) break ; hdr -> usb_cdc_mbim_extended_desc = ( struct usb_cdc_mbim_extended_desc * ) buffer ; break ; case CDC_PHONET_MAGIC_NUMBER : hdr -> phonet_magic_present = true ; break ; default : dev_dbg ( & intf -> dev , ""Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n"" , buffer [ 2 ] , elength ) ; goto next_desc ; } cnt ++ ; next_desc : buflen -= elength ; buffer += elength ; } hdr -> usb_cdc_union_desc = union_header ; hdr -> usb_cdc_header_desc = header ; hdr -> usb_cdc_mdlm_detail_desc = detail ; hdr -> usb_cdc_mdlm_desc = desc ; hdr -> usb_cdc_ether_desc = ether ; return cnt ; }
","<S2SV_ModStart> ; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break
"
93,"CWE-347 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> return NULL ;
"
94,"CWE-787 GF_Err tenc_box_read ( GF_Box * s , GF_BitStream * bs ) { u8 iv_size ; GF_TrackEncryptionBox * ptr = ( GF_TrackEncryptionBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isProtected = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isProtected ) { ISOM_DECREASE_SIZE ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , ptr -> key_info [ 20 ] ) ; <S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> } <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> }
","<S2SV_ModStart> ] ) ; if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> ) ; } else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; }
"
95,"CWE-189 Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <S2SV_StartBug> int isopen ; <S2SV_EndBug> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }
","<S2SV_ModStart> size ; int base_size ; int <S2SV_ModStart> ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> ] ) + base_size ; if ( base_size / npts != <S2SV_ModStart> 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> ; poly =
"
96,"CWE-59 int main ( int argc , char * argv [ ] ) { int ret ; struct lxc_lock * lock ; lock = lxc_newlock ( NULL , NULL ) ; if ( ! lock ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>unnamed<S2SV_blank>lock\\n"" , __LINE__ ) ; exit ( 1 ) ; } ret = lxclock ( lock , 0 ) ; if ( ret ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>take<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , __LINE__ , ret ) ; exit ( 1 ) ; } ret = lxcunlock ( lock ) ; if ( ret ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n"" , __LINE__ , ret ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; lock = lxc_newlock ( ""/var/lib/lxc"" , mycontainername ) ; if ( ! lock ) { fprintf ( stderr , ""%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>lock\\n"" , __LINE__ ) ; exit ( 1 ) ; } struct stat sb ; <S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ret = stat ( pathname , & sb ) ; if ( ret != 0 ) { fprintf ( stderr , ""%d:<S2SV_blank>filename<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>created\\n"" , __LINE__ , pathname ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; test_two_locks ( ) ; fprintf ( stderr , ""all<S2SV_blank>tests<S2SV_blank>passed\\n"" ) ; exit ( ret ) ; }
","<S2SV_ModStart> pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> ; ret =
"
97,"CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }
","<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
"
98,"CWE-400 static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> } end : rcu_read_unlock ( ) ; }
","<S2SV_ModStart> , u64 nr <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> , nr , <S2SV_ModEnd> data , regs
"
99,"CWE-200 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state = & env -> cur_state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs = state -> regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; init_reg_state ( regs ) ; insn_idx = 0 ; env -> varlen_map_value_access = false ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( log_level ) { if ( do_print_state ) verbose ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( ""%d:<S2SV_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( log_level && do_print_state ) { verbose ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( & env -> cur_state ) ; do_print_state = false ; } if ( log_level ) { verbose ( ""%d:<S2SV_blank>"" , insn_idx ) ; <S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; if ( BPF_SIZE ( insn -> code ) != BPF_W && BPF_SIZE ( insn -> code ) != BPF_DW ) { insn_idx ++ ; continue ; } prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } process_bpf_exit : insn_idx = pop_stack ( env , & prev_insn_idx ) ; if ( insn_idx < 0 ) { break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; } else { verbose ( ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } reset_reg_range_values ( regs , insn -> dst_reg ) ; } else { verbose ( ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( ""processed<S2SV_blank>%d<S2SV_blank>insns\\n"" , insn_processed ) ; return 0 ; }
","<S2SV_ModStart> ; print_bpf_insn ( env ,
"
100,"CWE-20 void ArrowHead ( ) { int k ; double length ; SaveGraphicsState ; if ( flip ) length = - arrow . length ; else length = arrow . length ; SetDashSize ( 0 , 0 ) ; if ( arrow . stroke ) { SetLineWidth ( arrow . stroke ) ; for ( k = 1 ; k <= 2 ; k ++ ) { SaveGraphicsState ; MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; if ( k == 1 ) { SetBackgroundColor ( NONSTROKING ) ; <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ; <S2SV_EndBug> } RestoreGraphicsState ; } } else { MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> } RestoreGraphicsState ; }
","<S2SV_ModStart> NONSTROKING ) ; send ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_ModStart> } else { send ( <S2SV_ModEnd> ""<S2SV_blank>s"" ) ; <S2SV_ModStart> width ) ; send ( <S2SV_ModEnd> ""<S2SV_blank>h<S2SV_blank>f"" ) ;
"
101,"CWE-416 int wwunpack ( uint8_t * exe , uint32_t exesz , uint8_t * wwsect , struct cli_exe_section * sects , uint16_t scount , uint32_t pe , int desc ) { uint8_t * structs = wwsect + 0x2a1 , * compd , * ccur , * unpd , * ucur , bc ; uint32_t src , srcend , szd , bt , bits ; int error = 0 , i ; cli_dbgmsg ( ""in<S2SV_blank>wwunpack\\n"" ) ; while ( 1 ) { if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , structs , 17 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>structs<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section\\n"" ) ; break ; } src = sects [ scount ] . rva - cli_readint32 ( structs ) ; structs += 8 ; szd = cli_readint32 ( structs ) * 4 ; structs += 4 ; srcend = cli_readint32 ( structs ) ; structs += 4 ; unpd = ucur = exe + src + srcend + 4 - szd ; if ( ! szd || ! CLI_ISCONTAINED ( exe , exesz , unpd , szd ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Compressed<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; break ; } cli_dbgmsg ( ""WWP:<S2SV_blank>src:<S2SV_blank>%x,<S2SV_blank>szd:<S2SV_blank>%x,<S2SV_blank>srcend:<S2SV_blank>%x<S2SV_blank>-<S2SV_blank>%x\\n"" , src , szd , srcend , srcend + 4 - szd ) ; if ( ! ( compd = cli_malloc ( szd ) ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>compd\\n"" ) ; break ; } memcpy ( compd , unpd , szd ) ; memset ( unpd , - 1 , szd ) ; ccur = compd ; RESEED ; while ( ! error ) { uint32_t backbytes , backsize ; uint8_t saved ; BIT ; if ( ! bits ) { if ( ccur - compd >= szd || ! CLI_ISCONTAINED ( exe , exesz , ucur , 1 ) ) error = 1 ; else * ucur ++ = * ccur ++ ; continue ; } BITS ( 2 ) ; if ( bits == 3 ) { uint8_t shifted , subbed = 31 ; BITS ( 2 ) ; shifted = bits + 5 ; if ( bits >= 2 ) { shifted ++ ; subbed += 0x80 ; } backbytes = ( 1 << shifted ) - subbed ; BITS ( shifted ) ; if ( error || bits == 0x1ff ) break ; backbytes += bits ; if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , 2 ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , 2 ) ) { error = 1 ; } else { ucur [ 0 ] = * ( ucur - backbytes ) ; ucur [ 1 ] = * ( ucur - backbytes + 1 ) ; ucur += 2 ; } continue ; } saved = bits ; BITS ( 3 ) ; if ( bits < 6 ) { backbytes = bits ; switch ( bits ) { case 4 : backbytes ++ ; case 3 : BIT ; backbytes += bits ; case 0 : case 1 : case 2 : backbytes += 5 ; break ; case 5 : backbytes = 12 ; break ; } BITS ( backbytes ) ; bits += ( 1 << backbytes ) - 31 ; } else if ( bits == 6 ) { BITS ( 0x0e ) ; bits += 0x1fe1 ; } else { BITS ( 0x0f ) ; bits += 0x5fe1 ; } backbytes = bits ; if ( ! saved ) { BIT ; if ( ! bits ) { BIT ; bits += 5 ; } else { BITS ( 3 ) ; if ( bits ) { bits += 6 ; } else { BITS ( 4 ) ; if ( bits ) { bits += 13 ; } else { uint8_t cnt = 4 ; uint16_t shifted = 0x0d ; do { if ( cnt == 7 ) { cnt = 0x0e ; shifted = 0 ; break ; } shifted = ( ( shifted + 2 ) << 1 ) - 1 ; BIT ; cnt ++ ; } while ( ! bits ) ; BITS ( cnt ) ; bits += shifted ; } } } backsize = bits ; } else { backsize = saved + 2 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , backsize ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , backsize ) ) error = 1 ; else while ( backsize -- ) { * ucur = * ( ucur - backbytes ) ; ucur ++ ; } } free ( compd ) ; if ( error ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>decompression<S2SV_blank>error\\n"" ) ; break ; } if ( error || ! * structs ++ ) break ; } if ( ! error ) { if ( pe + 6 > exesz || pe + 7 > exesz || pe + 0x28 > exesz || pe + 0x50 > exesz || pe + 0x14 > exesz ) return CL_EFORMAT ; exe [ pe + 6 ] = ( uint8_t ) scount ; exe [ pe + 7 ] = ( uint8_t ) ( scount >> 8 ) ; <S2SV_StartBug> cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ; <S2SV_EndBug> cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ; structs = & exe [ ( 0xffff & cli_readint32 ( & exe [ pe + 0x14 ] ) ) + pe + 0x18 ] ; for ( i = 0 ; i < scount ; i ++ ) { if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return CL_EFORMAT ; } cli_writeint32 ( structs + 8 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 12 , sects [ i ] . rva ) ; cli_writeint32 ( structs + 16 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 20 , sects [ i ] . rva ) ; structs += 0x28 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return CL_EFORMAT ; } memset ( structs , 0 , 0x28 ) ; error = ( uint32_t ) cli_writen ( desc , exe , exesz ) != exesz ; } return error ; }
","<S2SV_ModStart> 8 ) ; if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n"" ) ; return CL_EFORMAT ; }
"
102,"CWE-264 static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , ""tasks"" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }
","<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
"
103,"CWE-400 static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
"
104,"CWE-125 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } switch ( type ) { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; x ++ ; } x -- ; continue ; } } break ; } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }
","<S2SV_ModStart> ( ssize_t ) ConstrainColormapIndex ( image , <S2SV_ModStart> image , q ) , exception
"
105,"CWE-345 static <S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> { HeaderIterator hi ; struct rpmtd_s td ; <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> break ; case RPMSIGTAG_PGP : <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> continue ; break ; } <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 ) continue ; break ; case RPM_I18NSTRING_TYPE : continue ; break ; } <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> } } headerFreeIterator ( hi ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static rpmTagVal <S2SV_ModEnd> headerMergeLegacySigs ( Header <S2SV_ModStart> , Header sigh , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> ; struct rpmtd_s <S2SV_ModStart> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> td . tag <S2SV_ModStart> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> td . tag <S2SV_ModStart> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! headerPut <S2SV_ModEnd> ( h , <S2SV_ModStart> ( h , <S2SV_ModEnd> & td , <S2SV_ModStart> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> ; } <S2SV_null>
"
106,"CWE-119 bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }
","<S2SV_ModStart> ; } } if ( ! <S2SV_ModEnd> xdr_opaque ( xdrs <S2SV_ModStart> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE
"
107,"CWE-264 static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; }
","<S2SV_ModStart> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }
"
108,"CWE-59 static int fsmMkfile ( rpmfi fi , const char * dest , rpmfiles files , rpmpsm psm , int nodigest , int * setmeta , int * firsthardlink ) { int rc = 0 ; int numHardlinks = rpmfiFNlink ( fi ) ; if ( numHardlinks > 1 ) { if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ; rc = link ( fn , dest ) ; if ( rc < 0 ) { rc = RPMERR_LINK_FAILED ; } free ( fn ) ; } } if ( numHardlinks <= 1 ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> } else if ( rpmfiArchiveHasContent ( fi ) ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> * firsthardlink = - 1 ; } else { * setmeta = 0 ; } return rc ; }
","<S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 0 ,
"
109,"CWE-200 static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) <S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }
","<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram
"
110,"CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } <S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }
","<S2SV_ModStart> } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if (
"
111,"CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( ""%d<S2SV_blank>tickets\\n"" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }
","<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
112,"CWE-119 SPL_METHOD ( SplObjectStorage , unserialize ) { spl_SplObjectStorage * intern = Z_SPLOBJSTORAGE_P ( getThis ( ) ) ; char * buf ; size_t buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval entry , inf ; zval * pcount , * pmembers ; spl_SplObjectStorageElement * element ; zend_long count ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s"" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pcount = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) { goto outexcept ; } -- p ; <S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> while ( count -- > 0 ) { spl_SplObjectStorageElement * pelement ; zend_string * hash ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) { goto outexcept ; } <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> zval_ptr_dtor ( & entry ) ; goto outexcept ; } if ( * p == ',' ) { ++ p ; if ( ! php_var_unserialize ( & inf , & p , s + buf_len , & var_hash ) ) { zval_ptr_dtor ( & entry ) ; goto outexcept ; } <S2SV_StartBug> } else { <S2SV_EndBug> ZVAL_UNDEF ( & inf ) ; } hash = spl_object_storage_get_hash ( intern , getThis ( ) , & entry ) ; if ( ! hash ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept ; } pelement = spl_object_storage_get ( intern , hash ) ; spl_object_storage_free_hash ( intern , hash ) ; if ( pelement ) { if ( ! Z_ISUNDEF ( pelement -> inf ) ) { var_push_dtor ( & var_hash , & pelement -> inf ) ; } if ( ! Z_ISUNDEF ( pelement -> obj ) ) { var_push_dtor ( & var_hash , & pelement -> obj ) ; } } element = spl_object_storage_attach ( intern , getThis ( ) , & entry , Z_ISUNDEF ( inf ) ? NULL : & inf ) ; var_replace ( & var_hash , & entry , & element -> obj ) ; var_replace ( & var_hash , & inf , & element -> inf ) ; zval_ptr_dtor ( & entry ) ; ZVAL_UNDEF ( & entry ) ; zval_ptr_dtor ( & inf ) ; ZVAL_UNDEF ( & inf ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pmembers = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pmembers , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { goto outexcept ; } object_properties_load ( & intern -> std , Z_ARRVAL_P ( pmembers ) ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%pd<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }
","<S2SV_ModStart> Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> } if ( <S2SV_ModEnd> * p == <S2SV_ModStart> ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; } hash
"
113,"CWE-125 static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug> # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""!="" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) { PyObject_FREE ( str ) ; err_ret -> expected = NOTEQUAL ; err_ret -> error = E_SYNTAX ; break ; } } # endif lineno = type == STRING ? tok -> first_lineno : tok -> lineno ; line_start = type == STRING ? tok -> multi_line_start : tok -> line_start ; if ( a != NULL && a >= line_start ) { col_offset = Py_SAFE_DOWNCAST ( a - line_start , intptr_t , int ) ; } else { col_offset = - 1 ; } if ( b != NULL && b >= tok -> line_start ) { end_col_offset = Py_SAFE_DOWNCAST ( b - tok -> line_start , intptr_t , int ) ; } else { end_col_offset = - 1 ; } <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug> # ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; PyNode_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = NULL ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; # endif PyParser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = col_offset != - 1 ? col_offset + 1 : ( ( int ) ( tok -> cur - tok -> buf ) ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = PyNode_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : PyTokenizer_Free ( tok ) ; if ( n != NULL ) { _PyNode_FinalizeEndPos ( n ) ; } return n ; }
","<S2SV_ModStart> , end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )
"
114,"CWE-264 const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }
","<S2SV_ModStart> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
"
115,"CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; <S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }
","<S2SV_ModStart> , 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> ; int n <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short""
"
116,"CWE-835 void dwg_free_object ( Dwg_Object * obj ) { int error = 0 ; long unsigned int j ; Dwg_Data * dwg ; Bit_Chain * dat = & pdat ; if ( obj && obj -> parent ) { dwg = obj -> parent ; dat -> version = dwg -> header . version ; } else return ; if ( obj -> type == DWG_TYPE_FREED || obj -> tio . object == NULL ) return ; dat -> from_version = dat -> version ; if ( obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) goto unhandled ; switch ( obj -> type ) { case DWG_TYPE_TEXT : dwg_free_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : dwg_free_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : dwg_free_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : dwg_free_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : dwg_free_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : dwg_free_SEQEND ( dat , obj ) ; break ; case DWG_TYPE_INSERT : dwg_free_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : dwg_free_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : dwg_free_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : dwg_free_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : dwg_free_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : dwg_free_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : dwg_free_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : dwg_free_POLYLINE_2D ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_3D : dwg_free_POLYLINE_3D ( dat , obj ) ; break ; case DWG_TYPE_ARC : dwg_free_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : dwg_free_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : dwg_free_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : dwg_free_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : dwg_free_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : dwg_free_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : dwg_free_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : dwg_free_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : dwg_free_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : dwg_free_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : dwg_free_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : dwg_free__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : dwg_free_POLYLINE_PFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : dwg_free_POLYLINE_MESH ( dat , obj ) ; break ; case DWG_TYPE_SOLID : dwg_free_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : dwg_free_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : dwg_free_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : dwg_free_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : dwg_free_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : dwg_free_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : dwg_free_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : dwg_free__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : dwg_free_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : dwg_free_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : dwg_free_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : dwg_free_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : dwg_free_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : dwg_free_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : dwg_free_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : dwg_free_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : dwg_free_BLOCK_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_HEADER : dwg_free_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : dwg_free_LAYER_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LAYER : dwg_free_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : dwg_free_STYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_STYLE : dwg_free_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : dwg_free_LTYPE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LTYPE : dwg_free_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : dwg_free_VIEW_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VIEW : dwg_free_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : dwg_free_UCS_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_UCS : dwg_free_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : dwg_free_VPORT_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT : dwg_free_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : dwg_free_APPID_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_APPID : dwg_free_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : dwg_free_DIMSTYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE : dwg_free_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : dwg_free_VPORT_ENTITY_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_HEADER : dwg_free_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : dwg_free_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : dwg_free_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : dwg_free_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : dwg_free_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : dwg_free_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : dwg_free_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : dwg_free_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : dwg_free_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : dwg_free_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : dwg_free_OLEFRAME ( dat , obj ) ; break ; # ifdef DEBUG_VBA_PROJECT case DWG_TYPE_VBA_PROJECT : dwg_free_VBA_PROJECT ( dat , obj ) ; break ; # endif case DWG_TYPE_LAYOUT : dwg_free_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : dwg_free_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : dwg_free_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type ) { SINCE ( R_13 ) { dwg_free_LAYOUT ( dat , obj ) ; } } else if ( ( error = dwg_free_variable_type ( obj -> parent , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { <S2SV_StartBug> int is_entity ; <S2SV_EndBug> int i ; Dwg_Class * klass ; unhandled : is_entity = 0 ; i = obj -> type - 500 ; klass = NULL ; dwg = obj -> parent ; if ( dwg -> dwg_class && i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = klass ? dwg_class_is_entity ( klass ) : 0 ; } <S2SV_StartBug> if ( obj -> fixedtype == DWG_TYPE_TABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_ENT ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( klass && ! is_entity ) { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; } else if ( klass && is_entity ) { dwg_free_UNKNOWN_ENT ( dat , obj ) ; } else { FREE_IF ( obj -> tio . unknown ) ; } } } if ( dwg -> opts & DWG_OPTS_INDXF ) FREE_IF ( obj -> dxfname ) ; obj -> type = DWG_TYPE_FREED ; }
","<S2SV_ModStart> DWG_ERR_UNHANDLEDCLASS ) { unhandled : <S2SV_ModEnd> if ( obj <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> dwg_free_UNKNOWN_ENT ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> else if ( <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> dwg_free_UNKNOWN_OBJ ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
"
117,"CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
","<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
"
118,"CWE-125 static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; asdl_seq * _target , * seq = NULL , * suite_seq ; expr_ty expression ; expr_ty target , first ; const node * node_target ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> if ( ! seq ) return NULL ; } node_target = CHILD ( n , 1 ) ; _target = ast_for_exprlist ( c , node_target , Store ) ; if ( ! _target ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( _target , 0 ) ; if ( NCH ( node_target ) == 1 ) target = first ; else target = Tuple ( _target , Store , first -> lineno , first -> col_offset , node_target -> n_end_lineno , node_target -> n_end_col_offset , c -> c_arena ) ; expression = ast_for_testlist ( c , CHILD ( n , 3 ) ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> if ( ! suite_seq ) return NULL ; if ( seq != NULL ) { get_last_end_pos ( seq , & end_lineno , & end_col_offset ) ; } else { get_last_end_pos ( suite_seq , & end_lineno , & end_col_offset ) ; } <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; int has_type_comment ; string type_comment ; <S2SV_ModStart> , for_stmt ) ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> ) == 9 + has_type_comment <S2SV_ModStart> n , 8 + has_type_comment <S2SV_ModStart> n , 5 + has_type_comment <S2SV_ModStart> } if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , seq , type_comment , <S2SV_ModStart> suite_seq , seq , type_comment
"
119,"CWE-400 static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( ""Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel"" , regs , 0 ) ; return - 1 ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
"
120,"CWE-125 static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }
","<S2SV_ModStart> + 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( kk < input -> length ) )
"
121,"CWE-119 int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
"
122,"CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long"" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto error ; } if (
"
123,"CWE-416 struct dst_entry * inet6_csk_route_req ( const struct sock * sk , struct flowi6 * fl6 , const struct request_sock * req , u8 proto ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = proto ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> fl6 -> flowi6_oif = ireq -> ir_iif ; fl6 -> flowi6_mark = ireq -> ir_mark ; fl6 -> fl6_dport = ireq -> ir_rmt_port ; fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( IS_ERR ( dst ) ) return NULL ; return dst ; }
","<S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
"
124,"CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( ""BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( ""BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( ""invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( ""unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n"" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n"" , insn -> imm ) ; <S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; bpf_map_inc ( map , false ) ; fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }
","<S2SV_ModStart> imm ) ; <S2SV_ModEnd> return PTR_ERR (
"
125,"CWE-189 static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
126,"CWE-119 Imaging ImagingResampleHorizontal ( Imaging imIn , int xsize , int filter ) { ImagingSectionCookie cookie ; Imaging imOut ; struct filter * filterp ; float support , scale , filterscale ; float center , ww , ss , ss0 , ss1 , ss2 , ss3 ; int xx , yy , x , kmax , xmin , xmax ; int * xbounds ; float * k , * kk ; switch ( filter ) { case IMAGING_TRANSFORM_LANCZOS : filterp = & LANCZOS ; break ; case IMAGING_TRANSFORM_BILINEAR : filterp = & BILINEAR ; break ; case IMAGING_TRANSFORM_BICUBIC : filterp = & BICUBIC ; break ; default : return ( Imaging ) ImagingError_ValueError ( ""unsupported<S2SV_blank>resampling<S2SV_blank>filter"" ) ; } filterscale = scale = ( float ) imIn -> xsize / xsize ; support = filterp -> support ; if ( filterscale < 1.0 ) { filterscale = 1.0 ; } support = support * filterscale ; kmax = ( int ) ceil ( support ) * 2 + 1 ; <S2SV_StartBug> kk = malloc ( xsize * kmax * sizeof ( float ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! kk ) <S2SV_EndBug> return ( Imaging ) ImagingError_MemoryError ( ) ; xbounds = malloc ( xsize * 2 * sizeof ( int ) ) ; if ( ! xbounds ) { free ( kk ) ; return ( Imaging ) ImagingError_MemoryError ( ) ; } for ( xx = 0 ; xx < xsize ; xx ++ ) { k = & kk [ xx * kmax ] ; center = ( xx + 0.5 ) * scale ; ww = 0.0 ; ss = 1.0 / filterscale ; xmin = ( int ) floor ( center - support ) ; if ( xmin < 0 ) xmin = 0 ; xmax = ( int ) ceil ( center + support ) ; if ( xmax > imIn -> xsize ) xmax = imIn -> xsize ; for ( x = xmin ; x < xmax ; x ++ ) { float w = filterp -> filter ( ( x - center + 0.5 ) * ss ) * ss ; k [ x - xmin ] = w ; ww += w ; } for ( x = 0 ; x < xmax - xmin ; x ++ ) { if ( ww != 0.0 ) k [ x ] /= ww ; } xbounds [ xx * 2 + 0 ] = xmin ; xbounds [ xx * 2 + 1 ] = xmax ; } imOut = ImagingNew ( imIn -> mode , xsize , imIn -> ysize ) ; if ( ! imOut ) { free ( kk ) ; free ( xbounds ) ; return NULL ; } ImagingSectionEnter ( & cookie ) ; for ( yy = 0 ; yy < imOut -> ysize ; yy ++ ) { if ( imIn -> image8 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( imIn -> image8 [ yy ] [ x ] ) * k [ x - xmin ] ; imOut -> image8 [ yy ] [ xx ] = clip8 ( ss ) ; } } else { switch ( imIn -> type ) { case IMAGING_TYPE_UINT8 : if ( imIn -> bands == 2 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss1 ) ; } } else if ( imIn -> bands == 3 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; } } else { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = ss3 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; ss3 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss3 ) ; } } break ; case IMAGING_TYPE_INT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( IMAGING_PIXEL_I ( imIn , x , yy ) ) * k [ x - xmin ] ; IMAGING_PIXEL_I ( imOut , xx , yy ) = ( int ) ss ; } break ; case IMAGING_TYPE_FLOAT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += IMAGING_PIXEL_F ( imIn , x , yy ) * k [ x - xmin ] ; IMAGING_PIXEL_F ( imOut , xx , yy ) = ss ; } break ; } } } ImagingSectionLeave ( & cookie ) ; free ( kk ) ; free ( xbounds ) ; return imOut ; }
","<S2SV_ModStart> + 1 ; if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ; <S2SV_ModStart> ( ! kk ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) )
"
127,"CWE-611 void init_xml_relax_ng ( ) { VALUE nokogiri = rb_define_module ( ""Nokogiri"" ) ; VALUE xml = rb_define_module_under ( nokogiri , ""XML"" ) ; VALUE klass = rb_define_class_under ( xml , ""RelaxNG"" , cNokogiriXmlSchema ) ; cNokogiriXmlRelaxNG = klass ; <S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ; }
","<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -
"
128,"CWE-119 static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; }
","<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,
"
129,"CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
"
130,"CWE-20 int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) -> i_orphan , & EXT4_SB ( sb ) -> s_orphan ) ; jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n"" , inode -> i_ino ) ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n"" , inode -> i_ino , NEXT_ORPHAN ( inode ) ) ; out_unlock : mutex_unlock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; ext4_std_error ( inode -> i_sb , err ) ; return err ; }
","<S2SV_ModStart> if ( ! EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> ) return 0
"
131,"CWE-476 rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) <S2SV_StartBug> { <S2SV_EndBug> if ( i -> next == 0 ) { LOCK ( rfbClientListMutex ) ; i -> next = i -> screen -> clientHead ; UNLOCK ( rfbClientListMutex ) ; } else { rfbClientPtr cl = i -> next ; i -> next = i -> next -> next ; rfbDecrClientRef ( cl ) ; } # if defined ( LIBVNCSERVER_HAVE_LIBPTHREAD ) || defined ( LIBVNCSERVER_HAVE_WIN32THREADS ) if ( ! i -> closedToo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ; if ( i -> next ) rfbIncrClientRef ( i -> next ) ; # endif return i -> next ; }
","<S2SV_ModStart> i ) { if ( ! i ) return NULL ;
"
132,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
"
133,"CWE-119 <S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - EIO ; }
","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
"
134,"CWE-125 static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { u_int16_t offset = 22 , buf_out_len = 0 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; # ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>%s\\n"" , buf ) ; # endif return ( buf_out_len ) ; invalid_payload : # ifdef SSH_DEBUG printf ( ""[SSH]<S2SV_blank>Invalid<S2SV_blank>packet<S2SV_blank>payload\\n"" ) ; # endif return ( 0 ) ; }
","<S2SV_ModStart> += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload
"
135,"CWE-000 static void * bpf_obj_do_get ( const struct filename * pathname , enum bpf_type * type ) { struct inode * inode ; struct path path ; void * raw ; int ret ; ret = kern_path ( pathname -> name , LOOKUP_FOLLOW , & path ) ; if ( ret ) return ERR_PTR ( ret ) ; inode = d_backing_inode ( path . dentry ) ; ret = inode_permission ( inode , MAY_WRITE ) ; if ( ret ) goto out ; ret = bpf_inode_type ( inode , type ) ; if ( ret ) goto out ; raw = bpf_any_get ( inode -> i_private , * type ) ; <S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> path_put ( & path ) ; return raw ; out : path_put ( & path ) ; return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> type ) ; if ( ! IS_ERR ( raw ) )
"
136,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
"
137,"CWE-119 void vp8_multiframe_quality_enhance ( VP8_COMMON * cm ) { YV12_BUFFER_CONFIG * show = cm -> frame_to_show ; YV12_BUFFER_CONFIG * dest = & cm -> post_proc_buffer ; FRAME_TYPE frame_type = cm -> frame_type ; const MODE_INFO * mode_info_context = cm -> show_frame_mi ; int mb_row ; int mb_col ; int totmap , map [ 4 ] ; int qcurr = cm -> base_qindex ; int qprev = cm -> postproc_state . last_base_qindex ; unsigned char * y_ptr , * u_ptr , * v_ptr ; unsigned char * yd_ptr , * ud_ptr , * vd_ptr ; y_ptr = show -> y_buffer ; u_ptr = show -> u_buffer ; v_ptr = show -> v_buffer ; yd_ptr = dest -> y_buffer ; ud_ptr = dest -> u_buffer ; vd_ptr = dest -> v_buffer ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( frame_type == INTER_FRAME ) totmap = qualify_inter_mb ( mode_info_context , map ) ; else totmap = ( frame_type == KEY_FRAME ? 4 : 0 ) ; if ( totmap ) { if ( totmap < 4 ) { int i , j ; for ( i = 0 ; i < 2 ; ++ i ) for ( j = 0 ; j < 2 ; ++ j ) { if ( map [ i * 2 + j ] ) { multiframe_quality_enhance_block ( 8 , qcurr , qprev , y_ptr + 8 * ( i * show -> y_stride + j ) , u_ptr + 4 * ( i * show -> uv_stride + j ) , v_ptr + 4 * ( i * show -> uv_stride + j ) , show -> y_stride , show -> uv_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , ud_ptr + 4 * ( i * dest -> uv_stride + j ) , vd_ptr + 4 * ( i * dest -> uv_stride + j ) , dest -> y_stride , dest -> uv_stride ) ; } else { int k ; unsigned char * up = u_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * udp = ud_ptr + 4 * ( i * dest -> uv_stride + j ) ; unsigned char * vp = v_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * vdp = vd_ptr + 4 * ( i * dest -> uv_stride + j ) ; vp8_copy_mem8x8 ( y_ptr + 8 * ( i * show -> y_stride + j ) , show -> y_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , dest -> y_stride ) ; for ( k = 0 ; k < 4 ; ++ k , up += show -> uv_stride , udp += dest -> uv_stride , vp += show -> uv_stride , vdp += dest -> uv_stride ) { <S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> } } } } else { multiframe_quality_enhance_block ( 16 , qcurr , qprev , y_ptr , u_ptr , v_ptr , show -> y_stride , show -> uv_stride , yd_ptr , ud_ptr , vd_ptr , dest -> y_stride , dest -> uv_stride ) ; } } else { vp8_copy_mem16x16 ( y_ptr , show -> y_stride , yd_ptr , dest -> y_stride ) ; vp8_copy_mem8x8 ( u_ptr , show -> uv_stride , ud_ptr , dest -> uv_stride ) ; vp8_copy_mem8x8 ( v_ptr , show -> uv_stride , vd_ptr , dest -> uv_stride ) ; } y_ptr += 16 ; u_ptr += 8 ; v_ptr += 8 ; yd_ptr += 16 ; ud_ptr += 8 ; vd_ptr += 8 ; mode_info_context ++ ; } y_ptr += show -> y_stride * 16 - 16 * cm -> mb_cols ; u_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; v_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; yd_ptr += dest -> y_stride * 16 - 16 * cm -> mb_cols ; ud_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; vd_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; mode_info_context ++ ; } }
","<S2SV_ModStart> uv_stride ) { memcpy <S2SV_ModEnd> ( udp , <S2SV_ModStart> 4 ) ; memcpy <S2SV_ModEnd> ( vdp ,
"
138,"CWE-285 static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , """" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> ; } break
"
139,"CWE-125 static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , ""%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , ""%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\n\\t"" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( ldp_msg_values , ""Unknown"" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]"" , tok2str ( ldp_msg_values , ""Unknown"" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? ""continue<S2SV_blank>processing"" : ""ignore"" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , ""\\n\\t<S2SV_blank><S2SV_blank>"" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ( ndo , ""%s"" , tstr <S2SV_ModEnd> ) ) ;
"
140,"CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; <S2SV_StartBug> VpxVideoWriter * writer = NULL ; <S2SV_EndBug> vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ; <S2SV_StartBug> vpx_fixed_buf_t stats = { 0 } ; <S2SV_EndBug> VpxVideoInfo info = { 0 } ; <S2SV_StartBug> const VpxInterface * encoder = NULL ; <S2SV_EndBug> int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; <S2SV_StartBug> info . codec_fourcc = encoder -> fourcc ; <S2SV_EndBug> info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; <S2SV_StartBug> info . frame_height = strtol ( height_arg , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( info . frame_width <= 0 || <S2SV_EndBug> <S2SV_StartBug> info . frame_height <= 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_width % 2 ) != 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_height % 2 ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , <S2SV_EndBug> <S2SV_StartBug> info . frame_height , 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , outfile_arg ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; <S2SV_StartBug> while ( vpx_img_read ( & raw , infile ) ) { <S2SV_EndBug> ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( ""\\n"" ) ; } <S2SV_StartBug> fclose ( infile ) ; <S2SV_EndBug> printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> = NULL ; int w , h <S2SV_ModEnd> ; vpx_codec_ctx_t codec <S2SV_ModStart> ; vpx_fixed_buf_t stats <S2SV_ModEnd> ; const VpxInterface <S2SV_ModStart> encoder = NULL <S2SV_ModEnd> ; const int <S2SV_ModStart> ""Unsupported<S2SV_blank>codec."" ) ; w <S2SV_ModEnd> = strtol ( <S2SV_ModStart> 0 ) ; h <S2SV_ModEnd> = strtol ( <S2SV_ModStart> ; if ( w <S2SV_ModEnd> <= 0 || <S2SV_ModStart> <= 0 || h <S2SV_ModEnd> <= 0 || <S2SV_ModStart> <= 0 || ( w <S2SV_ModEnd> % 2 ) <S2SV_ModStart> != 0 || ( h <S2SV_ModEnd> % 2 ) <S2SV_ModStart> != 0 ) <S2SV_ModEnd> die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" <S2SV_ModStart> ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , w , h ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> , VPX_IMG_FMT_I420 , w , h <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ) <S2SV_ModEnd> die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" <S2SV_ModStart> ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , w , h ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = w ; cfg . g_h = h ; cfg . g_timebase . num = 1 ; cfg . g_timebase . den = fps ; cfg . rc_target_bitrate = bitrate ; if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; cfg . g_pass = VPX_RC_FIRST_PASS ; stats = pass0 ( & raw , infile , encoder , & cfg ) ; rewind ( infile ) ; cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; pass1 ( & raw , infile , outfile_arg , encoder , & cfg ) ; free ( stats . buf ) ; vpx_img_free <S2SV_ModEnd> ( & raw <S2SV_ModStart> ( & raw ) ; <S2SV_ModEnd> fclose ( infile <S2SV_ModStart> fclose ( infile <S2SV_ModEnd> ) ; return
"
141,"CWE-264 int fpm_unix_resolve_socket_premissions ( struct fpm_worker_pool_s * wp ) { struct fpm_worker_pool_config_s * c = wp -> config ; wp -> socket_uid = - 1 ; wp -> socket_gid = - 1 ; <S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> if ( ! c ) { return 0 ; } if ( c -> listen_owner && * c -> listen_owner ) { struct passwd * pwd ; pwd = getpwnam ( c -> listen_owner ) ; if ( ! pwd ) { zlog ( ZLOG_SYSERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\'%s\'"" , wp -> config -> name , c -> listen_owner ) ; return - 1 ; } wp -> socket_uid = pwd -> pw_uid ; wp -> socket_gid = pwd -> pw_gid ; } if ( c -> listen_group && * c -> listen_group ) { struct group * grp ; grp = getgrnam ( c -> listen_group ) ; if ( ! grp ) { zlog ( ZLOG_SYSERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>\'%s\'"" , wp -> config -> name , c -> listen_group ) ; return - 1 ; } wp -> socket_gid = grp -> gr_gid ; } if ( c -> listen_mode && * c -> listen_mode ) { wp -> socket_mode = strtoul ( c -> listen_mode , 0 , 8 ) ; } return 0 ; }
","<S2SV_ModStart> -> socket_mode = 0660 <S2SV_ModEnd> ; if (
"
142,"CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
"
143,"CWE-119 <S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int hbs , int mi_row , int mi_col , <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; if ( has_rows && has_cols ) { vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ; } else if ( ! has_rows && has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> } else if ( has_rows && ! has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> } else { assert ( p == PARTITION_SPLIT ) ; } }
","<S2SV_ModStart> void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const <S2SV_ModEnd> xd , int <S2SV_ModStart> BLOCK_SIZE bsize , vpx_writer <S2SV_ModEnd> * w ) <S2SV_ModStart> ) ; const vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> ; const int <S2SV_ModStart> PARTITION_HORZ ) ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> PARTITION_VERT ) ; vpx_write <S2SV_ModEnd> ( w ,
"
144,"CWE-17 void __fput_sync ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ; __fput ( file ) ; } }
","<S2SV_ModStart> = current ; <S2SV_ModEnd> BUG_ON ( !
"
145,"CWE-000 static ssize_t aio_setup_iocb ( struct kiocb * kiocb , bool compat ) { struct file * file = kiocb -> ki_filp ; ssize_t ret = 0 ; switch ( kiocb -> ki_opcode ) { case IOCB_CMD_PREAD : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITE : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PREADV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( READ , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITEV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( WRITE , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_FDSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fdsync ; break ; case IOCB_CMD_FSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fsync ; break ; default : dprintk ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n"" ) ; ret = - EINVAL ; } if ( ! kiocb -> ki_retry ) return ret ; return 0 ; }
","<S2SV_ModStart> ; ret = aio_setup_single_vector ( READ , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( READ <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( WRITE
"
146,"CWE-264 int perf_event_task_disable ( void ) <S2SV_StartBug> { <S2SV_EndBug> struct perf_event * event ; mutex_lock ( & current -> perf_event_mutex ) ; <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_disable ) ; <S2SV_EndBug> mutex_unlock ( & current -> perf_event_mutex ) ; return 0 ; }
","<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
"
147,"CWE-125 static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , ""compressed<S2SV_blank>PPP<S2SV_blank>data"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( ppptype2str , ""unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; break ; } }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
"
148,"CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }
","<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; }
"
149,"CWE-119 static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
"
150,"CWE-476 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { <S2SV_StartBug> * head = NULL ; <S2SV_EndBug> * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR<S2SV_blank>"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }
","<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
"
151,"CWE-264 static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , struct user_namespace * user_ns , struct fs_struct * fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old = mnt_ns -> root ; struct mount * new ; int copy_flags ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; down_write ( & namespace_sem ) ; copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns -> user_ns ) <S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; br_write_unlock ( & vfsmount_lock ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; if ( fs ) { if ( & p -> mnt == fs -> root . mnt ) { fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == fs -> pwd . mnt ) { fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; } up_write ( & namespace_sem ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }
","<S2SV_ModStart> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED
"
152,"CWE-120 void test_base64_lengths ( void ) { const char * in = ""FuseMuse"" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , 0 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } out1 [ 0 ] = '\\0' ; <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , - 1 ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , exp ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , enclen ) ; } <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%zu"" , i ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu"" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( ""Expected:<S2SV_blank>%s"" , in ) ; TEST_MSG ( ""Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s"" , out2 ) ; } } }
","<S2SV_ModStart> out2 , out1 , sizeof ( out2 ) <S2SV_ModStart> out2 , out1 , sizeof ( out2 )
"
153,"CWE-362 static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; <S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; xen_evtchn_handle_events ( cpu ) ; BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = smp_processor_id ( ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ;
"
154,"CWE-254 static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
","<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
"
155,"CWE-770 int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ; <S2SV_StartBug> struct range * range ; <S2SV_EndBug> struct evbuffer * evb = NULL ; <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ; <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>*/%lld"" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ; <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ; goto abort ; } if ( nranges == 1 ) { <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , ""Content-Range"" , content_range ) == NULL ) goto abort ; <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> goto abort ; } else { <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> boundary = arc4random ( ) ; while ( nranges -- ) { if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud\\r\\n"" , boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" , media -> media_type , media -> media_subtype ) ) == - 1 ) goto abort ; content_length += i ; if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , range -> start , range -> end , st -> st_size ) ) == - 1 ) goto abort ; content_length += i ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; content_length += range -> end - range -> start + 1 ; <S2SV_StartBug> range ++ ; <S2SV_EndBug> } <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> ( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ; ( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> media = & multipart_media ; } <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> fd = - 1 ; ret = server_response_http ( clt , 206 , media , content_length , MINIMUM ( time ( NULL ) , st -> st_mtim . tv_sec ) ) ; switch ( ret ) { case - 1 : goto fail ; case 0 : <S2SV_StartBug> goto done ; <S2SV_EndBug> default : break ; } <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> clt -> clt_toread = TOREAD_HTTP_HEADER ; else clt -> clt_toread = TOREAD_HTTP_NONE ; clt -> clt_done = 0 ; done : evbuffer_free ( evb ) ; server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; bufferevent_free ( clt -> clt_bev ) ; clt -> clt_bev = NULL ; abort : <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> evbuffer_free ( evb ) ; if ( fd != - 1 ) close ( fd ) ; if ( errstr == NULL ) errstr = strerror ( errno ) ; server_abort_http ( clt , code , errstr ) ; return ( - 1 ) ; }
","<S2SV_ModStart> multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> ; size_t content_length <S2SV_ModStart> ; size_t content_length = 0 <S2SV_ModStart> nranges , ret <S2SV_ModEnd> ; char content_range <S2SV_ModStart> if ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , st <S2SV_ModStart> st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code <S2SV_ModStart> path ) ; r -> range_media = media ; <S2SV_ModEnd> if ( nranges <S2SV_ModStart> 1 ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret + <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret <S2SV_ModEnd> ; ( void <S2SV_ModStart> media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> ) ; media <S2SV_ModStart> multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = <S2SV_ModStart> case 0 : close ( fd ) ; <S2SV_ModStart> break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> <S2SV_ModStart> EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt <S2SV_ModStart> ; abort : <S2SV_ModEnd> if ( fd
"
156,"CWE-400 <S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> { <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ( cpu , ctrl <S2SV_ModEnd> ) ; }
"
157,"CWE-200 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }
","<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;
"
158,"CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , ""usb%d"" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , ""eth%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , ""wlan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , ""wwan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }
","<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
"
159,"CWE-20 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; <S2SV_StartBug> u32 offset ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
","<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
"
160,"CWE-119 TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }
","<S2SV_ModStart> return TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
"
161,"CWE-119 static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }
","<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
"
162,"CWE-125 <S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 0 ) { const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> fields -> BufferOffset <S2SV_ModStart> -> BufferOffset + ( UINT64 ) <S2SV_ModStart> fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length (
"
163,"CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; if ( u4_trailing_ones < 3 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : 1 ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = 2 + ( MIN ( u4_lev_prefix , 15 ) << 1 ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } } else { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = ( u4_lev_prefix - 3 ) ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } if ( u4_total_coeff < ( 16 - u4_isdc ) ) { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 16 ] = ( const UWORD8 ( * ) [ 16 ] ) gau1_ih264d_table_total_zero_11to15 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 4 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 11 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }
","<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
"
164,"CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && <S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }
","<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
"
165,"CWE-119 static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> const int mb_col = mi_col >> 1 ; const int idx_map = mb_row * cm -> mb_cols + mb_col ; const struct segmentation * const seg = & cm -> seg ; set_skip_context ( xd , mi_row , mi_col ) ; <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ; x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ; assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ; set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , cm -> mi_rows , cm -> mi_cols ) ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> if ( seg -> enabled ) { if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> } vp9_init_plane_quantizers ( cpi , x ) ; x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ; } else { mbmi -> segment_id = 0 ; x -> encode_breakout = cpi -> encode_breakout ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> const tile , MACROBLOCK * const x , <S2SV_ModStart> bsize ) { <S2SV_ModEnd> VP9_COMMON * const <S2SV_ModStart> ] ; const <S2SV_ModEnd> struct segmentation * <S2SV_ModStart> mi_col ) ; set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> vp9_setup_dst_planes ( xd -> plane <S2SV_ModStart> = cpi -> rd . <S2SV_ModStart> = cpi -> rd . <S2SV_ModStart> -> segment_id = get_segment_id <S2SV_ModEnd> ( cm , <S2SV_ModStart> encode_breakout ; } xd -> tile = * tile ;
"
166,"CWE-125 static inline signed short ReadPropertySignedShort ( const EndianType endian , const unsigned char * buffer ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
","<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return ( <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) buffer <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
"
167,"CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = ""Getting<S2SV_blank>sb<S2SV_blank>failed"" ; struct inode * inode ; struct path path ; <S2SV_StartBug> int rc ; <S2SV_EndBug> sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> if ( rc ) { err = ""Error<S2SV_blank>parsing<S2SV_blank>options"" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } s -> s_flags = flags ; rc = bdi_setup_and_register ( & sbi -> bdi , ""ecryptfs"" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = ""Reading<S2SV_blank>sb<S2SV_blank>failed"" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , ""kern_path()<S2SV_blank>failed\\n"" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR ""Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>"" ""eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>"" ""known<S2SV_blank>incompatibilities\\n"" ) ; goto out_free ; } <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_alloc_root ( inode ) ; if ( ! s -> s_root ) { iput ( inode ) ; rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; ecryptfs_set_dentry_lower ( s -> s_root , path . dentry ) ; ecryptfs_set_dentry_lower_mnt ( s -> s_root , path . mnt ) ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR ""%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , err , rc ) ; return ERR_PTR ( rc ) ; }
","<S2SV_ModStart> path path ; uid_t check_ruid ; <S2SV_ModStart> sbi , raw_data , & check_ruid <S2SV_ModStart> out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }
"
168,"CWE-119 char * path_name ( const struct name_path * path , const char * name ) { const struct name_path * p ; char * n , * m ; int nlen = strlen ( name ) ; int len = nlen + 1 ; for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) len += p -> elem_len + 1 ; } n = xmalloc ( len ) ; m = n + len - ( nlen + 1 ) ; <S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) { m -= p -> elem_len + 1 ; memcpy ( m , p -> elem , p -> elem_len ) ; m [ p -> elem_len ] = '/' ; } } return n ; }
","<S2SV_ModStart> 1 ) ; memcpy <S2SV_ModEnd> ( m , <S2SV_ModStart> m , name , nlen + 1
"
169,"CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }
","<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
"
170,"CWE-000 OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }
","<S2SV_ModStart> ; if ( ctx -> terminated ||
"
171,"CWE-532 static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , ""sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n"" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ; <S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , ""read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n"" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }
","<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status
"
172,"CWE-119 <S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }
","<S2SV_ModStart> int vp9_loop_filter_worker ( <S2SV_ModEnd> LFWorkerData * const <S2SV_ModStart> * const lf_data , void * unused ) { <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( void ) unused <S2SV_ModEnd> ; vp9_loop_filter_rows ( <S2SV_ModStart> -> cm , lf_data -> planes <S2SV_ModEnd> , lf_data ->
"
173,"CWE-190 int jas_memdump ( FILE * out , void * data , size_t len ) { size_t i ; size_t j ; <S2SV_StartBug> uchar * dp ; <S2SV_EndBug> dp = data ; for ( i = 0 ; i < len ; i += 16 ) { fprintf ( out , ""%04zx:"" , i ) ; for ( j = 0 ; j < 16 ; ++ j ) { if ( i + j < len ) { fprintf ( out , ""<S2SV_blank>%02x"" , dp [ i + j ] ) ; } } fprintf ( out , ""\\n"" ) ; } return 0 ; }
","<S2SV_ModStart> size_t j ; jas_uchar <S2SV_ModEnd> * dp ;
"
174,"CWE-476 int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , ""out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , ""Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n"" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> instance ) ; return - ENOMEM ; } return <S2SV_ModEnd> 0 ; }
"
175,"CWE-119 <S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats."" ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> get_frame_stats ( vpx_codec_ctx_t <S2SV_ModStart> stats ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
"
176,"CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE <S2SV_StartBug> if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { <S2SV_EndBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; <S2SV_StartBug> while ( i < npages ) { <S2SV_EndBug> struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
","<S2SV_ModStart> & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModStart> ; while ( ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModEnd> ) { struct
"
177,"CWE-310 static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) { EVP_CIPHER_CTX * ctx ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; VALUE pass , init_v ; if ( rb_scan_args ( argc , argv , ""02"" , & pass , & init_v ) > 0 ) { VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; rb_warn ( ""arguments<S2SV_blank>for<S2SV_blank>%"" PRIsVALUE ""#encrypt<S2SV_blank>and<S2SV_blank>%"" PRIsVALUE ""#decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>"" ""use<S2SV_blank>%"" PRIsVALUE ""#pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV"" , cname , cname , cname ) ; StringValue ( pass ) ; GetCipher ( self , ctx ) ; if ( NIL_P ( init_v ) ) memcpy ( iv , ""OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!"" , sizeof ( iv ) ) ; else { StringValue ( init_v ) ; if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; } else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; } EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; p_key = key ; p_iv = iv ; } else { GetCipher ( self , ctx ) ; } if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { ossl_raise ( eCipherError , NULL ) ; } <S2SV_StartBug> return self ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
"
178,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , rescale_intercept , rescale_slope , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; rescale_intercept = 0 ; rescale_slope = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : <S2SV_StartBug> { <S2SV_EndBug> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( depth ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; PixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { if ( signed_data ) pixel_value = ReadDCMSignedShort ( stream_info , image ) ; else pixel_value = ReadDCMShort ( stream_info , image ) ; if ( polarity != MagickFalse ) pixel_value = ( int ) max_value - pixel_value ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMSignedShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) index , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> } } SetPixelRed ( image , ( Quantum ) pixel . red , q ) ; SetPixelGreen ( image , ( Quantum ) pixel . green , q ) ; SetPixelBlue ( image , ( Quantum ) pixel . blue , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) ( ( ( size_t ) GetPixelIndex ( image , q ) ) | ( ( ( size_t ) index ) << 8 ) ) , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( image , ( Quantum ) ( ( ( size_t ) GetPixelRed ( image , q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( ( size_t ) GetPixelGreen ( image , q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( ( size_t ) GetPixelBlue ( image , q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0 ; i <= <S2SV_ModEnd> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> GetQuantumRange ( depth <S2SV_ModStart> GetQuantumRange ( depth <S2SV_ModEnd> ) ; i <S2SV_ModStart> NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
"
179,"CWE-125 static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { <S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ; pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
","<S2SV_ModStart> -> pirlvls ; if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
"
180,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> * bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++
"
181,"CWE-119 static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user * ) arg ; udest_compat = ( struct ip_vs_dest_user * ) ( usvc_compat + 1 ) ; ip_vs_copy_usvc_compat ( & usvc , usvc_compat ) ; ip_vs_copy_udest_compat ( & udest , udest_compat ) ; if ( cmd == IP_VS_SO_SET_ZERO ) { if ( ! usvc . fwmark && ! usvc . addr . ip && ! usvc . port ) { ret = ip_vs_zero_all ( ) ; goto out_unlock ; } } if ( usvc . protocol != IPPROTO_TCP && usvc . protocol != IPPROTO_UDP ) { pr_err ( ""set_ctl:<S2SV_blank>invalid<S2SV_blank>protocol:<S2SV_blank>%d<S2SV_blank>%pI4:%d<S2SV_blank>%s\\n"" , usvc . protocol , & usvc . addr . ip , ntohs ( usvc . port ) , usvc . sched_name ) ; ret = - EFAULT ; goto out_unlock ; } if ( usvc . fwmark == 0 ) svc = __ip_vs_service_get ( usvc . af , usvc . protocol , & usvc . addr , usvc . port ) ; else svc = __ip_vs_svc_fwm_get ( usvc . af , usvc . fwmark ) ; if ( cmd != IP_VS_SO_SET_ADD && ( svc == NULL || svc -> protocol != usvc . protocol ) ) { ret = - ESRCH ; goto out_unlock ; } switch ( cmd ) { case IP_VS_SO_SET_ADD : if ( svc != NULL ) ret = - EEXIST ; else ret = ip_vs_add_service ( & usvc , & svc ) ; break ; case IP_VS_SO_SET_EDIT : ret = ip_vs_edit_service ( svc , & usvc ) ; break ; case IP_VS_SO_SET_DEL : ret = ip_vs_del_service ( svc ) ; if ( ! ret ) goto out_unlock ; break ; case IP_VS_SO_SET_ZERO : ret = ip_vs_zero_service ( svc ) ; break ; case IP_VS_SO_SET_ADDDEST : ret = ip_vs_add_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_EDITDEST : ret = ip_vs_edit_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_DELDEST : ret = ip_vs_del_dest ( svc , & udest ) ; break ; default : ret = - EINVAL ; } if ( svc ) ip_vs_service_put ( svc ) ; out_unlock : mutex_unlock ( & __ip_vs_mutex ) ; out_dec : ip_vs_use_count_dec ( ) ; return ret ; }
","<S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (
"
182,"CWE-125 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
"
183,"CWE-000 <S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }
","<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock
"
184,"CWE-20 error_t enc624j600SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> { return ERROR_FAILURE ; } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , ENC624J600_EGPWRPT <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXST <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXLEN <S2SV_ModEnd> , length ) <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) ; return
"
185,"CWE-190 int jas_matrix_cmp ( jas_matrix_t * mat0 , jas_matrix_t * mat1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; if ( mat0 -> numrows_ != mat1 -> numrows_ || mat0 -> numcols_ != mat1 -> numcols_ ) { return 1 ; } for ( i = 0 ; i < mat0 -> numrows_ ; i ++ ) { for ( j = 0 ; j < mat0 -> numcols_ ; j ++ ) { if ( jas_matrix_get ( mat0 , i , j ) != jas_matrix_get ( mat1 , i , j ) ) { return 1 ; } } } return 0 ; }
","<S2SV_ModStart> mat1 ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; if
"
186,"CWE-119 static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , ""//"" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) <S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( strncmp ( file , ""../"" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , ""/../"" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , ""/.."" ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\\0' ; } }
","<S2SV_ModStart> , strlen ( cp <S2SV_ModEnd> ) - 1
"
187,"CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
","<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res
"
188,"CWE-119 int <S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> { struct vendor_attribute * attr ; <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> * data = attr -> attrib_data ; * len = attr -> attrib_len - 2 ; <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> }
","<S2SV_ModStart> u_int32_t * vendor , unsigned char * type <S2SV_ModStart> size_t * len , const void * raw , size_t raw_len <S2SV_ModStart> * attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> vendor_attribute * ) raw <S2SV_ModEnd> ; * vendor <S2SV_ModStart> -> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> - 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }
"
189,"CWE-19 void ext2_xattr_delete_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> down_write ( & EXT2_I ( inode ) -> xattr_sem ) ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } ea_bdebug ( bh , ""b_count=%d"" , atomic_read ( & ( bh -> b_count ) ) ) ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> lock_buffer ( bh ) ; if ( HDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ext2_free_blocks ( inode , EXT2_I ( inode ) -> i_file_acl , 1 ) ; get_bh ( bh ) ; bforget ( bh ) ; unlock_buffer ( bh ) ; } else { <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> if ( ce ) mb_cache_entry_release ( ce ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; unlock_buffer ( bh ) ; mark_buffer_dirty ( bh ) ; if ( IS_SYNC ( inode ) ) sync_dirty_buffer ( bh ) ; dquot_free_block_nodirty ( inode , 1 ) ; } EXT2_I ( inode ) -> i_file_acl = 0 ; cleanup : brelse ( bh ) ; up_write ( & EXT2_I ( inode ) -> xattr_sem ) ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> down_write ( & <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; ext2_free_blocks <S2SV_ModStart> , - 1 <S2SV_ModEnd> ) ; ea_bdebug
"
190,"CWE-400 static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; } pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; break ; } rcu_read_unlock ( ) ; if ( & ptype -> list == head ) goto normal ; same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; if ( pp ) { struct sk_buff * nskb = * pp ; * pp = nskb -> next ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; napi -> gro_count -- ; } if ( same_flow ) goto ok ; if ( NAPI_GRO_CB ( skb ) -> flush ) goto normal ; if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { struct sk_buff * nskb = napi -> gro_list ; while ( nskb -> next ) { pp = & nskb -> next ; nskb = * pp ; } * pp = NULL ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; } else { napi -> gro_count ++ ; } NAPI_GRO_CB ( skb ) -> count = 1 ; NAPI_GRO_CB ( skb ) -> age = jiffies ; NAPI_GRO_CB ( skb ) -> last = skb ; skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; skb -> next = napi -> gro_list ; napi -> gro_list = skb ; ret = GRO_HELD ; pull : grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; if ( grow > 0 ) gro_pull_from_frag0 ( skb , grow ) ; ok : return ret ; normal : ret = GRO_NORMAL ; goto pull ; }
","<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 0 ;
"
191,"CWE-125 int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; <S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }
","<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'
"
192,"CWE-189 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> 64 : 32 ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; }
"
193,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , ""picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n"" , s -> dst_tff ? ""up"" : ""down"" ) ; h = frame -> height ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size ) ; } else { memcpy ( data , data + line_step + line_step , line_size ) ; } data -= line_step ; } } } frame -> top_field_first = s -> dst_tff ; return ff_filter_frame ( outlink , frame ) ; }
","<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
"
194,"CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;
"
195,"CWE-20 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kzfree ( buf ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
"
196,"CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } <S2SV_StartBug> { <S2SV_EndBug> char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } <S2SV_StartBug> } <S2SV_EndBug> dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
","<S2SV_ModStart> ) ; } # if 0 <S2SV_ModStart> ; } } # endif
"
197,"CWE-552 static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags , <S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> oe_socklen_t * addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; <S2SV_StartBug> oe_socklen_t addrlen_in = 0 ; <S2SV_EndBug> oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen ) addrlen_in = * addrlen ; if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags , <S2SV_StartBug> ( struct oe_sockaddr * ) src_addr , <S2SV_EndBug> addrlen_in , <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> int flags , <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> ; oe_socklen_t addrlen_in = 0 ; oe_socklen_t addrlen_out <S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( src_addr && <S2SV_ModEnd> addrlen ) addrlen_in <S2SV_ModStart> , flags , <S2SV_ModEnd> src_addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( src_addr && addrlen ) { if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
"
198,"CWE-20 void initServerConfig ( ) { server . port = REDIS_SERVERPORT ; server . bindaddr = NULL ; server . unixsocket = NULL ; server . ipfd = - 1 ; server . sofd = - 1 ; server . dbnum = REDIS_DEFAULT_DBNUM ; server . verbosity = REDIS_VERBOSE ; server . maxidletime = REDIS_MAXIDLETIME ; server . saveparams = NULL ; server . loading = 0 ; server . logfile = NULL ; server . syslog_enabled = 0 ; server . syslog_ident = zstrdup ( ""redis"" ) ; server . syslog_facility = LOG_LOCAL0 ; server . glueoutputbuf = 1 ; server . daemonize = 0 ; server . appendonly = 0 ; server . appendfsync = APPENDFSYNC_EVERYSEC ; server . no_appendfsync_on_rewrite = 0 ; server . lastfsync = time ( NULL ) ; server . appendfd = - 1 ; server . appendseldb = - 1 ; server . pidfile = zstrdup ( ""/var/run/redis.pid"" ) ; server . dbfilename = zstrdup ( ""dump.rdb"" ) ; server . appendfilename = zstrdup ( ""appendonly.aof"" ) ; server . requirepass = NULL ; server . rdbcompression = 1 ; server . activerehashing = 1 ; server . maxclients = 0 ; server . bpop_blocked_clients = 0 ; server . maxmemory = 0 ; server . maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU ; server . maxmemory_samples = 3 ; <S2SV_StartBug> server . vm_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ; <S2SV_EndBug> server . vm_page_size = 256 ; server . vm_pages = 1024 * 1024 * 100 ; <S2SV_StartBug> server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> server . vm_max_threads = 4 ; server . vm_blocked_clients = 0 ; server . hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES ; server . hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE ; server . list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES ; server . list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE ; server . set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES ; server . shutdown_asap = 0 ; updateLRUClock ( ) ; resetServerSaveParams ( ) ; appendServerSaveParams ( 60 * 60 , 1 ) ; appendServerSaveParams ( 300 , 100 ) ; appendServerSaveParams ( 60 , 10000 ) ; server . isslave = 0 ; server . masterauth = NULL ; server . masterhost = NULL ; server . masterport = 6379 ; server . master = NULL ; server . replstate = REDIS_REPL_NONE ; server . repl_serve_stale_data = 1 ; R_Zero = 0.0 ; R_PosInf = 1.0 / R_Zero ; R_NegInf = - 1.0 / R_Zero ; R_Nan = R_Zero / R_Zero ; server . commands = dictCreate ( & commandTableDictType , NULL ) ; populateCommandTable ( ) ; server . delCommand = lookupCommandByCString ( ""del"" ) ; server . multiCommand = lookupCommandByCString ( ""multi"" ) ; }
","<S2SV_ModStart> ; server . ds_enabled = 0 ; server . ds_path <S2SV_ModEnd> = zstrdup ( <S2SV_ModStart> = zstrdup ( ""/tmp/redis.ds"" ) ; server . cache_max_memory = 64LL <S2SV_ModEnd> * 1024 * <S2SV_ModStart> 1024 * 1024 ; server . cache_blocked_clients <S2SV_ModEnd> = 0 ;
"
199,"CWE-362 int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; <S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> vma -> vm_file ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> ; out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
"
200,"CWE-787 <S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ; <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ; <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> { <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT <S2SV_ModStart> UINT16 y ; <S2SV_ModEnd> UINT32 tempWidth ; <S2SV_ModStart> ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ++ ) { BYTE * <S2SV_ModStart> 1 ) ; BYTE * <S2SV_ModStart> 1 ) ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> + tempWidth ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> ; } } return TRUE ;
"
201,"CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( file_printf ( ms , "",<S2SV_blank>%s<S2SV_blank>Endian"" , si . si_byte_order == 0xfffe ? ""Little"" : ""Big"" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d"" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d"" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , "",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d"" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> free ( info ) ; return m == - 1 ? - 2 : m ; }
","<S2SV_ModStart> sst , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { cdf_summary_info_header_t <S2SV_ModStart> break ; } if ( root_storage ) { <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc ) <S2SV_ModStart> - 2 ; } <S2SV_ModStart> , count , root_storage <S2SV_ModEnd> ) ; free
"
202,"CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
"
203,"CWE-190 static void Process_ipfix_template_withdraw ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { ipfix_template_record_t * ipfix_template_record ; while ( size_left ) { <S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; id = ntohs ( ipfix_template_record -> TemplateID ) ; if ( id == IPFIX_TEMPLATE_FLOWSET_ID ) { remove_all_translation_tables ( exporter ) ; ReInitExtensionMapList ( fs ) ; } else { remove_translation_table ( fs , exporter , id ) ; } DataPtr = DataPtr + 4 ; if ( size_left < 4 ) { dbg_printf ( ""Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n"" , size_left ) ; size_left = 0 ; } } }
","<S2SV_ModStart> uint32_t id ; if ( size_left < 4 ) { LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
"
204,"CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n"" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( ""RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n"" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n"" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n"" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }
","<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
"
205,"CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }
","<S2SV_ModStart> ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,
"
206,"CWE-400 int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = FPUSTATE ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > ASI_SNFL ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
"
207,"CWE-399 static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE ""rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>"" ""extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n"" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; <S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n"" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }
","<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
"
208,"CWE-119 void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( seg ->
"
209,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }
","<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
"
210,"CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
"
211,"CWE-416 static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ; goto out ; } sin . sin_family = AF_INET ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; sin . sin_port = usin -> sin6_port ; err = __ip4_datagram_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; ipv4_connected : if ( err ) goto out ; ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; if ( ipv6_addr_any ( & np -> saddr ) || ipv6_mapped_addr_any ( & np -> saddr ) ) ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , & sk -> sk_v6_rcv_saddr ) ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } goto out ; } if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { err = - EINVAL ; goto out ; } sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) sk -> sk_bound_dev_if = np -> mcast_oif ; if ( ! sk -> sk_bound_dev_if ) { err = - EINVAL ; goto out ; } } sk -> sk_v6_daddr = * daddr ; np -> flow_label = fl6 . flowlabel ; inet -> inet_dport = usin -> sin6_port ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) fl6 . flowi6_oif = np -> mcast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; err = 0 ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( ipv6_addr_any ( & np -> saddr ) ) np -> saddr = fl6 . saddr ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { sk -> sk_v6_rcv_saddr = fl6 . saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; sk -> sk_state = TCP_ESTABLISHED ; sk_set_txhash ( sk ) ; out : fl6_sock_release ( flowlabel ) ; return err ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> opt : rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock (
"
212,"CWE-200 static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq ( & port -> lock ) ; memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ; icount . dcd = cnow . dcd ; icount . rx = cnow . rx ; icount . tx = cnow . tx ; icount . frame = cnow . frame ; icount . overrun = cnow . overrun ; icount . parity = cnow . parity ; icount . brk = cnow . brk ; icount . buf_overrun = cnow . buf_overrun ; return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; }
","<S2SV_ModStart> struct serial_icounter_struct icount = { }
"
213,"CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }
","<S2SV_ModStart> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !
"
214,"CWE-264 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( ""/dev/null"" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio"" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""chdir()"" ) ; _exit ( 127 ) ; } <S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> uv__write_int ( error_fd , - errno ) ; perror ( ""setgid()"" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""setuid()"" ) ; _exit ( 127 ) ; } if ( options -> env != NULL ) { environ = options -> env ; } execvp ( options -> file , options -> args ) ; uv__write_int ( error_fd , - errno ) ; perror ( ""execvp()"" ) ; _exit ( 127 ) ; }
","<S2SV_ModStart> } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
"
215,"CWE-000 BIO * PKCS7_dataDecode ( PKCS7 * p7 , EVP_PKEY * pkey , BIO * in_bio , X509 * pcert ) { int i , j ; BIO * out = NULL , * btmp = NULL , * etmp = NULL , * bio = NULL ; X509_ALGOR * xa ; ASN1_OCTET_STRING * data_body = NULL ; const EVP_MD * evp_md ; const EVP_CIPHER * evp_cipher = NULL ; EVP_CIPHER_CTX * evp_ctx = NULL ; X509_ALGOR * enc_alg = NULL ; STACK_OF ( X509_ALGOR ) * md_sk = NULL ; STACK_OF ( PKCS7_RECIP_INFO ) * rsk = NULL ; PKCS7_RECIP_INFO * ri = NULL ; unsigned char * ek = NULL , * tkey = NULL ; int eklen = 0 , tkeylen = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; } i = OBJ_obj2nid ( p7 -> type ) ; p7 -> state = PKCS7_S_HEADER ; switch ( i ) { case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ; if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ; goto err ; } md_sk = p7 -> d . sign -> md_algs ; break ; case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ; md_sk = p7 -> d . signed_and_enveloped -> md_algs ; data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ; enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ; enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ; data_body = p7 -> d . enveloped -> enc_data -> enc_data ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } <S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> for ( i = 0 ; i < sk_X509_ALGOR_num ( md_sk ) ; i ++ ) { xa = sk_X509_ALGOR_value ( md_sk , i ) ; if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } j = OBJ_obj2nid ( xa -> algorithm ) ; evp_md = EVP_get_digestbynid ( j ) ; if ( evp_md == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ; goto err ; } BIO_set_md ( btmp , evp_md ) ; if ( out == NULL ) out = btmp ; else BIO_push ( out , btmp ) ; btmp = NULL ; } } if ( evp_cipher != NULL ) { if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } if ( pcert ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ; ri = NULL ; } if ( ri == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ; goto err ; } } if ( pcert == NULL ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } } else { if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } evp_ctx = NULL ; BIO_get_cipher_ctx ( etmp , & evp_ctx ) ; if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ; if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) { if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) { OPENSSL_clear_free ( ek , eklen ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ; OPENSSL_clear_free ( ek , eklen ) ; ek = NULL ; OPENSSL_clear_free ( tkey , tkeylen ) ; tkey = NULL ; if ( out == NULL ) out = etmp ; else BIO_push ( out , etmp ) ; etmp = NULL ; } <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> bio = in_bio ; } else { if ( data_body -> length > 0 ) bio = BIO_new_mem_buf ( data_body -> data , data_body -> length ) ; else { bio = BIO_new ( BIO_s_mem ( ) ) ; BIO_set_mem_eof_return ( bio , 0 ) ; } if ( bio == NULL ) goto err ; } BIO_push ( out , bio ) ; bio = NULL ; return out ; err : OPENSSL_clear_free ( ek , eklen ) ; OPENSSL_clear_free ( tkey , tkeylen ) ; BIO_free_all ( out ) ; BIO_free_all ( btmp ) ; BIO_free_all ( etmp ) ; BIO_free_all ( bio ) ; return NULL ; }
","<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
"
216,"CWE-000 int assoc_array_gc ( struct assoc_array * array , const struct assoc_array_ops * ops , bool ( * iterator ) ( void * object , void * iterator_data ) , void * iterator_data ) { struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; unsigned long nr_leaves_on_tree ; int keylen , slot , nr_free , next_slot , i ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; if ( ! array -> root ) return 0 ; edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; if ( ! edit ) return - ENOMEM ; edit -> array = array ; edit -> ops = ops ; edit -> ops_for_excised_subtree = ops ; edit -> set [ 0 ] . ptr = & array -> root ; edit -> excised_subtree = array -> root ; new_root = new_parent = NULL ; new_ptr_pp = & new_root ; cursor = array -> root ; descend : if ( assoc_array_ptr_is_shortcut ( cursor ) ) { shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s ) goto enomem ; pr_devel ( ""dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , shortcut , new_s ) ; memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ) ; new_s -> back_pointer = new_parent ; new_s -> parent_slot = shortcut -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; new_ptr_pp = & new_s -> next_node ; cursor = shortcut -> next_node ; } node = assoc_array_ptr_to_node ( cursor ) ; new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n ) goto enomem ; pr_devel ( ""dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n"" , node , new_n ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = node -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; new_ptr_pp = NULL ; slot = 0 ; continue_node : for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = node -> slots [ slot ] ; if ( ! ptr ) continue ; if ( assoc_array_ptr_is_leaf ( ptr ) ) { if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) ) new_n -> slots [ slot ] = ptr ; continue ; } new_ptr_pp = & new_n -> slots [ slot ] ; cursor = ptr ; goto descend ; } pr_devel ( ""--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\n"" , new_n ) ; new_n -> nr_leaves_on_branch = 0 ; nr_free = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = new_n -> slots [ slot ] ; if ( ! ptr ) nr_free ++ ; else if ( assoc_array_ptr_is_leaf ( ptr ) ) new_n -> nr_leaves_on_branch ++ ; } pr_devel ( ""free=%d,<S2SV_blank>leaves=%lu\\n"" , nr_free , new_n -> nr_leaves_on_branch ) ; next_slot = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ] ; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) continue ; s = NULL ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { s = assoc_array_ptr_to_shortcut ( ptr ) ; ptr = s -> next_node ; } child = assoc_array_ptr_to_node ( ptr ) ; new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { pr_devel ( ""[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; BUG_ON ( s ) ; new_n -> slots [ slot ] = NULL ; nr_free ++ ; if ( slot < next_slot ) next_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p ) continue ; BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; while ( new_n -> slots [ next_slot ] ) next_slot ++ ; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n -> slots [ next_slot ++ ] = p ; nr_free -- ; } kfree ( child ) ; } else { pr_devel ( ""[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n"" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; } } pr_devel ( ""after:<S2SV_blank>%lu\\n"" , new_n -> nr_leaves_on_branch ) ; nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) if ( ( ptr = new_n -> slots [ slot ] ) ) break ; if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) ) { pr_devel ( ""excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\n"" , new_n ) ; new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_n -> back_pointer ; slot = new_n -> parent_slot ; kfree ( new_n ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; pr_devel ( ""excise<S2SV_blank>preceding<S2SV_blank>shortcut\\n"" ) ; new_parent = new_s -> back_pointer = s -> back_pointer ; slot = new_s -> parent_slot = s -> parent_slot ; kfree ( s ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } } new_s -> back_pointer = new_parent ; new_s -> parent_slot = slot ; new_n = assoc_array_ptr_to_node ( new_parent ) ; new_n -> slots [ slot ] = ptr ; goto ascend_old_tree ; } } ptr = new_n -> back_pointer ; if ( ! ptr ) goto gc_complete ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_s -> back_pointer ; slot = new_s -> parent_slot ; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { struct assoc_array_node * n ; pr_devel ( ""excise<S2SV_blank>shortcut\\n"" ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = slot ; kfree ( new_s ) ; if ( ! new_parent ) { new_root = assoc_array_node_to_ptr ( new_n ) ; goto gc_complete ; } n = assoc_array_ptr_to_node ( new_parent ) ; n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; } } else { new_parent = ptr ; } new_n = assoc_array_ptr_to_node ( new_parent ) ; ascend_old_tree : ptr = node -> back_pointer ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; slot = shortcut -> parent_slot ; cursor = shortcut -> back_pointer ; <S2SV_StartBug> } else { <S2SV_EndBug> slot = node -> parent_slot ; cursor = ptr ; } <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> node = assoc_array_ptr_to_node ( cursor ) ; slot ++ ; goto continue_node ; gc_complete : edit -> set [ 0 ] . to = new_root ; assoc_array_apply_edit ( edit ) ; array -> nr_leaves_on_tree = nr_leaves_on_tree ; return 0 ; enomem : pr_devel ( ""enomem\\n"" ) ; assoc_array_destroy_subtree ( new_root , edit -> ops ) ; kfree ( edit ) ; return - ENOMEM ; }
","<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node
"
217,"CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
"
218,"CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
"
219,"CWE-787 static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( ""reverseSamplesBytes"" , ""Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer"" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( ""reverseSamplesBytes"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }
","<S2SV_ModStart> / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; }
"
220,"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
","<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
"
221,"CWE-119 static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = NULL ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map"" ) ; }
","<S2SV_ModStart> map = { 0 , 0 ,
"
222,"CWE-20 long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = NULL ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - EINVAL ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - EACCES ; down_write ( & key -> sem ) ; if ( ! capable ( CAP_SYS_ADMIN ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - ENOMEM ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - EDQUOT ; goto error_put ; }
","<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
"
223,"CWE-416 GF_Err audio_sample_entry_Read ( GF_Box * s , GF_BitStream * bs ) { GF_MPEGAudioSampleEntryBox * ptr ; char * data ; u8 a , b , c , d ; u32 i , size , v , nb_alnum ; GF_Err e ; u64 pos , start ; ptr = ( GF_MPEGAudioSampleEntryBox * ) s ; start = gf_bs_get_position ( bs ) ; gf_bs_seek ( bs , start + 8 ) ; v = gf_bs_read_u16 ( bs ) ; if ( v ) ptr -> is_qtff = 1 ; if ( v == 1 ) { gf_bs_seek ( bs , start + 8 + 20 + 4 ) ; a = gf_bs_read_u8 ( bs ) ; b = gf_bs_read_u8 ( bs ) ; c = gf_bs_read_u8 ( bs ) ; d = gf_bs_read_u8 ( bs ) ; nb_alnum = 0 ; if ( isalnum ( a ) ) nb_alnum ++ ; if ( isalnum ( b ) ) nb_alnum ++ ; if ( isalnum ( c ) ) nb_alnum ++ ; if ( isalnum ( d ) ) nb_alnum ++ ; if ( nb_alnum > 2 ) ptr -> is_qtff = 0 ; } gf_bs_seek ( bs , start ) ; e = gf_isom_audio_sample_entry_read ( ( GF_AudioSampleEntryBox * ) s , bs ) ; if ( e ) return e ; pos = gf_bs_get_position ( bs ) ; size = ( u32 ) s -> size ; if ( gf_bs_get_cookie ( bs ) ) { ptr -> is_qtff |= 1 << 16 ; } e = gf_isom_box_array_read ( s , bs , audio_sample_entry_AddBox ) ; if ( ! e ) return GF_OK ; if ( size < 8 ) return GF_ISOM_INVALID_FILE ; gf_bs_seek ( bs , pos ) ; data = ( char * ) gf_malloc ( sizeof ( char ) * size ) ; gf_bs_read_data ( bs , data , size ) ; for ( i = 0 ; i < size - 8 ; i ++ ) { if ( GF_4CC ( ( u32 ) data [ i + 4 ] , ( u8 ) data [ i + 5 ] , ( u8 ) data [ i + 6 ] , ( u8 ) data [ i + 7 ] ) == GF_ISOM_BOX_TYPE_ESDS ) { <S2SV_StartBug> GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ; <S2SV_EndBug> if ( ptr -> esd ) { <S2SV_StartBug> gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; <S2SV_EndBug> ptr -> esd = NULL ; } e = gf_isom_box_parse ( ( GF_Box * * ) & ptr -> esd , mybs ) ; if ( e == GF_OK ) { gf_isom_box_add_for_dump_mode ( ( GF_Box * ) ptr , ( GF_Box * ) ptr -> esd ) ; } else if ( ptr -> esd ) { gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; ptr -> esd = NULL ; } gf_bs_del ( mybs ) ; break ; } } gf_free ( data ) ; return e ; }
","<S2SV_ModStart> GF_ISOM_BOX_TYPE_ESDS ) { extern Bool use_dump_mode ; <S2SV_ModStart> esd ) { if ( ! use_dump_mode )
"
224,"CWE-119 <S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int frame_filter_level , int y_only , int partial_frame ) { int start_mi_row , end_mi_row , mi_rows_to_filter ; if ( ! frame_filter_level ) return ; start_mi_row = 0 ; mi_rows_to_filter = cm -> mi_rows ; if ( partial_frame && cm -> mi_rows > 8 ) { start_mi_row = cm -> mi_rows >> 1 ; start_mi_row &= 0xfffffff8 ; mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ; } end_mi_row = start_mi_row + mi_rows_to_filter ; vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> start_mi_row , end_mi_row , y_only ) ; }
","<S2SV_ModStart> void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> ; vp9_loop_filter_rows ( frame <S2SV_ModEnd> , cm , <S2SV_ModStart> cm , xd -> plane
"
225,"CWE-835 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , ""No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , ""skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n"" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n"" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }
","<S2SV_ModStart> ; int just_opened = 0 ; int reload_count <S2SV_ModStart> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
"
226,"CWE-362 struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }
","<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
"
227,"CWE-399 static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; <S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }
","<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
"
228,"CWE-20 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; <S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> srose -> srose_family = AF_ROSE ; srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
"
229,"CWE-20 static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
"
230,"CWE-352 char * Util_monitId ( char * idfile ) { <S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> ASSERT ( idfile ) ; if ( ! File_exist ( idfile ) ) { <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> char buf [ STRLEN ] ; MD_T digest ; file = fopen ( idfile , ""w"" ) ; if ( ! file ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> md5_init ( & ctx ) ; md5_append ( & ctx , ( const md5_byte_t * ) buf , STRLEN - 1 ) ; md5_finish ( & ctx , ( md5_byte_t * ) digest ) ; Util_digest2Bytes ( ( unsigned char * ) digest , 16 , Run . id ) ; <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug> LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\n<S2SV_blank>Stored<S2SV_blank>in<S2SV_blank>\'%s\'\\n"" , Run . id , idfile ) ; } else { if ( ! File_isFile ( idfile ) ) { LogError ( ""idfile<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\n"" , idfile ) ; return NULL ; } if ( ( file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) { LogError ( ""Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } if ( fscanf ( file , ""%64s"" , Run . id ) != 1 ) { LogError ( ""Error<S2SV_blank>reading<S2SV_blank>id<S2SV_blank>from<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , idfile ) ; if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return NULL ; } } if ( fclose ( file ) ) LogError ( ""Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n"" , idfile , STRERROR ) ; return Run . id ; }
","<S2SV_ModStart> idfile ) { ASSERT ( idfile ) ; <S2SV_ModStart> file = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> file = fopen <S2SV_ModStart> NULL ; } <S2SV_ModEnd> fprintf ( file <S2SV_ModStart> , ""%s"" , Util_getToken ( Run . id ) <S2SV_ModEnd> ) ; LogInfo
"
231,"CWE-119 void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter = get_flc ( 1 , stream ) ; } decoder_info -> bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> bitdepth == 10 ) decoder_info -> bitdepth += 2 * get_flc ( 1 , stream ) ; decoder_info -> input_bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> input_bitdepth == 10 ) decoder_info -> input_bitdepth += 2 * get_flc ( 1 , stream ) ; }
","<S2SV_ModStart> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )
"
232,"CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SPS_PPS_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } <S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
","<S2SV_ModStart> pv_parse_tu_coeff_data ; } <S2SV_ModEnd> if ( u1_slice_type
"
233,"CWE-772 generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( ""kadm5_delete_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_delete_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
234,"CWE-000 struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n"" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n"" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n"" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n"" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( ""Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n"" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( ""Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n"" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
"
235,"CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
"
236,"CWE-362 int my_redel ( const char * org_name , const char * tmp_name , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( ""my_redel"" ) ; DBUG_PRINT ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + 20 ] ; char ext [ 20 ] ; ext [ 0 ] = '-' ; get_date ( ext + 1 , 2 + 4 , ( time_t ) 0 ) ; strmov ( strend ( ext ) , REDEL_EXT ) ; if ( my_rename ( org_name , fn_format ( name_buff , org_name , """" , ext , 2 ) , MyFlags ) ) goto end ; } else if ( my_delete_allow_opened ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }
","<S2SV_ModStart> ; if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> goto end ; }
"
237,"CWE-404 static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; }
","<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
"
238,"CWE-369 static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
","<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
"
239,"CWE-772 static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , ""%.*s"" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }
","<S2SV_ModStart> hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }
"
240,"CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { <S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> low ) ; }
"
241,"CWE-125 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\n"" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\n"" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file"" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid"" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>@<S2SV_blank>%"" PRIu64 ""<S2SV_blank>has<S2SV_blank>%"" PRIu16 ""<S2SV_blank>records\\n"" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%"" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; <S2SV_StartBug> if ( ( keylen ) > nodesize ) { <S2SV_EndBug> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" <S2SV_StartBug> PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; <S2SV_EndBug> free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d"" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node"" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf"" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(%"" PRIu64 "")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%"" PRIu8 "")"" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
","<S2SV_ModStart> ; if ( keylen >= nodesize - rec_off <S2SV_ModEnd> ) { tsk_error_set_errno <S2SV_ModStart> , keylen , ( nodesize - rec_off ) <S2SV_ModEnd> ) ; free
"
242,"CWE-264 static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; <S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ; return false ; }
","<S2SV_ModStart> ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return
"
243,"CWE-20 error_t enc624j600SoftReset ( NetInterface * interface ) { do { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ; <S2SV_EndBug> sleep ( 1 ) ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 ) <S2SV_EndBug> { return ERROR_FAILURE ; } sleep ( 1 ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> , 0x1234 ) <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x1234 <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY <S2SV_ModEnd> ) == 0 <S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST <S2SV_ModEnd> ) ; sleep <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x0000
"
244,"CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ret -> size = size ; return ret ; }
","<S2SV_ModStart> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> ; ret ->
"
245,"CWE-190 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( ""invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n"" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }
","<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
"
246,"CWE-120 enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( ""Authenticating<S2SV_blank>(CRAM-MD5)..."" ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , ""AUTHENTICATE<S2SV_blank>CRAM-MD5"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n"" , ibuf ) ; goto bail ; } <S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> if ( len == - 1 ) { mutt_debug ( 1 , ""Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n"" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , ""CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n"" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , ""%s<S2SV_blank>"" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , ""CRAM<S2SV_blank>response:<S2SV_blank>%s\\n"" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , ""Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( ""CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }
","<S2SV_ModStart> buf + 2 , sizeof ( obuf )
"
247,"CWE-362 fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , ""localhost"" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <S2SV_StartBug> return res ; <S2SV_EndBug> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }
","<S2SV_ModStart> ; } } cleanup : <S2SV_ModEnd> return res ;
"
248,"CWE-119 static void fwnet_receive_broadcast ( struct fw_iso_context * context , u32 cycle , size_t header_length , void * header , void * data ) { struct fwnet_device * dev ; struct fw_iso_packet packet ; __be16 * hdr_ptr ; __be32 * buf_ptr ; int retval ; u32 length ; <S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> u32 specifier_id ; u32 ver ; unsigned long offset ; unsigned long flags ; dev = data ; hdr_ptr = header ; length = be16_to_cpup ( hdr_ptr ) ; spin_lock_irqsave ( & dev -> lock , flags ) ; offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ; buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ; if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ; ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ; source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ; if ( specifier_id == IANA_SPECIFIER_ID && <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> # if IS_ENABLED ( CONFIG_IPV6 ) <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> # endif <S2SV_StartBug> ) ) { <S2SV_EndBug> buf_ptr += 2 ; length -= IEEE1394_GASP_HDR_SIZE ; fwnet_incoming_packet ( dev , buf_ptr , length , source_node_id , context -> card -> generation , true ) ; <S2SV_StartBug> } <S2SV_EndBug> packet . payload_length = dev -> rcv_buffer_size ; packet . interrupt = 1 ; packet . skip = 0 ; packet . tag = 3 ; packet . sy = 0 ; packet . header_length = IEEE1394_GASP_HDR_SIZE ; spin_lock_irqsave ( & dev -> lock , flags ) ; retval = fw_iso_context_queue ( dev -> broadcast_rcv_context , & packet , & dev -> broadcast_rcv_buffer , offset ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; if ( retval >= 0 ) fw_iso_context_queue_flush ( dev -> broadcast_rcv_context ) ; else dev_err ( & dev -> netdev -> dev , ""requeue<S2SV_blank>failed\\n"" ) ; }
","<S2SV_ModStart> u32 length ; <S2SV_ModEnd> unsigned long offset <S2SV_ModStart> flags ) ; if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> == IANA_SPECIFIER_ID && <S2SV_ModStart> IANA_SPECIFIER_ID && ( gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC2734_SW_VERSION # <S2SV_ModStart> CONFIG_IPV6 ) || gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC3146_SW_VERSION # <S2SV_ModStart> endif ) ) fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> , context -> <S2SV_ModStart> true ) ; <S2SV_ModEnd> packet . payload_length
"
249,"CWE-200 int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ; <S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( ""Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n"" , rr -> u . NM . flags ) ; break ; } <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> truncate = 1 ; break ; } <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
","<S2SV_ModStart> = 0 ; char * p ; int len ; <S2SV_ModStart> break ; } len = <S2SV_ModEnd> rr -> len <S2SV_ModStart> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> <S2SV_ModStart> . name , len <S2SV_ModEnd> ) ; retnamlen <S2SV_ModStart> ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ;
"
250,"CWE-415 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , ""\\x3F\\x00"" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , ""received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n"" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , ""invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n"" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }
","<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;
"
251,"CWE-287 static int unix_dgram_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie tmp_scm ; int max_level ; int data_len = 0 ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( siocb -> scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; unix_get_secdata ( siocb -> scm , skb ) ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iovec ( skb , 0 , msg -> msg_iov , 0 , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } unix_state_lock ( other ) ; err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = 0 ; unix_state_lock ( sk ) ; if ( unix_peer ( sk ) == other ) { unix_peer ( sk ) = NULL ; unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { if ( ! timeo ) { err = - EAGAIN ; goto out_unlock ; } timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , len ) ; sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return len ; out_unlock : unix_state_unlock ( other ) ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return err ; }
","<S2SV_ModStart> siocb -> scm , false
"
252,"CWE-416 void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
","<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
"
253,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args <S2SV_ModStart> ; # else ( void ) ctx ; ( void ) args ;
"
254,"CWE-17 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }
","<S2SV_ModStart> 2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd
"
255,"CWE-362 static int set_evtchn_to_irq ( evtchn_port_t evtchn , unsigned int irq ) { unsigned row ; unsigned col ; if ( evtchn >= xen_evtchn_max_channels ( ) ) return - EINVAL ; row = EVTCHN_ROW ( evtchn ) ; col = EVTCHN_COL ( evtchn ) ; if ( evtchn_to_irq [ row ] == NULL ) { if ( irq == - 1 ) return 0 ; evtchn_to_irq [ row ] = ( int * ) get_zeroed_page ( GFP_KERNEL ) ; if ( evtchn_to_irq [ row ] == NULL ) return - ENOMEM ; clear_evtchn_to_irq_row ( row ) ; } <S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ) ; } WRITE_ONCE ( <S2SV_ModStart> [ col ] , irq ) <S2SV_ModEnd> ; return 0
"
256,"CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( ""Wrong<S2SV_blank>len<S2SV_blank>argument\\n"" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( ""Entries_size<S2SV_blank>never<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( ""Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n"" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }
","<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
"
257,"CWE-125 static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; <S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; nstrips32 = ( uint32 ) nstrips64 ; <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ; <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> offset += stripbytes ; bytecount -= stripbytes ; } <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }
","<S2SV_ModStart> uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip <S2SV_ModStart> ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> newcounts = ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; strip < nstrips <S2SV_ModEnd> ; strip ++ <S2SV_ModStart> strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += <S2SV_ModStart> -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField (
"
258,"CWE-119 static Image * ReadGRAYImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( size_t ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , GRAYColorspace ) ; canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_type = GrayQuantum ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } scene = 0 ; count = 0 ; length = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register ssize_t x ; register PixelPacket * restrict q ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
259,"CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }
","<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
"
260,"CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }
","<S2SV_ModStart> u64 ) len - s
"
261,"CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
"
262,"CWE-835 static enum rules_token lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) { <S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , ""unterminated<S2SV_blank>keysym<S2SV_blank>literal"" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""keysym<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , \'\\""\' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != \'\\""\' ) { if ( chr ( s , '\\\\' ) ) { uint8_t o ; if ( chr ( s , '\\\\' ) ) { buf_append ( s , '\\\\' ) ; } else if ( chr ( s , \'""\' ) ) { buf_append ( s , \'""\' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , ""illegal<S2SV_blank>hexadecimal<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal"" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , ""unknown<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>(%c)<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal"" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , \'\\""\' ) ) { scanner_err ( s , ""unterminated<S2SV_blank>string<S2SV_blank>literal"" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , ""string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>UTF-8<S2SV_blank>string"" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , ""identifier<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , ""include"" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , ""unrecognized<S2SV_blank>token"" ) ; return TOK_ERROR ; }
","<S2SV_ModStart> ( s ) && ! eof ( s )
"
263,"CWE-189 static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }
","<S2SV_ModStart> <= w - ( int )
"
264,"CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
"
265,"CWE-119 int effect_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { effect_context_t * context = ( effect_context_t * ) self ; int retsize ; int status = 0 ; pthread_mutex_lock ( & lock ) ; if ( ! effect_exists ( context ) ) { status = - ENOSYS ; goto exit ; } if ( context == NULL || context -> state == EFFECT_STATE_UNINITIALIZED ) { status = - ENOSYS ; goto exit ; } switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> ops . init ) * ( int * ) pReplyData = context -> ops . init ( context ) ; else * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } * ( int * ) pReplyData = set_config ( context , ( effect_config_t * ) pCmdData ) ; break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { status = - EINVAL ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } get_config ( context , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : if ( context -> ops . reset ) context -> ops . reset ( context ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_INITIALIZED ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_ACTIVE ; if ( context -> ops . enable ) context -> ops . enable ( context ) ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_ENABLE"" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_ACTIVE ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_INITIALIZED ; if ( context -> ops . disable ) context -> ops . disable ( context ) ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_DISABLE"" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + <S2SV_StartBug> sizeof ( uint16_t ) ) ) { <S2SV_EndBug> status = - EINVAL ; ALOGV ( ""EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , cmdSize , * replySize ) ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } effect_param_t * q = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + q -> psize ) ; effect_param_t * p = ( effect_param_t * ) pReplyData ; if ( context -> ops . get_parameter ) context -> ops . get_parameter ( context , p , replySize ) ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { status = - EINVAL ; ALOGV ( ""EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d"" , cmdSize , * replySize ) ; goto exit ; } * ( int32_t * ) pReplyData = 0 ; effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( context -> ops . set_parameter ) * ( int32_t * ) pReplyData = context -> ops . set_parameter ( context , p , * replySize ) ; } break ; case EFFECT_CMD_SET_DEVICE : { uint32_t device ; ALOGV ( ""\\t<S2SV_blank>EFFECT_CMD_SET_DEVICE<S2SV_blank>start"" ) ; if ( pCmdData == NULL || cmdSize < sizeof ( uint32_t ) ) { status = - EINVAL ; ALOGV ( ""EFFECT_CMD_SET_DEVICE<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d"" , cmdSize ) ; goto exit ; } device = * ( uint32_t * ) pCmdData ; if ( context -> ops . set_device ) context -> ops . set_device ( context , device ) ; } break ; case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : break ; case EFFECT_CMD_OFFLOAD : { output_context_t * out_ctxt ; if ( cmdSize != sizeof ( effect_offload_param_t ) || pCmdData == NULL || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>bad<S2SV_blank>format"" , __func__ ) ; status = - EINVAL ; break ; } effect_offload_param_t * offload_param = ( effect_offload_param_t * ) pCmdData ; ALOGV ( ""%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>offload<S2SV_blank>%d<S2SV_blank>output<S2SV_blank>%d"" , __func__ , offload_param -> isOffload , offload_param -> ioHandle ) ; * ( int * ) pReplyData = 0 ; context -> offload_enabled = offload_param -> isOffload ; if ( context -> out_handle == offload_param -> ioHandle ) break ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) remove_effect_from_output ( out_ctxt , context ) ; context -> out_handle = offload_param -> ioHandle ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) add_effect_to_output ( out_ctxt , context ) ; } break ; default : if ( cmdCode >= EFFECT_CMD_FIRST_PROPRIETARY && context -> ops . command ) status = context -> ops . command ( context , cmdCode , cmdSize , pCmdData , replySize , pReplyData ) ; else { ALOGW ( ""%s<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%d"" , __func__ , cmdCode ) ; status = - EINVAL ; } break ; } exit : pthread_mutex_unlock ( & lock ) ; return status ; }
","<S2SV_ModStart> ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t
"
266,"CWE-000 struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }
","<S2SV_ModStart> return map ; map =
"
267,"CWE-000 int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = OCFS2_SB ( sb ) ; struct buffer_head * bh = NULL ; handle_t * handle = NULL ; struct dquot * transfer_to [ MAXQUOTAS ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( S_ISLNK ( inode -> i_mode ) ) attr -> ia_valid &= ~ ATTR_SIZE ; # define OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; if ( size_change ) { <S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ML_ERROR , ""Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n"" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - ENOSPC ) mlog_errno ( status ) ; status = - ENOSPC ; goto bail_unlock ; } } if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & ATTR_MODE ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }
","<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
"
268,"CWE-77 void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }
","<S2SV_ModStart> dlen , buf , false
"
269,"CWE-119 int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= USECS_PER_SEC ) return - 1 ; # else if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= 1 ) return - 1 ; # endif return 0 ; }
","<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
"
270,"CWE-189 static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
","<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
"
271,"CWE-787 static int l2cap_sock_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_l2 la ; int len , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & la , 0 , sizeof ( la ) ) ; len = min_t ( unsigned int , sizeof ( la ) , alen ) ; memcpy ( & la , addr , len ) ; if ( la . l2_cid ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && ! la . l2_psm ) { err = - EINVAL ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case L2CAP_MODE_BASIC : break ; case L2CAP_MODE_ERTM : <S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> break ; default : err = - ENOTSUPP ; goto done ; } switch ( sk -> sk_state ) { case BT_CONNECT : case BT_CONNECT2 : case BT_CONFIG : goto wait ; case BT_CONNECTED : goto done ; case BT_OPEN : case BT_BOUND : break ; default : err = - EBADFD ; goto done ; } bacpy ( & bt_sk ( sk ) -> dst , & la . l2_bdaddr ) ; l2cap_pi ( sk ) -> psm = la . l2_psm ; err = l2cap_do_connect ( sk ) ; if ( err ) goto done ; wait : err = bt_sock_wait_state ( sk , BT_CONNECTED , sock_sndtimeo ( sk , flags & O_NONBLOCK ) ) ; done : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
"
272,"CWE-19 int xfs_attr3_leaf_lookup_int ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; xfs_dahash_t hashval ; int probe ; int span ; trace_xfs_attr_leaf_lookup ( args ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; hashval = args -> hashval ; probe = span = ichdr . count / 2 ; for ( entry = & entries [ probe ] ; span > 4 ; entry = & entries [ probe ] ) { span /= 2 ; if ( be32_to_cpu ( entry -> hashval ) < hashval ) probe += span ; else if ( be32_to_cpu ( entry -> hashval ) > hashval ) probe -= span ; else break ; } ASSERT ( probe >= 0 && ( ! ichdr . count || probe < ichdr . count ) ) ; ASSERT ( span <= 4 || be32_to_cpu ( entry -> hashval ) == hashval ) ; while ( probe > 0 && be32_to_cpu ( entry -> hashval ) >= hashval ) { entry -- ; probe -- ; } while ( probe < ichdr . count && be32_to_cpu ( entry -> hashval ) < hashval ) { entry ++ ; probe ++ ; } if ( probe == ichdr . count || be32_to_cpu ( entry -> hashval ) != hashval ) { args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; } for ( ; probe < ichdr . count && ( be32_to_cpu ( entry -> hashval ) == hashval ) ; entry ++ , probe ++ ) { if ( ( args -> flags & XFS_ATTR_INCOMPLETE ) != ( entry -> flags & XFS_ATTR_INCOMPLETE ) ) { continue ; } if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , probe ) ; if ( name_loc -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; return XFS_ERROR ( EEXIST ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ; if ( name_rmt -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; <S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> return XFS_ERROR ( EEXIST ) ; } } args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; }
","<S2SV_ModStart> ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> ( name_rmt -> <S2SV_ModEnd> valueblk ) ; <S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; return
"
273,"CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-id:"" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\"""" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
"
274,"CWE-125 void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }
","<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
"
275,"CWE-000 bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl2 -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl2 -> tl_data_length = len ; tl2 -> tl_data_next = tl ; tl = tl2 ; } * tl_data_head = tl ; break ; } return TRUE ; }
","<S2SV_ModStart> tl2 ; } * tl_data_head = NULL ;
"
276,"CWE-119 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; } switch ( sun_info . maptype ) { case RMT_NONE : { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> bytes_per_line = sun_info . width * sun_info . depth ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> ( size_t ) MagickMax ( <S2SV_ModStart> . length , bytes_per_line * sun_info . width ) , <S2SV_ModStart> sun_info . height <S2SV_ModEnd> ; if (
"
277,"CWE-200 static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
","<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
"
278,"CWE-119 void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { int i , j ; <S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; const nmv_context_counts * counts = & cm -> counts . mv ; <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & fc -> comps [ i ] ; const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; const nmv_component_counts * c = & counts -> comps [ i ] ; <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> comp -> classes ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> comp -> class0_fp [ j ] ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> if ( allow_hp ) { <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> nmvc ; const <S2SV_ModStart> . mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree , <S2SV_ModStart> -> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> sign ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree , <S2SV_ModStart> classes ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree , <S2SV_ModStart> j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> ++ j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> ] ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , <S2SV_ModStart> -> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> <S2SV_ModStart> -> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp ->
"
279,"CWE-189 int do_adjtimex ( struct timex * txc ) { <S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }
","<S2SV_ModStart> mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj <S2SV_ModStart> ; time_offset = div_s64 <S2SV_ModEnd> ( time_offset , <S2SV_ModStart> time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset
"
280,"CWE-119 static void cyclic_background_refresh ( VP8_COMP * cpi , int Q , int lf_adjustment ) { unsigned char * seg_map = cpi -> segmentation_map ; signed char feature_data [ MB_LVL_MAX ] [ MAX_MB_SEGMENTS ] ; int i ; int block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; int mbs_in_frame = cpi -> common . mb_rows * cpi -> common . mb_cols ; cpi -> cyclic_refresh_q = Q / 2 ; <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> { i = cpi -> cyclic_refresh_mode_index ; assert ( i < mbs_in_frame ) ; do { if ( cpi -> cyclic_refresh_map [ i ] == 0 ) { seg_map [ i ] = 1 ; block_count -- ; } else if ( cpi -> cyclic_refresh_map [ i ] < 0 ) cpi -> cyclic_refresh_map [ i ] ++ ; i ++ ; if ( i == mbs_in_frame ) i = 0 ; } while ( block_count && i != cpi -> cyclic_refresh_mode_index ) ; <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug> } cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; enable_segmentation ( cpi ) ; feature_data [ MB_LVL_ALT_Q ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 1 ] = ( cpi -> cyclic_refresh_q - Q ) ; feature_data [ MB_LVL_ALT_Q ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 3 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 1 ] = lf_adjustment ; feature_data [ MB_LVL_ALT_LF ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 3 ] = 0 ; set_segment_data ( cpi , & feature_data [ 0 ] [ 0 ] , SEGMENT_DELTADATA ) ; }
","<S2SV_ModStart> / 2 ; if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> frame_type != KEY_FRAME && block_count > 0 <S2SV_ModStart> = i ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif
"
281,"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
","<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
"
282,"CWE-787 static void ReadReason ( rfbClient * client ) { uint32_t reasonLen ; char * reason ; if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; <S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return ; } reason [ reasonLen ] = 0 ; rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n"" , reason ) ; free ( reason ) ; }
","<S2SV_ModStart> reasonLen ) ; if ( reasonLen > 1 << 20 ) { rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> reasonLen + 1
"
283,"CWE-834 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <S2SV_StartBug> int name_len ; <S2SV_EndBug> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }
","<S2SV_ModStart> pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
"
284,"CWE-000 static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; <S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }
","<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
"
285,"CWE-125 <S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xd0 : data_1 = * event_data ++ ; midi_setup_channel_pressure ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xe0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_pitch ( mdi , channel , ( ( data_2 << 7 ) | ( data_1 & 0x7f ) ) ) ; ret_cnt += 2 ; break ; case 0xf0 : if ( channel == 0x0f ) { uint32_t tmp_length = 0 ; if ( ( event_data [ 0 ] == 0x00 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else if ( event_data [ 0 ] == 0x01 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_text ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x02 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> if ( mdi -> extra_info . copyright ) { mdi -> extra_info . copyright = realloc ( mdi -> extra_info . copyright , ( strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length + 1 ) ) ; memcpy ( & mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 ] , event_data , tmp_length ) ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length ] = '\\0' ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) ] = '\\n' ; } else { mdi -> extra_info . copyright = malloc ( tmp_length + 1 ) ; memcpy ( mdi -> extra_info . copyright , event_data , tmp_length ) ; mdi -> extra_info . copyright [ tmp_length ] = '\\0' ; } text = malloc ( tmp_length + 1 ) ; memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_copyright ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x03 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_trackname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x04 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_instrumentname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x05 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_lyric ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x06 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_marker ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x07 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_cuepoint ( mdi , text ) ; ret_cnt += tmp_length ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ; ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x21 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x2F ) && ( event_data [ 1 ] == 0x00 ) ) { <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> ret_cnt += 2 ; } else if ( ( event_data [ 0 ] == 0x51 ) && ( event_data [ 1 ] == 0x03 ) ) { <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> ret_cnt += 5 ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ; mdi -> events [ mdi -> events_size - 1 ] . event_data . channel = event_data [ 2 ] ; ret_cnt += 7 ; } else if ( ( event_data [ 0 ] == 0x58 ) && ( event_data [ 1 ] == 0x04 ) ) { <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> ret_cnt += 6 ; } else if ( ( event_data [ 0 ] == 0x59 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; ret_cnt ++ ; ret_cnt += tmp_length ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( ( channel == 0 ) || ( channel == 7 ) ) { uint32_t sysex_len = 0 ; uint8_t * sysex_store = NULL ; if ( * event_data > 0x7f ) { <S2SV_StartBug> do { <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> ret_cnt ++ ; sysex_store = malloc ( sizeof ( uint8_t ) * sysex_len ) ; memcpy ( sysex_store , event_data , sysex_len ) ; if ( sysex_store [ sysex_len - 1 ] == 0xF7 ) { uint8_t rolandsysexid [ ] = { 0x41 , 0x10 , 0x42 , 0x12 } ; if ( memcmp ( rolandsysexid , sysex_store , 4 ) == 0 ) { uint8_t sysex_cs = 0 ; uint32_t sysex_ofs = 4 ; do { sysex_cs += sysex_store [ sysex_ofs ] ; if ( sysex_cs > 0x7F ) { sysex_cs -= 0x80 ; } sysex_ofs ++ ; } while ( sysex_store [ sysex_ofs + 1 ] != 0xf7 ) ; sysex_cs = 128 - sysex_cs ; if ( sysex_cs == sysex_store [ sysex_ofs ] ) { if ( sysex_store [ 4 ] == 0x40 ) { if ( ( ( sysex_store [ 5 ] & 0xf0 ) == 0x10 ) && ( sysex_store [ 6 ] == 0x15 ) ) { uint8_t sysex_ch = 0x0f & sysex_store [ 5 ] ; if ( sysex_ch == 0x00 ) { sysex_ch = 0x09 ; } else if ( sysex_ch <= 0x09 ) { sysex_ch -= 1 ; } midi_setup_sysex_roland_drum_track ( mdi , sysex_ch , sysex_store [ 7 ] ) ; } else if ( ( sysex_store [ 5 ] == 0x00 ) && ( sysex_store [ 6 ] == 0x7F ) && ( sysex_store [ 7 ] == 0x00 ) ) { midi_setup_sysex_roland_reset ( mdi ) ; } } } } else { uint8_t gm_reset [ ] = { 0x7e , 0x7f , 0x09 , 0x01 , 0xf7 } ; uint8_t yamaha_reset [ ] = { 0x43 , 0x10 , 0x4c , 0x00 , 0x00 , 0x7e , 0x00 , 0xf7 } ; if ( memcmp ( gm_reset , sysex_store , 5 ) == 0 ) { midi_setup_sysex_gm_reset ( mdi ) ; } else if ( memcmp ( yamaha_reset , sysex_store , 8 ) == 0 ) { midi_setup_sysex_yamaha_reset ( mdi ) ; } } } free ( sysex_store ) ; sysex_store = NULL ; ret_cnt += sysex_len ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(unrecognized<S2SV_blank>meta<S2SV_blank>type<S2SV_blank>event)"" , 0 ) ; return 0 ; } break ; default : ret_cnt = 0 ; break ; } if ( ret_cnt == 0 ) _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>event)"" , 0 ) ; return ret_cnt ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * event_data , uint32_t siz , <S2SV_ModStart> ; if ( ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart> sysex_len ) break <S2SV_ModEnd> ; sysex_store = <S2SV_ModStart> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ;
"
286,"CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
","<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
"
287,"CWE-310 int ASN1_verify ( i2d_of_void * i2d , X509_ALGOR * a , ASN1_BIT_STRING * signature , char * data , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; const EVP_MD * type ; unsigned char * p , * buf_in = NULL ; int ret = - 1 , i , inl ; EVP_MD_CTX_init ( & ctx ) ; i = OBJ_obj2nid ( a -> algorithm ) ; type = EVP_get_digestbyname ( OBJ_nid2sn ( i ) ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } <S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } p = buf_in ; i2d ( data , & p ) ; ret = EVP_VerifyInit_ex ( & ctx , type , NULL ) && EVP_VerifyUpdate ( & ctx , ( unsigned char * ) buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_VerifyFinal ( & ctx , ( unsigned char * ) signature -> data , ( unsigned int ) signature -> length , pkey ) <= 0 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
","<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }
"
288,"CWE-119 static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; <S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }
","<S2SV_ModStart> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; }
"
289,"CWE-119 static void encode_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct encode_b_args * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; struct optimize_ctx * const ctx = args -> ctx ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> int i , j ; uint8_t * dst ; ENTROPY_CONTEXT * a , * l ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ; a = & ctx -> ta [ plane ] [ i ] ; l = & ctx -> tl [ plane ] [ j ] ; if ( x -> zcoeff_blk [ tx_size ] [ block ] && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } <S2SV_StartBug> if ( ! x -> skip_recode ) <S2SV_EndBug> <S2SV_StartBug> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <S2SV_EndBug> if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) { <S2SV_StartBug> optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ; <S2SV_EndBug> } else { * a = * l = p -> eobs [ block ] > 0 ; } if ( p -> eobs [ block ] ) * ( args -> skip ) = 0 ; if ( x -> skip_encode || p -> eobs [ block ] == 0 ) return ; <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> case TX_32X32 : <S2SV_StartBug> vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_16X16 : <S2SV_StartBug> vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_8X8 : <S2SV_StartBug> vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_4X4 : <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> plane ] ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> -> skip_recode ) { if ( x -> quant_fp ) { if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } else { vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ; } } else { if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ; if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) { <S2SV_ModStart> tx_size ) ; } else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) { vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; } else { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; } } } <S2SV_ModStart> ) ) { const int ctx = combine_entropy_contexts ( * a , * l ) ; * a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) return ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> case TX_32X32 : vp9_highbd_idct32x32_add <S2SV_ModEnd> ( dqcoeff , <S2SV_ModStart> . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> case TX_16X16 : vp9_highbd_idct16x16_add <S2SV_ModEnd> ( dqcoeff , <S2SV_ModStart> . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> case TX_8X8 : vp9_highbd_idct8x8_add <S2SV_ModEnd> ( dqcoeff , <S2SV_ModStart> . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> case TX_4X4 : x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break <S2SV_ModStart> ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ; break ; }
"
290,"CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }
","<S2SV_ModStart> if ( roishift < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )
"
291,"CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int size_group ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ; return y_mode ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_y ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = read_intra_mode <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> y_mode_prob [ size_group <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> y_mode [ size_group
"
292,"CWE-399 static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; <S2SV_StartBug> } <S2SV_EndBug> fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } <S2SV_StartBug> return num ; <S2SV_EndBug> }
","<S2SV_ModStart> = SCM_MAX_FD ; fpl -> user = NULL ; <S2SV_ModStart> ++ ; } if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;
"
293,"CWE-119 void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }
","<S2SV_ModStart> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> data_len = elt <S2SV_ModStart> -> length - ( <S2SV_ModStart> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }
"
294,"CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }
","<S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; n <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; }
"
295,"CWE-119 <S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ; } if ( is_compound ) { <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ; } else { const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ; <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> if ( bit0 ) { const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> } } } }
","<S2SV_ModStart> write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> seg <S2SV_ModStart> SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> ( ! is_compound == <S2SV_ModEnd> ( cm -> <S2SV_ModStart> -> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) ) <S2SV_ModStart> is_compound ) { vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w ,
"
296,"CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; } <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> }
","<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
"
297,"CWE-399 <S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> { struct xenvif * vif ; struct pending_tx_info * pending_tx_info ; pending_ring_idx_t index ; if ( netbk -> mmap_pages [ pending_idx ] == NULL ) return ; pending_tx_info = & netbk -> pending_tx_info [ pending_idx ] ; vif = pending_tx_info -> vif ; <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; netbk -> mmap_pages [ pending_idx ] -> mapping = 0 ; put_page ( netbk -> mmap_pages [ pending_idx ] ) ; netbk -> mmap_pages [ pending_idx ] = NULL ; }
","<S2SV_ModStart> , u16 pending_idx , u8 status <S2SV_ModStart> -> req , status <S2SV_ModEnd> ) ; index
"
298,"CWE-264 void test_js ( void ) { GString * result = g_string_new ( """" ) ; parse_cmd_line ( ""js<S2SV_blank>(\'x\'<S2SV_blank>+<S2SV_blank>345).toUpperCase()"" , result ) ; g_assert_cmpstr ( ""X345"" , == , result -> str ) ; <S2SV_StartBug> uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> parse_cmd_line ( ""js<S2SV_blank>Uzbl.run(\'print<S2SV_blank>@useragent\').toUpperCase();"" , result ) ; g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , result -> str ) ; g_string_free ( result , TRUE ) ; }
","<S2SV_ModStart> str ) ; <S2SV_ModEnd> g_string_free ( result
"
299,"CWE-000 <S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; }
","<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock
"
300,"CWE-119 static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 30 ] = 0x0c ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 31 <S2SV_ModEnd> && rdesc [
"
301,"CWE-119 static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { DIBInfo dib_info ; Image * image ; IndexPacket index ; ssize_t bit , y ; MagickBooleanType status ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_line , length ; ssize_t count ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; if ( dib_info . size != 40 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; dib_info . planes = ReadBlobLSBShort ( image ) ; dib_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; dib_info . compression = ReadBlobLSBLong ( image ) ; dib_info . image_size = ReadBlobLSBLong ( image ) ; dib_info . x_pixels = ReadBlobLSBLong ( image ) ; dib_info . y_pixels = ReadBlobLSBLong ( image ) ; dib_info . number_colors = ReadBlobLSBLong ( image ) ; dib_info . colors_important = ReadBlobLSBLong ( image ) ; if ( ( dib_info . compression == BI_BITFIELDS ) && ( ( dib_info . bits_per_pixel == 16 ) || ( dib_info . bits_per_pixel == 32 ) ) ) { dib_info . red_mask = ReadBlobLSBLong ( image ) ; dib_info . green_mask = ReadBlobLSBLong ( image ) ; dib_info . blue_mask = ReadBlobLSBLong ( image ) ; } image -> matte = dib_info . bits_per_pixel == 32 ? MagickTrue : MagickFalse ; image -> columns = ( size_t ) MagickAbsoluteValue ( dib_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( dib_info . height ) ; image -> depth = 8 ; if ( ( dib_info . number_colors != 0 ) || ( dib_info . bits_per_pixel < 16 ) ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = dib_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << dib_info . bits_per_pixel ; } if ( image_info -> size ) { RectangleInfo geometry ; MagickStatusType flags ; flags = ParseAbsoluteGeometry ( image_info -> size , & geometry ) ; if ( flags & WidthValue ) if ( ( geometry . width != 0 ) && ( geometry . width < image -> columns ) ) image -> columns = geometry . width ; if ( flags & HeightValue ) if ( ( geometry . height != 0 ) && ( geometry . height < image -> rows ) ) image -> rows = geometry . height ; } <S2SV_StartBug> if ( image -> storage_class == PseudoClass ) <S2SV_EndBug> { size_t length , packet_size ; unsigned char * dib_colormap ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) image -> colors ; dib_colormap = ( unsigned char * ) AcquireQuantumMemory ( length , 4 * sizeof ( * dib_colormap ) ) ; if ( dib_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; packet_size = 4 ; count = ReadBlob ( image , packet_size * image -> colors , dib_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = dib_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } dib_colormap = ( unsigned char * ) RelinquishMagickMemory ( dib_colormap ) ; } if ( dib_info . compression == BI_RLE4 ) dib_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * dib_info . bits_per_pixel + 31 ) / 32 ) ; length = bytes_per_line * image -> rows ; pixel_info = AcquireVirtualMemory ( ( size_t ) image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( dib_info . compression == BI_RGB ) || ( dib_info . compression == BI_BITFIELDS ) ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) ( length ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } else { status = DecodeImage ( image , dib_info . compression ? MagickTrue : MagickFalse , pixels ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = ( double ) dib_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) dib_info . y_pixels / 100.0 ; switch ( dib_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , * p & 0xf ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( dib_info . compression == BI_RLE8 ) || ( dib_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { unsigned short word ; image -> storage_class = DirectClass ; if ( dib_info . compression == BI_RLE8 ) bytes_per_line = 2 * image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { word = ( * p ++ ) ; word |= ( * p ++ << 8 ) ; if ( dib_info . red_mask == 0 ) { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 10 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x1f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } else { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 11 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor6to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x3f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( dib_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; image = DestroyImage ( image ) ; image = flipped_image ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
302,"CWE-000 static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
","<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
"
303,"CWE-125 static int validate_node ( node * tree ) { int type = TYPE ( tree ) ; int nch = NCH ( tree ) ; dfa * nt_dfa ; state * dfa_state ; int pos , arc ; assert ( ISNONTERMINAL ( type ) ) ; type -= NT_OFFSET ; if ( type >= _PyParser_Grammar . g_ndfas ) { PyErr_Format ( parser_error , ""Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d."" , TYPE ( tree ) ) ; return 0 ; } nt_dfa = & _PyParser_Grammar . g_dfa [ type ] ; REQ ( tree , nt_dfa -> d_type ) ; dfa_state = & nt_dfa -> d_state [ nt_dfa -> d_initial ] ; for ( pos = 0 ; pos < nch ; ++ pos ) { node * ch = CHILD ( tree , pos ) ; int ch_type = TYPE ( ch ) ; <S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> short a_label = dfa_state -> s_arc [ arc ] . a_lbl ; assert ( a_label < _PyParser_Grammar . g_ll . ll_nlabels ) ; if ( _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type == ch_type ) { if ( ISNONTERMINAL ( ch_type ) && ! validate_node ( ch ) ) return 0 ; dfa_state = & nt_dfa -> d_state [ dfa_state -> s_arc [ arc ] . a_arrow ] ; goto arc_found ; } } { short a_label = dfa_state -> s_arc -> a_lbl ; int next_type ; if ( ! a_label ) goto illegal_num_children ; next_type = _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type ; if ( ISNONTERMINAL ( next_type ) ) PyErr_Format ( parser_error , ""Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d."" , next_type , ch_type ) ; else PyErr_Format ( parser_error , ""Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s."" , _PyParser_TokenNames [ next_type ] ) ; return 0 ; } arc_found : continue ; } for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { if ( ! dfa_state -> s_arc [ arc ] . a_lbl ) { return 1 ; } } illegal_num_children : PyErr_Format ( parser_error , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node."" , nt_dfa -> d_name ) ; return 0 ; }
","<S2SV_ModStart> ch ) ; if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; }
"
304,"CWE-16 <S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> char buf [ 65 ] ; if ( current -> personality & UNAME26 ) { <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> int ndots = 0 ; <S2SV_StartBug> unsigned v ; <S2SV_EndBug> while ( * rest ) { if ( * rest == '.' && ++ ndots >= 3 ) break ; if ( ! isdigit ( * rest ) && * rest != '.' ) break ; rest ++ ; } v = ( ( LINUX_VERSION_CODE >> 8 ) & 0xff ) + 40 ; <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> } return ret ; }
","<S2SV_ModStart> * release , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> UNAME26 ) { const <S2SV_ModStart> rest = UTS_RELEASE ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; unsigned v ; size_t copy <S2SV_ModStart> + 40 ; copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , copy <S2SV_ModEnd> , ""2.6.%u%s"" , <S2SV_ModStart> , buf , copy + 1 <S2SV_ModEnd> ) ; }
"
305,"CWE-476 static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; } <S2SV_StartBug> if ( in ) { <S2SV_EndBug> dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }
","<S2SV_ModStart> ( in ) <S2SV_ModEnd> dev -> in_pipe <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in
"
306,"CWE-000 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""256"" , CVAR_ARCHIVE ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_ARCHIVE ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""1.3"" , CVAR_ARCHIVE ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_ARCHIVE ) ; s_alTalkAnims = Cvar_Get ( ""s_alTalkAnims"" , ""160"" , CVAR_ARCHIVE ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> FadeStreamingSound = S_AL_FadeStreamingSound ; si -> FadeAllSounds = S_AL_FadeAllSounds ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> StopEntStreamingSound = S_AL_StopEntStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
"
307,"CWE-119 static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
308,"CWE-17 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }
","<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
"
309,"CWE-20 static void __iov_iter_advance_iov ( struct iov_iter * i , size_t bytes ) { if ( likely ( i -> nr_segs == 1 ) ) { i -> iov_offset += bytes ; } else { const struct iovec * iov = i -> iov ; size_t base = i -> iov_offset ; <S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> int copy = min ( bytes , iov -> iov_len - base ) ; bytes -= copy ; base += copy ; if ( iov -> iov_len == base ) { iov ++ ; base = 0 ; } } i -> iov = iov ; i -> iov_offset = base ; } }
","<S2SV_ModStart> while ( bytes || ! iov -> iov_len
"
310,"CWE-476 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
","<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
"
311,"CWE-200 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
","<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
"
312,"CWE-399 static int do_tkill ( pid_t tgid , pid_t pid , int sig ) { <S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> info . si_signo = sig ; info . si_errno = 0 ; info . si_code = SI_TKILL ; info . si_pid = task_tgid_vnr ( current ) ; info . si_uid = from_kuid_munged ( current_user_ns ( ) , current_uid ( ) ) ; return do_send_specific ( tgid , pid , sig , & info ) ; }
","<S2SV_ModStart> struct siginfo info = { }
"
313,"CWE-125 PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ;
"
314,"CWE-20 int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) { __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; unsigned int start_segno , end_segno ; struct cp_control cpc ; int err = 0 ; if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) return - EINVAL ; cpc . trimmed = 0 ; if ( end <= MAIN_BLKADDR ( sbi ) ) goto out ; if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { f2fs_msg ( sbi -> sb , KERN_WARNING , ""Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix."" ) ; goto out ; } start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : GET_SEGNO ( sbi , end ) ; cpc . reason = CP_DISCARD ; cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { cpc . trim_start = start_segno ; if ( sbi -> discard_blks == 0 ) break ; else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) cpc . trim_end = end_segno ; else cpc . trim_end = min_t ( unsigned int , rounddown ( start_segno + BATCHED_TRIM_SEGMENTS ( sbi ) , sbi -> segs_per_sec ) - 1 , end_segno ) ; mutex_lock ( & sbi -> gc_mutex ) ; err = write_checkpoint ( sbi , & cpc ) ; mutex_unlock ( & sbi -> gc_mutex ) ; if ( err ) break ; schedule ( ) ; } mark_discard_range_all ( sbi ) ; <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ; }
","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , false
"
315,"CWE-000 asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }
","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
"
316,"CWE-834 static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n"" , size ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n"" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%"" PRId64 ""<S2SV_blank>ms\\n"" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n"" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n"" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ; <S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }
","<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + size ; }
"
317,"CWE-20 int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }
","<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
"
318,"CWE-125 static int read_new_config_info ( WavpackContext * wpc , WavpackMetadata * wpmd ) { int bytecnt = wpmd -> byte_length ; unsigned char * byteptr = wpmd -> data ; wpc -> version_five = 1 ; wpc -> file_format = wpc -> config . qmode = wpc -> channel_layout = 0 ; if ( wpc -> channel_reordering ) { free ( wpc -> channel_reordering ) ; wpc -> channel_reordering = NULL ; } <S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> wpc -> file_format = * byteptr ++ ; wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; bytecnt -= 2 ; if ( bytecnt ) { int nchans , i ; wpc -> channel_layout = ( int32_t ) * byteptr ++ << 16 ; bytecnt -- ; if ( bytecnt ) { wpc -> channel_layout += nchans = * byteptr ++ ; bytecnt -- ; if ( bytecnt ) { if ( bytecnt > nchans ) return FALSE ; wpc -> channel_reordering = malloc ( nchans ) ; if ( wpc -> channel_reordering ) { for ( i = 0 ; i < nchans ; ++ i ) if ( bytecnt ) { wpc -> channel_reordering [ i ] = * byteptr ++ ; <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> } else wpc -> channel_reordering [ i ] = i ; } } } else wpc -> channel_layout += wpc -> config . num_channels ; } } return TRUE ; }
","<S2SV_ModStart> if ( bytecnt >= 2 <S2SV_ModStart> byteptr ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
"
319,"CWE-476 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }
","<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
"
320,"CWE-189 struct timespec ns_to_timespec ( const s64 nsec ) { <S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ; <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> return ts ; }
","<S2SV_ModStart> struct timespec ts ; s32 rem <S2SV_ModStart> . tv_sec = div_s64_rem <S2SV_ModEnd> ( nsec , <S2SV_ModStart> NSEC_PER_SEC , & rem <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( rem <S2SV_ModEnd> < 0 ) <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> ts . tv_sec <S2SV_ModStart> ts . tv_sec -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> ts . tv_nsec <S2SV_ModStart> ts . tv_nsec = rem <S2SV_ModEnd> ; return ts
"
321,"CWE-399 long pipe_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct pipe_inode_info * pipe ; long ret ; pipe = get_pipe_info ( file ) ; if ( ! pipe ) return - EBADF ; __pipe_lock ( pipe ) ; switch ( cmd ) { case F_SETPIPE_SZ : { unsigned int size , nr_pages ; size = round_pipe_size ( arg ) ; nr_pages = size >> PAGE_SHIFT ; ret = - EINVAL ; if ( ! nr_pages ) goto out ; if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size ) { ret = - EPERM ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> ret = pipe_set_size ( pipe , nr_pages ) ; break ; } case F_GETPIPE_SZ : ret = pipe -> buffers * PAGE_SIZE ; break ; default : ret = - EINVAL ; break ; } out : __pipe_unlock ( pipe ) ; return ret ; }
","<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
"
322,"CWE-125 static int <S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }
","<S2SV_ModStart> int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }
"
323,"CWE-119 void cJSON_Delete ( cJSON * c ) { cJSON * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ; if ( ! ( c -> type & cJSON_IsReference ) && c -> valuestring ) cJSON_free ( c -> valuestring ) ; <S2SV_StartBug> if ( c -> string ) <S2SV_EndBug> cJSON_free ( c -> string ) ; cJSON_free ( c ) ; c = next ; } }
","<S2SV_ModStart> ; if ( ! ( c -> type & cJSON_StringIsConst ) &&
"
324,"CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }
","<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
"
325,"CWE-000 PHYSICALPATH_FUNC ( mod_alias_physical_handler ) { plugin_data * p = p_d ; int uri_len , basedir_len ; char * uri_ptr ; size_t k ; if ( buffer_is_empty ( con -> physical . path ) ) return HANDLER_GO_ON ; mod_alias_patch_connection ( srv , con , p ) ; basedir_len = buffer_string_length ( con -> physical . basedir ) ; if ( '/' == con -> physical . basedir -> ptr [ basedir_len - 1 ] ) -- basedir_len ; uri_len = buffer_string_length ( con -> physical . path ) - basedir_len ; uri_ptr = con -> physical . path -> ptr + basedir_len ; for ( k = 0 ; k < p -> conf . alias -> used ; k ++ ) { data_string * ds = ( data_string * ) p -> conf . alias -> data [ k ] ; int alias_len = buffer_string_length ( ds -> key ) ; if ( alias_len > uri_len ) continue ; if ( buffer_is_empty ( ds -> key ) ) continue ; if ( 0 == ( con -> conf . force_lowercase_filenames ? strncasecmp ( uri_ptr , ds -> key -> ptr , alias_len ) : strncmp ( uri_ptr , ds -> key -> ptr , alias_len ) ) ) { <S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ; buffer_append_string ( srv -> tmp_buf , uri_ptr + alias_len ) ; buffer_copy_buffer ( con -> physical . path , srv -> tmp_buf ) ; return HANDLER_GO_ON ; } } return HANDLER_GO_ON ; }
","<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
"
326,"CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
","<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) <S2SV_ModStart> ( pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> <S2SV_ModStart> , pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst ->
"
327,"CWE-119 static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ MAX_SKB_FRAGS ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; <S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - EFAULT ; } truesize = size * PAGE_SIZE ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ PAGE_MASK ; int size = min_t ( int , len , PAGE_SIZE - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }
","<S2SV_ModStart> >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
"
328,"CWE-190 <S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
","<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {
"
329,"CWE-835 static void urlParsePostBody ( struct URL * url , const struct HttpConnection * http , const char * buf , int len ) { struct HashMap contentType ; initHashMap ( & contentType , urlDestroyHashMapEntry , NULL ) ; const char * ctHeader = getFromHashMap ( & http -> header , ""content-type"" ) ; urlParseHeaderLine ( & contentType , ctHeader , ctHeader ? strlen ( ctHeader ) : 0 ) ; if ( getRefFromHashMap ( & contentType , ""application/x-www-form-urlencoded"" ) ) { urlParseQueryString ( & url -> args , buf , len ) ; } else if ( getRefFromHashMap ( & contentType , ""multipart/form-data"" ) ) { const char * boundary = getFromHashMap ( & contentType , ""boundary"" ) ; if ( boundary && * boundary ) { const char * lastPart = NULL ; for ( const char * part = buf ; len > 0 ; ) { const char * ptr ; if ( ( part == buf && ( ptr = urlMemstr ( part , len , ""--"" ) ) != NULL ) || ( ptr = urlMemstr ( part , len , ""\\r\\n--"" ) ) != NULL ) { len -= ptr - part + ( part == buf ? 2 : 4 ) ; part = ptr + ( part == buf ? 2 : 4 ) ; if ( ! urlMemcmp ( part , len , boundary ) ) { int i = strlen ( boundary ) ; len -= i ; part += i ; if ( ! urlMemcmp ( part , len , ""\\r\\n"" ) ) { len -= 2 ; part += 2 ; if ( lastPart ) { urlParsePart ( url , lastPart , ptr - lastPart ) ; } else { if ( ptr != buf ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>prologue<S2SV_blank>before<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } lastPart = part ; } else if ( ! urlMemcmp ( part , len , ""--\\r\\n"" ) ) { len -= 4 ; part += 4 ; urlParsePart ( url , lastPart , ptr - lastPart ) ; lastPart = NULL ; if ( len > 0 ) { info ( ""[http]<S2SV_blank>Ignoring<S2SV_blank>epilogue<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>\\""multipart/"" ""form-data\\""!"" ) ; } } } } <S2SV_StartBug> } <S2SV_EndBug> if ( lastPart ) { <S2SV_StartBug> warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\""boundary\\""<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; <S2SV_EndBug> } } else { warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>\\""boundary\\""<S2SV_blank>information<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; } } destroyHashMap ( & contentType ) ; }
","<S2SV_ModStart> } } } else <S2SV_ModEnd> { warn ( <S2SV_ModStart> { warn ( ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ; break ; } } if ( lastPart ) { warn (
"
330,"CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , ""invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
","<S2SV_ModStart> , * insn_idx , false
"
331,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
"
332,"CWE-264 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }
","<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
333,"CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""entering<S2SV_blank>CDROM_DRIVE_STATUS\\n"" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
"
334,"CWE-399 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }
","<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
"
