,source,target
0,"static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }","int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY"
1,"static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }","- EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;"
2,"static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }","; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;"
3,"static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , <S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> { <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; <S2SV_StartBug> ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" <S2SV_EndBug> ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }","inode , struct ext4_map_blocks * map , struct <S2SV_ModStart> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> err = ext4_ext_get_access"
4,"static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }","= hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;"
5,"int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }",slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
6,"static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s"" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }",O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
7,"int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <S2SV_StartBug> init_thread : <S2SV_EndBug> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }","= fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;"
8,"void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }","handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
9,"void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; }"
10,"static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }",; s -> interlaced_dct = 0 ; s ->
11,"uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }",uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
12,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame."" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame."" ) ; printf ( keyframe ? ""K"" : ""."" ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t <S2SV_ModStart> writer ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
13,"<S2SV_StartBug> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double this_frame_mv_in_out ) { <S2SV_EndBug> double frame_boost ; <S2SV_StartBug> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <S2SV_EndBug> <S2SV_StartBug> frame_boost = ( IIFACTOR * this_frame -> intra_error / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <S2SV_EndBug> else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ; else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ; <S2SV_StartBug> return MIN ( frame_boost , GF_RMAX ) ; <S2SV_EndBug> }","* cpi , const <S2SV_ModStart> , double this_frame_mv_in_out , double max_boost <S2SV_ModStart> double frame_boost ; const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <S2SV_ModEnd> frame_boost = ( <S2SV_ModStart> frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK ( <S2SV_ModStart> -> coded_error ) ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( frame_boost , max_boost * boost_q_correction <S2SV_ModEnd> ) ; }"
14,"<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; }","* deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock"
15,"PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rdd"" , & IM , & input , & output ) == FAILURE ) { return ; } <S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }","return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; }"
16,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;"
17,"SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( ""selReadStream"" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file"" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( ""invalid<S2SV_blank>sel<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n"" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""dimensions<S2SV_blank>not<S2SV_blank>read"" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""sel<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , ""%1d"" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , ""\\n"" ) ; } ignore = fscanf ( fp , ""\\n"" ) ; LEPT_FREE ( selname ) ; return sel ; }","char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> , selname )"
18,"void xenvif_disconnect ( struct xenvif * vif ) { <S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) ) <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }",vif ) { <S2SV_ModEnd> if ( netif_carrier_ok <S2SV_ModStart> ( netif_carrier_ok ( vif -> <S2SV_ModEnd> dev ) ) <S2SV_ModStart> dev ) ) xenvif_carrier_off <S2SV_ModEnd> ( vif ) <S2SV_ModStart> vif ) ; <S2SV_ModEnd> atomic_dec ( &
19,"<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }","net * net <S2SV_ModEnd> , const struct <S2SV_ModStart> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> ) ; hash <S2SV_ModStart> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id"
20,"static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>ICMP6<S2SV_blank>socket."" ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVPKTINFO."" ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }","ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."""
21,void pin_remove ( struct fs_pin * pin ) { spin_lock ( & pin_lock ) ; <S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> spin_unlock ( & pin_lock ) ; spin_lock_irq ( & pin -> wait . lock ) ; pin -> done = 1 ; wake_up_locked ( & pin -> wait ) ; spin_unlock_irq ( & pin -> wait . lock ) ; },pin_lock ) ; hlist_del_init <S2SV_ModEnd> ( & pin <S2SV_ModStart> m_list ) ; hlist_del_init <S2SV_ModEnd> ( & pin
22,"static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> int step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int distortion ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , & sse ) ; } x -> plane [ 0 ] . src = src ; xd -> plane [ 0 ] . pre [ 0 ] = pre ; return bestsme ; }","{ MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; MACROBLOCKD <S2SV_ModStart> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> - 2 ) <S2SV_ModStart> - 2 ) <S2SV_ModEnd> ; vp9_hex_search ( <S2SV_ModStart> , 1 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> x -> plane"
23,"static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; return - EIO ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , ""Starting<S2SV_blank>stream<S2SV_blank>failed\\n"" ) ; else gspca_dbg ( gspca_dev , D_STREAM , ""Started<S2SV_blank>streaming\\n"" ) ; return ( err < 0 ) ? err : 0 ; }",EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
24,"static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)"" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , ""Session<S2SV_blank>needs<S2SV_blank>reconnect"" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , ""Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found"" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , ""%pI6"" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , ""%pI4"" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }","server , volume_info <S2SV_ModEnd> ) ; if"
25,"int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + ( border * y_stride ) + border ; ybf -> u_buffer = ybf -> buffer_alloc + yplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> v_buffer = ybf -> buffer_alloc + yplane_size + uvplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> alpha_buffer = NULL ; ybf -> corrupted = 0 ; return 0 ; } return - 2 ; }",; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->
26,"static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }","f2fs_wait_discard_bios ( sbi , true"
27,"err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }","""SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out"" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> return NULL ;"
28,"static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , const uint8_t * buf , int buf_size , int first_field ) { int i , cid , ret ; int old_bit_depth = ctx -> bit_depth , bitdepth ; uint64_t header_prefix ; if ( buf_size < 0x280 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>640).\\n"" , buf_size ) ; return AVERROR_INVALIDDATA ; } header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; if ( header_prefix == 0 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""unknown<S2SV_blank>header<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X\\n"" , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; return AVERROR_INVALIDDATA ; } if ( buf [ 5 ] & 2 ) { ctx -> cur_field = buf [ 5 ] & 1 ; frame -> interlaced_frame = 1 ; frame -> top_field_first = first_field ^ ctx -> cur_field ; av_log ( ctx -> avctx , AV_LOG_DEBUG , ""interlaced<S2SV_blank>%d,<S2SV_blank>cur<S2SV_blank>field<S2SV_blank>%d\\n"" , buf [ 5 ] & 3 , ctx -> cur_field ) ; } else { ctx -> cur_field = 0 ; } ctx -> mbaff = ( buf [ 0x6 ] >> 5 ) & 1 ; ctx -> height = AV_RB16 ( buf + 0x18 ) ; ctx -> width = AV_RB16 ( buf + 0x1a ) ; switch ( buf [ 0x21 ] >> 5 ) { case 1 : bitdepth = 8 ; break ; case 2 : bitdepth = 10 ; break ; case 3 : bitdepth = 12 ; break ; default : av_log ( ctx -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>bitdepth<S2SV_blank>indicator<S2SV_blank>(%d)\\n"" , buf [ 0x21 ] >> 5 ) ; return AVERROR_INVALIDDATA ; } cid = AV_RB32 ( buf + 0x28 ) ; ctx -> avctx -> profile = dnxhd_get_profile ( cid ) ; if ( ( ret = dnxhd_init_vlc ( ctx , cid , bitdepth ) ) < 0 ) return ret ; if ( ctx -> mbaff && ctx -> cid_table -> cid != 1260 ) av_log ( ctx -> avctx , AV_LOG_WARNING , ""Adaptive<S2SV_blank>MB<S2SV_blank>interlace<S2SV_blank>flag<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n"" ) ; ctx -> act = buf [ 0x2C ] & 7 ; if ( ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270 ) av_log ( ctx -> avctx , AV_LOG_WARNING , ""Adaptive<S2SV_blank>color<S2SV_blank>transform<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n"" ) ; ctx -> is_444 = ( buf [ 0x2C ] >> 6 ) & 1 ; if ( ctx -> is_444 ) { if ( bitdepth == 8 ) { avpriv_request_sample ( ctx -> avctx , ""4:4:4<S2SV_blank>8<S2SV_blank>bits"" ) ; return AVERROR_INVALIDDATA ; } else if ( bitdepth == 10 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_12_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12 ; } } else if ( bitdepth == 12 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_12 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P12 ; } else if ( bitdepth == 10 ) { if ( ctx -> avctx -> profile == FF_PROFILE_DNXHR_HQX ) ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; else ctx -> decode_dct_block = dnxhd_decode_dct_block_10 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_8 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P ; } ctx -> avctx -> bits_per_raw_sample = ctx -> bit_depth = bitdepth ; if ( ctx -> bit_depth != old_bit_depth ) { ff_blockdsp_init ( & ctx -> bdsp , ctx -> avctx ) ; ff_idctdsp_init ( & ctx -> idsp , ctx -> avctx ) ; ff_init_scantable ( ctx -> idsp . idct_permutation , & ctx -> scantable , ff_zigzag_direct ) ; } if ( ctx -> width != ctx -> cid_table -> width && ctx -> cid_table -> width != DNXHD_VARIABLE ) { av_reduce ( & ctx -> avctx -> sample_aspect_ratio . num , & ctx -> avctx -> sample_aspect_ratio . den , ctx -> width , ctx -> cid_table -> width , 255 ) ; ctx -> width = ctx -> cid_table -> width ; } if ( buf_size < ctx -> cid_table -> coding_unit_size ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""incorrect<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%u).\\n"" , buf_size , ctx -> cid_table -> coding_unit_size ) ; return AVERROR_INVALIDDATA ; } ctx -> mb_width = ( ctx -> width + 15 ) >> 4 ; ctx -> mb_height = AV_RB16 ( buf + 0x16c ) ; if ( ( ctx -> height + 15 ) >> 4 == ctx -> mb_height && frame -> interlaced_frame ) ctx -> height <<= 1 ; av_log ( ctx -> avctx , AV_LOG_VERBOSE , ""%dx%d,<S2SV_blank>4:%s<S2SV_blank>%d<S2SV_blank>bits,<S2SV_blank>MBAFF=%d<S2SV_blank>ACT=%d\\n"" , ctx -> width , ctx -> height , ctx -> is_444 ? ""4:4"" : ""2:2"" , ctx -> bit_depth , ctx -> mbaff , ctx -> act ) ; if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) { ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ; } else { <S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> } if ( buf_size < ctx -> data_offset ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%d).\\n"" , buf_size , ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } if ( ctx -> mb_height > FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb_height<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%"" SIZE_SPECIFIER "").\\n"" , ctx -> mb_height , FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < ctx -> mb_height ; i ++ ) { ctx -> mb_scan_index [ i ] = AV_RB32 ( buf + 0x170 + ( i << 2 ) ) ; ff_dlog ( ctx -> avctx , ""mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>%d,<S2SV_blank>pos<S2SV_blank>%d:<S2SV_blank>%"" PRIu32 ""\\n"" , i , 0x170 + ( i << 2 ) , ctx -> mb_scan_index [ i ] ) ; if ( buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ] ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>(%"" PRIu32 ""<S2SV_blank>vs<S2SV_blank>%u).\\n"" , ctx -> mb_scan_index [ i ] , buf_size - ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }","mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> AVERROR_INVALIDDATA ; } <S2SV_ModEnd> if ( buf_size"
29,"static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }",( likely ( serio <S2SV_ModEnd> && ! filtered
30,"int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }",-> band = av_calloc <S2SV_ModEnd> ( reslevel -> <S2SV_ModStart> -> prec = av_calloc <S2SV_ModEnd> ( reslevel ->
31,"int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , ""usb%d"" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , ""eth%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , ""wlan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , ""wwan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }",; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
32,"int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= USECS_PER_SEC ) return - 1 ; # else if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= 1 ) return - 1 ; # endif return 0 ; }",char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
33,static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; },"ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }"
34,"static void nfs4_close_done ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; struct nfs_server * server = NFS_SERVER ( calldata -> inode ) ; if ( RPC_ASSASSINATED ( task ) ) return ; switch ( task -> tk_status ) { case 0 : nfs_set_open_stateid ( state , & calldata -> res . stateid , 0 ) ; renew_lease ( server , calldata -> timestamp ) ; break ; case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : <S2SV_StartBug> if ( calldata -> arg . open_flags == 0 ) <S2SV_EndBug> break ; default : if ( nfs4_async_handle_error ( task , server , state ) == - EAGAIN ) { rpc_restart_call ( task ) ; return ; } } nfs_refresh_inode ( calldata -> inode , calldata -> res . fattr ) ; }",-> arg . fmode <S2SV_ModEnd> == 0 )
35,"static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , offsetof ( struct ipv6hdr , payload_len ) ) ; return - 1 ; } if ( end > fq -> q . len ) { if ( fq -> q . last_in & INET_FRAG_LAST_IN ) goto err ; fq -> q . len = end ; } } if ( end == offset ) goto err ; if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) goto err ; if ( pskb_trim_rcsum ( skb , end - offset ) ) goto err ; prev = fq -> q . fragments_tail ; if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { next = NULL ; goto found ; } prev = NULL ; for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { if ( FRAG6_CB ( next ) -> offset >= offset ) break ; prev = next ; } found : <S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> offset += i ; if ( end <= offset ) goto err ; if ( ! pskb_pull ( skb , i ) ) goto err ; if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) skb -> ip_summed = CHECKSUM_NONE ; } } <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> int i = end - FRAG6_CB ( next ) -> offset ; if ( i < next -> len ) { if ( ! pskb_pull ( next , i ) ) goto err ; FRAG6_CB ( next ) -> offset += i ; fq -> q . meat -= i ; if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ; break ; } else { struct sk_buff * free_it = next ; next = next -> next ; if ( prev ) prev -> next = next ; else fq -> q . fragments = next ; fq -> q . meat -= free_it -> len ; frag_kfree_skb ( fq -> q . net , free_it ) ; } } FRAG6_CB ( skb ) -> offset = offset ; skb -> next = next ; if ( ! next ) fq -> q . fragments_tail = skb ; if ( prev ) prev -> next = skb ; else fq -> q . fragments = skb ; dev = skb -> dev ; if ( dev ) { fq -> iif = dev -> ifindex ; skb -> dev = NULL ; } fq -> q . stamp = skb -> tstamp ; fq -> q . meat += skb -> len ; atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; if ( offset == 0 ) { fq -> nhoffset = nhoff ; fq -> q . last_in |= INET_FRAG_FIRST_IN ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) return ip6_frag_reasm ( fq , prev , dev ) ; write_lock ( & ip6_frags . lock ) ; list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; write_unlock ( & ip6_frags . lock ) ; return - 1 ; <S2SV_StartBug> err : <S2SV_EndBug> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ; kfree_skb ( skb ) ; return - 1 ; }",if ( prev && <S2SV_ModEnd> ( FRAG6_CB ( <S2SV_ModStart> ) - offset <S2SV_ModEnd> > 0 ) <S2SV_ModStart> > 0 ) goto discard_fq ; if <S2SV_ModEnd> ( next && <S2SV_ModStart> < end ) goto discard_fq ; <S2SV_ModEnd> FRAG6_CB ( skb <S2SV_ModStart> - 1 ; discard_fq : fq_kill ( fq ) ;
36,"static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }",( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> buf -> f_blocks <S2SV_ModStart> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> ; buf ->
37,"static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }",} if ( strlen ( token ) > 4 &&
38,"WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SPS_PPS_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } <S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",pv_parse_tu_coeff_data ; } <S2SV_ModEnd> if ( u1_slice_type
39,"void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> } vp8_loop_filter_frame_init ( pc , & pbi -> mb , filter_level ) ; } else vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; setup_decoding_thread_data ( pbi , xd , pbi -> mb_row_di , pbi -> decoding_thread_count ) ; for ( i = 0 ; i < pbi -> decoding_thread_count ; i ++ ) sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; mt_decode_mb_rows ( pbi , xd , 0 ) ; sem_wait ( & pbi -> h_event_end_decoding ) ; }",filter_level ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 5 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 16 ) ; memset <S2SV_ModEnd> ( pbi -> <S2SV_ModStart> 8 ) ; memset <S2SV_ModEnd> ( pbi ->
40,"int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 ""grammar.y"" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 ""grammar.c"" break ; case 9 : # line 242 ""grammar.y"" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 ""grammar.c"" break ; case 10 : # line 251 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 ""grammar.c"" break ; case 11 : # line 259 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 ""grammar.c"" break ; case 12 : # line 274 ""grammar.y"" { ( yyval . meta ) = NULL ; } # line 1709 ""grammar.c"" break ; case 13 : # line 278 ""grammar.y"" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 ""grammar.c"" break ; case 14 : # line 305 ""grammar.y"" { ( yyval . string ) = NULL ; } # line 1744 ""grammar.c"" break ; case 15 : # line 309 ""grammar.y"" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 ""grammar.c"" break ; case 17 : # line 340 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 1777 ""grammar.c"" break ; case 18 : # line 341 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 ""grammar.c"" break ; case 19 : # line 346 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 ""grammar.c"" break ; case 20 : # line 347 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 ""grammar.c"" break ; case 21 : # line 353 ""grammar.y"" { ( yyval . c_string ) = NULL ; } # line 1803 ""grammar.c"" break ; case 22 : # line 357 ""grammar.y"" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 ""grammar.c"" break ; case 23 : # line 375 ""grammar.y"" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 ""grammar.c"" break ; case 24 : # line 388 ""grammar.y"" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 ""grammar.c"" break ; case 25 : # line 424 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 ""grammar.c"" break ; case 26 : # line 425 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 ""grammar.c"" break ; case 27 : # line 431 ""grammar.y"" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 ""grammar.c"" break ; case 28 : # line 447 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 ""grammar.c"" break ; case 29 : # line 460 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 ""grammar.c"" break ; case 30 : # line 473 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 ""grammar.c"" break ; case 31 : # line 486 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 ""grammar.c"" break ; case 32 : # line 502 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 ""grammar.c"" break ; case 33 : # line 503 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 ""grammar.c"" break ; case 34 : # line 509 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 ""grammar.c"" break ; case 35 : # line 513 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 ""grammar.c"" break ; case 36 : # line 524 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 ""grammar.c"" break ; case 37 : # line 528 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 ""grammar.c"" break ; case 38 : # line 540 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 ""grammar.c"" break ; case 39 : # line 553 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 2053 ""grammar.c"" break ; case 40 : # line 554 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 ""grammar.c"" break ; case 41 : # line 559 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 ""grammar.c"" break ; case 42 : # line 560 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 ""grammar.c"" break ; case 43 : # line 561 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 ""grammar.c"" break ; case 44 : # line 562 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 ""grammar.c"" break ; case 45 : # line 568 ""grammar.y"" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 ""grammar.c"" break ; case 46 : # line 653 ""grammar.y"" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 ""grammar.c"" break ; case 47 : # line 699 ""grammar.y"" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , ""dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 ""grammar.c"" break ; case 48 : # line 757 ""grammar.y"" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 ""grammar.c"" break ; case 49 : # line 801 ""grammar.y"" { ( yyval . c_string ) = yr_strdup ( """" ) ; } # line 2334 ""grammar.c"" break ; case 50 : # line 802 ""grammar.y"" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 ""grammar.c"" break ; case 51 : # line 807 ""grammar.y"" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> ERROR_IF ( ( yyval . c_string ) == NULL ) ; } <S2SV_StartBug> # line 2369 ""grammar.c"" <S2SV_EndBug> break ; case 52 : <S2SV_StartBug> # line 832 ""grammar.y"" <S2SV_EndBug> { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } <S2SV_StartBug> # line 2405 ""grammar.c"" <S2SV_EndBug> break ; case 53 : <S2SV_StartBug> # line 868 ""grammar.y"" <S2SV_EndBug> { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } <S2SV_StartBug> # line 2451 ""grammar.c"" <S2SV_EndBug> break ; case 54 : <S2SV_StartBug> # line 914 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , ""Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation."" , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2474 ""grammar.c"" <S2SV_EndBug> break ; case 55 : <S2SV_StartBug> # line 936 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2487 ""grammar.c"" <S2SV_EndBug> break ; case 56 : <S2SV_StartBug> # line 945 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2500 ""grammar.c"" <S2SV_EndBug> break ; case 57 : <S2SV_StartBug> # line 954 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""matches"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , ""matches"" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2519 ""grammar.c"" <S2SV_EndBug> break ; case 58 : <S2SV_StartBug> # line 969 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2535 ""grammar.c"" <S2SV_EndBug> break ; case 59 : <S2SV_StartBug> # line 981 ""grammar.y"" <S2SV_EndBug> { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2553 ""grammar.c"" <S2SV_EndBug> break ; case 60 : <S2SV_StartBug> # line 995 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""at"" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2570 ""grammar.c"" <S2SV_EndBug> break ; case 61 : <S2SV_StartBug> # line 1008 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2585 ""grammar.c"" <S2SV_EndBug> break ; case 62 : <S2SV_StartBug> # line 1019 ""grammar.y"" <S2SV_EndBug> { if ( compiler -> loop_depth > 0 ) { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } <S2SV_StartBug> } <S2SV_EndBug> # line 2597 ""grammar.c"" break ; case 63 : <S2SV_StartBug> # line 1027 ""grammar.y"" <S2SV_EndBug> { int var_index ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2631 ""grammar.c"" <S2SV_EndBug> break ; case 64 : <S2SV_StartBug> # line 1057 ""grammar.y"" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2670 ""grammar.c"" <S2SV_EndBug> break ; case 65 : <S2SV_StartBug> # line 1092 ""grammar.y"" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2753 ""grammar.c"" <S2SV_EndBug> break ; case 66 : <S2SV_StartBug> # line 1171 ""grammar.y"" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2787 ""grammar.c"" <S2SV_EndBug> break ; case 67 : <S2SV_StartBug> # line 1201 ""grammar.y"" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2840 ""grammar.c"" <S2SV_EndBug> break ; case 68 : <S2SV_StartBug> # line 1250 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2850 ""grammar.c"" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1256 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2860 ""grammar.c"" <S2SV_EndBug> break ; case 70 : <S2SV_StartBug> # line 1262 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2890 ""grammar.c"" <S2SV_EndBug> break ; case 71 : <S2SV_StartBug> # line 1288 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2930 ""grammar.c"" <S2SV_EndBug> break ; case 72 : <S2SV_StartBug> # line 1324 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2959 ""grammar.c"" <S2SV_EndBug> break ; case 73 : <S2SV_StartBug> # line 1349 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2999 ""grammar.c"" <S2SV_EndBug> break ; case 74 : <S2SV_StartBug> # line 1385 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3012 ""grammar.c"" <S2SV_EndBug> break ; case 75 : <S2SV_StartBug> # line 1394 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3025 ""grammar.c"" <S2SV_EndBug> break ; case 76 : <S2SV_StartBug> # line 1403 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3038 ""grammar.c"" <S2SV_EndBug> break ; case 77 : <S2SV_StartBug> # line 1412 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3051 ""grammar.c"" <S2SV_EndBug> break ; case 78 : <S2SV_StartBug> # line 1421 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""=="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3064 ""grammar.c"" <S2SV_EndBug> break ; case 79 : <S2SV_StartBug> # line 1430 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""!="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3077 ""grammar.c"" <S2SV_EndBug> break ; case 80 : <S2SV_StartBug> # line 1439 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3085 ""grammar.c"" <S2SV_EndBug> break ; case 81 : <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3093 ""grammar.c"" <S2SV_EndBug> break ; case 82 : <S2SV_StartBug> # line 1450 ""grammar.y"" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } <S2SV_StartBug> # line 3099 ""grammar.c"" <S2SV_EndBug> break ; case 83 : <S2SV_StartBug> # line 1451 ""grammar.y"" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_StartBug> # line 3105 ""grammar.c"" <S2SV_EndBug> break ; case 84 : <S2SV_StartBug> # line 1457 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>lower<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>upper<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3127 ""grammar.c"" <S2SV_EndBug> break ; case 85 : <S2SV_StartBug> # line 1479 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3143 ""grammar.c"" <S2SV_EndBug> break ; case 86 : <S2SV_StartBug> # line 1491 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3158 ""grammar.c"" <S2SV_EndBug> break ; case 87 : <S2SV_StartBug> # line 1506 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3167 ""grammar.c"" <S2SV_EndBug> break ; case 89 : <S2SV_StartBug> # line 1512 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , ""$*"" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3178 ""grammar.c"" <S2SV_EndBug> break ; case 92 : <S2SV_StartBug> # line 1529 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3189 ""grammar.c"" <S2SV_EndBug> break ; case 93 : <S2SV_StartBug> # line 1536 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3200 ""grammar.c"" <S2SV_EndBug> break ; case 95 : <S2SV_StartBug> # line 1548 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3208 ""grammar.c"" <S2SV_EndBug> break ; case 96 : <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } <S2SV_StartBug> # line 3216 ""grammar.c"" <S2SV_EndBug> break ; case 97 : <S2SV_StartBug> # line 1560 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3224 ""grammar.c"" <S2SV_EndBug> break ; case 98 : <S2SV_StartBug> # line 1564 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3238 ""grammar.c"" <S2SV_EndBug> break ; case 99 : <S2SV_StartBug> # line 1574 ""grammar.y"" <S2SV_EndBug> { yywarning ( yyscanner , ""Using<S2SV_blank>deprecated<S2SV_blank>\\""entrypoint\\""<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\""entry_point\\""<S2SV_blank>"" ""function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead."" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3256 ""grammar.c"" <S2SV_EndBug> break ; case 100 : <S2SV_StartBug> # line 1588 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3276 ""grammar.c"" <S2SV_EndBug> break ; case 101 : <S2SV_StartBug> # line 1604 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3290 ""grammar.c"" <S2SV_EndBug> break ; case 102 : <S2SV_StartBug> # line 1614 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3303 ""grammar.c"" <S2SV_EndBug> break ; case 103 : <S2SV_StartBug> # line 1623 ""grammar.y"" <S2SV_EndBug> { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3332 ""grammar.c"" <S2SV_EndBug> break ; case 104 : <S2SV_StartBug> # line 1648 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3348 ""grammar.c"" <S2SV_EndBug> break ; case 105 : <S2SV_StartBug> # line 1660 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3364 ""grammar.c"" <S2SV_EndBug> break ; case 106 : <S2SV_StartBug> # line 1672 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3384 ""grammar.c"" <S2SV_EndBug> break ; case 107 : <S2SV_StartBug> # line 1688 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3400 ""grammar.c"" <S2SV_EndBug> break ; case 108 : <S2SV_StartBug> # line 1700 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3420 ""grammar.c"" <S2SV_EndBug> break ; case 109 : <S2SV_StartBug> # line 1716 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , ""wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\""%s\\"""" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3469 ""grammar.c"" <S2SV_EndBug> break ; case 110 : <S2SV_StartBug> # line 1761 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3492 ""grammar.c"" <S2SV_EndBug> break ; case 111 : <S2SV_StartBug> # line 1780 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""+"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3514 ""grammar.c"" <S2SV_EndBug> break ; case 112 : <S2SV_StartBug> # line 1798 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""-"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3536 ""grammar.c"" <S2SV_EndBug> break ; case 113 : <S2SV_StartBug> # line 1816 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""*"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3558 ""grammar.c"" <S2SV_EndBug> break ; case 114 : <S2SV_StartBug> # line 1834 ""grammar.y"" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""\\\\"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3588 ""grammar.c"" <S2SV_EndBug> break ; case 115 : <S2SV_StartBug> # line 1860 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3610 ""grammar.c"" <S2SV_EndBug> break ; case 116 : <S2SV_StartBug> # line 1878 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3624 ""grammar.c"" <S2SV_EndBug> break ; case 117 : <S2SV_StartBug> # line 1888 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3638 ""grammar.c"" <S2SV_EndBug> break ; case 118 : <S2SV_StartBug> # line 1898 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3652 ""grammar.c"" <S2SV_EndBug> break ; case 119 : <S2SV_StartBug> # line 1908 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""~"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3666 ""grammar.c"" <S2SV_EndBug> break ; case 120 : <S2SV_StartBug> # line 1918 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3680 ""grammar.c"" <S2SV_EndBug> break ; case 121 : <S2SV_StartBug> # line 1928 ""grammar.y"" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> break ; case 122 : <S2SV_StartBug> # line 1938 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3702 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3706 ""grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2371 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 834 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2409 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 872 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 2455 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 918 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 2478 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 940 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2491 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 949 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2504 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 958 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2523 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 973 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2539 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 985 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2557 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 999 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 2574 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1012 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 2589 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1023 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> NULL ; } YYERROR ; } # line 2603 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1033 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2637 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1063 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2676 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1098 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2759 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1177 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2793 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1207 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2846 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1256 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> } # line 2856 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1262 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> } # line 2866 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1268 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2896 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1294 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2936 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1330 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2965 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1355 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 3005 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1391 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3018 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1400 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3031 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1409 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3044 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1418 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3057 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1427 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3070 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1436 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3083 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1445 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3091 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1449 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3099 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1456 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3105 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1457 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3111 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1463 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3133 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1485 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3149 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1497 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3164 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1512 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3173 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1518 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3184 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1535 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3195 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1542 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3206 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1554 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3214 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1558 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3222 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1566 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3230 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1570 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3244 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1580 <S2SV_ModEnd> ""grammar.y"" { yywarning <S2SV_ModStart> } # line 3262 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1594 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3282 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1610 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3296 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1620 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3309 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1629 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 3338 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1654 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3354 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1666 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3370 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1678 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3390 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1694 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3406 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1706 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3426 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1722 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3475 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1767 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3498 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1786 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3520 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1804 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3542 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1822 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3564 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1840 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3594 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1866 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3616 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1884 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3630 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1894 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3644 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1904 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3658 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1914 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3672 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1924 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3686 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1934 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3700 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1944 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3708 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> ; # line 3712 <S2SV_ModEnd> ""grammar.c"" default :"
41,"static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( ""warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }","if ( roishift < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )"
42,"<S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats."" ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> get_frame_stats ( vpx_codec_ctx_t <S2SV_ModStart> stats ) { int got_pkts = 0 ; <S2SV_ModStart> NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; } } return got_pkts ;
43,"<S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }","int vp9_loop_filter_worker ( <S2SV_ModEnd> LFWorkerData * const <S2SV_ModStart> * const lf_data , void * unused ) { <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( void ) unused <S2SV_ModEnd> ; vp9_loop_filter_rows ( <S2SV_ModStart> -> cm , lf_data -> planes <S2SV_ModEnd> , lf_data ->"
44,"static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , ""//"" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) <S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( strncmp ( file , ""../"" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , ""/../"" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , ""/.."" ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\\0' ; } }",", strlen ( cp <S2SV_ModEnd> ) - 1"
45,"static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( ""arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct arpt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }",if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
46,static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; },event ) { u64 <S2SV_ModEnd> event_id = event
47,"static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file."" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured."" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object."" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm."" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }",) ; } btif_config_devcache_cleanup ( ) ;
48,"static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups"" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }",ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
49,"static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }",+ 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( kk < input -> length ) )
50,"static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }",; rx_drop : <S2SV_ModEnd> rcv_stats -> rx_dropped
51,"static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <S2SV_StartBug> int rc ; <S2SV_EndBug> unsigned char key2 [ 8 ] ; <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> if ( IS_ERR ( tfm_des ) ) { <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n"" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <S2SV_StartBug> smbhash_err : <S2SV_EndBug> return rc ; }","key ) { <S2SV_ModEnd> unsigned char key2 <S2SV_ModStart> ] ; struct crypto_cipher * tfm_des <S2SV_ModEnd> ; str_to_key ( <S2SV_ModStart> ; tfm_des = crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> cifs_dbg ( VFS <S2SV_ModStart> ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n"" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( tfm_des , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> ( tfm_des ) <S2SV_ModStart> tfm_des ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>"
52,"void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }",++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
53,"int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; <S2SV_StartBug> if ( ret ) { <S2SV_EndBug> log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } } if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }","( ret ) ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <S2SV_ModStart> ) ; return ret ; } } if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return ret <S2SV_ModEnd> ; } }"
54,"int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( ""Entering<S2SV_blank>request<S2SV_blank>loop!\\n"" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( ""%d:<S2SV_blank>"" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , ""Disconnect<S2SV_blank>request<S2SV_blank>received."" ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( ""Not<S2SV_blank>enough<S2SV_blank>magic."" ) ; <S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ; # ifdef DODBG printf ( ""%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>"" , request . type ? ""WRITE"" : ""READ"" , ( unsigned long long ) request . from , ( unsigned long long ) request . from / 512 , len ) ; # endif memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; if ( ( request . from + len ) > ( OFFT_MAX ) ) { DEBUG ( ""[Number<S2SV_blank>too<S2SV_blank>large!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { DEBUG ( ""[RANGE!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( request . type == NBD_CMD_WRITE ) { DEBUG ( ""wr:<S2SV_blank>net->buf,<S2SV_blank>"" ) ; readit ( client -> net , buf , len ) ; DEBUG ( ""buf->exp,<S2SV_blank>"" ) ; if ( ( client -> server -> flags & F_READONLY ) || ( client -> server -> flags & F_AUTOREADONLY ) ) { DEBUG ( ""[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]"" ) ; ERROR ( client , reply , EPERM ) ; continue ; } if ( expwrite ( request . from , buf , len , client ) ) { DEBUG ( ""Write<S2SV_blank>failed:<S2SV_blank>%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } SEND ( client -> net , reply ) ; DEBUG ( ""OK!\\n"" ) ; continue ; } DEBUG ( ""exp->buf,<S2SV_blank>"" ) ; if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { DEBUG ( ""Read<S2SV_blank>failed:<S2SV_blank>%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } DEBUG ( ""buf->net,<S2SV_blank>"" ) ; memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; DEBUG ( ""OK!\\n"" ) ; } return 0 ; }",len > BUFSIZE - <S2SV_ModEnd> sizeof ( struct
55,"static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }","* bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++"
56,"void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }","= VP8_BD_VALUE_SIZE - CHAR_BIT <S2SV_ModEnd> - ( count <S2SV_ModStart> ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br ->"
57,"static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; } <S2SV_StartBug> if ( in ) { <S2SV_EndBug> dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }",( in ) <S2SV_ModEnd> dev -> in_pipe <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in
58,"static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , ""%d<S2SV_blank>bytes<S2SV_blank>left\\n"" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , ""chunk<S2SV_blank>too<S2SV_blank>big\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , ""png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n"" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ; if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : case MKTAG ( 't' , 'E' , 'X' , 't' ) : case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : case MKTAG ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto skip_tag ; } } switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) goto fail ; break ; case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) goto fail ; break ; case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) goto fail ; decode_next_dat = 1 ; break ; case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ! decode_next_dat ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_get_be32 ( & s -> gb ) ; length -= 4 ; case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) goto skip_tag ; if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) goto fail ; break ; case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : if ( decode_plte_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'R' , 'N' , 'S' ) : if ( decode_trns_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'E' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 'z' , 'T' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { int mode = bytestream2_get_byte ( & s -> gb ) ; AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; if ( ! stereo3d ) goto fail ; if ( mode == 0 || mode == 1 ) { stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; } else { av_log ( avctx , AV_LOG_WARNING , ""Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n"" , mode ) ; } bytestream2_skip ( & s -> gb , 4 ) ; break ; } case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) av_log ( avctx , AV_LOG_ERROR , ""IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n"" ) ; if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_skip ( & s -> gb , 4 ) ; goto exit_loop ; default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ; break ; } } exit_loop : if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( s -> bits_per_pixel <= 4 ) handle_small_bpp ( s , p ) ; if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; size_t raw_bpp = s -> bpp - byte_depth ; unsigned x , y ; <S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; for ( x = s -> width ; x > 0 ; -- x ) { uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; } else { memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; } } } } if ( s -> last_picture . f -> data [ 0 ] ) { if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( ""MPNG"" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format ) { if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) handle_p_frame_png ( s , p ) ; else if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) goto fail ; } } ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; av_frame_set_metadata ( p , metadata ) ; metadata = NULL ; return 0 ; fail : av_dict_free ( & metadata ) ; ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; return ret ; }",", y ; av_assert0 ( s -> bit_depth > 1 ) ;"
59,"<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }","* inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock"
60,"<S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }","len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>COMMENT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str"
61,void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; },( ! handle || ! SecIsValidHandle ( handle )
62,"static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }","NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;"
63,"<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }","int n , jas_ulonglong <S2SV_ModEnd> val ) {"
64,"fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , ""localhost"" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <S2SV_StartBug> return res ; <S2SV_EndBug> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }",; } } cleanup : <S2SV_ModEnd> return res ;
65,"NOEXPORT char * parse_service_option ( CMD cmd , SERVICE_OPTIONS * * section_ptr , char * opt , char * arg ) { SERVICE_OPTIONS * section ; int endpoints = 0 ; # ifndef USE_WIN32 struct group * gr ; struct passwd * pw ; # endif section = section_ptr ? * section_ptr : NULL ; if ( cmd == CMD_SET_DEFAULTS || cmd == CMD_SET_COPY ) { section -> ref = 1 ; <S2SV_StartBug> } else if ( cmd == CMD_FREE ) { <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options || section == & new_service_options ) <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>defaults"" ) ; <S2SV_EndBug> else s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>[%s]"" , section -> servname ) ; } else if ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE , ""<S2SV_blank>"" ) ; s_log ( LOG_NOTICE , ""Service-level<S2SV_blank>options:"" ) ; } switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; name_list_dup ( & section -> local_addr . names , new_service_options . local_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> local_addr . names ) ; str_free ( section -> local_addr . addr ) ; str_free ( section -> local_fd ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""accept"" ) ) break ; section -> option . accept = 1 ; name_list_append ( & section -> local_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> local_addr . names ) { unsigned i ; if ( ! addrlist_resolve ( & section -> local_addr ) ) return ""Cannot<S2SV_blank>resolve<S2SV_blank>accept<S2SV_blank>target"" ; section -> local_fd = str_alloc_detached ( section -> local_addr . num * sizeof ( SOCKET ) ) ; for ( i = 0 ; i < section -> local_addr . num ; ++ i ) section -> local_fd [ i ] = INVALID_SOCKET ; ++ endpoints ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>accept<S2SV_blank>connections<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>host:port"" , ""accept"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # if 0 section -> ca_dir = ( char * ) X509_get_default_cert_dir ( ) ; # endif section -> ca_dir = NULL ; break ; case CMD_SET_COPY : section -> ca_dir = str_dup_detached ( new_service_options . ca_dir ) ; break ; case CMD_FREE : str_free ( section -> ca_dir ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CApath"" ) ) break ; str_free ( section -> ca_dir ) ; if ( arg [ 0 ] ) section -> ca_dir = str_dup_detached ( arg ) ; else section -> ca_dir = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if 0 s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""CApath"" , section -> ca_dir ? section -> ca_dir : ""(none)"" ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>\'verify\'<S2SV_blank>option"" , ""CApath"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # if 0 section -> ca_file = ( char * ) X509_get_default_certfile ( ) ; # endif section -> ca_file = NULL ; break ; case CMD_SET_COPY : section -> ca_file = str_dup_detached ( new_service_options . ca_file ) ; break ; case CMD_FREE : str_free ( section -> ca_file ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CAfile"" ) ) break ; str_free ( section -> ca_file ) ; if ( arg [ 0 ] ) section -> ca_file = str_dup_detached ( arg ) ; else section -> ca_file = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if 0 s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""CAfile"" , section -> ca_file ? section -> ca_file : ""(none)"" ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>file<S2SV_blank>for<S2SV_blank>\'verify\'<S2SV_blank>option"" , ""CAfile"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> cert = NULL ; break ; case CMD_SET_COPY : section -> cert = str_dup_detached ( new_service_options . cert ) ; break ; case CMD_FREE : str_free ( section -> cert ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""cert"" ) ) break ; str_free ( section -> cert ) ; section -> cert = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : # ifndef OPENSSL_NO_PSK if ( section -> psk_keys ) break ; # endif # ifndef OPENSSL_NO_ENGINE if ( section -> engine ) break ; # endif if ( ! section -> option . client && ! section -> cert ) return ""TLS<S2SV_blank>server<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>certificate"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>certificate<S2SV_blank>chain"" , ""cert"" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10002000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_email = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_email , new_service_options . check_email ) ; break ; case CMD_FREE : name_list_free ( section -> check_email ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""checkEmail"" ) ) break ; name_list_append ( & section -> check_email , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_email && ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>email<S2SV_blank>address"" , ""checkEmail"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_host = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_host , new_service_options . check_host ) ; break ; case CMD_FREE : name_list_free ( section -> check_host ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""checkHost"" ) ) break ; name_list_append ( & section -> check_host , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_host && ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>host<S2SV_blank>name<S2SV_blank>pattern"" , ""checkHost"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_ip = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_ip , new_service_options . check_ip ) ; break ; case CMD_FREE : name_list_free ( section -> check_ip ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""checkIP"" ) ) break ; name_list_append ( & section -> check_ip , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_ip && ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>IP<S2SV_blank>address"" , ""checkIP"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> cipher_list = NULL ; break ; case CMD_SET_COPY : section -> cipher_list = str_dup_detached ( new_service_options . cipher_list ) ; break ; case CMD_FREE : str_free ( section -> cipher_list ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ciphers"" ) ) break ; str_free ( section -> cipher_list ) ; section -> cipher_list = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> cipher_list ) { # ifdef USE_FIPS if ( new_global_options . option . fips ) section -> cipher_list = str_dup_detached ( ""FIPS"" ) ; else # endif section -> cipher_list = str_dup_detached ( stunnel_cipher_list ) ; } break ; case CMD_PRINT_DEFAULTS : # ifdef USE_FIPS s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s"" , ""ciphers"" , ""FIPS"" , ""(with<S2SV_blank>\\""fips<S2SV_blank>=<S2SV_blank>yes\\"")"" ) ; s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s"" , ""ciphers"" , stunnel_cipher_list , ""(with<S2SV_blank>\\""fips<S2SV_blank>=<S2SV_blank>no\\"")"" ) ; # else s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""ciphers"" , stunnel_cipher_list ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>permitted<S2SV_blank>ciphers<S2SV_blank>for<S2SV_blank>TLS<S2SV_blank>1.2<S2SV_blank>or<S2SV_blank>older"" , ""ciphers"" ) ; break ; } # ifndef OPENSSL_NO_TLS1_3 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ciphersuites = NULL ; break ; case CMD_SET_COPY : section -> ciphersuites = str_dup_detached ( new_service_options . ciphersuites ) ; break ; case CMD_FREE : str_free ( section -> ciphersuites ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ciphersuites"" ) ) break ; str_free ( section -> ciphersuites ) ; section -> ciphersuites = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ciphersuites ) { section -> ciphersuites = str_dup_detached ( stunnel_ciphersuites ) ; } break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s"" , ""ciphersuites"" , stunnel_ciphersuites , ""(with<S2SV_blank>TLSv1.3)"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>permitted<S2SV_blank>ciphersuites<S2SV_blank>for<S2SV_blank>TLS<S2SV_blank>1.3"" , ""ciphersuites"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . client = 0 ; break ; case CMD_SET_COPY : section -> option . client = new_service_options . option . client ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""client"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . client = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . client = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>client<S2SV_blank>mode<S2SV_blank>(remote<S2SV_blank>service<S2SV_blank>uses<S2SV_blank>TLS)"" , ""client"" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10002000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> config = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> config , new_service_options . config ) ; break ; case CMD_FREE : name_list_free ( section -> config ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""config"" ) ) break ; name_list_append ( & section -> config , arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>command[:parameter]<S2SV_blank>to<S2SV_blank>execute"" , ""config"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> connect_addr , 0 ) ; section -> connect_session = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> connect_addr , 0 ) ; section -> connect_session = NULL ; name_list_dup ( & section -> connect_addr . names , new_service_options . connect_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> connect_addr . names ) ; str_free ( section -> connect_addr . addr ) ; str_free ( section -> connect_session ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""connect"" ) ) break ; name_list_append ( & section -> connect_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> connect_addr . names ) { if ( ! section -> option . delayed_lookup && ! addrlist_resolve ( & section -> connect_addr ) ) { s_log ( LOG_INFO , ""Cannot<S2SV_blank>resolve<S2SV_blank>connect<S2SV_blank>target<S2SV_blank>-<S2SV_blank>delaying<S2SV_blank>DNS<S2SV_blank>lookup"" ) ; section -> connect_addr . num = 0 ; section -> redirect_addr . num = 0 ; section -> option . delayed_lookup = 1 ; } if ( section -> option . client ) section -> connect_session = str_alloc_detached ( section -> connect_addr . num * sizeof ( SSL_SESSION * ) ) ; ++ endpoints ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>to<S2SV_blank>connect"" , ""connect"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> crl_dir = NULL ; break ; case CMD_SET_COPY : section -> crl_dir = str_dup_detached ( new_service_options . crl_dir ) ; break ; case CMD_FREE : str_free ( section -> crl_dir ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CRLpath"" ) ) break ; str_free ( section -> crl_dir ) ; if ( arg [ 0 ] ) section -> crl_dir = str_dup_detached ( arg ) ; else section -> crl_dir = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CRL<S2SV_blank>directory"" , ""CRLpath"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> crl_file = NULL ; break ; case CMD_SET_COPY : section -> crl_file = str_dup_detached ( new_service_options . crl_file ) ; break ; case CMD_FREE : str_free ( section -> crl_file ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""CRLfile"" ) ) break ; str_free ( section -> crl_file ) ; if ( arg [ 0 ] ) section -> crl_file = str_dup_detached ( arg ) ; else section -> crl_file = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>CRL<S2SV_blank>file"" , ""CRLfile"" ) ; break ; } # ifndef OPENSSL_NO_ECDH switch ( cmd ) { case CMD_SET_DEFAULTS : section -> curves = str_dup_detached ( DEFAULT_CURVES ) ; break ; case CMD_SET_COPY : section -> curves = str_dup_detached ( new_service_options . curves ) ; break ; case CMD_FREE : str_free ( section -> curves ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""curves"" ) && strcasecmp ( opt , ""curve"" ) ) break ; str_free ( section -> curves ) ; section -> curves = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""curves"" , DEFAULT_CURVES ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>ECDH<S2SV_blank>curve<S2SV_blank>names"" , ""curves"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> log_level = LOG_NOTICE ; # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) new_global_options . log_facility = LOG_DAEMON ; # endif break ; case CMD_SET_COPY : section -> log_level = new_service_options . log_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""debug"" ) ) break ; return parse_debug_level ( arg , section ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""debug"" , ""daemon.notice"" ) ; # else s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""debug"" , ""notice"" ) ; # endif break ; case CMD_PRINT_HELP : # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[facility].level<S2SV_blank>(e.g.<S2SV_blank>daemon.info)"" , ""debug"" ) ; # else s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>(e.g.<S2SV_blank>info)"" , ""debug"" ) ; # endif break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . delayed_lookup = 0 ; break ; case CMD_SET_COPY : section -> option . delayed_lookup = new_service_options . option . delayed_lookup ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""delay"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . delayed_lookup = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . delayed_lookup = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>delay<S2SV_blank>DNS<S2SV_blank>lookup<S2SV_blank>for<S2SV_blank>\'connect\'<S2SV_blank>option"" , ""delay"" ) ; break ; } # ifndef OPENSSL_NO_ENGINE switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : section -> engine = new_service_options . engine ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engineId"" ) ) break ; section -> engine = engine_get_by_id ( arg ) ; if ( ! section -> engine ) return ""Engine<S2SV_blank>ID<S2SV_blank>not<S2SV_blank>found"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>ID<S2SV_blank>of<S2SV_blank>engine<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>key<S2SV_blank>from"" , ""engineId"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : section -> engine = new_service_options . engine ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engineNum"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>engine<S2SV_blank>number"" ; section -> engine = engine_get_by_num ( tmp_int - 1 ) ; } if ( ! section -> engine ) return ""Illegal<S2SV_blank>engine<S2SV_blank>number"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>number<S2SV_blank>of<S2SV_blank>engine<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>key<S2SV_blank>from"" , ""engineNum"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> exec_name = NULL ; break ; case CMD_SET_COPY : section -> exec_name = str_dup_detached ( new_service_options . exec_name ) ; break ; case CMD_FREE : str_free ( section -> exec_name ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""exec"" ) ) break ; str_free ( section -> exec_name ) ; section -> exec_name = str_dup_detached ( arg ) ; # ifdef USE_WIN32 section -> exec_args = str_dup_detached ( arg ) ; # else if ( ! section -> exec_args ) { section -> exec_args = str_alloc_detached ( 2 * sizeof ( char * ) ) ; section -> exec_args [ 0 ] = str_dup_detached ( section -> exec_name ) ; section -> exec_args [ 1 ] = NULL ; } # endif return NULL ; case CMD_INITIALIZE : if ( section -> exec_name ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>file<S2SV_blank>execute<S2SV_blank>local<S2SV_blank>inetd-type<S2SV_blank>program"" , ""exec"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> exec_args = NULL ; break ; case CMD_SET_COPY : # ifdef USE_WIN32 section -> exec_args = str_dup_detached ( new_service_options . exec_args ) ; # else section -> exec_args = arg_dup ( new_service_options . exec_args ) ; # endif break ; case CMD_FREE : # ifdef USE_WIN32 str_free ( section -> exec_args ) ; # else arg_free ( section -> exec_args ) ; # endif break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""execArgs"" ) ) break ; # ifdef USE_WIN32 str_free ( section -> exec_args ) ; section -> exec_args = str_dup_detached ( arg ) ; # else arg_free ( section -> exec_args ) ; section -> exec_args = arg_alloc ( arg ) ; # endif return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'exec\'<S2SV_blank>(including<S2SV_blank>$0)"" , ""execArgs"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> failover = FAILOVER_PRIO ; section -> rr = 0 ; break ; case CMD_SET_COPY : section -> failover = new_service_options . failover ; section -> rr = new_service_options . rr ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""failover"" ) ) break ; if ( ! strcasecmp ( arg , ""rr"" ) ) section -> failover = FAILOVER_RR ; else if ( ! strcasecmp ( arg , ""prio"" ) ) section -> failover = FAILOVER_PRIO ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'rr\'<S2SV_blank>or<S2SV_blank>\'prio\'"" ; return NULL ; case CMD_INITIALIZE : if ( section -> option . delayed_lookup ) section -> failover = FAILOVER_PRIO ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>rr|prio<S2SV_blank>failover<S2SV_blank>strategy"" , ""failover"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> username = NULL ; break ; case CMD_SET_COPY : section -> username = str_dup_detached ( new_service_options . username ) ; break ; case CMD_FREE : str_free ( section -> username ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ident"" ) ) break ; str_free ( section -> username ) ; section -> username = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>IDENT<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>checking"" , ""ident"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""include"" ) ) break ; return include_config ( arg , section_ptr ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>directory<S2SV_blank>with<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>snippets"" , ""include"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> key = NULL ; break ; case CMD_SET_COPY : section -> key = str_dup_detached ( new_service_options . key ) ; break ; case CMD_FREE : str_free ( section -> key ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""key"" ) ) break ; str_free ( section -> key ) ; section -> key = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> cert && ! section -> key ) section -> key = str_dup_detached ( section -> cert ) ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>certificate<S2SV_blank>private<S2SV_blank>key"" , ""key"" ) ; break ; } # ifdef USE_LIBWRAP switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . libwrap = 0 ; break ; case CMD_SET_COPY : section -> option . libwrap = new_service_options . option . libwrap ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""libwrap"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . libwrap = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . libwrap = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>use<S2SV_blank>/etc/hosts.allow<S2SV_blank>and<S2SV_blank>/etc/hosts.deny"" , ""libwrap"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . local = 0 ; break ; case CMD_SET_COPY : section -> option . local = new_service_options . option . local ; memcpy ( & section -> source_addr , & new_service_options . source_addr , sizeof ( SOCKADDR_UNION ) ) ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""local"" ) ) break ; if ( ! hostport2addr ( & section -> source_addr , arg , ""0"" , 1 ) ) return ""Failed<S2SV_blank>to<S2SV_blank>resolve<S2SV_blank>local<S2SV_blank>address"" ; section -> option . local = 1 ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>to<S2SV_blank>be<S2SV_blank>used<S2SV_blank>as<S2SV_blank>source<S2SV_blank>for<S2SV_blank>remote"" ""<S2SV_blank>connections"" , ""local"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> log_id = LOG_ID_SEQUENTIAL ; break ; case CMD_SET_COPY : section -> log_id = new_service_options . log_id ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""logId"" ) ) break ; if ( ! strcasecmp ( arg , ""sequential"" ) ) section -> log_id = LOG_ID_SEQUENTIAL ; else if ( ! strcasecmp ( arg , ""unique"" ) ) section -> log_id = LOG_ID_UNIQUE ; else if ( ! strcasecmp ( arg , ""thread"" ) ) section -> log_id = LOG_ID_THREAD ; else if ( ! strcasecmp ( arg , ""process"" ) ) section -> log_id = LOG_ID_PROCESS ; else return ""Invalid<S2SV_blank>connection<S2SV_blank>identifier<S2SV_blank>type"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""logId"" , ""sequential"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>connection<S2SV_blank>identifier<S2SV_blank>type"" , ""logId"" ) ; break ; } # ifndef OPENSSL_NO_OCSP switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ocsp_url = NULL ; break ; case CMD_SET_COPY : section -> ocsp_url = str_dup_detached ( new_service_options . ocsp_url ) ; break ; case CMD_FREE : str_free ( section -> ocsp_url ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ocsp"" ) ) break ; str_free ( section -> ocsp_url ) ; section -> ocsp_url = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>OCSP<S2SV_blank>responder<S2SV_blank>URL"" , ""OCSP"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . aia = 0 ; break ; case CMD_SET_COPY : section -> option . aia = new_service_options . option . aia ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""OCSPaia"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . aia = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . aia = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>check<S2SV_blank>the<S2SV_blank>AIA<S2SV_blank>responders<S2SV_blank>from<S2SV_blank>certificates"" , ""OCSPaia"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ocsp_flags = 0 ; break ; case CMD_SET_COPY : section -> ocsp_flags = new_service_options . ocsp_flags ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""OCSPflag"" ) ) break ; { unsigned long tmp_ulong = parse_ocsp_flag ( arg ) ; if ( ! tmp_ulong ) return ""Illegal<S2SV_blank>OCSP<S2SV_blank>flag"" ; section -> ocsp_flags |= tmp_ulong ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>OCSP<S2SV_blank>responder<S2SV_blank>flags"" , ""OCSPflag"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . nonce = 0 ; break ; case CMD_SET_COPY : section -> option . nonce = new_service_options . option . nonce ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""OCSPnonce"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . nonce = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . nonce = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>and<S2SV_blank>verify<S2SV_blank>the<S2SV_blank>OCSP<S2SV_blank>nonce<S2SV_blank>extension"" , ""OCSPnonce"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ssl_options_set = 0 ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL section -> ssl_options_clear = 0 ; # endif break ; case CMD_SET_COPY : section -> ssl_options_set = new_service_options . ssl_options_set ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL section -> ssl_options_clear = new_service_options . ssl_options_clear ; # endif break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""options"" ) ) break ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL if ( * arg == '-' ) { long unsigned tmp = parse_ssl_option ( arg + 1 ) ; if ( tmp == INVALID_SSL_OPTION ) return ""Illegal<S2SV_blank>TLS<S2SV_blank>option"" ; section -> ssl_options_clear |= tmp ; return NULL ; } # endif { long unsigned tmp = parse_ssl_option ( arg ) ; if ( tmp == INVALID_SSL_OPTION ) return ""Illegal<S2SV_blank>TLS<S2SV_blank>option"" ; section -> ssl_options_set |= tmp ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""options"" , ""NO_SSLv2"" ) ; s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""options"" , ""NO_SSLv3"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>TLS<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set/reset"" , ""options"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol = NULL ; break ; case CMD_SET_COPY : section -> protocol = str_dup_detached ( new_service_options . protocol ) ; break ; case CMD_FREE : str_free ( section -> protocol ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocol"" ) ) break ; str_free ( section -> protocol ) ; section -> protocol = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : { char * tmp_str = protocol ( NULL , section , PROTOCOL_CHECK ) ; if ( tmp_str ) return tmp_str ; } endpoints += section -> option . protocol_endpoint ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>protocol<S2SV_blank>to<S2SV_blank>negotiate<S2SV_blank>before<S2SV_blank>TLS<S2SV_blank>initialization"" , ""protocol"" ) ; s_log ( LOG_NOTICE , ""%25scurrently<S2SV_blank>supported:<S2SV_blank>cifs,<S2SV_blank>connect,<S2SV_blank>imap,"" , """" ) ; s_log ( LOG_NOTICE , ""%25s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nntp,<S2SV_blank>pgsql,<S2SV_blank>pop3,<S2SV_blank>proxy,<S2SV_blank>smtp,<S2SV_blank>socks"" , """" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_authentication = str_dup_detached ( ""basic"" ) ; break ; case CMD_SET_COPY : section -> protocol_authentication = str_dup_detached ( new_service_options . protocol_authentication ) ; break ; case CMD_FREE : str_free ( section -> protocol_authentication ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolAuthentication"" ) ) break ; str_free ( section -> protocol_authentication ) ; section -> protocol_authentication = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>authentication<S2SV_blank>type<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolAuthentication"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_domain = NULL ; break ; case CMD_SET_COPY : section -> protocol_domain = str_dup_detached ( new_service_options . protocol_domain ) ; break ; case CMD_FREE : str_free ( section -> protocol_domain ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolDomain"" ) ) break ; str_free ( section -> protocol_domain ) ; section -> protocol_domain = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>domain<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolDomain"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_host = NULL ; break ; case CMD_SET_COPY : section -> protocol_host = str_dup_detached ( new_service_options . protocol_host ) ; break ; case CMD_FREE : str_free ( section -> protocol_host ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolHost"" ) ) break ; str_free ( section -> protocol_host ) ; section -> protocol_host = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>host:port<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolHost"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_password = NULL ; break ; case CMD_SET_COPY : section -> protocol_password = str_dup_detached ( new_service_options . protocol_password ) ; break ; case CMD_FREE : str_free ( section -> protocol_password ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolPassword"" ) ) break ; str_free ( section -> protocol_password ) ; section -> protocol_password = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>password<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolPassword"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_username = NULL ; break ; case CMD_SET_COPY : section -> protocol_username = str_dup_detached ( new_service_options . protocol_username ) ; break ; case CMD_FREE : str_free ( section -> protocol_username ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""protocolUsername"" ) ) break ; str_free ( section -> protocol_username ) ; section -> protocol_username = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations"" , ""protocolUsername"" ) ; break ; } # ifndef OPENSSL_NO_PSK switch ( cmd ) { case CMD_SET_DEFAULTS : section -> psk_identity = NULL ; section -> psk_selected = NULL ; section -> psk_sorted . val = NULL ; section -> psk_sorted . num = 0 ; break ; case CMD_SET_COPY : section -> psk_identity = str_dup_detached ( new_service_options . psk_identity ) ; break ; case CMD_FREE : str_free ( section -> psk_identity ) ; str_free ( section -> psk_sorted . val ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""PSKidentity"" ) ) break ; str_free ( section -> psk_identity ) ; section -> psk_identity = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> psk_keys ) break ; psk_sort ( & section -> psk_sorted , section -> psk_keys ) ; if ( section -> option . client ) { if ( section -> psk_identity ) { section -> psk_selected = psk_find ( & section -> psk_sorted , section -> psk_identity ) ; if ( ! section -> psk_selected ) return ""No<S2SV_blank>key<S2SV_blank>found<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>PSK<S2SV_blank>identity"" ; } else { section -> psk_selected = section -> psk_keys ; } } else { if ( section -> psk_identity ) s_log ( LOG_NOTICE , ""PSK<S2SV_blank>identity<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>server<S2SV_blank>mode"" ) ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>identity<S2SV_blank>for<S2SV_blank>PSK<S2SV_blank>authentication"" , ""PSKidentity"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> psk_keys = NULL ; break ; case CMD_SET_COPY : section -> psk_keys = psk_dup ( new_service_options . psk_keys ) ; break ; case CMD_FREE : psk_free ( section -> psk_keys ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""PSKsecrets"" ) ) break ; section -> psk_keys = psk_read ( arg ) ; if ( ! section -> psk_keys ) return ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>PSK<S2SV_blank>secrets"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>secrets<S2SV_blank>for<S2SV_blank>PSK<S2SV_blank>authentication"" , ""PSKsecrets"" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . pty = 0 ; break ; case CMD_SET_COPY : section -> option . pty = new_service_options . option . pty ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""pty"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . pty = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . pty = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>allocate<S2SV_blank>pseudo<S2SV_blank>terminal<S2SV_blank>for<S2SV_blank>\'exec\'<S2SV_blank>option"" , ""pty"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> redirect_addr , 0 ) ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> redirect_addr , 0 ) ; name_list_dup ( & section -> redirect_addr . names , new_service_options . redirect_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> redirect_addr . names ) ; str_free ( section -> redirect_addr . addr ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""redirect"" ) ) break ; name_list_append ( & section -> redirect_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> redirect_addr . names ) { if ( section -> option . client ) return ""\\""redirect\\""<S2SV_blank>is<S2SV_blank>unsupported<S2SV_blank>in<S2SV_blank>client<S2SV_blank>sections"" ; if ( section -> option . connect_before_ssl ) return ""\\""redirect\\""<S2SV_blank>is<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>protocol<S2SV_blank>negotiation"" ; if ( ! section -> option . delayed_lookup && ! addrlist_resolve ( & section -> redirect_addr ) ) { s_log ( LOG_INFO , ""Cannot<S2SV_blank>resolve<S2SV_blank>redirect<S2SV_blank>target<S2SV_blank>-<S2SV_blank>delaying<S2SV_blank>DNS<S2SV_blank>lookup"" ) ; section -> connect_addr . num = 0 ; section -> redirect_addr . num = 0 ; section -> option . delayed_lookup = 1 ; } if ( ! section -> option . verify_chain && ! section -> option . verify_peer ) return ""Either<S2SV_blank>\\""verifyChain\\""<S2SV_blank>or<S2SV_blank>\\""verifyPeer\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>for<S2SV_blank>\\""redirect\\""<S2SV_blank>to<S2SV_blank>work"" ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>to<S2SV_blank>redirect<S2SV_blank>on<S2SV_blank>authentication<S2SV_blank>failures"" , ""redirect"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . renegotiation = 1 ; break ; case CMD_SET_COPY : section -> option . renegotiation = new_service_options . option . renegotiation ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""renegotiation"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . renegotiation = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . renegotiation = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>support<S2SV_blank>renegotiation"" , ""renegotiation"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . require_cert = 0 ; break ; case CMD_SET_COPY : section -> option . require_cert = new_service_options . option . require_cert ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""requireCert"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; } else if ( ! strcasecmp ( arg , ""no"" ) ) { section -> option . require_cert = 0 ; } else { return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>require<S2SV_blank>client<S2SV_blank>certificate"" , ""requireCert"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . reset = 1 ; break ; case CMD_SET_COPY : section -> option . reset = new_service_options . option . reset ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""reset"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . reset = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . reset = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>TCP<S2SV_blank>RST<S2SV_blank>on<S2SV_blank>error"" , ""reset"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . retry = 0 ; break ; case CMD_SET_COPY : section -> option . retry = new_service_options . option . retry ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""retry"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) section -> option . retry = 1 ; else if ( ! strcasecmp ( arg , ""no"" ) ) section -> option . retry = 0 ; else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>retry<S2SV_blank>connect+exec<S2SV_blank>section"" , ""retry"" ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> servname = str_dup_detached ( ""stunnel"" ) ; break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""service"" ) ) break ; str_free ( section -> servname ) ; section -> servname = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>service<S2SV_blank>name"" , ""service"" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> gid = 0 ; break ; case CMD_SET_COPY : section -> gid = new_service_options . gid ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""setgid"" ) ) break ; gr = getgrnam ( arg ) ; if ( gr ) { section -> gid = gr -> gr_gid ; return NULL ; } { char * tmp_str ; section -> gid = ( gid_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>GID"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>groupname<S2SV_blank>for<S2SV_blank>setgid()"" , ""setgid"" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> uid = 0 ; break ; case CMD_SET_COPY : section -> uid = new_service_options . uid ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""setuid"" ) ) break ; pw = getpwnam ( arg ) ; if ( pw ) { section -> uid = pw -> pw_uid ; return NULL ; } { char * tmp_str ; section -> uid = ( uid_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>UID"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>setuid()"" , ""setuid"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> session_size = 1000L ; break ; case CMD_SET_COPY : section -> session_size = new_service_options . session_size ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sessionCacheSize"" ) ) break ; { char * tmp_str ; section -> session_size = strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>size"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%ld"" , ""sessionCacheSize"" , 1000L ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>size"" , ""sessionCacheSize"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> session_timeout = 300L ; break ; case CMD_SET_COPY : section -> session_timeout = new_service_options . session_timeout ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sessionCacheTimeout"" ) && strcasecmp ( opt , ""session"" ) ) break ; { char * tmp_str ; section -> session_timeout = strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%ld<S2SV_blank>seconds"" , ""sessionCacheTimeout"" , 300L ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>timeout<S2SV_blank>(in<S2SV_blank>seconds)"" , ""sessionCacheTimeout"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . sessiond = 0 ; memset ( & section -> sessiond_addr , 0 , sizeof ( SOCKADDR_UNION ) ) ; section -> sessiond_addr . in . sin_family = AF_INET ; break ; case CMD_SET_COPY : section -> option . sessiond = new_service_options . option . sessiond ; memcpy ( & section -> sessiond_addr , & new_service_options . sessiond_addr , sizeof ( SOCKADDR_UNION ) ) ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sessiond"" ) ) break ; section -> option . sessiond = 1 ; # ifdef SSL_OP_NO_TICKET section -> ssl_options_set |= SSL_OP_NO_TICKET ; # endif if ( ! name2addr ( & section -> sessiond_addr , arg , 0 ) ) return ""Failed<S2SV_blank>to<S2SV_blank>resolve<S2SV_blank>sessiond<S2SV_blank>server<S2SV_blank>address"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>use<S2SV_blank>sessiond<S2SV_blank>at<S2SV_blank>host:port"" , ""sessiond"" ) ; break ; } # ifndef OPENSSL_NO_TLSEXT switch ( cmd ) { case CMD_SET_DEFAULTS : section -> servername_list_head = NULL ; section -> servername_list_tail = NULL ; break ; case CMD_SET_COPY : section -> sni = str_dup_detached ( new_service_options . sni ) ; break ; case CMD_FREE : str_free ( section -> sni ) ; sni_free ( section ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sni"" ) ) break ; str_free ( section -> sni ) ; section -> sni = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : { char * tmp_str = sni_init ( section ) ; if ( tmp_str ) return tmp_str ; } if ( ! section -> option . client && section -> sni ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>master_service:host_name<S2SV_blank>for<S2SV_blank>an<S2SV_blank>SNI<S2SV_blank>virtual<S2SV_blank>service"" , ""sni"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> sock_opts = socket_options_init ( ) ; break ; case CMD_SET_COPY : section -> sock_opts = socket_options_dup ( new_service_options . sock_opts ) ; break ; case CMD_FREE : socket_options_free ( section -> sock_opts ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""socket"" ) ) break ; if ( socket_option_parse ( section -> sock_opts , arg ) ) return ""Illegal<S2SV_blank>socket<S2SV_blank>option"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>a|l|r:option=value[:value]"" , ""socket"" ) ; s_log ( LOG_NOTICE , ""%25sset<S2SV_blank>an<S2SV_blank>option<S2SV_blank>on<S2SV_blank>accept/local/remote<S2SV_blank>socket"" , """" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersion"" ) ) break ; section -> max_proto_version = section -> min_proto_version = str_to_proto_version ( arg ) ; if ( section -> max_proto_version == - 1 ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version"" ; return NULL ; case CMD_INITIALIZE : if ( section -> max_proto_version && section -> min_proto_version && section -> max_proto_version < section -> min_proto_version ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>range"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv3|TLSv1|TLSv1.1|TLSv1.2"" # ifdef TLS1_3_VERSION ""|TLSv1.3"" # endif ""<S2SV_blank>TLS<S2SV_blank>version"" , ""sslVersion"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> max_proto_version = 0 ; break ; case CMD_SET_COPY : section -> max_proto_version = new_service_options . max_proto_version ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersionMax"" ) ) break ; section -> max_proto_version = str_to_proto_version ( arg ) ; if ( section -> max_proto_version == - 1 ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv3|TLSv1|TLSv1.1|TLSv1.2"" # ifdef TLS1_3_VERSION ""|TLSv1.3"" # endif ""<S2SV_blank>TLS<S2SV_blank>version"" , ""sslVersionMax"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> min_proto_version = TLS1_VERSION ; break ; case CMD_SET_COPY : section -> min_proto_version = new_service_options . min_proto_version ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersionMin"" ) ) break ; section -> min_proto_version = str_to_proto_version ( arg ) ; if ( section -> min_proto_version == - 1 ) return ""Invalid<S2SV_blank>protocol<S2SV_blank>version"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv3|TLSv1|TLSv1.1|TLSv1.2"" # ifdef TLS1_3_VERSION ""|TLSv1.3"" # endif ""<S2SV_blank>TLS<S2SV_blank>version"" , ""sslVersionMin"" ) ; break ; } # else switch ( cmd ) { case CMD_SET_DEFAULTS : tls_methods_set ( section , NULL ) ; break ; case CMD_SET_COPY : section -> client_method = new_service_options . client_method ; section -> server_method = new_service_options . server_method ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""sslVersion"" ) ) break ; return tls_methods_set ( section , arg ) ; case CMD_INITIALIZE : { char * tmp_str = tls_methods_check ( section ) ; if ( tmp_str ) return tmp_str ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>all"" ""|SSLv2|SSLv3|TLSv1"" # if OPENSSL_VERSION_NUMBER >= 0x10001000L ""|TLSv1.1|TLSv1.2"" # endif ""<S2SV_blank>TLS<S2SV_blank>method"" , ""sslVersion"" ) ; break ; } # endif # ifndef USE_FORK switch ( cmd ) { case CMD_SET_DEFAULTS : section -> stack_size = DEFAULT_STACK_SIZE ; break ; case CMD_SET_COPY : section -> stack_size = new_service_options . stack_size ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""stack"" ) ) break ; { char * tmp_str ; section -> stack_size = ( size_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>thread<S2SV_blank>stack<S2SV_blank>size"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes"" , ""stack"" , DEFAULT_STACK_SIZE ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>thread<S2SV_blank>stack<S2SV_blank>size<S2SV_blank>(in<S2SV_blank>bytes)"" , ""stack"" ) ; break ; } # endif # if OPENSSL_VERSION_NUMBER >= 0x10000000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ticket_key = NULL ; break ; case CMD_SET_COPY : section -> ticket_key = key_dup ( new_service_options . ticket_key ) ; break ; case CMD_FREE : key_free ( section -> ticket_key ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ticketKeySecret"" ) ) break ; section -> ticket_key = key_read ( arg , ""ticketKeySecret"" ) ; if ( ! section -> ticket_key ) return ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>ticketKeySecret"" ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ticket_key ) break ; if ( section -> option . client ) { s_log ( LOG_NOTICE , ""ticketKeySecret<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>client<S2SV_blank>mode"" ) ; break ; } if ( section -> ticket_key && ! section -> ticket_mac ) return ""\\""ticketKeySecret\\""<S2SV_blank>and<S2SV_blank>\\""ticketMacSecret\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>together"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>secret<S2SV_blank>key<S2SV_blank>for<S2SV_blank>encryption/decryption<S2SV_blank>TLSv1.3<S2SV_blank>tickets"" , ""ticketKeySecret"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ticket_mac = NULL ; break ; case CMD_SET_COPY : section -> ticket_mac = key_dup ( new_service_options . ticket_mac ) ; break ; case CMD_FREE : key_free ( section -> ticket_mac ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""ticketMacSecret"" ) ) break ; section -> ticket_mac = key_read ( arg , ""ticketMacSecret"" ) ; if ( ! section -> ticket_mac ) return ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>ticketMacSecret"" ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ticket_mac ) break ; if ( section -> option . client ) { s_log ( LOG_NOTICE , ""ticketMacSecret<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>client<S2SV_blank>mode"" ) ; break ; } if ( section -> ticket_mac && ! section -> ticket_key ) return ""\\""ticketKeySecret\\""<S2SV_blank>and<S2SV_blank>\\""ticketMacSecret\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>together"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>key<S2SV_blank>for<S2SV_blank>HMAC<S2SV_blank>operations<S2SV_blank>on<S2SV_blank>TLSv1.3<S2SV_blank>tickets"" , ""ticketMacSecret"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_busy = 300 ; break ; case CMD_SET_COPY : section -> timeout_busy = new_service_options . timeout_busy ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTbusy"" ) ) break ; { char * tmp_str ; section -> timeout_busy = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>busy<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTbusy"" , 300 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>expected<S2SV_blank>data"" , ""TIMEOUTbusy"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_close = 60 ; break ; case CMD_SET_COPY : section -> timeout_close = new_service_options . timeout_close ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTclose"" ) ) break ; { char * tmp_str ; section -> timeout_close = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>close<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTclose"" , 60 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>close_notify"" , ""TIMEOUTclose"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_connect = 10 ; break ; case CMD_SET_COPY : section -> timeout_connect = new_service_options . timeout_connect ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTconnect"" ) ) break ; { char * tmp_str ; section -> timeout_connect = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>connect<S2SV_blank>timeout"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTconnect"" , 10 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>remote<S2SV_blank>host"" , ""TIMEOUTconnect"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_idle = 43200 ; break ; case CMD_SET_COPY : section -> timeout_idle = new_service_options . timeout_idle ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""TIMEOUTidle"" ) ) break ; { char * tmp_str ; section -> timeout_idle = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>idle<S2SV_blank>timeout"" ; return NULL ; } case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds"" , ""TIMEOUTidle"" , 43200 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>keep<S2SV_blank>an<S2SV_blank>idle<S2SV_blank>connection"" , ""TIMEOUTidle"" ) ; break ; } # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . transparent_src = 0 ; section -> option . transparent_dst = 0 ; break ; case CMD_SET_COPY : section -> option . transparent_src = new_service_options . option . transparent_src ; section -> option . transparent_dst = new_service_options . option . transparent_dst ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""transparent"" ) ) break ; if ( ! strcasecmp ( arg , ""none"" ) || ! strcasecmp ( arg , ""no"" ) ) { section -> option . transparent_src = 0 ; section -> option . transparent_dst = 0 ; } else if ( ! strcasecmp ( arg , ""source"" ) || ! strcasecmp ( arg , ""yes"" ) ) { section -> option . transparent_src = 1 ; section -> option . transparent_dst = 0 ; } else if ( ! strcasecmp ( arg , ""destination"" ) ) { section -> option . transparent_src = 0 ; section -> option . transparent_dst = 1 ; } else if ( ! strcasecmp ( arg , ""both"" ) ) { section -> option . transparent_src = 1 ; section -> option . transparent_dst = 1 ; } else return ""Selected<S2SV_blank>transparent<S2SV_blank>proxy<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ; return NULL ; case CMD_INITIALIZE : if ( section -> option . transparent_dst ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>none|source|destination|both<S2SV_blank>transparent<S2SV_blank>proxy<S2SV_blank>mode"" , ""transparent"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . request_cert = 0 ; break ; case CMD_SET_COPY : section -> option . request_cert = new_service_options . option . request_cert ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""verify"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 4 ) return ""Bad<S2SV_blank>verify<S2SV_blank>level"" ; section -> option . request_cert = 1 ; section -> option . require_cert = ( tmp_int >= 2 ) ; section -> option . verify_chain = ( tmp_int >= 1 && tmp_int <= 3 ) ; section -> option . verify_peer = ( tmp_int >= 3 ) ; } return NULL ; case CMD_INITIALIZE : if ( ( section -> option . verify_chain || section -> option . verify_peer ) && ! section -> ca_file && ! section -> ca_dir ) return ""Either<S2SV_blank>\\""CAfile\\""<S2SV_blank>or<S2SV_blank>\\""CApath\\""<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>configured"" ; break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>none"" , ""verify"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>of<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>verification"" , ""verify"" ) ; <S2SV_StartBug> s_log ( LOG_NOTICE , <S2SV_EndBug> ""%25slevel<S2SV_blank>0<S2SV_blank>-<S2SV_blank>request<S2SV_blank>and<S2SV_blank>ignore<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>1<S2SV_blank>-<S2SV_blank>only<S2SV_blank>validate<S2SV_blank>peer<S2SV_blank>cert<S2SV_blank>if<S2SV_blank>present"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>2<S2SV_blank>-<S2SV_blank>always<S2SV_blank>require<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>3<S2SV_blank>-<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>with<S2SV_blank>locally<S2SV_blank>installed<S2SV_blank>cert"" , """" ) ; s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>4<S2SV_blank>-<S2SV_blank>ignore<S2SV_blank>CA<S2SV_blank>chain<S2SV_blank>and<S2SV_blank>only<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . verify_chain = 0 ; break ; case CMD_SET_COPY : section -> option . verify_chain = new_service_options . option . verify_chain ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""verifyChain"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; section -> option . verify_chain = 1 ; } else if ( ! strcasecmp ( arg , ""no"" ) ) { section -> option . verify_chain = 0 ; } else { return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>verify<S2SV_blank>certificate<S2SV_blank>chain"" , ""verifyChain"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . verify_peer = 0 ; break ; case CMD_SET_COPY : section -> option . verify_peer = new_service_options . option . verify_peer ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""verifyPeer"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; section -> option . verify_peer = 1 ; } else if ( ! strcasecmp ( arg , ""no"" ) ) { section -> option . verify_peer = 0 ; } else { return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>certificate"" , ""verifyPeer"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : str_free ( section -> chain ) ; if ( section -> session ) SSL_SESSION_free ( section -> session ) ; if ( section -> ctx ) SSL_CTX_free ( section -> ctx ) ; str_free ( section -> servname ) ; <S2SV_StartBug> if ( section == & service_options ) <S2SV_EndBug> memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ; else str_free ( section ) ; break ; case CMD_SET_VALUE : return option_not_found ; case CMD_INITIALIZE : if ( section != & new_service_options ) { if ( endpoints != 2 ) return ""Each<S2SV_blank>service<S2SV_blank>must<S2SV_blank>define<S2SV_blank>two<S2SV_blank>endpoints"" ; } else { if ( section -> option . accept ) return ""\'accept\'<S2SV_blank>option<S2SV_blank>is<S2SV_blank>only<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>a<S2SV_blank>[section]"" ; if ( endpoints != 1 ) return ""Inetd<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>define<S2SV_blank>one<S2SV_blank>endpoint"" ; } # ifdef SSL_OP_NO_TICKET if ( OpenSSL_version_num ( ) < 0x10101000L && ! section -> option . client && ! section -> option . connect_before_ssl ) section -> ssl_options_set |= SSL_OP_NO_TICKET ; # endif if ( context_init ( section ) ) return ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>TLS<S2SV_blank>context"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : break ; } return NULL ; }","= 1 ; if ( section == & service_options ) s_log ( LOG_ERR , ""INTERNAL<S2SV_blank>ERROR:<S2SV_blank>Initializing<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , section -> servname ) ; <S2SV_ModStart> == & service_options ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( <S2SV_ModEnd> section == & <S2SV_ModStart> ( LOG_DEBUG , ""Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""securityLevel"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return ""Illegal<S2SV_blank>security<S2SV_blank>level"" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""securityLevel"" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level"" , ""securityLevel"" ) ; break ; } # endif <S2SV_ModStart> ""verify"" ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> == & service_options || section == & new_service_options"
66,static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> },"{ lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt )"
67,"int vp8_hex_search ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvsadcost [ 2 ] , int * mvcost [ 2 ] , int_mv * center_mv ) { MV hex [ 6 ] = { { - 1 , - 2 } , { 1 , - 2 } , { 2 , 0 } , { 1 , 2 } , { - 1 , 2 } , { - 2 , 0 } } ; MV neighbors [ 4 ] = { { 0 , - 1 } , { - 1 , 0 } , { 1 , 0 } , { 0 , 1 } } ; int i , j ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int br , bc ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; unsigned char * base_offset ; unsigned char * this_offset ; int k = - 1 ; int all_in ; int best_site = - 1 ; int hex_range = 127 ; int dia_range = 8 ; int_mv fcenter_mv ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; <S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> br = ref_mv -> as_mv . row ; bc = ref_mv -> as_mv . col ; base_offset = ( unsigned char * ) ( base_pre + d -> offset ) ; this_offset = base_offset + ( br * ( pre_stride ) ) + bc ; this_mv . as_mv . row = br ; this_mv . as_mv . col = bc ; <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; # if CONFIG_MULTI_RES_ENCODING if ( search_param >= 6 ) goto cal_neighbors ; else if ( search_param >= 5 ) hex_range = 4 ; else if ( search_param >= 4 ) hex_range = 6 ; else if ( search_param >= 3 ) hex_range = 15 ; else if ( search_param >= 2 ) hex_range = 31 ; else if ( search_param >= 1 ) hex_range = 63 ; dia_range = 8 ; <S2SV_StartBug> # endif <S2SV_EndBug> CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) goto cal_neighbors ; else { br += hex [ best_site ] . row ; bc += hex [ best_site ] . col ; k = best_site ; } for ( j = 1 ; j < hex_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += next_chkpts [ k ] [ best_site ] . row ; bc += next_chkpts [ k ] [ best_site ] . col ; k += 5 + best_site ; if ( k >= 12 ) k -= 12 ; else if ( k >= 6 ) k -= 6 ; } } cal_neighbors : for ( j = 0 ; j < dia_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 1 ) if ( all_in ) { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += neighbors [ best_site ] . row ; bc += neighbors [ best_site ] . col ; } } best_mv -> as_mv . row = br ; best_mv -> as_mv . col = bc ; return bestsad ; }",">> 3 ; ( void ) mvcost ; <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> 8 ; # else ( void ) search_param ; # <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER <S2SV_ModStart> this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER"
68,"static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> struct hlist_node * n ; int err ; <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out : <S2SV_StartBug> return err ; <S2SV_EndBug> }",") ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ; out : ns -> pending_mounts = 0 ;"
69,"void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , ""authorization"" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , ""basic"" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , ""content-length:"" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , ""content-type:"" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , ""x-www-form-urlencoded"" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , ""HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n"" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : """" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , ""<tr>"" ""<td>%s</td><td><A<S2SV_blank>HREF=\\\'/C%c%d\\\'>%s</A></td><td>"" , ( cp -> comment ) ? cp -> comment : ""&nbsp;"" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? ""NO"" : ""YES"" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , "",<br<S2SV_blank>/>\\r\\n"" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , ""</td><td<S2SV_blank>colspan=\\\'6\\\'<S2SV_blank>align=\\\'center\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\r\\n"" ) ; } else { inbuf += sprintf ( buf + inbuf , ""</td><td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>MB%s</td>"" ""<td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>%s</td>"" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : ""never"" ) ; inbuf += sprintf ( buf + inbuf , ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\\r\\n"" , cp -> updated ? ctime ( & cp -> updated ) : ""never"" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , ""<h3>Reload<S2SV_blank>scheduled</h3>"" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , ""<h3><font<S2SV_blank>color=\\""red\\"">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>"" ) ; break ; } printstr ( & pp , ""<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>"" ) ; <S2SV_StartBug> printstr ( & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , ""</textarea><br><input<S2SV_blank>type=\\""Submit\\""></form>"" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , ""conffile="" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , ""%s"" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? ""<h3><font<S2SV_blank>color=\\""red\\"">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\""writable\\""<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file"" : ""<h3>Configuration<S2SV_blank>updated</h3>"" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }","printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , ""%u"" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""<S2SV_blank>enctype=\\""application/x-www-form-urlencoded\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if"
70,"void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }","sk , SCM_TSTAMP_SND , false"
71,"<S2SV_StartBug> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <S2SV_EndBug> { struct file * filp ; int ret ; <S2SV_StartBug> if ( nd -> intent . open . flags & FMODE_EXEC ) { <S2SV_EndBug> ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : <S2SV_StartBug> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <S2SV_EndBug> return ret ; }","nfs4_state * state , fmode_t fmode <S2SV_ModStart> ; if ( fmode <S2SV_ModEnd> & FMODE_EXEC ) <S2SV_ModStart> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> ) ; return"
72,"struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }",return map ; map =
73,"static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }","-> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> w = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,"
74,"static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug> # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""!="" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) { PyObject_FREE ( str ) ; err_ret -> expected = NOTEQUAL ; err_ret -> error = E_SYNTAX ; break ; } } # endif lineno = type == STRING ? tok -> first_lineno : tok -> lineno ; line_start = type == STRING ? tok -> multi_line_start : tok -> line_start ; if ( a != NULL && a >= line_start ) { col_offset = Py_SAFE_DOWNCAST ( a - line_start , intptr_t , int ) ; } else { col_offset = - 1 ; } if ( b != NULL && b >= tok -> line_start ) { end_col_offset = Py_SAFE_DOWNCAST ( b - tok -> line_start , intptr_t , int ) ; } else { end_col_offset = - 1 ; } <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug> # ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; PyNode_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = NULL ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; # endif PyParser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = col_offset != - 1 ? col_offset + 1 : ( ( int ) ( tok -> cur - tok -> buf ) ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = PyNode_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : PyTokenizer_Free ( tok ) ; if ( n != NULL ) { _PyNode_FinalizeEndPos ( n ) ; } return n ; }",", end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )"
75,"static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; }",segmentation_map ) { memcpy <S2SV_ModEnd> ( cpi ->
76,"void vp9_rc_postencode_update_drop_frame ( VP9_COMP * cpi ) { update_buffer_level ( cpi , 0 ) ; <S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> cpi -> rc . frames_since_key ++ ; cpi -> rc . frames_to_key -- ; <S2SV_StartBug> } <S2SV_EndBug>",; cpi -> <S2SV_ModEnd> rc . frames_since_key <S2SV_ModStart> frames_to_key -- ; cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ;
77,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }"
78,"static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }","size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> -> ops ; <S2SV_ModEnd> size_t chars = <S2SV_ModStart> buf -> len ; size_t written <S2SV_ModStart> ; int error <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ;"
79,"stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""<S2SV_blank>with<S2SV_blank>policy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>\\""%s\\""<S2SV_blank>forbids<S2SV_blank>connection"" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( ""found<S2SV_blank>connection:<S2SV_blank>%s\\n"" , c ? c -> name : ""<none>"" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( ""received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it"" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( ""dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet"" , blob ) ; DBG_dump ( ""dcookie<S2SV_blank>computed"" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( ""mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one"" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( ""dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one"" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie"" ) ; DBG_log ( ""send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state"" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie"" ) ) ; } { struct ikev2_ke * ke ; <S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ; <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , ""ikev2_inI1outR1<S2SV_blank>KE"" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , ""system<S2SV_blank>too<S2SV_blank>busy"" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }","* ke ; <S2SV_ModEnd> char fromname [ <S2SV_ModStart> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname <S2SV_ModStart> ) ; return STF_FAIL +"
80,"static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }",if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2
81,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","val , regs <S2SV_ModEnd> ) ; }"
82,"int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }","lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart> in_use ++ ; <S2SV_ModEnd> if ( next_id"
83,"bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl2 -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl2 -> tl_data_length = len ; tl2 -> tl_data_next = tl ; tl = tl2 ; } * tl_data_head = tl ; break ; } return TRUE ; }",tl2 ; } * tl_data_head = NULL ;
84,"static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT"" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET"" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN"" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , ""nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n"" ) ; break ; default : dev_err ( & desc -> intf -> dev , ""Unexpected<S2SV_blank>error<S2SV_blank>%d\\n"" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }","-> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up"
85,"int DetectEngineContentInspection ( DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , const Signature * s , const SigMatchData * smd , Flow * f , uint8_t * buffer , uint32_t buffer_len , uint32_t stream_start_offset , uint8_t inspection_mode , void * data ) { SCEnter ( ) ; KEYWORD_PROFILING_START ; det_ctx -> inspection_recursion_counter ++ ; if ( det_ctx -> inspection_recursion_counter == de_ctx -> inspection_recursion_limit ) { det_ctx -> discontinue_matching = 1 ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd == NULL || buffer_len == 0 ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd -> type == DETECT_CONTENT ) { DetectContentData * cd = ( DetectContentData * ) smd -> ctx ; SCLogDebug ( ""inspecting<S2SV_blank>content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 , cd -> id , buffer_len ) ; # ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ; # endif uint8_t * found = NULL ; uint32_t offset = 0 ; uint32_t depth = buffer_len ; uint32_t prev_offset = 0 ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; do { if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) { SCLogDebug ( ""det_ctx->buffer_offset<S2SV_blank>%"" PRIu32 , det_ctx -> buffer_offset ) ; offset = prev_buffer_offset ; depth = buffer_len ; int distance = cd -> distance ; if ( cd -> flags & DETECT_CONTENT_DISTANCE ) { if ( cd -> flags & DETECT_CONTENT_DISTANCE_BE ) { distance = det_ctx -> bj_values [ cd -> distance ] ; } if ( distance < 0 && ( uint32_t ) ( abs ( distance ) ) > offset ) offset = 0 ; else offset += distance ; SCLogDebug ( ""cd->distance<S2SV_blank>%"" PRIi32 "",<S2SV_blank>offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , distance , offset , depth ) ; } if ( cd -> flags & DETECT_CONTENT_WITHIN ) { if ( cd -> flags & DETECT_CONTENT_WITHIN_BE ) { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ) ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ; } } else { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + cd -> within + distance ) ) { depth = prev_buffer_offset + cd -> within + distance ; } SCLogDebug ( ""cd->within<S2SV_blank>%"" PRIi32 "",<S2SV_blank>det_ctx->buffer_offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , cd -> within , prev_buffer_offset , depth ) ; } if ( stream_start_offset != 0 && prev_buffer_offset == 0 ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } } if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { if ( ( det_ctx -> bj_values [ cd -> depth ] + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> depth ] ; } } else { if ( cd -> depth != 0 ) { if ( ( cd -> depth + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + cd -> depth ; } SCLogDebug ( ""cd->depth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , cd -> depth , depth ) ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) { if ( det_ctx -> bj_values [ cd -> offset ] > offset ) offset = det_ctx -> bj_values [ cd -> offset ] ; } else { if ( cd -> offset > offset ) { offset = cd -> offset ; SCLogDebug ( ""setting<S2SV_blank>offset<S2SV_blank>%"" PRIu32 , offset ) ; } } } else { if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { depth = det_ctx -> bj_values [ cd -> depth ] ; } else { if ( cd -> depth != 0 ) { depth = cd -> depth ; } } if ( stream_start_offset != 0 && cd -> flags & DETECT_CONTENT_DEPTH ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) offset = det_ctx -> bj_values [ cd -> offset ] ; else offset = cd -> offset ; prev_buffer_offset = 0 ; } SCLogDebug ( ""offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>prev_offset<S2SV_blank>%"" PRIu32 , offset , prev_offset ) ; if ( prev_offset != 0 ) offset = prev_offset ; SCLogDebug ( ""offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , offset , depth ) ; if ( depth > buffer_len ) depth = buffer_len ; if ( offset > depth || depth == 0 ) { if ( cd -> flags & DETECT_CONTENT_NEGATED ) { goto match ; } else { goto no_match ; } } uint8_t * sbuffer = buffer + offset ; uint32_t sbuffer_len = depth - offset ; uint32_t match_offset = 0 ; SCLogDebug ( ""sbuffer_len<S2SV_blank>%"" PRIu32 , sbuffer_len ) ; # ifdef DEBUG BUG_ON ( sbuffer_len > buffer_len ) ; # endif found = SpmScan ( cd -> spm_ctx , det_ctx -> spm_thread_ctx , sbuffer , sbuffer_len ) ; SCLogDebug ( ""found<S2SV_blank>%p<S2SV_blank>cd<S2SV_blank>negated<S2SV_blank>%s"" , found , cd -> flags & DETECT_CONTENT_NEGATED ? ""true"" : ""false"" ) ; if ( found == NULL && ! ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { <S2SV_StartBug> goto no_match ; <S2SV_EndBug> } else if ( found == NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { goto match ; } else if ( found != NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>but<S2SV_blank>negated<S2SV_blank>so<S2SV_blank>no<S2SV_blank>match"" , cd -> id , match_offset ) ; if ( DETECT_CONTENT_IS_SINGLE ( cd ) ) det_ctx -> discontinue_matching = 1 ; goto no_match ; } else { match_offset = ( uint32_t ) ( ( found - buffer ) + cd -> content_len ) ; SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIu32 """" , cd -> id , match_offset ) ; det_ctx -> buffer_offset = match_offset ; if ( cd -> flags & DETECT_CONTENT_REPLACE ) { if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) { det_ctx -> replist = DetectReplaceAddToList ( det_ctx -> replist , found , cd ) ; } else { SCLogWarning ( SC_ERR_INVALID_VALUE , ""Can\'t<S2SV_blank>modify<S2SV_blank>payload<S2SV_blank>without<S2SV_blank>packet"" ) ; } } <S2SV_StartBug> if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) { <S2SV_EndBug> SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ; goto match ; } if ( smd -> is_last ) { goto no_match ; } SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 , cd -> id ) ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } <S2SV_StartBug> if ( det_ctx -> discontinue_matching ) <S2SV_EndBug> goto no_match ; prev_offset = ( match_offset - ( cd -> content_len - 1 ) ) ; SCLogDebug ( ""trying<S2SV_blank>to<S2SV_blank>see<S2SV_blank>if<S2SV_blank>there<S2SV_blank>is<S2SV_blank>another<S2SV_blank>match<S2SV_blank>after<S2SV_blank>prev_offset<S2SV_blank>%"" PRIu32 , prev_offset ) ; } } while ( 1 ) ; } else if ( smd -> type == DETECT_ISDATAAT ) { SCLogDebug ( ""inspecting<S2SV_blank>isdataat"" ) ; DetectIsdataatData * id = ( DetectIsdataatData * ) smd -> ctx ; if ( id -> flags & ISDATAAT_RELATIVE ) { if ( det_ctx -> buffer_offset + id -> dataat > buffer_len ) { SCLogDebug ( ""det_ctx->buffer_offset<S2SV_blank>+<S2SV_blank>id->dataat<S2SV_blank>%"" PRIu32 ""<S2SV_blank>><S2SV_blank>%"" PRIu32 , det_ctx -> buffer_offset + id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } else { SCLogDebug ( ""relative<S2SV_blank>isdataat<S2SV_blank>match"" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } } else { if ( id -> dataat < buffer_len ) { SCLogDebug ( ""absolute<S2SV_blank>isdataat<S2SV_blank>match"" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } else { SCLogDebug ( ""absolute<S2SV_blank>isdataat<S2SV_blank>mismatch,<S2SV_blank>id->isdataat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 """" , id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } } } else if ( smd -> type == DETECT_PCRE ) { SCLogDebug ( ""inspecting<S2SV_blank>pcre"" ) ; DetectPcreData * pe = ( DetectPcreData * ) smd -> ctx ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; uint32_t prev_offset = 0 ; int r = 0 ; det_ctx -> pcre_match_start_offset = 0 ; do { Packet * p = NULL ; if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) p = ( Packet * ) data ; r = DetectPcrePayloadMatch ( det_ctx , s , smd , p , f , buffer , buffer_len ) ; if ( r == 0 ) { goto no_match ; } if ( ! ( pe -> flags & DETECT_PCRE_RELATIVE_NEXT ) ) { SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ; goto match ; } KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; prev_offset = det_ctx -> pcre_match_start_offset ; r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } if ( det_ctx -> discontinue_matching ) goto no_match ; det_ctx -> buffer_offset = prev_buffer_offset ; det_ctx -> pcre_match_start_offset = prev_offset ; } while ( 1 ) ; } else if ( smd -> type == DETECT_BYTETEST ) { DetectBytetestData * btd = ( DetectBytetestData * ) smd -> ctx ; uint8_t flags = btd -> flags ; int32_t offset = btd -> offset ; uint64_t value = btd -> value ; if ( flags & DETECT_BYTETEST_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTETEST_VALUE_BE ) { value = det_ctx -> bj_values [ value ] ; } if ( flags & DETECT_BYTETEST_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTETEST_LITTLE : 0 ) ; } if ( DetectBytetestDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset , value ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTEJUMP ) { DetectBytejumpData * bjd = ( DetectBytejumpData * ) smd -> ctx ; uint8_t flags = bjd -> flags ; int32_t offset = bjd -> offset ; if ( flags & DETECT_BYTEJUMP_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTEJUMP_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTEJUMP_LITTLE : 0 ) ; } if ( DetectBytejumpDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTE_EXTRACT ) { DetectByteExtractData * bed = ( DetectByteExtractData * ) smd -> ctx ; uint8_t endian = bed -> endian ; if ( ( bed -> flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN ) && endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; endian |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] == 0x10 ) ? DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG ) ; } if ( DetectByteExtractDoMatch ( det_ctx , smd , s , buffer , buffer_len , & det_ctx -> bj_values [ bed -> local_id ] , endian ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_AL_URILEN ) { SCLogDebug ( ""inspecting<S2SV_blank>uri<S2SV_blank>len"" ) ; int r = 0 ; DetectUrilenData * urilend = ( DetectUrilenData * ) smd -> ctx ; switch ( urilend -> mode ) { case DETECT_URILEN_EQ : if ( buffer_len == urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_LT : if ( buffer_len < urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_GT : if ( buffer_len > urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_RA : if ( buffer_len > urilend -> urilen1 && buffer_len < urilend -> urilen2 ) { r = 1 ; } break ; } if ( r == 1 ) { goto match ; } det_ctx -> discontinue_matching = 0 ; goto no_match ; # ifdef HAVE_LUA } else if ( smd -> type == DETECT_LUA ) { SCLogDebug ( ""lua<S2SV_blank>starting"" ) ; if ( DetectLuaMatchBuffer ( det_ctx , s , smd , buffer , buffer_len , det_ctx -> buffer_offset , f ) != 1 ) { SCLogDebug ( ""lua<S2SV_blank>no_match"" ) ; goto no_match ; } SCLogDebug ( ""lua<S2SV_blank>match"" ) ; goto match ; # endif } else if ( smd -> type == DETECT_BASE64_DECODE ) { if ( DetectBase64DecodeDoMatch ( det_ctx , s , smd , buffer , buffer_len ) ) { if ( s -> sm_arrays [ DETECT_SM_LIST_BASE64_DATA ] != NULL ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; if ( DetectBase64DataDoMatch ( de_ctx , det_ctx , s , f ) ) { goto final_match ; } } } } else { SCLogDebug ( ""sm->type<S2SV_blank>%u"" , smd -> type ) ; # ifdef DEBUG BUG_ON ( 1 ) ; # endif } no_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; match : if ( ! smd -> is_last ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; SCReturnInt ( r ) ; } final_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; SCReturnInt ( 1 ) ; }",") ) { if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <S2SV_ModStart> } if ( smd -> is_last ) { goto match <S2SV_ModEnd> ; } SCLogDebug <S2SV_ModStart> ) ; } SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\'next<S2SV_blank>sm\'"" ) ; <S2SV_ModStart> -> discontinue_matching ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) <S2SV_ModEnd> ; prev_offset ="
86,"static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( ""%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>commands<S2SV_blank>pending<S2SV_blank>response"" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( ""%s<S2SV_blank>hci<S2SV_blank>layer<S2SV_blank>timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>to<S2SV_blank>a<S2SV_blank>command.<S2SV_blank>opcode:<S2SV_blank>0x%x"" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( ""%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process."" , __func__ ) ; <S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; }",__func__ ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 10000 )
87,"static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }","struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !"
88,"bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }","; } } if ( ! <S2SV_ModEnd> xdr_opaque ( xdrs <S2SV_ModStart> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE"
89,"ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }",ParseCommon * ) <S2SV_ModEnd> append ) ;
90,"void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }","struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,"
91,"static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <S2SV_StartBug> int name_len ; <S2SV_EndBug> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }","pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA"
92,"static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = ""INBOX"" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }",". path ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = ""INBOX"" ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> 0 , & <S2SV_ModEnd> imapc -> mailbox <S2SV_ModStart> imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>"
93,"int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }",( ! npages || base_gfn != old . base_gfn
94,"BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , ""client<S2SV_blank>authentication<S2SV_blank>failure\\n"" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }",credssp ) ; transport -> credssp = NULL ;
95,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
96,"static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; # endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof ( sCtx ) ) ; sCtx . iCol = ( ( iCol == pTab -> iPKey ) ? - 1 : iCol ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = 0 ; # endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameColumnExprCb ; sWalker . xSelectCallback = renameColumnSelectCb ; sWalker . u . pRename = & sCtx ; sCtx . pTab = pTab ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; if ( sParse . pNewTable ) { Select * pSelect = sParse . pNewTable -> pSelect ; if ( pSelect ) { <S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug> rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ; if ( rc == SQLITE_OK ) { sqlite3WalkSelect ( & sWalker , pSelect ) ; } if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; } else { int bFKOnly = sqlite3_stricmp ( zTable , sParse . pNewTable -> zName ) ; FKey * pFKey ; assert ( sParse . pNewTable -> pSelect == 0 ) ; sCtx . pTab = sParse . pNewTable ; if ( bFKOnly == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) sParse . pNewTable -> aCol [ iCol ] . zName ) ; if ( sCtx . iCol < 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & sParse . pNewTable -> iPKey ) ; } sqlite3WalkExprList ( & sWalker , sParse . pNewTable -> pCheck ) ; for ( pIdx = sParse . pNewTable -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } for ( pIdx = sParse . pNewIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } } # ifndef SQLITE_OMIT_GENERATED_COLUMNS for ( i = 0 ; i < sParse . pNewTable -> nCol ; i ++ ) { sqlite3WalkExpr ( & sWalker , sParse . pNewTable -> aCol [ i ] . pDflt ) ; } # endif for ( pFKey = sParse . pNewTable -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { if ( bFKOnly == 0 && pFKey -> aCol [ i ] . iFrom == iCol ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & pFKey -> aCol [ i ] ) ; } if ( 0 == sqlite3_stricmp ( pFKey -> zTo , zTable ) && 0 == sqlite3_stricmp ( pFKey -> aCol [ i ] . zCol , zOld ) ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> aCol [ i ] . zCol ) ; } } } } } else if ( sParse . pNewIndex ) { sqlite3WalkExprList ( & sWalker , sParse . pNewIndex -> aColExpr ) ; sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } else { TriggerStep * pStep ; rc = renameResolveTrigger ( & sParse , ( bTemp ? 0 : zDb ) ) ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; for ( pStep = sParse . pNewTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget ) { Table * pTarget = sqlite3LocateTable ( & sParse , 0 , pStep -> zTarget , zDb ) ; if ( pTarget == pTab ) { if ( pStep -> pUpsert ) { ExprList * pUpsertSet = pStep -> pUpsert -> pUpsertSet ; renameColumnElistNames ( & sParse , & sCtx , pUpsertSet , zOld ) ; } renameColumnIdlistNames ( & sParse , & sCtx , pStep -> pIdList , zOld ) ; renameColumnElistNames ( & sParse , & sCtx , pStep -> pExprList , zOld ) ; } } } if ( sParse . pTriggerTab == pTab ) { renameColumnIdlistNames ( & sParse , & sCtx , sParse . pNewTrigger -> pColumns , zOld ) ; } renameWalkTrigger ( & sWalker , sParse . pNewTrigger ) ; } assert ( rc == SQLITE_OK ) ; rc = renameEditSql ( context , & sCtx , zSql , zNew , bQuote ) ; renameColumnFunc_done : if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif sqlite3BtreeLeaveAll ( db ) ; }","pSelect ) { pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart> & sParse , <S2SV_ModEnd> pSelect , 0"
97,"void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }",alarm_timer ) ; btif_config_write ( <S2SV_ModEnd> ) ; }
98,"SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; if ( task ) { err = mutex_lock_interruptible ( & task -> signal -> cred_guard_mutex ) ; if ( err ) goto err_cpus ; err = - EACCES ; if ( ! ptrace_may_access ( task , PTRACE_MODE_READ_REALCREDS ) ) goto err_cred ; } if ( flags & PERF_FLAG_PID_CGROUP ) cgroup_fd = pid ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL , cgroup_fd ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cred ; } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - EOPNOTSUPP ; goto err_alloc ; } } pmu = event -> pmu ; if ( attr . use_clockid ) { err = perf_event_set_clock ( event , attr . clockid ) ; if ( err ) goto err_alloc ; } if ( pmu -> task_ctx_nr == perf_sw_context ) event -> event_caps |= PERF_EV_CAP_SOFTWARE ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( ( pmu -> capabilities & PERF_PMU_CAP_EXCLUSIVE ) && group_leader ) { err = - EBUSY ; goto err_context ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( group_leader -> clock != event -> clock ) goto err_context ; if ( move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu ) goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; event_file = NULL ; goto err_context ; } if ( move_group ) { <S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; if ( gctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } <S2SV_StartBug> } else { <S2SV_EndBug> mutex_lock ( & ctx -> mutex ) ; } if ( ctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } if ( ! perf_event_validate_size ( event ) ) { err = - E2BIG ; goto err_locked ; } if ( ! exclusive_event_installable ( event , ctx ) ) { WARN_ON_ONCE ( move_group ) ; err = - EBUSY ; goto err_locked ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { perf_remove_from_context ( group_leader , 0 ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , 0 ) ; put_ctx ( gctx ) ; } synchronize_rcu ( ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_event__state_init ( sibling ) ; perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } perf_event__state_init ( group_leader ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; put_ctx ( gctx ) ; } perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; event -> owner = current ; perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; if ( task ) { mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; put_task_struct ( task ) ; } put_online_cpus ( ) ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_locked : if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; fput ( event_file ) ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : if ( ! event_file ) free_event ( event ) ; err_cred : if ( task ) mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }","{ gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if <S2SV_ModStart> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock"
99,"int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }","1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }"
100,"MagickExport const char * GetMagickFeatures ( void ) { return ""DPC"" <S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif <S2SV_StartBug> ; <S2SV_EndBug> }","if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> # endif # <S2SV_ModStart> MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif"
101,"static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }","desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 ("
102,"int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , <S2SV_StartBug> int64_t * time_stamp , int64_t * time_end_stamp , <S2SV_EndBug> <S2SV_StartBug> vp9_ppflags_t * flags ) { <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> if ( pbi -> ready_for_new_data == 1 ) return ret ; <S2SV_StartBug> if ( pbi -> common . show_frame == 0 ) <S2SV_EndBug> return ret ; pbi -> ready_for_new_data = 1 ; <S2SV_StartBug> * time_stamp = pbi -> last_time_stamp ; <S2SV_EndBug> * time_end_stamp = 0 ; <S2SV_StartBug> # if CONFIG_VP9_POSTPROC <S2SV_EndBug> <S2SV_StartBug> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <S2SV_EndBug> # else <S2SV_StartBug> * sd = * pbi -> common . frame_to_show ; <S2SV_EndBug> sd -> y_width = pbi -> common . width ; sd -> y_height = pbi -> common . height ; sd -> uv_width = sd -> y_width >> pbi -> common . subsampling_x ; sd -> uv_height = sd -> y_height >> pbi -> common . subsampling_y ; ret = 0 ; # endif <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> return ret ; }","* sd , <S2SV_ModEnd> vp9_ppflags_t * flags <S2SV_ModStart> flags ) { VP9_COMMON * const cm = & pbi -> common ; <S2SV_ModStart> - 1 ; # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <S2SV_ModStart> return ret ; pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <S2SV_ModEnd> ) return ret <S2SV_ModStart> = 1 ; <S2SV_ModEnd> # if CONFIG_VP9_POSTPROC <S2SV_ModStart> # if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) { <S2SV_ModStart> = vp9_post_proc_frame ( cm <S2SV_ModEnd> , sd , <S2SV_ModStart> flags ) ; } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <S2SV_ModStart> sd = * cm -> frame_to_show <S2SV_ModEnd> ; ret = <S2SV_ModStart> ; # endif vpx_clear_system_state <S2SV_ModEnd> ( ) ;"
103,"static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = ""tun%d"" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = ""tap%d"" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , ""tun_set_iff\\n"" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }","- ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;"
104,"static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , ""compressed<S2SV_blank>PPP<S2SV_blank>data"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( ppptype2str , ""unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; break ; } }","p , length <S2SV_ModEnd> ) ; break"
105,"static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }",", r -> qiov . size <S2SV_ModEnd> ) ; n <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; }"
106,"void vp9_rc_get_one_pass_cbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ( cm -> current_video_frame == 0 || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> rc -> frames_to_key == 0 || <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> rc -> kf_boost = DEFAULT_KF_BOOST ; <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } else { cm -> frame_type = INTER_FRAME ; <S2SV_StartBug> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> vp9_rc_set_frame_target ( cpi , target ) ; <S2SV_StartBug> rc -> frames_till_gf_update_due = INT_MAX ; <S2SV_EndBug> rc -> baseline_gf_interval = INT_MAX ; }",0 || ( cpi <S2SV_ModEnd> -> frame_flags & <S2SV_ModStart> . auto_key && 0 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> = cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc -> <S2SV_ModStart> source_alt_ref_active = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <S2SV_ModEnd> calc_pframe_target_size_one_pass_cbr ( cpi <S2SV_ModStart> cpi ) ; <S2SV_ModEnd> vp9_rc_set_frame_target ( cpi <S2SV_ModStart> target ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> ; } <S2SV_null>
107,"GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size , data , pck_size ) ; ctx -> latm_buffer_size += pck_size ; } if ( ! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer , ctx -> latm_buffer_size , GF_BITSTREAM_READ ) ; else gf_bs_reassign_buffer ( ctx -> bs , ctx -> latm_buffer , ctx -> latm_buffer_size ) ; if ( ctx -> resume_from ) { gf_bs_seek ( ctx -> bs , ctx -> resume_from - 1 ) ; ctx -> resume_from = 0 ; } if ( cts == GF_FILTER_NO_TS ) prev_pck_size = 0 ; while ( 1 ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; u8 latm_buffer [ 4096 ] ; u32 latm_frame_size = 4096 ; if ( ! latm_dmx_sync_frame_bs ( ctx -> bs , & ctx -> acfg , & latm_frame_size , latm_buffer , NULL ) ) break ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } latm_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = pos + 1 ; return GF_OK ; } if ( ! ctx -> in_seek ) { GF_FilterSAPType sap = GF_FILTER_SAP_1 ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , latm_frame_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , latm_buffer , latm_frame_size ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> acfg . base_object_type == GF_CODECID_USAC ) { if ( latm_frame_size && ( output [ 0 ] & 0x80 ) && ! ctx -> prev_sap ) { sap = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; } else { sap = GF_FILTER_SAP_NONE ; ctx -> prev_sap = GF_FALSE ; } } gf_filter_pck_set_sap ( dst_pck , sap ) ; gf_filter_pck_send ( dst_pck ) ; } latm_dmx_update_cts ( ctx ) ; if ( prev_pck_size ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; if ( prev_pck_size <= pos ) { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } } if ( pck ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; assert ( ctx -> latm_buffer_size >= pos ) ; memmove ( ctx -> latm_buffer , ctx -> latm_buffer + pos , ctx -> latm_buffer_size - pos ) ; ctx -> latm_buffer_size -= pos ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; assert ( ! ctx -> resume_from ) ; } else { ctx -> latm_buffer_size = 0 ; return latm_dmx_process ( filter ) ; } return GF_OK ; }",u8 * data = NULL <S2SV_ModStart> ; u32 pck_size = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> pck_size ) ; }
108,"int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }",{ if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> iterator -> _rtheader + sizeof ( uint32_t )
109,"static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ; goto out ; } sin . sin_family = AF_INET ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; sin . sin_port = usin -> sin6_port ; err = __ip4_datagram_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; ipv4_connected : if ( err ) goto out ; ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; if ( ipv6_addr_any ( & np -> saddr ) || ipv6_mapped_addr_any ( & np -> saddr ) ) ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , & sk -> sk_v6_rcv_saddr ) ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } goto out ; } if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { err = - EINVAL ; goto out ; } sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) sk -> sk_bound_dev_if = np -> mcast_oif ; if ( ! sk -> sk_bound_dev_if ) { err = - EINVAL ; goto out ; } } sk -> sk_v6_daddr = * daddr ; np -> flow_label = fl6 . flowlabel ; inet -> inet_dport = usin -> sin6_port ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) fl6 . flowi6_oif = np -> mcast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; err = 0 ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( ipv6_addr_any ( & np -> saddr ) ) np -> saddr = fl6 . saddr ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { sk -> sk_v6_rcv_saddr = fl6 . saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; sk -> sk_state = TCP_ESTABLISHED ; sk_set_txhash ( sk ) ; out : fl6_sock_release ( flowlabel ) ; return err ; }",") ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> opt : rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock ("
110,"static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> err_info ) ; }","err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> FALSE ; } return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> , phdr , buf , line <S2SV_ModEnd> , err ,"
111,"static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , insn_idx ) ; else verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( env , state ) ; do_print_state = false ; } if ( env -> log . level ) { verbose ( env , ""%d:<S2SV_blank>"" , insn_idx ) ; print_bpf_insn ( verbose , env , insn , env -> allow_ptr_leaks ) ; } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; regs = cur_regs ( env ) ; <S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn_idx , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; <S2SV_StartBug> } else { <S2SV_EndBug> verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns,<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>%d\\n"" , insn_processed , env -> prog -> aux -> stack_depth ) ; return 0 ; }",env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
112,"void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }",n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
113,"void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }","ch , seq , size << 3"
114,"static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return ( NULL ) ; }","( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,"
115,"static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break ; } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",", message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;"
116,"stmt_ty <S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->"
117,"static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }",+= 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
118,"static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> } end : rcu_read_unlock ( ) ; }",", u64 nr <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> , nr , <S2SV_ModEnd> data , regs"
119,"<S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xd0 : data_1 = * event_data ++ ; midi_setup_channel_pressure ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xe0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_pitch ( mdi , channel , ( ( data_2 << 7 ) | ( data_1 & 0x7f ) ) ) ; ret_cnt += 2 ; break ; case 0xf0 : if ( channel == 0x0f ) { uint32_t tmp_length = 0 ; if ( ( event_data [ 0 ] == 0x00 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else if ( event_data [ 0 ] == 0x01 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_text ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x02 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> if ( mdi -> extra_info . copyright ) { mdi -> extra_info . copyright = realloc ( mdi -> extra_info . copyright , ( strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length + 1 ) ) ; memcpy ( & mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 ] , event_data , tmp_length ) ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length ] = '\\0' ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) ] = '\\n' ; } else { mdi -> extra_info . copyright = malloc ( tmp_length + 1 ) ; memcpy ( mdi -> extra_info . copyright , event_data , tmp_length ) ; mdi -> extra_info . copyright [ tmp_length ] = '\\0' ; } text = malloc ( tmp_length + 1 ) ; memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_copyright ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x03 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_trackname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x04 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_instrumentname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x05 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_lyric ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x06 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_marker ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x07 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_cuepoint ( mdi , text ) ; ret_cnt += tmp_length ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ; ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x21 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x2F ) && ( event_data [ 1 ] == 0x00 ) ) { <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> ret_cnt += 2 ; } else if ( ( event_data [ 0 ] == 0x51 ) && ( event_data [ 1 ] == 0x03 ) ) { <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> ret_cnt += 5 ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ; mdi -> events [ mdi -> events_size - 1 ] . event_data . channel = event_data [ 2 ] ; ret_cnt += 7 ; } else if ( ( event_data [ 0 ] == 0x58 ) && ( event_data [ 1 ] == 0x04 ) ) { <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> ret_cnt += 6 ; } else if ( ( event_data [ 0 ] == 0x59 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; ret_cnt ++ ; ret_cnt += tmp_length ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( ( channel == 0 ) || ( channel == 7 ) ) { uint32_t sysex_len = 0 ; uint8_t * sysex_store = NULL ; if ( * event_data > 0x7f ) { <S2SV_StartBug> do { <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> ret_cnt ++ ; sysex_store = malloc ( sizeof ( uint8_t ) * sysex_len ) ; memcpy ( sysex_store , event_data , sysex_len ) ; if ( sysex_store [ sysex_len - 1 ] == 0xF7 ) { uint8_t rolandsysexid [ ] = { 0x41 , 0x10 , 0x42 , 0x12 } ; if ( memcmp ( rolandsysexid , sysex_store , 4 ) == 0 ) { uint8_t sysex_cs = 0 ; uint32_t sysex_ofs = 4 ; do { sysex_cs += sysex_store [ sysex_ofs ] ; if ( sysex_cs > 0x7F ) { sysex_cs -= 0x80 ; } sysex_ofs ++ ; } while ( sysex_store [ sysex_ofs + 1 ] != 0xf7 ) ; sysex_cs = 128 - sysex_cs ; if ( sysex_cs == sysex_store [ sysex_ofs ] ) { if ( sysex_store [ 4 ] == 0x40 ) { if ( ( ( sysex_store [ 5 ] & 0xf0 ) == 0x10 ) && ( sysex_store [ 6 ] == 0x15 ) ) { uint8_t sysex_ch = 0x0f & sysex_store [ 5 ] ; if ( sysex_ch == 0x00 ) { sysex_ch = 0x09 ; } else if ( sysex_ch <= 0x09 ) { sysex_ch -= 1 ; } midi_setup_sysex_roland_drum_track ( mdi , sysex_ch , sysex_store [ 7 ] ) ; } else if ( ( sysex_store [ 5 ] == 0x00 ) && ( sysex_store [ 6 ] == 0x7F ) && ( sysex_store [ 7 ] == 0x00 ) ) { midi_setup_sysex_roland_reset ( mdi ) ; } } } } else { uint8_t gm_reset [ ] = { 0x7e , 0x7f , 0x09 , 0x01 , 0xf7 } ; uint8_t yamaha_reset [ ] = { 0x43 , 0x10 , 0x4c , 0x00 , 0x00 , 0x7e , 0x00 , 0xf7 } ; if ( memcmp ( gm_reset , sysex_store , 5 ) == 0 ) { midi_setup_sysex_gm_reset ( mdi ) ; } else if ( memcmp ( yamaha_reset , sysex_store , 8 ) == 0 ) { midi_setup_sysex_yamaha_reset ( mdi ) ; } } } free ( sysex_store ) ; sysex_store = NULL ; ret_cnt += sysex_len ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(unrecognized<S2SV_blank>meta<S2SV_blank>type<S2SV_blank>event)"" , 0 ) ; return 0 ; } break ; default : ret_cnt = 0 ; break ; } if ( ret_cnt == 0 ) _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>event)"" , 0 ) ; return ret_cnt ; <S2SV_StartBug> } <S2SV_EndBug>","* event_data , uint32_t siz , <S2SV_ModStart> ; if ( ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart> sysex_len ) break <S2SV_ModEnd> ; sysex_store = <S2SV_ModStart> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ;"
120,"int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n"" , argv [ 0 ] ) ; printf ( ""Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n"" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , ""rb"" ) ; if ( ! file ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n"" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf ( stdout , ""Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n"" , track -> num_samples ) ; for ( snum = 0 ; snum < track -> num_samples ; snum ++ ) { sample = & track -> sample [ snum ] ; frame_codestream = ( unsigned char * ) malloc ( sample -> sample_size - 8 ) ; fseek ( file , sample -> offset + 8 , SEEK_SET ) ; fread ( frame_codestream , sample -> sample_size - 8 , 1 , file ) ; <S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> outfile = fopen ( outfilename , ""wb"" ) ; if ( ! outfile ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfilename ) ; return 1 ; } fwrite ( frame_codestream , sample -> sample_size - 8 , 1 , outfile ) ; fclose ( outfile ) ; free ( frame_codestream ) ; } fclose ( file ) ; fprintf ( stdout , ""%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n"" , snum ) ; if ( dinfo ) { mj2_destroy_decompress ( ( opj_mj2_t * ) dinfo -> mj2_handle ) ; } return 0 ; }","file ) ; int num = snprintf <S2SV_ModEnd> ( outfilename , <S2SV_ModStart> ( outfilename , sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; return 1 ; }"
121,"static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }",) break ; <S2SV_ModEnd> rinfo [ val
122,"int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""comprehension<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *"
123,"int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }",prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
124,"static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> int bestsme = INT_MAX ; <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; } vp9_set_mv_search_range ( x , & ref_mv ) ; <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> } else { step_param = cpi -> mv_step_param ; } <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> cpi -> common . show_frame ) { <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> b_width_log2 ( bsize ) ) ) ; step_param = MAX ( step_param , boffset ) ; } if ( cpi -> sf . adaptive_motion_search ) { int bwl = b_width_log2_lookup [ bsize ] ; <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> int i ; int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; if ( tlevel < 5 ) step_param += 2 ; <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> tmp_mv -> as_int = INVALID_MV ; if ( scaled_ref_frame ) { int i ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } <S2SV_StartBug> return ; <S2SV_EndBug> } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full . col >>= 3 ; mvp_full . row >>= 3 ; <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> if ( cpi -> sf . search_method == FAST_DIAMOND ) { bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == SQUARE ) { bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == BIGDIA ) { bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else { bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } }","* x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> -> e_mbd ; const <S2SV_ModStart> { { 0 , 0 <S2SV_ModStart> INT_MAX ; int <S2SV_ModEnd> step_param ; int <S2SV_ModStart> MV ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> x -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> 0 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> 1 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> [ ref ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> sf . mv . auto_mv_step_size && cm -> <S2SV_ModEnd> show_frame ) { <S2SV_ModStart> ( vp9_init_search_range ( <S2SV_ModEnd> x -> max_mv_context <S2SV_ModStart> -> mv_step_param ) / 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> bsize < BLOCK_64X64 <S2SV_ModEnd> ) { int <S2SV_ModStart> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> - MIN ( <S2SV_ModStart> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) ; <S2SV_ModStart> [ bsize ] <S2SV_ModEnd> ; int tlevel <S2SV_ModStart> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> <= ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; ++ <S2SV_ModStart> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 ; <S2SV_ModStart> < MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd -> <S2SV_ModStart> } return ; } <S2SV_ModStart> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> ; if ( <S2SV_ModStart> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , <S2SV_ModStart> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart> bsize ] , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_force_stop , <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> , & x <S2SV_ModStart> [ ref ] , NULL , 0 , 0 <S2SV_ModStart> sf . adaptive_motion_search <S2SV_ModEnd> ) x -> <S2SV_ModStart> [ ref ] <S2SV_ModEnd> = tmp_mv -> <S2SV_ModStart> = tmp_mv -> as_mv <S2SV_ModEnd> ; if ("
125,"int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }",nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> * exthdr ; unsigned int len ; <S2SV_ModStart> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> ; * nexthdr
126,"static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }","skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if"
127,"static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long"" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }","; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto error ; } if ("
128,"void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }","dlen , buf , false"
129,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; err_code = selector & 0xfffc ; err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR ; if ( seg <= VCPU_SREG_GS && ! seg_desc . s ) goto exception ; if ( ! seg_desc . p ) { err_vec = ( seg == VCPU_SREG_SS ) ? SS_VECTOR : NP_VECTOR ; goto exception ; } dpl = seg_desc . dpl ; switch ( seg ) { case VCPU_SREG_SS : if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) goto exception ; break ; case VCPU_SREG_CS : if ( ! ( seg_desc . type & 8 ) ) goto exception ; if ( seg_desc . type & 4 ) { if ( dpl > cpl ) goto exception ; } else { if ( rpl > cpl || dpl != cpl ) goto exception ; } if ( seg_desc . d && seg_desc . l ) { u64 efer = 0 ; ctxt -> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( efer & EFER_LMA ) goto exception ; } selector = ( selector & 0xfffc ) | cpl ; break ; case VCPU_SREG_TR : if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) goto exception ; old_desc = seg_desc ; seg_desc . type |= 2 ; ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , sizeof ( seg_desc ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; break ; case VCPU_SREG_LDTR : if ( seg_desc . s || seg_desc . type != 2 ) goto exception ; break ; default : if ( ( seg_desc . type & 0xa ) == 0x8 || ( ( ( seg_desc . type & 0xc ) != 0xc ) && ( rpl > dpl && cpl > dpl ) ) ) goto exception ; break ; } if ( seg_desc . s ) { seg_desc . type |= 1 ; ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } else if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) { ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , sizeof ( base3 ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } load : ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ; }",", bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> seg ) ; if ( desc ) * desc = seg_desc ;"
130,"static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <S2SV_StartBug> } <S2SV_EndBug> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }",{ struct blkif_response * <S2SV_ModStart> int notify ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> native . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> x86_32 . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
131,"void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , ""_sdp.txt"" ) ; } dump = gf_fopen ( szBuf , ""wt"" ) ; if ( ! dump ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>dumping\\n"" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , ""*<S2SV_blank>File<S2SV_blank>SDP<S2SV_blank>content<S2SV_blank>*\\n\\n"" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <S2SV_StartBug> fprintf ( dump , ""%s"" , sdp ) ; <S2SV_EndBug> fprintf ( dump , ""\\r\\n"" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , ""%s"" , sdp ) ; } fprintf ( dump , ""\\n\\n"" ) ; if ( inName ) gf_fclose ( dump ) ; }",size ) ; if ( sdp && size )
132,"int phar_parse_zipfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , char * * error ) { phar_zip_dir_end locator ; char buf [ sizeof ( locator ) + 65536 ] ; zend_long size ; php_uint16 i ; phar_archive_data * mydata = NULL ; phar_entry_info entry = { 0 } ; char * p = buf , * ext , * actual_alias = NULL ; char * metadata = NULL ; size = php_stream_tell ( fp ) ; if ( size > sizeof ( locator ) + 65536 ) { size = sizeof ( locator ) + 65536 ; if ( FAILURE == php_stream_seek ( fp , - size , SEEK_END ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; } } else { php_stream_seek ( fp , 0 , SEEK_SET ) ; } if ( ! php_stream_read ( fp , buf , size ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>data<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; } while ( ( p = ( char * ) memchr ( p + 1 , 'P' , ( size_t ) ( size - ( p + 1 - buf ) ) ) ) != NULL ) { if ( ( p - buf ) + sizeof ( locator ) <= size && ! memcmp ( p + 1 , ""K\\5\\6"" , 3 ) ) { memcpy ( ( void * ) & locator , ( void * ) p , sizeof ( locator ) ) ; if ( PHAR_GET_16 ( locator . centraldisk ) != 0 || PHAR_GET_16 ( locator . disknumber ) != 0 ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>split<S2SV_blank>archives<S2SV_blank>spanning<S2SV_blank>multiple<S2SV_blank>zips<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>processed<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; } if ( PHAR_GET_16 ( locator . counthere ) != PHAR_GET_16 ( locator . count ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>conflicting<S2SV_blank>file<S2SV_blank>count<S2SV_blank>in<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>record<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } php_stream_close ( fp ) ; return FAILURE ; } mydata = pecalloc ( 1 , sizeof ( phar_archive_data ) , PHAR_G ( persist ) ) ; mydata -> is_persistent = PHAR_G ( persist ) ; if ( PHAR_GET_16 ( locator . comment_len ) ) { metadata = p + sizeof ( locator ) ; if ( PHAR_GET_16 ( locator . comment_len ) != size - ( metadata - buf ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>zip<S2SV_blank>file<S2SV_blank>comment<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } php_stream_close ( fp ) ; pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; } mydata -> metadata_len = PHAR_GET_16 ( locator . comment_len ) ; if ( phar_parse_metadata ( & metadata , & mydata -> metadata , PHAR_GET_16 ( locator . comment_len ) ) == FAILURE ) { mydata -> metadata_len = 0 ; ZVAL_NEW_STR ( & mydata -> metadata , zend_string_init ( metadata , PHAR_GET_16 ( locator . comment_len ) , mydata -> is_persistent ) ) ; } } else { ZVAL_UNDEF ( & mydata -> metadata ) ; } goto foundit ; } } php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , fname ) ; } return FAILURE ; foundit : mydata -> fname = pestrndup ( fname , fname_len , mydata -> is_persistent ) ; # ifdef PHP_WIN32 phar_unixify_path_separators ( mydata -> fname , fname_len ) ; # endif mydata -> is_zip = 1 ; mydata -> fname_len = fname_len ; ext = strrchr ( mydata -> fname , '/' ) ; if ( ext ) { mydata -> ext = memchr ( ext , '.' , ( mydata -> fname + fname_len ) - ext ) ; if ( mydata -> ext == ext ) { mydata -> ext = memchr ( ext + 1 , '.' , ( mydata -> fname + fname_len ) - ext - 1 ) ; } if ( mydata -> ext ) { mydata -> ext_len = ( mydata -> fname + fname_len ) - mydata -> ext ; } } php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; zend_hash_init ( & mydata -> manifest , PHAR_GET_16 ( locator . count ) , zend_get_hash_value , destroy_phar_manifest_entry , ( zend_bool ) mydata -> is_persistent ) ; zend_hash_init ( & mydata -> mounted_dirs , 5 , zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; zend_hash_init ( & mydata -> virtual_dirs , PHAR_GET_16 ( locator . count ) * 2 , zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; entry . phar = mydata ; entry . is_zip = 1 ; entry . fp_type = PHAR_FP ; entry . is_persistent = mydata -> is_persistent ; # define PHAR_ZIP_FAIL_FREE ( errmsg , save ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; efree ( save ) ; return FAILURE ; # define PHAR_ZIP_FAIL ( errmsg ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; for ( i = 0 ; i < PHAR_GET_16 ( locator . count ) ; ++ i ) { phar_zip_central_dir_file zipentry ; zend_off_t beforeus = php_stream_tell ( fp ) ; if ( sizeof ( zipentry ) != php_stream_read ( fp , ( char * ) & zipentry , sizeof ( zipentry ) ) ) { PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>truncated"" ) ; } if ( memcmp ( ""PK\\1\\2"" , zipentry . signature , 4 ) ) { PHAR_ZIP_FAIL ( ""corrupted<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>no<S2SV_blank>magic<S2SV_blank>signature"" ) ; } if ( entry . is_persistent ) { entry . manifest_pos = i ; } entry . compressed_filesize = PHAR_GET_32 ( zipentry . compsize ) ; entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ; entry . crc32 = PHAR_GET_32 ( zipentry . crc32 ) ; entry . timestamp = phar_zip_d2u_time ( zipentry . timestamp , zipentry . datestamp ) ; entry . flags = PHAR_ENT_PERM_DEF_FILE ; entry . header_offset = PHAR_GET_32 ( zipentry . offset ) ; entry . offset = entry . offset_abs = PHAR_GET_32 ( zipentry . offset ) + sizeof ( phar_zip_file_header ) + PHAR_GET_16 ( zipentry . filename_len ) + PHAR_GET_16 ( zipentry . extra_len ) ; if ( PHAR_GET_16 ( zipentry . flags ) & PHAR_ZIP_FLAG_ENCRYPTED ) { PHAR_ZIP_FAIL ( ""Cannot<S2SV_blank>process<S2SV_blank>encrypted<S2SV_blank>zip<S2SV_blank>files"" ) ; } if ( ! PHAR_GET_16 ( zipentry . filename_len ) ) { PHAR_ZIP_FAIL ( ""Cannot<S2SV_blank>process<S2SV_blank>zips<S2SV_blank>created<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>(zero-length<S2SV_blank>filename)"" ) ; } entry . filename_len = PHAR_GET_16 ( zipentry . filename_len ) ; entry . filename = ( char * ) pemalloc ( entry . filename_len + 1 , entry . is_persistent ) ; if ( entry . filename_len != php_stream_read ( fp , entry . filename , entry . filename_len ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>filename<S2SV_blank>from<S2SV_blank>central<S2SV_blank>directory,<S2SV_blank>truncated"" ) ; } entry . filename [ entry . filename_len ] = '\\0' ; if ( entry . filename [ entry . filename_len - 1 ] == '/' ) { entry . is_dir = 1 ; if ( entry . filename_len > 1 ) { entry . filename_len -- ; } entry . flags |= PHAR_ENT_PERM_DEF_DIR ; } else { entry . is_dir = 0 ; } if ( entry . filename_len == sizeof ( "".phar/signature.bin"" ) - 1 && ! strncmp ( entry . filename , "".phar/signature.bin"" , sizeof ( "".phar/signature.bin"" ) - 1 ) ) { size_t read ; php_stream * sigfile ; zend_off_t now ; char * sig ; now = php_stream_tell ( fp ) ; pefree ( entry . filename , entry . is_persistent ) ; sigfile = php_stream_fopen_tmpfile ( ) ; if ( ! sigfile ) { PHAR_ZIP_FAIL ( ""couldn\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; php_stream_copy_to_stream_ex ( fp , sigfile , entry . header_offset , NULL ) ; php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; php_stream_copy_to_stream_ex ( fp , sigfile , beforeus - PHAR_GET_32 ( locator . cdir_offset ) , NULL ) ; if ( metadata ) { php_stream_write ( sigfile , metadata , PHAR_GET_16 ( locator . comment_len ) ) ; } php_stream_seek ( fp , sizeof ( phar_zip_file_header ) + entry . header_offset + entry . filename_len + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; sig = ( char * ) emalloc ( entry . uncompressed_filesize ) ; read = php_stream_read ( fp , sig , entry . uncompressed_filesize ) ; <S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> php_stream_close ( sigfile ) ; efree ( sig ) ; PHAR_ZIP_FAIL ( ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>read"" ) ; } mydata -> sig_flags = PHAR_GET_32 ( sig ) ; if ( FAILURE == phar_verify_signature ( sigfile , php_stream_tell ( sigfile ) , mydata -> sig_flags , sig + 8 , entry . uncompressed_filesize - 8 , fname , & mydata -> signature , & mydata -> sig_len , error ) ) { efree ( sig ) ; if ( error ) { char * save ; php_stream_close ( sigfile ) ; spprintf ( & save , 4096 , ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified:<S2SV_blank>%s"" , * error ) ; efree ( * error ) ; PHAR_ZIP_FAIL_FREE ( save , save ) ; } else { php_stream_close ( sigfile ) ; PHAR_ZIP_FAIL ( ""signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified"" ) ; } } php_stream_close ( sigfile ) ; efree ( sig ) ; if ( i != PHAR_GET_16 ( locator . count ) - 1 ) { PHAR_ZIP_FAIL ( ""entries<S2SV_blank>exist<S2SV_blank>after<S2SV_blank>signature,<S2SV_blank>invalid<S2SV_blank>phar"" ) ; } continue ; } phar_add_virtual_dirs ( mydata , entry . filename , entry . filename_len ) ; if ( PHAR_GET_16 ( zipentry . extra_len ) ) { zend_off_t loc = php_stream_tell ( fp ) ; if ( FAILURE == phar_zip_process_extra ( fp , & entry , PHAR_GET_16 ( zipentry . extra_len ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""Unable<S2SV_blank>to<S2SV_blank>process<S2SV_blank>extra<S2SV_blank>field<S2SV_blank>header<S2SV_blank>for<S2SV_blank>file<S2SV_blank>in<S2SV_blank>central<S2SV_blank>directory"" ) ; } php_stream_seek ( fp , loc + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; } switch ( PHAR_GET_16 ( zipentry . compressed ) ) { case PHAR_ZIP_COMP_NONE : break ; case PHAR_ZIP_COMP_DEFLATE : entry . flags |= PHAR_ENT_COMPRESSED_GZ ; if ( ! PHAR_G ( has_zlib ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""zlib<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required"" ) ; } break ; case PHAR_ZIP_COMP_BZIP2 : entry . flags |= PHAR_ENT_COMPRESSED_BZ2 ; if ( ! PHAR_G ( has_bz2 ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""bzip2<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required"" ) ; } break ; case 1 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Shrunk)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 2 : case 3 : case 4 : case 5 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Reduce)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 6 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Implode)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 7 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Tokenize)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 9 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Deflate64)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 10 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PKWare<S2SV_blank>Implode/old<S2SV_blank>IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 14 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(LZMA)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 18 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 19 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>LZ77)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 97 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(WavPack)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; case 98 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PPMd)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; default : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(unknown)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip"" ) ; } if ( PHAR_GET_16 ( zipentry . comment_len ) ) { if ( PHAR_GET_16 ( zipentry . comment_len ) != php_stream_read ( fp , buf , PHAR_GET_16 ( zipentry . comment_len ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>file<S2SV_blank>comment,<S2SV_blank>truncated"" ) ; } p = buf ; entry . metadata_len = PHAR_GET_16 ( zipentry . comment_len ) ; if ( phar_parse_metadata ( & p , & ( entry . metadata ) , PHAR_GET_16 ( zipentry . comment_len ) ) == FAILURE ) { entry . metadata_len = 0 ; ZVAL_NEW_STR ( & entry . metadata , zend_string_init ( buf , PHAR_GET_16 ( zipentry . comment_len ) , entry . is_persistent ) ) ; } } else { ZVAL_UNDEF ( & entry . metadata ) ; } if ( ! actual_alias && entry . filename_len == sizeof ( "".phar/alias.txt"" ) - 1 && ! strncmp ( entry . filename , "".phar/alias.txt"" , sizeof ( "".phar/alias.txt"" ) - 1 ) ) { php_stream_filter * filter ; zend_off_t saveloc ; phar_zip_file_header local ; saveloc = php_stream_tell ( fp ) ; php_stream_seek ( fp , PHAR_GET_32 ( zipentry . offset ) , SEEK_SET ) ; if ( sizeof ( local ) != php_stream_read ( fp , ( char * ) & local , sizeof ( local ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(cannot<S2SV_blank>read<S2SV_blank>local<S2SV_blank>file<S2SV_blank>header<S2SV_blank>for<S2SV_blank>alias)"" ) ; } if ( entry . filename_len != PHAR_GET_16 ( local . filename_len ) || entry . crc32 != PHAR_GET_32 ( local . crc32 ) || entry . uncompressed_filesize != PHAR_GET_32 ( local . uncompsize ) || entry . compressed_filesize != PHAR_GET_32 ( local . compsize ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(local<S2SV_blank>header<S2SV_blank>of<S2SV_blank>alias<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>central<S2SV_blank>directory)"" ) ; } entry . offset = entry . offset_abs = sizeof ( local ) + entry . header_offset + PHAR_GET_16 ( local . filename_len ) + PHAR_GET_16 ( local . extra_len ) ; php_stream_seek ( fp , entry . offset , SEEK_SET ) ; fp -> writepos = 0 ; fp -> readpos = 0 ; php_stream_seek ( fp , entry . offset , SEEK_SET ) ; fp -> writepos = 0 ; fp -> readpos = 0 ; mydata -> alias_len = entry . uncompressed_filesize ; if ( entry . flags & PHAR_ENT_COMPRESSED_GZ ) { filter = php_stream_filter_create ( ""zlib.inflate"" , NULL , php_stream_is_persistent ( fp ) ) ; if ( ! filter ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>alias,<S2SV_blank>zlib<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed"" ) ; } php_stream_filter_append ( & fp -> readfilters , filter ) ; { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } php_stream_filter_flush ( filter , 1 ) ; php_stream_filter_remove ( filter , 1 ) ; } else if ( entry . flags & PHAR_ENT_COMPRESSED_BZ2 ) { filter = php_stream_filter_create ( ""bzip2.decompress"" , NULL , php_stream_is_persistent ( fp ) ) ; if ( ! filter ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>bzip2<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed"" ) ; } php_stream_filter_append ( & fp -> readfilters , filter ) ; { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } php_stream_filter_flush ( filter , 1 ) ; php_stream_filter_remove ( filter , 1 ) ; } else { { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated"" ) ; } } php_stream_seek ( fp , saveloc , SEEK_SET ) ; } phar_set_inode ( & entry ) ; zend_hash_str_add_mem ( & mydata -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) ) ; } mydata -> fp = fp ; if ( zend_hash_str_exists ( & ( mydata -> manifest ) , "".phar/stub.php"" , sizeof ( "".phar/stub.php"" ) - 1 ) ) { mydata -> is_data = 0 ; } else { mydata -> is_data = 1 ; } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len , mydata ) ; if ( actual_alias ) { phar_archive_data * fd_ptr ; if ( ! phar_validate_alias ( actual_alias , mydata -> alias_len ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>invalid<S2SV_blank>alias<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\"""" , actual_alias , fname ) ; } efree ( actual_alias ) ; zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } mydata -> is_temporary_alias = 0 ; if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len ) ) ) { if ( SUCCESS != phar_free_alias ( fd_ptr , actual_alias , mydata -> alias_len ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\""<S2SV_blank>with<S2SV_blank>implicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , fname ) ; } efree ( actual_alias ) ; zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } } mydata -> alias = entry . is_persistent ? pestrndup ( actual_alias , mydata -> alias_len , 1 ) : actual_alias ; if ( entry . is_persistent ) { efree ( actual_alias ) ; } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; } else { phar_archive_data * fd_ptr ; if ( alias_len ) { if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , alias , alias_len ) ) ) { if ( SUCCESS != phar_free_alias ( fd_ptr , alias , alias_len ) ) { if ( error ) { spprintf ( error , 4096 , ""phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\""%s\\""<S2SV_blank>with<S2SV_blank>explicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use"" , fname ) ; } zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; mydata -> alias = pestrndup ( alias , alias_len , mydata -> is_persistent ) ; mydata -> alias_len = alias_len ; } else { mydata -> alias = pestrndup ( mydata -> fname , fname_len , mydata -> is_persistent ) ; mydata -> alias_len = fname_len ; } mydata -> is_temporary_alias = 1 ; } if ( pphar ) { * pphar = mydata ; } return SUCCESS ; }",entry . uncompressed_filesize || read <= 8
133,"static void snd_timer_user_tinterrupt ( struct snd_timer_instance * timeri , unsigned long resolution , unsigned long ticks ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread * r , r1 ; struct timespec tstamp ; int prev , append = 0 ; memset ( & tstamp , 0 , sizeof ( tstamp ) ) ; spin_lock ( & tu -> qlock ) ; if ( ( tu -> filter & ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) ) ) == 0 ) { spin_unlock ( & tu -> qlock ) ; return ; } if ( tu -> last_resolution != resolution || ticks > 0 ) { if ( timer_tstamp_monotonic ) ktime_get_ts ( & tstamp ) ; else getnstimeofday ( & tstamp ) ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) ) && tu -> last_resolution != resolution ) { <S2SV_StartBug> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <S2SV_EndBug> r1 . tstamp = tstamp ; r1 . val = resolution ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; tu -> last_resolution = resolution ; append ++ ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_TICK ) ) == 0 ) goto __wake ; if ( ticks == 0 ) goto __wake ; if ( tu -> qused > 0 ) { prev = tu -> qtail == 0 ? tu -> queue_size - 1 : tu -> qtail - 1 ; r = & tu -> tqueue [ prev ] ; if ( r -> event == SNDRV_TIMER_EVENT_TICK ) { r -> tstamp = tstamp ; r -> val += ticks ; append ++ ; goto __wake ; } } r1 . event = SNDRV_TIMER_EVENT_TICK ; r1 . tstamp = tstamp ; r1 . val = ticks ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; append ++ ; __wake : spin_unlock ( & tu -> qlock ) ; if ( append == 0 ) return ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }","resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;"
134,"static int ext4_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) { struct inode * inode = mapping -> host ; int ret , needed_blocks ; handle_t * handle ; int retries = 0 ; struct page * page ; pgoff_t index ; unsigned from , to ; trace_ext4_write_begin ( inode , pos , len , flags ) ; needed_blocks = ext4_writepage_trans_blocks ( inode ) + 1 ; index = pos >> PAGE_CACHE_SHIFT ; from = pos & ( PAGE_CACHE_SIZE - 1 ) ; to = from + len ; retry : handle = ext4_journal_start ( inode , needed_blocks ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; goto out ; } flags |= AOP_FLAG_NOFS ; page = grab_cache_page_write_begin ( mapping , index , flags ) ; if ( ! page ) { ext4_journal_stop ( handle ) ; ret = - ENOMEM ; goto out ; } * pagep = page ; <S2SV_StartBug> ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , <S2SV_EndBug> <S2SV_StartBug> ext4_get_block ) ; <S2SV_EndBug> if ( ! ret && ext4_should_journal_data ( inode ) ) { ret = walk_page_buffers ( handle , page_buffers ( page ) , from , to , NULL , do_journal_get_write_access ) ; } if ( ret ) { unlock_page ( page ) ; page_cache_release ( page ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; ext4_journal_stop ( handle ) ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } } if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry ; out : return ret ; }","= page ; if ( ext4_should_dioread_nolock ( inode ) ) <S2SV_ModStart> , fsdata , ext4_get_block_write ) ; else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata ,"
135,"<S2SV_StartBug> int16_t vp9_ac_quant ( int qindex , int delta ) { <S2SV_EndBug> return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; <S2SV_StartBug> } <S2SV_EndBug>",", int delta , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return ac_qlookup [ <S2SV_ModStart> ) ] ; case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1 ; } # else ( void ) bit_depth ; return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif"
136,"int <S2SV_StartBug> add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip ) <S2SV_EndBug> { FILE * fp ; char token [ MAXTOKEN ] , token2 [ MAXTOKEN ] ; if ( ( fp = fopen ( tmpstr , ""r"" ) ) == NULL ) { snmp_log_perror ( tmpstr ) ; return 1 ; } DEBUGMSGTL ( ( ""parse-mibs"" , ""Checking<S2SV_blank>file:<S2SV_blank>%s...\\n"" , tmpstr ) ) ; mibLine = 1 ; File = tmpstr ; if ( get_token ( fp , token , MAXTOKEN ) != LABEL ) { fclose ( fp ) ; return 1 ; } if ( get_token ( fp , token2 , MAXTOKEN ) == DEFINITIONS ) { new_module ( token , tmpstr ) ; <S2SV_StartBug> if ( ip ) <S2SV_EndBug> fprintf ( ip , ""%s<S2SV_blank>%s\\n"" , token , d_name ) ; fclose ( fp ) ; return 0 ; } else { fclose ( fp ) ; return 1 ; } }",char * d_name <S2SV_ModEnd> ) { FILE <S2SV_ModStart> tmpstr ) ; <S2SV_ModEnd> fclose ( fp
137,"int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ; <S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , ""failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>child<S2SV_blank>stdio:<S2SV_blank>dup2()"" ) ; return - 1 ; } } return 0 ; }",1 ) ; <S2SV_ModEnd> return 0 ;
138,"void test_parser ( void ) { <S2SV_StartBug> int i , retval ; <S2SV_EndBug> bzrtpPacket_t * zrtpPacket ; bzrtpContext_t * context87654321 = bzrtp_createBzrtpContext ( 0x87654321 ) ; bzrtpContext_t * context12345678 = bzrtp_createBzrtpContext ( 0x12345678 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 0 ] , H12345678 [ 0 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 1 ] , H12345678 [ 1 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 2 ] , H12345678 [ 2 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 3 ] , H12345678 [ 3 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 0 ] , H87654321 [ 0 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 1 ] , H87654321 [ 1 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 2 ] , H87654321 [ 2 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 3 ] , H87654321 [ 3 ] , 32 ) ; context87654321 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context12345678 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context87654321 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context12345678 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context87654321 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ; context12345678 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ; updateCryptoFunctionPointers ( context87654321 -> channelContext [ 0 ] ) ; updateCryptoFunctionPointers ( context12345678 -> channelContext [ 0 ] ) ; context87654321 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ; context12345678 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ; context87654321 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ; context12345678 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ; context87654321 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ; context12345678 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ; context87654321 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ; context12345678 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ; context12345678 -> channelContext [ 0 ] -> role = RESPONDER ; for ( i = 0 ; i < TEST_PACKET_NUMBER ; i ++ ) { uint8_t freePacketFlag = 1 ; zrtpPacket = bzrtp_packetCheck ( patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , ( patternZRTPMetaData [ i ] [ 1 ] ) - 1 , & retval ) ; retval += bzrtp_packetParser ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , zrtpPacket ) ; if ( zrtpPacket -> messageType == MSGTYPE_HELLO ) { if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) { context12345678 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ; } else { context87654321 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ; } freePacketFlag = 0 ; } if ( zrtpPacket -> messageType == MSGTYPE_COMMIT ) { if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) { context12345678 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ; } else { context87654321 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ; } freePacketFlag = 0 ; } if ( zrtpPacket -> messageType == MSGTYPE_DHPART1 || zrtpPacket -> messageType == MSGTYPE_DHPART2 ) { if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) { context12345678 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ; } else { context87654321 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ; } freePacketFlag = 0 ; } free ( zrtpPacket -> packetString ) ; retval = bzrtp_packetBuild ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , zrtpPacket , patternZRTPMetaData [ i ] [ 1 ] ) ; if ( zrtpPacket -> packetString != NULL ) { CU_ASSERT_TRUE ( memcmp ( zrtpPacket -> packetString , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] ) == 0 ) ; <S2SV_StartBug> } else { <S2SV_EndBug> CU_FAIL ( ""Unable<S2SV_blank>to<S2SV_blank>build<S2SV_blank>packet"" ) ; } if ( freePacketFlag == 1 ) { bzrtp_freeZrtpPacket ( zrtpPacket ) ; } } bzrtp_destroyBzrtpContext ( context87654321 , 0x87654321 ) ; bzrtp_destroyBzrtpContext ( context12345678 , 0x12345678 ) ; }",void ) { test_parser_param ( <S2SV_ModEnd> 0 ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
139,"static enum try_read_result try_read_network ( conn * c ) { enum try_read_result gotdata = READ_NO_DATA_RECEIVED ; int res ; <S2SV_StartBug> assert ( c != NULL ) ; <S2SV_EndBug> if ( c -> rcurr != c -> rbuf ) { if ( c -> rbytes != 0 ) memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; } while ( 1 ) { <S2SV_StartBug> if ( c -> rbytes >= c -> rsize ) { <S2SV_EndBug> char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ; if ( ! new_rbuf ) { if ( settings . verbose > 0 ) fprintf ( stderr , ""Couldn\'t<S2SV_blank>realloc<S2SV_blank>input<S2SV_blank>buffer\\n"" ) ; c -> rbytes = 0 ; out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>reading<S2SV_blank>request"" ) ; c -> write_and_go = conn_closing ; return READ_MEMORY_ERROR ; } c -> rcurr = c -> rbuf = new_rbuf ; c -> rsize *= 2 ; } int avail = c -> rsize - c -> rbytes ; res = read ( c -> sfd , c -> rbuf + c -> rbytes , avail ) ; if ( res > 0 ) { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . bytes_read += res ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; gotdata = READ_DATA_RECEIVED ; c -> rbytes += res ; if ( res == avail ) { continue ; } else { break ; } } if ( res == 0 ) { return READ_ERROR ; } if ( res == - 1 ) { if ( errno == EAGAIN || errno == EWOULDBLOCK ) { break ; } return READ_ERROR ; } } return gotdata ; }",int res ; int num_allocs = 0 ; <S2SV_ModStart> rsize ) { if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ;
140,"static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; one = 1 ; image = AcquireImage ( image_info ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; <S2SV_StartBug> Rd_WP_DWORD ( image , & Rec . RecordLength ) ; <S2SV_EndBug> if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( BImgBuff , i , image , bpp ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }","Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"""
141,"static int netlink_dump ( struct sock * sk ) { struct netlink_sock * nlk = nlk_sk ( sk ) ; struct netlink_callback * cb ; struct sk_buff * skb = NULL ; struct nlmsghdr * nlh ; <S2SV_StartBug> int len , err = - ENOBUFS ; <S2SV_EndBug> int alloc_min_size ; int alloc_size ; mutex_lock ( nlk -> cb_mutex ) ; if ( ! nlk -> cb_running ) { err = - EINVAL ; goto errout_skb ; } if ( atomic_read ( & sk -> sk_rmem_alloc ) >= sk -> sk_rcvbuf ) goto errout_skb ; cb = & nlk -> cb ; alloc_min_size = max_t ( int , cb -> min_dump_alloc , NLMSG_GOODSIZE ) ; if ( alloc_min_size < nlk -> max_recvmsg_len ) { alloc_size = nlk -> max_recvmsg_len ; skb = alloc_skb ( alloc_size , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; } if ( ! skb ) { alloc_size = alloc_min_size ; skb = alloc_skb ( alloc_size , GFP_KERNEL ) ; } if ( ! skb ) goto errout_skb ; skb_reserve ( skb , skb_tailroom ( skb ) - alloc_size ) ; netlink_skb_set_owner_r ( skb , sk ) ; len = cb -> dump ( skb , cb ) ; if ( len > 0 ) { mutex_unlock ( nlk -> cb_mutex ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; return 0 ; } nlh = nlmsg_put_answer ( skb , cb , NLMSG_DONE , sizeof ( len ) , NLM_F_MULTI ) ; if ( ! nlh ) goto errout_skb ; nl_dump_check_consistent ( cb , nlh ) ; memcpy ( nlmsg_data ( nlh ) , & len , sizeof ( len ) ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; if ( cb -> done ) cb -> done ( cb ) ; nlk -> cb_running = false ; <S2SV_StartBug> mutex_unlock ( nlk -> cb_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> module_put ( cb -> module ) ; <S2SV_EndBug> <S2SV_StartBug> consume_skb ( cb -> skb ) ; <S2SV_EndBug> return 0 ; errout_skb : mutex_unlock ( nlk -> cb_mutex ) ; kfree_skb ( skb ) ; return err ; }",* nlh ; struct module * module ; <S2SV_ModStart> = false ; module = cb -> module ; skb = cb -> skb ; <S2SV_ModStart> ; module_put ( <S2SV_ModEnd> module ) ; <S2SV_ModStart> ; consume_skb ( <S2SV_ModEnd> skb ) ;
142,"qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""96"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>library:<S2SV_blank>\\""%s\\"".\\n"" , s_alDriver -> string ) ; if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }","CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }"
143,"int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( ""<i>"" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( ""</i>"" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( ""<b>"" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( ""</b>"" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( ""`"" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( ""\'"" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( ""<b>"" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( ""</b>"" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( ""%d"" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , "".<S2SV_blank>"" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( ""<b>"" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; <S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , ""--FRAME--"" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( ""<a<S2SV_blank>hseq=\\""%d\\""<S2SV_blank>href=\\""%s\\"">"" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , ""</a>"" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , ""</pre_int>"" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , """" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , ""</img_alt>"" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , ""</input_alt>"" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = """" ; q = ""!CURRENT_URL!"" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( ""<form<S2SV_blank>method=get<S2SV_blank>action=\\"""" , html_quote ( q ) , ""\\"">"" , html_quote ( p ) , ""<input<S2SV_blank>type=text<S2SV_blank>name=\\""\\""<S2SV_blank>accept></form>"" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , ""Content-Type"" ) && ( q = strcasestr ( q , ""charset"" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , ""refresh"" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( ""Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\""%s\\"">%s</a>"" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( ""Refresh<S2SV_blank>(%d<S2SV_blank>sec)"" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[DEL:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , ""<s>"" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:DEL]</U>"" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , ""</s>"" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[S:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , ""<s>"" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:S]</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , ""</s>"" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[INS:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , ""<ins>"" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:INS]</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , ""</ins>"" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""^"" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""["" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""]"" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<A<S2SV_blank>HREF=\\""%s\\"">bgsound(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<A<S2SV_blank>HREF=\\""%s\\"">embed(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<A<S2SV_blank>HREF=\\""%s\\"">applet<S2SV_blank>archive(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<IMG<S2SV_blank>SRC=\\""%s\\""<S2SV_blank>ALT=\\""bg<S2SV_blank>image(%s)\\""><BR>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( ""</title>"" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }",; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
144,"static int r_core_cmd_subst_i ( RCore * core , char * cmd , char * colon , bool * tmpseek ) { RList * tmpenvs = r_list_newf ( tmpenvs_free ) ; const char * quotestr = ""`"" ; const char * tick = NULL ; char * ptr , * ptr2 , * str ; char * arroba = NULL ; char * grep = NULL ; RIODesc * tmpdesc = NULL ; int pamode = ! core -> io -> va ; int i , ret = 0 , pipefd ; bool usemyblock = false ; int scr_html = - 1 ; int scr_color = - 1 ; bool eos = false ; bool haveQuote = false ; bool oldfixedarch = core -> fixedarch ; bool oldfixedbits = core -> fixedbits ; bool cmd_tmpseek = false ; ut64 tmpbsz = core -> blocksize ; int cmd_ignbithints = - 1 ; if ( ! cmd ) { r_list_free ( tmpenvs ) ; return 0 ; } cmd = r_str_trim_head_tail ( cmd ) ; char * $0 = strstr ( cmd , ""$("" ) ; if ( $0 ) { char * $1 = strchr ( $0 + 2 , ')' ) ; if ( $1 ) { * $0 = '`' ; * $1 = '`' ; memmove ( $0 + 1 , $0 + 2 , strlen ( $0 + 2 ) + 1 ) ; } else { eprintf ( ""Unterminated<S2SV_blank>$()<S2SV_blank>block\\n"" ) ; } } switch ( * cmd ) { case '.' : if ( cmd [ 1 ] == \'""\' ) { r_list_free ( tmpenvs ) ; return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case \'""\' : for ( ; * cmd ; ) { int pipefd = - 1 ; ut64 oseek = UT64_MAX ; char * line , * p ; haveQuote = * cmd == \'""\' ; if ( haveQuote ) { cmd ++ ; p = * cmd ? find_eoq ( cmd ) : NULL ; if ( ! p || ! * p ) { eprintf ( ""Missing<S2SV_blank>\\""<S2SV_blank>in<S2SV_blank>(%s)."" , cmd ) ; r_list_free ( tmpenvs ) ; return false ; } * p ++ = 0 ; if ( ! * p ) { eos = true ; } } else { char * sc = strchr ( cmd , ';' ) ; if ( sc ) { * sc = 0 ; } r_core_cmd0 ( core , cmd ) ; if ( ! sc ) { break ; } cmd = sc + 1 ; continue ; } <S2SV_StartBug> if ( * p ) { <S2SV_EndBug> if ( p [ 0 ] == '@' ) { p -- ; } while ( p [ 1 ] == ';' || IS_WHITESPACE ( p [ 1 ] ) ) { p ++ ; } if ( p [ 1 ] == '@' || ( p [ 1 ] && p [ 2 ] == '@' ) ) { char * q = strchr ( p + 1 , \'""\' ) ; if ( q ) { <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> } haveQuote = q != NULL ; oseek = core -> offset ; r_core_seek ( core , r_num_math ( core -> num , p + 2 ) , 1 ) ; if ( q ) { * p = \'""\' ; p = q ; } else { p = strchr ( p + 1 , ';' ) ; } } if ( p && * p && p [ 1 ] == '>' ) { str = p + 2 ; while ( * str == '>' ) { str ++ ; } str = ( char * ) r_str_trim_ro ( str ) ; r_cons_flush ( ) ; const bool append = p [ 2 ] == '>' ; pipefd = r_cons_pipe_open ( str , 1 , append ) ; } } line = strdup ( cmd ) ; line = r_str_replace ( line , ""\\\\\\"""" , ""\\"""" , true ) ; if ( p && * p && p [ 1 ] == '|' ) { str = p + 2 ; while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_core_cmd_pipe ( core , cmd , str ) ; } else { r_cmd_call ( core -> rcmd , line ) ; } free ( line ) ; if ( oseek != UT64_MAX ) { r_core_seek ( core , oseek , 1 ) ; } if ( pipefd != - 1 ) { r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } if ( ! p ) { break ; } if ( eos ) { break ; } if ( haveQuote ) { if ( * p == ';' ) { cmd = p + 1 ; } else { if ( * p == \'""\' ) { <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> } else { <S2SV_StartBug> * p = \'""\' ; <S2SV_EndBug> cmd = p ; } } } else { cmd = p + 1 ; } } r_list_free ( tmpenvs ) ; return true ; case '(' : if ( cmd [ 1 ] != '*' && ! strstr ( cmd , "")()"" ) ) { r_list_free ( tmpenvs ) ; return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case '?' : if ( cmd [ 1 ] == '>' ) { r_core_cmd_help ( core , help_msg_greater_sign ) ; r_list_free ( tmpenvs ) ; return true ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_firstbut ( cmd , '#' , ""`\\"""" ) ; if ( ptr && ( ptr [ 1 ] == '<S2SV_blank>' || ptr [ 1 ] == '\\t' ) ) { * ptr = '\\0' ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , ';' , quotestr ) ; if ( colon && ptr ) { int ret ; * ptr = '\\0' ; if ( r_core_cmd_subst ( core , cmd ) == - 1 ) { r_list_free ( tmpenvs ) ; return - 1 ; } cmd = ptr + 1 ; ret = r_core_cmd_subst ( core , cmd ) ; * ptr = ';' ; r_list_free ( tmpenvs ) ; return ret ; } } ptr = ( char * ) r_str_lastbut ( cmd , '|' , quotestr ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_pipe ; } } char * ptr2 = strchr ( cmd , '`' ) ; if ( ! ptr2 || ( ptr2 && ptr2 > ptr ) ) { if ( ! tick || ( tick && tick > ptr ) ) { * ptr = '\\0' ; cmd = r_str_trim_nc ( cmd ) ; if ( ! strcmp ( ptr + 1 , ""?"" ) ) { r_core_cmd_help ( core , help_msg_vertical_bar ) ; r_list_free ( tmpenvs ) ; return ret ; } else if ( ! strncmp ( ptr + 1 , ""H"" , 1 ) ) { scr_html = r_config_get_i ( core -> config , ""scr.html"" ) ; r_config_set_i ( core -> config , ""scr.html"" , true ) ; } else if ( ! strcmp ( ptr + 1 , ""T"" ) ) { scr_color = r_config_get_i ( core -> config , ""scr.color"" ) ; r_config_set_i ( core -> config , ""scr.color"" , COLOR_MODE_DISABLED ) ; core -> cons -> use_tts = true ; } else if ( ! strcmp ( ptr + 1 , ""."" ) ) { ret = * cmd ? r_core_cmdf ( core , "".%s"" , cmd ) : 0 ; r_list_free ( tmpenvs ) ; return ret ; } else if ( ptr [ 1 ] ) { int value = core -> num -> value ; if ( * cmd ) { r_core_cmd_pipe ( core , cmd , ptr + 1 ) ; } else { char * res = r_io_system ( core -> io , ptr + 1 ) ; if ( res ) { r_cons_printf ( ""%s\\n"" , res ) ; free ( res ) ; } } core -> num -> value = value ; r_list_free ( tmpenvs ) ; return 0 ; } else { scr_html = r_config_get_i ( core -> config , ""scr.html"" ) ; r_config_set_i ( core -> config , ""scr.html"" , 0 ) ; scr_color = r_config_get_i ( core -> config , ""scr.color"" ) ; r_config_set_i ( core -> config , ""scr.color"" , COLOR_MODE_DISABLED ) ; } } } } escape_pipe : ptr = ( char * ) r_str_lastbut ( cmd , '&' , quotestr ) ; while ( ptr && * ptr && ptr [ 1 ] == '&' ) { * ptr = '\\0' ; ret = r_cmd_call ( core -> rcmd , cmd ) ; if ( ret == - 1 ) { eprintf ( ""command<S2SV_blank>error(%s)\\n"" , cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } r_list_free ( tmpenvs ) ; return ret ; } for ( cmd = ptr + 2 ; cmd && * cmd == '<S2SV_blank>' ; cmd ++ ) { ; } ptr = strchr ( cmd , '&' ) ; } R_FREE ( core -> oobi ) ; ptr = strstr ( cmd , ""?*"" ) ; if ( ptr && ( ptr == cmd || ptr [ - 1 ] != '~' ) ) { ptr [ 0 ] = 0 ; if ( * cmd != '#' ) { int detail = 0 ; if ( cmd < ptr && ptr [ - 1 ] == '?' ) { detail ++ ; if ( cmd < ptr - 1 && ptr [ - 2 ] == '?' ) { detail ++ ; } } r_cons_break_push ( NULL , NULL ) ; recursive_help ( core , detail , cmd ) ; r_cons_break_pop ( ) ; r_cons_grep_parsecmd ( ptr + 2 , ""`"" ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } r_list_free ( tmpenvs ) ; return 0 ; } } # if 0 ptr = strchr ( cmd , '<' ) ; if ( ptr ) { ptr [ 0 ] = '\\0' ; if ( r_cons_singleton ( ) -> is_interactive ) { if ( ptr [ 1 ] == '<' ) { for ( str = ptr + 2 ; str [ 0 ] == '<S2SV_blank>' ; str ++ ) { } eprintf ( ""==><S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>until<S2SV_blank>\'%s\'\\n"" , str ) ; free ( core -> oobi ) ; core -> oobi = malloc ( 1 ) ; if ( core -> oobi ) { core -> oobi [ 0 ] = '\\0' ; } core -> oobi_len = 0 ; for ( ; ; ) { char buf [ 1024 ] ; int ret ; write ( 1 , ""><S2SV_blank>"" , 2 ) ; fgets ( buf , sizeof ( buf ) - 1 , stdin ) ; if ( feof ( stdin ) ) { break ; } if ( * buf ) buf [ strlen ( buf ) - 1 ] = '\\0' ; ret = strlen ( buf ) ; core -> oobi_len += ret ; core -> oobi = realloc ( core -> oobi , core -> oobi_len + 1 ) ; if ( core -> oobi ) { if ( ! strcmp ( buf , str ) ) { break ; } strcat ( ( char * ) core -> oobi , buf ) ; } } } else { for ( str = ptr + 1 ; * str == '<S2SV_blank>' ; str ++ ) { } if ( ! * str ) { goto next ; } eprintf ( ""Slurping<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , str ) ; free ( core -> oobi ) ; core -> oobi = ( ut8 * ) r_file_slurp ( str , & core -> oobi_len ) ; if ( ! core -> oobi ) { eprintf ( ""cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; } else if ( ptr == cmd ) { return r_core_cmd_buffer ( core , ( const char * ) core -> oobi ) ; } } } else { eprintf ( ""Cannot<S2SV_blank>slurp<S2SV_blank>with<S2SV_blank><<<S2SV_blank>in<S2SV_blank>non-interactive<S2SV_blank>mode\\n"" ) ; r_list_free ( tmpenvs ) ; return 0 ; } } next : # endif ptr = ( char * ) r_str_firstbut ( cmd , '>' , ""\\"""" ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_redir ; } } if ( ptr [ 0 ] && ptr [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_greater_sign ) ; r_list_free ( tmpenvs ) ; return true ; } int fdn = 1 ; int pipecolor = r_config_get_i ( core -> config , ""scr.color.pipe"" ) ; int use_editor = false ; int ocolor = r_config_get_i ( core -> config , ""scr.color"" ) ; * ptr = '\\0' ; str = r_str_trim_head_tail ( ptr + 1 + ( ptr [ 1 ] == '>' ) ) ; if ( ! * str ) { eprintf ( ""No<S2SV_blank>output?\\n"" ) ; goto next2 ; } if ( ptr > ( cmd + 1 ) && IS_WHITECHAR ( ptr [ - 2 ] ) ) { char * fdnum = ptr - 1 ; if ( * fdnum == 'H' ) { scr_html = r_config_get_i ( core -> config , ""scr.html"" ) ; r_config_set_i ( core -> config , ""scr.html"" , true ) ; pipecolor = true ; * fdnum = 0 ; } else { if ( IS_DIGIT ( * fdnum ) ) { fdn = * fdnum - '0' ; } * fdnum = 0 ; } } r_cons_set_interactive ( false ) ; if ( ! strcmp ( str , ""-"" ) ) { use_editor = true ; str = r_file_temp ( ""dumpedit"" ) ; r_config_set_i ( core -> config , ""scr.color"" , COLOR_MODE_DISABLED ) ; } const bool appendResult = ( ptr [ 1 ] == '>' ) ; if ( * str == '$' ) { char * o = r_core_cmd_str ( core , cmd ) ; if ( appendResult ) { char * oldText = r_cmd_alias_get ( core -> rcmd , str , 1 ) ; if ( oldText ) { char * two = r_str_newf ( ""%s%s"" , oldText , o ) ; if ( two ) { r_cmd_alias_set ( core -> rcmd , str , two , 1 ) ; free ( two ) ; } } else { char * n = r_str_newf ( ""$%s"" , o ) ; r_cmd_alias_set ( core -> rcmd , str , n , 1 ) ; free ( n ) ; } } else { char * n = r_str_newf ( ""$%s"" , o ) ; r_cmd_alias_set ( core -> rcmd , str , n , 1 ) ; free ( n ) ; } ret = 0 ; free ( o ) ; } else if ( fdn > 0 ) { pipefd = r_cons_pipe_open ( str , fdn , appendResult ) ; if ( pipefd != - 1 ) { if ( ! pipecolor ) { r_config_set_i ( core -> config , ""scr.color"" , COLOR_MODE_DISABLED ) ; } ret = r_core_cmd_subst ( core , cmd ) ; r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } } r_cons_set_last_interactive ( ) ; if ( ! pipecolor ) { r_config_set_i ( core -> config , ""scr.color"" , ocolor ) ; } if ( use_editor ) { const char * editor = r_config_get ( core -> config , ""cfg.editor"" ) ; if ( editor && * editor ) { r_sys_cmdf ( ""%s<S2SV_blank>\'%s\'"" , editor , str ) ; r_file_rm ( str ) ; } else { eprintf ( ""No<S2SV_blank>cfg.editor<S2SV_blank>configured\\n"" ) ; } r_config_set_i ( core -> config , ""scr.color"" , ocolor ) ; free ( str ) ; } if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } core -> cons -> use_tts = false ; r_list_free ( tmpenvs ) ; return ret ; } escape_redir : next2 : ptr = strchr ( cmd , '`' ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_backtick ; } } bool empty = false ; int oneline = 1 ; if ( ptr [ 1 ] == '`' ) { memmove ( ptr , ptr + 1 , strlen ( ptr ) ) ; oneline = 0 ; empty = true ; } ptr2 = strchr ( ptr + 1 , '`' ) ; if ( empty ) { } else if ( ! ptr2 ) { eprintf ( ""parse:<S2SV_blank>Missing<S2SV_blank>backtick<S2SV_blank>in<S2SV_blank>expression.\\n"" ) ; goto fail ; } else { int value = core -> num -> value ; * ptr = '\\0' ; * ptr2 = '\\0' ; if ( ptr [ 1 ] == '!' ) { str = r_core_cmd_str_pipe ( core , ptr + 1 ) ; } else { int ocolor = r_config_get_i ( core -> config , ""scr.color"" ) ; r_config_set_i ( core -> config , ""scr.color"" , 0 ) ; core -> cmd_in_backticks = true ; str = r_core_cmd_str ( core , ptr + 1 ) ; core -> cmd_in_backticks = false ; r_config_set_i ( core -> config , ""scr.color"" , ocolor ) ; } if ( ! str ) { goto fail ; } if ( * str == '|' || * str == '*' ) { eprintf ( ""r_core_cmd_subst_i:<S2SV_blank>invalid<S2SV_blank>backticked<S2SV_blank>command\\n"" ) ; free ( str ) ; goto fail ; } if ( oneline && str ) { for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '\\n' ) { str [ i ] = '<S2SV_blank>' ; } } } str = r_str_append ( str , ptr2 + 1 ) ; cmd = r_str_append ( strdup ( cmd ) , str ) ; core -> num -> value = value ; ret = r_core_cmd_subst ( core , cmd ) ; free ( cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } free ( str ) ; r_list_free ( tmpenvs ) ; return ret ; } } escape_backtick : if ( * cmd != \'""\' && * cmd ) { const char * s = strstr ( cmd , ""~?"" ) ; if ( s ) { bool showHelp = false ; if ( cmd == s ) { showHelp = true ; } else { if ( ! strcmp ( s , ""~??"" ) ) { showHelp = true ; } } if ( showHelp ) { r_cons_grep_help ( ) ; r_list_free ( tmpenvs ) ; return true ; } } } if ( * cmd != '.' ) { grep = r_cons_grep_strip ( cmd , quotestr ) ; } if ( * cmd != \'""\' ) { ptr = strchr ( cmd , '@' ) ; if ( ptr == cmd + 1 && * cmd == '?' ) { ptr = NULL ; } } else { ptr = NULL ; } cmd_tmpseek = core -> tmpseek = ptr ? true : false ; int rc = 0 ; if ( ptr ) { char * f , * ptr2 = strchr ( ptr + 1 , '!' ) ; ut64 addr = core -> offset ; bool addr_is_set = false ; char * tmpbits = NULL ; const char * offstr = NULL ; bool is_bits_set = false ; bool is_arch_set = false ; char * tmpeval = NULL ; char * tmpasm = NULL ; bool flgspc_changed = false ; int tmpfd = - 1 ; int sz , len ; ut8 * buf ; * ptr ++ = '\\0' ; repeat_arroba : arroba = ( ptr [ 0 ] && ptr [ 1 ] && ptr [ 2 ] ) ? strchr ( ptr + 2 , '@' ) : NULL ; if ( arroba ) { * arroba = 0 ; } for ( ; * ptr == '<S2SV_blank>' ; ptr ++ ) { } if ( * ptr && ptr [ 1 ] == ':' ) { } else { ptr -- ; } ptr = r_str_trim_tail ( ptr ) ; if ( ptr [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_at ) ; } else if ( ptr [ 1 ] == '%' ) { char * k = strdup ( ptr + 2 ) ; char * v = strchr ( k , '=' ) ; if ( v ) { * v ++ = 0 ; r_sys_setenv ( k , v ) ; r_list_append ( tmpenvs , k ) ; } else { free ( k ) ; } } else if ( ptr [ 1 ] == '.' ) { if ( ptr [ 2 ] == '.' ) { if ( ptr [ 3 ] == '.' ) { ut64 addr = r_num_tail ( core -> num , core -> offset , ptr + 4 ) ; r_core_block_size ( core , R_ABS ( ( st64 ) addr - ( st64 ) core -> offset ) ) ; goto fuji ; } else { addr = r_num_tail ( core -> num , core -> offset , ptr + 3 ) ; r_core_seek ( core , addr , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; goto fuji ; } } else { eprintf ( ""TODO:<S2SV_blank>what<S2SV_blank>do<S2SV_blank>you<S2SV_blank>expect<S2SV_blank>for<S2SV_blank>@.<S2SV_blank>import<S2SV_blank>offset<S2SV_blank>from<S2SV_blank>file<S2SV_blank>maybe?\\n"" ) ; } } else if ( ptr [ 0 ] && ptr [ 1 ] == ':' && ptr [ 2 ] ) { switch ( ptr [ 0 ] ) { case 'F' : flgspc_changed = r_flag_space_push ( core -> flags , ptr + 2 ) ; break ; case 'B' : { int index = ( int ) r_num_math ( core -> num , ptr + 2 ) ; RAnalBlock * bb = r_anal_bb_from_offset ( core -> anal , core -> offset ) ; if ( bb ) { if ( index < 0 ) { index = bb -> ninstr + index ; } if ( index >= 0 && index < bb -> ninstr ) { ut16 inst_off = r_anal_bb_offset_inst ( bb , index ) ; r_core_seek ( core , bb -> addr + inst_off , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; } else { eprintf ( ""The<S2SV_blank>current<S2SV_blank>basic<S2SV_blank>block<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>instructions\\n"" , bb -> ninstr ) ; } } else { eprintf ( ""Can\'t<S2SV_blank>find<S2SV_blank>a<S2SV_blank>basic<S2SV_blank>block<S2SV_blank>for<S2SV_blank>0x%08"" PFMT64x ""\\n"" , core -> offset ) ; } break ; } break ; case 'f' : f = r_file_slurp ( ptr + 2 , & sz ) ; if ( f ) { { RBuffer * b = r_buf_new_with_bytes ( ( const ut8 * ) f , sz ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , ""io.va"" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; } } # if 0 buf = malloc ( sz ) ; if ( buf ) { free ( core -> block ) ; core -> block = buf ; core -> blocksize = sz ; memcpy ( core -> block , f , sz ) ; usemyblock = true ; } else { eprintf ( ""cannot<S2SV_blank>alloc<S2SV_blank>%d"" , sz ) ; } free ( f ) ; # endif } else { eprintf ( ""cannot<S2SV_blank>open<S2SV_blank>\'%s\'\\n"" , ptr + 3 ) ; } break ; case 'r' : if ( ptr [ 1 ] == ':' ) { ut64 regval ; char * mander = strdup ( ptr + 2 ) ; char * sep = findSeparator ( mander ) ; if ( sep ) { char ch = * sep ; * sep = 0 ; regval = r_debug_reg_get ( core -> dbg , mander ) ; * sep = ch ; char * numexpr = r_str_newf ( ""0x%"" PFMT64x ""%s"" , regval , sep ) ; regval = r_num_math ( core -> num , numexpr ) ; free ( numexpr ) ; } else { regval = r_debug_reg_get ( core -> dbg , ptr + 2 ) ; } r_core_seek ( core , regval , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; free ( mander ) ; } break ; case 'b' : is_bits_set = set_tmp_bits ( core , r_num_math ( core -> num , ptr + 2 ) , & tmpbits ) ; cmd_ignbithints = r_config_get_i ( core -> config , ""anal.ignbithints"" ) ; r_config_set_i ( core -> config , ""anal.ignbithints"" , 1 ) ; break ; case 'i' : { ut64 addr = r_num_math ( core -> num , ptr + 2 ) ; if ( addr ) { r_core_cmdf ( core , ""so<S2SV_blank>%s"" , ptr + 2 ) ; cmd_tmpseek = core -> tmpseek = true ; } } break ; case 'e' : { char * cmd = parse_tmp_evals ( core , ptr + 2 ) ; if ( ! tmpeval ) { tmpeval = cmd ; } else { tmpeval = r_str_prepend ( tmpeval , cmd ) ; free ( cmd ) ; } } break ; case 'x' : if ( ptr [ 1 ] == ':' ) { buf = malloc ( strlen ( ptr + 2 ) + 1 ) ; if ( buf ) { len = r_hex_str2bin ( ptr + 2 , buf ) ; r_core_block_size ( core , R_ABS ( len ) ) ; if ( len > 0 ) { RBuffer * b = r_buf_new_with_bytes ( buf , len ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , ""io.va"" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; r_core_block_size ( core , len ) ; r_core_block_read ( core ) ; } } else { eprintf ( ""Error:<S2SV_blank>Invalid<S2SV_blank>hexpairs<S2SV_blank>for<S2SV_blank>@x:\\n"" ) ; } free ( buf ) ; } else { eprintf ( ""cannot<S2SV_blank>allocate\\n"" ) ; } } else { eprintf ( ""Invalid<S2SV_blank>@x:<S2SV_blank>syntax\\n"" ) ; } break ; case 'k' : { char * out = sdb_querys ( core -> sdb , NULL , 0 , ptr + ( ( ptr [ 1 ] ) ? 2 : 1 ) ) ; if ( out ) { r_core_seek ( core , r_num_math ( core -> num , out ) , 1 ) ; free ( out ) ; usemyblock = true ; } } break ; case 'o' : if ( ptr [ 1 ] == ':' ) { tmpfd = core -> io -> desc ? core -> io -> desc -> fd : - 1 ; r_io_use_fd ( core -> io , atoi ( ptr + 2 ) ) ; } break ; case 'a' : if ( ptr [ 1 ] == ':' ) { char * q = strchr ( ptr + 2 , ':' ) ; if ( q ) { * q ++ = 0 ; int bits = r_num_math ( core -> num , q ) ; is_bits_set = set_tmp_bits ( core , bits , & tmpbits ) ; } is_arch_set = set_tmp_arch ( core , ptr + 2 , & tmpasm ) ; } else { eprintf ( ""Usage:<S2SV_blank>pd<S2SV_blank>10<S2SV_blank>@a:arm:32\\n"" ) ; } break ; case 's' : { len = strlen ( ptr + 2 ) ; r_core_block_size ( core , len ) ; const ut8 * buf = ( const ut8 * ) r_str_trim_ro ( ptr + 2 ) ; if ( len > 0 ) { RBuffer * b = r_buf_new_with_bytes ( buf , len ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( ! core -> io -> va ) { r_config_set_i ( core -> config , ""io.va"" , 1 ) ; } if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , ""io.va"" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; r_core_block_size ( core , len ) ; } } } break ; default : goto ignore ; } * ptr = '@' ; char * trim = ptr - 2 ; while ( trim > cmd ) { if ( ! IS_WHITESPACE ( * trim ) ) { break ; } * trim = 0 ; trim -- ; } goto next_arroba ; } ignore : ptr = r_str_trim_head ( ptr + 1 ) - 1 ; cmd = r_str_trim_nc ( cmd ) ; if ( ptr2 ) { if ( strlen ( ptr + 1 ) == 13 && strlen ( ptr2 + 1 ) == 6 && ! memcmp ( ptr + 1 , ""0x"" , 2 ) && ! memcmp ( ptr2 + 1 , ""0x"" , 2 ) ) { } else if ( strlen ( ptr + 1 ) == 9 && strlen ( ptr2 + 1 ) == 4 ) { } else { * ptr2 = '\\0' ; if ( ! ptr2 [ 1 ] ) { goto fail ; } r_core_block_size ( core , r_num_math ( core -> num , ptr2 + 1 ) ) ; } } offstr = r_str_trim_head ( ptr + 1 ) ; addr = r_num_math ( core -> num , offstr ) ; addr_is_set = true ; if ( isalpha ( ( ut8 ) ptr [ 1 ] ) && ! addr ) { if ( ! r_flag_get ( core -> flags , ptr + 1 ) ) { eprintf ( ""Invalid<S2SV_blank>address<S2SV_blank>(%s)\\n"" , ptr + 1 ) ; goto fail ; } } else { char ch = * offstr ; if ( ch == '-' || ch == '+' ) { addr = core -> offset + addr ; } } if ( addr ) { RIODesc * d = tmpdesc ; if ( d ) { r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , addr , r_io_desc_size ( d ) ) ; } } next_arroba : if ( arroba ) { ptr = arroba + 1 ; * arroba = '@' ; arroba = NULL ; goto repeat_arroba ; } core -> fixedblock = ! ! tmpdesc ; if ( core -> fixedblock ) { r_core_block_read ( core ) ; } if ( ptr [ 1 ] == '@' ) { if ( ptr [ 2 ] == '@' ) { char * rule = ptr + 3 ; while ( * rule && * rule == '<S2SV_blank>' ) { rule ++ ; } ret = r_core_cmd_foreach3 ( core , cmd , rule ) ; } else { ret = r_core_cmd_foreach ( core , cmd , ptr + 2 ) ; } } else { bool tmpseek = false ; const char * fromvars [ ] = { ""anal.from"" , ""diff.from"" , ""graph.from"" , ""io.buffer.from"" , ""lines.from"" , ""search.from"" , ""zoom.from"" , NULL } ; const char * tovars [ ] = { ""anal.to"" , ""diff.to"" , ""graph.to"" , ""io.buffer.to"" , ""lines.to"" , ""search.to"" , ""zoom.to"" , NULL } ; ut64 curfrom [ R_ARRAY_SIZE ( fromvars ) - 1 ] , curto [ R_ARRAY_SIZE ( tovars ) - 1 ] ; if ( ptr [ 1 ] == '(' ) { char * range = ptr + 3 ; char * p = strchr ( range , '<S2SV_blank>' ) ; if ( ! p ) { eprintf ( ""Usage:<S2SV_blank>/<S2SV_blank>ABCD<S2SV_blank>@..0x1000<S2SV_blank>0x3000\\n"" ) ; free ( tmpeval ) ; free ( tmpasm ) ; free ( tmpbits ) ; goto fail ; } * p = '\\x00' ; ut64 from = r_num_math ( core -> num , range ) ; ut64 to = r_num_math ( core -> num , p + 1 ) ; for ( i = 0 ; fromvars [ i ] ; i ++ ) { curfrom [ i ] = r_config_get_i ( core -> config , fromvars [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { curto [ i ] = r_config_get_i ( core -> config , tovars [ i ] ) ; } for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , from ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , to ) ; } tmpseek = true ; } if ( usemyblock ) { if ( addr_is_set ) { core -> offset = addr ; } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { if ( addr_is_set ) { if ( ptr [ 1 ] ) { r_core_seek ( core , addr , 1 ) ; r_core_block_read ( core ) ; } } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } if ( tmpseek ) { for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , curfrom [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , curto [ i ] ) ; } } } if ( ptr2 ) { * ptr2 = '!' ; r_core_block_size ( core , tmpbsz ) ; } if ( is_arch_set ) { core -> fixedarch = oldfixedarch ; r_config_set ( core -> config , ""asm.arch"" , tmpasm ) ; R_FREE ( tmpasm ) ; } if ( tmpfd != - 1 ) { r_io_use_fd ( core -> io , tmpfd ) ; } if ( tmpdesc ) { if ( pamode ) { r_config_set_i ( core -> config , ""io.va"" , 0 ) ; } r_io_desc_close ( tmpdesc ) ; tmpdesc = NULL ; } if ( is_bits_set ) { r_config_set ( core -> config , ""asm.bits"" , tmpbits ) ; core -> fixedbits = oldfixedbits ; } if ( tmpbsz != core -> blocksize ) { r_core_block_size ( core , tmpbsz ) ; } if ( tmpeval ) { r_core_cmd0 ( core , tmpeval ) ; R_FREE ( tmpeval ) ; } if ( flgspc_changed ) { r_flag_space_pop ( core -> flags ) ; } * ptr = '@' ; rc = ret ; goto beach ; } fuji : rc = cmd ? r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) : false ; beach : r_cons_grep_process ( grep ) ; if ( scr_html != - 1 ) { r_cons_flush ( ) ; r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } r_list_free ( tmpenvs ) ; if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; tmpdesc = NULL ; } core -> fixedarch = oldfixedarch ; core -> fixedbits = oldfixedbits ; if ( tmpseek ) { * tmpseek = cmd_tmpseek ; } if ( cmd_ignbithints != - 1 ) { r_config_set_i ( core -> config , ""anal.ignbithints"" , cmd_ignbithints ) ; } return rc ; fail : rc = - 1 ; goto beach ; }",continue ; } char op0 = 0 ; <S2SV_ModStart> q ) { op0 = * q ; <S2SV_ModStart> cmd = p <S2SV_ModEnd> ; } else <S2SV_ModStart> * p = op0 <S2SV_ModEnd> ; cmd =
145,"int check_user_token ( const char * authfile , const char * username , const char * otp_id , int verbose , FILE * debug_file ) { char buf [ 1024 ] ; char * s_user , * s_token ; int retval = AUTH_ERROR ; int fd ; struct stat st ; FILE * opwfile ; fd = open ( authfile , O_RDONLY , 0 ) ; if ( fd < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; return retval ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; close ( fd ) ; return retval ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , authfile ) ; close ( fd ) ; return retval ; } opwfile = fdopen ( fd , ""r"" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , ""fdopen:<S2SV_blank>%s"" , strerror ( errno ) ) ; close ( fd ) ; return retval ; } retval = AUTH_NO_TOKENS ; while ( fgets ( buf , 1024 , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( buf [ 0 ] == '#' ) { if ( verbose ) D ( debug_file , ""Skipping<S2SV_blank>comment<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; continue ; } if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; s_user = strtok_r ( buf , "":"" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , ""Matched<S2SV_blank>user:<S2SV_blank>%s"" , s_user ) ; retval = AUTH_NOT_FOUND ; do { s_token = strtok_r ( NULL , "":"" , & saveptr ) ; if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>token:<S2SV_blank>%s"" , s_token ) ; if ( s_token && otp_id && strcmp ( otp_id , s_token ) == 0 ) { if ( verbose ) D ( debug_file , ""Match<S2SV_blank>user/token<S2SV_blank>as<S2SV_blank>%s/%s"" , username , otp_id ) ; <S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> } } while ( s_token != NULL ) ; } } fclose ( opwfile ) ; return retval ; }",otp_id ) ; fclose ( opwfile ) ;
146,static int PARSER_FLAGS ( PyCompilerFlags * flags ) { int parser_flags = 0 ; if ( ! flags ) return 0 ; if ( flags -> cf_flags & PyCF_DONT_IMPLY_DEDENT ) parser_flags |= PyPARSE_DONT_IMPLY_DEDENT ; if ( flags -> cf_flags & PyCF_IGNORE_COOKIE ) parser_flags |= PyPARSE_IGNORE_COOKIE ; if ( flags -> cf_flags & CO_FUTURE_BARRY_AS_BDFL ) parser_flags |= PyPARSE_BARRY_AS_BDFL ; <S2SV_StartBug> return parser_flags ; <S2SV_EndBug> },|= PyPARSE_BARRY_AS_BDFL ; if ( flags -> cf_flags & PyCF_TYPE_COMMENTS ) parser_flags |= PyPARSE_TYPE_COMMENTS ;
147,"void bootp_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register const struct bootp * bp ; static const u_char vm_cmu [ 4 ] = VM_CMU ; static const u_char vm_rfc1048 [ 4 ] = VM_RFC1048 ; bp = ( const struct bootp * ) cp ; ND_TCHECK ( bp -> bp_op ) ; ND_PRINT ( ( ndo , ""BOOTP/DHCP,<S2SV_blank>%s"" , tok2str ( bootp_op_values , ""unknown<S2SV_blank>(0x%02x)"" , bp -> bp_op ) ) ) ; ND_TCHECK ( bp -> bp_hlen ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 && bp -> bp_op == BOOTPREQUEST ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>from<S2SV_blank>%s"" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_TCHECK ( bp -> bp_secs ) ; if ( bp -> bp_htype != 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>htype<S2SV_blank>%d"" , bp -> bp_htype ) ) ; if ( bp -> bp_htype != 1 || bp -> bp_hlen != 6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>hlen<S2SV_blank>%d"" , bp -> bp_hlen ) ) ; if ( bp -> bp_hops ) ND_PRINT ( ( ndo , "",<S2SV_blank>hops<S2SV_blank>%d"" , bp -> bp_hops ) ) ; if ( EXTRACT_32BITS ( & bp -> bp_xid ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>xid<S2SV_blank>0x%x"" , EXTRACT_32BITS ( & bp -> bp_xid ) ) ) ; if ( EXTRACT_16BITS ( & bp -> bp_secs ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>secs<S2SV_blank>%d"" , EXTRACT_16BITS ( & bp -> bp_secs ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , <S2SV_EndBug> bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ; ND_TCHECK ( bp -> bp_ciaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_ciaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Client-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_ciaddr ) ) ) ; ND_TCHECK ( bp -> bp_yiaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_yiaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Your-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_yiaddr ) ) ) ; ND_TCHECK ( bp -> bp_siaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_siaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Server-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_siaddr ) ) ) ; ND_TCHECK ( bp -> bp_giaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_giaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Gateway-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_giaddr ) ) ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Client-Ethernet-Address<S2SV_blank>%s"" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_TCHECK2 ( bp -> bp_sname [ 0 ] , 1 ) ; if ( * bp -> bp_sname ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>sname<S2SV_blank>\\"""" ) ) ; if ( fn_printztn ( ndo , bp -> bp_sname , ( u_int ) sizeof bp -> bp_sname , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } ND_TCHECK2 ( bp -> bp_file [ 0 ] , 1 ) ; if ( * bp -> bp_file ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>file<S2SV_blank>\\"""" ) ) ; if ( fn_printztn ( ndo , bp -> bp_file , ( u_int ) sizeof bp -> bp_file , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } ND_TCHECK ( bp -> bp_vend [ 0 ] ) ; if ( memcmp ( ( const char * ) bp -> bp_vend , vm_rfc1048 , sizeof ( uint32_t ) ) == 0 ) rfc1048_print ( ndo , bp -> bp_vend ) ; else if ( memcmp ( ( const char * ) bp -> bp_vend , vm_cmu , sizeof ( uint32_t ) ) == 0 ) cmu_print ( ndo , bp -> bp_vend ) ; else { uint32_t ul ; ul = EXTRACT_32BITS ( & bp -> bp_vend ) ; if ( ul != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Vendor-#0x%x"" , ul ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }",) ) ; ND_TCHECK ( bp -> bp_flags ) ;
148,"static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; int interlaced = dctx -> interlaced ; int cur_field = dctx -> cur_field ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; interlaced = ( state & 2 ) >> 1 ; cur_field = state & 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i >= dctx -> remaining && ( ! dctx -> interlaced || dctx -> cur_field ) ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> interlaced = interlaced ; dctx -> cur_field = 0 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> interlaced = interlaced ; dctx -> cur_field = 0 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; dctx -> interlaced = interlaced ; dctx -> cur_field = cur_field ; return END_NOT_FOUND ; }",& 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
149,"grub_ssize_t grub_fshelp_read_file ( grub_disk_t disk , grub_fshelp_node_t node , void ( * read_hook ) ( grub_disk_addr_t sector , unsigned offset , unsigned length , void * closure ) , void * closure , int flags , grub_off_t pos , grub_size_t len , char * buf , grub_disk_addr_t ( * get_block ) ( grub_fshelp_node_t node , grub_disk_addr_t block ) , grub_off_t filesize , int log2blocksize ) { grub_disk_addr_t i , blockcnt ; int blocksize = 1 << ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; if ( pos + len > filesize ) len = filesize - pos ; <S2SV_StartBug> blockcnt = ( ( len + pos ) + blocksize - 1 ) >> <S2SV_EndBug> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; for ( i = pos >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; i < blockcnt ; i ++ ) { grub_disk_addr_t blknr ; int blockoff = pos & ( blocksize - 1 ) ; int blockend = blocksize ; int skipfirst = 0 ; blknr = get_block ( node , i ) ; if ( grub_errno ) return - 1 ; blknr = blknr << log2blocksize ; if ( i == blockcnt - 1 ) { blockend = ( len + pos ) & ( blocksize - 1 ) ; if ( ! blockend ) blockend = blocksize ; } if ( i == ( pos >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ) ) { skipfirst = blockoff ; blockend -= skipfirst ; } if ( blknr ) { disk -> read_hook = read_hook ; disk -> closure = closure ; grub_hack_lastoff = blknr * 512 ; grub_disk_read_ex ( disk , blknr , skipfirst , blockend , buf , flags ) ; disk -> read_hook = 0 ; if ( grub_errno ) return - 1 ; } else if ( buf ) grub_memset ( buf , 0 , blockend ) ; if ( buf ) buf += blocksize - skipfirst ; } return len ; }",- pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
150,"int migrate_page_move_mapping ( struct address_space * mapping , struct page * newpage , struct page * page , struct buffer_head * head , enum migrate_mode mode , int extra_count ) { <S2SV_StartBug> int expected_count = 1 + extra_count ; <S2SV_EndBug> void * * pslot ; if ( ! mapping ) { if ( page_count ( page ) != expected_count ) return - EAGAIN ; set_page_memcg ( newpage , page_memcg ( page ) ) ; newpage -> index = page -> index ; newpage -> mapping = page -> mapping ; if ( PageSwapBacked ( page ) ) SetPageSwapBacked ( newpage ) ; return MIGRATEPAGE_SUCCESS ; <S2SV_StartBug> } <S2SV_EndBug> spin_lock_irq ( & mapping -> tree_lock ) ; pslot = radix_tree_lookup_slot ( & mapping -> page_tree , page_index ( page ) ) ; expected_count += 1 + page_has_private ( page ) ; if ( page_count ( page ) != expected_count || radix_tree_deref_slot_protected ( pslot , & mapping -> tree_lock ) != page ) { spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } if ( ! page_freeze_refs ( page , expected_count ) ) { spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } if ( mode == MIGRATE_ASYNC && head && ! buffer_migrate_lock_buffers ( head , mode ) ) { page_unfreeze_refs ( page , expected_count ) ; spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } set_page_memcg ( newpage , page_memcg ( page ) ) ; newpage -> index = page -> index ; newpage -> mapping = page -> mapping ; if ( PageSwapBacked ( page ) ) SetPageSwapBacked ( newpage ) ; get_page ( newpage ) ; if ( PageSwapCache ( page ) ) { SetPageSwapCache ( newpage ) ; set_page_private ( newpage , page_private ( page ) ) ; } <S2SV_StartBug> radix_tree_replace_slot ( pslot , newpage ) ; <S2SV_EndBug> page_unfreeze_refs ( page , expected_count - 1 ) ; <S2SV_StartBug> __dec_zone_page_state ( page , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) { <S2SV_EndBug> __dec_zone_page_state ( page , NR_SHMEM ) ; __inc_zone_page_state ( newpage , NR_SHMEM ) ; } spin_unlock_irq ( & mapping -> tree_lock ) ; return MIGRATEPAGE_SUCCESS ; }","extra_count ) { struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> 1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> NR_FILE_PAGES ) ; __inc_zone_state ( newzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> ; if ( PageSwapBacked ( page ) && <S2SV_ModStart> ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> ) ; return"
151,"static guint32 parse_wbxml_attribute_list_defined ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr , const wbxml_decoding * map ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; guint8 attr_save_known = 0 ; const char * attr_save_literal = NULL ; DebugLog ( ( ""parse_wbxml_attr_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , <S2SV_StartBug> level , offset ) ) ; <S2SV_EndBug> while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( ""ATTR:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>"" ""off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>-->%3d<S2SV_blank>"" ""|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Attr<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|"" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\'&#%u;\'"" , level , * codepage_attr , Indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; attr_save_known = 0 ; attr_save_literal = tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL<S2SV_blank>(Literal<S2SV_blank>Attribute)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s<%s<S2SV_blank>/>"" , level , * codepage_attr , Indent ( level ) , attr_save_literal ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%s:<S2SV_blank>\\\'%s\\\')"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , map_token ( map -> global , 0 , peek ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; { char * s ; if ( map -> ext_t [ peek & 0x03 ] ) s = ( map -> ext_t [ peek & 0x03 ] ) ( tvb , idx , str_tbl ) ; else s = wmem_strdup_printf ( wmem_packet_scope ( ) , ""EXT_T_%1x<S2SV_blank>(%s)"" , peek & 0x03 , map_token ( map -> global , 0 , peek ) ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s%s)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , s ) ; } off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%s)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , map_token ( map -> global , 0 , peek ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { char * str ; if ( attr_save_known ) { if ( map -> opaque_binary_attr ) { str = map -> opaque_binary_attr ( tvb , off + 1 , attr_save_known , * codepage_attr , & len ) ; } else { str = default_opaque_binary_attr ( tvb , off + 1 , attr_save_known , * codepage_attr , & len ) ; } } else { if ( map -> opaque_literal_tag ) { str = map -> opaque_literal_attr ( tvb , off + 1 , attr_save_literal , * codepage_attr , & len ) ; } else { str = default_opaque_literal_attr ( tvb , off + 1 , attr_save_literal , * codepage_attr , & len ) ; } } proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s%s"" , level , * codepage_attr , Indent ( level ) , str ) ; off += 1 + len ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr ) ; off = tvb_len ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%-10s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , ""(unknown<S2SV_blank>0x%x)"" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrValue<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s%s"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , map_token ( map -> attrValue , * codepage_attr , peek ) ) ; off ++ ; } else { attr_save_known = peek & 0x7f ; proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrStart<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s%s"" , level , * codepage_attr , attr_save_known , Indent ( level ) , map_token ( map -> attrStart , * codepage_attr , peek ) ) ; off ++ ; } } <S2SV_StartBug> } <S2SV_EndBug> DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n"" , level , off - offset ) ) ; return ( off - offset ) ; }","off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;"
152,"BOOL license_read_scope_list ( wStream * s , SCOPE_LIST * scopeList ) { UINT32 i ; UINT32 scopeCount ; if ( Stream_GetRemainingLength ( s ) < 4 ) return FALSE ; <S2SV_StartBug> Stream_Read_UINT32 ( s , scopeCount ) ; <S2SV_EndBug> scopeList -> count = scopeCount ; scopeList -> array = ( LICENSE_BLOB * ) malloc ( sizeof ( LICENSE_BLOB ) * scopeCount ) ; for ( i = 0 ; i < scopeCount ; i ++ ) { scopeList -> array [ i ] . type = BB_SCOPE_BLOB ; if ( ! license_read_binary_blob ( s , & scopeList -> array [ i ] ) ) return FALSE ; } return TRUE ; }",", scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE"
153,"STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; <S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug> acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }",aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
154,"struct key * key_alloc ( struct key_type * type , const char * desc , kuid_t uid , kgid_t gid , const struct cred * cred , key_perm_t perm , unsigned long flags , struct key_restriction * restrict_link ) { struct key_user * user = NULL ; struct key * key ; size_t desclen , quotalen ; int ret ; key = ERR_PTR ( - EINVAL ) ; if ( ! desc || ! * desc ) goto error ; if ( type -> vet_description ) { ret = type -> vet_description ( desc ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } desclen = strlen ( desc ) ; quotalen = desclen + 1 + type -> def_datalen ; user = key_user_lookup ( uid ) ; if ( ! user ) goto no_memory_1 ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & user -> lock ) ; if ( ! ( flags & KEY_ALLOC_QUOTA_OVERRUN ) ) { if ( user -> qnkeys + 1 >= maxkeys || user -> qnbytes + quotalen >= maxbytes || user -> qnbytes + quotalen < user -> qnbytes ) goto no_quota ; } user -> qnkeys ++ ; user -> qnbytes += quotalen ; spin_unlock ( & user -> lock ) ; } key = kmem_cache_zalloc ( key_jar , GFP_KERNEL ) ; if ( ! key ) goto no_memory_2 ; key -> index_key . desc_len = desclen ; key -> index_key . description = kmemdup ( desc , desclen + 1 , GFP_KERNEL ) ; if ( ! key -> index_key . description ) goto no_memory_3 ; refcount_set ( & key -> usage , 1 ) ; init_rwsem ( & key -> sem ) ; lockdep_set_class ( & key -> sem , & type -> lock_class ) ; key -> index_key . type = type ; key -> user = user ; key -> quotalen = quotalen ; key -> datalen = type -> def_datalen ; key -> uid = uid ; key -> gid = gid ; key -> perm = perm ; key -> restrict_link = restrict_link ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) key -> flags |= 1 << KEY_FLAG_IN_QUOTA ; if ( flags & KEY_ALLOC_BUILT_IN ) key -> flags |= 1 << KEY_FLAG_BUILTIN ; <S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> key -> magic = KEY_DEBUG_MAGIC ; # endif ret = security_key_alloc ( key , cred , flags ) ; if ( ret < 0 ) goto security_error ; atomic_inc ( & user -> nkeys ) ; key_alloc_serial ( key ) ; error : return key ; security_error : kfree ( key -> description ) ; kmem_cache_free ( key_jar , key ) ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; key = ERR_PTR ( ret ) ; goto error ; no_memory_3 : kmem_cache_free ( key_jar , key ) ; no_memory_2 : if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; no_memory_1 : key = ERR_PTR ( - ENOMEM ) ; goto error ; no_quota : spin_unlock ( & user -> lock ) ; key_user_put ( user ) ; key = ERR_PTR ( - EDQUOT ) ; goto error ; }",<< KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
155,"int tls1_mac ( SSL * ssl , SSL3_RECORD * rec , unsigned char * md , int send ) { unsigned char * seq ; EVP_MD_CTX * hash ; size_t md_size ; int i ; EVP_MD_CTX * hmac = NULL , * mac_ctx ; unsigned char header [ 13 ] ; int stream_mac = ( send ? ( ssl -> mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM ) : ( ssl -> mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM ) ) ; int t ; if ( send ) { seq = RECORD_LAYER_get_write_sequence ( & ssl -> rlayer ) ; hash = ssl -> write_hash ; } else { seq = RECORD_LAYER_get_read_sequence ( & ssl -> rlayer ) ; hash = ssl -> read_hash ; } t = EVP_MD_CTX_size ( hash ) ; OPENSSL_assert ( t >= 0 ) ; md_size = t ; if ( stream_mac ) { mac_ctx = hash ; } else { hmac = EVP_MD_CTX_new ( ) ; if ( hmac == NULL || ! EVP_MD_CTX_copy ( hmac , hash ) ) return - 1 ; mac_ctx = hmac ; } if ( SSL_IS_DTLS ( ssl ) ) { unsigned char dtlsseq [ 8 ] , * p = dtlsseq ; s2n ( send ? DTLS_RECORD_LAYER_get_w_epoch ( & ssl -> rlayer ) : DTLS_RECORD_LAYER_get_r_epoch ( & ssl -> rlayer ) , p ) ; memcpy ( p , & seq [ 2 ] , 6 ) ; memcpy ( header , dtlsseq , 8 ) ; } else memcpy ( header , seq , 8 ) ; header [ 8 ] = rec -> type ; header [ 9 ] = ( unsigned char ) ( ssl -> version >> 8 ) ; header [ 10 ] = ( unsigned char ) ( ssl -> version ) ; header [ 11 ] = ( rec -> length ) >> 8 ; header [ 12 ] = ( rec -> length ) & 0xff ; <S2SV_StartBug> if ( ! send && ! SSL_USE_ETM ( ssl ) && <S2SV_EndBug> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) { if ( ssl3_cbc_digest_record ( mac_ctx , md , & md_size , header , rec -> input , rec -> length + md_size , rec -> orig_len , ssl -> s3 -> read_mac_secret , ssl -> s3 -> read_mac_secret_size , 0 ) <= 0 ) { EVP_MD_CTX_free ( hmac ) ; return - 1 ; } } else { if ( EVP_DigestSignUpdate ( mac_ctx , header , sizeof ( header ) ) <= 0 || EVP_DigestSignUpdate ( mac_ctx , rec -> input , rec -> length ) <= 0 || EVP_DigestSignFinal ( mac_ctx , md , & md_size ) <= 0 ) { EVP_MD_CTX_free ( hmac ) ; return - 1 ; } <S2SV_StartBug> if ( ! send && ! SSL_USE_ETM ( ssl ) && FIPS_mode ( ) ) <S2SV_EndBug> if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , rec -> orig_len ) ) { EVP_MD_CTX_free ( hmac ) ; return - 1 ; } } EVP_MD_CTX_free ( hmac ) ; # ifdef SSL_DEBUG fprintf ( stderr , ""seq="" ) ; { int z ; for ( z = 0 ; z < 8 ; z ++ ) fprintf ( stderr , ""%02X<S2SV_blank>"" , seq [ z ] ) ; fprintf ( stderr , ""\\n"" ) ; } fprintf ( stderr , ""rec="" ) ; { unsigned int z ; for ( z = 0 ; z < rec -> length ; z ++ ) fprintf ( stderr , ""%02X<S2SV_blank>"" , rec -> data [ z ] ) ; fprintf ( stderr , ""\\n"" ) ; } # endif if ( ! SSL_IS_DTLS ( ssl ) ) { for ( i = 7 ; i >= 0 ; i -- ) { ++ seq [ i ] ; if ( seq [ i ] != 0 ) break ; } } # ifdef SSL_DEBUG { unsigned int z ; for ( z = 0 ; z < md_size ; z ++ ) fprintf ( stderr , ""%02X<S2SV_blank>"" , md [ z ] ) ; fprintf ( stderr , ""\\n"" ) ; } # endif return ( md_size ) ; }",send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl ) <S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl )
156,"int do_remount_sb ( struct super_block * sb , int flags , void * data , int force ) { int retval ; int remount_ro ; if ( sb -> s_writers . frozen != SB_UNFROZEN ) return - EBUSY ; # ifdef CONFIG_BLOCK if ( ! ( flags & MS_RDONLY ) && bdev_read_only ( sb -> s_bdev ) ) return - EACCES ; # endif if ( flags & MS_RDONLY ) acct_auto_close ( sb ) ; shrink_dcache_sb ( sb ) ; sync_filesystem ( sb ) ; remount_ro = ( flags & MS_RDONLY ) && ! ( sb -> s_flags & MS_RDONLY ) ; if ( remount_ro ) { if ( force ) { <S2SV_StartBug> mark_files_ro ( sb ) ; <S2SV_EndBug> } else { retval = sb_prepare_remount_readonly ( sb ) ; if ( retval ) return retval ; } } if ( sb -> s_op -> remount_fs ) { retval = sb -> s_op -> remount_fs ( sb , & flags , data ) ; if ( retval ) { if ( ! force ) goto cancel_readonly ; WARN ( 1 , ""forced<S2SV_blank>remount<S2SV_blank>of<S2SV_blank>a<S2SV_blank>%s<S2SV_blank>fs<S2SV_blank>returned<S2SV_blank>%i\\n"" , sb -> s_type -> name , retval ) ; } } sb -> s_flags = ( sb -> s_flags & ~ MS_RMT_MASK ) | ( flags & MS_RMT_MASK ) ; smp_wmb ( ) ; sb -> s_readonly_remount = 0 ; if ( remount_ro && sb -> s_bdev ) invalidate_bdev ( sb -> s_bdev ) ; return 0 ; cancel_readonly : sb -> s_readonly_remount = 0 ; return retval ; }",force ) { sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> ) ; }
157,"static GsfInfileTar * tar_directory_for_file ( GsfInfileTar * dir , const char * name , gboolean last ) { const char * s = name ; while ( 1 ) { const char * s0 = s ; char * dirname ; while ( 1 ) { if ( * s == 0 ) { if ( last && s != s0 ) break ; else return dir ; } if ( * s == '/' ) break ; s ++ ; } dirname = g_strndup ( s0 , s - s0 ) ; while ( * s == '/' ) s ++ ; if ( strcmp ( dirname , ""."" ) != 0 ) { GsfInput * subdir = gsf_infile_child_by_name ( GSF_INFILE ( dir ) , dirname ) ; if ( subdir ) { <S2SV_StartBug> g_object_unref ( subdir ) ; <S2SV_EndBug> <S2SV_StartBug> dir = GSF_INFILE_TAR ( subdir ) ; <S2SV_EndBug> } else dir = tar_create_dir ( dir , dirname ) ; } g_free ( dirname ) ; } }",subdir ) { dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; <S2SV_ModStart> subdir ) ; <S2SV_ModEnd> } else dir
158,"static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { <S2SV_StartBug> int i ; <S2SV_EndBug> memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , ""prompt="" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""debug_file="" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , ""stdout"" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , ""stderr"" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , ""syslog"" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else { <S2SV_StartBug> struct stat st ; <S2SV_EndBug> FILE * file ; <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> if ( S_ISREG ( st . st_mode ) ) { <S2SV_StartBug> file = fopen ( filename , ""a"" ) ; <S2SV_EndBug> if ( file != NULL ) { cfg -> debug_file = file ; <S2SV_StartBug> } <S2SV_EndBug> } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , ""called."" ) ; D ( cfg -> debug_file , ""flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d"" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , ""argv[%d]=%s"" , i , argv [ i ] ) ; } D ( cfg -> debug_file , ""max_devices=%d"" , cfg -> max_devs ) ; D ( cfg -> debug_file , ""debug=%d"" , cfg -> debug ) ; D ( cfg -> debug_file , ""interactive=%d"" , cfg -> interactive ) ; D ( cfg -> debug_file , ""cue=%d"" , cfg -> cue ) ; D ( cfg -> debug_file , ""nodetect=%d"" , cfg -> nodetect ) ; D ( cfg -> debug_file , ""manual=%d"" , cfg -> manual ) ; D ( cfg -> debug_file , ""nouserok=%d"" , cfg -> nouserok ) ; D ( cfg -> debug_file , ""openasuser=%d"" , cfg -> openasuser ) ; D ( cfg -> debug_file , ""alwaysok=%d"" , cfg -> alwaysok ) ; D ( cfg -> debug_file , ""authfile=%s"" , cfg -> auth_file ? cfg -> auth_file : ""(null)"" ) ; D ( cfg -> debug_file , ""authpending_file=%s"" , cfg -> authpending_file ? cfg -> authpending_file : ""(null)"" ) ; D ( cfg -> debug_file , ""origin=%s"" , cfg -> origin ? cfg -> origin : ""(null)"" ) ; D ( cfg -> debug_file , ""appid=%s"" , cfg -> appid ? cfg -> appid : ""(null)"" ) ; D ( cfg -> debug_file , ""prompt=%s"" , cfg -> prompt ? cfg -> prompt : ""(null)"" ) ; } <S2SV_StartBug> } <S2SV_EndBug>","cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> , & st <S2SV_ModStart> == 0 ) && <S2SV_ModEnd> S_ISREG ( st <S2SV_ModStart> { file = fdopen ( fd <S2SV_ModEnd> , ""a"" ) <S2SV_ModStart> = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> } } } <S2SV_ModStart> ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;"
159,"static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmGlobalEntry * ptr = NULL ; <S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> if ( sec -> payload_data + 32 > buflen ) { return NULL ; } if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; while ( i < len && len < buflen && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmGlobalEntry ) ) ) { return ret ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , ( ut8 * ) & ptr -> content_type , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , & ptr -> mutability , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { goto beach ; } r_list_append ( ret , ptr ) ; r ++ ; } return ret ; beach : free ( ptr ) ; return ret ; }",= NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
160,"static gdImagePtr gdImageScaleTwoPass ( const gdImagePtr src , const unsigned int new_width , const unsigned int new_height ) { const unsigned int src_width = src -> sx ; const unsigned int src_height = src -> sy ; gdImagePtr tmp_im = NULL ; gdImagePtr dst = NULL ; if ( src_width == new_width && src_height == new_height ) { return gdImageClone ( src ) ; } if ( ! src -> trueColor ) { gdImagePaletteToTrueColor ( src ) ; } if ( src_width == new_width ) { tmp_im = src ; } else { tmp_im = gdImageCreateTrueColor ( new_width , src_height ) ; if ( tmp_im == NULL ) { return NULL ; } gdImageSetInterpolationMethod ( tmp_im , src -> interpolation_id ) ; _gdScalePass ( src , src_width , tmp_im , new_width , src_height , HORIZONTAL ) ; } if ( src_height == new_height ) { assert ( tmp_im != src ) ; return tmp_im ; } dst = gdImageCreateTrueColor ( new_width , new_height ) ; if ( dst != NULL ) { gdImageSetInterpolationMethod ( dst , src -> interpolation_id ) ; _gdScalePass ( tmp_im , src_height , dst , new_height , new_width , VERTICAL ) ; } if ( src != tmp_im ) { <S2SV_StartBug> gdFree ( tmp_im ) ; <S2SV_EndBug> } return dst ; }",tmp_im ) { gdImageDestroy <S2SV_ModEnd> ( tmp_im )
161,"sctp_disposition_t sctp_sf_ootb ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sk_buff * skb = chunk -> skb ; sctp_chunkhdr_t * ch ; sctp_errhdr_t * err ; __u8 * ch_end ; int ootb_shut_ack = 0 ; int ootb_cookie_ack = 0 ; SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; ch = ( sctp_chunkhdr_t * ) chunk -> chunk_hdr ; do { if ( ntohs ( ch -> length ) < sizeof ( sctp_chunkhdr_t ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; <S2SV_StartBug> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) <S2SV_EndBug> ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } } ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ; if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; <S2SV_StartBug> ch = ( sctp_chunkhdr_t * ) ch_end ; <S2SV_EndBug> } while ( ch_end < skb_tail_pointer ( skb ) ) ; if ( ootb_shut_ack ) return sctp_sf_shut_8_4_5 ( net , ep , asoc , type , arg , commands ) ; else if ( ootb_cookie_ack ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; else return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; }","commands ) ; <S2SV_ModEnd> ch_end = ( <S2SV_ModStart> commands ) ; if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } }"
162,"static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ; if ( mode ) { const int res = vp9_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) mode -> h_scaling_mode , ( VPX_SCALING ) mode -> v_scaling_mode ) ; return ( res == 0 ) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }","* ctx , <S2SV_ModEnd> va_list args )"
163,"static inline int l2cap_config_req ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u16 cmd_len , u8 * data ) { struct l2cap_conf_req * req = ( struct l2cap_conf_req * ) data ; u16 dcid , flags ; u8 rsp [ 64 ] ; struct sock * sk ; int len ; dcid = __le16_to_cpu ( req -> dcid ) ; flags = __le16_to_cpu ( req -> flags ) ; BT_DBG ( ""dcid<S2SV_blank>0x%4.4x<S2SV_blank>flags<S2SV_blank>0x%2.2x"" , dcid , flags ) ; sk = l2cap_get_chan_by_scid ( & conn -> chan_list , dcid ) ; if ( ! sk ) return - ENOENT ; if ( sk -> sk_state == BT_DISCONN ) goto unlock ; len = cmd_len - sizeof ( * req ) ; if ( l2cap_pi ( sk ) -> conf_len + len > sizeof ( l2cap_pi ( sk ) -> conf_req ) ) { l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , l2cap_build_conf_rsp ( sk , rsp , L2CAP_CONF_REJECT , flags ) , rsp ) ; goto unlock ; } memcpy ( l2cap_pi ( sk ) -> conf_req + l2cap_pi ( sk ) -> conf_len , req -> data , len ) ; l2cap_pi ( sk ) -> conf_len += len ; if ( flags & 0x0001 ) { l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , l2cap_build_conf_rsp ( sk , rsp , L2CAP_CONF_SUCCESS , 0x0001 ) , rsp ) ; goto unlock ; } len = l2cap_parse_conf_req ( sk , rsp ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> goto unlock ; <S2SV_StartBug> l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ; <S2SV_EndBug> l2cap_pi ( sk ) -> conf_len = 0 ; if ( ! ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_OUTPUT_DONE ) ) goto unlock ; if ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_INPUT_DONE ) { sk -> sk_state = BT_CONNECTED ; l2cap_chan_ready ( sk ) ; goto unlock ; } if ( ! ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_REQ_SENT ) ) { u8 buf [ 64 ] ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , l2cap_build_conf_req ( sk , buf ) , buf ) ; <S2SV_StartBug> } <S2SV_EndBug> unlock : bh_unlock_sock ( sk ) ; return 0 ; }","< 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; <S2SV_ModStart> goto unlock ; } <S2SV_ModStart> , rsp ) ; l2cap_pi ( sk ) -> num_conf_rsp ++ <S2SV_ModStart> buf ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;"
164,"static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , <S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> { int symlink_len = 0 ; <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) : <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> isonum_733 ( rr -> u . CL . location ) ; reloc = <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;"
165,"static int csnmp_read_table ( host_definition_t * host , data_definition_t * data ) { struct snmp_pdu * req ; struct snmp_pdu * res = NULL ; struct variable_list * vb ; const data_set_t * ds ; size_t oid_list_len = data -> values_len + 1 ; oid_t oid_list [ oid_list_len ] ; _Bool oid_list_todo [ oid_list_len ] ; int status ; size_t i ; csnmp_list_instances_t * instance_list_head ; csnmp_list_instances_t * instance_list_tail ; csnmp_table_values_t * * value_list_head ; csnmp_table_values_t * * value_list_tail ; DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table<S2SV_blank>(host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%s)"" , host -> name , data -> name ) ; if ( host -> sess_handle == NULL ) { DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table:<S2SV_blank>host->sess_handle<S2SV_blank>==<S2SV_blank>NULL"" ) ; return ( - 1 ) ; } ds = plugin_get_ds ( data -> type ) ; if ( ! ds ) { ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>DataSet<S2SV_blank>`%s\'<S2SV_blank>not<S2SV_blank>defined."" , data -> type ) ; return ( - 1 ) ; } if ( ds -> ds_num != data -> values_len ) { ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>DataSet<S2SV_blank>`%s\'<S2SV_blank>requires<S2SV_blank>%zu<S2SV_blank>values,<S2SV_blank>but<S2SV_blank>config<S2SV_blank>talks<S2SV_blank>"" ""about<S2SV_blank>%zu"" , data -> type , ds -> ds_num , data -> values_len ) ; return ( - 1 ) ; } assert ( data -> values_len > 0 ) ; memcpy ( oid_list , data -> values , data -> values_len * sizeof ( oid_t ) ) ; if ( data -> instance . oid . oid_len > 0 ) memcpy ( oid_list + data -> values_len , & data -> instance . oid , sizeof ( oid_t ) ) ; else oid_list_len -- ; for ( i = 0 ; i < oid_list_len ; i ++ ) oid_list_todo [ i ] = 1 ; value_list_head = calloc ( data -> values_len , sizeof ( * value_list_head ) ) ; value_list_tail = calloc ( data -> values_len , sizeof ( * value_list_tail ) ) ; if ( ( value_list_head == NULL ) || ( value_list_tail == NULL ) ) { ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table:<S2SV_blank>calloc<S2SV_blank>failed."" ) ; sfree ( value_list_head ) ; sfree ( value_list_tail ) ; return ( - 1 ) ; } instance_list_head = NULL ; instance_list_tail = NULL ; status = 0 ; while ( status == 0 ) { int oid_list_todo_num ; req = snmp_pdu_create ( SNMP_MSG_GETNEXT ) ; if ( req == NULL ) { ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>snmp_pdu_create<S2SV_blank>failed."" ) ; status = - 1 ; break ; } oid_list_todo_num = 0 ; for ( i = 0 ; i < oid_list_len ; i ++ ) { if ( ! oid_list_todo [ i ] ) continue ; oid_list_todo_num ++ ; snmp_add_null_var ( req , oid_list [ i ] . oid , oid_list [ i ] . oid_len ) ; } if ( oid_list_todo_num == 0 ) { <S2SV_StartBug> DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree"" ) ; <S2SV_EndBug> status = 0 ; break ; } res = NULL ; status = snmp_sess_synch_response ( host -> sess_handle , req , & res ) ; if ( ( status != STAT_SUCCESS ) || ( res == NULL ) ) { char * errstr = NULL ; snmp_sess_error ( host -> sess_handle , NULL , NULL , & errstr ) ; c_complain ( LOG_ERR , & host -> complaint , ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>%s:<S2SV_blank>snmp_sess_synch_response<S2SV_blank>failed:<S2SV_blank>%s"" , host -> name , ( errstr == NULL ) ? ""Unknown<S2SV_blank>problem"" : errstr ) ; if ( res != NULL ) snmp_free_pdu ( res ) ; res = NULL ; <S2SV_StartBug> req = NULL ; <S2SV_EndBug> sfree ( errstr ) ; csnmp_host_close_session ( host ) ; status = - 1 ; break ; } status = 0 ; assert ( res != NULL ) ; c_release ( LOG_INFO , & host -> complaint , ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>%s:<S2SV_blank>snmp_sess_synch_response<S2SV_blank>successful."" , host -> name ) ; vb = res -> variables ; if ( vb == NULL ) { status = - 1 ; break ; } for ( vb = res -> variables , i = 0 ; ( vb != NULL ) ; vb = vb -> next_variable , i ++ ) { while ( ( i < oid_list_len ) && ! oid_list_todo [ i ] ) i ++ ; if ( ( data -> instance . oid . oid_len > 0 ) && ( i == data -> values_len ) ) { if ( ( vb -> type == SNMP_ENDOFMIBVIEW ) || ( snmp_oid_ncompare ( data -> instance . oid . oid , data -> instance . oid . oid_len , vb -> name , vb -> name_length , data -> instance . oid . oid_len ) != 0 ) ) { DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>=<S2SV_blank>%s;<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%s;<S2SV_blank>Instance<S2SV_blank>left<S2SV_blank>its<S2SV_blank>subtree."" , host -> name , data -> name ) ; oid_list_todo [ i ] = 0 ; continue ; } if ( csnmp_instance_list_add ( & instance_list_head , & instance_list_tail , res , host , data ) != 0 ) { ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>%s:<S2SV_blank>csnmp_instance_list_add<S2SV_blank>failed."" , host -> name ) ; status = - 1 ; break ; } } else { csnmp_table_values_t * vt ; oid_t vb_name ; oid_t suffix ; int ret ; csnmp_oid_init ( & vb_name , vb -> name , vb -> name_length ) ; ret = csnmp_oid_suffix ( & suffix , & vb_name , data -> values + i ) ; if ( ret != 0 ) { DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>=<S2SV_blank>%s;<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%s;<S2SV_blank>i<S2SV_blank>=<S2SV_blank>%zu;<S2SV_blank>"" ""Value<S2SV_blank>probably<S2SV_blank>left<S2SV_blank>its<S2SV_blank>subtree."" , host -> name , data -> name , i ) ; oid_list_todo [ i ] = 0 ; continue ; } if ( ( value_list_tail [ i ] != NULL ) && ( csnmp_oid_compare ( & suffix , & value_list_tail [ i ] -> suffix ) <= 0 ) ) { DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>=<S2SV_blank>%s;<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%s;<S2SV_blank>i<S2SV_blank>=<S2SV_blank>%zu;<S2SV_blank>"" ""Suffix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>increasing."" , host -> name , data -> name , i ) ; oid_list_todo [ i ] = 0 ; continue ; } vt = calloc ( 1 , sizeof ( * vt ) ) ; if ( vt == NULL ) { ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>calloc<S2SV_blank>failed."" ) ; status = - 1 ; break ; } vt -> value = csnmp_value_list_to_value ( vb , ds -> ds [ i ] . type , data -> scale , data -> shift , host -> name , data -> name ) ; memcpy ( & vt -> suffix , & suffix , sizeof ( vt -> suffix ) ) ; vt -> next = NULL ; if ( value_list_tail [ i ] == NULL ) value_list_head [ i ] = vt ; else value_list_tail [ i ] -> next = vt ; value_list_tail [ i ] = vt ; } memcpy ( oid_list [ i ] . oid , vb -> name , sizeof ( oid ) * vb -> name_length ) ; oid_list [ i ] . oid_len = vb -> name_length ; } if ( res != NULL ) snmp_free_pdu ( res ) ; res = NULL ; } if ( res != NULL ) snmp_free_pdu ( res ) ; res = NULL ; <S2SV_StartBug> if ( req != NULL ) <S2SV_EndBug> snmp_free_pdu ( req ) ; req = NULL ; if ( status == 0 ) csnmp_dispatch_table ( host , data , instance_list_head , value_list_head ) ; while ( instance_list_head != NULL ) { csnmp_list_instances_t * next = instance_list_head -> next ; sfree ( instance_list_head ) ; instance_list_head = next ; } for ( i = 0 ; i < data -> values_len ; i ++ ) { while ( value_list_head [ i ] != NULL ) { csnmp_table_values_t * next = value_list_head [ i ] -> next ; sfree ( value_list_head [ i ] ) ; value_list_head [ i ] = next ; } } sfree ( value_list_head ) ; sfree ( value_list_tail ) ; return ( 0 ) ; }","DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree"" ) ; snmp_free_pdu ( req <S2SV_ModStart> = NULL ; <S2SV_ModEnd> sfree ( errstr <S2SV_ModStart> ; if ( <S2SV_ModEnd> status == 0"
166,"PHP_FUNCTION ( radius_get_vendor_attr ) { <S2SV_StartBug> int res ; <S2SV_EndBug> <S2SV_StartBug> const void * data ; <S2SV_EndBug> int len ; <S2SV_StartBug> u_int32_t vendor ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) { <S2SV_EndBug> return ; } <S2SV_StartBug> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <S2SV_EndBug> if ( res == - 1 ) { RETURN_FALSE ; } else { array_init ( return_value ) ; <S2SV_StartBug> add_assoc_long ( return_value , ""attr"" , res ) ; <S2SV_EndBug> add_assoc_long ( return_value , ""vendor"" , vendor ) ; <S2SV_StartBug> add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ; <S2SV_EndBug> return ; } }","radius_get_vendor_attr ) { <S2SV_ModEnd> const void * <S2SV_ModStart> void * data , * raw <S2SV_ModStart> ; u_int32_t vendor ; unsigned char type ; size_t data_len <S2SV_ModStart> ""s"" , & raw <S2SV_ModEnd> , & len <S2SV_ModStart> return ; } if ( <S2SV_ModEnd> rad_get_vendor_attr ( & <S2SV_ModStart> vendor , & type , & data , & data_len , raw , len ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> , ""attr"" , type <S2SV_ModEnd> ) ; add_assoc_long <S2SV_ModStart> ) data , data_len <S2SV_ModEnd> , 1 )"
167,"static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixel<S2SV_blank>format<S2SV_blank>0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }",bpp <= 8 && c -> format != CHUNKY
168,"void httpClientParseQopParam ( const HttpParam * param , HttpWwwAuthenticateHeader * authHeader ) { # if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) size_t i ; size_t n ; authHeader -> qop = HTTP_AUTH_QOP_NONE ; for ( i = 0 ; i < param -> valueLen ; i += ( n + 1 ) ) { for ( n = 0 ; ( i + n ) < param -> valueLen ; n ++ ) { <S2SV_StartBug> if ( strchr ( "",<S2SV_blank>\\t"" , param -> value [ i + n ] ) ) <S2SV_EndBug> break ; } if ( n == 4 && ! osStrncasecmp ( param -> value + i , ""auth"" , 4 ) ) { authHeader -> qop = HTTP_AUTH_QOP_AUTH ; } } if ( authHeader -> qop == HTTP_AUTH_QOP_NONE ) { authHeader -> mode = HTTP_AUTH_MODE_NONE ; } # endif }","{ if ( osStrchr <S2SV_ModEnd> ( "",<S2SV_blank>\\t"" , <S2SV_ModStart> n ] ) != NULL ) { break ; } <S2SV_ModEnd> } if ("
169,"static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( ""index"" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { print_str ( ""codec_name"" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( ""codec_long_name"" , cd -> long_name ? cd -> long_name : ""unknown"" ) ; } } else { print_str_opt ( ""codec_name"" , ""unknown"" ) ; if ( ! do_bitexact ) { print_str_opt ( ""codec_long_name"" , ""unknown"" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( ""profile"" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , ""%d"" , par -> profile ) ; print_str ( ""profile"" , profile_num ) ; } else print_str_opt ( ""profile"" , ""unknown"" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( ""codec_type"" , s ) ; else print_str_opt ( ""codec_type"" , ""unknown"" ) ; # if FF_API_LAVF_AVCTX if ( dec_ctx ) print_q ( ""codec_time_base"" , dec_ctx -> time_base , '/' ) ; # endif print_str ( ""codec_tag_string"" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( ""codec_tag"" , ""0x%04"" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , par -> width ) ; print_int ( ""height"" , par -> height ) ; if ( dec_ctx ) { print_int ( ""coded_width"" , dec_ctx -> coded_width ) ; print_int ( ""coded_height"" , dec_ctx -> coded_height ) ; } print_int ( ""has_b_frames"" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . den ) { print_q ( ""sample_aspect_ratio"" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( ""display_aspect_ratio"" , dar , ':' ) ; } else { print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ; print_str_opt ( ""display_aspect_ratio"" , ""N/A"" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( ""pix_fmt"" , s ) ; else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ; print_int ( ""level"" , par -> level ) ; if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( par -> color_range ) ) ; else print_str_opt ( ""color_range"" , ""N/A"" ) ; if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; else print_str_opt ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; <S2SV_StartBug> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; else print_str_opt ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; else print_str_opt ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( ""field_order"" , ""progressive"" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( ""field_order"" , ""tt"" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( ""field_order"" , ""bb"" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( ""field_order"" , ""tb"" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( ""field_order"" , ""bt"" ) ; else print_str_opt ( ""field_order"" , ""unknown"" ) ; # if FF_API_PRIVATE_OPT if ( dec_ctx && dec_ctx -> timecode_frame_start >= 0 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , dec_ctx -> timecode_frame_start ) ; print_str ( ""timecode"" , tcbuf ) ; } else { print_str_opt ( ""timecode"" , ""N/A"" ) ; } # endif if ( dec_ctx ) print_int ( ""refs"" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( ""sample_fmt"" , s ) ; else print_str_opt ( ""sample_fmt"" , ""unknown"" ) ; print_val ( ""sample_rate"" , par -> sample_rate , unit_hertz_str ) ; print_int ( ""channels"" , par -> channels ) ; if ( par -> channel_layout ) { av_bprint_clear ( & pbuf ) ; av_bprint_channel_layout ( & pbuf , par -> channels , par -> channel_layout ) ; print_str ( ""channel_layout"" , pbuf . str ) ; } else { print_str_opt ( ""channel_layout"" , ""unknown"" ) ; } print_int ( ""bits_per_sample"" , av_get_bits_per_sample ( par -> codec_id ) ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( ""width"" , par -> width ) ; else print_str_opt ( ""width"" , ""N/A"" ) ; if ( par -> height ) print_int ( ""height"" , par -> height ) ; else print_str_opt ( ""height"" , ""N/A"" ) ; break ; } if ( dec_ctx && dec_ctx -> codec && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) { uint8_t * str ; if ( opt -> flags ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( ""id"" , ""0x%x"" , stream -> id ) ; else print_str_opt ( ""id"" , ""N/A"" ) ; print_q ( ""r_frame_rate"" , stream -> r_frame_rate , '/' ) ; print_q ( ""avg_frame_rate"" , stream -> avg_frame_rate , '/' ) ; print_q ( ""time_base"" , stream -> time_base , '/' ) ; print_ts ( ""start_pts"" , stream -> start_time ) ; print_time ( ""start_time"" , stream -> start_time , & stream -> time_base ) ; print_ts ( ""duration_ts"" , stream -> duration ) ; print_time ( ""duration"" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( ""bit_rate"" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""bit_rate"" , ""N/A"" ) ; # if FF_API_LAVF_AVCTX if ( stream -> codec -> rc_max_rate > 0 ) print_val ( ""max_bit_rate"" , stream -> codec -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""max_bit_rate"" , ""N/A"" ) ; # endif if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( ""bits_per_raw_sample"" , ""%d"" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( ""bits_per_raw_sample"" , ""N/A"" ) ; if ( stream -> nb_frames ) print_fmt ( ""nb_frames"" , ""%"" PRId64 , stream -> nb_frames ) ; else print_str_opt ( ""nb_frames"" , ""N/A"" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( ""nb_read_frames"" , ""%"" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( ""nb_read_frames"" , ""N/A"" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( ""nb_read_packets"" , ""%"" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( ""nb_read_packets"" , ""N/A"" ) ; if ( do_show_data ) writer_print_data ( w , ""extradata"" , par -> extradata , par -> extradata_size ) ; writer_print_data_hash ( w , ""extradata_hash"" , par -> extradata , par -> extradata_size ) ; # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , ""default"" ) ; PRINT_DISPOSITION ( DUB , ""dub"" ) ; PRINT_DISPOSITION ( ORIGINAL , ""original"" ) ; PRINT_DISPOSITION ( COMMENT , ""comment"" ) ; PRINT_DISPOSITION ( LYRICS , ""lyrics"" ) ; PRINT_DISPOSITION ( KARAOKE , ""karaoke"" ) ; PRINT_DISPOSITION ( FORCED , ""forced"" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , ""hearing_impaired"" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , ""visual_impaired"" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , ""clean_effects"" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , ""attached_pic"" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , ""timed_thumbnails"" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }",") ) ; print_primaries ( w , <S2SV_ModEnd> par -> color_primaries <S2SV_ModStart> par -> color_primaries <S2SV_ModEnd> ) ; if"
170,"static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; <S2SV_StartBug> } <S2SV_EndBug> fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } <S2SV_StartBug> return num ; <S2SV_EndBug> }",= SCM_MAX_FD ; fpl -> user = NULL ; <S2SV_ModStart> ++ ; } if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;
171,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ; mark_as_seen ( object ) ; }","* object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *"
172,"static enum try_read_result try_read_network ( conn * c ) { enum try_read_result gotdata = READ_NO_DATA_RECEIVED ; int res ; <S2SV_StartBug> assert ( c != NULL ) ; <S2SV_EndBug> if ( c -> rcurr != c -> rbuf ) { if ( c -> rbytes != 0 ) memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; } while ( 1 ) { <S2SV_StartBug> if ( c -> rbytes >= c -> rsize ) { <S2SV_EndBug> char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ; if ( ! new_rbuf ) { if ( settings . verbose > 0 ) fprintf ( stderr , ""Couldn\'t<S2SV_blank>realloc<S2SV_blank>input<S2SV_blank>buffer\\n"" ) ; c -> rbytes = 0 ; out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>reading<S2SV_blank>request"" ) ; c -> write_and_go = conn_closing ; return READ_MEMORY_ERROR ; } c -> rcurr = c -> rbuf = new_rbuf ; c -> rsize *= 2 ; } int avail = c -> rsize - c -> rbytes ; res = read ( c -> sfd , c -> rbuf + c -> rbytes , avail ) ; if ( res > 0 ) { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . bytes_read += res ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; gotdata = READ_DATA_RECEIVED ; c -> rbytes += res ; if ( res == avail ) { continue ; } else { break ; } } if ( res == 0 ) { return READ_ERROR ; } if ( res == - 1 ) { if ( errno == EAGAIN || errno == EWOULDBLOCK ) { break ; } return READ_ERROR ; } } return gotdata ; }",int res ; int num_allocs = 0 ; <S2SV_ModStart> rsize ) { if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ;
173,"static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * caption , geometry [ MaxTextExtent ] , * property , * text ; const char * gravity , * option ; DrawInfo * draw_info ; Image * image ; MagickBooleanType split , status ; register ssize_t i ; size_t height , width ; TypeMetric metrics ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; option = GetImageOption ( image_info , ""filename"" ) ; if ( option == ( const char * ) NULL ) property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; else if ( LocaleNCompare ( option , ""caption:"" , 8 ) == 0 ) property = InterpretImageProperties ( image_info , image , option + 8 ) ; else property = InterpretImageProperties ( image_info , image , option ) ; ( void ) SetImageProperty ( image , ""caption"" , property ) ; property = DestroyString ( property ) ; caption = ConstantString ( GetImageProperty ( image , ""caption"" ) ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; gravity = GetImageOption ( image_info , ""gravity"" ) ; if ( gravity != ( char * ) NULL ) draw_info -> gravity = ( GravityType ) ParseCommandOption ( MagickGravityOptions , MagickFalse , gravity ) ; split = MagickFalse ; status = MagickTrue ; if ( image -> columns == 0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> columns = width ; } if ( image -> rows == 0 ) { split = MagickTrue ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; image -> rows = ( size_t ) ( ( i + 1 ) * ( metrics . ascent - metrics . descent + draw_info -> interline_spacing + draw_info -> stroke_width ) + 0.5 ) ; } if ( status != MagickFalse ) status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; ( void ) status ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = floor ( ( low + high ) / 2.0 - 0.5 ) ; } i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , MagickMax ( draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0.0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; <S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""caption:pointsize"" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; caption = DestroyString ( caption ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }","0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;"
174,"int snmp_helper ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ; <S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> if ( * pdata == ctx -> from ) { pr_debug ( ""%s:<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n"" , __func__ , ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ; if ( * ctx -> check ) fast_csum ( ctx , ( unsigned char * ) data - ctx -> begin ) ; * pdata = ctx -> to ; } return 1 ; }",; __be32 * pdata ; if ( datalen != 4 ) return - EINVAL ;
175,"static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; <S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }",; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
176,"int WavpackSetConfiguration64 ( WavpackContext * wpc , WavpackConfig * config , int64_t total_samples , const unsigned char * chan_ids ) { uint32_t flags , bps = 0 ; uint32_t chan_mask = config -> channel_mask ; int num_chans = config -> num_channels ; <S2SV_StartBug> int i ; <S2SV_EndBug> wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ; if ( ( config -> qmode & QMODE_DSD_AUDIO ) && config -> bytes_per_sample == 1 && config -> bits_per_sample == 8 ) { # ifdef ENABLE_DSD wpc -> dsd_multiplier = 1 ; flags = DSD_FLAG ; for ( i = 14 ; i >= 0 ; -- i ) if ( config -> sample_rate % sample_rates [ i ] == 0 ) { int divisor = config -> sample_rate / sample_rates [ i ] ; if ( divisor && ( divisor & ( divisor - 1 ) ) == 0 ) { config -> sample_rate /= divisor ; wpc -> dsd_multiplier = divisor ; break ; } } if ( config -> flags & CONFIG_HYBRID_FLAG ) { strcpy ( wpc -> error_message , ""hybrid<S2SV_blank>mode<S2SV_blank>not<S2SV_blank>available<S2SV_blank>for<S2SV_blank>DSD!"" ) ; return FALSE ; } config -> flags &= ( CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS ) ; config -> float_norm_exp = config -> xmode = 0 ; # else strcpy ( wpc -> error_message , ""libwavpack<S2SV_blank>not<S2SV_blank>configured<S2SV_blank>for<S2SV_blank>DSD!"" ) ; return FALSE ; # endif } else flags = config -> bytes_per_sample - 1 ; wpc -> total_samples = total_samples ; wpc -> config . sample_rate = config -> sample_rate ; wpc -> config . num_channels = config -> num_channels ; wpc -> config . channel_mask = config -> channel_mask ; wpc -> config . bits_per_sample = config -> bits_per_sample ; wpc -> config . bytes_per_sample = config -> bytes_per_sample ; wpc -> config . block_samples = config -> block_samples ; wpc -> config . flags = config -> flags ; wpc -> config . qmode = config -> qmode ; if ( config -> flags & CONFIG_VERY_HIGH_FLAG ) wpc -> config . flags |= CONFIG_HIGH_FLAG ; for ( i = 0 ; i < 15 ; ++ i ) if ( wpc -> config . sample_rate == sample_rates [ i ] ) break ; flags |= i << SRATE_LSB ; if ( ! ( flags & DSD_FLAG ) ) { if ( config -> float_norm_exp ) { wpc -> config . float_norm_exp = config -> float_norm_exp ; wpc -> config . flags |= CONFIG_FLOAT_DATA ; flags |= FLOAT_DATA ; } else flags |= ( ( config -> bytes_per_sample * 8 ) - config -> bits_per_sample ) << SHIFT_LSB ; if ( config -> flags & CONFIG_HYBRID_FLAG ) { flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE ; if ( ! ( wpc -> config . flags & CONFIG_SHAPE_OVERRIDE ) ) { wpc -> config . flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } else if ( wpc -> config . flags & CONFIG_HYBRID_SHAPE ) { wpc -> config . shaping_weight = config -> shaping_weight ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } if ( wpc -> config . flags & ( CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC ) ) flags |= CROSS_DECORR ; if ( config -> flags & CONFIG_BITRATE_KBPS ) { bps = ( uint32_t ) floor ( config -> bitrate * 256000.0 / config -> sample_rate / config -> num_channels + 0.5 ) ; if ( bps > ( 64 << 8 ) ) bps = 64 << 8 ; } else bps = ( uint32_t ) floor ( config -> bitrate * 256.0 + 0.5 ) ; } else flags |= CROSS_DECORR ; if ( ! ( config -> flags & CONFIG_JOINT_OVERRIDE ) || ( config -> flags & CONFIG_JOINT_STEREO ) ) flags |= JOINT_STEREO ; if ( config -> flags & CONFIG_CREATE_WVC ) wpc -> wvc_flag = TRUE ; } if ( chan_ids ) { int lastchan = 0 , mask_copy = chan_mask ; if ( ( int ) strlen ( ( char * ) chan_ids ) > num_chans ) { strcpy ( wpc -> error_message , ""chan_ids<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>num<S2SV_blank>channels!"" ) ; return FALSE ; } while ( * chan_ids ) if ( * chan_ids <= 32 && * chan_ids > lastchan && ( mask_copy & ( 1 << ( * chan_ids - 1 ) ) ) ) { mask_copy &= ~ ( 1 << ( * chan_ids - 1 ) ) ; lastchan = * chan_ids ++ ; } else break ; for ( i = 0 ; chan_ids [ i ] ; i ++ ) if ( chan_ids [ i ] != 0xff ) { wpc -> channel_identities = ( unsigned char * ) strdup ( ( char * ) chan_ids ) ; break ; } } for ( wpc -> current_stream = 0 ; num_chans ; wpc -> current_stream ++ ) { WavpackStream * wps = malloc ( sizeof ( WavpackStream ) ) ; unsigned char left_chan_id = 0 , right_chan_id = 0 ; int pos , chans = 1 ; wpc -> streams = realloc ( wpc -> streams , ( wpc -> current_stream + 1 ) * sizeof ( wpc -> streams [ 0 ] ) ) ; wpc -> streams [ wpc -> current_stream ] = wps ; CLEAR ( * wps ) ; if ( chan_mask ) for ( pos = 0 ; pos < 32 ; ++ pos ) if ( chan_mask & ( 1 << pos ) ) { if ( left_chan_id ) { right_chan_id = pos + 1 ; break ; } else { chan_mask &= ~ ( 1 << pos ) ; left_chan_id = pos + 1 ; } } while ( ! right_chan_id && chan_ids && * chan_ids ) if ( left_chan_id ) right_chan_id = * chan_ids ; else left_chan_id = * chan_ids ++ ; if ( ! left_chan_id ) left_chan_id = right_chan_id = 0xff ; else if ( ! right_chan_id ) right_chan_id = 0xff ; if ( num_chans >= 2 ) { if ( ( config -> flags & CONFIG_PAIR_UNDEF_CHANS ) && left_chan_id == 0xff && right_chan_id == 0xff ) chans = 2 ; else for ( i = 0 ; i < NUM_STEREO_PAIRS ; ++ i ) if ( ( left_chan_id == stereo_pairs [ i ] . a && right_chan_id == stereo_pairs [ i ] . b ) || ( left_chan_id == stereo_pairs [ i ] . b && right_chan_id == stereo_pairs [ i ] . a ) ) { if ( right_chan_id <= 32 && ( chan_mask & ( 1 << ( right_chan_id - 1 ) ) ) ) chan_mask &= ~ ( 1 << ( right_chan_id - 1 ) ) ; else if ( chan_ids && * chan_ids == right_chan_id ) chan_ids ++ ; chans = 2 ; break ; } } num_chans -= chans ; if ( num_chans && wpc -> current_stream == NEW_MAX_STREAMS - 1 ) break ; memcpy ( wps -> wphdr . ckID , ""wvpk"" , 4 ) ; wps -> wphdr . ckSize = sizeof ( WavpackHeader ) - 8 ; SET_TOTAL_SAMPLES ( wps -> wphdr , wpc -> total_samples ) ; wps -> wphdr . version = wpc -> stream_version ; wps -> wphdr . flags = flags ; wps -> bits = bps ; if ( ! wpc -> current_stream ) wps -> wphdr . flags |= INITIAL_BLOCK ; if ( ! num_chans ) wps -> wphdr . flags |= FINAL_BLOCK ; if ( chans == 1 ) { wps -> wphdr . flags &= ~ ( JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE ) ; wps -> wphdr . flags |= MONO_FLAG ; } } wpc -> num_streams = wpc -> current_stream ; wpc -> current_stream = 0 ; if ( num_chans ) { strcpy ( wpc -> error_message , ""too<S2SV_blank>many<S2SV_blank>channels!"" ) ; return FALSE ; } if ( config -> flags & CONFIG_EXTRA_MODE ) wpc -> config . xmode = config -> xmode ? config -> xmode : 1 ; return TRUE ; }","int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ; return FALSE ; }"
177,"static stmt_ty ast_for_funcdef ( struct compiling * c , const node * n , asdl_seq * decorator_seq ) { return ast_for_funcdef_impl ( c , n , decorator_seq , <S2SV_StartBug> 0 ) ; <S2SV_EndBug> }",", decorator_seq , false <S2SV_ModEnd> ) ; }"
178,"static void scsi_write_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; <S2SV_StartBug> uint32_t len ; <S2SV_EndBug> uint32_t n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_WRITE ) ) { return ; } } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } else { <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> if ( len > SCSI_DMA_BUF_SIZE ) { len = SCSI_DMA_BUF_SIZE ; } r -> iov . iov_len = len ; <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> } }",") ; uint32_t <S2SV_ModEnd> n ; if <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data <S2SV_ModStart> -> req , r -> qiov . size <S2SV_ModEnd> ) ; }"
179,"<S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> } return ( pixels ) ; }","const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * <S2SV_ModStart> j ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 <S2SV_ModStart> ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j <S2SV_ModStart> ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels"
180,"void vp8_create_common ( VP8_COMMON * oci ) { vp8_machine_specific_config ( oci ) ; vp8_init_mbmode_probs ( oci ) ; vp8_default_bmode_probs ( oci -> fc . bmode_prob ) ; oci -> mb_no_coeff_skip = 1 ; oci -> no_lpf = 0 ; oci -> filter_type = NORMAL_LOOPFILTER ; oci -> use_bilinear_mc_filter = 0 ; oci -> full_pixel = 0 ; oci -> multi_token_partition = ONE_PARTITION ; oci -> clamp_type = RECON_CLAMP_REQUIRED ; <S2SV_StartBug> vpx_memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ; <S2SV_EndBug> oci -> copy_buffer_to_gf = 0 ; oci -> copy_buffer_to_arf = 0 ; }",= RECON_CLAMP_REQUIRED ; memset <S2SV_ModEnd> ( oci ->
181,"void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; snapend_save = ndo -> ndo_snapend ; ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; <S2SV_StartBug> if ( ! ext_dp -> icmp_length ) { <S2SV_EndBug> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; <S2SV_StartBug> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <S2SV_EndBug> vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; <S2SV_StartBug> hlen -= 4 ; <S2SV_EndBug> obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }","ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> ) ) ; }"
182,"void jiffies_to_timespec ( const unsigned long jiffies , struct timespec * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> }","value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) <S2SV_ModStart> ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null>"
183,"void enc624j600UpdateMacConfig ( NetInterface * interface ) { uint16_t duplexMode ; <S2SV_StartBug> duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ; <S2SV_EndBug> if ( duplexMode ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug> } }","( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; }"
184,"GF_Err adts_dmx_process ( GF_Filter * filter ) { GF_ADTSDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u8 * data , * output ; u8 * start ; u32 pck_size , remain , prev_pck_size ; u64 cts = GF_FILTER_NO_TS ; if ( ! ctx -> duration . num ) adts_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> adts_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } } prev_pck_size = ctx -> adts_buffer_size ; if ( pck && ! ctx -> resume_from ) { data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; if ( ! pck_size ) { gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_OK ; } if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { u64 byte_offset = gf_filter_pck_get_byte_offset ( pck ) ; if ( ! ctx -> adts_buffer_size ) { ctx -> byte_offset = byte_offset ; } else if ( ctx -> byte_offset + ctx -> adts_buffer_size != byte_offset ) { ctx -> byte_offset = GF_FILTER_NO_BO ; if ( ( byte_offset != GF_FILTER_NO_BO ) && ( byte_offset > ctx -> adts_buffer_size ) ) { ctx -> byte_offset = byte_offset - ctx -> adts_buffer_size ; } } } if ( ctx -> adts_buffer_size + pck_size > ctx -> adts_buffer_alloc ) { ctx -> adts_buffer_alloc = ctx -> adts_buffer_size + pck_size ; ctx -> adts_buffer = gf_realloc ( ctx -> adts_buffer , ctx -> adts_buffer_alloc ) ; } memcpy ( ctx -> adts_buffer + ctx -> adts_buffer_size , data , pck_size ) ; ctx -> adts_buffer_size += pck_size ; } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } if ( cts == GF_FILTER_NO_TS ) { prev_pck_size = 0 ; } remain = ctx -> adts_buffer_size ; start = ctx -> adts_buffer ; if ( ctx -> resume_from ) { start += ctx -> resume_from - 1 ; remain -= ctx -> resume_from - 1 ; ctx -> resume_from = 0 ; } while ( remain ) { u8 * sync ; u32 sync_pos , size , offset , bytes_to_drop = 0 , nb_blocks_per_frame ; if ( ! ctx -> tag_size && ( remain > 3 ) ) { if ( start [ 0 ] == 'I' && start [ 1 ] == 'D' && start [ 2 ] == '3' ) { if ( remain < 10 ) return GF_OK ; ctx -> tag_size = ( ( start [ 9 ] & 0x7f ) + ( ( start [ 8 ] & 0x7f ) << 7 ) + ( ( start [ 7 ] & 0x7f ) << 14 ) + ( ( start [ 6 ] & 0x7f ) << 21 ) ) ; bytes_to_drop = 10 ; if ( ctx -> id3_buffer_alloc < ctx -> tag_size + 10 ) { ctx -> id3_buffer = gf_realloc ( ctx -> id3_buffer , ctx -> tag_size + 10 ) ; ctx -> id3_buffer_alloc = ctx -> tag_size + 10 ; } memcpy ( ctx -> id3_buffer , start , 10 ) ; ctx -> id3_buffer_size = 10 ; goto drop_byte ; } } if ( ctx -> tag_size ) { if ( ctx -> tag_size > remain ) { bytes_to_drop = remain ; ctx -> tag_size -= remain ; } else { bytes_to_drop = ctx -> tag_size ; ctx -> tag_size = 0 ; } memcpy ( ctx -> id3_buffer + ctx -> id3_buffer_size , start , bytes_to_drop ) ; ctx -> id3_buffer_size += bytes_to_drop ; if ( ! ctx -> tag_size && ctx -> opid ) { id3dmx_flush ( filter , ctx -> id3_buffer , ctx -> id3_buffer_size , ctx -> opid , ctx -> expart ? & ctx -> vpid : NULL ) ; ctx -> id3_buffer_size = 0 ; } goto drop_byte ; } sync = memchr ( start , 0xFF , remain ) ; sync_pos = ( u32 ) ( sync ? sync - start : remain ) ; if ( remain - sync_pos < 7 ) { break ; } if ( ( sync [ 1 ] & 0xF0 ) != 0xF0 ) { GF_LOG ( ctx -> nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>invalid<S2SV_blank>ADTS<S2SV_blank>sync<S2SV_blank>bytes,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } if ( ! ctx -> bs ) { ctx -> bs = gf_bs_new ( sync + 1 , remain - sync_pos - 1 , GF_BITSTREAM_READ ) ; } else { gf_bs_reassign_buffer ( ctx -> bs , sync + 1 , remain - sync_pos - 1 ) ; } gf_bs_read_int ( ctx -> bs , 4 ) ; ctx -> hdr . is_mp2 = ( Bool ) gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . is_mp2 = 0 ; gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . no_crc = ( Bool ) gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . profile = 1 + gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . sr_idx = gf_bs_read_int ( ctx -> bs , 4 ) ; gf_bs_read_int ( ctx -> bs , 1 ) ; ctx -> hdr . nb_ch = gf_bs_read_int ( ctx -> bs , 3 ) ; gf_bs_read_int ( ctx -> bs , 4 ) ; ctx -> hdr . frame_size = gf_bs_read_int ( ctx -> bs , 13 ) ; gf_bs_read_int ( ctx -> bs , 11 ) ; nb_blocks_per_frame = gf_bs_read_int ( ctx -> bs , 2 ) ; ctx -> hdr . hdr_size = 7 ; if ( ! ctx -> hdr . no_crc ) { u32 skip ; if ( ! nb_blocks_per_frame ) { skip = 2 ; } else { skip = 2 + 2 * nb_blocks_per_frame ; } ctx -> hdr . hdr_size += skip ; gf_bs_skip_bytes ( ctx -> bs , skip ) ; } if ( ! ctx -> hdr . frame_size || ! GF_M4ASampleRates [ ctx -> hdr . sr_idx ] ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Invalid<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } if ( ( nb_blocks_per_frame > 2 ) || ( nb_blocks_per_frame && ctx -> hdr . nb_ch ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Unsupported<S2SV_blank>multi-block<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header<S2SV_blank>-<S2SV_blank>patch<S2SV_blank>welcome\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } else if ( ! nb_blocks_per_frame ) { if ( ctx -> aacchcfg < 0 ) ctx -> hdr . nb_ch = - ctx -> aacchcfg ; else if ( ! ctx -> hdr . nb_ch ) ctx -> hdr . nb_ch = ctx -> aacchcfg ; if ( ! ctx -> hdr . nb_ch ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Missing<S2SV_blank>channel<S2SV_blank>configuration<S2SV_blank>in<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>defaulting<S2SV_blank>to<S2SV_blank>stereo<S2SV_blank>-<S2SV_blank>use<S2SV_blank>`--aacchcfg`<S2SV_blank>to<S2SV_blank>force<S2SV_blank>config\\n"" ) ) ; ctx -> hdr . nb_ch = ctx -> aacchcfg = 2 ; } } if ( nb_blocks_per_frame == 2 ) { u32 pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; gf_m4a_parse_program_config_element ( ctx -> bs , & ctx -> acfg ) ; if ( ! ctx -> hdr . no_crc ) gf_bs_skip_bytes ( ctx -> bs , 2 ) ; ctx -> hdr . hdr_size += ( u32 ) gf_bs_get_position ( ctx -> bs ) - pos ; } if ( ctx -> hdr . nb_ch == 7 ) ctx -> hdr . nb_ch = 8 ; if ( ctx -> hdr . frame_size + 1 < remain ) { u32 next_frame = ctx -> hdr . frame_size ; if ( ( sync [ next_frame ] != 0xFF ) || ( ( sync [ next_frame + 1 ] & 0xF0 ) != 0xF0 ) ) { GF_LOG ( ctx -> nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>invalid<S2SV_blank>next<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>sync,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } } else if ( pck ) { if ( ctx -> timescale && ! prev_pck_size && ( cts != GF_FILTER_NO_TS ) ) { ctx -> cts = cts ; } break ; } <S2SV_StartBug> adts_dmx_check_pid ( filter , ctx ) ; <S2SV_EndBug> if ( ! ctx -> is_playing ) { ctx -> resume_from = 1 + ctx -> adts_buffer_size - remain ; return GF_OK ; } ctx -> nb_frames ++ ; size = ctx -> hdr . frame_size - ctx -> hdr . hdr_size ; offset = ctx -> hdr . hdr_size ; if ( ( nb_blocks_per_frame == 2 ) && ! ctx -> hdr . no_crc ) size -= 2 ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } bytes_to_drop = ctx -> hdr . frame_size ; if ( ctx -> timescale && ! prev_pck_size && ( cts != GF_FILTER_NO_TS ) ) { ctx -> cts = cts ; cts = GF_FILTER_NO_TS ; } if ( ! ctx -> in_seek ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , sync + offset , size ) ; gf_filter_pck_set_dts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; gf_filter_pck_set_sap ( dst_pck , GF_FILTER_SAP_1 ) ; if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , ctx -> byte_offset + ctx -> hdr . hdr_size ) ; } gf_filter_pck_send ( dst_pck ) ; } adts_dmx_update_cts ( ctx ) ; if ( bytes_to_drop > remain ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>truncated<S2SV_blank>ADTS<S2SV_blank>frame!\\n"" ) ) ; bytes_to_drop = remain ; } drop_byte : if ( ! bytes_to_drop ) { bytes_to_drop = 1 ; } start += bytes_to_drop ; remain -= bytes_to_drop ; if ( prev_pck_size ) { if ( prev_pck_size > bytes_to_drop ) prev_pck_size -= bytes_to_drop ; else { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } if ( ctx -> byte_offset != GF_FILTER_NO_BO ) ctx -> byte_offset += bytes_to_drop ; } if ( ! pck ) { ctx -> adts_buffer_size = 0 ; return adts_dmx_process ( filter ) ; } else { if ( remain ) { memmove ( ctx -> adts_buffer , start , remain ) ; } ctx -> adts_buffer_size = remain ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; } return GF_OK ; }","break ; } if ( ctx -> hdr . frame_size < ctx -> hdr . hdr_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Corrupted<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; }"
185,"<S2SV_StartBug> void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; int correction_factor = 100 ; double rate_correction_factor = get_rate_correction_factor ( cpi ) ; double adjustment_limit ; int projected_size_based_on_q = 0 ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> projected_size_based_on_q = estimate_bits_at_q ( cm -> frame_type , cm -> base_qindex , cm -> MBs , <S2SV_StartBug> rate_correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( projected_size_based_on_q > 0 ) <S2SV_EndBug> correction_factor = ( 100 * cpi -> rc . projected_frame_size ) / projected_size_based_on_q ; switch ( damp_var ) { case 0 : adjustment_limit = 0.75 ; break ; case 1 : adjustment_limit = 0.375 ; break ; case 2 : default : adjustment_limit = 0.25 ; break ; } if ( correction_factor > 102 ) { correction_factor = ( int ) ( 100 + ( ( correction_factor - 100 ) * adjustment_limit ) ) ; rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ; if ( rate_correction_factor > MAX_BPB_FACTOR ) rate_correction_factor = MAX_BPB_FACTOR ; } else if ( correction_factor < 99 ) { correction_factor = ( int ) ( 100 - ( ( 100 - correction_factor ) * adjustment_limit ) ) ; rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ; if ( rate_correction_factor < MIN_BPB_FACTOR ) rate_correction_factor = MIN_BPB_FACTOR ; } set_rate_correction_factor ( cpi , rate_correction_factor ) ; }","VP9_COMP * cpi <S2SV_ModEnd> ) { const <S2SV_ModStart> = 0 ; if ( cpi -> rc . is_src_frame_alt_ref ) return ; vpx_clear_system_state ( ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) { projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ; } else { projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . <S2SV_ModEnd> frame_type , cm <S2SV_ModStart> MBs , rate_correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( projected_size_based_on_q <S2SV_ModStart> ( projected_size_based_on_q > FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ; adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ; cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ; cpi -> rc . q_1_frame = cm -> base_qindex ; cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ; if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ; else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ; else cpi -> rc . rc_1_frame = 0 ; <S2SV_ModEnd> if ( correction_factor"
186,"void interprete ( char * lbook , char * path ) { int status , i , j , n , message_id , inactive ; char list [ 1000 ] , section [ 256 ] , str [ NAME_LENGTH ] , str1 [ NAME_LENGTH ] , str2 [ NAME_LENGTH ] , edit_id [ 80 ] , file_name [ 256 ] , command [ 256 ] , enc_path [ 256 ] , dec_path [ 256 ] , uname [ 80 ] , full_name [ 256 ] , user_email [ 256 ] , logbook [ 256 ] , logbook_enc [ 256 ] , * experiment , group [ 256 ] , css [ 256 ] , * pfile , attachment [ MAX_PATH_LENGTH ] , str3 [ NAME_LENGTH ] , thumb_name [ 256 ] , sid [ 32 ] , error_str [ 256 ] , subdir [ 256 ] , * s ; LOGBOOK * lbs ; FILE * f ; strcpy ( dec_path , path ) ; url_decode ( dec_path ) ; strcpy ( enc_path , dec_path ) ; url_encode ( enc_path , sizeof ( enc_path ) ) ; strencode2 ( command , isparam ( ""cmd"" ) ? getparam ( ""cmd"" ) : """" , sizeof ( command ) ) ; strencode2 ( group , isparam ( ""group"" ) ? getparam ( ""group"" ) : """" , sizeof ( group ) ) ; experiment = getparam ( ""exp"" ) ; if ( getcfg ( lbook , ""Logging<S2SV_blank>Level"" , str , sizeof ( str ) ) ) _logging_level = atoi ( str ) ; else _logging_level = 2 ; set_condition ( """" ) ; message_id = atoi ( dec_path ) ; if ( isparam ( ""jcmd"" ) && * getparam ( ""jcmd"" ) ) strlcpy ( command , getparam ( ""jcmd"" ) , sizeof ( command ) ) ; if ( stricmp ( command , ""loc"" ) == 0 ) { show_http_header ( NULL , FALSE , NULL ) ; <S2SV_StartBug> if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) <S2SV_EndBug> <S2SV_StartBug> rsputs ( loc ( getparam ( ""value"" ) ) ) ; <S2SV_EndBug> s = loc ( ""Drop<S2SV_blank>attachments<S2SV_blank>here..."" ) ; s = loc ( ""Insert<S2SV_blank>Timestamp"" ) ; if ( s ) s = NULL ; return ; } if ( experiment && experiment [ 0 ] ) { strcpy ( logbook_enc , experiment ) ; strcpy ( logbook , experiment ) ; url_decode ( logbook ) ; for ( i = 0 ; ; i ++ ) { if ( ! enumgrp ( i , str ) ) break ; if ( strieq ( logbook , str ) ) break ; } if ( ! strieq ( logbook , str ) ) { sprintf ( str , ""Error:<S2SV_blank>logbook<S2SV_blank>\\""%s\\""<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>in<S2SV_blank>%s"" , logbook_enc , CFGFILE ) ; show_error ( str ) ; return ; } } else { strcpy ( logbook_enc , lbook ) ; strcpy ( logbook , lbook ) ; url_decode ( logbook ) ; } setcfg_topgroup ( """" ) ; sprintf ( str , ""Top<S2SV_blank>group<S2SV_blank>%s"" , logbook ) ; if ( getcfg ( ""global"" , str , list , sizeof ( list ) ) ) { setcfg_topgroup ( logbook ) ; logbook [ 0 ] = 0 ; } for ( i = j = 0 ; ; i ++ ) { if ( ! enumgrp ( i , str ) ) break ; if ( is_logbook ( str ) ) { if ( ! strieq ( str , lb_list [ j ++ ] . name ) ) { el_index_logbooks ( ) ; break ; } } } if ( lb_list [ j ] . name [ 0 ] != 0 ) el_index_logbooks ( ) ; if ( ! logbook [ 0 ] ) { if ( getcfg ( group , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) && atoi ( str ) > 0 ) { if ( ! do_self_register ( NULL , getparam ( ""cmd"" ) ) ) return ; } if ( strieq ( command , loc ( ""Activate"" ) ) && isparam ( ""new_user_name"" ) && isparam ( ""code"" ) ) { if ( ! activate_user ( NULL , getparam ( ""new_user_name"" ) , atoi ( getparam ( ""code"" ) ) ) ) return ; setparam ( ""cfg_user"" , getparam ( ""new_user_name"" ) ) ; get_user_line ( NULL , getparam ( ""new_user_name"" ) , NULL , full_name , user_email , NULL , NULL , NULL ) ; sprintf ( str , ""%s<S2SV_blank><b>&lt;%s&gt;</b>"" , full_name , user_email ) ; sprintf ( str2 , loc ( ""Activation<S2SV_blank>notice<S2SV_blank>has<S2SV_blank>been<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>%s"" ) , str ) ; setparam ( ""notice"" , str2 ) ; show_config_page ( NULL ) ; return ; } if ( strieq ( command , loc ( ""Save"" ) ) ) { if ( isparam ( ""config"" ) ) { if ( ! isparam ( ""config"" ) || ! save_user_config ( NULL , getparam ( ""config"" ) , FALSE ) ) return ; } redirect ( NULL , ""."" ) ; return ; } if ( isparam ( ""cmd"" ) || isparam ( ""newpwd"" ) ) { if ( isparam ( ""newpwd"" ) || strieq ( command , loc ( ""Change<S2SV_blank>password"" ) ) ) { if ( sid_check ( getparam ( ""sid"" ) , uname ) ) setparam ( ""unm"" , uname ) ; show_change_pwd_page ( NULL ) ; return ; } } if ( isparam ( ""uname"" ) && isparam ( ""upassword"" ) ) { strlcpy ( uname , getparam ( ""uname"" ) , sizeof ( uname ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(attempt)<S2SV_blank>for<S2SV_blank>logbook<S2SV_blank>selection<S2SV_blank>page"" , uname ) ; write_logfile ( NULL , str ) ; if ( isparam ( ""redir"" ) ) strlcpy ( str , getparam ( ""redir"" ) , sizeof ( str ) ) ; else strlcpy ( str , isparam ( ""cmdline"" ) ? getparam ( ""cmdline"" ) : """" , sizeof ( str ) ) ; if ( ! auth_verify_password ( NULL , uname , getparam ( ""upassword"" ) , error_str , sizeof ( error_str ) ) ) { if ( error_str [ 0 ] ) show_error ( error_str ) ; else show_login_page ( NULL , str , 1 ) ; return ; } if ( get_user_line ( NULL , uname , NULL , full_name , NULL , NULL , NULL , NULL ) == 2 ) { if ( ! getcfg ( group , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) || atoi ( str ) == 0 ) { show_login_page ( NULL , str , 1 ) ; return ; } # ifdef HAVE_PAM getcfg ( NULL , ""Authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""PAM"" ) ) { show_new_user_page ( NULL , uname ) ; return ; } # endif } set_user_password ( NULL , uname , getparam ( ""upassword"" ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(success)"" , uname ) ; write_logfile ( NULL , str ) ; sid_new ( NULL , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( NULL , sid , full_name ) ; return ; } if ( ! logbook [ 0 ] && getcfg ( ""global"" , ""Selection<S2SV_blank>page"" , str , sizeof ( str ) ) ) { if ( strstr ( str , ""http://"" ) || strstr ( str , ""https://"" ) ) { redirect ( NULL , str ) ; return ; } if ( str [ 0 ] == DIR_SEPARATOR || str [ 1 ] == ':' ) strlcpy ( file_name , str , sizeof ( file_name ) ) ; else { strlcpy ( file_name , logbook_dir , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } send_file_direct ( file_name ) ; return ; } if ( strieq ( command , ""Synchronize"" ) ) { synchronize ( NULL , SYNC_HTML ) ; return ; } } for ( n = 0 ; lb_list [ n ] . name [ 0 ] ; n ++ ) ; if ( ! logbook [ 0 ] && ! path [ 0 ] ) { if ( n > 1 ) { if ( strieq ( command , loc ( ""Forgot"" ) ) ) { show_forgot_pwd_page ( NULL ) ; return ; } show_selection_page ( ) ; return ; } strcpy ( logbook , lb_list [ 0 ] . name ) ; strcpy ( logbook_enc , logbook ) ; url_encode ( logbook_enc , sizeof ( logbook_enc ) ) ; } for ( i = 0 ; lb_list [ i ] . name [ 0 ] ; i ++ ) if ( strieq ( logbook , lb_list [ i ] . name ) ) break ; lbs = & lb_list [ i ] ; if ( lbs -> top_group [ 0 ] ) setcfg_topgroup ( lbs -> top_group ) ; if ( getcfg ( logbook , ""Theme"" , str , sizeof ( str ) ) ) strlcpy ( theme_name , str , sizeof ( theme_name ) ) ; else strlcpy ( theme_name , ""default"" , sizeof ( theme_name ) ) ; lbs = lb_list + i ; lbs -> n_attr = scan_attributes ( lbs -> name ) ; if ( lbs -> n_attr < 0 ) return ; if ( isparam ( ""acmd"" ) && * getparam ( ""acmd"" ) ) { if ( strieq ( getparam ( ""acmd"" ) , ""Upload"" ) ) show_uploader_json ( lbs ) ; return ; } getcfg ( lbs -> name , ""Authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""Webserver"" ) ) { if ( http_user [ 0 ] ) { if ( ! sid_check ( getparam ( ""sid"" ) , http_user ) ) { sid_new ( lbs , http_user , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( lbs , sid , http_user ) ; } } else { sprintf ( str , ""Error:<S2SV_blank>Misconfigured<S2SV_blank>webserver,<S2SV_blank>did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>X-Forwarded-User<S2SV_blank>from<S2SV_blank>it."" ) ; show_error ( str ) ; return ; } } if ( isparam ( ""uname"" ) && isparam ( ""upassword"" ) ) { strlcpy ( uname , getparam ( ""uname"" ) , sizeof ( uname ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(attempt)"" , uname ) ; write_logfile ( lbs , str ) ; if ( isparam ( ""redir"" ) ) strlcpy ( str , getparam ( ""redir"" ) , sizeof ( str ) ) ; else strlcpy ( str , isparam ( ""cmdline"" ) ? getparam ( ""cmdline"" ) : """" , sizeof ( str ) ) ; if ( ! auth_verify_password ( lbs , uname , getparam ( ""upassword"" ) , error_str , sizeof ( error_str ) ) ) { if ( error_str [ 0 ] ) show_error ( error_str ) ; else show_login_page ( lbs , str , 1 ) ; return ; } if ( get_user_line ( lbs , uname , NULL , full_name , NULL , NULL , NULL , & inactive ) == 2 ) { if ( ! getcfg ( lbs -> name , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) || atoi ( str ) == 0 ) { show_login_page ( lbs , str , 1 ) ; return ; } # ifdef HAVE_PAM getcfg ( lbs -> name , ""Authentication"" , str , sizeof ( str ) ) ; if ( stristr ( str , ""PAM"" ) ) { show_new_user_page ( lbs , uname ) ; return ; } # endif } if ( inactive ) { show_error ( ""This<S2SV_blank>account<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>deactivated"" ) ; return ; } if ( ! check_login_user ( lbs , getparam ( ""uname"" ) ) ) { show_error ( ""User<S2SV_blank>has<S2SV_blank>no<S2SV_blank>access<S2SV_blank>to<S2SV_blank>this<S2SV_blank>logbook"" ) ; return ; } set_user_password ( lbs , uname , getparam ( ""upassword"" ) ) ; sprintf ( str , ""LOGIN<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(success)"" , uname ) ; write_logfile ( lbs , str ) ; sid_new ( lbs , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; set_sid_cookie ( lbs , sid , full_name ) ; return ; } if ( chkext ( path , "".gif"" ) || chkext ( path , "".jpg"" ) || chkext ( path , "".png"" ) || chkext ( path , "".ico"" ) || chkext ( path , "".htm"" ) || chkext ( path , "".css"" ) ) { strlcpy ( str , resource_dir , sizeof ( str ) ) ; strlcat ( str , path , sizeof ( str ) ) ; if ( exist_file ( str ) ) { send_file_direct ( str ) ; return ; } else { strlcpy ( str , resource_dir , sizeof ( str ) ) ; strlcat ( str , ""themes"" , sizeof ( str ) ) ; strlcat ( str , DIR_SEPARATOR_STR , sizeof ( str ) ) ; strlcat ( str , theme_name , sizeof ( str ) ) ; strlcat ( str , DIR_SEPARATOR_STR , sizeof ( str ) ) ; strlcat ( str , path , sizeof ( str ) ) ; if ( exist_file ( str ) ) { send_file_direct ( str ) ; return ; } } } if ( ! logbook [ 0 ] ) { strencode2 ( str2 , path , sizeof ( str2 ) ) ; sprintf ( str , ""%s:<S2SV_blank><b>%s</b>"" , loc ( ""Invalid<S2SV_blank>URL"" ) , str2 ) ; show_error ( str ) ; return ; } if ( strieq ( command , loc ( ""Activate"" ) ) && isparam ( ""unm"" ) && isparam ( ""code"" ) && ! isparam ( ""new_user_name"" ) ) { strlcpy ( uname , getparam ( ""unm"" ) , sizeof ( uname ) ) ; if ( ! activate_user ( lbs , uname , atoi ( getparam ( ""code"" ) ) ) ) return ; sprintf ( str , ""ACTIVATE<S2SV_blank>user<S2SV_blank>\\""%s\\""<S2SV_blank>(success)"" , uname ) ; write_logfile ( lbs , str ) ; sid_new ( lbs , uname , ( char * ) inet_ntoa ( rem_addr ) , sid ) ; sprintf ( str , ""?cmd=%s&notice=%s.<S2SV_blank>%s"" , loc ( ""Config"" ) , loc ( ""Your<S2SV_blank>account<S2SV_blank>has<S2SV_blank>been<S2SV_blank>activated"" ) , loc ( ""Please<S2SV_blank>subscribe<S2SV_blank>to<S2SV_blank>logbooks<S2SV_blank>if<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>automatic<S2SV_blank>email<S2SV_blank>notifications"" ) ) ; setparam ( ""redir"" , str ) ; set_sid_cookie ( lbs , sid , uname ) ; return ; } # ifdef HAVE_PAM if ( strieq ( command , loc ( ""Save"" ) ) && isparam ( ""new_user_name"" ) && ! isparam ( ""config"" ) ) { save_user_config ( NULL , getparam ( ""new_user_name"" ) , 1 ) ; redirect ( lbs , """" ) ; check_login ( lbs , NULL ) ; return ; } # endif if ( getcfg ( lbs -> name , ""Password<S2SV_blank>file"" , str , sizeof ( str ) ) ) { strlcpy ( css , ""elog.css"" , sizeof ( css ) ) ; if ( lbs != NULL && getcfg ( lbs -> name , ""CSS"" , str , sizeof ( str ) ) ) strlcpy ( css , str , sizeof ( css ) ) ; else if ( lbs == NULL && getcfg ( ""global"" , ""CSS"" , str , sizeof ( str ) ) ) strlcpy ( css , str , sizeof ( css ) ) ; if ( getcfg ( lbs -> name , ""Guest<S2SV_blank>menu<S2SV_blank>commands"" , str , sizeof ( str ) ) ) { if ( sid_check ( getparam ( ""sid"" ) , uname ) ) setparam ( ""unm"" , uname ) ; } if ( uname [ 0 ] && ! isparam ( ""new_user_name"" ) ) { if ( ! set_user_login_time ( lbs , uname ) ) { show_error ( loc ( ""File<S2SV_blank>system<S2SV_blank>full,<S2SV_blank>ELOG<S2SV_blank>cannot<S2SV_blank>continue<S2SV_blank>to<S2SV_blank>work"" ) ) ; return ; } } if ( ! ( getcfg ( lbs -> name , ""Guest<S2SV_blank>menu<S2SV_blank>commands"" , str , sizeof ( str ) ) && ! isparam ( ""fail"" ) ) ) { if ( strcmp ( path , css ) != 0 ) { if ( getcfg ( lbs -> name , ""Self<S2SV_blank>register"" , str , sizeof ( str ) ) && atoi ( str ) > 0 ) { if ( ! do_self_register ( lbs , command ) ) return ; } if ( ! check_login ( lbs , getparam ( ""sid"" ) ) ) return ; } } } if ( strieq ( command , loc ( ""Login"" ) ) ) { check_login ( lbs , """" ) ; return ; } if ( strieq ( command , loc ( ""New"" ) ) || strieq ( command , loc ( ""Edit"" ) ) || strieq ( command , loc ( ""Reply"" ) ) || strieq ( command , loc ( ""Duplicate"" ) ) || strieq ( command , loc ( ""Delete"" ) ) || strieq ( command , loc ( ""Upload"" ) ) || strieq ( command , loc ( ""Submit"" ) ) || strieq ( command , loc ( ""Preview"" ) ) ) { sprintf ( str , ""%s?cmd=%s"" , path , command ) ; } if ( strieq ( command , loc ( ""Delete"" ) ) || strieq ( command , loc ( ""Config"" ) ) || strieq ( command , loc ( ""Copy<S2SV_blank>to"" ) ) || strieq ( command , loc ( ""Move<S2SV_blank>to"" ) ) ) { sprintf ( str , ""%s?cmd=%s"" , path , command ) ; } if ( strieq ( command , loc ( ""Back"" ) ) ) { if ( isparam ( ""edit_id"" ) ) { el_lock_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , NULL , FALSE ) ; el_draft_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , NULL , FALSE ) ; strlcpy ( edit_id , getparam ( ""edit_id"" ) , sizeof ( edit_id ) ) ; sprintf ( str , ""../%s/%s"" , logbook_enc , edit_id ) ; } else sprintf ( str , ""../%s/"" , logbook_enc ) ; if ( getcfg ( lbs -> name , ""Back<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) strcpy ( str , ""../"" ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , ""XDelete"" ) ) { if ( getparam ( ""edit_id"" ) ) { status = el_delete_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , TRUE , NULL , TRUE , TRUE ) ; if ( status != EL_SUCCESS ) { sprintf ( str , ""%s<S2SV_blank>=<S2SV_blank>%d"" , loc ( ""Error<S2SV_blank>deleting<S2SV_blank>message:<S2SV_blank>status"" ) , status ) ; show_error ( str ) ; return ; } } redirect ( lbs , """" ) ; return ; } if ( strieq ( command , ""Unlock"" ) ) { if ( isparam ( ""edit_id"" ) ) { el_lock_message ( lbs , atoi ( getparam ( ""edit_id"" ) ) , NULL , FALSE ) ; strlcpy ( edit_id , getparam ( ""edit_id"" ) , sizeof ( edit_id ) ) ; sprintf ( str , ""../%s/%s"" , logbook_enc , edit_id ) ; } else sprintf ( str , ""../%s/"" , logbook_enc ) ; if ( getcfg ( lbs -> name , ""Back<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) strcpy ( str , ""../"" ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , loc ( ""List"" ) ) ) { if ( getcfg ( lbs -> name , ""Back<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) { redirect ( lbs , ""../"" ) ; return ; } show_elog_list ( lbs , 0 , 0 , 0 , TRUE , NULL ) ; return ; } if ( strieq ( command , loc ( ""Cancel"" ) ) ) { sprintf ( str , ""../%s/%s"" , logbook_enc , path ) ; redirect ( lbs , str ) ; return ; } strlcpy ( str , isparam ( ""last"" ) ? getparam ( ""last"" ) : """" , sizeof ( str ) ) ; if ( strchr ( str , '<S2SV_blank>' ) ) { i = atoi ( strchr ( str , '<S2SV_blank>' ) ) ; sprintf ( str , ""last%d"" , i ) ; if ( isparam ( ""mode"" ) ) { sprintf ( str + strlen ( str ) , ""?mode="" ) ; strlcat ( str , getparam ( ""mode"" ) , sizeof ( str ) ) ; } redirect ( lbs , str ) ; return ; } strlcpy ( str , isparam ( ""past"" ) ? getparam ( ""past"" ) : """" , sizeof ( str ) ) ; if ( strchr ( str , '<S2SV_blank>' ) ) { i = atoi ( strchr ( str , '<S2SV_blank>' ) ) ; sprintf ( str , ""past%d"" , i ) ; redirect ( lbs , str ) ; return ; } if ( strncmp ( path , ""past"" , 4 ) == 0 && ( isdigit ( path [ 4 ] ) || isdigit ( path [ 5 ] ) ) && isparam ( ""cmd"" ) == 0 ) { show_elog_list ( lbs , atoi ( path + 4 ) , 0 , 0 , FALSE , NULL ) ; return ; } if ( strncmp ( path , ""last"" , 4 ) == 0 && ! chkext ( path , "".png"" ) && ( ! isparam ( ""cmd"" ) || strieq ( getparam ( ""cmd"" ) , loc ( ""Select"" ) ) ) && ! isparam ( ""newpwd"" ) && atoi ( path + 4 ) > 0 ) { show_elog_list ( lbs , 0 , atoi ( path + 4 ) , 0 , FALSE , NULL ) ; return ; } if ( strncmp ( path , ""page"" , 4 ) == 0 && isparam ( ""cmd"" ) == 0 ) { if ( ! path [ 4 ] ) show_elog_list ( lbs , 0 , 0 , - 1 , FALSE , NULL ) ; else show_elog_list ( lbs , 0 , 0 , atoi ( path + 4 ) , FALSE , NULL ) ; return ; } if ( strieq ( dec_path , ""cal.html"" ) ) { show_calendar ( lbs ) ; return ; } if ( strieq ( dec_path , ""elog.rdf"" ) ) { show_rss_feed ( lbs ) ; return ; } if ( strieq ( dec_path , ""upload.html"" ) ) { show_uploader ( lbs ) ; return ; } if ( isparam ( ""jcmd"" ) && isparam ( ""jcmd"" ) && strieq ( getparam ( ""jcmd"" ) , ""JUpload"" ) ) { show_uploader_finished ( lbs ) ; return ; } pfile = dec_path ; if ( strchr ( pfile , '/' ) && pfile [ 13 ] != '/' && isdigit ( pfile [ 0 ] ) ) pfile = strchr ( pfile , '/' ) + 1 ; if ( ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '_' ) || ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '/' ) || chkext ( pfile , "".gif"" ) || chkext ( pfile , "".ico"" ) || chkext ( pfile , "".jpg"" ) || chkext ( pfile , "".jpeg"" ) || chkext ( pfile , "".png"" ) || chkext ( pfile , "".css"" ) || chkext ( pfile , "".js"" ) || chkext ( pfile , "".html"" ) ) { if ( ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '_' ) || ( strlen ( pfile ) > 13 && pfile [ 6 ] == '_' && pfile [ 13 ] == '/' ) ) { if ( pfile [ 13 ] == '/' ) pfile [ 13 ] = '_' ; strlcpy ( file_name , lbs -> data_dir , sizeof ( file_name ) ) ; generate_subdir_name ( pfile , subdir , sizeof ( subdir ) ) ; strlcat ( file_name , subdir , sizeof ( file_name ) ) ; strlcat ( file_name , pfile , sizeof ( file_name ) ) ; } else { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; if ( file_name [ 0 ] && file_name [ strlen ( file_name ) - 1 ] != DIR_SEPARATOR ) strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , ""themes"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; if ( theme_name [ 0 ] ) { strlcat ( file_name , theme_name , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; } strlcat ( file_name , pfile , sizeof ( file_name ) ) ; } if ( isparam ( ""thumb"" ) ) { get_thumb_name ( file_name , thumb_name , sizeof ( thumb_name ) , 0 ) ; if ( thumb_name [ 0 ] ) send_file_direct ( thumb_name ) ; else send_file_direct ( file_name ) ; } else send_file_direct ( file_name ) ; return ; } if ( ! logbook [ 0 ] ) { show_selection_page ( ) ; return ; } if ( strchr ( dec_path , '/' ) ) { message_id = atoi ( dec_path ) ; n = atoi ( strchr ( dec_path , '/' ) + 1 ) - 1 ; status = el_retrieve_attachment ( lbs , message_id , n , attachment ) ; if ( status != EL_SUCCESS || n >= MAX_ATTACHMENTS ) { sprintf ( str , ""Attachment<S2SV_blank>#%d<S2SV_blank>of<S2SV_blank>entry<S2SV_blank>#%d<S2SV_blank>not<S2SV_blank>found"" , n + 1 , message_id ) ; show_error ( str ) ; } else { if ( isparam ( ""thumb"" ) ) strlcat ( attachment , ""?thumb=1"" , sizeof ( attachment ) ) ; redirect ( lbs , attachment ) ; } return ; } if ( getcfg ( lbs -> name , ""Types"" , str , sizeof ( str ) ) ) { show_upgrade_page ( lbs ) ; return ; } if ( isparam ( ""cmd_first.x"" ) ) strcpy ( command , loc ( ""First"" ) ) ; if ( isparam ( ""cmd_previous.x"" ) ) strcpy ( command , loc ( ""Previous"" ) ) ; if ( isparam ( ""cmd_next.x"" ) ) strcpy ( command , loc ( ""Next"" ) ) ; if ( isparam ( ""cmd_last.x"" ) ) strcpy ( command , loc ( ""Last"" ) ) ; if ( command [ 0 ] && ! is_user_allowed ( lbs , command ) ) { if ( isparam ( ""uname"" ) ) get_full_name ( lbs , getparam ( ""uname"" ) , full_name ) ; else full_name [ 0 ] = 0 ; strencode2 ( str2 , command , sizeof ( str2 ) ) ; strencode2 ( str3 , full_name , sizeof ( str3 ) ) ; sprintf ( str , loc ( ""Error:<S2SV_blank>Command<S2SV_blank>\\""<b>%s</b>\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\\""<b>%s</b>\\"""" ) , str2 , str3 ) ; show_error ( str ) ; return ; } if ( ! is_command_allowed ( lbs , command , message_id ) ) { if ( strieq ( command , loc ( ""New"" ) ) && ! isparam ( ""unm"" ) ) { show_login_page ( lbs , _cmdline , 0 ) ; return ; } strencode2 ( str2 , command , sizeof ( str3 ) ) ; sprintf ( str , loc ( ""Error:<S2SV_blank>Command<S2SV_blank>\\""<b>%s</b>\\""<S2SV_blank>not<S2SV_blank>allowed"" ) , str2 ) ; show_error ( str ) ; return ; } if ( strieq ( command , loc ( ""Help"" ) ) ) { if ( getcfg ( lbs -> name , ""Help<S2SV_blank>URL"" , str , sizeof ( str ) ) ) { if ( strstr ( str , ""http://"" ) || strstr ( str , ""https://"" ) ) { redirect ( lbs , str ) ; return ; } strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == NULL ) { sprintf ( str , ""Cannot<S2SV_blank>find<S2SV_blank>file<S2SV_blank>\\""%s\\"""" , file_name ) ; show_error ( str ) ; } else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , ""eloghelp_"" , sizeof ( file_name ) ) ; if ( getcfg ( ""global"" , ""Language"" , str , sizeof ( str ) ) ) { for ( i = 0 ; i < ( int ) strlen ( str ) ; i ++ ) str [ i ] = my_tolower ( str [ i ] ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } else strlcat ( file_name , ""english"" , sizeof ( file_name ) ) ; strlcat ( file_name , "".html"" , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == NULL ) redirect ( lbs , ""https://elog.psi.ch/elog/eloghelp_english.html"" ) ; else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } if ( strieq ( command , loc ( ""HelpELCode"" ) ) ) { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , ""resources"" , sizeof ( file_name ) ) ; strlcat ( file_name , DIR_SEPARATOR_STR , sizeof ( file_name ) ) ; strlcat ( file_name , ""elcode_"" , sizeof ( file_name ) ) ; if ( getcfg ( ""global"" , ""Language"" , str , sizeof ( str ) ) ) { for ( i = 0 ; i < ( int ) strlen ( str ) ; i ++ ) str [ i ] = my_tolower ( str [ i ] ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } else strlcat ( file_name , ""english"" , sizeof ( file_name ) ) ; strlcat ( file_name , "".html"" , sizeof ( file_name ) ) ; f = fopen ( file_name , ""r"" ) ; if ( f == NULL ) redirect ( lbs , ""https://elog.psi.ch/elog/elcode_english.html"" ) ; else { fclose ( f ) ; send_file_direct ( file_name ) ; } return ; } if ( strieq ( command , loc ( ""New"" ) ) ) { if ( check_drafts ( lbs ) ) return ; show_edit_form ( lbs , 0 , FALSE , FALSE , FALSE , FALSE , FALSE , FALSE ) ; return ; } for ( i = 0 ; i < MAX_ATTACHMENTS ; i ++ ) { sprintf ( str , ""delatt%d"" , i ) ; if ( isparam ( str ) || ( isparam ( ""smcmd"" ) && stricmp ( getparam ( ""smcmd"" ) , str ) == 0 ) ) { sprintf ( str , ""attachment%d"" , i ) ; strlcpy ( file_name , getparam ( str ) , sizeof ( file_name ) ) ; el_delete_attachment ( lbs , file_name ) ; for ( j = i ; j < MAX_ATTACHMENTS ; j ++ ) { sprintf ( str , ""attachment%d"" , j + 1 ) ; if ( isparam ( str ) ) strlcpy ( file_name , getparam ( str ) , sizeof ( file_name ) ) ; else file_name [ 0 ] = 0 ; sprintf ( str , ""attachment%d"" , j ) ; if ( file_name [ 0 ] ) setparam ( str , file_name ) ; else unsetparam ( str ) ; } show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , TRUE , FALSE , FALSE , FALSE ) ; return ; } } if ( strieq ( command , loc ( ""Upload"" ) ) || strieq ( command , ""Upload"" ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , TRUE , FALSE , FALSE , FALSE ) ; return ; } if ( strieq ( command , loc ( ""Edit"" ) ) ) { if ( message_id ) { show_edit_form ( lbs , message_id , FALSE , TRUE , FALSE , FALSE , FALSE , FALSE ) ; return ; } else if ( isparam ( ""nsel"" ) ) { show_edit_form ( lbs , 0 , FALSE , TRUE , FALSE , FALSE , FALSE , FALSE ) ; return ; } } if ( strieq ( command , loc ( ""Reply"" ) ) ) { show_edit_form ( lbs , message_id , TRUE , FALSE , FALSE , FALSE , FALSE , FALSE ) ; return ; } if ( strieq ( command , loc ( ""Update"" ) ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , FALSE , TRUE , FALSE , FALSE ) ; return ; } if ( ( strieq ( command , loc ( ""Save"" ) ) || strieq ( command , ""Save"" ) ) && ! isparam ( ""cfgpage"" ) && ! isparam ( ""new_user_name"" ) ) { if ( isparam ( ""unm"" ) ) strlcpy ( str , getparam ( ""unm"" ) , sizeof ( str ) ) ; else strlcpy ( str , loc ( ""user"" ) , sizeof ( str ) ) ; setparam ( ""draft"" , str ) ; submit_elog ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Duplicate"" ) ) ) { if ( message_id ) { show_edit_form ( lbs , message_id , FALSE , FALSE , FALSE , FALSE , TRUE , FALSE ) ; return ; } } if ( strieq ( command , loc ( ""Preview"" ) ) ) { show_edit_form ( lbs , isparam ( ""edit_id"" ) ? atoi ( getparam ( ""edit_id"" ) ) : 0 , FALSE , TRUE , FALSE , TRUE , FALSE , TRUE ) ; return ; } if ( strieq ( command , loc ( ""Submit"" ) ) || strieq ( command , ""Submit"" ) ) { if ( isparam ( ""mirror_id"" ) ) submit_elog_mirror ( lbs ) ; else submit_elog ( lbs ) ; if ( isparam ( ""sidclose"" ) ) sid_remove ( getparam ( ""sid"" ) ) ; return ; } if ( strieq ( command , loc ( ""Find"" ) ) ) { if ( dec_path [ 0 ] ) { sprintf ( str , ""../%s/?cmd=%s"" , lbs -> name_enc , loc ( ""Find"" ) ) ; redirect ( lbs , str ) ; return ; } show_find_form ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Search"" ) ) ) { if ( dec_path [ 0 ] && atoi ( dec_path ) == 0 && strchr ( dec_path , '/' ) != NULL ) { strencode2 ( str2 , dec_path , sizeof ( str2 ) ) ; sprintf ( str , ""%s:<S2SV_blank><b>%s</b>"" , loc ( ""Invalid<S2SV_blank>URL"" ) , str2 ) ; show_error ( str ) ; return ; } show_elog_list ( lbs , 0 , 0 , 0 , TRUE , NULL ) ; return ; } if ( strieq ( command , loc ( ""Last<S2SV_blank>day"" ) ) ) { redirect ( lbs , ""past1"" ) ; return ; } if ( strieq ( command , loc ( ""Last<S2SV_blank>10"" ) ) ) { redirect ( lbs , ""last10"" ) ; return ; } if ( strieq ( command , loc ( ""Copy<S2SV_blank>to"" ) ) ) { copy_to ( lbs , message_id , isparam ( ""destc"" ) ? getparam ( ""destc"" ) : """" , 0 , 0 ) ; return ; } if ( strieq ( command , loc ( ""Move<S2SV_blank>to"" ) ) ) { copy_to ( lbs , message_id , isparam ( ""destm"" ) ? getparam ( ""destm"" ) : """" , 1 , 0 ) ; return ; } if ( strieq ( command , loc ( ""Admin"" ) ) || strieq ( command , loc ( ""Change<S2SV_blank>config<S2SV_blank>file"" ) ) ) { show_admin_page ( lbs , NULL ) ; return ; } sprintf ( str , loc ( ""Change<S2SV_blank>%s"" ) , ""[global]"" ) ; if ( strieq ( command , str ) ) { show_admin_page ( lbs , ""global"" ) ; return ; } sprintf ( str2 , ""[global<S2SV_blank>%s]"" , lbs -> top_group ) ; sprintf ( str , loc ( ""Change<S2SV_blank>%s"" ) , str2 ) ; if ( strieq ( command , str ) ) { show_admin_page ( lbs , lbs -> top_group ) ; return ; } if ( strieq ( command , loc ( ""Delete<S2SV_blank>this<S2SV_blank>logbook"" ) ) ) { show_logbook_delete ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Rename<S2SV_blank>this<S2SV_blank>logbook"" ) ) ) { show_logbook_rename ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Create<S2SV_blank>new<S2SV_blank>logbook"" ) ) ) { if ( isparam ( ""tmp"" ) && strieq ( getparam ( ""tmp"" ) , ""Cancel"" ) ) { if ( getcfg ( lbs -> name , ""Password<S2SV_blank>file"" , str , sizeof ( str ) ) ) sprintf ( str , ""?cmd=%s"" , loc ( ""Change<S2SV_blank>config<S2SV_blank>file"" ) ) ; else sprintf ( str , ""?cmd=%s"" , loc ( ""Config"" ) ) ; redirect ( lbs , str ) ; return ; } show_logbook_new ( lbs ) ; return ; } if ( strieq ( command , ""GetPwdFile"" ) ) { char allow [ 256 ] ; allow [ 0 ] = 0 ; getcfg ( ""global"" , ""Allow<S2SV_blank>clone"" , allow , sizeof ( allow ) ) ; if ( atoi ( allow ) == 1 ) { if ( get_password_file ( lbs , file_name , sizeof ( file_name ) ) ) send_file_direct ( file_name ) ; } else { show_http_header ( NULL , FALSE , NULL ) ; rsputs ( loc ( ""Cloning<S2SV_blank>not<S2SV_blank>allowed.<S2SV_blank>Set<S2SV_blank>\\""Allow<S2SV_blank>clone<S2SV_blank>=<S2SV_blank>1\\""<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>cloning."" ) ) ; rsputs ( ""\\r\\n"" ) ; return ; } return ; } if ( strieq ( command , loc ( ""Change<S2SV_blank>password"" ) ) || ( isparam ( ""newpwd"" ) && ! strieq ( command , loc ( ""Cancel"" ) ) && ! strieq ( command , loc ( ""Save"" ) ) ) ) { show_change_pwd_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Save"" ) ) && ( isparam ( ""cfgpage"" ) || isparam ( ""new_user_name"" ) ) ) { if ( isparam ( ""config"" ) && isparam ( ""new_user_name"" ) ) { if ( ! strieq ( getparam ( ""config"" ) , getparam ( ""new_user_name"" ) ) ) { if ( get_user_line ( lbs , getparam ( ""new_user_name"" ) , NULL , NULL , NULL , NULL , NULL , NULL ) == 1 ) { sprintf ( str , ""%s<S2SV_blank>\\""%s\\""<S2SV_blank>%s"" , loc ( ""Login<S2SV_blank>name"" ) , getparam ( ""new_user_name"" ) , loc ( ""exists<S2SV_blank>already"" ) ) ; show_error ( str ) ; return ; } } if ( ! save_user_config ( lbs , isparam ( ""config"" ) ? getparam ( ""config"" ) : """" , FALSE ) ) return ; redirect ( lbs , """" ) ; return ; } else if ( isparam ( ""new_user_name"" ) ) { if ( ! save_user_config ( lbs , getparam ( ""new_user_name"" ) , TRUE ) ) return ; } else { if ( isparam ( ""global"" ) ) { if ( strieq ( getparam ( ""global"" ) , ""global"" ) ) strcpy ( section , ""global"" ) ; else { sprintf ( section , ""global<S2SV_blank>"" ) ; strlcat ( section , getparam ( ""global"" ) , sizeof ( section ) ) ; } } else strlcpy ( section , lbs -> name , sizeof ( section ) ) ; if ( ! save_admin_config ( section , _mtext , str ) ) { show_error ( str ) ; return ; } } if ( lbs ) sprintf ( str , ""../%s/"" , lbs -> name_enc ) ; else sprintf ( str , ""."" ) ; if ( isparam ( ""new_user_name"" ) ) { sprintf ( str + strlen ( str ) , ""?cmd=%s&cfg_user="" , loc ( ""Config"" ) ) ; strlcat ( str , getparam ( ""new_user_name"" ) , sizeof ( str ) ) ; } else if ( isparam ( ""cfg_user"" ) ) { sprintf ( str + strlen ( str ) , ""?cmd=%s&cfg_user="" , loc ( ""Config"" ) ) ; strlcat ( str , getparam ( ""cfg_user"" ) , sizeof ( str ) ) ; } else if ( getcfg ( lbs -> name , ""password<S2SV_blank>file"" , str2 , sizeof ( str2 ) ) ) sprintf ( str + strlen ( str ) , ""?cmd=%s"" , loc ( ""Config"" ) ) ; redirect ( lbs , str ) ; return ; } if ( strieq ( command , loc ( ""Activate"" ) ) && isparam ( ""new_user_name"" ) && isparam ( ""code"" ) ) { if ( ! activate_user ( lbs , getparam ( ""new_user_name"" ) , atoi ( getparam ( ""code"" ) ) ) ) return ; setparam ( ""cfg_user"" , getparam ( ""new_user_name"" ) ) ; get_user_line ( lbs , getparam ( ""new_user_name"" ) , NULL , full_name , user_email , NULL , NULL , NULL ) ; sprintf ( str , ""%s<S2SV_blank><b>&lt;%s&gt;</b>"" , full_name , user_email ) ; sprintf ( str2 , loc ( ""Activation<S2SV_blank>notice<S2SV_blank>has<S2SV_blank>been<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>%s"" ) , str ) ; setparam ( ""notice"" , str2 ) ; show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Remove<S2SV_blank>user"" ) ) && isparam ( ""config"" ) ) { if ( ! remove_user ( lbs , getparam ( ""config"" ) ) ) return ; if ( isparam ( ""unm"" ) && strieq ( getparam ( ""config"" ) , getparam ( ""unm"" ) ) ) { write_logfile ( lbs , ""LOGOUT"" ) ; sid_remove ( getparam ( ""sid"" ) ) ; set_sid_cookie ( lbs , """" , """" ) ; } unsetparam ( ""cfg_user"" ) ; show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""New<S2SV_blank>user"" ) ) ) { show_new_user_page ( lbs , NULL ) ; return ; } if ( strieq ( command , loc ( ""Forgot"" ) ) ) { show_forgot_pwd_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Config"" ) ) ) { if ( ! getcfg ( lbs -> name , ""Password<S2SV_blank>file"" , str , sizeof ( str ) ) ) show_admin_page ( lbs , NULL ) ; else show_config_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Download"" ) ) || strieq ( command , ""Download"" ) ) { show_download_page ( lbs , dec_path ) ; return ; } if ( strieq ( command , loc ( ""Import"" ) ) ) { strcpy ( str , loc ( ""CSV<S2SV_blank>Import"" ) ) ; url_encode ( str , sizeof ( str ) ) ; sprintf ( str1 , ""?cmd=%s"" , str ) ; strcpy ( str , loc ( ""XML<S2SV_blank>Import"" ) ) ; url_encode ( str , sizeof ( str ) ) ; sprintf ( str2 , ""?cmd=%s"" , str ) ; show_query ( lbs , loc ( ""ELOG<S2SV_blank>import"" ) , loc ( ""Please<S2SV_blank>choose<S2SV_blank>format<S2SV_blank>to<S2SV_blank>import:"" ) , ""CSV"" , str1 , ""XML"" , str2 ) ; return ; } if ( strieq ( command , loc ( ""CSV<S2SV_blank>Import"" ) ) ) { show_import_page_csv ( lbs ) ; return ; } if ( strieq ( command , loc ( ""XML<S2SV_blank>Import"" ) ) ) { show_import_page_xml ( lbs ) ; return ; } if ( strieq ( command , ""getmd5"" ) ) { show_md5_page ( lbs ) ; return ; } if ( strieq ( command , loc ( ""Synchronize"" ) ) ) { synchronize ( lbs , SYNC_HTML ) ; return ; } if ( strieq ( command , loc ( ""Logout"" ) ) ) { write_logfile ( lbs , ""LOGOUT"" ) ; if ( getcfg ( lbs -> name , ""Logout<S2SV_blank>to<S2SV_blank>main"" , str , sizeof ( str ) ) && atoi ( str ) == 1 ) { sprintf ( str , ""../"" ) ; setparam ( ""redir"" , str ) ; } else { if ( getcfg ( lbs -> name , ""Logout<S2SV_blank>to<S2SV_blank>URL"" , str , sizeof ( str ) ) ) setparam ( ""redir"" , str ) ; } set_sid_cookie ( lbs , """" , """" ) ; sid_remove ( getparam ( ""sid"" ) ) ; return ; } if ( strieq ( command , loc ( ""Delete"" ) ) ) { show_elog_delete ( lbs , message_id ) ; return ; } if ( strieq ( command , ""IM"" ) ) { call_image_magick ( lbs ) ; return ; } if ( ! _cmdline [ 0 ] && getcfg ( lbs -> name , ""Welcome<S2SV_blank>page"" , str , sizeof ( str ) ) && str [ 0 ] ) { if ( str [ 0 ] == DIR_SEPARATOR || str [ 1 ] == ':' ) strcpy ( file_name , str ) ; else { strlcpy ( file_name , resource_dir , sizeof ( file_name ) ) ; strlcat ( file_name , str , sizeof ( file_name ) ) ; } send_file_direct ( file_name ) ; return ; } if ( ! _cmdline [ 0 ] && getcfg ( lbs -> name , ""Start<S2SV_blank>page"" , str , sizeof ( str ) ) && str [ 0 ] ) { redirect ( lbs , str ) ; return ; } if ( dec_path [ 0 ] == 0 ) show_elog_list ( lbs , 0 , 0 , 0 , TRUE , NULL ) ; else show_elog_entry ( lbs , dec_path , command ) ; return ; }","""value"" ) ) { strencode2 ( str , getparam ( ""value"" ) , sizeof ( str ) ) ; <S2SV_ModStart> ( loc ( str ) ) ; } <S2SV_ModEnd> s = loc"
187,"static int header_gets ( SF_PRIVATE * psf , char * ptr , int bufsize ) { int k ; <S2SV_StartBug> for ( k = 0 ; k < bufsize - 1 ; k ++ ) <S2SV_EndBug> <S2SV_StartBug> { if ( psf -> headindex < psf -> headend ) <S2SV_EndBug> { ptr [ k ] = psf -> header [ psf -> headindex ] ; psf -> headindex ++ ; } else <S2SV_StartBug> { psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , 1 , psf ) ; <S2SV_EndBug> <S2SV_StartBug> ptr [ k ] = psf -> header [ psf -> headindex ] ; <S2SV_EndBug> psf -> headindex = psf -> headend ; } ; if ( ptr [ k ] == '\\n' ) break ; } ; ptr [ k ] = 0 ; return k ; }","int k ; if ( psf -> header . indx + bufsize >= psf -> header . len && psf_bump_header_allocation ( psf , bufsize ) ) return 0 ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> < psf -> <S2SV_ModStart> < psf -> header . end ) { ptr [ k ] = psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx <S2SV_ModEnd> ++ ; } <S2SV_ModStart> { psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx = psf -> header . end <S2SV_ModEnd> ; } ;"
188,"static int compile_search ( struct Context * ctx , const struct Pattern * pat , struct Buffer * buf ) { if ( do_search ( pat , 0 ) == 0 ) return 0 ; if ( pat -> not ) mutt_buffer_addstr ( buf , ""NOT<S2SV_blank>"" ) ; if ( pat -> child ) { int clauses ; clauses = do_search ( pat -> child , 1 ) ; if ( clauses > 0 ) { const struct Pattern * clause = pat -> child ; mutt_buffer_addch ( buf , '(' ) ; while ( clauses ) { if ( do_search ( clause , 0 ) ) { if ( pat -> op == MUTT_OR && clauses > 1 ) mutt_buffer_addstr ( buf , ""OR<S2SV_blank>"" ) ; clauses -- ; if ( compile_search ( ctx , clause , buf ) < 0 ) return - 1 ; if ( clauses ) mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; } clause = clause -> next ; } mutt_buffer_addch ( buf , ')' ) ; } } else { char term [ STRING ] ; char * delim = NULL ; switch ( pat -> op ) { case MUTT_HEADER : mutt_buffer_addstr ( buf , ""HEADER<S2SV_blank>"" ) ; delim = strchr ( pat -> p . str , ':' ) ; if ( ! delim ) { mutt_error ( _ ( ""Header<S2SV_blank>search<S2SV_blank>without<S2SV_blank>header<S2SV_blank>name:<S2SV_blank>%s"" ) , pat -> p . str ) ; return - 1 ; } * delim = '\\0' ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; * delim = ':' ; delim ++ ; SKIPWS ( delim ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_BODY : mutt_buffer_addstr ( buf , ""BODY<S2SV_blank>"" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_WHOLE_MSG : mutt_buffer_addstr ( buf , ""TEXT<S2SV_blank>"" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_SERVERSEARCH : { struct ImapData * idata = ctx -> data ; if ( ! mutt_bit_isset ( idata -> capabilities , X_GM_EXT1 ) ) { mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str ) ; return - 1 ; } } mutt_buffer_addstr ( buf , ""X-GM-RAW<S2SV_blank>"" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; } } return 0 ; }","p . str , false <S2SV_ModStart> ) , delim , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false"
189,"<S2SV_StartBug> int jas_matrix_resize ( jas_matrix_t * matrix , int numrows , int numcols ) <S2SV_EndBug> { <S2SV_StartBug> int size ; <S2SV_EndBug> int i ; size = numrows * numcols ; if ( size > matrix -> datasize_ || numrows > matrix -> maxrows_ ) { return - 1 ; } matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ numcols * i ] ; } return 0 ; }","* matrix , jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> numcols ) { <S2SV_ModStart> numcols ) { jas_matind_t size ; jas_matind_t <S2SV_ModEnd> i ; size"
190,"int res_inverse ( vorbis_dsp_state * vd , vorbis_info_residue * info , ogg_int32_t * * in , int * nonzero , int ch ) { int i , j , k , s , used = 0 ; codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ; codebook * phrasebook = ci -> book_param + info -> groupbook ; int samples_per_partition = info -> grouping ; int partitions_per_word = phrasebook -> dim ; int pcmend = ci -> blocksizes [ vd -> W ] ; if ( info -> type < 2 ) { int max = pcmend >> 1 ; int end = ( info -> end < max ? info -> end : max ) ; int n = end - info -> begin ; if ( n > 0 ) { int partvals = n / samples_per_partition ; int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) in [ used ++ ] = in [ i ] ; ch = used ; if ( used ) { char * * partword = ( char * * ) alloca ( ch * sizeof ( * partword ) ) ; for ( j = 0 ; j < ch ; j ++ ) partword [ j ] = ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword [ j ] ) ) ; for ( s = 0 ; s < info -> stages ; s ++ ) { for ( i = 0 ; i < partvals ; ) { if ( s == 0 ) { partword [ 0 ] [ i + partitions_per_word - 1 ] = 1 ; for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) partword [ 0 ] [ i + k ] = partword [ 0 ] [ i + k + 1 ] * info -> partitions ; for ( j = 1 ; j < ch ; j ++ ) for ( k = partitions_per_word - 1 ; k >= 0 ; k -- ) partword [ j ] [ i + k ] = partword [ j - 1 ] [ i + k ] ; for ( j = 0 ; j < ch ; j ++ ) { int temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; if ( temp == - 1 ) goto eopbreak ; for ( k = 0 ; k < partitions_per_word ; k ++ ) { ogg_uint32_t div = partword [ j ] [ i + k ] ; partword [ j ] [ i + k ] = temp / div ; temp -= partword [ j ] [ i + k ] * div ; } } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) for ( j = 0 ; j < ch ; j ++ ) { long offset = info -> begin + i * samples_per_partition ; <S2SV_StartBug> if ( info -> stagemasks [ ( int ) partword [ j ] [ i ] ] & ( 1 << s ) ) { <S2SV_EndBug> codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ j ] [ i ] << 3 ) + s ] ; if ( info -> type ) { if ( vorbis_book_decodev_add ( stagebook , in [ j ] + offset , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } else { if ( vorbis_book_decodevs_add ( stagebook , in [ j ] + offset , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } } } } } } } } else { int max = ( pcmend * ch ) >> 1 ; int end = ( info -> end < max ? info -> end : max ) ; int n = end - info -> begin ; if ( n > 0 ) { int partvals = n / samples_per_partition ; int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; char * partword = ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword ) ) ; int beginoff = info -> begin / ch ; for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) break ; if ( i == ch ) return ( 0 ) ; samples_per_partition /= ch ; for ( s = 0 ; s < info -> stages ; s ++ ) { for ( i = 0 ; i < partvals ; ) { if ( s == 0 ) { int temp ; partword [ i + partitions_per_word - 1 ] = 1 ; for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) partword [ i + k ] = partword [ i + k + 1 ] * info -> partitions ; temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; if ( temp == - 1 ) goto eopbreak ; for ( k = 0 ; k < partitions_per_word ; k ++ ) { ogg_uint32_t div = partword [ i + k ] ; partword [ i + k ] = temp / div ; temp -= partword [ i + k ] * div ; } } for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) if ( info -> stagemasks [ ( int ) partword [ i ] ] & ( 1 << s ) ) { codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ i ] << 3 ) + s ] ; if ( vorbis_book_decodevv_add ( stagebook , in , i * samples_per_partition + beginoff , ch , & vd -> opb , samples_per_partition , - 8 ) == - 1 ) goto eopbreak ; } } } } } eopbreak : return 0 ; }",* samples_per_partition ; int idx = ( int ) partword [ j ] [ i ] ; if ( idx < info -> partitions && <S2SV_ModEnd> info -> stagemasks <S2SV_ModStart> -> stagemasks [ idx <S2SV_ModEnd> ] & (
191,"ssize_t oe_recvfrom ( int sockfd , void * buf , size_t len , int flags , <S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> oe_socklen_t * addrlen ) { ssize_t ret = - 1 ; oe_fd_t * sock ; if ( ! ( sock = oe_fdtable_get ( sockfd , OE_FD_TYPE_SOCKET ) ) ) OE_RAISE_ERRNO ( oe_errno ) ; ret = sock -> ops . socket . recvfrom ( sock , buf , len , flags , src_addr , addrlen ) ; done : return ret ; }","int flags , <S2SV_ModEnd> struct oe_sockaddr *"
192,"static int dcbnl_cee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * cee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx , i , err = - EMSGSIZE ; u8 value ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) goto nla_put_failure ; cee = nla_nest_start ( skb , DCB_ATTR_CEE ) ; if ( ! cee ) goto nla_put_failure ; if ( ops -> getpgtccfgtx && ops -> getpgbwgcfgtx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 1 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpgtccfgrx && ops -> getpgbwgcfgrx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 0 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpfccfg ) { struct nlattr * pfc_nest = nla_nest_start ( skb , DCB_ATTR_CEE_PFC ) ; if ( ! pfc_nest ) goto nla_put_failure ; for ( i = DCB_PFC_UP_ATTR_0 ; i <= DCB_PFC_UP_ATTR_7 ; i ++ ) { ops -> getpfccfg ( netdev , i - DCB_PFC_UP_ATTR_0 , & value ) ; if ( nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; } nla_nest_end ( skb , pfc_nest ) ; } spin_lock ( & dcb_lock ) ; app = nla_nest_start ( skb , DCB_ATTR_CEE_APP_TABLE ) ; if ( ! app ) goto dcb_unlock ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { struct nlattr * app_nest = nla_nest_start ( skb , DCB_ATTR_APP ) ; if ( ! app_nest ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_IDTYPE , itr -> app . selector ) ; if ( err ) goto dcb_unlock ; err = nla_put_u16 ( skb , DCB_APP_ATTR_ID , itr -> app . protocol ) ; if ( err ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_PRIORITY , itr -> app . priority ) ; if ( err ) goto dcb_unlock ; nla_nest_end ( skb , app_nest ) ; } } nla_nest_end ( skb , app ) ; if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; if ( ops -> getfeatcfg ) { struct nlattr * feat = nla_nest_start ( skb , DCB_ATTR_CEE_FEAT ) ; if ( ! feat ) goto nla_put_failure ; for ( i = DCB_FEATCFG_ATTR_ALL + 1 ; i <= DCB_FEATCFG_ATTR_MAX ; i ++ ) if ( ! ops -> getfeatcfg ( netdev , i , & value ) && nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; nla_nest_end ( skb , feat ) ; } if ( ops -> cee_peer_getpg ) { struct cee_pg pg ; <S2SV_StartBug> err = ops -> cee_peer_getpg ( netdev , & pg ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ; } if ( ops -> cee_peer_getpfc ) { <S2SV_StartBug> struct cee_pfc pfc ; <S2SV_EndBug> err = ops -> cee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) goto nla_put_failure ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_CEE_PEER_APP_TABLE , DCB_ATTR_CEE_PEER_APP_INFO , DCB_ATTR_CEE_PEER_APP ) ; if ( err ) goto nla_put_failure ; } nla_nest_end ( skb , cee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) goto nla_put_failure ; } return 0 ; dcb_unlock : spin_unlock ( & dcb_lock ) ; nla_put_failure : return err ; }","cee_pg pg ; memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> struct cee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )"
193,"static int complete_emulated_mmio ( struct kvm_vcpu * vcpu ) { struct kvm_run * run = vcpu -> run ; struct kvm_mmio_fragment * frag ; unsigned len ; BUG_ON ( ! vcpu -> mmio_needed ) ; frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ; len = min ( 8u , frag -> len ) ; if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ; if ( frag -> len <= 8 ) { frag ++ ; vcpu -> mmio_cur_fragment ++ ; } else { frag -> data += len ; frag -> gpa += len ; frag -> len -= len ; } <S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> vcpu -> mmio_needed = 0 ; if ( vcpu -> mmio_is_write ) return 1 ; vcpu -> mmio_read_completed = 1 ; return complete_emulated_io ( vcpu ) ; } run -> exit_reason = KVM_EXIT_MMIO ; run -> mmio . phys_addr = frag -> gpa ; if ( vcpu -> mmio_is_write ) memcpy ( run -> mmio . data , frag -> data , min ( 8u , frag -> len ) ) ; run -> mmio . len = min ( 8u , frag -> len ) ; run -> mmio . is_write = vcpu -> mmio_is_write ; vcpu -> arch . complete_userspace_io = complete_emulated_mmio ; return 0 ; }",vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
194,"static krb5_error_code split_der ( asn1buf * buf , uint8_t * const * der , size_t len , taginfo * tag_out ) { krb5_error_code ret ; const uint8_t * contents , * remainder ; size_t clen , rlen ; <S2SV_StartBug> ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ; <S2SV_EndBug> if ( ret ) return ret ; if ( rlen != 0 ) return ASN1_BAD_LENGTH ; insert_bytes ( buf , contents , clen ) ; return 0 ; }",", & rlen , 0"
195,"static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }","value ) ; if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s"" , value ) ;"
196,"static void chase_port ( struct edgeport_port * port , unsigned long timeout , int flush ) { int baud_rate ; struct tty_struct * tty = tty_port_tty_get ( & port -> port -> port ) ; struct usb_serial * serial = port -> port -> serial ; wait_queue_t wait ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ; spin_lock_irqsave ( & port -> ep_lock , flags ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( kfifo_len ( & port -> write_fifo ) == 0 || timeout == 0 || signal_pending ( current ) || serial -> disconnected ) break ; spin_unlock_irqrestore ( & port -> ep_lock , flags ) ; timeout = schedule_timeout ( timeout ) ; spin_lock_irqsave ( & port -> ep_lock , flags ) ; } set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( flush ) kfifo_reset_out ( & port -> write_fifo ) ; spin_unlock_irqrestore ( & port -> ep_lock , flags ) ; tty_kref_put ( tty ) ; timeout += jiffies ; while ( ( long ) ( jiffies - timeout ) < 0 && ! signal_pending ( current ) && ! serial -> disconnected ) { if ( ! tx_active ( port ) ) break ; msleep ( 10 ) ; } if ( serial -> disconnected ) return ; baud_rate = port -> baud_rate ; if ( baud_rate == 0 ) baud_rate = 50 ; msleep ( max ( 1 , DIV_ROUND_UP ( 10000 , baud_rate ) ) ) ; }",unsigned long flags ; if ( ! tty ) return
197,"static int atusb_get_and_show_revision ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> int ret ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_ID , ATUSB_REQ_FROM_DEV , 0 , 0 , buffer , 3 , 1000 ) ; if ( ret >= 0 ) { atusb -> fw_ver_maj = buffer [ 0 ] ; atusb -> fw_ver_min = buffer [ 1 ] ; atusb -> fw_hw_type = buffer [ 2 ] ; dev_info ( & usb_dev -> dev , ""Firmware:<S2SV_blank>major:<S2SV_blank>%u,<S2SV_blank>minor:<S2SV_blank>%u,<S2SV_blank>hardware<S2SV_blank>type:<S2SV_blank>%u\\n"" , atusb -> fw_ver_maj , atusb -> fw_ver_min , atusb -> fw_hw_type ) ; } if ( atusb -> fw_ver_maj == 0 && atusb -> fw_ver_min < 2 ) { dev_info ( & usb_dev -> dev , ""Firmware<S2SV_blank>version<S2SV_blank>(%u.%u)<S2SV_blank>predates<S2SV_blank>our<S2SV_blank>first<S2SV_blank>public<S2SV_blank>release."" , atusb -> fw_ver_maj , atusb -> fw_ver_min ) ; dev_info ( & usb_dev -> dev , ""Please<S2SV_blank>update<S2SV_blank>to<S2SV_blank>version<S2SV_blank>0.2<S2SV_blank>or<S2SV_blank>newer"" ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }","; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ) ; } kfree ( buffer ) ;"
198,"static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 <S2SV_StartBug> HANDLE Token ; <S2SV_EndBug> <S2SV_StartBug> if ( LogonUser ( username , ""."" , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> GetLastError ( ) , ""LogonUser()<S2SV_blank>failed"" ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> if ( ImpersonateLoggedOnUser ( Token ) == 0 ) <S2SV_EndBug> { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , ""ImpersonateLoggedOnUser()<S2SV_blank>failed"" ) ; CloseHandle ( Token ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } CloseHandle ( Token ) ; return 0 ; <S2SV_StartBug> # else <S2SV_EndBug> struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ; # endif char * crypt_password ; if ( ( user = getpwnam ( username ) ) == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; <S2SV_EndBug> return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; <S2SV_EndBug> return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif <S2SV_StartBug> crypt_password = crypt ( password , user_password ) ; <S2SV_EndBug> if ( crypt_password == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; <S2SV_EndBug> return - 1 ; } if ( strcmp ( user_password , crypt_password ) != 0 ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; <S2SV_EndBug> return - 1 ; } if ( setuid ( user -> pw_uid ) ) { <S2SV_StartBug> pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> errno , ""setuid"" ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } return 0 ; # endif }","# ifdef _WIN32 DWORD error ; <S2SV_ModStart> HANDLE Token ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; <S2SV_ModStart> 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; error = GetLastError ( ) ; if ( error != ERROR_LOGON_FAILURE ) { pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , error , ""LogonUser()<S2SV_blank>failed"" ) ; rpcapd_log ( LOGPRIO_ERROR , ""%s"" , errmsgbuf ) ; } return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; pcap_fmt_errmsg_for_win32_err ( errmsgbuf <S2SV_ModEnd> , PCAP_ERRBUF_SIZE , <S2SV_ModStart> ( ) , ""ImpersonateLoggedOnUser()<S2SV_blank>failed"" ) ; rpcapd_log ( LOGPRIO_ERROR , ""%s"" , errmsgbuf ) ; CloseHandle <S2SV_ModEnd> ( Token ) <S2SV_ModStart> ( Token ) ; return - 1 ; } <S2SV_ModEnd> CloseHandle ( Token <S2SV_ModStart> ) ; return <S2SV_ModEnd> 0 ; # <S2SV_ModStart> ; # else int error ; <S2SV_ModStart> , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; # endif errno = 0 ; <S2SV_ModStart> NULL ) { error = errno ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; if ( error == 0 ) { rpcapd_log ( LOGPRIO_ERROR , ""crypt()<S2SV_blank>failed"" ) ; } else { rpcapd_log ( LOGPRIO_ERROR , ""crypt()<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( error ) ) ; } <S2SV_ModEnd> return - 1 <S2SV_ModStart> , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { error = errno ; <S2SV_ModStart> , PCAP_ERRBUF_SIZE , error <S2SV_ModEnd> , ""setuid"" ) <S2SV_ModStart> ""setuid"" ) ; rpcapd_log ( LOGPRIO_ERROR , ""setuid()<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( error ) ) ;"
199,"static PyObject * <S2SV_StartBug> _Unpickler_MemoGet ( UnpicklerObject * self , Py_ssize_t idx ) <S2SV_EndBug> { <S2SV_StartBug> if ( idx < 0 || idx >= self -> memo_size ) <S2SV_EndBug> return NULL ; return self -> memo [ idx ] ; }","* self , size_t <S2SV_ModEnd> idx ) { <S2SV_ModStart> { if ( <S2SV_ModEnd> idx >= self"
200,"void sas_deform_port ( struct asd_sas_phy * phy , int gone ) { struct sas_ha_struct * sas_ha = phy -> ha ; struct asd_sas_port * port = phy -> port ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; struct domain_device * dev ; unsigned long flags ; if ( ! port ) return ; dev = port -> port_dev ; if ( dev ) dev -> pathways -- ; if ( port -> num_phys == 1 ) { sas_unregister_domain_devices ( port , gone ) ; <S2SV_StartBug> sas_port_delete ( port -> port ) ; <S2SV_EndBug> port -> port = NULL ; } else { sas_port_delete_phy ( port -> port , phy -> phy ) ; sas_device_set_phy ( dev , port -> port ) ; } if ( si -> dft -> lldd_port_deformed ) si -> dft -> lldd_port_deformed ( phy ) ; spin_lock_irqsave ( & sas_ha -> phy_port_lock , flags ) ; spin_lock ( & port -> phy_list_lock ) ; list_del_init ( & phy -> port_phy_el ) ; sas_phy_set_target ( phy , NULL ) ; phy -> port = NULL ; port -> num_phys -- ; port -> phy_mask &= ~ ( 1U << phy -> id ) ; if ( port -> num_phys == 0 ) { INIT_LIST_HEAD ( & port -> phy_list ) ; memset ( port -> sas_addr , 0 , SAS_ADDR_SIZE ) ; memset ( port -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; port -> class = 0 ; port -> iproto = 0 ; port -> tproto = 0 ; port -> oob_mode = 0 ; port -> phy_mask = 0 ; } spin_unlock ( & port -> phy_list_lock ) ; spin_unlock_irqrestore ( & sas_ha -> phy_port_lock , flags ) ; return ; }",gone ) ; sas_destruct_devices ( port ) ;
201,"static stmt_ty <S2SV_StartBug> ast_for_with_stmt ( struct compiling * c , const node * n , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int i , n_items , nch_minus_type , has_type_comment ; asdl_seq * items , * body ; string type_comment ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>with<S2SV_blank>statements<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , with_stmt ) ; has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; n_items = ( nch_minus_type - 2 ) / 2 ; items = _Ta3_asdl_seq_new ( n_items , c -> c_arena ) ; if ( ! items ) return NULL ; for ( i = 1 ; i < nch_minus_type - 2 ; i += 2 ) { withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ; if ( ! item ) return NULL ; asdl_seq_SET ( items , ( i - 1 ) / 2 , item ) ; } body = ast_for_suite ( c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! body ) return NULL ; if ( has_type_comment ) type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; else type_comment = NULL ; if ( is_async ) <S2SV_StartBug> return AsyncWith ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; <S2SV_EndBug> else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }","const node * n0 , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,"
202,"struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { <S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }",tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
203,"static bool ldm_frag_add ( const u8 * data , int size , struct list_head * frags ) { struct frag * f ; struct list_head * item ; int rec , num , group ; BUG_ON ( ! data || ! frags ) ; if ( size < 2 * VBLK_SIZE_HEAD ) { ldm_error ( ""Value<S2SV_blank>of<S2SV_blank>size<S2SV_blank>is<S2SV_blank>to<S2SV_blank>small."" ) ; return false ; } group = get_unaligned_be32 ( data + 0x08 ) ; rec = get_unaligned_be16 ( data + 0x0C ) ; num = get_unaligned_be16 ( data + 0x0E ) ; if ( ( num < 1 ) || ( num > 4 ) ) { ldm_error ( ""A<S2SV_blank>VBLK<S2SV_blank>claims<S2SV_blank>to<S2SV_blank>have<S2SV_blank>%d<S2SV_blank>parts."" , num ) ; return false ; } if ( rec >= num ) { ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , num ) ; return false ; } list_for_each ( item , frags ) { f = list_entry ( item , struct frag , list ) ; if ( f -> group == group ) goto found ; } f = kmalloc ( sizeof ( * f ) + size * num , GFP_KERNEL ) ; if ( ! f ) { ldm_crit ( ""Out<S2SV_blank>of<S2SV_blank>memory."" ) ; return false ; } f -> group = group ; f -> num = num ; f -> rec = rec ; f -> map = 0xFF << num ; list_add_tail ( & f -> list , frags ) ; found : <S2SV_StartBug> if ( f -> map & ( 1 << rec ) ) { <S2SV_EndBug> ldm_error ( ""Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d."" , rec ) ; f -> map &= 0x7F ; return false ; } f -> map |= ( 1 << rec ) ; data += VBLK_SIZE_HEAD ; size -= VBLK_SIZE_HEAD ; memcpy ( f -> data + rec * ( size - VBLK_SIZE_HEAD ) + VBLK_SIZE_HEAD , data , size ) ; return true ; }",": if ( rec >= f -> num ) { ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , f -> num ) ; return false ; } if ("
204,"static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( ""lockd:<S2SV_blank>unlock<S2SV_blank>failed<S2SV_blank>(err<S2SV_blank>=<S2SV_blank>%d)\\n"" , - task -> tk_status ) ; <S2SV_StartBug> goto retry_rebind ; <S2SV_EndBug> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING ""lockd:<S2SV_blank>unexpected<S2SV_blank>unlock<S2SV_blank>status:<S2SV_blank>%d\\n"" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }",tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> goto retry_rebind ; }
205,"static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || ! rdev -> ops -> sched_scan_start ) return - EOPNOTSUPP ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; if ( rdev -> sched_scan_req ) return - EINPROGRESS ; if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) return - EINVAL ; interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; if ( interval == 0 ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , NL80211_CMD_START_SCHED_SCAN ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }",tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
206,"static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }",if ( iter >= <S2SV_ModEnd> CIPSO_V4_TAG_MAXCNT ) return <S2SV_ModStart> ) ; } while <S2SV_ModEnd> ( iter < <S2SV_ModStart> tags [ iter ++
207,"static int count_comp_fors ( struct compiling * c , const node * n ) { int n_fors = 0 ; <S2SV_StartBug> int is_async ; <S2SV_EndBug> count_comp_for : is_async = 0 ; n_fors ++ ; REQ ( n , comp_for ) ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> is_async = 1 ; } <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> } else { return n_fors ; } count_comp_iter : REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; if ( TYPE ( n ) == comp_for ) goto count_comp_for ; else if ( TYPE ( n ) == comp_if ) { if ( NCH ( n ) == 3 ) { n = CHILD ( n , 2 ) ; goto count_comp_iter ; } else return n_fors ; <S2SV_StartBug> } <S2SV_EndBug> PyErr_SetString ( PyExc_SystemError , ""logic<S2SV_blank>error<S2SV_blank>in<S2SV_blank>count_comp_fors"" ) ; return - 1 ; }","= 0 ; count_comp_for : <S2SV_ModEnd> n_fors ++ ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 ) { REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; n = CHILD ( n , 1 ) ; } else if ( NCH ( n ) == 1 ) { n = CHILD ( n , 0 ) ; } else { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> == ( 5 <S2SV_ModEnd> ) ) { <S2SV_ModStart> n , 4 <S2SV_ModEnd> ) ; } <S2SV_ModStart> n_fors ; } error :"
208,"static const u_char * ikev1_nonce_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct isakmp_gen e ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & e , ext , sizeof ( e ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ntohs ( e . len ) - 4 ) ) goto trunc ; <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> goto trunc ; } <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ; return NULL ; }","( ndo , ""<S2SV_blank>n<S2SV_blank>len=%u"" <S2SV_ModEnd> , ntohs ( <S2SV_ModStart> ; if ( ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 2 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> else if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> * ) ( <S2SV_ModEnd> ext + 1 <S2SV_ModStart> trunc ; } }"
209,"static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL ; if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; RB_CLEAR_NODE ( & rt_waiter . pi_tree_entry ) ; RB_CLEAR_NODE ( & rt_waiter . tree_entry ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; <S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }","goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }"
210,"int propagate_mnt ( struct mount * dest_mnt , struct mountpoint * dest_mp , struct mount * source_mnt , struct hlist_head * tree_list ) { struct mount * m , * n ; int ret = 0 ; user_ns = current -> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; <S2SV_StartBug> last_source = source_mnt ; <S2SV_EndBug> mp = dest_mp ; list = tree_list ; dest_master = dest_mnt -> mnt_master ; for ( n = next_peer ( dest_mnt ) ; n != dest_mnt ; n = next_peer ( n ) ) { ret = propagate_one ( n ) ; if ( ret ) goto out ; } for ( m = next_group ( dest_mnt , dest_mnt ) ; m ; m = next_group ( m , dest_mnt ) ) { n = m ; do { ret = propagate_one ( n ) ; if ( ret ) goto out ; n = next_peer ( n ) ; } while ( n != m ) ; } out : read_seqlock_excl ( & mount_lock ) ; hlist_for_each_entry ( n , tree_list , mnt_hash ) { m = n -> mnt_parent ; if ( m -> mnt_master != dest_mnt -> mnt_master ) CLEAR_MNT_MARK ( m -> mnt_master ) ; } read_sequnlock_excl ( & mount_lock ) ; return ret ; }",= dest_mnt ; first_source = source_mnt ;
211,"static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; msleep ( 300 ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""m88ds3103"" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( ""m88ds3103"" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""ts2022"" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( ""ts2020"" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }","d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex"
212,"static int nfc_llcp_build_gb ( struct nfc_llcp_local * local ) { <S2SV_StartBug> u8 * gb_cur , * version_tlv , version , version_length ; <S2SV_EndBug> u8 * lto_tlv , lto_length ; u8 * wks_tlv , wks_length ; u8 * miux_tlv , miux_length ; __be16 wks = cpu_to_be16 ( local -> local_wks ) ; u8 gb_len = 0 ; int ret = 0 ; version = LLCP_VERSION_11 ; version_tlv = nfc_llcp_build_tlv ( LLCP_TLV_VERSION , & version , 1 , & version_length ) ; <S2SV_StartBug> gb_len += version_length ; <S2SV_EndBug> lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ; <S2SV_StartBug> gb_len += lto_length ; <S2SV_EndBug> pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\n"" , local -> local_wks ) ; wks_tlv = nfc_llcp_build_tlv ( LLCP_TLV_WKS , ( u8 * ) & wks , 2 , & wks_length ) ; <S2SV_StartBug> gb_len += wks_length ; <S2SV_EndBug> miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 , <S2SV_StartBug> & miux_length ) ; <S2SV_EndBug> gb_len += miux_length ; gb_len += ARRAY_SIZE ( llcp_magic ) ; if ( gb_len > NFC_MAX_GT_LEN ) { ret = - EINVAL ; goto out ; } gb_cur = local -> gb ; memcpy ( gb_cur , llcp_magic , ARRAY_SIZE ( llcp_magic ) ) ; gb_cur += ARRAY_SIZE ( llcp_magic ) ; memcpy ( gb_cur , version_tlv , version_length ) ; gb_cur += version_length ; memcpy ( gb_cur , lto_tlv , lto_length ) ; gb_cur += lto_length ; memcpy ( gb_cur , wks_tlv , wks_length ) ; gb_cur += wks_length ; memcpy ( gb_cur , miux_tlv , miux_length ) ; gb_cur += miux_length ; local -> gb_len = gb_len ; out : kfree ( version_tlv ) ; kfree ( lto_tlv ) ; kfree ( wks_tlv ) ; kfree ( miux_tlv ) ; return ret ; }","* gb_cur , version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> ; __be16 wks <S2SV_ModStart> version_length ) ; if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> lto_length ) ; if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> wks_length ) ; if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> miux_length ) ; if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; }"
213,"static int next_state_class ( CClassNode * cc , OnigCodePoint * vs , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; if ( * state == CCS_RANGE ) return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE ; if ( * state == CCS_VALUE && * type != CCV_CLASS ) { if ( * type == CCV_SB ) BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } } <S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> * type = CCV_CLASS ; return 0 ; }",; } } if ( * state != CCS_START )
214,"static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <S2SV_StartBug> int pkt_len , pktnum , hr , min , sec , csec ; <S2SV_EndBug> char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , ""%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s"" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid"" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , ""OFFSET<S2SV_blank>0001-0203"" ) != 0 ) ; <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ; <S2SV_EndBug> if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; return FALSE ; } <S2SV_StartBug> phdr -> rec_type = REC_TYPE_PACKET ; <S2SV_EndBug> phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; } <S2SV_StartBug> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <S2SV_EndBug> pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid"" ) ; return FALSE ; } } return TRUE ; }","int num_items_scanned ; guint pkt_len ; int <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , ""LEN=%9u"" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } <S2SV_ModStart> ( buf , pkt_len <S2SV_ModEnd> ) ; pd"
215,"static int ceph_x_verify_authorizer_reply ( struct ceph_auth_client * ac , struct ceph_authorizer * a , size_t len ) { struct ceph_x_authorizer * au = ( void * ) a ; struct ceph_x_ticket_handler * th ; int ret = 0 ; struct ceph_x_authorize_reply reply ; <S2SV_StartBug> void * p = au -> reply_buf ; <S2SV_EndBug> void * end = p + sizeof ( au -> reply_buf ) ; th = get_ticket_handler ( ac , au -> service ) ; if ( IS_ERR ( th ) ) return PTR_ERR ( th ) ; <S2SV_StartBug> ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret != sizeof ( reply ) ) return - EPERM ; if ( au -> nonce + 1 != le64_to_cpu ( reply . nonce_plus_one ) ) ret = - EPERM ; else ret = 0 ; dout ( ""verify_authorizer_reply<S2SV_blank>nonce<S2SV_blank>%llx<S2SV_blank>got<S2SV_blank>%llx<S2SV_blank>ret<S2SV_blank>%d\\n"" , au -> nonce , le64_to_cpu ( reply . nonce_plus_one ) , ret ) ; return ret ; }","; void * preply = & reply ; void * <S2SV_ModStart> end , & preply <S2SV_ModEnd> , sizeof ("
216,"char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) { int length ; length = strlen ( filename ) ; <S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> { if ( ( filename [ 0 ] == \'\\""\' ) && ( filename [ length - 1 ] == \'\\""\' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ; } return strdup ( filename ) ; }",( length > 1 <S2SV_ModEnd> ) { if
217,"static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , ""compressed<S2SV_blank>PPP<S2SV_blank>data"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , tok2str ( ppptype2str , ""unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)"" , proto ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; break ; } }","p , length <S2SV_ModEnd> ) ; break"
218,"static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }",case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
219,"<S2SV_StartBug> static void predict_and_reconstruct_intra_block ( int plane , int block , <S2SV_EndBug> BLOCK_SIZE plane_bsize , <S2SV_StartBug> TX_SIZE tx_size , void * arg ) { <S2SV_EndBug> struct intra_args * const args = ( struct intra_args * ) arg ; VP9_COMMON * const cm = args -> cm ; MACROBLOCKD * const xd = args -> xd ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) <S2SV_EndBug> : mi -> mbmi . uv_mode ; int x , y ; uint8_t * dst ; <S2SV_StartBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; <S2SV_EndBug> <S2SV_StartBug> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , <S2SV_EndBug> b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ; <S2SV_StartBug> if ( ! mi -> mbmi . skip ) { <S2SV_EndBug> <S2SV_StartBug> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , <S2SV_EndBug> plane_bsize , x , y , tx_size , args -> r ) ; inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ; } }","void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col <S2SV_ModEnd> , TX_SIZE tx_size <S2SV_ModStart> , TX_SIZE tx_size ) { <S2SV_ModEnd> struct macroblockd_plane * <S2SV_ModStart> plane ] ; PREDICTION_MODE <S2SV_ModEnd> mode = ( <S2SV_ModStart> 0 ) ? mbmi -> mode : mbmi -> uv_mode ; <S2SV_ModEnd> uint8_t * dst <S2SV_ModStart> * dst ; <S2SV_ModEnd> dst = & <S2SV_ModStart> [ 4 * row <S2SV_ModEnd> * pd -> <S2SV_ModStart> + 4 * col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row <S2SV_ModEnd> << 1 ) <S2SV_ModStart> << 1 ) + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row <S2SV_ModEnd> , plane ) <S2SV_ModStart> if ( ! mbmi -> <S2SV_ModEnd> skip ) { <S2SV_ModStart> ) { const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const <S2SV_ModStart> = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , <S2SV_ModEnd> eob ) ;"
220,"void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; <S2SV_StartBug> impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; <S2SV_EndBug> return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; ps_dec -> u2_header_done = 1 ; } }",= e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; }
221,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { unsigned x , y ; AVFilterContext * ctx = inlink -> dst ; VignetteContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( s -> eval_mode == EVAL_MODE_FRAME ) update_context ( s , inlink , in ) ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { uint8_t * dst = out -> data [ 0 ] ; const uint8_t * src = in -> data [ 0 ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ 0 ] ; const int src_linesize = in -> linesize [ 0 ] ; const int fmap_linesize = s -> fmap_linesize ; for ( y = 0 ; y < inlink -> h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < inlink -> w ; x ++ , dstp += 3 , srcp += 3 ) { const float f = fmap [ x ] ; dstp [ 0 ] = av_clip_uint8 ( srcp [ 0 ] * f + get_dither_value ( s ) ) ; dstp [ 1 ] = av_clip_uint8 ( srcp [ 1 ] * f + get_dither_value ( s ) ) ; dstp [ 2 ] = av_clip_uint8 ( srcp [ 2 ] * f + get_dither_value ( s ) ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize ; } } else { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ plane ] ; const int src_linesize = in -> linesize [ plane ] ; const int fmap_linesize = s -> fmap_linesize ; const int chroma = plane == 1 || plane == 2 ; const int hsub = chroma ? s -> desc -> log2_chroma_w : 0 ; const int vsub = chroma ? s -> desc -> log2_chroma_h : 0 ; const int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; const int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; for ( y = 0 ; y < h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < w ; x ++ ) { const double dv = get_dither_value ( s ) ; if ( chroma ) * dstp ++ = av_clip_uint8 ( fmap [ x << hsub ] * ( * srcp ++ - 127 ) + 127 + dv ) ; else * dstp ++ = av_clip_uint8 ( fmap [ x ] * * srcp ++ + dv ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize << vsub ; } } } return ff_filter_frame ( outlink , out ) ; }",in -> data [ plane ] && in -> linesize
222,"static int em_loop ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ; if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }",ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ) ) ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
223,"static ssize_t k90_show_macro_mode ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; const char * macro_mode ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>mode<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> switch ( data [ 0 ] ) { case K90_MACRO_MODE_HW : macro_mode = ""HW"" ; break ; case K90_MACRO_MODE_SW : macro_mode = ""SW"" ; break ; default : dev_warn ( dev , ""K90<S2SV_blank>in<S2SV_blank>unknown<S2SV_blank>mode:<S2SV_blank>%02hhx.\\n"" , data [ 0 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; }","macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>"
224,"TSQuery QTN2QT ( QTNode * in ) { TSQuery out ; int len ; int sumlen = 0 , nnode = 0 ; QTN2QTState state ; <S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> len = COMPUTESIZE ( nnode , sumlen ) ; out = ( TSQuery ) palloc0 ( len ) ; SET_VARSIZE ( out , len ) ; out -> size = nnode ; state . curitem = GETQUERY ( out ) ; state . operand = state . curoperand = GETOPERAND ( out ) ; fillQT ( & state , in ) ; return out ; }",", & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) )"
225,"static int jpeg2000_decode_tile ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile , AVFrame * picture ) { int compno , reslevelno , bandno ; int x , y ; uint8_t * line ; Jpeg2000T1Context t1 ; for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels2decode ; reslevelno ++ ) { Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < rlevel -> nbands ; bandno ++ ) { int nb_precincts , precno ; Jpeg2000Band * band = rlevel -> band + bandno ; int cblkno = 0 , bandpos ; bandpos = bandno + ( reslevelno > 0 ) ; if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] ) continue ; nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { int x , y ; Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ) ; x = cblk -> coord [ 0 ] [ 0 ] ; y = cblk -> coord [ 1 ] [ 0 ] ; if ( codsty -> transform == FF_DWT97 ) dequantization_float ( x , y , cblk , comp , & t1 , band ) ; else dequantization_int ( x , y , cblk , comp , & t1 , band ) ; } } } } ff_dwt_decode ( & comp -> dwt , codsty -> transform == FF_DWT97 ? ( void * ) comp -> f_data : ( void * ) comp -> i_data ) ; } if ( tile -> codsty [ 0 ] . mct ) mct_decode ( s , tile ) ; if ( s -> cdef [ 0 ] < 0 ) { for ( x = 0 ; x < s -> ncomponents ; x ++ ) s -> cdef [ x ] = x + 1 ; if ( ( s -> ncomponents & 1 ) == 0 ) s -> cdef [ s -> ncomponents - 1 ] = 0 ; } if ( s -> precision <= 8 ) { for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; float * datap = comp -> f_data ; int32_t * i_datap = comp -> i_data ; int cbps = s -> cbps [ compno ] ; int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; int planar = ! ! picture -> data [ 2 ] ; int pixelsize = planar ? 1 : s -> ncomponents ; int plane = 0 ; if ( planar ) plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ) ; y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y ; <S2SV_StartBug> line = picture -> data [ plane ] + y * picture -> linesize [ plane ] ; <S2SV_EndBug> for ( ; y < tile -> comp [ compno ] . coord [ 1 ] [ 1 ] - s -> image_offset_y ; y += s -> cdy [ compno ] ) { uint8_t * dst ; x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x ; <S2SV_StartBug> dst = line + x * pixelsize + compno * ! planar ; <S2SV_EndBug> if ( codsty -> transform == FF_DWT97 ) { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 8 - cbps ) ; datap ++ ; dst += pixelsize ; } } else { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 8 - cbps ) ; i_datap ++ ; dst += pixelsize ; } } line += picture -> linesize [ plane ] ; } } } else { for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; float * datap = comp -> f_data ; int32_t * i_datap = comp -> i_data ; uint16_t * linel ; int cbps = s -> cbps [ compno ] ; int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; int planar = ! ! picture -> data [ 2 ] ; int pixelsize = planar ? 1 : s -> ncomponents ; int plane = 0 ; if ( planar ) plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ) ; y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y ; <S2SV_StartBug> linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ) ; <S2SV_EndBug> for ( ; y < tile -> comp [ compno ] . coord [ 1 ] [ 1 ] - s -> image_offset_y ; y += s -> cdy [ compno ] ) { uint16_t * dst ; x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x ; <S2SV_StartBug> dst = linel + ( x * pixelsize + compno * ! planar ) ; <S2SV_EndBug> if ( codsty -> transform == FF_DWT97 ) { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 16 - cbps ) ; datap ++ ; dst += pixelsize ; } } else { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 16 - cbps ) ; i_datap ++ ; dst += pixelsize ; } } linel += picture -> linesize [ plane ] >> 1 ; } } } return 0 ; }",] + y / s -> cdy [ compno ] <S2SV_ModStart> line + x / s -> cdx [ compno ] <S2SV_ModStart> ] + y / s -> cdy [ compno ] <S2SV_ModStart> + ( x / s -> cdx [ compno ]
226,"<S2SV_StartBug> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <S2SV_EndBug> <S2SV_StartBug> int length , int offset , int total_size ) <S2SV_EndBug> { struct oz_port * port = hport ; struct urb * urb ; int err = 0 ; oz_dbg ( ON , ""oz_hcd_get_desc_cnf<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>offs<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>tot_size<S2SV_blank>=<S2SV_blank>%d\\n"" , length , offset , total_size ) ; urb = oz_find_urb_by_id ( port , 0 , req_id ) ; if ( ! urb ) return ; if ( status == 0 ) { <S2SV_StartBug> int copy_len ; <S2SV_EndBug> <S2SV_StartBug> int required_size = urb -> transfer_buffer_length ; <S2SV_EndBug> if ( required_size > total_size ) required_size = total_size ; copy_len = required_size - offset ; if ( length <= copy_len ) copy_len = length ; memcpy ( urb -> transfer_buffer + offset , desc , copy_len ) ; offset += copy_len ; if ( offset < required_size ) { struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) ) err = - ENOMEM ; else if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) ) { oz_dequeue_ep_urb ( port , 0 , 0 , urb ) ; err = - ENOMEM ; } if ( err == 0 ) return ; } } urb -> actual_length = total_size ; oz_complete_urb ( port -> ozhcd -> hcd , urb , 0 ) ; }","u8 req_id , u8 <S2SV_ModEnd> status , const <S2SV_ModStart> * desc , u8 length , u16 offset , u16 <S2SV_ModEnd> total_size ) { <S2SV_ModStart> 0 ) { unsigned <S2SV_ModStart> int copy_len ; unsigned"
227,"int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , ""\\n"" , 1 ) ; return 1 ; }","128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , ""%s\\n"" , obj_txt <S2SV_ModEnd> ) ; return"
228,"static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , ""%.*s"" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }",hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }
229,"static int candidate_refresh_aq ( const CYCLIC_REFRESH * cr , const MB_MODE_INFO * mbmi , <S2SV_StartBug> BLOCK_SIZE bsize , int use_rd ) { <S2SV_EndBug> if ( use_rd ) { if ( cr -> projected_rate_sb < cr -> thresh_rate_sb ) return 1 ; else if ( bsize < cr -> min_block_size || <S2SV_StartBug> ( mbmi -> mv [ 0 ] . as_int != 0 && <S2SV_EndBug> <S2SV_StartBug> cr -> projected_dist_sb > cr -> thresh_dist_sb ) || <S2SV_EndBug> <S2SV_StartBug> ! is_inter_block ( mbmi ) ) <S2SV_EndBug> return 0 ; else return 1 ; } else { <S2SV_StartBug> if ( bsize < cr -> min_block_size || <S2SV_EndBug> <S2SV_StartBug> mbmi -> mv [ 0 ] . as_int != 0 || <S2SV_EndBug> ! is_inter_block ( mbmi ) ) return 0 ; else <S2SV_StartBug> return 1 ; <S2SV_EndBug> } }","* mbmi , int64_t rate , int64_t dist , int bsize ) { MV mv = <S2SV_ModEnd> mbmi -> mv <S2SV_ModStart> 0 ] . as_mv ; if ( dist <S2SV_ModEnd> > cr -> <S2SV_ModStart> cr -> thresh_dist_sb && ( mv . row > cr -> motion_thresh || mv . row < - cr -> motion_thresh || mv . col > cr -> motion_thresh || mv . col < - cr -> motion_thresh <S2SV_ModEnd> || ! is_inter_block <S2SV_ModStart> mbmi ) ) ) return CR_SEGMENT_ID_BASE ; else <S2SV_ModEnd> if ( bsize <S2SV_ModStart> if ( bsize >= BLOCK_16X16 && rate <S2SV_ModStart> < cr -> thresh_rate_sb && is_inter_block ( mbmi ) && <S2SV_ModEnd> mbmi -> mv <S2SV_ModStart> ] . as_int == 0 && cr -> rate_boost_fac > 10 ) return CR_SEGMENT_ID_BOOST2 <S2SV_ModEnd> ; else return <S2SV_ModStart> ; else return CR_SEGMENT_ID_BOOST1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
230,"<S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ; Stream_Read_UINT16 ( s , fields -> Len ) ; Stream_Read_UINT16 ( s , fields -> MaxLen ) ; Stream_Read_UINT32 ( s , fields -> BufferOffset ) ; return 1 ; }",<S2SV_null> <S2SV_null> <S2SV_null> static
231,"int midi_synth_load_patch ( int dev , int format , const char __user * addr , <S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> { int orig_dev = synth_devs [ dev ] -> midi_dev ; struct sysex_info sysex ; int i ; unsigned long left , src_offs , eox_seen = 0 ; int first_byte = 1 ; int hdr_size = ( unsigned long ) & sysex . data [ 0 ] - ( unsigned long ) & sysex ; leave_sysex ( dev ) ; if ( ! prefix_cmd ( orig_dev , 0xf0 ) ) return 0 ; if ( format != SYSEX_PATCH ) <S2SV_StartBug> { <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> if ( count < hdr_size ) <S2SV_StartBug> { <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> count -= hdr_size ; <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> return - EFAULT ; <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> sysex . len = count ; <S2SV_StartBug> } <S2SV_EndBug> left = sysex . len ; src_offs = 0 ; for ( i = 0 ; i < left && ! signal_pending ( current ) ; i ++ ) { unsigned char data ; if ( get_user ( data , ( unsigned char __user * ) ( addr + hdr_size + i ) ) ) return - EFAULT ; eox_seen = ( i > 0 && data & 0x80 ) ; if ( eox_seen && data != 0xf7 ) data = 0xf7 ; if ( i == 0 ) { if ( data != 0xf0 ) { printk ( KERN_WARNING ""midi_synth:<S2SV_blank>Sysex<S2SV_blank>start<S2SV_blank>missing\\n"" ) ; return - EINVAL ; } } while ( ! midi_devs [ orig_dev ] -> outputc ( orig_dev , ( unsigned char ) ( data & 0xff ) ) && ! signal_pending ( current ) ) schedule ( ) ; if ( ! first_byte && data & 0x80 ) return 0 ; first_byte = 0 ; } if ( ! eox_seen ) midi_outc ( orig_dev , 0xf7 ) ; return 0 ; }","* addr , <S2SV_ModEnd> int count , <S2SV_ModStart> != SYSEX_PATCH ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> if ( count <S2SV_ModStart> < hdr_size ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> count -= hdr_size <S2SV_ModStart> copy_from_user ( & sysex , addr , hdr_size <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> . len ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> = count ; <S2SV_ModEnd> left = sysex"
232,"static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; DECLARE_WAITQUEUE ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; LIST_HEAD ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = NULL ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == UFFD_EVENT_FORK ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - ERESTARTSYS ; break ; } if ( no_wait ) { ret = - EAGAIN ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> } <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> } } return ret ; }",fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
233,"<S2SV_StartBug> static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type , <S2SV_EndBug> <S2SV_StartBug> int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , <S2SV_EndBug> int ctx , const int16_t * scan , const int16_t * nb , <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> const int max_eob = 16 << ( tx_size << 1 ) ; <S2SV_StartBug> const FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> FRAME_COUNTS * const counts = & cm -> counts ; const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ; int band , c = 0 ; <S2SV_StartBug> const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = <S2SV_EndBug> fc -> coef_probs [ tx_size ] [ type ] [ ref ] ; <S2SV_StartBug> const vp9_prob * prob ; <S2SV_EndBug> <S2SV_StartBug> unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] = <S2SV_EndBug> counts -> coef [ tx_size ] [ type ] [ ref ] ; <S2SV_StartBug> unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] = <S2SV_EndBug> counts -> eob_branch [ tx_size ] [ type ] [ ref ] ; <S2SV_StartBug> uint8_t token_cache [ 32 * 32 ] ; <S2SV_EndBug> const uint8_t * cat6 ; const uint8_t * band_translate = get_band_translate ( tx_size ) ; const int dq_shift = ( tx_size == TX_32X32 ) ; int v ; int16_t dqv = dq [ 0 ] ; while ( c < max_eob ) { <S2SV_StartBug> int val ; <S2SV_EndBug> band = * band_translate ++ ; prob = coef_probs [ band ] [ ctx ] ; <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ eob_branch_count [ band ] [ ctx ] ; <S2SV_StartBug> if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) { <S2SV_EndBug> INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ; break ; } <S2SV_StartBug> while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) { <S2SV_EndBug> INCREMENT_COUNT ( ZERO_TOKEN ) ; dqv = dq [ 1 ] ; token_cache [ scan [ c ] ] = 0 ; ++ c ; if ( c >= max_eob ) return c ; ctx = get_coef_context ( nb , token_cache , c ) ; band = * band_translate ++ ; prob = coef_probs [ band ] [ ctx ] ; } <S2SV_StartBug> if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) { <S2SV_EndBug> INCREMENT_COUNT ( ONE_TOKEN ) ; <S2SV_StartBug> WRITE_COEF_CONTINUE ( 1 , ONE_TOKEN ) ; <S2SV_EndBug> } INCREMENT_COUNT ( TWO_TOKEN ) ; <S2SV_StartBug> prob = vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ; <S2SV_EndBug> if ( ! vp9_read ( r , prob [ LOW_VAL_CONTEXT_NODE ] ) ) { if ( ! vp9_read ( r , prob [ TWO_CONTEXT_NODE ] ) ) { WRITE_COEF_CONTINUE ( 2 , TWO_TOKEN ) ; } if ( ! vp9_read ( r , prob [ THREE_CONTEXT_NODE ] ) ) { WRITE_COEF_CONTINUE ( 3 , THREE_TOKEN ) ; } WRITE_COEF_CONTINUE ( 4 , FOUR_TOKEN ) ; } if ( ! vp9_read ( r , prob [ HIGH_LOW_CONTEXT_NODE ] ) ) { if ( ! vp9_read ( r , prob [ CAT_ONE_CONTEXT_NODE ] ) ) { val = CAT1_MIN_VAL ; ADJUST_COEF ( CAT1_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY1_TOKEN ) ; } val = CAT2_MIN_VAL ; ADJUST_COEF ( CAT2_PROB1 , 1 ) ; ADJUST_COEF ( CAT2_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY2_TOKEN ) ; } if ( ! vp9_read ( r , prob [ CAT_THREEFOUR_CONTEXT_NODE ] ) ) { if ( ! vp9_read ( r , prob [ CAT_THREE_CONTEXT_NODE ] ) ) { val = CAT3_MIN_VAL ; ADJUST_COEF ( CAT3_PROB2 , 2 ) ; ADJUST_COEF ( CAT3_PROB1 , 1 ) ; ADJUST_COEF ( CAT3_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY3_TOKEN ) ; } val = CAT4_MIN_VAL ; ADJUST_COEF ( CAT4_PROB3 , 3 ) ; ADJUST_COEF ( CAT4_PROB2 , 2 ) ; ADJUST_COEF ( CAT4_PROB1 , 1 ) ; ADJUST_COEF ( CAT4_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY4_TOKEN ) ; } if ( ! vp9_read ( r , prob [ CAT_FIVE_CONTEXT_NODE ] ) ) { val = CAT5_MIN_VAL ; ADJUST_COEF ( CAT5_PROB4 , 4 ) ; ADJUST_COEF ( CAT5_PROB3 , 3 ) ; ADJUST_COEF ( CAT5_PROB2 , 2 ) ; ADJUST_COEF ( CAT5_PROB1 , 1 ) ; ADJUST_COEF ( CAT5_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY5_TOKEN ) ; } val = 0 ; cat6 = cat6_prob ; while ( * cat6 ) val = ( val << 1 ) | vp9_read ( r , * cat6 ++ ) ; val += CAT6_MIN_VAL ; WRITE_COEF_CONTINUE ( val , CATEGORY6_TOKEN ) ; } return c ; }","int decode_coefs ( <S2SV_ModEnd> const MACROBLOCKD * <S2SV_ModStart> PLANE_TYPE type , tran_low_t <S2SV_ModEnd> * dqcoeff , <S2SV_ModStart> * nb , vpx_reader * r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModEnd> const int max_eob <S2SV_ModStart> const fc = xd -> fc <S2SV_ModEnd> ; const int <S2SV_ModStart> 0 ; const vpx_prob <S2SV_ModEnd> ( * coef_probs <S2SV_ModStart> ] ; const vpx_prob <S2SV_ModEnd> * prob ; <S2SV_ModStart> + 1 ] ; unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ; uint8_t token_cache [ 32 * 32 ] ; const uint8_t * band_translate = get_band_translate ( tx_size ) ; const int dq_shift = ( tx_size == TX_32X32 ) ; int v , token ; int16_t dqv = dq [ 0 ] ; const uint8_t * cat1_prob ; const uint8_t * cat2_prob ; const uint8_t * cat3_prob ; const uint8_t * cat4_prob ; const uint8_t * cat5_prob ; const uint8_t * cat6_prob ; if ( counts ) { coef_counts = <S2SV_ModEnd> counts -> coef <S2SV_ModStart> ref ] ; eob_branch_count = <S2SV_ModEnd> counts -> eob_branch <S2SV_ModStart> ref ] ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> bd > VPX_BITS_8 ) { if ( xd -> bd == VPX_BITS_10 ) { cat1_prob = vp9_cat1_prob_high10 ; cat2_prob = vp9_cat2_prob_high10 ; cat3_prob = vp9_cat3_prob_high10 ; cat4_prob = vp9_cat4_prob_high10 ; cat5_prob = vp9_cat5_prob_high10 ; cat6_prob = vp9_cat6_prob_high10 ; } else { cat1_prob = vp9_cat1_prob_high12 ; cat2_prob = vp9_cat2_prob_high12 ; cat3_prob = vp9_cat3_prob_high12 ; cat4_prob = vp9_cat4_prob_high12 ; cat5_prob = vp9_cat5_prob_high12 ; cat6_prob = vp9_cat6_prob_high12 ; } } else { cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; } # else cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; # endif <S2SV_ModEnd> while ( c <S2SV_ModStart> { int val = - 1 <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ eob_branch_count <S2SV_ModStart> if ( ! vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> while ( ! vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> if ( ! vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ONE_TOKEN ) ; token = ONE_TOKEN ; val = 1 ; } else { <S2SV_ModEnd> INCREMENT_COUNT ( TWO_TOKEN <S2SV_ModStart> TWO_TOKEN ) ; token = vpx_read_tree ( r , vp9_coef_con_tree , <S2SV_ModEnd> vp9_pareto8_full [ prob <S2SV_ModStart> - 1 ] ) ; switch ( token ) { case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ; break ; case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ; break ; case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ; break ; case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ; break ; case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ; break ; case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ; break ; case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( xd -> bd ) { case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; break ; case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ; break ; case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ; break ; default : assert ( 0 ) ; return - 1 ; } # else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; # endif break ; } } v = ( val * dqv ) >> dq_shift ; # if CONFIG_COEFFICIENT_RANGE_CHECKING # if CONFIG_VP9_HIGHBITDEPTH dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , xd -> bd ) ; # else dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ; # endif # else dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ; # endif token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ; ++ c ; ctx = get_coef_context ( nb , token_cache , c ) ; dqv = dq [ 1 ] <S2SV_ModEnd> ; } return"
234,"static void host_callback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct host_query * hquery = ( struct host_query * ) arg ; int addinfostatus = ARES_SUCCESS ; hquery -> timeouts += timeouts ; hquery -> remaining -- ; if ( status == ARES_SUCCESS ) { addinfostatus = ares__parse_into_addrinfo ( abuf , alen , hquery -> ai ) ; } else if ( status == ARES_EDESTRUCTION ) { end_hquery ( hquery , status ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! hquery -> remaining ) { if ( addinfostatus != ARES_SUCCESS ) { end_hquery ( hquery , addinfostatus ) ; } else if ( hquery -> ai -> nodes ) { end_hquery ( hquery , ARES_SUCCESS ) ; } else if ( status == ARES_ENOTFOUND ) { next_lookup ( hquery , status ) ; } else { end_hquery ( hquery , status ) ; } } }",status ) ; return ;
235,"<S2SV_StartBug> void vp9_fht4x4_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { __m128i in [ 4 ] ; switch ( tx_type ) { case DCT_DCT : <S2SV_StartBug> vp9_fdct4x4_sse2 ( input , output , stride ) ; <S2SV_EndBug> break ; case ADST_DCT : load_buffer_4x4 ( input , in , stride ) ; fadst4_sse2 ( in ) ; fdct4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; case DCT_ADST : load_buffer_4x4 ( input , in , stride ) ; fdct4_sse2 ( in ) ; fadst4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; case ADST_ADST : load_buffer_4x4 ( input , in , stride ) ; fadst4_sse2 ( in ) ; fadst4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; default : assert ( 0 ) ; break ; } }","* input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> case DCT_DCT : vpx_fdct4x4_sse2 <S2SV_ModEnd> ( input ,"
236,"<S2SV_StartBug> error_t mqttSnClientDisconnect ( MqttSnClientContext * context ) <S2SV_EndBug> { error_t error ; systime_t time ; if ( context == NULL ) return ERROR_INVALID_PARAMETER ; error = NO_ERROR ; while ( ! error ) { time = osGetSystemTime ( ) ; if ( context -> state == MQTT_SN_CLIENT_STATE_ACTIVE ) { context -> startTime = time ; <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> } else if ( context -> state == MQTT_SN_CLIENT_STATE_SENDING_REQ ) { if ( timeCompare ( time , context -> startTime + context -> timeout ) >= 0 ) { mqttSnClientShutdownConnection ( context ) ; error = ERROR_TIMEOUT ; } else if ( timeCompare ( time , context -> retransmitStartTime + MQTT_SN_CLIENT_RETRY_TIMEOUT ) >= 0 ) { <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> } else { error = mqttSnClientProcessEvents ( context , MQTT_SN_CLIENT_TICK_INTERVAL ) ; } } else if ( context -> state == MQTT_SN_CLIENT_STATE_DISCONNECTING ) { error = mqttSnClientShutdownConnection ( context ) ; mqttSnClientCloseConnection ( context ) ; context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTED ; } else if ( context -> state == MQTT_SN_CLIENT_STATE_DISCONNECTED ) { break ; } else { error = ERROR_WRONG_STATE ; } } if ( error != NO_ERROR && error != ERROR_WOULD_BLOCK ) { mqttSnClientCloseConnection ( context ) ; context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTED ; } return error ; }","MqttSnClientContext * context , systime_t duration <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; }"
237,"static int hfsplus_readdir ( struct file * filp , void * dirent , filldir_t filldir ) { struct inode * inode = filp -> f_path . dentry -> d_inode ; struct super_block * sb = inode -> i_sb ; int len , err ; char strbuf [ HFSPLUS_MAX_STRLEN + 1 ] ; hfsplus_cat_entry entry ; struct hfs_find_data fd ; struct hfsplus_readdir_data * rd ; u16 type ; if ( filp -> f_pos >= inode -> i_size ) return 0 ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & fd ) ; if ( err ) return err ; hfsplus_cat_build_key ( sb , fd . search_key , inode -> i_ino , NULL ) ; err = hfs_brec_find ( & fd ) ; if ( err ) goto out ; switch ( ( u32 ) filp -> f_pos ) { case 0 : if ( filldir ( dirent , ""."" , 1 , 0 , inode -> i_ino , DT_DIR ) ) goto out ; filp -> f_pos ++ ; case 1 : <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> fd . entrylength ) ; if ( be16_to_cpu ( entry . type ) != HFSPLUS_FOLDER_THREAD ) { printk ( KERN_ERR ""hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>folder<S2SV_blank>thread\\n"" ) ; err = - EIO ; goto out ; } if ( fd . entrylength < HFSPLUS_MIN_THREAD_SZ ) { printk ( KERN_ERR ""hfs:<S2SV_blank>truncated<S2SV_blank>catalog<S2SV_blank>thread\\n"" ) ; err = - EIO ; goto out ; } if ( filldir ( dirent , "".."" , 2 , 1 , be32_to_cpu ( entry . thread . parentID ) , DT_DIR ) ) goto out ; filp -> f_pos ++ ; default : if ( filp -> f_pos >= inode -> i_size ) goto out ; err = hfs_brec_goto ( & fd , filp -> f_pos - 1 ) ; if ( err ) goto out ; } for ( ; ; ) { if ( be32_to_cpu ( fd . key -> cat . parent ) != inode -> i_ino ) { printk ( KERN_ERR ""hfs:<S2SV_blank>walked<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>dir\\n"" ) ; err = - EIO ; goto out ; } <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> fd . entrylength ) ; type = be16_to_cpu ( entry . type ) ; len = HFSPLUS_MAX_STRLEN ; err = hfsplus_uni2asc ( sb , & fd . key -> cat . name , strbuf , & len ) ; if ( err ) goto out ; if ( type == HFSPLUS_FOLDER ) { if ( fd . entrylength < sizeof ( struct hfsplus_cat_folder ) ) { printk ( KERN_ERR ""hfs:<S2SV_blank>small<S2SV_blank>dir<S2SV_blank>entry\\n"" ) ; err = - EIO ; goto out ; } if ( HFSPLUS_SB ( sb ) -> hidden_dir && HFSPLUS_SB ( sb ) -> hidden_dir -> i_ino == be32_to_cpu ( entry . folder . id ) ) goto next ; if ( filldir ( dirent , strbuf , len , filp -> f_pos , be32_to_cpu ( entry . folder . id ) , DT_DIR ) ) break ; } else if ( type == HFSPLUS_FILE ) { if ( fd . entrylength < sizeof ( struct hfsplus_cat_file ) ) { printk ( KERN_ERR ""hfs:<S2SV_blank>small<S2SV_blank>file<S2SV_blank>entry\\n"" ) ; err = - EIO ; goto out ; } if ( filldir ( dirent , strbuf , len , filp -> f_pos , be32_to_cpu ( entry . file . id ) , DT_REG ) ) break ; } else { printk ( KERN_ERR ""hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>entry<S2SV_blank>type\\n"" ) ; err = - EIO ; goto out ; } next : filp -> f_pos ++ ; if ( filp -> f_pos >= inode -> i_size ) goto out ; err = hfs_brec_goto ( & fd , 1 ) ; if ( err ) goto out ; } rd = filp -> private_data ; if ( ! rd ) { rd = kmalloc ( sizeof ( struct hfsplus_readdir_data ) , GFP_KERNEL ) ; if ( ! rd ) { err = - ENOMEM ; goto out ; } filp -> private_data = rd ; rd -> file = filp ; list_add ( & rd -> list , & HFSPLUS_I ( inode ) -> open_dir_list ) ; } memcpy ( & rd -> key , fd . key , sizeof ( struct hfsplus_cat_key ) ) ; out : hfs_find_exit ( & fd ) ; return err ; }",case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; }
238,"static struct net_device * _init_airo_card ( unsigned short irq , int port , int is_pcmcia , struct pci_dev * pci , struct device * dmdev ) { struct net_device * dev ; struct airo_info * ai ; int i , rc ; CapabilityRid cap_rid ; dev = alloc_netdev ( sizeof ( * ai ) , """" , ether_setup ) ; if ( ! dev ) { airo_print_err ( """" , ""Couldn\'t<S2SV_blank>alloc_etherdev"" ) ; return NULL ; } ai = dev -> ml_priv = netdev_priv ( dev ) ; ai -> wifidev = NULL ; ai -> flags = 1 << FLAG_RADIO_DOWN ; ai -> jobs = 0 ; ai -> dev = dev ; if ( pci && ( pci -> device == 0x5000 || pci -> device == 0xa504 ) ) { airo_print_dbg ( """" , ""Found<S2SV_blank>an<S2SV_blank>MPI350<S2SV_blank>card"" ) ; set_bit ( FLAG_MPI , & ai -> flags ) ; } spin_lock_init ( & ai -> aux_lock ) ; sema_init ( & ai -> sem , 1 ) ; ai -> config . len = 0 ; ai -> pci = pci ; init_waitqueue_head ( & ai -> thr_wait ) ; ai -> tfm = NULL ; add_airo_dev ( ai ) ; if ( airo_networks_allocate ( ai ) ) goto err_out_free ; airo_networks_initialize ( ai ) ; skb_queue_head_init ( & ai -> txq ) ; if ( test_bit ( FLAG_MPI , & ai -> flags ) ) dev -> netdev_ops = & mpi_netdev_ops ; else dev -> netdev_ops = & airo_netdev_ops ; dev -> wireless_handlers = & airo_handler_def ; ai -> wireless_data . spy_data = & ai -> spy_data ; dev -> wireless_data = & ai -> wireless_data ; dev -> irq = irq ; dev -> base_addr = port ; <S2SV_StartBug> SET_NETDEV_DEV ( dev , dmdev ) ; <S2SV_EndBug> reset_card ( dev , 1 ) ; msleep ( 400 ) ; if ( ! is_pcmcia ) { if ( ! request_region ( dev -> base_addr , 64 , DRV_NAME ) ) { rc = - EBUSY ; airo_print_err ( dev -> name , ""Couldn\'t<S2SV_blank>request<S2SV_blank>region"" ) ; goto err_out_nets ; } } if ( test_bit ( FLAG_MPI , & ai -> flags ) ) { if ( mpi_map_card ( ai , pci ) ) { airo_print_err ( """" , ""Could<S2SV_blank>not<S2SV_blank>map<S2SV_blank>memory"" ) ; goto err_out_res ; } } if ( probe ) { if ( setup_card ( ai , dev -> dev_addr , 1 ) != SUCCESS ) { airo_print_err ( dev -> name , ""MAC<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>enabled"" ) ; rc = - EIO ; goto err_out_map ; } } else if ( ! test_bit ( FLAG_MPI , & ai -> flags ) ) { ai -> bap_read = fast_bap_read ; set_bit ( FLAG_FLASHING , & ai -> flags ) ; } strcpy ( dev -> name , ""eth%d"" ) ; rc = register_netdev ( dev ) ; if ( rc ) { airo_print_err ( dev -> name , ""Couldn\'t<S2SV_blank>register_netdev"" ) ; goto err_out_map ; } ai -> wifidev = init_wifidev ( ai , dev ) ; if ( ! ai -> wifidev ) goto err_out_reg ; rc = readCapabilityRid ( ai , & cap_rid , 1 ) ; if ( rc != SUCCESS ) { rc = - EIO ; goto err_out_wifi ; } ai -> wep_capable = ( cap_rid . softCap & cpu_to_le16 ( 0x02 ) ) ? 1 : 0 ; ai -> max_wep_idx = ( cap_rid . softCap & cpu_to_le16 ( 0x80 ) ) ? 3 : 0 ; airo_print_info ( dev -> name , ""Firmware<S2SV_blank>version<S2SV_blank>%x.%x.%02d"" , ( ( le16_to_cpu ( cap_rid . softVer ) >> 8 ) & 0xF ) , ( le16_to_cpu ( cap_rid . softVer ) & 0xFF ) , le16_to_cpu ( cap_rid . softSubVer ) ) ; if ( le16_to_cpu ( cap_rid . softVer ) > 0x530 || ( le16_to_cpu ( cap_rid . softVer ) == 0x530 && le16_to_cpu ( cap_rid . softSubVer ) >= 17 ) ) { airo_print_info ( ai -> dev -> name , ""WPA<S2SV_blank>supported."" ) ; set_bit ( FLAG_WPA_CAPABLE , & ai -> flags ) ; ai -> bssListFirst = RID_WPA_BSSLISTFIRST ; ai -> bssListNext = RID_WPA_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) ; } else { airo_print_info ( ai -> dev -> name , ""WPA<S2SV_blank>unsupported<S2SV_blank>with<S2SV_blank>firmware<S2SV_blank>"" ""versions<S2SV_blank>older<S2SV_blank>than<S2SV_blank>5.30.17."" ) ; ai -> bssListFirst = RID_BSSLISTFIRST ; ai -> bssListNext = RID_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) - sizeof ( BSSListRidExtra ) ; } set_bit ( FLAG_REGISTERED , & ai -> flags ) ; airo_print_info ( dev -> name , ""MAC<S2SV_blank>enabled<S2SV_blank>%pM"" , dev -> dev_addr ) ; if ( probe && ! test_bit ( FLAG_MPI , & ai -> flags ) ) for ( i = 0 ; i < MAX_FIDS ; i ++ ) ai -> fids [ i ] = transmit_allocate ( ai , AIRO_DEF_MTU , i >= MAX_FIDS / 2 ) ; if ( setup_proc_entry ( dev , dev -> ml_priv ) < 0 ) goto err_out_wifi ; return dev ; err_out_wifi : unregister_netdev ( ai -> wifidev ) ; free_netdev ( ai -> wifidev ) ; err_out_reg : unregister_netdev ( dev ) ; err_out_map : if ( test_bit ( FLAG_MPI , & ai -> flags ) && pci ) { pci_free_consistent ( pci , PCI_SHARED_LEN , ai -> shared , ai -> shared_dma ) ; iounmap ( ai -> pciaux ) ; iounmap ( ai -> pcimem ) ; mpi_unmap_card ( ai -> pci ) ; } err_out_res : if ( ! is_pcmcia ) release_region ( dev -> base_addr , 64 ) ; err_out_nets : airo_networks_free ( ai ) ; err_out_free : del_airo_dev ( ai ) ; free_netdev ( dev ) ; return NULL ; }",= port ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
239,"static void ov511_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size , fps , needed ; int interlaced = 0 ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n"" ) ; <S2SV_StartBug> sd -> gspca_dev . usb_err = - EIO ; <S2SV_EndBug> return ; } packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; reg_w ( sd , R51x_FIFO_PSIZE , packet_size >> 5 ) ; reg_w ( sd , R511_CAM_UV_EN , 0x01 ) ; reg_w ( sd , R511_SNAP_UV_EN , 0x01 ) ; reg_w ( sd , R511_SNAP_OPTS , 0x03 ) ; hsegs = ( sd -> gspca_dev . pixfmt . width >> 3 ) - 1 ; vsegs = ( sd -> gspca_dev . pixfmt . height >> 3 ) - 1 ; reg_w ( sd , R511_CAM_PXCNT , hsegs ) ; reg_w ( sd , R511_CAM_LNCNT , vsegs ) ; reg_w ( sd , R511_CAM_PXDIV , 0x00 ) ; reg_w ( sd , R511_CAM_LNDIV , 0x00 ) ; reg_w ( sd , R511_CAM_OPTS , 0x03 ) ; reg_w ( sd , R511_SNAP_PXCNT , hsegs ) ; reg_w ( sd , R511_SNAP_LNCNT , vsegs ) ; reg_w ( sd , R511_SNAP_PXDIV , 0x00 ) ; reg_w ( sd , R511_SNAP_LNDIV , 0x00 ) ; if ( frame_rate > 0 ) sd -> frame_rate = frame_rate ; switch ( sd -> sensor ) { case SEN_OV6620 : sd -> clockdiv = 3 ; break ; case SEN_OV7620 : case SEN_OV7620AE : case SEN_OV7640 : case SEN_OV7648 : case SEN_OV76BE : if ( sd -> gspca_dev . pixfmt . width == 320 ) interlaced = 1 ; case SEN_OV6630 : case SEN_OV7610 : case SEN_OV7670 : switch ( sd -> frame_rate ) { case 30 : case 25 : if ( sd -> gspca_dev . pixfmt . width != 640 ) { sd -> clockdiv = 0 ; break ; } default : sd -> clockdiv = 1 ; break ; case 10 : sd -> clockdiv = 2 ; break ; case 5 : sd -> clockdiv = 5 ; break ; } if ( interlaced ) { sd -> clockdiv = ( sd -> clockdiv + 1 ) * 2 - 1 ; if ( sd -> clockdiv > 10 ) sd -> clockdiv = 10 ; } break ; case SEN_OV8610 : sd -> clockdiv = 0 ; break ; } fps = ( interlaced ? 60 : 30 ) / ( sd -> clockdiv + 1 ) + 1 ; needed = fps * sd -> gspca_dev . pixfmt . width * sd -> gspca_dev . pixfmt . height * 3 / 2 ; if ( needed > 1000 * packet_size ) { reg_w ( sd , R511_COMP_EN , 0x07 ) ; reg_w ( sd , R511_COMP_LUT_EN , 0x03 ) ; } else { reg_w ( sd , R511_COMP_EN , 0x06 ) ; reg_w ( sd , R511_COMP_LUT_EN , 0x00 ) ; } reg_w ( sd , R51x_SYS_RESET , OV511_RESET_OMNICE ) ; reg_w ( sd , R51x_SYS_RESET , 0 ) ; }",= - EIO ; return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV
240,"struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( ""ALSA:<S2SV_blank>seq:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>ports<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%d\\n"" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , ""port-%d"" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; <S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> sprintf ( new_port -> name , ""port-%d"" , num ) ; return new_port ; }","c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> = num ; sprintf ( new_port -> name , ""port-%d"" , num ) ; <S2SV_ModStart> client -> ports_mutex <S2SV_ModEnd> ) ; return"
241,"static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }",( sk ) ; msg -> msg_namelen = 0
242,"static long btrfs_ioctl_dev_info ( struct btrfs_fs_info * fs_info , void __user * arg ) { struct btrfs_ioctl_dev_info_args * di_args ; struct btrfs_device * dev ; int ret = 0 ; char * s_uuid = NULL ; di_args = memdup_user ( arg , sizeof ( * di_args ) ) ; if ( IS_ERR ( di_args ) ) return PTR_ERR ( di_args ) ; if ( ! btrfs_is_empty_uuid ( di_args -> uuid ) ) s_uuid = di_args -> uuid ; rcu_read_lock ( ) ; dev = btrfs_find_device ( fs_info -> fs_devices , di_args -> devid , s_uuid , <S2SV_StartBug> NULL ) ; <S2SV_EndBug> if ( ! dev ) { ret = - ENODEV ; goto out ; } di_args -> devid = dev -> devid ; di_args -> bytes_used = btrfs_device_get_bytes_used ( dev ) ; di_args -> total_bytes = btrfs_device_get_total_bytes ( dev ) ; memcpy ( di_args -> uuid , dev -> uuid , sizeof ( di_args -> uuid ) ) ; if ( dev -> name ) { strncpy ( di_args -> path , rcu_str_deref ( dev -> name ) , sizeof ( di_args -> path ) - 1 ) ; di_args -> path [ sizeof ( di_args -> path ) - 1 ] = 0 ; } else { di_args -> path [ 0 ] = '\\0' ; } out : rcu_read_unlock ( ) ; if ( ret == 0 && copy_to_user ( arg , di_args , sizeof ( * di_args ) ) ) ret = - EFAULT ; kfree ( di_args ) ; return ret ; }","s_uuid , NULL , true"
243,"int ocfs2_set_acl ( handle_t * handle , struct inode * inode , struct buffer_head * di_bh , int type , struct posix_acl * acl , struct ocfs2_alloc_context * meta_ac , struct ocfs2_alloc_context * data_ac ) { int name_index ; void * value = NULL ; size_t size = 0 ; int ret ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; ret = ocfs2_acl_set_mode ( inode , di_bh , handle , mode ) ; if ( ret ) return ret ; } break ; case ACL_TYPE_DEFAULT : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ocfs2_acl_to_xattr ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } if ( handle ) ret = ocfs2_xattr_set_handle ( handle , inode , di_bh , name_index , """" , value , size , 0 , meta_ac , data_ac ) ; else ret = ocfs2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; return ret ; }","{ umode_t mode ; ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; ret ="
244,"void decnet_print ( netdissect_options * ndo , register const u_char * ap , register u_int length , register u_int caplen ) { register const union routehdr * rhp ; register int mflags ; int dst , src , hops ; u_int nsplen , pktlen ; const u_char * nspp ; if ( length < sizeof ( struct shorthdr ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } ND_TCHECK2 ( * ap , sizeof ( short ) ) ; pktlen = EXTRACT_LE_16BITS ( ap ) ; if ( pktlen < sizeof ( struct shorthdr ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } if ( pktlen > length ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } length = pktlen ; rhp = ( const union routehdr * ) & ( ap [ sizeof ( short ) ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ; mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; if ( mflags & RMF_PAD ) { u_int padlen = mflags & RMF_PADMASK ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""[pad:%d]<S2SV_blank>"" , padlen ) ) ; if ( length < padlen + 2 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } ND_TCHECK2 ( ap [ sizeof ( short ) ] , padlen ) ; ap += padlen ; length -= padlen ; caplen -= padlen ; rhp = ( const union routehdr * ) & ( ap [ sizeof ( short ) ] ) ; <S2SV_StartBug> mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; <S2SV_EndBug> } if ( mflags & RMF_FVER ) { ND_PRINT ( ( ndo , ""future-version-decnet"" ) ) ; ND_DEFAULTPRINT ( ap , min ( length , caplen ) ) ; return ; } if ( mflags & RMF_CTLMSG ) { if ( ! print_decnet_ctlmsg ( ndo , rhp , length , caplen ) ) goto trunc ; return ; } switch ( mflags & RMF_MASK ) { case RMF_LONG : if ( length < sizeof ( struct longhdr ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } ND_TCHECK ( rhp -> rh_long ) ; dst = EXTRACT_LE_16BITS ( rhp -> rh_long . lg_dst . dne_remote . dne_nodeaddr ) ; src = EXTRACT_LE_16BITS ( rhp -> rh_long . lg_src . dne_remote . dne_nodeaddr ) ; hops = EXTRACT_LE_8BITS ( rhp -> rh_long . lg_visits ) ; nspp = & ( ap [ sizeof ( short ) + sizeof ( struct longhdr ) ] ) ; nsplen = length - sizeof ( struct longhdr ) ; break ; case RMF_SHORT : ND_TCHECK ( rhp -> rh_short ) ; dst = EXTRACT_LE_16BITS ( rhp -> rh_short . sh_dst ) ; src = EXTRACT_LE_16BITS ( rhp -> rh_short . sh_src ) ; hops = ( EXTRACT_LE_8BITS ( rhp -> rh_short . sh_visits ) & VIS_MASK ) + 1 ; nspp = & ( ap [ sizeof ( short ) + sizeof ( struct shorthdr ) ] ) ; nsplen = length - sizeof ( struct shorthdr ) ; break ; default : ND_PRINT ( ( ndo , ""unknown<S2SV_blank>message<S2SV_blank>flags<S2SV_blank>under<S2SV_blank>mask"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , min ( length , caplen ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>"" , dnaddr_string ( ndo , src ) , dnaddr_string ( ndo , dst ) , pktlen ) ) ; if ( ndo -> ndo_vflag ) { if ( mflags & RMF_RQR ) ND_PRINT ( ( ndo , ""RQR<S2SV_blank>"" ) ) ; if ( mflags & RMF_RTS ) ND_PRINT ( ( ndo , ""RTS<S2SV_blank>"" ) ) ; if ( mflags & RMF_IE ) ND_PRINT ( ( ndo , ""IE<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""%d<S2SV_blank>hops<S2SV_blank>"" , hops ) ) ; } if ( ! print_nsp ( ndo , nspp , nsplen ) ) goto trunc ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; }",] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
245,"int main ( int argc , char * argv [ ] ) { int result ; int infoOnly = 0 ; int writeToStdio = 0 ; int readFromStdin = 0 ; int object_type = LC ; int def_srate = 0 ; int downMatrix = 0 ; int format = 1 ; int outputFormat = FAAD_FMT_16BIT ; int outfile_set = 0 ; int adts_out = 0 ; int old_format = 0 ; int showHelp = 0 ; int mp4file = 0 ; int noGapless = 0 ; char * fnp ; <S2SV_StartBug> char aacFileName [ 255 ] ; <S2SV_EndBug> char audioFileName [ 255 ] ; char adtsFileName [ 255 ] ; unsigned char header [ 8 ] ; float length = 0 ; FILE * hMP4File ; # ifdef _WIN32 long begin ; # else clock_t begin ; # endif unsigned long cap = NeAACDecGetCapabilities ( ) ; progName = argv [ 0 ] ; while ( 1 ) { int c = - 1 ; int option_index = 0 ; static struct option long_options [ ] = { { ""quiet"" , 0 , 0 , 'q' } , { ""outfile"" , 0 , 0 , 'o' } , { ""adtsout"" , 0 , 0 , 'a' } , { ""oldformat"" , 0 , 0 , 't' } , { ""format"" , 0 , 0 , 'f' } , { ""bits"" , 0 , 0 , 'b' } , { ""samplerate"" , 0 , 0 , 's' } , { ""objecttype"" , 0 , 0 , 'l' } , { ""downmix"" , 0 , 0 , 'd' } , { ""info"" , 0 , 0 , 'i' } , { ""stdio"" , 0 , 0 , 'w' } , { ""stdio"" , 0 , 0 , 'g' } , { ""help"" , 0 , 0 , 'h' } , { 0 , 0 , 0 , 0 } } ; c = getopt_long ( argc , argv , ""o:a:s:f:b:l:wgdhitq"" , long_options , & option_index ) ; if ( c == - 1 ) break ; switch ( c ) { case 'o' : if ( optarg ) { outfile_set = 1 ; <S2SV_StartBug> strcpy ( audioFileName , optarg ) ; <S2SV_EndBug> } break ; case 'a' : if ( optarg ) { adts_out = 1 ; <S2SV_StartBug> strcpy ( adtsFileName , optarg ) ; <S2SV_EndBug> } break ; case 's' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { def_srate = 0 ; } else { def_srate = atoi ( dr ) ; } } break ; case 'f' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { format = 1 ; } else { format = atoi ( dr ) ; if ( ( format < 1 ) || ( format > 2 ) ) showHelp = 1 ; } } break ; case 'b' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { outputFormat = FAAD_FMT_16BIT ; } else { outputFormat = atoi ( dr ) ; if ( ( outputFormat < 1 ) || ( outputFormat > 5 ) ) showHelp = 1 ; } } break ; case 'l' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { object_type = LC ; } else { object_type = atoi ( dr ) ; if ( ( object_type != LC ) && ( object_type != MAIN ) && ( object_type != LTP ) && ( object_type != LD ) ) { showHelp = 1 ; } } } break ; case 't' : old_format = 1 ; break ; case 'd' : downMatrix = 1 ; break ; case 'w' : writeToStdio = 1 ; break ; case 'g' : noGapless = 1 ; break ; case 'i' : infoOnly = 1 ; break ; case 'h' : showHelp = 1 ; break ; case 'q' : quiet = 1 ; break ; default : break ; } } faad_fprintf ( stderr , ""<S2SV_blank>***********<S2SV_blank>Ahead<S2SV_blank>Software<S2SV_blank>MPEG-4<S2SV_blank>AAC<S2SV_blank>Decoder<S2SV_blank>V%s<S2SV_blank>******************\\n\\n"" , FAAD2_VERSION ) ; faad_fprintf ( stderr , ""<S2SV_blank>Build:<S2SV_blank>%s\\n"" , __DATE__ ) ; faad_fprintf ( stderr , ""<S2SV_blank>Copyright<S2SV_blank>2002-2004:<S2SV_blank>Ahead<S2SV_blank>Software<S2SV_blank>AG\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>http://www.audiocoding.com\\n"" ) ; if ( cap & FIXED_POINT_CAP ) faad_fprintf ( stderr , ""<S2SV_blank>Fixed<S2SV_blank>point<S2SV_blank>version\\n"" ) ; else faad_fprintf ( stderr , ""<S2SV_blank>Floating<S2SV_blank>point<S2SV_blank>version\\n"" ) ; faad_fprintf ( stderr , ""\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License.\\n"" ) ; faad_fprintf ( stderr , ""\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>**************************************************************************\\n\\n"" ) ; if ( ( ( argc - optind ) < 1 ) || showHelp ) { usage ( ) ; return 1 ; } # if 0 if ( writeToStdio == 1 ) { format = 2 ; } <S2SV_StartBug> # endif <S2SV_EndBug> strcpy ( aacFileName , argv [ optind ] ) ; # ifdef _WIN32 begin = GetTickCount ( ) ; # else begin = clock ( ) ; # endif if ( ! writeToStdio && ! outfile_set ) { <S2SV_StartBug> strcpy ( audioFileName , aacFileName ) ; <S2SV_EndBug> fnp = ( char * ) strrchr ( audioFileName , '.' ) ; if ( fnp ) fnp [ 0 ] = '\\0' ; strcat ( audioFileName , file_ext [ format ] ) ; } if ( 0 == strcmp ( aacFileName , ""-"" ) ) { faad_fprintf ( stderr , ""Reading<S2SV_blank>from<S2SV_blank>stdin:<S2SV_blank>%s\\n"" , aacFileName ) ; readFromStdin = 1 ; hMP4File = stdin ; # ifdef _WIN32 setmode ( fileno ( stdin ) , O_BINARY ) ; # endif } else { mp4file = 0 ; hMP4File = fopen ( aacFileName , ""rb"" ) ; if ( ! hMP4File ) { faad_fprintf ( stderr , ""Error<S2SV_blank>opening<S2SV_blank>file:<S2SV_blank>%s\\n"" , aacFileName ) ; return 1 ; } } fread ( header , 1 , 8 , hMP4File ) ; if ( ! readFromStdin ) fclose ( hMP4File ) ; if ( header [ 4 ] == 'f' && header [ 5 ] == 't' && header [ 6 ] == 'y' && header [ 7 ] == 'p' ) mp4file = 1 ; if ( mp4file ) { result = decodeMP4file ( aacFileName , audioFileName , adtsFileName , writeToStdio , outputFormat , format , downMatrix , noGapless , infoOnly , adts_out , & length ) ; } else { if ( readFromStdin == 1 ) { ungetc ( header [ 7 ] , hMP4File ) ; ungetc ( header [ 6 ] , hMP4File ) ; ungetc ( header [ 5 ] , hMP4File ) ; ungetc ( header [ 4 ] , hMP4File ) ; ungetc ( header [ 3 ] , hMP4File ) ; ungetc ( header [ 2 ] , hMP4File ) ; ungetc ( header [ 1 ] , hMP4File ) ; ungetc ( header [ 0 ] , hMP4File ) ; } result = decodeAACfile ( aacFileName , audioFileName , adtsFileName , writeToStdio , def_srate , object_type , outputFormat , format , downMatrix , infoOnly , adts_out , old_format , & length ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! result && ! infoOnly ) { # ifdef _WIN32 float dec_length = ( float ) ( GetTickCount ( ) - begin ) / 1000.0 ; SetConsoleTitle ( ""FAAD"" ) ; # else float dec_length = ( float ) ( clock ( ) - begin ) / ( float ) CLOCKS_PER_SEC ; # endif faad_fprintf ( stderr , ""Decoding<S2SV_blank>%s<S2SV_blank>took:<S2SV_blank>%5.2f<S2SV_blank>sec.<S2SV_blank>%5.2fx<S2SV_blank>real-time.\\n"" , aacFileName , dec_length , length / dec_length ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","fnp ; char * aacFileName = NULL ; char * audioFileName = NULL ; char * adtsFileName = NULL <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> = 1 ; audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> = 1 ; adtsFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( adtsFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>adtsFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> } # endif aacFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( argv [ optind ] ) + 1 ) ) ; if ( aacFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>aacFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> outfile_set ) { audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( aacFileName ) + strlen ( file_ext [ format ] ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> ) ; } if ( audioFileName != NULL ) free ( audioFileName ) ; if ( adtsFileName != NULL ) free ( adtsFileName ) ; <S2SV_ModStart> ) ; } if ( aacFileName != NULL ) free ( aacFileName ) ;"
246,"static void put_crypt_info ( struct fscrypt_info * ci ) { if ( ! ci ) return ; <S2SV_StartBug> key_put ( ci -> ci_keyring_key ) ; <S2SV_EndBug> crypto_free_skcipher ( ci -> ci_ctfm ) ; kmem_cache_free ( fscrypt_info_cachep , ci ) ; }",) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci
247,"static rsRetVal createSocket ( instanceConf_t * info , void * * sock ) { int rv ; sublist * sub ; * sock = zsocket_new ( s_context , info -> type ) ; if ( ! sock ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zsocket_new<S2SV_blank>failed:<S2SV_blank>%s,<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%d"" , zmq_strerror ( errno ) , info -> type ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>socket<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>created<S2SV_blank>successfully\\n"" , info -> type ) if ( info -> identity ) zsocket_set_identity ( * sock , info -> identity ) ; if ( info -> sndBuf > - 1 ) zsocket_set_sndbuf ( * sock , info -> sndBuf ) ; if ( info -> rcvBuf > - 1 ) zsocket_set_rcvbuf ( * sock , info -> rcvBuf ) ; if ( info -> linger > - 1 ) zsocket_set_linger ( * sock , info -> linger ) ; if ( info -> backlog > - 1 ) zsocket_set_backlog ( * sock , info -> backlog ) ; if ( info -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( * sock , info -> sndTimeout ) ; if ( info -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( * sock , info -> rcvTimeout ) ; if ( info -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( * sock , info -> maxMsgSize ) ; if ( info -> rate > - 1 ) zsocket_set_rate ( * sock , info -> rate ) ; if ( info -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( * sock , info -> recoveryIVL ) ; if ( info -> multicastHops > - 1 ) zsocket_set_multicast_hops ( * sock , info -> multicastHops ) ; if ( info -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( * sock , info -> reconnectIVL ) ; if ( info -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( * sock , info -> reconnectIVLMax ) ; if ( info -> ipv4Only > - 1 ) zsocket_set_ipv4only ( * sock , info -> ipv4Only ) ; if ( info -> affinity > - 1 ) zsocket_set_affinity ( * sock , info -> affinity ) ; if ( info -> sndHWM > - 1 ) zsocket_set_sndhwm ( * sock , info -> sndHWM ) ; if ( info -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( * sock , info -> rcvHWM ) ; if ( info -> type == ZMQ_SUB ) { for ( sub = info -> subscriptions ; sub != NULL ; sub = sub -> next ) { zsocket_set_subscribe ( * sock , sub -> subscribe ) ; } } if ( info -> action == ACTION_CONNECT ) { <S2SV_StartBug> rv = zsocket_connect ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zmq_connect<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s"" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>connect<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n"" , info -> description ) ; } else { <S2SV_StartBug> rv = zsocket_bind ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zmq_bind<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s"" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>bind<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n"" , info -> description ) ; } return RS_RET_OK ; }","* sock , ""%s"" , <S2SV_ModStart> * sock , ""%s"" ,"
248,"static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; struct ipv6hdr * ipv6h ; const struct net_offload * ops ; int proto ; struct frag_hdr * fptr ; unsigned int unfrag_ip6hlen ; unsigned int payload_len ; u8 * prevhdr ; int offset = 0 ; bool encap , udpfrag ; int nhoff ; bool gso_partial ; skb_reset_network_header ( skb ) ; nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) goto out ; encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; if ( encap ) features &= skb -> dev -> hw_enc_features ; SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; ipv6h = ipv6_hdr ( skb ) ; __skb_pull ( skb , sizeof ( * ipv6h ) ) ; segs = ERR_PTR ( - EPROTONOSUPPORT ) ; proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) udpfrag = proto == IPPROTO_UDP && encap ; else udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; ops = rcu_dereference ( inet6_offloads [ proto ] ) ; if ( likely ( ops && ops -> callbacks . gso_segment ) ) { skb_reset_transport_header ( skb ) ; segs = ops -> callbacks . gso_segment ( skb , features ) ; } if ( IS_ERR_OR_NULL ( segs ) ) goto out ; gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; for ( skb = segs ; skb ; skb = skb -> next ) { ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; if ( gso_partial ) payload_len = skb_shinfo ( skb ) -> gso_size + SKB_GSO_CB ( skb ) -> data_offset + skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; else payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; ipv6h -> payload_len = htons ( payload_len ) ; skb -> network_header = ( u8 * ) ipv6h - skb -> head ; if ( udpfrag ) { unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> fptr -> frag_off = htons ( offset ) ; if ( skb -> next ) fptr -> frag_off |= htons ( IP6_MF ) ; offset += ( ntohs ( ipv6h -> payload_len ) - sizeof ( struct frag_hdr ) ) ; } if ( encap ) skb_reset_inner_headers ( skb ) ; } out : return segs ; }",prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
249,"struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n"" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n"" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n"" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( ""Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n"" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( ""Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n"" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( ""Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n"" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }",; if ( <S2SV_ModEnd> atomic_read ( &
250,"static void flatpak_proxy_client_init ( FlatpakProxyClient * client ) { init_side ( client , & client -> client_side ) ; init_side ( client , & client -> bus_side ) ; <S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client -> get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; client -> unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ; }",; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client ->
251,"int generic_permission ( struct inode * inode , int mask ) { int ret ; ret = acl_permission_check ( inode , mask ) ; if ( ret != - EACCES ) return ret ; if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; if ( ! ( mask & MAY_WRITE ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; } if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; mask &= MAY_READ | MAY_WRITE | MAY_EXEC ; if ( mask == MAY_READ ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; }","{ if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,"
252,"Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; } <S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }","NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;"
253,"static int do_ip_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct inet_sock * inet = inet_sk ( sk ) ; int val = 0 , err ; if ( ( ( 1 << optname ) & ( ( 1 << IP_PKTINFO ) | ( 1 << IP_RECVTTL ) | ( 1 << IP_RECVOPTS ) | ( 1 << IP_RECVTOS ) | ( 1 << IP_RETOPTS ) | ( 1 << IP_TOS ) | ( 1 << IP_TTL ) | ( 1 << IP_HDRINCL ) | ( 1 << IP_MTU_DISCOVER ) | ( 1 << IP_RECVERR ) | ( 1 << IP_ROUTER_ALERT ) | ( 1 << IP_FREEBIND ) | ( 1 << IP_PASSSEC ) | ( 1 << IP_TRANSPARENT ) | ( 1 << IP_MINTTL ) | ( 1 << IP_NODEFRAG ) ) ) || optname == IP_MULTICAST_TTL || optname == IP_MULTICAST_ALL || optname == IP_MULTICAST_LOOP || optname == IP_RECVORIGDSTADDR ) { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else if ( optlen >= sizeof ( char ) ) { unsigned char ucval ; if ( get_user ( ucval , ( unsigned char __user * ) optval ) ) return - EFAULT ; val = ( int ) ucval ; } } if ( ip_mroute_opt ( optname ) ) return ip_mroute_setsockopt ( sk , optname , optval , optlen ) ; err = 0 ; lock_sock ( sk ) ; switch ( optname ) { case IP_OPTIONS : { <S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> if ( optlen > 40 ) goto e_inval ; err = ip_options_get_from_user ( sock_net ( sk ) , & opt , optval , optlen ) ; if ( err ) <S2SV_StartBug> break ; <S2SV_EndBug> if ( inet -> is_icsk ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; # if defined ( CONFIG_IPV6 ) || defined ( CONFIG_IPV6_MODULE ) if ( sk -> sk_family == PF_INET || ( ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet -> inet_daddr != LOOPBACK4_IPV6 ) ) { # endif <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len -= inet -> opt -> optlen ; <S2SV_EndBug> if ( opt ) <S2SV_StartBug> icsk -> icsk_ext_hdr_len += opt -> optlen ; <S2SV_EndBug> icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; # if defined ( CONFIG_IPV6 ) || defined ( CONFIG_IPV6_MODULE ) } # endif } <S2SV_StartBug> opt = xchg ( & inet -> opt , opt ) ; <S2SV_EndBug> kfree ( opt ) ; break ; } case IP_PKTINFO : if ( val ) inet -> cmsg_flags |= IP_CMSG_PKTINFO ; else inet -> cmsg_flags &= ~ IP_CMSG_PKTINFO ; break ; case IP_RECVTTL : if ( val ) inet -> cmsg_flags |= IP_CMSG_TTL ; else inet -> cmsg_flags &= ~ IP_CMSG_TTL ; break ; case IP_RECVTOS : if ( val ) inet -> cmsg_flags |= IP_CMSG_TOS ; else inet -> cmsg_flags &= ~ IP_CMSG_TOS ; break ; case IP_RECVOPTS : if ( val ) inet -> cmsg_flags |= IP_CMSG_RECVOPTS ; else inet -> cmsg_flags &= ~ IP_CMSG_RECVOPTS ; break ; case IP_RETOPTS : if ( val ) inet -> cmsg_flags |= IP_CMSG_RETOPTS ; else inet -> cmsg_flags &= ~ IP_CMSG_RETOPTS ; break ; case IP_PASSSEC : if ( val ) inet -> cmsg_flags |= IP_CMSG_PASSSEC ; else inet -> cmsg_flags &= ~ IP_CMSG_PASSSEC ; break ; case IP_RECVORIGDSTADDR : if ( val ) inet -> cmsg_flags |= IP_CMSG_ORIGDSTADDR ; else inet -> cmsg_flags &= ~ IP_CMSG_ORIGDSTADDR ; break ; case IP_TOS : if ( sk -> sk_type == SOCK_STREAM ) { val &= ~ 3 ; val |= inet -> tos & 3 ; } if ( inet -> tos != val ) { inet -> tos = val ; sk -> sk_priority = rt_tos2priority ( val ) ; sk_dst_reset ( sk ) ; } break ; case IP_TTL : if ( optlen < 1 ) goto e_inval ; if ( val != - 1 && ( val < 0 || val > 255 ) ) goto e_inval ; inet -> uc_ttl = val ; break ; case IP_HDRINCL : if ( sk -> sk_type != SOCK_RAW ) { err = - ENOPROTOOPT ; break ; } inet -> hdrincl = val ? 1 : 0 ; break ; case IP_NODEFRAG : if ( sk -> sk_type != SOCK_RAW ) { err = - ENOPROTOOPT ; break ; } inet -> nodefrag = val ? 1 : 0 ; break ; case IP_MTU_DISCOVER : if ( val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE ) goto e_inval ; inet -> pmtudisc = val ; break ; case IP_RECVERR : inet -> recverr = ! ! val ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; break ; case IP_MULTICAST_TTL : if ( sk -> sk_type == SOCK_STREAM ) goto e_inval ; if ( optlen < 1 ) goto e_inval ; if ( val == - 1 ) val = 1 ; if ( val < 0 || val > 255 ) goto e_inval ; inet -> mc_ttl = val ; break ; case IP_MULTICAST_LOOP : if ( optlen < 1 ) goto e_inval ; inet -> mc_loop = ! ! val ; break ; case IP_MULTICAST_IF : { struct ip_mreqn mreq ; struct net_device * dev = NULL ; if ( sk -> sk_type == SOCK_STREAM ) goto e_inval ; if ( optlen < sizeof ( struct in_addr ) ) goto e_inval ; err = - EFAULT ; if ( optlen >= sizeof ( struct ip_mreqn ) ) { if ( copy_from_user ( & mreq , optval , sizeof ( mreq ) ) ) break ; } else { memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( optlen >= sizeof ( struct in_addr ) && copy_from_user ( & mreq . imr_address , optval , sizeof ( struct in_addr ) ) ) break ; } if ( ! mreq . imr_ifindex ) { if ( mreq . imr_address . s_addr == htonl ( INADDR_ANY ) ) { inet -> mc_index = 0 ; inet -> mc_addr = 0 ; err = 0 ; break ; } dev = ip_dev_find ( sock_net ( sk ) , mreq . imr_address . s_addr ) ; if ( dev ) mreq . imr_ifindex = dev -> ifindex ; } else dev = dev_get_by_index ( sock_net ( sk ) , mreq . imr_ifindex ) ; err = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; err = - EINVAL ; if ( sk -> sk_bound_dev_if && mreq . imr_ifindex != sk -> sk_bound_dev_if ) break ; inet -> mc_index = mreq . imr_ifindex ; inet -> mc_addr = mreq . imr_address . s_addr ; err = 0 ; break ; } case IP_ADD_MEMBERSHIP : case IP_DROP_MEMBERSHIP : { struct ip_mreqn mreq ; err = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; if ( optlen < sizeof ( struct ip_mreq ) ) goto e_inval ; err = - EFAULT ; if ( optlen >= sizeof ( struct ip_mreqn ) ) { if ( copy_from_user ( & mreq , optval , sizeof ( mreq ) ) ) break ; } else { memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ip_mreq ) ) ) break ; } if ( optname == IP_ADD_MEMBERSHIP ) err = ip_mc_join_group ( sk , & mreq ) ; else err = ip_mc_leave_group ( sk , & mreq ) ; break ; } case IP_MSFILTER : { struct ip_msfilter * msf ; if ( optlen < IP_MSFILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { err = - ENOBUFS ; break ; } msf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! msf ) { err = - ENOBUFS ; break ; } err = - EFAULT ; if ( copy_from_user ( msf , optval , optlen ) ) { kfree ( msf ) ; break ; } if ( msf -> imsf_numsrc >= 0x3ffffffcU || msf -> imsf_numsrc > sysctl_igmp_max_msf ) { kfree ( msf ) ; err = - ENOBUFS ; break ; } if ( IP_MSFILTER_SIZE ( msf -> imsf_numsrc ) > optlen ) { kfree ( msf ) ; err = - EINVAL ; break ; } err = ip_mc_msfilter ( sk , msf , 0 ) ; kfree ( msf ) ; break ; } case IP_BLOCK_SOURCE : case IP_UNBLOCK_SOURCE : case IP_ADD_SOURCE_MEMBERSHIP : case IP_DROP_SOURCE_MEMBERSHIP : { struct ip_mreq_source mreqs ; int omode , add ; if ( optlen != sizeof ( struct ip_mreq_source ) ) goto e_inval ; if ( copy_from_user ( & mreqs , optval , sizeof ( mreqs ) ) ) { err = - EFAULT ; break ; } if ( optname == IP_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == IP_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == IP_ADD_SOURCE_MEMBERSHIP ) { struct ip_mreqn mreq ; mreq . imr_multiaddr . s_addr = mreqs . imr_multiaddr ; mreq . imr_address . s_addr = mreqs . imr_interface ; mreq . imr_ifindex = 0 ; err = ip_mc_join_group ( sk , & mreq ) ; if ( err && err != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } err = ip_mc_source ( add , omode , sk , & mreqs , 0 ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in * psin ; struct ip_mreqn mreq ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; err = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( greq ) ) ) break ; psin = ( struct sockaddr_in * ) & greq . gr_group ; if ( psin -> sin_family != AF_INET ) goto e_inval ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; mreq . imr_multiaddr = psin -> sin_addr ; mreq . imr_ifindex = greq . gr_interface ; if ( optname == MCAST_JOIN_GROUP ) err = ip_mc_join_group ( sk , & mreq ) ; else err = ip_mc_leave_group ( sk , & mreq ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; struct ip_mreq_source mreqs ; struct sockaddr_in * psin ; int omode , add ; if ( optlen != sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { err = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET || greqs . gsr_source . ss_family != AF_INET ) { err = - EADDRNOTAVAIL ; break ; } psin = ( struct sockaddr_in * ) & greqs . gsr_group ; mreqs . imr_multiaddr = psin -> sin_addr . s_addr ; psin = ( struct sockaddr_in * ) & greqs . gsr_source ; mreqs . imr_sourceaddr = psin -> sin_addr . s_addr ; mreqs . imr_interface = 0 ; if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct ip_mreqn mreq ; psin = ( struct sockaddr_in * ) & greqs . gsr_group ; mreq . imr_multiaddr = psin -> sin_addr ; mreq . imr_address . s_addr = 0 ; mreq . imr_ifindex = greqs . gsr_interface ; err = ip_mc_join_group ( sk , & mreq ) ; if ( err && err != - EADDRINUSE ) break ; greqs . gsr_interface = mreq . imr_ifindex ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } err = ip_mc_source ( add , omode , sk , & mreqs , greqs . gsr_interface ) ; break ; } case MCAST_MSFILTER : { struct sockaddr_in * psin ; struct ip_msfilter * msf = NULL ; struct group_filter * gsf = NULL ; int msize , i , ifindex ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { err = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { err = - ENOBUFS ; break ; } err = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) goto mc_msf_out ; if ( gsf -> gf_numsrc >= 0x1ffffff || gsf -> gf_numsrc > sysctl_igmp_max_msf ) { err = - ENOBUFS ; goto mc_msf_out ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { err = - EINVAL ; goto mc_msf_out ; } msize = IP_MSFILTER_SIZE ( gsf -> gf_numsrc ) ; msf = kmalloc ( msize , GFP_KERNEL ) ; if ( ! msf ) { err = - ENOBUFS ; goto mc_msf_out ; } ifindex = gsf -> gf_interface ; psin = ( struct sockaddr_in * ) & gsf -> gf_group ; if ( psin -> sin_family != AF_INET ) { err = - EADDRNOTAVAIL ; goto mc_msf_out ; } msf -> imsf_multiaddr = psin -> sin_addr . s_addr ; msf -> imsf_interface = 0 ; msf -> imsf_fmode = gsf -> gf_fmode ; msf -> imsf_numsrc = gsf -> gf_numsrc ; err = - EADDRNOTAVAIL ; for ( i = 0 ; i < gsf -> gf_numsrc ; ++ i ) { psin = ( struct sockaddr_in * ) & gsf -> gf_slist [ i ] ; if ( psin -> sin_family != AF_INET ) goto mc_msf_out ; msf -> imsf_slist [ i ] = psin -> sin_addr . s_addr ; } kfree ( gsf ) ; gsf = NULL ; err = ip_mc_msfilter ( sk , msf , ifindex ) ; mc_msf_out : kfree ( msf ) ; kfree ( gsf ) ; break ; } case IP_MULTICAST_ALL : if ( optlen < 1 ) goto e_inval ; if ( val != 0 && val != 1 ) goto e_inval ; inet -> mc_all = val ; break ; case IP_ROUTER_ALERT : err = ip_ra_control ( sk , val ? 1 : 0 , NULL ) ; break ; case IP_FREEBIND : if ( optlen < 1 ) goto e_inval ; inet -> freebind = ! ! val ; break ; case IP_IPSEC_POLICY : case IP_XFRM_POLICY : err = - EPERM ; if ( ! capable ( CAP_NET_ADMIN ) ) break ; err = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IP_TRANSPARENT : if ( ! capable ( CAP_NET_ADMIN ) ) { err = - EPERM ; break ; } if ( optlen < 1 ) goto e_inval ; inet -> transparent = ! ! val ; break ; case IP_MINTTL : if ( optlen < 1 ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; inet -> min_ttl = val ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; e_inval : release_sock ( sk ) ; return - EINVAL ; }",": { struct ip_options_rcu * old , <S2SV_ModEnd> * opt = <S2SV_ModStart> err ) break ; old = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) <S2SV_ModStart> endif if ( old <S2SV_ModEnd> ) icsk -> <S2SV_ModStart> -> icsk_ext_hdr_len -= old -> opt . <S2SV_ModEnd> optlen ; if <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> # endif } rcu_assign_pointer ( inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; break"
254,"static void <S2SV_StartBug> l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_CAP_ASYNC_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_CAP_SYNC_MASK ) { ND_PRINT ( ( ndo , ""S"" ) ) ; } }","u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }"
255,"static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? ""POST"" : ""GET"" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , ""Received<S2SV_blank>method:<S2SV_blank>%s\\n"" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , ""Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\n"" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , ""Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\n"" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , ""Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\n"" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , ""Requested<S2SV_blank>resource:<S2SV_blank>%s\\n"" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\0' ; if ( av_strncasecmp ( version , ""HTTP/"" , 5 ) ) { av_log ( h , AV_LOG_ERROR , ""Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\n"" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , ""HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\n"" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , ""http_code=%d\\n"" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , ""Location"" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , ""Content-Range"" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , ""Accept-Ranges"" ) && ! strncmp ( p , ""bytes"" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , ""Transfer-Encoding"" ) && ! av_strncasecmp ( p , ""chunked"" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'%s\'\\n"" , p ) ; } else if ( ! av_strcasecmp ( tag , ""Icy-MetaInt"" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , ""Icy-"" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , ""Content-Encoding"" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }","-> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,"
256,"MagickExport void * AcquireQuantumMemory ( const size_t count , const size_t quantum ) { size_t extent ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; extent = count * quantum ; return ( AcquireMagickMemory ( extent ) ) ; }","; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,"
257,"int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & ( ATTR_UID | ATTR_GID ) ) { iuid = inode -> i_uid ; igid = inode -> i_gid ; gid = ( mask & ATTR_GID ) ? iattr -> ia_gid : igid ; uid = ( mask & ATTR_UID ) ? iattr -> ia_uid : iuid ; if ( XFS_IS_QUOTA_RUNNING ( mp ) && ( ( XFS_IS_UQUOTA_ON ( mp ) && ! uid_eq ( iuid , uid ) ) || ( XFS_IS_GQUOTA_ON ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { ASSERT ( tp ) ; error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , NULL , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( error ) goto out_cancel ; } } if ( mask & ( ATTR_UID | ATTR_GID ) ) { if ( ( inode -> i_mode & ( S_ISUID | S_ISGID ) ) && ! capable ( CAP_FSETID ) ) inode -> i_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( ! uid_eq ( iuid , uid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_UQUOTA_ON ( mp ) ) { ASSERT ( mask & ATTR_UID ) ; ASSERT ( udqp ) ; olddquot1 = xfs_qm_vop_chown ( tp , ip , & ip -> i_udquot , udqp ) ; } ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; inode -> i_uid = uid ; } if ( ! gid_eq ( igid , gid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_GQUOTA_ON ( mp ) ) { ASSERT ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || ! XFS_IS_PQUOTA_ON ( mp ) ) ; ASSERT ( mask & ATTR_GID ) ; ASSERT ( gdqp ) ; olddquot2 = xfs_qm_vop_chown ( tp , ip , & ip -> i_gdquot , gdqp ) ; } ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; inode -> i_gid = gid ; } } if ( mask & ATTR_MODE ) xfs_setattr_mode ( ip , iattr ) ; if ( mask & ( ATTR_ATIME | ATTR_CTIME | ATTR_MTIME ) ) xfs_setattr_time ( ip , iattr ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( mp , xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; error = xfs_trans_commit ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; xfs_qm_dqrele ( olddquot1 ) ; xfs_qm_dqrele ( olddquot2 ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; if ( error ) return error ; if ( ( mask & ATTR_MODE ) && ! ( flags & XFS_ATTR_NOACL ) ) { error = posix_acl_chmod ( inode , inode -> i_mode ) ; if ( error ) return error ; } return 0 ; out_cancel : xfs_trans_cancel ( tp ) ; <S2SV_StartBug> out_dqrele : <S2SV_EndBug> xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; return error ; }","tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;"
258,"static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <S2SV_StartBug> case 'c' : return getnum ( fmt , 1 ) ; <S2SV_EndBug> case 'i' : case 'I' : { <S2SV_StartBug> int sz = getnum ( fmt , sizeof ( int ) ) ; <S2SV_EndBug> if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }","return getnum ( L , <S2SV_ModStart> = getnum ( L ,"
259,"static void mt_decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above ; unsigned char * yleft ; int left_stride ; unsigned char top_left ; if ( i < 4 && pbi -> common . filter_level ) Above = xd -> recon_above [ 0 ] + b -> offset ; else Above = dst - dst_stride ; if ( i % 4 == 0 && pbi -> common . filter_level ) { yleft = xd -> recon_left [ 0 ] + i ; left_stride = 1 ; } else { yleft = dst - 1 ; left_stride = dst_stride ; } if ( ( i == 4 || i == 8 || i == 12 ) && pbi -> common . filter_level ) top_left = * ( xd -> recon_left [ 0 ] + i - 1 ) ; else top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }",0 ; # else ( void ) mb_idx ; # <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> . mb_skip_coeff ) memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> dst_stride ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b ->
260,"void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> while ( tptr < ( pptr + length ) ) { <S2SV_EndBug> len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; ND_TCHECK ( * vtp_vlan ) ; ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; while ( len > 0 ) { type = * tptr ; tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; if ( type == 0 || tlv_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } len -= 2 + tlv_len * 2 ; tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }",case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ) ) { ND_TCHECK_8BITS ( tptr ) ;
261,"sf_count_t psf_fwrite ( const void * ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE * psf ) { sf_count_t total = 0 ; <S2SV_StartBug> ssize_t count ; <S2SV_EndBug> if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ; items *= bytes ; if ( items <= 0 ) return 0 ; while ( items > 0 ) { count = ( items > SENSIBLE_SIZE ) ? SENSIBLE_SIZE : items ; count = write ( psf -> file . filedes , ( ( const char * ) ptr ) + total , count ) ; if ( count == - 1 ) { if ( errno == EINTR ) continue ; psf_log_syserr ( psf , errno ) ; break ; } ; if ( count == 0 ) break ; total += count ; items -= count ; } ; if ( psf -> is_pipe ) psf -> pipeoffset += total ; return total / bytes ; }",; ssize_t count ; if ( bytes == 0 || items == 0 ) return 0
262,"static void handle_mlppp ( netdissect_options * ndo , const u_char * p , int length ) { if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""MLPPP,<S2SV_blank>"" ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ; }",") ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; }"
263,"static int parse_codes ( struct archive_read * a ) { int i , j , val , n , r ; unsigned char bitlengths [ MAX_SYMBOLS ] , zerocount , ppmd_flags ; unsigned int maxorder ; struct huffman_code precode ; struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; struct rar_br * br = & ( rar -> br ) ; free_codes ( a ) ; rar_br_consume_unalined_bits ( br ) ; if ( ! rar_br_read_ahead ( a , br , 1 ) ) goto truncated_data ; if ( ( rar -> is_ppmd_block = rar_br_bits ( br , 1 ) ) != 0 ) { rar_br_consume ( br , 1 ) ; if ( ! rar_br_read_ahead ( a , br , 7 ) ) goto truncated_data ; ppmd_flags = rar_br_bits ( br , 7 ) ; rar_br_consume ( br , 7 ) ; if ( ppmd_flags & 0x20 ) { if ( ! rar_br_read_ahead ( a , br , 8 ) ) goto truncated_data ; rar -> dictionary_size = ( rar_br_bits ( br , 8 ) + 1 ) << 20 ; rar_br_consume ( br , 8 ) ; } if ( ppmd_flags & 0x40 ) { if ( ! rar_br_read_ahead ( a , br , 8 ) ) goto truncated_data ; rar -> ppmd_escape = rar -> ppmd7_context . InitEsc = rar_br_bits ( br , 8 ) ; rar_br_consume ( br , 8 ) ; } else rar -> ppmd_escape = 2 ; if ( ppmd_flags & 0x20 ) { maxorder = ( ppmd_flags & 0x1F ) + 1 ; if ( maxorder > 16 ) maxorder = 16 + ( maxorder - 16 ) * 3 ; if ( maxorder == 1 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>RAR<S2SV_blank>file<S2SV_blank>data"" ) ; return ( ARCHIVE_FATAL ) ; } __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> bytein . a = a ; rar -> bytein . Read = & ppmd_read ; __archive_ppmd7_functions . PpmdRAR_RangeDec_CreateVTable ( & rar -> range_dec ) ; rar -> range_dec . Stream = & rar -> bytein ; __archive_ppmd7_functions . Ppmd7_Construct ( & rar -> ppmd7_context ) ; <S2SV_StartBug> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , <S2SV_EndBug> rar -> dictionary_size , & g_szalloc ) ) { archive_set_error ( & a -> archive , ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ( ARCHIVE_FATAL ) ; } if ( ! __archive_ppmd7_functions . PpmdRAR_RangeDec_Init ( & rar -> range_dec ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PPMd<S2SV_blank>range<S2SV_blank>decoder"" ) ; return ( ARCHIVE_FATAL ) ; } __archive_ppmd7_functions . Ppmd7_Init ( & rar -> ppmd7_context , maxorder ) ; rar -> ppmd_valid = 1 ; } else { if ( ! rar -> ppmd_valid ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>PPMd<S2SV_blank>sequence"" ) ; return ( ARCHIVE_FATAL ) ; } if ( ! __archive_ppmd7_functions . PpmdRAR_RangeDec_Init ( & rar -> range_dec ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PPMd<S2SV_blank>range<S2SV_blank>decoder"" ) ; return ( ARCHIVE_FATAL ) ; } } } else { rar_br_consume ( br , 1 ) ; if ( ! rar_br_read_ahead ( a , br , 1 ) ) goto truncated_data ; if ( ! rar_br_bits ( br , 1 ) ) memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; rar_br_consume ( br , 1 ) ; memset ( & bitlengths , 0 , sizeof ( bitlengths ) ) ; for ( i = 0 ; i < MAX_SYMBOLS ; ) { if ( ! rar_br_read_ahead ( a , br , 4 ) ) goto truncated_data ; bitlengths [ i ++ ] = rar_br_bits ( br , 4 ) ; rar_br_consume ( br , 4 ) ; if ( bitlengths [ i - 1 ] == 0xF ) { if ( ! rar_br_read_ahead ( a , br , 4 ) ) goto truncated_data ; zerocount = rar_br_bits ( br , 4 ) ; rar_br_consume ( br , 4 ) ; if ( zerocount ) { i -- ; for ( j = 0 ; j < zerocount + 2 && i < MAX_SYMBOLS ; j ++ ) bitlengths [ i ++ ] = 0 ; } } } memset ( & precode , 0 , sizeof ( precode ) ) ; r = create_code ( a , & precode , bitlengths , MAX_SYMBOLS , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) { free ( precode . tree ) ; free ( precode . table ) ; return ( r ) ; } for ( i = 0 ; i < HUFFMAN_TABLE_SIZE ; ) { if ( ( val = read_next_symbol ( a , & precode ) ) < 0 ) { free ( precode . tree ) ; free ( precode . table ) ; return ( ARCHIVE_FATAL ) ; } if ( val < 16 ) { rar -> lengthtable [ i ] = ( rar -> lengthtable [ i ] + val ) & 0xF ; i ++ ; } else if ( val < 18 ) { if ( i == 0 ) { free ( precode . tree ) ; free ( precode . table ) ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Internal<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>RAR<S2SV_blank>file."" ) ; return ( ARCHIVE_FATAL ) ; } if ( val == 16 ) { if ( ! rar_br_read_ahead ( a , br , 3 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 3 ) + 3 ; rar_br_consume ( br , 3 ) ; } else { if ( ! rar_br_read_ahead ( a , br , 7 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 7 ) + 11 ; rar_br_consume ( br , 7 ) ; } for ( j = 0 ; j < n && i < HUFFMAN_TABLE_SIZE ; j ++ ) { rar -> lengthtable [ i ] = rar -> lengthtable [ i - 1 ] ; i ++ ; } } else { if ( val == 18 ) { if ( ! rar_br_read_ahead ( a , br , 3 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 3 ) + 3 ; rar_br_consume ( br , 3 ) ; } else { if ( ! rar_br_read_ahead ( a , br , 7 ) ) { free ( precode . tree ) ; free ( precode . table ) ; goto truncated_data ; } n = rar_br_bits ( br , 7 ) + 11 ; rar_br_consume ( br , 7 ) ; } for ( j = 0 ; j < n && i < HUFFMAN_TABLE_SIZE ; j ++ ) rar -> lengthtable [ i ++ ] = 0 ; } } free ( precode . tree ) ; free ( precode . table ) ; r = create_code ( a , & rar -> maincode , & rar -> lengthtable [ 0 ] , MAINCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; r = create_code ( a , & rar -> offsetcode , & rar -> lengthtable [ MAINCODE_SIZE ] , OFFSETCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; r = create_code ( a , & rar -> lowoffsetcode , & rar -> lengthtable [ MAINCODE_SIZE + OFFSETCODE_SIZE ] , LOWOFFSETCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; r = create_code ( a , & rar -> lengthcode , & rar -> lengthtable [ MAINCODE_SIZE + OFFSETCODE_SIZE + LOWOFFSETCODE_SIZE ] , LENGTHCODE_SIZE , MAX_SYMBOL_LENGTH ) ; if ( r != ARCHIVE_OK ) return ( r ) ; } if ( ! rar -> dictionary_size || ! rar -> lzss . window ) { void * new_window ; unsigned int new_size ; if ( rar -> unp_size >= DICTIONARY_MAX_SIZE ) new_size = DICTIONARY_MAX_SIZE ; else new_size = rar_fls ( ( unsigned int ) rar -> unp_size ) << 1 ; new_window = realloc ( rar -> lzss . window , new_size ) ; if ( new_window == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>uncompressed<S2SV_blank>data."" ) ; return ( ARCHIVE_FATAL ) ; } rar -> lzss . window = ( unsigned char * ) new_window ; rar -> dictionary_size = new_size ; memset ( rar -> lzss . window , 0 , rar -> dictionary_size ) ; rar -> lzss . mask = rar -> dictionary_size - 1 ; } rar -> start_new_table = 0 ; return ( ARCHIVE_OK ) ; truncated_data : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>RAR<S2SV_blank>file<S2SV_blank>data"" ) ; rar -> valid = 0 ; return ( ARCHIVE_FATAL ) ; }","; if ( rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if ("
264,"static int opl3_load_patch ( int dev , int format , const char __user * addr , <S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> { struct sbi_instrument ins ; if ( count < sizeof ( ins ) ) { printk ( KERN_WARNING ""FM<S2SV_blank>Error:<S2SV_blank>Patch<S2SV_blank>record<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <S2SV_EndBug> return - EFAULT ; if ( ins . channel < 0 || ins . channel >= SBFM_MAXINSTR ) { printk ( KERN_WARNING ""FM<S2SV_blank>Error:<S2SV_blank>Invalid<S2SV_blank>instrument<S2SV_blank>number<S2SV_blank>%d\\n"" , ins . channel ) ; return - EINVAL ; } ins . key = format ; return store_instr ( ins . channel , & ins ) ; }","* addr , <S2SV_ModEnd> int count , <S2SV_ModStart> copy_from_user ( & ins , addr <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( ins ) <S2SV_ModEnd> ) ) return"
265,"static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; <S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }",; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
266,"static int cg_opendir ( const char * path , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; const char * cgroup ; struct file_info * dir_info ; char * controller = NULL ; if ( ! fc ) return - EIO ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { cgroup = NULL ; controller = NULL ; } else { controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { cgroup = ""/"" ; } } <S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> return - EACCES ; } dir_info = malloc ( sizeof ( * dir_info ) ) ; if ( ! dir_info ) return - ENOMEM ; dir_info -> controller = must_copy_string ( controller ) ; dir_info -> cgroup = must_copy_string ( cgroup ) ; dir_info -> type = LXC_TYPE_CGDIR ; dir_info -> buf = NULL ; dir_info -> file = NULL ; dir_info -> buflen = 0 ; fi -> fh = ( unsigned long ) dir_info ; return 0 ; }","if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access ( <S2SV_ModStart> O_RDONLY ) ) <S2SV_ModEnd> return - EACCES"
267,"SYSCALL_DEFINE6 ( sendto , int , fd , void __user * , buff , size_t , len , unsigned int , flags , struct sockaddr __user * , addr , int , addr_len ) { struct socket * sock ; struct sockaddr_storage address ; int err ; struct msghdr msg ; struct iovec iov ; int fput_needed ; if ( len > INT_MAX ) <S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; iov . iov_base = buff ; iov . iov_len = len ; msg . msg_name = NULL ; iov_iter_init ( & msg . msg_iter , WRITE , & iov , 1 , len ) ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_namelen = 0 ; if ( addr ) { err = move_addr_to_kernel ( addr , addr_len , & address ) ; if ( err < 0 ) goto out_put ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = addr_len ; } if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; msg . msg_flags = flags ; err = sock_sendmsg ( sock , & msg , len ) ; out_put : fput_light ( sock -> file , fput_needed ) ; out : return err ; }","len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT"
268,"static void perf_log_throttle ( struct perf_event * event , int enable ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int ret ; struct { struct perf_event_header header ; u64 time ; u64 id ; u64 stream_id ; } throttle_event = { . header = { . type = PERF_RECORD_THROTTLE , . misc = 0 , . size = sizeof ( throttle_event ) , } , . time = perf_clock ( ) , . id = primary_event_id ( event ) , . stream_id = event -> id , } ; if ( enable ) throttle_event . header . type = PERF_RECORD_UNTHROTTLE ; perf_event_header__init_id ( & throttle_event . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <S2SV_StartBug> throttle_event . header . size , 1 , 0 ) ; <S2SV_EndBug> if ( ret ) return ; perf_output_put ( & handle , throttle_event ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; }",". size , <S2SV_ModEnd> 0 ) ;"
269,"static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; <S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }",; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
270,"BOOL license_read_new_or_upgrade_license_packet ( rdpLicense * license , wStream * s ) { UINT32 os_major ; UINT32 os_minor ; UINT32 cbScope , cbCompanyName , cbProductId , cbLicenseInfo ; wStream * licenseStream = NULL ; BOOL ret = FALSE ; BYTE computedMac [ 16 ] ; LICENSE_BLOB * calBlob ; DEBUG_LICENSE ( ""Receiving<S2SV_blank>Server<S2SV_blank>New/Upgrade<S2SV_blank>License<S2SV_blank>Packet"" ) ; calBlob = license_new_binary_blob ( BB_DATA_BLOB ) ; if ( ! calBlob ) return FALSE ; if ( ! license_read_encrypted_blob ( license , s , calBlob ) ) goto out_free_blob ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto out_free_blob ; if ( ! security_mac_data ( license -> MacSaltKey , calBlob -> data , calBlob -> length , computedMac ) ) goto out_free_blob ; if ( memcmp ( computedMac , Stream_Pointer ( s ) , sizeof ( computedMac ) ) != 0 ) { WLog_ERR ( TAG , ""new<S2SV_blank>or<S2SV_blank>upgrade<S2SV_blank>license<S2SV_blank>MAC<S2SV_blank>mismatch"" ) ; goto out_free_blob ; } if ( ! Stream_SafeSeek ( s , 16 ) ) goto out_free_blob ; licenseStream = Stream_New ( calBlob -> data , calBlob -> length ) ; if ( ! licenseStream ) goto out_free_blob ; <S2SV_StartBug> Stream_Read_UINT16 ( licenseStream , os_minor ) ; <S2SV_EndBug> Stream_Read_UINT16 ( licenseStream , os_major ) ; Stream_Read_UINT32 ( licenseStream , cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < cbScope ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , ""Scope:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbScope ) ; # endif Stream_Seek ( licenseStream , cbScope ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbCompanyName ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbCompanyName ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , ""Company<S2SV_blank>name:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbCompanyName ) ; # endif Stream_Seek ( licenseStream , cbCompanyName ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbProductId ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbProductId ) goto out_free_stream ; # ifdef WITH_DEBUG_LICENSE WLog_DBG ( TAG , ""Product<S2SV_blank>id:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , Stream_Pointer ( licenseStream ) , cbProductId ) ; # endif Stream_Seek ( licenseStream , cbProductId ) ; <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbLicenseInfo ) ; <S2SV_EndBug> if ( Stream_GetRemainingLength ( licenseStream ) < cbLicenseInfo ) goto out_free_stream ; license -> state = LICENSE_STATE_COMPLETED ; ret = TRUE ; if ( ! license -> rdp -> settings -> OldLicenseBehaviour ) ret = saveCal ( license -> rdp -> settings , Stream_Pointer ( licenseStream ) , cbLicenseInfo , license -> rdp -> settings -> ClientHostname ) ; out_free_stream : Stream_Free ( licenseStream , FALSE ) ; out_free_blob : license_free_binary_blob ( calBlob ) ; return ret ; }",goto out_free_blob ; if ( Stream_GetRemainingLength ( licenseStream ) < 8 ) goto out_free_stream ; <S2SV_ModStart> cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbCompanyName ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbProductId ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;
271,"int orangefs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { struct orangefs_inode_s * orangefs_inode = ORANGEFS_I ( inode ) ; int error = 0 ; void * value = NULL ; size_t size = 0 ; const char * name = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) { <S2SV_StartBug> gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" , <S2SV_EndBug> __func__ , error ) ; return error ; } if ( inode -> i_mode != mode ) SetModeFlag ( orangefs_inode ) ; inode -> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : gossip_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>%d!\\n"" , __func__ , type ) ; return - EINVAL ; } gossip_debug ( GOSSIP_ACL_DEBUG , ""%s:<S2SV_blank>inode<S2SV_blank>%pU,<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , get_khandle_from_ino ( inode ) , name , type ) ; if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( error < 0 ) goto out ; } gossip_debug ( GOSSIP_ACL_DEBUG , ""%s:<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>value<S2SV_blank>%p,<S2SV_blank>size<S2SV_blank>%zd,<S2SV_blank>acl<S2SV_blank>%p\\n"" , __func__ , name , value , size , acl ) ; error = orangefs_inode_setxattr ( inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","{ umode_t mode ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( error <S2SV_ModEnd> ) { gossip_err <S2SV_ModStart> { gossip_err ( ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" <S2SV_ModEnd> , __func__ , <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;"
272,"SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { SecureElementStatus_t status = SECURE_ELEMENT_ERROR ; if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) { <S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug> } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } uint8_t micHeader10 [ 1 ] = { 0x20 } ; lr1110_crypto_process_join_accept ( & LR1110 , ( lr1110_crypto_status_t * ) & status , convert_key_id_from_se_to_lr1110 ( encKeyID ) , convert_key_id_from_se_to_lr1110 ( NWK_KEY ) , ( lr1110_crypto_lorawan_version_t ) 0 , micHeader10 , encJoinAccept + 1 , encJoinAcceptSize - 1 , decJoinAccept + 1 ) ; if ( status == SECURE_ELEMENT_SUCCESS ) { * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; if ( * versionMinor == 0 ) { return SECURE_ELEMENT_SUCCESS ; } } # if ( USE_LRWAN_1_1_X_CRYPTO == 1 ) uint8_t micHeader11 [ JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; uint16_t bufItr = 0 ; micHeader11 [ bufItr ++ ] = ( uint8_t ) joinReqType ; memcpyr ( micHeader11 + bufItr , joinEui , LORAMAC_JOIN_EUI_FIELD_SIZE ) ; bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE ; micHeader11 [ bufItr ++ ] = devNonce & 0xFF ; micHeader11 [ bufItr ++ ] = ( devNonce >> 8 ) & 0xFF ; micHeader11 [ bufItr ++ ] = 0x20 ; lr1110_crypto_process_join_accept ( & LR1110 , ( lr1110_crypto_status_t * ) & status , convert_key_id_from_se_to_lr1110 ( encKeyID ) , convert_key_id_from_se_to_lr1110 ( J_S_INT_KEY ) , ( lr1110_crypto_lorawan_version_t ) 1 , micHeader11 , encJoinAccept + 1 , encJoinAcceptSize - 1 , decJoinAccept + 1 ) ; if ( status == SECURE_ELEMENT_SUCCESS ) { * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; if ( * versionMinor == 1 ) { return SECURE_ELEMENT_SUCCESS ; } } # endif return status ; }",{ return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
273,"void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }",; if ( skb_is_err_queue ( skb ) &&
274,"static void do_free_upto ( BIO * f , BIO * upto ) { if ( upto ) { BIO * tbio ; do { tbio = BIO_pop ( f ) ; BIO_free ( f ) ; f = tbio ; } <S2SV_StartBug> while ( f != upto ) ; <S2SV_EndBug> } else BIO_free_all ( f ) ; }",while ( f && f
275,"int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; daemon ( 1 , 0 ) ; openlog ( ""KVP"" , 0 , LOG_USER ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d"" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools"" ) ; exit ( - 1 ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , ""netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d"" , fd ) ; exit ( - 1 ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , ""bind<S2SV_blank>failed;<S2SV_blank>error:%d"" , error ) ; close ( fd ) ; exit ( - 1 ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; close ( fd ) ; exit ( - 1 ) ; } pfd . fd = fd ; while ( 1 ) { <S2SV_StartBug> pfd . events = POLLIN ; <S2SV_EndBug> pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; <S2SV_StartBug> len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_ERR , ""recv<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; <S2SV_EndBug> close ( fd ) ; return - 1 ; } incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; switch ( hv_msg -> kvp_hdr . operation ) { case KVP_OP_REGISTER : p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s"" , lic_version ) ; } else { syslog ( LOG_ERR , ""malloc<S2SV_blank>failed"" ) ; } continue ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) strcpy ( hv_msg -> body . kvp_set . data . key , """" ) ; break ; case KVP_OP_GET : if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) strcpy ( hv_msg -> body . kvp_set . data . key , """" ) ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) strcpy ( hv_msg -> body . kvp_delete . key , """" ) ; break ; default : break ; } if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE ) goto kvp_done ; if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO ) { kvp_pool_enumerate ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""FullyQualifiedDomainName"" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , ""IntegrationServicesVersion"" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv4"" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv6"" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSBuildNumber"" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , ""OSName"" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , ""OSMajorVersion"" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , ""OSMinorVersion"" ) ; break ; case OSVersion : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSVersion"" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , ""ProcessorArchitecture"" ) ; break ; default : strcpy ( key_value , ""Unknown<S2SV_blank>Key"" ) ; strcpy ( key_name , """" ) ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; exit ( - 1 ) ; } } }","1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> ; len = recvfrom <S2SV_ModEnd> ( fd , <S2SV_ModStart> ) , 0 , addr_p , & addr_l <S2SV_ModStart> len < 0 || addr . nl_pid <S2SV_ModStart> ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> ) ; close"
276,static void init_once ( void * foo ) { struct ext4_inode_info * ei = ( struct ext4_inode_info * ) foo ; INIT_LIST_HEAD ( & ei -> i_orphan ) ; init_rwsem ( & ei -> xattr_sem ) ; init_rwsem ( & ei -> i_data_sem ) ; <S2SV_StartBug> inode_init_once ( & ei -> vfs_inode ) ; <S2SV_EndBug> },i_data_sem ) ; init_rwsem ( & ei -> i_mmap_sem ) ;
277,"int vp8dx_get_raw_frame ( VP8D_COMP * pbi , YV12_BUFFER_CONFIG * sd , int64_t * time_stamp , int64_t * time_end_stamp , vp8_ppflags_t * flags ) { int ret = - 1 ; if ( pbi -> ready_for_new_data == 1 ) return ret ; if ( pbi -> common . show_frame == 0 ) return ret ; pbi -> ready_for_new_data = 1 ; * time_stamp = pbi -> last_time_stamp ; * time_end_stamp = 0 ; # if CONFIG_POSTPROC ret = vp8_post_proc_frame ( & pbi -> common , sd , flags ) ; # else <S2SV_StartBug> if ( pbi -> common . frame_to_show ) <S2SV_EndBug> { * sd = * pbi -> common . frame_to_show ; sd -> y_width = pbi -> common . Width ; sd -> y_height = pbi -> common . Height ; sd -> uv_height = pbi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; }",; # else ( void ) flags ;
278,"static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ( int ) ReadBlobLong ( image ) ; viff_info . y_offset = ( int ) ReadBlobLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , <S2SV_EndBug> bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",") AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel * sizeof"
279,"int do_mathemu ( struct pt_regs * regs , struct fpustate * f ) { unsigned long pc = regs -> tpc ; unsigned long tstate = regs -> tstate ; u32 insn = 0 ; int type = 0 ; # define TYPE ( ftt , r , ru , b , bu , a , au ) type = ( au << 2 ) | ( a << 0 ) | ( bu << 5 ) | ( b << 3 ) | ( ru << 8 ) | ( r << 6 ) | ( ftt << 9 ) int freg ; static u64 zero [ 2 ] = { 0L , 0L } ; int flags ; FP_DECL_EX ; FP_DECL_S ( SA ) ; FP_DECL_S ( SB ) ; FP_DECL_S ( SR ) ; FP_DECL_D ( DA ) ; FP_DECL_D ( DB ) ; FP_DECL_D ( DR ) ; FP_DECL_Q ( QA ) ; FP_DECL_Q ( QB ) ; FP_DECL_Q ( QR ) ; int IR ; long XR , xfsr ; if ( tstate & TSTATE_PRIV ) die_if_kernel ( ""unfinished/unimplemented<S2SV_blank>FPop<S2SV_blank>from<S2SV_blank>kernel"" , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) { if ( ( insn & 0xc1f80000 ) == 0x81a00000 ) { switch ( ( insn >> 5 ) & 0x1ff ) { case FMOVQ : case FNEGQ : case FABSQ : TYPE ( 3 , 3 , 0 , 3 , 0 , 0 , 0 ) ; break ; case FSQRTQ : TYPE ( 3 , 3 , 1 , 3 , 1 , 0 , 0 ) ; break ; case FADDQ : case FSUBQ : case FMULQ : case FDIVQ : TYPE ( 3 , 3 , 1 , 3 , 1 , 3 , 1 ) ; break ; case FDMULQ : TYPE ( 3 , 3 , 1 , 2 , 1 , 2 , 1 ) ; break ; case FQTOX : TYPE ( 3 , 2 , 0 , 3 , 1 , 0 , 0 ) ; break ; case FXTOQ : TYPE ( 3 , 3 , 1 , 2 , 0 , 0 , 0 ) ; break ; case FQTOS : TYPE ( 3 , 1 , 1 , 3 , 1 , 0 , 0 ) ; break ; case FQTOD : TYPE ( 3 , 2 , 1 , 3 , 1 , 0 , 0 ) ; break ; case FITOQ : TYPE ( 3 , 3 , 1 , 1 , 0 , 0 , 0 ) ; break ; case FSTOQ : TYPE ( 3 , 3 , 1 , 1 , 1 , 0 , 0 ) ; break ; case FDTOQ : TYPE ( 3 , 3 , 1 , 2 , 1 , 0 , 0 ) ; break ; case FQTOI : TYPE ( 3 , 1 , 0 , 3 , 1 , 0 , 0 ) ; break ; case FSQRTS : { unsigned long x = current_thread_info ( ) -> xfsr [ 0 ] ; x = ( x >> 14 ) & 0xf ; TYPE ( x , 1 , 1 , 1 , 1 , 0 , 0 ) ; break ; } case FSQRTD : { unsigned long x = current_thread_info ( ) -> xfsr [ 0 ] ; x = ( x >> 14 ) & 0xf ; TYPE ( x , 2 , 1 , 2 , 1 , 0 , 0 ) ; break ; } case FADDD : case FSUBD : case FMULD : case FDIVD : TYPE ( 2 , 2 , 1 , 2 , 1 , 2 , 1 ) ; break ; case FADDS : case FSUBS : case FMULS : case FDIVS : TYPE ( 2 , 1 , 1 , 1 , 1 , 1 , 1 ) ; break ; case FSMULD : TYPE ( 2 , 2 , 1 , 1 , 1 , 1 , 1 ) ; break ; case FSTOX : TYPE ( 2 , 2 , 0 , 1 , 1 , 0 , 0 ) ; break ; case FDTOX : TYPE ( 2 , 2 , 0 , 2 , 1 , 0 , 0 ) ; break ; case FDTOS : TYPE ( 2 , 1 , 1 , 2 , 1 , 0 , 0 ) ; break ; case FSTOD : TYPE ( 2 , 2 , 1 , 1 , 1 , 0 , 0 ) ; break ; case FSTOI : TYPE ( 2 , 1 , 0 , 1 , 1 , 0 , 0 ) ; break ; case FDTOI : TYPE ( 2 , 1 , 0 , 2 , 1 , 0 , 0 ) ; break ; case FXTOS : TYPE ( 2 , 1 , 1 , 2 , 0 , 0 , 0 ) ; break ; case FXTOD : TYPE ( 2 , 2 , 1 , 2 , 0 , 0 , 0 ) ; break ; # if 0 case FITOS : TYPE ( 2 , 1 , 1 , 1 , 0 , 0 , 0 ) ; break ; # endif case FITOD : TYPE ( 2 , 2 , 1 , 1 , 0 , 0 , 0 ) ; break ; } } else if ( ( insn & 0xc1f80000 ) == 0x81a80000 ) { IR = 2 ; switch ( ( insn >> 5 ) & 0x1ff ) { case FCMPQ : TYPE ( 3 , 0 , 0 , 3 , 1 , 3 , 1 ) ; break ; case FCMPEQ : TYPE ( 3 , 0 , 0 , 3 , 1 , 3 , 1 ) ; break ; case FMOVQ0 : case FMOVQ1 : case FMOVQ2 : case FMOVQ3 : if ( ! ( ( insn >> 11 ) & 3 ) ) XR = current_thread_info ( ) -> xfsr [ 0 ] >> 10 ; else XR = current_thread_info ( ) -> xfsr [ 0 ] >> ( 30 + ( ( insn >> 10 ) & 0x6 ) ) ; XR &= 3 ; IR = 0 ; switch ( ( insn >> 14 ) & 0x7 ) { case 1 : if ( XR ) IR = 1 ; break ; case 2 : if ( XR == 1 || XR == 2 ) IR = 1 ; break ; case 3 : if ( XR & 1 ) IR = 1 ; break ; case 4 : if ( XR == 1 ) IR = 1 ; break ; case 5 : if ( XR & 2 ) IR = 1 ; break ; case 6 : if ( XR == 2 ) IR = 1 ; break ; case 7 : if ( XR == 3 ) IR = 1 ; break ; } if ( ( insn >> 14 ) & 8 ) IR ^= 1 ; break ; case FMOVQI : case FMOVQX : XR = regs -> tstate >> 32 ; if ( ( insn >> 5 ) & 0x80 ) XR >>= 4 ; XR &= 0xf ; IR = 0 ; freg = ( ( XR >> 2 ) ^ XR ) & 2 ; switch ( ( insn >> 14 ) & 0x7 ) { case 1 : if ( XR & 4 ) IR = 1 ; break ; case 2 : if ( ( XR & 4 ) || freg ) IR = 1 ; break ; case 3 : if ( freg ) IR = 1 ; break ; case 4 : if ( XR & 5 ) IR = 1 ; break ; case 5 : if ( XR & 1 ) IR = 1 ; break ; case 6 : if ( XR & 8 ) IR = 1 ; break ; case 7 : if ( XR & 2 ) IR = 1 ; break ; } if ( ( insn >> 14 ) & 8 ) IR ^= 1 ; break ; case FMOVQZ : case FMOVQLE : case FMOVQLZ : case FMOVQNZ : case FMOVQGZ : case FMOVQGE : freg = ( insn >> 14 ) & 0x1f ; if ( ! freg ) XR = 0 ; else if ( freg < 16 ) XR = regs -> u_regs [ freg ] ; else if ( test_thread_flag ( TIF_32BIT ) ) { struct reg_window32 __user * win32 ; flushw_user ( ) ; win32 = ( struct reg_window32 __user * ) ( ( unsigned long ) ( ( u32 ) regs -> u_regs [ UREG_FP ] ) ) ; get_user ( XR , & win32 -> locals [ freg - 16 ] ) ; } else { struct reg_window __user * win ; flushw_user ( ) ; win = ( struct reg_window __user * ) ( regs -> u_regs [ UREG_FP ] + STACK_BIAS ) ; get_user ( XR , & win -> locals [ freg - 16 ] ) ; } IR = 0 ; switch ( ( insn >> 10 ) & 3 ) { case 1 : if ( ! XR ) IR = 1 ; break ; case 2 : if ( XR <= 0 ) IR = 1 ; break ; case 3 : if ( XR < 0 ) IR = 1 ; break ; } if ( ( insn >> 10 ) & 4 ) IR ^= 1 ; break ; } if ( IR == 0 ) { current_thread_info ( ) -> xfsr [ 0 ] &= ~ ( FSR_CEXC_MASK ) ; regs -> tpc = regs -> tnpc ; regs -> tnpc += 4 ; return 1 ; } else if ( IR == 1 ) { insn = ( insn & 0x3e00001f ) | 0x81a00060 ; TYPE ( 3 , 3 , 0 , 3 , 0 , 0 , 0 ) ; } } } if ( type ) { argp rs1 = NULL , rs2 = NULL , rd = NULL ; freg = ( current_thread_info ( ) -> xfsr [ 0 ] >> 14 ) & 0xf ; if ( freg != ( type >> 9 ) ) goto err ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; freg = ( ( insn >> 14 ) & 0x1f ) ; switch ( type & 0x3 ) { case 3 : if ( freg & 2 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; goto err ; } case 2 : freg = ( ( freg & 1 ) << 5 ) | ( freg & 0x1e ) ; case 1 : rs1 = ( argp ) & f -> regs [ freg ] ; flags = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flags ) ) rs1 = ( argp ) & zero ; break ; } switch ( type & 0x7 ) { case 7 : FP_UNPACK_QP ( QA , rs1 ) ; break ; case 6 : FP_UNPACK_DP ( DA , rs1 ) ; break ; case 5 : FP_UNPACK_SP ( SA , rs1 ) ; break ; } freg = ( insn & 0x1f ) ; switch ( ( type >> 3 ) & 0x3 ) { case 3 : if ( freg & 2 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; goto err ; } case 2 : freg = ( ( freg & 1 ) << 5 ) | ( freg & 0x1e ) ; case 1 : rs2 = ( argp ) & f -> regs [ freg ] ; flags = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flags ) ) rs2 = ( argp ) & zero ; break ; } switch ( ( type >> 3 ) & 0x7 ) { case 7 : FP_UNPACK_QP ( QB , rs2 ) ; break ; case 6 : FP_UNPACK_DP ( DB , rs2 ) ; break ; case 5 : FP_UNPACK_SP ( SB , rs2 ) ; break ; } freg = ( ( insn >> 25 ) & 0x1f ) ; switch ( ( type >> 6 ) & 0x3 ) { case 3 : if ( freg & 2 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; goto err ; } case 2 : freg = ( ( freg & 1 ) << 5 ) | ( freg & 0x1e ) ; case 1 : rd = ( argp ) & f -> regs [ freg ] ; flags = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flags ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } current_thread_info ( ) -> fpsaved [ 0 ] |= flags ; break ; } switch ( ( insn >> 5 ) & 0x1ff ) { case FADDS : FP_ADD_S ( SR , SA , SB ) ; break ; case FADDD : FP_ADD_D ( DR , DA , DB ) ; break ; case FADDQ : FP_ADD_Q ( QR , QA , QB ) ; break ; case FSUBS : FP_SUB_S ( SR , SA , SB ) ; break ; case FSUBD : FP_SUB_D ( DR , DA , DB ) ; break ; case FSUBQ : FP_SUB_Q ( QR , QA , QB ) ; break ; case FMULS : FP_MUL_S ( SR , SA , SB ) ; break ; case FSMULD : FP_CONV ( D , S , 1 , 1 , DA , SA ) ; FP_CONV ( D , S , 1 , 1 , DB , SB ) ; case FMULD : FP_MUL_D ( DR , DA , DB ) ; break ; case FDMULQ : FP_CONV ( Q , D , 2 , 1 , QA , DA ) ; FP_CONV ( Q , D , 2 , 1 , QB , DB ) ; case FMULQ : FP_MUL_Q ( QR , QA , QB ) ; break ; case FDIVS : FP_DIV_S ( SR , SA , SB ) ; break ; case FDIVD : FP_DIV_D ( DR , DA , DB ) ; break ; case FDIVQ : FP_DIV_Q ( QR , QA , QB ) ; break ; case FSQRTS : FP_SQRT_S ( SR , SB ) ; break ; case FSQRTD : FP_SQRT_D ( DR , DB ) ; break ; case FSQRTQ : FP_SQRT_Q ( QR , QB ) ; break ; case FMOVQ : rd -> q [ 0 ] = rs2 -> q [ 0 ] ; rd -> q [ 1 ] = rs2 -> q [ 1 ] ; break ; case FABSQ : rd -> q [ 0 ] = rs2 -> q [ 0 ] & 0x7fffffffffffffffUL ; rd -> q [ 1 ] = rs2 -> q [ 1 ] ; break ; case FNEGQ : rd -> q [ 0 ] = rs2 -> q [ 0 ] ^ 0x8000000000000000UL ; rd -> q [ 1 ] = rs2 -> q [ 1 ] ; break ; case FSTOI : FP_TO_INT_S ( IR , SB , 32 , 1 ) ; break ; case FDTOI : FP_TO_INT_D ( IR , DB , 32 , 1 ) ; break ; case FQTOI : FP_TO_INT_Q ( IR , QB , 32 , 1 ) ; break ; case FSTOX : FP_TO_INT_S ( XR , SB , 64 , 1 ) ; break ; case FDTOX : FP_TO_INT_D ( XR , DB , 64 , 1 ) ; break ; case FQTOX : FP_TO_INT_Q ( XR , QB , 64 , 1 ) ; break ; case FITOQ : IR = rs2 -> s ; FP_FROM_INT_Q ( QR , IR , 32 , int ) ; break ; case FXTOQ : XR = rs2 -> d ; FP_FROM_INT_Q ( QR , XR , 64 , long ) ; break ; case FXTOS : XR = rs2 -> d ; FP_FROM_INT_S ( SR , XR , 64 , long ) ; break ; case FXTOD : XR = rs2 -> d ; FP_FROM_INT_D ( DR , XR , 64 , long ) ; break ; # if 0 case FITOS : IR = rs2 -> s ; FP_FROM_INT_S ( SR , IR , 32 , int ) ; break ; # endif case FITOD : IR = rs2 -> s ; FP_FROM_INT_D ( DR , IR , 32 , int ) ; break ; case FSTOD : FP_CONV ( D , S , 1 , 1 , DR , SB ) ; break ; case FSTOQ : FP_CONV ( Q , S , 2 , 1 , QR , SB ) ; break ; case FDTOQ : FP_CONV ( Q , D , 2 , 1 , QR , DB ) ; break ; case FDTOS : FP_CONV ( S , D , 1 , 1 , SR , DB ) ; break ; case FQTOS : FP_CONV ( S , Q , 1 , 2 , SR , QB ) ; break ; case FQTOD : FP_CONV ( D , Q , 1 , 2 , DR , QB ) ; break ; case FCMPQ : case FCMPEQ : FP_CMP_Q ( XR , QB , QA , 3 ) ; if ( XR == 3 && ( ( ( insn >> 5 ) & 0x1ff ) == FCMPEQ || FP_ISSIGNAN_Q ( QA ) || FP_ISSIGNAN_Q ( QB ) ) ) FP_SET_EXCEPTION ( FP_EX_INVALID ) ; } if ( ! FP_INHIBIT_RESULTS ) { switch ( ( type >> 6 ) & 0x7 ) { case 0 : xfsr = current_thread_info ( ) -> xfsr [ 0 ] ; if ( XR == - 1 ) XR = 2 ; switch ( freg & 3 ) { case 0 : xfsr &= ~ 0xc00 ; xfsr |= ( XR << 10 ) ; break ; case 1 : xfsr &= ~ 0x300000000UL ; xfsr |= ( XR << 32 ) ; break ; case 2 : xfsr &= ~ 0xc00000000UL ; xfsr |= ( XR << 34 ) ; break ; case 3 : xfsr &= ~ 0x3000000000UL ; xfsr |= ( XR << 36 ) ; break ; } current_thread_info ( ) -> xfsr [ 0 ] = xfsr ; break ; case 1 : rd -> s = IR ; break ; case 2 : rd -> d = XR ; break ; case 5 : FP_PACK_SP ( rd , SR ) ; break ; case 6 : FP_PACK_DP ( rd , DR ) ; break ; case 7 : FP_PACK_QP ( rd , QR ) ; break ; } } if ( _fex != 0 ) return record_exception ( regs , _fex ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ ( FSR_CEXC_MASK ) ; regs -> tpc = regs -> tnpc ; regs -> tnpc += 4 ; return 1 ; } err : return 0 ; }","PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,"
280,"void mono_reflection_create_dynamic_method ( MonoReflectionDynamicMethod * mb ) { <S2SV_StartBug> ReflectionMethodBuilder rmb ; <S2SV_EndBug> MonoMethodSignature * sig ; MonoClass * klass ; GSList * l ; <S2SV_StartBug> int i ; <S2SV_EndBug> sig = dynamic_method_to_signature ( mb ) ; reflection_methodbuilder_from_dynamic_method ( & rmb , mb ) ; rmb . nrefs = mb -> nrefs ; rmb . refs = g_new0 ( gpointer , mb -> nrefs + 1 ) ; for ( i = 0 ; i < mb -> nrefs ; i += 2 ) { MonoClass * handle_class ; gpointer ref ; MonoObject * obj = mono_array_get ( mb -> refs , MonoObject * , i ) ; if ( strcmp ( obj -> vtable -> klass -> name , ""DynamicMethod"" ) == 0 ) { MonoReflectionDynamicMethod * method = ( MonoReflectionDynamicMethod * ) obj ; if ( method -> mhandle ) { ref = method -> mhandle ; } else { ref = method ; method -> referenced_by = g_slist_append ( method -> referenced_by , mb ) ; } handle_class = mono_defaults . methodhandle_class ; } else { MonoException * ex = NULL ; ref = resolve_object ( mb -> module -> image , obj , & handle_class , NULL ) ; if ( ! ref ) ex = mono_get_exception_type_load ( NULL , NULL ) ; else if ( mono_security_get_mode ( ) == MONO_SECURITY_MODE_CORE_CLR ) ex = mono_security_core_clr_ensure_dynamic_method_resolved_object ( ref , handle_class ) ; if ( ex ) { g_free ( rmb . refs ) ; mono_raise_exception ( ex ) ; return ; } } rmb . refs [ i ] = ref ; rmb . refs [ i + 1 ] = handle_class ; } klass = mb -> owner ? mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) mb -> owner ) ) : mono_defaults . object_class ; <S2SV_StartBug> mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ; <S2SV_EndBug> for ( l = mb -> referenced_by ; l ; l = l -> next ) { MonoReflectionDynamicMethod * method = ( MonoReflectionDynamicMethod * ) l -> data ; MonoMethodWrapper * wrapper = ( MonoMethodWrapper * ) method -> mhandle ; gpointer * data ; g_assert ( method -> mhandle ) ; data = ( gpointer * ) wrapper -> method_data ; for ( i = 0 ; i < GPOINTER_TO_UINT ( data [ 0 ] ) ; i += 2 ) { if ( ( data [ i + 1 ] == mb ) && ( data [ i + 1 + 1 ] == mono_defaults . methodhandle_class ) ) data [ i + 1 ] = mb -> mhandle ; } } g_slist_free ( mb -> referenced_by ) ; g_free ( rmb . refs ) ; mb -> ilgen = NULL ; }","mb ) { MonoReferenceQueue * queue ; MonoMethod * handle ; DynamicMethodReleaseData * release_data ; <S2SV_ModStart> int i ; if ( mono_runtime_is_shutting_down ( ) ) mono_raise_exception ( mono_get_exception_invalid_operation ( """" ) ) ; if ( ! ( queue = dynamic_method_queue ) ) { mono_loader_lock ( ) ; if ( ! ( queue = dynamic_method_queue ) ) queue = dynamic_method_queue = mono_gc_reference_queue_new ( free_dynamic_method ) ; mono_loader_unlock ( ) ; } <S2SV_ModStart> -> mhandle = handle = <S2SV_ModStart> rmb , sig ) ; release_data = g_new ( DynamicMethodReleaseData , 1 ) ; release_data -> handle = handle ; release_data -> domain = mono_object_get_domain ( ( MonoObject * ) mb ) ; if ( ! mono_gc_reference_queue_add ( queue , ( MonoObject * ) mb , release_data ) ) g_free ( release_data"
281,"int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , <S2SV_StartBug> double correction_factor ) { <S2SV_EndBug> <S2SV_StartBug> const double q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ; <S2SV_EndBug> enumerator += ( int ) ( enumerator * q ) >> 12 ; <S2SV_StartBug> return ( int ) ( 0.5 + ( enumerator * correction_factor / q ) ) ; <S2SV_EndBug> }",", double correction_factor , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , bit_depth <S2SV_ModStart> == KEY_FRAME ? 2700000 : 1800000 ; assert ( correction_factor <= MAX_BPB_FACTOR && correction_factor >= MIN_BPB_FACTOR ) <S2SV_ModEnd> ; enumerator += <S2SV_ModStart> int ) ( <S2SV_ModEnd> enumerator * correction_factor <S2SV_ModStart> / q ) <S2SV_ModEnd> ; } <S2SV_null>"
282,"static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }",trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
283,"int do_remount_sb ( struct super_block * sb , int flags , void * data , int force ) { int retval ; int remount_ro ; if ( sb -> s_writers . frozen != SB_UNFROZEN ) return - EBUSY ; # ifdef CONFIG_BLOCK if ( ! ( flags & MS_RDONLY ) && bdev_read_only ( sb -> s_bdev ) ) return - EACCES ; # endif if ( flags & MS_RDONLY ) acct_auto_close ( sb ) ; shrink_dcache_sb ( sb ) ; sync_filesystem ( sb ) ; remount_ro = ( flags & MS_RDONLY ) && ! ( sb -> s_flags & MS_RDONLY ) ; if ( remount_ro ) { if ( force ) { <S2SV_StartBug> mark_files_ro ( sb ) ; <S2SV_EndBug> } else { retval = sb_prepare_remount_readonly ( sb ) ; if ( retval ) return retval ; } } if ( sb -> s_op -> remount_fs ) { retval = sb -> s_op -> remount_fs ( sb , & flags , data ) ; if ( retval ) { if ( ! force ) goto cancel_readonly ; WARN ( 1 , ""forced<S2SV_blank>remount<S2SV_blank>of<S2SV_blank>a<S2SV_blank>%s<S2SV_blank>fs<S2SV_blank>returned<S2SV_blank>%i\\n"" , sb -> s_type -> name , retval ) ; } } sb -> s_flags = ( sb -> s_flags & ~ MS_RMT_MASK ) | ( flags & MS_RMT_MASK ) ; smp_wmb ( ) ; sb -> s_readonly_remount = 0 ; if ( remount_ro && sb -> s_bdev ) invalidate_bdev ( sb -> s_bdev ) ; return 0 ; cancel_readonly : sb -> s_readonly_remount = 0 ; return retval ; }",force ) { sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> ) ; }
284,"STREAM sec_recv ( RD_BOOL * is_fastpath ) { uint8 fastpath_hdr , fastpath_flags ; uint16 sec_flags ; uint16 channel ; STREAM s ; <S2SV_StartBug> while ( ( s = mcs_recv ( & channel , is_fastpath , & fastpath_hdr ) ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( * is_fastpath == True ) { fastpath_flags = ( fastpath_hdr & 0xC0 ) >> 6 ; if ( fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED ) <S2SV_StartBug> { <S2SV_EndBug> in_uint8s ( s , 8 ) ; sec_decrypt ( s -> p , s -> end - s -> p ) ; } return s ; } if ( g_encryption || ( ! g_licence_issued && ! g_licence_error_result ) ) { in_uint16_le ( s , sec_flags ) ; in_uint8s ( s , 2 ) ; if ( g_encryption ) { if ( sec_flags & SEC_ENCRYPT ) { <S2SV_StartBug> in_uint8s ( s , 8 ) ; <S2SV_EndBug> sec_decrypt ( s -> p , s -> end - s -> p ) ; } if ( sec_flags & SEC_LICENSE_PKT ) { licence_process ( s ) ; continue ; } if ( sec_flags & SEC_REDIRECTION_PKT ) { <S2SV_StartBug> uint8 swapbyte ; <S2SV_EndBug> in_uint8s ( s , 8 ) ; sec_decrypt ( s -> p , s -> end - s -> p ) ; if ( s -> p [ 0 ] == 0 && s -> p [ 1 ] == 4 ) { swapbyte = s -> p [ 0 ] ; s -> p [ 0 ] = s -> p [ 2 ] ; s -> p [ 2 ] = swapbyte ; swapbyte = s -> p [ 1 ] ; s -> p [ 1 ] = s -> p [ 3 ] ; s -> p [ 3 ] = swapbyte ; swapbyte = s -> p [ 2 ] ; s -> p [ 2 ] = s -> p [ 3 ] ; s -> p [ 3 ] = swapbyte ; } } } else { if ( sec_flags & SEC_LICENSE_PKT ) { licence_process ( s ) ; continue ; } s -> p -= 4 ; } } if ( channel != MCS_GLOBAL_CHANNEL ) { channel_process ( s , channel ) ; continue ; } return s ; } return NULL ; }","STREAM s ; struct stream packet ; <S2SV_ModStart> NULL ) { packet = * s ; <S2SV_ModStart> FASTPATH_OUTPUT_ENCRYPTED ) { if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>fastpath<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> SEC_ENCRYPT ) { if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>encrypt<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> uint8 swapbyte ; if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>redirect<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }"
285,"<S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> { if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) ) { if ( skb == NULL ) { * mtu = * mtu - rt -> dst . header_len ; } else { <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> } * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; } }","void ip6_append_data_mtu ( unsigned <S2SV_ModStart> rt6_info * rt , bool pmtuprobe <S2SV_ModStart> * mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> dst . path )"
286,"static void build_y_mask ( const loop_filter_info_n * const lfi_n , const MODE_INFO * mi , const int shift_y , LOOP_FILTER_MASK * lfm ) { const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ; uint64_t * const int_4x4_y = & lfm -> int_4x4_y ; int i ; if ( ! filter_level ) { return ; } else { const int w = num_8x8_blocks_wide_lookup [ block_size ] ; const int h = num_8x8_blocks_high_lookup [ block_size ] ; int index = shift_y ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> index += 8 ; } } * above_y |= above_prediction_mask [ block_size ] << shift_y ; * left_y |= left_prediction_mask [ block_size ] << shift_y ; if ( mbmi -> skip && is_inter_block ( mbmi ) ) return ; * above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * left_y |= ( size_mask [ block_size ] & left_64x64_txform_mask [ tx_size_y ] ) << shift_y ; if ( tx_size_y == TX_4X4 ) <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> }",++ ) { memset <S2SV_ModEnd> ( & lfm <S2SV_ModStart> block_size ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) << shift_y
287,"static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }",( d ) ; msg -> msg_namelen = 0
288,"static int http_rxchunk ( struct http * hp ) { char * q ; int l , i ; l = hp -> prxbuf ; do ( void ) http_rxchar ( hp , 1 , 0 ) ; while ( hp -> rxbuf [ hp -> prxbuf - 1 ] != '\\n' ) ; vtc_dump ( hp -> vl , 4 , ""len"" , hp -> rxbuf + l , - 1 ) ; i = strtoul ( hp -> rxbuf + l , & q , 16 ) ; bprintf ( hp -> chunklen , ""%d"" , i ) ; if ( ( q == hp -> rxbuf + l ) || ( * q != '\\0' && ! vct_islws ( * q ) ) ) { vtc_log ( hp -> vl , hp -> fatal , ""chunked<S2SV_blank>fail<S2SV_blank>%02x<S2SV_blank>@<S2SV_blank>%d"" , * q , q - ( hp -> rxbuf + l ) ) ; } assert ( q != hp -> rxbuf + l ) ; assert ( * q == '\\0' || vct_islws ( * q ) ) ; hp -> prxbuf = l ; if ( i > 0 ) { ( void ) http_rxchar ( hp , i , 0 ) ; vtc_dump ( hp -> vl , 4 , ""chunk"" , hp -> rxbuf + l , i ) ; } l = hp -> prxbuf ; ( void ) http_rxchar ( hp , 2 , 0 ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[0]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l ] & 0xff ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[1]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l + 1 ] & 0xff ) ; hp -> prxbuf = l ; hp -> rxbuf [ l ] = '\\0' ; return ( i ) ; }",! vct_iscrlf ( & <S2SV_ModStart> ! vct_iscrlf ( &
289,"int ff_mov_write_packet ( AVFormatContext * s , AVPacket * pkt ) { MOVMuxContext * mov = s -> priv_data ; AVIOContext * pb = s -> pb ; MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; AVCodecParameters * par = trk -> par ; unsigned int samples_in_chunk = 0 ; int size = pkt -> size , ret = 0 ; uint8_t * reformatted_data = NULL ; ret = check_pkt ( s , pkt ) ; if ( ret < 0 ) return ret ; if ( mov -> flags & FF_MOV_FLAG_FRAGMENT ) { int ret ; if ( mov -> moov_written || mov -> flags & FF_MOV_FLAG_EMPTY_MOOV ) { if ( mov -> frag_interleave && mov -> fragments > 0 ) { if ( trk -> entry - trk -> entries_flushed >= mov -> frag_interleave ) { if ( ( ret = mov_flush_fragment_interleaving ( s , trk ) ) < 0 ) return ret ; } } if ( ! trk -> mdat_buf ) { if ( ( ret = avio_open_dyn_buf ( & trk -> mdat_buf ) ) < 0 ) return ret ; } pb = trk -> mdat_buf ; } else { if ( ! mov -> mdat_buf ) { if ( ( ret = avio_open_dyn_buf ( & mov -> mdat_buf ) ) < 0 ) return ret ; } pb = mov -> mdat_buf ; } } if ( par -> codec_id == AV_CODEC_ID_AMR_NB ) { static const uint16_t packed_size [ 16 ] = { 13 , 14 , 16 , 18 , 20 , 21 , 27 , 32 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; int len = 0 ; while ( len < size && samples_in_chunk < 100 ) { len += packed_size [ ( pkt -> data [ len ] >> 3 ) & 0x0F ] ; samples_in_chunk ++ ; } if ( samples_in_chunk > 1 ) { av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>single<S2SV_blank>packet,<S2SV_blank>implement<S2SV_blank>a<S2SV_blank>AVParser<S2SV_blank>for<S2SV_blank>it\\n"" ) ; return - 1 ; } } else if ( par -> codec_id == AV_CODEC_ID_ADPCM_MS || par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { samples_in_chunk = trk -> par -> frame_size ; } else if ( trk -> sample_size ) samples_in_chunk = size / trk -> sample_size ; else samples_in_chunk = 1 ; <S2SV_StartBug> if ( trk -> vos_len == 0 && par -> extradata_size > 0 && <S2SV_EndBug> ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) { trk -> vos_len = par -> extradata_size ; trk -> vos_data = av_malloc ( trk -> vos_len ) ; if ( ! trk -> vos_data ) { ret = AVERROR ( ENOMEM ) ; goto err ; } memcpy ( trk -> vos_data , par -> extradata , trk -> vos_len ) ; } if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , ""Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>"" ""(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n"" ) ; return - 1 ; } av_log ( s , AV_LOG_WARNING , ""aac<S2SV_blank>bitstream<S2SV_blank>error\\n"" ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 && trk -> vos_len > 0 && * ( uint8_t * ) trk -> vos_data != 1 && ! TAG_IS_AVCI ( trk -> tag ) ) { if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { ff_avc_parse_nal_units_buf ( pkt -> data , & reformatted_data , & size ) ; avio_write ( pb , reformatted_data , size ) ; } else { if ( trk -> cenc . aes_ctr ) { size = ff_mov_cenc_avc_parse_nal_units ( & trk -> cenc , pb , pkt -> data , size ) ; if ( size < 0 ) { ret = size ; goto err ; } } else { size = ff_avc_parse_nal_units ( pb , pkt -> data , pkt -> size ) ; } } } else if ( par -> codec_id == AV_CODEC_ID_HEVC && trk -> vos_len > 6 && ( AV_RB24 ( trk -> vos_data ) == 1 || AV_RB32 ( trk -> vos_data ) == 1 ) ) { if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { ff_hevc_annexb2mp4_buf ( pkt -> data , & reformatted_data , & size , 0 , NULL ) ; avio_write ( pb , reformatted_data , size ) ; } else { size = ff_hevc_annexb2mp4 ( pb , pkt -> data , pkt -> size , 0 , NULL ) ; } # if CONFIG_AC3_PARSER } else if ( par -> codec_id == AV_CODEC_ID_EAC3 ) { size = handle_eac3 ( mov , pkt , trk ) ; if ( size < 0 ) return size ; else if ( ! size ) goto end ; avio_write ( pb , pkt -> data , size ) ; # endif } else { if ( trk -> cenc . aes_ctr ) { if ( par -> codec_id == AV_CODEC_ID_H264 && par -> extradata_size > 4 ) { int nal_size_length = ( par -> extradata [ 4 ] & 0x3 ) + 1 ; ret = ff_mov_cenc_avc_write_nal_units ( s , & trk -> cenc , nal_size_length , pb , pkt -> data , size ) ; } else { ret = ff_mov_cenc_write_packet ( & trk -> cenc , pb , pkt -> data , size ) ; } if ( ret ) { goto err ; } } else { avio_write ( pb , pkt -> data , size ) ; } } if ( ( par -> codec_id == AV_CODEC_ID_DNXHD || par -> codec_id == AV_CODEC_ID_AC3 ) && ! trk -> vos_len ) { trk -> vos_len = size ; trk -> vos_data = av_malloc ( size ) ; if ( ! trk -> vos_data ) { ret = AVERROR ( ENOMEM ) ; goto err ; } memcpy ( trk -> vos_data , pkt -> data , size ) ; } if ( trk -> entry >= trk -> cluster_capacity ) { unsigned new_capacity = 2 * ( trk -> entry + MOV_INDEX_CLUSTER_SIZE ) ; if ( av_reallocp_array ( & trk -> cluster , new_capacity , sizeof ( * trk -> cluster ) ) ) { ret = AVERROR ( ENOMEM ) ; goto err ; } trk -> cluster_capacity = new_capacity ; } trk -> cluster [ trk -> entry ] . pos = avio_tell ( pb ) - size ; trk -> cluster [ trk -> entry ] . samples_in_chunk = samples_in_chunk ; trk -> cluster [ trk -> entry ] . chunkNum = 0 ; trk -> cluster [ trk -> entry ] . size = size ; trk -> cluster [ trk -> entry ] . entries = samples_in_chunk ; trk -> cluster [ trk -> entry ] . dts = pkt -> dts ; trk -> cluster [ trk -> entry ] . pts = pkt -> pts ; if ( ! trk -> entry && trk -> start_dts != AV_NOPTS_VALUE ) { if ( ! trk -> frag_discont ) { trk -> cluster [ trk -> entry ] . dts = trk -> start_dts + trk -> track_duration ; if ( ( mov -> flags & FF_MOV_FLAG_DASH && ! ( mov -> flags & FF_MOV_FLAG_GLOBAL_SIDX ) ) || mov -> mode == MODE_ISM ) pkt -> pts = pkt -> dts + trk -> end_pts - trk -> cluster [ trk -> entry ] . dts ; } else { trk -> frag_start = pkt -> dts - trk -> start_dts ; trk -> end_pts = AV_NOPTS_VALUE ; trk -> frag_discont = 0 ; } } if ( ! trk -> entry && trk -> start_dts == AV_NOPTS_VALUE && ! mov -> use_editlist && s -> avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO ) { trk -> cluster [ trk -> entry ] . dts = trk -> start_dts = 0 ; } if ( trk -> start_dts == AV_NOPTS_VALUE ) { trk -> start_dts = pkt -> dts ; if ( trk -> frag_discont ) { if ( mov -> use_editlist ) { trk -> frag_start = pkt -> pts ; trk -> start_dts = pkt -> dts - pkt -> pts ; } else { trk -> frag_start = pkt -> dts ; trk -> start_dts = 0 ; } trk -> frag_discont = 0 ; } else if ( pkt -> dts && mov -> moov_written ) av_log ( s , AV_LOG_WARNING , ""Track<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>a<S2SV_blank>nonzero<S2SV_blank>dts<S2SV_blank>%"" PRId64 "",<S2SV_blank>while<S2SV_blank>the<S2SV_blank>moov<S2SV_blank>"" ""already<S2SV_blank>has<S2SV_blank>been<S2SV_blank>written.<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>delay_moov<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>"" ""this<S2SV_blank>case.\\n"" , pkt -> stream_index , pkt -> dts ) ; } trk -> track_duration = pkt -> dts - trk -> start_dts + pkt -> duration ; trk -> last_sample_is_subtitle_end = 0 ; if ( pkt -> pts == AV_NOPTS_VALUE ) { av_log ( s , AV_LOG_WARNING , ""pts<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value\\n"" ) ; pkt -> pts = pkt -> dts ; } if ( pkt -> dts != pkt -> pts ) trk -> flags |= MOV_TRACK_CTTS ; trk -> cluster [ trk -> entry ] . cts = pkt -> pts - pkt -> dts ; trk -> cluster [ trk -> entry ] . flags = 0 ; if ( trk -> start_cts == AV_NOPTS_VALUE ) trk -> start_cts = pkt -> pts - pkt -> dts ; if ( trk -> end_pts == AV_NOPTS_VALUE ) trk -> end_pts = trk -> cluster [ trk -> entry ] . dts + trk -> cluster [ trk -> entry ] . cts + pkt -> duration ; else trk -> end_pts = FFMAX ( trk -> end_pts , trk -> cluster [ trk -> entry ] . dts + trk -> cluster [ trk -> entry ] . cts + pkt -> duration ) ; if ( par -> codec_id == AV_CODEC_ID_VC1 ) { mov_parse_vc1_frame ( pkt , trk ) ; } else if ( pkt -> flags & AV_PKT_FLAG_KEY ) { if ( mov -> mode == MODE_MOV && par -> codec_id == AV_CODEC_ID_MPEG2VIDEO && trk -> entry > 0 ) { mov_parse_mpeg2_frame ( pkt , & trk -> cluster [ trk -> entry ] . flags ) ; if ( trk -> cluster [ trk -> entry ] . flags & MOV_PARTIAL_SYNC_SAMPLE ) trk -> flags |= MOV_TRACK_STPS ; } else { trk -> cluster [ trk -> entry ] . flags = MOV_SYNC_SAMPLE ; } if ( trk -> cluster [ trk -> entry ] . flags & MOV_SYNC_SAMPLE ) trk -> has_keyframes ++ ; } if ( pkt -> flags & AV_PKT_FLAG_DISPOSABLE ) { trk -> cluster [ trk -> entry ] . flags |= MOV_DISPOSABLE_SAMPLE ; trk -> has_disposable ++ ; } trk -> entry ++ ; trk -> sample_count += samples_in_chunk ; mov -> mdat_size += size ; if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) ff_mov_add_hinted_packet ( s , pkt , trk -> hint_track , trk -> entry , reformatted_data , size ) ; end : err : av_free ( reformatted_data ) ; return ret ; }","; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ("
290,cJSON * cJSON_CreateBool ( int b ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = b ? cJSON_True : cJSON_False ; return item ; },"
"
291,"static void print_trans ( netdissect_options * ndo , const u_char * words , const u_char * data1 , const u_char * buf , const u_char * maxbuf ) { u_int bcc ; const char * f1 , * f2 , * f3 , * f4 ; const u_char * data , * param ; const u_char * w = words + 1 ; int datalen , paramlen ; if ( request ) { ND_TCHECK2 ( w [ 12 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 9 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 10 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 11 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 12 * 2 ) ; f1 = ""TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nMaxParmCnt=[d]<S2SV_blank>\\nMaxDataCnt=[d]\\nMaxSCnt=[d]<S2SV_blank>\\nTransFlags=[w]<S2SV_blank>\\nRes1=[w]<S2SV_blank>\\nRes2=[w]<S2SV_blank>\\nRes3=[w]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nSUCnt=[d]\\n"" ; f2 = ""|Name=[S]\\n"" ; f3 = ""|Param<S2SV_blank>"" ; f4 = ""|Data<S2SV_blank>"" ; } else { ND_TCHECK2 ( w [ 7 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 3 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 4 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 6 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 7 * 2 ) ; f1 = ""TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nRes1=[d]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nRes2=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nRes3=[d]\\nLsetup=[d]\\n"" ; f2 = ""|Unknown<S2SV_blank>"" ; f3 = ""|Param<S2SV_blank>"" ; f4 = ""|Data<S2SV_blank>"" ; } smb_fdata ( ndo , words + 1 , f1 , min ( words + 1 + 2 * words [ 0 ] , maxbuf ) , unicodestr ) ; ND_TCHECK2 ( * data1 , 2 ) ; bcc = EXTRACT_LE_16BITS ( data1 ) ; ND_PRINT ( ( ndo , ""smb_bcc=%u\\n"" , bcc ) ) ; if ( bcc > 0 ) { smb_fdata ( ndo , data1 + 2 , f2 , maxbuf - ( paramlen + datalen ) , unicodestr ) ; <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\MAILSLOT\\\\BROWSE"" ) == 0 ) { <S2SV_EndBug> print_browse ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\PIPE\\\\LANMAN"" ) == 0 ) { <S2SV_EndBug> print_ipc ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug> smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ; if ( datalen ) smb_fdata ( ndo , data , f4 , min ( data + datalen , maxbuf ) , unicodestr ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","unicodestr ) ; # define MAILSLOT_BROWSE_STR ""\\\\MAILSLOT\\\\BROWSE"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( MAILSLOT_BROWSE_STR ) + 1 ) ; <S2SV_ModStart> 2 ) , MAILSLOT_BROWSE_STR <S2SV_ModEnd> ) == 0 <S2SV_ModStart> return ; } # undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR ""\\\\PIPE\\\\LANMAN"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ; <S2SV_ModStart> 2 ) , PIPE_LANMAN_STR <S2SV_ModEnd> ) == 0 <S2SV_ModStart> return ; } # undef PIPE_LANMAN_STR"
292,"<S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> input -> file = strcmp ( input -> filename , ""-"" ) ? fopen ( input -> filename , ""rb"" ) : set_binary_mode ( stdin ) ; if ( ! input -> file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file"" ) ; if ( ! fseeko ( input -> file , 0 , SEEK_END ) ) { input -> length = ftello ( input -> file ) ; rewind ( input -> file ) ; } <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> input -> detect . position = 0 ; if ( input -> detect . buf_read == 4 && file_is_y4m ( input -> detect . buf ) ) { if ( y4m_input_open ( & input -> y4m , input -> file , input -> detect . buf , 4 , input -> only_i420 ) >= 0 ) { input -> file_type = FILE_TYPE_Y4M ; input -> width = input -> y4m . pic_w ; input -> height = input -> y4m . pic_h ; <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> input -> framerate . denominator = input -> y4m . fps_d ; <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug> } else fatal ( ""Unsupported<S2SV_blank>Y4M<S2SV_blank>stream."" ) ; } else if ( input -> detect . buf_read == 4 && fourcc_is_ivf ( input -> detect . buf ) ) { fatal ( ""IVF<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>as<S2SV_blank>input."" ) ; } else { input -> file_type = FILE_TYPE_RAW ; } }",<S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> } input -> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; input -> <S2SV_ModStart> ; input -> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> ; input -> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> ; } else
293,"bgp_size_t bgp_packet_attribute ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , struct bpacket_attr_vec_arr * vecarr , struct prefix * p , afi_t afi , safi_t safi , struct peer * from , struct prefix_rd * prd , mpls_label_t * label , uint32_t num_labels , int addpath_encode , uint32_t addpath_tx_id ) { size_t cp ; size_t aspath_sizep ; struct aspath * aspath ; int send_as4_path = 0 ; int send_as4_aggregator = 0 ; int use32bit = ( CHECK_FLAG ( peer -> cap , PEER_CAP_AS4_RCV ) ) ? 1 : 0 ; if ( ! bgp ) bgp = peer -> bgp ; cp = stream_get_endp ( s ) ; if ( p && ! ( ( afi == AFI_IP && safi == SAFI_UNICAST ) && ! peer_cap_enhe ( peer , afi , safi ) ) ) { size_t mpattrlen_pos = 0 ; mpattrlen_pos = bgp_packet_mpattr_start ( s , peer , afi , safi , vecarr , attr ) ; bgp_packet_mpattr_prefix ( s , afi , safi , p , prd , label , num_labels , addpath_encode , addpath_tx_id , attr ) ; bgp_packet_mpattr_end ( s , mpattrlen_pos ) ; } stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_ORIGIN ) ; stream_putc ( s , 1 ) ; stream_putc ( s , attr -> origin ) ; if ( peer -> sort == BGP_PEER_EBGP && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_AS_PATH_UNCHANGED ) || attr -> aspath -> segments == NULL ) && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_RSERVER_CLIENT ) ) ) { aspath = aspath_dup ( attr -> aspath ) ; aspath = aspath_delete_confed_seq ( aspath ) ; if ( CHECK_FLAG ( bgp -> config , BGP_CONFIG_CONFEDERATION ) ) { aspath = aspath_add_seq ( aspath , bgp -> confed_id ) ; } else { if ( peer -> change_local_as ) { if ( ! CHECK_FLAG ( peer -> flags , PEER_FLAG_LOCAL_AS_REPLACE_AS ) ) { aspath = aspath_add_seq ( aspath , peer -> local_as ) ; } aspath = aspath_add_seq ( aspath , peer -> change_local_as ) ; } else { aspath = aspath_add_seq ( aspath , peer -> local_as ) ; } } } else if ( peer -> sort == BGP_PEER_CONFED ) { aspath = aspath_dup ( attr -> aspath ) ; aspath = aspath_add_confed_seq ( aspath , peer -> local_as ) ; } else aspath = attr -> aspath ; stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_AS_PATH ) ; aspath_sizep = stream_get_endp ( s ) ; stream_putw ( s , 0 ) ; stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , use32bit ) ) ; if ( ! use32bit && aspath_has_as4 ( aspath ) ) send_as4_path = 1 ; if ( afi == AFI_IP && safi == SAFI_UNICAST && ! peer_cap_enhe ( peer , afi , safi ) ) { if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_NEXT_HOP ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , attr ) ; stream_putc ( s , 4 ) ; stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; } else if ( peer_cap_enhe ( from , afi , safi ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , NULL ) ; stream_putc ( s , 4 ) ; stream_put_ipv4 ( s , 0 ) ; } } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_MULTI_EXIT_DISC ) || bgp -> maxmed_active ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_MULTI_EXIT_DISC ) ; stream_putc ( s , 4 ) ; stream_putl ( s , ( bgp -> maxmed_active ? bgp -> maxmed_value : attr -> med ) ) ; } if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_LOCAL_PREF ) ; stream_putc ( s , 4 ) ; stream_putl ( s , attr -> local_pref ) ; } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ATOMIC_AGGREGATE ) ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_ATOMIC_AGGREGATE ) ; stream_putc ( s , 0 ) ; } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_AGGREGATOR ) ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_AGGREGATOR ) ; if ( use32bit ) { stream_putc ( s , 8 ) ; stream_putl ( s , attr -> aggregator_as ) ; } else { stream_putc ( s , 6 ) ; if ( attr -> aggregator_as > 65535 ) { stream_putw ( s , BGP_AS_TRANS ) ; send_as4_aggregator = 1 ; } else stream_putw ( s , ( uint16_t ) attr -> aggregator_as ) ; } stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_COMMUNITIES ) ) ) { if ( attr -> community -> size * 4 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; stream_putw ( s , attr -> community -> size * 4 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; stream_putc ( s , attr -> community -> size * 4 ) ; } stream_put ( s , attr -> community -> val , attr -> community -> size * 4 ) ; } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_LARGE_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_LARGE_COMMUNITIES ) ) ) { if ( lcom_length ( attr -> lcommunity ) > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; stream_putw ( s , lcom_length ( attr -> lcommunity ) ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; stream_putc ( s , lcom_length ( attr -> lcommunity ) ) ; } stream_put ( s , attr -> lcommunity -> val , lcom_length ( attr -> lcommunity ) ) ; } if ( peer -> sort == BGP_PEER_IBGP && from && from -> sort == BGP_PEER_IBGP ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_ORIGINATOR_ID ) ; stream_putc ( s , 4 ) ; if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ORIGINATOR_ID ) ) stream_put_in_addr ( s , & attr -> originator_id ) ; else stream_put_in_addr ( s , & from -> remote_id ) ; stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , BGP_ATTR_CLUSTER_LIST ) ; if ( attr -> cluster ) { stream_putc ( s , attr -> cluster -> length + 4 ) ; if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) stream_put_in_addr ( s , & bgp -> cluster_id ) ; else stream_put_in_addr ( s , & bgp -> router_id ) ; stream_put ( s , attr -> cluster -> list , attr -> cluster -> length ) ; } else { stream_putc ( s , 4 ) ; if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) stream_put_in_addr ( s , & bgp -> cluster_id ) ; else stream_put_in_addr ( s , & bgp -> router_id ) ; } } if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_EXT_COMMUNITY ) && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_EXT_COMMUNITIES ) ) ) { if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { if ( attr -> ecommunity -> size * 8 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putw ( s , attr -> ecommunity -> size * 8 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putc ( s , attr -> ecommunity -> size * 8 ) ; } stream_put ( s , attr -> ecommunity -> val , attr -> ecommunity -> size * 8 ) ; } else { uint8_t * pnt ; int tbit ; int ecom_tr_size = 0 ; int i ; for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { pnt = attr -> ecommunity -> val + ( i * 8 ) ; tbit = * pnt ; if ( CHECK_FLAG ( tbit , ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) continue ; ecom_tr_size ++ ; } if ( ecom_tr_size ) { if ( ecom_tr_size * 8 > 255 ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putw ( s , ecom_tr_size * 8 ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; stream_putc ( s , ecom_tr_size * 8 ) ; } for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { pnt = attr -> ecommunity -> val + ( i * 8 ) ; tbit = * pnt ; if ( CHECK_FLAG ( tbit , ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) continue ; stream_put ( s , pnt , 8 ) ; } } } } if ( safi == SAFI_LABELED_UNICAST ) { if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PREFIX_SID ) ) { uint32_t label_index ; label_index = attr -> label_index ; if ( label_index != BGP_INVALID_LABEL_INDEX ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_PREFIX_SID ) ; stream_putc ( s , 10 ) ; stream_putc ( s , BGP_PREFIX_SID_LABEL_INDEX ) ; stream_putw ( s , BGP_PREFIX_SID_LABEL_INDEX_LENGTH ) ; stream_putc ( s , 0 ) ; stream_putw ( s , 0 ) ; stream_putl ( s , label_index ) ; } } } if ( send_as4_path ) { aspath = aspath_delete_confed_seq ( aspath ) ; stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , BGP_ATTR_AS4_PATH ) ; aspath_sizep = stream_get_endp ( s ) ; stream_putw ( s , 0 ) ; stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , 1 ) ) ; } if ( aspath != attr -> aspath ) aspath_free ( aspath ) ; if ( send_as4_aggregator ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_AS4_AGGREGATOR ) ; stream_putc ( s , 8 ) ; stream_putl ( s , attr -> aggregator_as ) ; stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; } if ( ( ( afi == AFI_IP || afi == AFI_IP6 ) && ( safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN ) ) || ( afi == AFI_L2VPN && safi == SAFI_EVPN ) ) { bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_ENCAP ) ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ; # endif } if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PMSI_TUNNEL ) ) { stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; stream_putc ( s , BGP_ATTR_PMSI_TUNNEL ) ; stream_putc ( s , 9 ) ; stream_putc ( s , 0 ) ; stream_putc ( s , PMSI_TNLTYPE_INGR_REPL ) ; stream_put ( s , & ( attr -> label ) , BGP_LABEL_BYTES ) ; stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; } if ( attr -> transit ) stream_put ( s , attr -> transit -> val , attr -> transit -> length ) ; return stream_get_endp ( s ) - cp ; }",; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp
294,"static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * ieee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx ; int err ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) return - EMSGSIZE ; ieee = nla_nest_start ( skb , DCB_ATTR_IEEE ) ; if ( ! ieee ) return - EMSGSIZE ; if ( ops -> ieee_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_getmaxrate ) { struct ieee_maxrate maxrate ; <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> if ( ! err ) { err = nla_put ( skb , DCB_ATTR_IEEE_MAXRATE , sizeof ( maxrate ) , & maxrate ) ; if ( err ) return - EMSGSIZE ; } } if ( ops -> ieee_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } app = nla_nest_start ( skb , DCB_ATTR_IEEE_APP_TABLE ) ; if ( ! app ) return - EMSGSIZE ; spin_lock ( & dcb_lock ) ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { err = nla_put ( skb , DCB_ATTR_IEEE_APP , sizeof ( itr -> app ) , & itr -> app ) ; if ( err ) { spin_unlock ( & dcb_lock ) ; return - EMSGSIZE ; } } } if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; nla_nest_end ( skb , app ) ; if ( ops -> ieee_peer_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_peer_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_IEEE_PEER_APP , DCB_ATTR_IEEE_APP_UNSPEC , DCB_ATTR_IEEE_APP ) ; if ( err ) return - EMSGSIZE ; } nla_nest_end ( skb , ieee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) return - EMSGSIZE ; } return 0 ; }","ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )"
295,"void cfm_print ( netdissect_options * ndo , register const u_char * pptr , register u_int length ) { const struct cfm_common_header_t * cfm_common_header ; const struct cfm_tlv_header_t * cfm_tlv_header ; const uint8_t * tptr , * tlv_ptr ; const uint8_t * namesp ; u_int names_data_remaining ; uint8_t md_nameformat , md_namelength ; const uint8_t * md_name ; uint8_t ma_nameformat , ma_namelength ; const uint8_t * ma_name ; u_int hexdump , tlen , cfm_tlv_len , cfm_tlv_type , ccm_interval ; union { const struct cfm_ccm_t * cfm_ccm ; const struct cfm_lbm_t * cfm_lbm ; const struct cfm_ltm_t * cfm_ltm ; const struct cfm_ltr_t * cfm_ltr ; } msg_ptr ; tptr = pptr ; cfm_common_header = ( const struct cfm_common_header_t * ) pptr ; if ( length < sizeof ( * cfm_common_header ) ) goto tooshort ; ND_TCHECK ( * cfm_common_header ) ; if ( CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) != CFM_VERSION ) { ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , length ) ) ; return ; } ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , tok2str ( cfm_opcode_values , ""unknown<S2SV_blank>(%u)"" , cfm_common_header -> opcode ) , CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tFirst<S2SV_blank>TLV<S2SV_blank>offset<S2SV_blank>%u"" , cfm_common_header -> first_tlv_offset ) ) ; tptr += sizeof ( const struct cfm_common_header_t ) ; tlen = length - sizeof ( struct cfm_common_header_t ) ; if ( cfm_common_header -> first_tlv_offset > tlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , tlen ) ) ; return ; } switch ( cfm_common_header -> opcode ) { case CFM_OPCODE_CCM : msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ccm ) ; ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]"" , ccm_interval , cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? "",<S2SV_blank>RDI"" : """" ) ) ; if ( ccm_interval ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>CCM<S2SV_blank>Interval<S2SV_blank>%.3fs"" "",<S2SV_blank>min<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs,<S2SV_blank>max<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs"" , ccm_interval_base [ ccm_interval ] , ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MIN_MULTIPLIER , ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MAX_MULTIPLIER ) ) ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Sequence<S2SV_blank>Number<S2SV_blank>0x%08x,<S2SV_blank>MA-End-Point-ID<S2SV_blank>0x%04x"" , EXTRACT_32BITS ( msg_ptr . cfm_ccm -> sequence ) , EXTRACT_16BITS ( msg_ptr . cfm_ccm -> ma_epi ) ) ) ; namesp = msg_ptr . cfm_ccm -> names ; names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ; md_nameformat = * namesp ; namesp ++ ; names_data_remaining -- ; if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) { md_namelength = * namesp ; namesp ++ ; names_data_remaining -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_md_nameformat_values , ""Unknown"" , md_nameformat ) , md_nameformat , md_namelength ) ) ; if ( md_namelength > names_data_remaining - 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining - 2 ) ) ; return ; } md_name = namesp ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name:<S2SV_blank>"" ) ) ; switch ( md_nameformat ) { case CFM_CCM_MD_FORMAT_DNS : case CFM_CCM_MD_FORMAT_CHAR : safeputs ( ndo , md_name , md_namelength ) ; break ; case CFM_CCM_MD_FORMAT_MAC : if ( md_namelength == 6 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , md_name ) ) ) ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>(length<S2SV_blank>invalid)"" ) ) ; } break ; case CFM_CCM_MA_FORMAT_8021 : default : print_unknown_data ( ndo , md_name , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , md_namelength ) ; } namesp += md_namelength ; names_data_remaining -= md_namelength ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_md_nameformat_values , ""Unknown"" , md_nameformat ) , md_nameformat ) ) ; } ma_nameformat = * namesp ; namesp ++ ; names_data_remaining -- ; ma_namelength = * namesp ; namesp ++ ; names_data_remaining -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name-Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MA<S2SV_blank>name<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_ma_nameformat_values , ""Unknown"" , ma_nameformat ) , ma_nameformat , ma_namelength ) ) ; if ( ma_namelength > names_data_remaining ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining ) ) ; return ; } ma_name = namesp ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name:<S2SV_blank>"" ) ) ; switch ( ma_nameformat ) { case CFM_CCM_MA_FORMAT_CHAR : safeputs ( ndo , ma_name , ma_namelength ) ; break ; case CFM_CCM_MA_FORMAT_8021 : case CFM_CCM_MA_FORMAT_VID : case CFM_CCM_MA_FORMAT_INT : case CFM_CCM_MA_FORMAT_VPN : default : print_unknown_data ( ndo , ma_name , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ma_namelength ) ; } break ; case CFM_OPCODE_LTM : msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ltm ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltm_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u"" , EXTRACT_32BITS ( msg_ptr . cfm_ltm -> transaction_id ) , msg_ptr . cfm_ltm -> ttl ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Original-MAC<S2SV_blank>%s,<S2SV_blank>Target-MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , msg_ptr . cfm_ltm -> original_mac ) , etheraddr_string ( ndo , msg_ptr . cfm_ltm -> target_mac ) ) ) ; break ; case CFM_OPCODE_LTR : msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ; if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ; return ; } if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) goto tooshort ; ND_TCHECK ( * msg_ptr . cfm_ltr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltr_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u"" , EXTRACT_32BITS ( msg_ptr . cfm_ltr -> transaction_id ) , msg_ptr . cfm_ltr -> ttl ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Replay-Action<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_ltr_replay_action_values , ""Unknown"" , msg_ptr . cfm_ltr -> replay_action ) , msg_ptr . cfm_ltr -> replay_action ) ) ; break ; case CFM_OPCODE_LBR : case CFM_OPCODE_LBM : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , tlen - cfm_common_header -> first_tlv_offset ) ; break ; } tptr += cfm_common_header -> first_tlv_offset ; tlen -= cfm_common_header -> first_tlv_offset ; while ( tlen > 0 ) { cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ; ND_TCHECK2 ( * tptr , 1 ) ; cfm_tlv_type = cfm_tlv_header -> type ; ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>TLV<S2SV_blank>(0x%02x)"" , tok2str ( cfm_tlv_values , ""Unknown"" , cfm_tlv_type ) , cfm_tlv_type ) ) ; if ( cfm_tlv_type == CFM_TLV_END ) { return ; } if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) goto tooshort ; ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ; cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , cfm_tlv_len ) ) ; tptr += sizeof ( struct cfm_tlv_header_t ) ; tlen -= sizeof ( struct cfm_tlv_header_t ) ; tlv_ptr = tptr ; if ( tlen < cfm_tlv_len ) goto tooshort ; ND_TCHECK2 ( * tptr , cfm_tlv_len ) ; hexdump = FALSE ; switch ( cfm_tlv_type ) { case CFM_TLV_PORT_STATUS : if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_port_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ; break ; case CFM_TLV_INTERFACE_STATUS : if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_interface_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ; break ; case CFM_TLV_PRIVATE : if ( cfm_tlv_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return ; } ND_PRINT ( ( ndo , "",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( tptr ) ) , EXTRACT_24BITS ( tptr ) , * ( tptr + 3 ) ) ) ; hexdump = TRUE ; break ; case CFM_TLV_SENDER_ID : { u_int chassis_id_type , chassis_id_length ; u_int mgmt_addr_length ; if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } chassis_id_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; if ( chassis_id_length ) { if ( cfm_tlv_len < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } chassis_id_type = * tptr ; cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Chassis-ID<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Chassis-ID<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( cfm_tlv_senderid_chassisid_values , ""Unknown"" , chassis_id_type ) , chassis_id_type , chassis_id_length ) ) ; if ( cfm_tlv_len < chassis_id_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } switch ( chassis_id_type ) { <S2SV_StartBug> case CFM_CHASSIS_ID_MAC_ADDRESS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , tptr + 1 ) ) ) ; break ; case CFM_CHASSIS_ID_NETWORK_ADDRESS : <S2SV_StartBug> hexdump |= cfm_network_addr_print ( ndo , tptr ) ; <S2SV_EndBug> break ; case CFM_CHASSIS_ID_INTERFACE_NAME : case CFM_CHASSIS_ID_INTERFACE_ALIAS : case CFM_CHASSIS_ID_LOCAL : case CFM_CHASSIS_ID_CHASSIS_COMPONENT : case CFM_CHASSIS_ID_PORT_COMPONENT : safeputs ( ndo , tptr + 1 , chassis_id_length ) ; break ; default : hexdump = TRUE ; break ; } cfm_tlv_len -= chassis_id_length ; tptr += 1 + chassis_id_length ; tlen -= 1 + chassis_id_length ; } if ( cfm_tlv_len == 0 ) { <S2SV_StartBug> return ; <S2SV_EndBug> } mgmt_addr_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> if ( cfm_tlv_len < mgmt_addr_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> tptr += mgmt_addr_length ; tlen -= mgmt_addr_length ; if ( cfm_tlv_len < 1 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_EndBug> return ; } mgmt_addr_length = * tptr ; tptr ++ ; tlen -- ; cfm_tlv_len -- ; <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> if ( cfm_tlv_len < mgmt_addr_length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; return ; } <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> tptr += mgmt_addr_length ; tlen -= mgmt_addr_length ; } } break ; } case CFM_TLV_DATA : case CFM_TLV_REPLY_INGRESS : case CFM_TLV_REPLY_EGRESS : default : hexdump = TRUE ; break ; } if ( hexdump || ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tlv_ptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , cfm_tlv_len ) ; <S2SV_StartBug> tptr += cfm_tlv_len ; <S2SV_EndBug> tlen -= cfm_tlv_len ; } return ; tooshort : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }",") ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_length <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_type <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } switch <S2SV_ModStart> case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> ndo , tptr + 1 , chassis_id_length <S2SV_ModStart> 0 ) { break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } cfm_tlv_len <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> ( ndo , ""<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)"" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> cfm_tlv_len ) ; next_tlv :"
296,"<S2SV_StartBug> void fadst4_sse2 ( __m128i * in ) { <S2SV_EndBug> const __m128i k__sinpi_p01_p02 = pair_set_epi16 ( sinpi_1_9 , sinpi_2_9 ) ; const __m128i k__sinpi_p04_m01 = pair_set_epi16 ( sinpi_4_9 , - sinpi_1_9 ) ; const __m128i k__sinpi_p03_p04 = pair_set_epi16 ( sinpi_3_9 , sinpi_4_9 ) ; const __m128i k__sinpi_m03_p02 = pair_set_epi16 ( - sinpi_3_9 , sinpi_2_9 ) ; <S2SV_StartBug> const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( sinpi_3_9 ) ; <S2SV_EndBug> const __m128i kZero = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u [ 8 ] , v [ 8 ] ; __m128i in7 = _mm_add_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 1 ] = _mm_unpacklo_epi16 ( in [ 2 ] , in [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in7 , kZero ) ; u [ 3 ] = _mm_unpacklo_epi16 ( in [ 2 ] , kZero ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 3 ] , kZero ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__sinpi_p01_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__sinpi_p03_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__sinpi_p03_p03 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 0 ] , k__sinpi_p04_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 1 ] , k__sinpi_m03_p02 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__sinpi_p03_p03 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 4 ] , k__sinpi_p03_p03 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 3 ] , v [ 4 ] ) ; u [ 3 ] = _mm_sub_epi32 ( u [ 2 ] , u [ 0 ] ) ; u [ 4 ] = _mm_slli_epi32 ( v [ 5 ] , 2 ) ; u [ 5 ] = _mm_sub_epi32 ( u [ 4 ] , v [ 5 ] ) ; u [ 6 ] = _mm_add_epi32 ( u [ 3 ] , u [ 5 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 2 ] ) ; in [ 1 ] = _mm_packs_epi32 ( u [ 1 ] , u [ 3 ] ) ; transpose_4x4 ( in ) ; }",<S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
297,"int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame."" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; ++ frame_cnt ; } } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec"" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }","( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,"
298,"int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }",= - EINVAL ; msg -> msg_namelen = 0
299,"static int target_xcopy_parse_target_descriptors ( struct se_cmd * se_cmd , struct xcopy_op * xop , unsigned char * p , unsigned short tdll , sense_reason_t * sense_ret ) { struct se_device * local_dev = se_cmd -> se_dev ; unsigned char * desc = p ; int offset = tdll % XCOPY_TARGET_DESC_LEN , rc ; unsigned short cscd_index = 0 ; unsigned short start = 0 ; * sense_ret = TCM_INVALID_PARAMETER_LIST ; if ( offset != 0 ) { pr_err ( ""XCOPY<S2SV_blank>target<S2SV_blank>descriptor<S2SV_blank>list<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not"" ""<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>%d\\n"" , XCOPY_TARGET_DESC_LEN ) ; * sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE ; return - EINVAL ; } if ( tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN ) { pr_err ( ""XCOPY<S2SV_blank>target<S2SV_blank>descriptor<S2SV_blank>supports<S2SV_blank>a<S2SV_blank>maximum"" ""<S2SV_blank>two<S2SV_blank>src/dest<S2SV_blank>descriptors,<S2SV_blank>tdll:<S2SV_blank>%hu<S2SV_blank>too<S2SV_blank>large..\\n"" , tdll ) ; * sense_ret = TCM_TOO_MANY_TARGET_DESCS ; return - EINVAL ; } memset ( & xop -> local_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ; target_xcopy_gen_naa_ieee ( local_dev , & xop -> local_dev_wwn [ 0 ] ) ; while ( start < tdll ) { switch ( desc [ 0 ] ) { case 0xe4 : rc = target_xcopy_parse_tiddesc_e4 ( se_cmd , xop , & desc [ 0 ] , cscd_index ) ; if ( rc != 0 ) goto out ; start += XCOPY_TARGET_DESC_LEN ; desc += XCOPY_TARGET_DESC_LEN ; cscd_index ++ ; break ; default : pr_err ( ""XCOPY<S2SV_blank>unsupported<S2SV_blank>descriptor<S2SV_blank>type<S2SV_blank>code:"" ""<S2SV_blank>0x%02x\\n"" , desc [ 0 ] ) ; * sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE ; goto out ; } } switch ( xop -> op_origin ) { case XCOL_SOURCE_RECV_OP : <S2SV_StartBug> rc = target_xcopy_locate_se_dev_e4 ( xop -> dst_tid_wwn , <S2SV_EndBug> <S2SV_StartBug> & xop -> dst_dev ) ; <S2SV_EndBug> break ; case XCOL_DEST_RECV_OP : <S2SV_StartBug> rc = target_xcopy_locate_se_dev_e4 ( xop -> src_tid_wwn , <S2SV_EndBug> <S2SV_StartBug> & xop -> src_dev ) ; <S2SV_EndBug> break ; default : pr_err ( ""XCOPY<S2SV_blank>CSCD<S2SV_blank>descriptor<S2SV_blank>IDs<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>CSCD<S2SV_blank>list<S2SV_blank>-<S2SV_blank>"" ""stdi:<S2SV_blank>%hu<S2SV_blank>dtdi:<S2SV_blank>%hu\\n"" , xop -> stdi , xop -> dtdi ) ; rc = - EINVAL ; break ; } if ( rc < 0 ) { * sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE ; goto out ; } pr_debug ( ""XCOPY<S2SV_blank>TGT<S2SV_blank>desc:<S2SV_blank>Source<S2SV_blank>dev:<S2SV_blank>%p<S2SV_blank>NAA<S2SV_blank>IEEE<S2SV_blank>WWN:<S2SV_blank>0x%16phN\\n"" , xop -> src_dev , & xop -> src_tid_wwn [ 0 ] ) ; pr_debug ( ""XCOPY<S2SV_blank>TGT<S2SV_blank>desc:<S2SV_blank>Dest<S2SV_blank>dev:<S2SV_blank>%p<S2SV_blank>NAA<S2SV_blank>IEEE<S2SV_blank>WWN:<S2SV_blank>0x%16phN\\n"" , xop -> dst_dev , & xop -> dst_tid_wwn [ 0 ] ) ; return cscd_index ; out : return - EINVAL ; }","= target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , <S2SV_ModStart> xop -> dst_dev , & xop -> remote_lun_ref <S2SV_ModStart> = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , <S2SV_ModStart> xop -> src_dev , & xop -> remote_lun_ref"
300,"<S2SV_StartBug> void ipc_rcu_getref ( void * ptr ) <S2SV_EndBug> { <S2SV_StartBug> container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount ++ ; <S2SV_EndBug> }",<S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> ipc_rcu_getref ( void <S2SV_ModStart> ptr ) { return atomic_inc_not_zero ( & <S2SV_ModStart> ) -> refcount ) <S2SV_ModEnd> ; } <S2SV_null>
301,"static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }","siocb -> scm , true"
302,"static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; ( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ( int ) ReadBlobLong ( image ) ; viff_info . y_offset = ( int ) ReadBlobLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , <S2SV_EndBug> bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( MagickRealType ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( MagickRealType ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( image -> storage_class != PseudoClass ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * ( p + number_pixels ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . red ) ; index = ( ssize_t ) GetPixelGreen ( q ) ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . green ) ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . blue ) ; } SetPixelOpacity ( q , image -> matte != MagickFalse ? QuantumRange - ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",") AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel * sizeof"
303,"jas_image_t * jpg_decode ( jas_stream_t * in , char * optstr ) { struct jpeg_decompress_struct cinfo ; struct jpeg_error_mgr jerr ; FILE * input_file ; jpg_dest_t dest_mgr_buf ; jpg_dest_t * dest_mgr = & dest_mgr_buf ; JDIMENSION num_scanlines ; jas_image_t * image ; int ret ; jpg_dec_importopts_t opts ; <S2SV_StartBug> size_t size ; <S2SV_EndBug> if ( jpg_dec_parseopts ( optstr , & opts ) ) { goto error ; } memset ( & cinfo , 0 , sizeof ( struct jpeg_decompress_struct ) ) ; memset ( dest_mgr , 0 , sizeof ( jpg_dest_t ) ) ; dest_mgr -> data = 0 ; image = 0 ; input_file = 0 ; if ( ! ( input_file = tmpfile ( ) ) ) { jas_eprintf ( ""cannot<S2SV_blank>make<S2SV_blank>temporary<S2SV_blank>file\\n"" ) ; goto error ; } if ( jpg_copystreamtofile ( input_file , in ) ) { jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>stream\\n"" ) ; goto error ; } rewind ( input_file ) ; JAS_DBGLOG ( 10 , ( ""jpeg_std_error(%p)\\n"" , & jerr ) ) ; cinfo . err = jpeg_std_error ( & jerr ) ; JAS_DBGLOG ( 10 , ( ""jpeg_create_decompress(%p)\\n"" , & cinfo ) ) ; jpeg_create_decompress ( & cinfo ) ; JAS_DBGLOG ( 10 , ( ""jpeg_stdio_src(%p,<S2SV_blank>%p)\\n"" , & cinfo , input_file ) ) ; jpeg_stdio_src ( & cinfo , input_file ) ; JAS_DBGLOG ( 10 , ( ""jpeg_read_header(%p,<S2SV_blank>TRUE)\\n"" , & cinfo ) ) ; ret = jpeg_read_header ( & cinfo , TRUE ) ; JAS_DBGLOG ( 10 , ( ""jpeg_read_header<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\n"" , ret ) ) ; if ( ret != JPEG_HEADER_OK ) { jas_eprintf ( ""jpeg_read_header<S2SV_blank>did<S2SV_blank>not<S2SV_blank>return<S2SV_blank>JPEG_HEADER_OK\\n"" ) ; } JAS_DBGLOG ( 10 , ( ""header:<S2SV_blank>image_width<S2SV_blank>%d;<S2SV_blank>image_height<S2SV_blank>%d;<S2SV_blank>num_components<S2SV_blank>%d\\n"" , cinfo . image_width , cinfo . image_height , cinfo . num_components ) ) ; <S2SV_StartBug> JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress(%p)\\n"" , & cinfo ) ) ; <S2SV_EndBug> ret = jpeg_start_decompress ( & cinfo ) ; JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\n"" , ret ) ) ; JAS_DBGLOG ( 10 , ( ""header:<S2SV_blank>output_width<S2SV_blank>%d;<S2SV_blank>output_height<S2SV_blank>%d;<S2SV_blank>output_components<S2SV_blank>%d\\n"" , cinfo . output_width , cinfo . output_height , cinfo . output_components ) ) ; <S2SV_StartBug> if ( opts . max_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! jas_safe_size_mul ( cinfo . output_width , cinfo . output_height , <S2SV_EndBug> & size ) || ! jas_safe_size_mul ( size , cinfo . output_components , & size ) ) { goto error ; } <S2SV_StartBug> if ( size > opts . max_size ) { <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\n"" ) ; <S2SV_EndBug> goto error ; } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( image = jpg_mkimage ( & cinfo ) ) ) { jas_eprintf ( ""jpg_mkimage<S2SV_blank>failed\\n"" ) ; goto error ; } dest_mgr -> image = image ; if ( ! ( dest_mgr -> data = jas_matrix_create ( 1 , cinfo . output_width ) ) ) { jas_eprintf ( ""jas_matrix_create<S2SV_blank>failed\\n"" ) ; goto error ; } dest_mgr -> start_output = jpg_start_output ; dest_mgr -> put_pixel_rows = jpg_put_pixel_rows ; dest_mgr -> finish_output = jpg_finish_output ; dest_mgr -> buffer = ( * cinfo . mem -> alloc_sarray ) ( ( j_common_ptr ) & cinfo , JPOOL_IMAGE , cinfo . output_width * cinfo . output_components , ( JDIMENSION ) 1 ) ; dest_mgr -> buffer_height = 1 ; dest_mgr -> error = 0 ; ( * dest_mgr -> start_output ) ( & cinfo , dest_mgr ) ; while ( cinfo . output_scanline < cinfo . output_height ) { JAS_DBGLOG ( 10 , ( ""jpeg_read_scanlines(%p,<S2SV_blank>%p,<S2SV_blank>%lu)\\n"" , & cinfo , dest_mgr -> buffer , JAS_CAST ( unsigned long , dest_mgr -> buffer_height ) ) ) ; num_scanlines = jpeg_read_scanlines ( & cinfo , dest_mgr -> buffer , dest_mgr -> buffer_height ) ; JAS_DBGLOG ( 10 , ( ""jpeg_read_scanlines<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%lu\\n"" , JAS_CAST ( unsigned long , num_scanlines ) ) ) ; ( * dest_mgr -> put_pixel_rows ) ( & cinfo , dest_mgr , num_scanlines ) ; } ( * dest_mgr -> finish_output ) ( & cinfo , dest_mgr ) ; JAS_DBGLOG ( 10 , ( ""jpeg_finish_decompress(%p)\\n"" , & cinfo ) ) ; jpeg_finish_decompress ( & cinfo ) ; JAS_DBGLOG ( 10 , ( ""jpeg_destroy_decompress(%p)\\n"" , & cinfo ) ) ; jpeg_destroy_decompress ( & cinfo ) ; jas_matrix_destroy ( dest_mgr -> data ) ; JAS_DBGLOG ( 10 , ( ""fclose(%p)\\n"" , input_file ) ) ; fclose ( input_file ) ; input_file = 0 ; if ( dest_mgr -> error ) { jas_eprintf ( ""error<S2SV_blank>during<S2SV_blank>decoding\\n"" ) ; goto error ; } return image ; error : if ( dest_mgr -> data ) { jas_matrix_destroy ( dest_mgr -> data ) ; } if ( image ) { jas_image_destroy ( image ) ; } if ( input_file ) { fclose ( input_file ) ; } return 0 ; }","opts ; size_t num_samples ; JAS_DBGLOG ( 100 , ( ""jpg_decode(%p,<S2SV_blank>\\""%s\\"")\\n"" , in , optstr ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( opts <S2SV_ModStart> ( opts . max_samples > 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> if ( ! jas_safe_size_mul3 ( cinfo . image_width , cinfo . image_height , cinfo . num_components , & num_samples <S2SV_ModEnd> ) ) { <S2SV_ModStart> } if ( num_samples <S2SV_ModEnd> > opts . <S2SV_ModStart> > opts . max_samples <S2SV_ModEnd> ) { jas_eprintf <S2SV_ModStart> { jas_eprintf ( ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%zu<S2SV_blank>><S2SV_blank>%zu)\\n"" , num_samples , opts . max_samples <S2SV_ModEnd> ) ; goto <S2SV_ModStart> ; } } JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress(%p)\\n"" , & cinfo ) ) ; ret = jpeg_start_decompress ( & cinfo ) ; JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\n"" , ret ) ) ; JAS_DBGLOG ( 10 , ( ""header:<S2SV_blank>output_width<S2SV_blank>%d;<S2SV_blank>output_height<S2SV_blank>%d;<S2SV_blank>output_components<S2SV_blank>%d\\n"" , cinfo . output_width , cinfo . output_height , cinfo . output_components ) ) ;"
304,"static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }",-> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;
305,"static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } <S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }",tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> tlen = compile_length_tree
306,"void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }",priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
307,"static int snd_usb_create_streams ( struct snd_usb_audio * chip , int ctrlif ) { struct usb_device * dev = chip -> dev ; struct usb_host_interface * host_iface ; struct usb_interface_descriptor * altsd ; void * control_header ; <S2SV_StartBug> int i , protocol ; <S2SV_EndBug> host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ; control_header = snd_usb_find_csint_desc ( host_iface -> extra , host_iface -> extralen , NULL , UAC_HEADER ) ; altsd = get_iface_desc ( host_iface ) ; protocol = altsd -> bInterfaceProtocol ; if ( ! control_header ) { dev_err ( & dev -> dev , ""cannot<S2SV_blank>find<S2SV_blank>UAC_HEADER\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> switch ( protocol ) { <S2SV_EndBug> default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\n"" , protocol ) ; case UAC_VERSION_1 : { struct uac1_ac_header_descriptor * h1 = control_header ; <S2SV_StartBug> if ( ! h1 -> bInCollection ) { <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; <S2SV_EndBug> return - EINVAL ; } if ( h1 -> bLength < sizeof ( * h1 ) + h1 -> bInCollection ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>UAC_HEADER<S2SV_blank>(v1)\\n"" ) ; return - EINVAL ; } for ( i = 0 ; i < h1 -> bInCollection ; i ++ ) snd_usb_create_stream ( chip , ctrlif , h1 -> baInterfaceNr [ i ] ) ; break ; } case UAC_VERSION_2 : { struct usb_interface_assoc_descriptor * assoc = usb_ifnum_to_if ( dev , ctrlif ) -> intf_assoc ; if ( ! assoc ) { struct usb_interface * iface = usb_ifnum_to_if ( dev , ctrlif + 1 ) ; if ( iface && iface -> intf_assoc && iface -> intf_assoc -> bFunctionClass == USB_CLASS_AUDIO && iface -> intf_assoc -> bFunctionProtocol == UAC_VERSION_2 ) assoc = iface -> intf_assoc ; } if ( ! assoc ) { dev_err ( & dev -> dev , ""Audio<S2SV_blank>class<S2SV_blank>v2<S2SV_blank>interfaces<S2SV_blank>need<S2SV_blank>an<S2SV_blank>interface<S2SV_blank>association\\n"" ) ; return - EINVAL ; } for ( i = 0 ; i < assoc -> bInterfaceCount ; i ++ ) { int intf = assoc -> bFirstInterface + i ; if ( intf != ctrlif ) snd_usb_create_stream ( chip , ctrlif , intf ) ; } break ; } } return 0 ; }","i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n"" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"""
308,"void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }","struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,"
309,"int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = NULL ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = NULL ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , NULL , skb ) || ! af -> addr_valid ( & dest , NULL , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport ) ; if ( ! asoc ) ep = __sctp_rcv_lookup_endpoint ( & dest ) ; rcvr = asoc ? & asoc -> base : & ep -> base ; sk = rcvr -> sk ; if ( sk -> sk_bound_dev_if && ( sk -> sk_bound_dev_if != af -> skb_iif ( skb ) ) ) { if ( asoc ) { sctp_association_put ( asoc ) ; asoc = NULL ; } else { sctp_endpoint_put ( ep ) ; ep = NULL ; } sk = sctp_get_ctl_sock ( ) ; ep = sctp_sk ( sk ) -> ep ; sctp_endpoint_hold ( ep ) ; rcvr = & ep -> base ; } if ( ! asoc ) { if ( sctp_rcv_ootb ( skb ) ) { SCTP_INC_STATS_BH ( SCTP_MIB_OUTOFBLUES ) ; goto discard_release ; } } if ( ! xfrm_policy_check ( sk , XFRM_POLICY_IN , skb , family ) ) goto discard_release ; nf_reset ( skb ) ; if ( sk_filter ( sk , skb ) ) goto discard_release ; chunk = sctp_chunkify ( skb , asoc , sk ) ; if ( ! chunk ) goto discard_release ; SCTP_INPUT_CB ( skb ) -> chunk = chunk ; chunk -> rcvr = rcvr ; chunk -> sctp_hdr = sh ; sctp_init_addrs ( chunk , & src , & dest ) ; chunk -> transport = transport ; sctp_bh_lock_sock ( sk ) ; <S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug> SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ; sctp_add_backlog ( sk , skb ) ; } else { SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_SOFTIRQ ) ; sctp_inq_push ( & chunk -> rcvr -> inqueue , chunk ) ; } sctp_bh_unlock_sock ( sk ) ; if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; return 0 ; discard_it : SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_DISCARDS ) ; kfree_skb ( skb ) ; return 0 ; discard_release : if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; goto discard_it ; }",; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
310,"void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"""
311,"<S2SV_StartBug> static void <S2SV_EndBug> horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] -= wp [ 0 ] ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;"
312,"struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }",r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||
313,"char * enl_ipc_get ( const char * msg_data ) { static char * message = NULL ; <S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ; if ( msg_data == IPC_TIMEOUT ) { return ( IPC_TIMEOUT ) ; } for ( i = 0 ; i < 12 ; i ++ ) { buff [ i ] = msg_data [ i ] ; } buff [ 12 ] = 0 ; blen = strlen ( buff ) ; if ( message != NULL ) { len += blen ; message = ( char * ) erealloc ( message , len + 1 ) ; strcat ( message , buff ) ; } else { len = blen ; message = ( char * ) emalloc ( len + 1 ) ; strcpy ( message , buff ) ; } if ( blen < 12 ) { ret_msg = message ; message = NULL ; D ( ( ""Received<S2SV_blank>complete<S2SV_blank>reply:<S2SV_blank><S2SV_blank>\\""%s\\""\\n"" , ret_msg ) ) ; } return ( ret_msg ) ; }",NULL ; static size_t <S2SV_ModEnd> len = 0
314,"<S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> unsigned int keylen ) { return - ENOSYS ; }",<S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
315,"void vp9_tile_init ( TileInfo * tile , const VP9_COMMON * cm , int row , int col ) { <S2SV_StartBug> tile -> mi_row_start = get_tile_offset ( row , cm -> mi_rows , cm -> log2_tile_rows ) ; <S2SV_EndBug> tile -> mi_row_end = get_tile_offset ( row + 1 , cm -> mi_rows , cm -> log2_tile_rows ) ; tile -> mi_col_start = get_tile_offset ( col , cm -> mi_cols , cm -> log2_tile_cols ) ; tile -> mi_col_end = get_tile_offset ( col + 1 , cm -> mi_cols , cm -> log2_tile_cols ) ; }","col ) { vp9_tile_set_row ( tile , cm , row ) ; vp9_tile_set_col ( tile , cm , col <S2SV_ModEnd> ) ; }"
316,<S2SV_StartBug> static double get_rate_correction_factor ( const VP9_COMP * cpi ) { <S2SV_EndBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_StartBug> return cpi -> rc . key_frame_rate_correction_factor ; <S2SV_EndBug> } else { if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> return cpi -> rc . gf_rate_correction_factor ; else return cpi -> rc . rate_correction_factor ; } },"cpi ) { const RATE_CONTROL * const rc = & cpi -> rc ; double rcf ; <S2SV_ModStart> KEY_FRAME ) { rcf = rc -> rate_correction_factors [ KF_STD ] ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rcf = rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> ; } else <S2SV_ModStart> ) && ! rc -> <S2SV_ModEnd> is_src_frame_alt_ref && ! <S2SV_ModStart> is_src_frame_alt_ref && ! <S2SV_ModEnd> cpi -> use_svc <S2SV_ModStart> -> use_svc && ( <S2SV_ModStart> -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rcf = rc -> rate_correction_factors [ GF_ARF_STD ] ; else rcf = rc -> rate_correction_factors [ INTER_NORMAL ] ; } rcf *= rcf_mult [ rc -> frame_size_selector ] ; return fclamp ( rcf , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
317,"static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",", message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ("
318,"static int smb_send_rqst ( struct TCP_Server_Info * server , struct smb_rqst * rqst ) { int rc ; struct kvec * iov = rqst -> rq_iov ; int n_vec = rqst -> rq_nvec ; unsigned int smb_buf_length = get_rfc1002_length ( iov [ 0 ] . iov_base ) ; unsigned int i ; size_t total_len = 0 , sent ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> int val = 1 ; <S2SV_EndBug> cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ; dump_smb ( iov [ 0 ] . iov_base , iov [ 0 ] . iov_len ) ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; rc = smb_send_kvec ( server , iov , n_vec , & sent ) ; if ( rc < 0 ) goto uncork ; total_len += sent ; for ( i = 0 ; i < rqst -> rq_npages ; i ++ ) { struct kvec p_iov ; cifs_rqst_page_to_kvec ( rqst , i , & p_iov ) ; rc = smb_send_kvec ( server , & p_iov , 1 , & sent ) ; kunmap ( rqst -> rq_pages [ i ] ) ; if ( rc < 0 ) break ; total_len += sent ; } uncork : val = 0 ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; if ( ( total_len > 0 ) && ( total_len != smb_buf_length + 4 ) ) { cFYI ( 1 , ""partial<S2SV_blank>send<S2SV_blank>(wanted=%u<S2SV_blank>sent=%zu):<S2SV_blank>terminating<S2SV_blank>"" ""session"" , smb_buf_length + 4 , total_len ) ; server -> tcpStatus = CifsNeedReconnect ; } if ( rc < 0 && rc != - EINTR ) cERROR ( 1 , ""Error<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>data<S2SV_blank>on<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>server"" , rc ) ; else rc = 0 ; return rc ; }",val = 1 ; if ( ssocket == NULL ) return - ENOTSOCK
319,"static void recovery_abort ( void ) { if ( ! dry_run ) { storage_reset ( ) ; <S2SV_StartBug> } <S2SV_EndBug> awaiting_character = false ; memzero ( mnemonic , sizeof ( mnemonic ) ) ; memzero ( cipher , sizeof ( cipher ) ) ; }",) ; } recovery_started = false ;
320,"static int list_tables ( MYSQL * mysql , const char * db , const char * table ) { const char * header ; uint head_length , counter = 0 ; <S2SV_StartBug> char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ; <S2SV_EndBug> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row , rrow ; if ( mysql_select_db ( mysql , db ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>db<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; return 1 ; } if ( table ) { mysql_real_escape_string ( mysql , rows , table , ( unsigned long ) strlen ( table ) ) ; my_snprintf ( query , sizeof ( query ) , ""show%s<S2SV_blank>tables<S2SV_blank>like<S2SV_blank>\'%s\'"" , opt_table_type ? ""<S2SV_blank>full"" : """" , rows ) ; } else my_snprintf ( query , sizeof ( query ) , ""show%s<S2SV_blank>tables"" , opt_table_type ? ""<S2SV_blank>full"" : """" ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>tables<S2SV_blank>in<S2SV_blank>%s:<S2SV_blank>%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; exit ( 1 ) ; } printf ( ""Database:<S2SV_blank>%s"" , db ) ; if ( table ) printf ( ""<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s"" , table ) ; putchar ( '\\n' ) ; header = ""Tables"" ; head_length = ( uint ) strlen ( header ) ; field = mysql_fetch_field ( result ) ; if ( head_length < field -> max_length ) head_length = field -> max_length ; if ( opt_table_type ) { if ( ! opt_verbose ) print_header ( header , head_length , ""table_type"" , 10 , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , head_length , ""table_type"" , 10 , ""Columns"" , 8 , NullS ) ; else { print_header ( header , head_length , ""table_type"" , 10 , ""Columns"" , 8 , ""Total<S2SV_blank>Rows"" , 10 , NullS ) ; } } else { if ( ! opt_verbose ) print_header ( header , head_length , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , head_length , ""Columns"" , 8 , NullS ) ; else print_header ( header , head_length , ""Columns"" , 8 , ""Total<S2SV_blank>Rows"" , 10 , NullS ) ; } while ( ( row = mysql_fetch_row ( result ) ) ) { counter ++ ; if ( opt_verbose > 0 ) { if ( ! ( mysql_select_db ( mysql , db ) ) ) { MYSQL_RES * rresult = mysql_list_fields ( mysql , row [ 0 ] , NULL ) ; ulong rowcount = 0L ; if ( ! rresult ) { strmov ( fields , ""N/A"" ) ; strmov ( rows , ""N/A"" ) ; } else { sprintf ( fields , ""%8u"" , ( uint ) mysql_num_fields ( rresult ) ) ; mysql_free_result ( rresult ) ; if ( opt_verbose > 1 ) { <S2SV_StartBug> sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , row [ 0 ] ) ; <S2SV_EndBug> if ( ! ( mysql_query ( mysql , query ) ) ) { if ( ( rresult = mysql_store_result ( mysql ) ) ) { rrow = mysql_fetch_row ( rresult ) ; rowcount += ( unsigned long ) strtoull ( rrow [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( rresult ) ; } sprintf ( rows , ""%10lu"" , rowcount ) ; } else sprintf ( rows , ""%10d"" , 0 ) ; } } } else { strmov ( fields , ""N/A"" ) ; strmov ( rows , ""N/A"" ) ; } } if ( opt_table_type ) { if ( ! opt_verbose ) print_row ( row [ 0 ] , head_length , row [ 1 ] , 10 , NullS ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , head_length , row [ 1 ] , 10 , fields , 8 , NullS ) ; else print_row ( row [ 0 ] , head_length , row [ 1 ] , 10 , fields , 8 , rows , 10 , NullS ) ; } else { if ( ! opt_verbose ) print_row ( row [ 0 ] , head_length , NullS ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , head_length , fields , 8 , NullS ) ; else print_row ( row [ 0 ] , head_length , fields , 8 , rows , 10 , NullS ) ; } } print_trailer ( head_length , ( opt_table_type ? 10 : opt_verbose > 0 ? 8 : 0 ) , ( opt_table_type ? ( opt_verbose > 0 ? 8 : 0 ) : ( opt_verbose > 1 ? 10 : 0 ) ) , ! opt_table_type ? 0 : opt_verbose > 1 ? 10 : 0 , 0 ) ; if ( counter && opt_verbose ) printf ( ""%u<S2SV_blank>row%s<S2SV_blank>in<S2SV_blank>set.\\n\\n"" , counter , ( counter > 1 ) ? ""s"" : """" ) ; mysql_free_result ( result ) ; return 0 ; }","char query [ NAME_LEN + 100 <S2SV_ModEnd> ] , rows <S2SV_ModStart> 1 ) { my_snprintf <S2SV_ModEnd> ( query , <S2SV_ModStart> ( query , sizeof ( query ) ,"
321,"static int try_to_unmap_cluster ( unsigned long cursor , unsigned int * mapcount , struct vm_area_struct * vma , struct page * check_page ) { struct mm_struct * mm = vma -> vm_mm ; pmd_t * pmd ; pte_t * pte ; pte_t pteval ; spinlock_t * ptl ; struct page * page ; unsigned long address ; unsigned long mmun_start ; unsigned long mmun_end ; unsigned long end ; int ret = SWAP_AGAIN ; int locked_vma = 0 ; address = ( vma -> vm_start + cursor ) & CLUSTER_MASK ; end = address + CLUSTER_SIZE ; if ( address < vma -> vm_start ) address = vma -> vm_start ; if ( end > vma -> vm_end ) end = vma -> vm_end ; pmd = mm_find_pmd ( mm , address ) ; if ( ! pmd ) return ret ; mmun_start = address ; mmun_end = end ; mmu_notifier_invalidate_range_start ( mm , mmun_start , mmun_end ) ; if ( down_read_trylock ( & vma -> vm_mm -> mmap_sem ) ) { locked_vma = ( vma -> vm_flags & VM_LOCKED ) ; if ( ! locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; } pte = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; update_hiwater_rss ( mm ) ; for ( ; address < end ; pte ++ , address += PAGE_SIZE ) { if ( ! pte_present ( * pte ) ) continue ; page = vm_normal_page ( vma , address , * pte ) ; BUG_ON ( ! page || PageAnon ( page ) ) ; if ( locked_vma ) { <S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug> continue ; } if ( ptep_clear_flush_young_notify ( vma , address , pte ) ) continue ; flush_cache_page ( vma , address , pte_pfn ( * pte ) ) ; pteval = ptep_clear_flush ( vma , address , pte ) ; if ( page -> index != linear_page_index ( vma , address ) ) { pte_t ptfile = pgoff_to_pte ( page -> index ) ; if ( pte_soft_dirty ( pteval ) ) pte_file_mksoft_dirty ( ptfile ) ; set_pte_at ( mm , address , pte , ptfile ) ; } if ( pte_dirty ( pteval ) ) set_page_dirty ( page ) ; page_remove_rmap ( page ) ; page_cache_release ( page ) ; dec_mm_counter ( mm , MM_FILEPAGES ) ; ( * mapcount ) -- ; } pte_unmap_unlock ( pte - 1 , ptl ) ; mmu_notifier_invalidate_range_end ( mm , mmun_start , mmun_end ) ; if ( locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; return ret ; }",locked_vma ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> == check_page ) { mlock_vma_page ( page ) ; <S2SV_ModStart> = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; }
322,"static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n"" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( ""RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n"" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n"" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n"" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }",rs_bound_addr == 0 || ! rs -> rs_transport
323,"static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; <S2SV_StartBug> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }",; int n ; if ( ! body -> unit_size ) break ; n
324,"static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , ""endobj"" ) ) ) { * ( c + strlen ( ""endobj"" ) + 1 ) = '\\0' ; obj_sz = ( void * ) strstr ( data + search , ""endobj"" ) - ( void * ) data ; obj_sz += strlen ( ""endobj"" ) + 1 ; break ; } else if ( strstr ( data , ""stream"" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }",; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks
325,"<S2SV_StartBug> int vp8_denoiser_filter_sse2 ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) { <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> int sig_stride = 16 ; <S2SV_StartBug> unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; <S2SV_EndBug> int mc_avg_y_stride = mc_running_avg -> y_stride ; <S2SV_StartBug> unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; <S2SV_EndBug> int avg_y_stride = running_avg -> y_stride ; int r ; <S2SV_StartBug> __m128i acc_diff = _mm_setzero_si128 ( ) ; <S2SV_EndBug> const __m128i k_0 = _mm_setzero_si128 ( ) ; const __m128i k_4 = _mm_set1_epi8 ( 4 ) ; const __m128i k_8 = _mm_set1_epi8 ( 8 ) ; const __m128i k_16 = _mm_set1_epi8 ( 16 ) ; const __m128i l3 = _mm_set1_epi8 ( <S2SV_StartBug> ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 : 6 ) ; <S2SV_EndBug> const __m128i l32 = _mm_set1_epi8 ( 2 ) ; const __m128i l21 = _mm_set1_epi8 ( 1 ) ; for ( r = 0 ; r < 16 ; ++ r ) { const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ; const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ; __m128i v_running_avg_y ; const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ; const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ; const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ; const __m128i clamped_absdiff = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_16 ) ; const __m128i mask2 = _mm_cmpgt_epi8 ( k_16 , clamped_absdiff ) ; const __m128i mask1 = _mm_cmpgt_epi8 ( k_8 , clamped_absdiff ) ; const __m128i mask0 = _mm_cmpgt_epi8 ( k_4 , clamped_absdiff ) ; __m128i adj2 = _mm_and_si128 ( mask2 , l32 ) ; const __m128i adj1 = _mm_and_si128 ( mask1 , l21 ) ; const __m128i adj0 = _mm_and_si128 ( mask0 , clamped_absdiff ) ; __m128i adj , padj , nadj ; adj2 = _mm_add_epi8 ( adj2 , adj1 ) ; adj = _mm_sub_epi8 ( l3 , adj2 ) ; adj = _mm_andnot_si128 ( mask0 , adj ) ; adj = _mm_or_si128 ( adj , adj0 ) ; padj = _mm_andnot_si128 ( diff_sign , adj ) ; nadj = _mm_and_si128 ( diff_sign , adj ) ; v_running_avg_y = _mm_adds_epu8 ( v_sig , padj ) ; v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , nadj ) ; _mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ; acc_diff = _mm_adds_epi8 ( acc_diff , padj ) ; acc_diff = _mm_subs_epi8 ( acc_diff , nadj ) ; sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } { <S2SV_StartBug> union sum_union s ; <S2SV_EndBug> int sum_diff = 0 ; <S2SV_StartBug> s . v = acc_diff ; <S2SV_EndBug> <S2SV_StartBug> sum_diff = s . e [ 0 ] + s . e [ 1 ] + s . e [ 2 ] + s . e [ 3 ] + s . e [ 4 ] + s . e [ 5 ] <S2SV_EndBug> + s . e [ 6 ] + s . e [ 7 ] + s . e [ 8 ] + s . e [ 9 ] + s . e [ 10 ] + s . e [ 11 ] + s . e [ 12 ] + s . e [ 13 ] + s . e [ 14 ] + s . e [ 15 ] ; <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> { return COPY_BLOCK ; } <S2SV_StartBug> } <S2SV_EndBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> return FILTER_BLOCK ; }","int vp8_denoiser_filter_sse2 ( <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * mc_running_avg_y , int mc_avg_y_stride , <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * running_avg_y , int avg_y_stride , <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; unsigned int sum_diff_thresh <S2SV_ModEnd> ; int r <S2SV_ModStart> int r ; int shift_inc = ( increase_denoising && <S2SV_ModEnd> motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD <S2SV_ModStart> MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; __m128i acc_diff = _mm_setzero_si128 ( ) ; const __m128i k_0 = _mm_setzero_si128 ( ) ; const __m128i k_4 = _mm_set1_epi8 ( 4 + shift_inc ) ; const __m128i k_8 = _mm_set1_epi8 ( 8 ) ; const __m128i k_16 = _mm_set1_epi8 ( 16 ) ; const __m128i l3 = _mm_set1_epi8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 + shift_inc <S2SV_ModEnd> : 6 ) <S2SV_ModStart> ; } { unsigned int abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) ; sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs_sum_diff > sum_diff_thresh ) { int delta = ( ( abs_sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const __m128i k_delta = _mm_set1_epi8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; r < 16 ; ++ r ) { __m128i v_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & running_avg_y <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> [ 0 ] ) ) ; const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ; const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ; const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ; const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ; const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ; const __m128i adj = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_delta ) ; __m128i padj , nadj ; padj = _mm_andnot_si128 ( diff_sign , adj ) ; nadj = _mm_and_si128 ( diff_sign , adj ) ; v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , padj ) ; v_running_avg_y = _mm_adds_epu8 ( v_running_avg_y , nadj ) ; _mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ; acc_diff = _mm_subs_epi8 ( acc_diff , padj ) ; acc_diff = _mm_adds_epi8 ( acc_diff , nadj ) ; sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( abs_sum_diff > sum_diff_thresh ) <S2SV_ModEnd> { return COPY_BLOCK <S2SV_ModStart> ; } } else { return COPY_BLOCK ; } } } vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> , avg_y_stride , <S2SV_ModStart> , avg_y_stride , sig_start <S2SV_ModEnd> , sig_stride )"
326,"static int __vcpu_run ( struct kvm_vcpu * vcpu ) { int r ; struct kvm * kvm = vcpu -> kvm ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; <S2SV_StartBug> r = vapic_enter ( vcpu ) ; <S2SV_EndBug> if ( r ) { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; return r ; } r = 1 ; while ( r > 0 ) { if ( vcpu -> arch . mp_state == KVM_MP_STATE_RUNNABLE && ! vcpu -> arch . apf . halted ) r = vcpu_enter_guest ( vcpu ) ; else { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; kvm_vcpu_block ( vcpu ) ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) { kvm_apic_accept_events ( vcpu ) ; switch ( vcpu -> arch . mp_state ) { case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ; vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ; break ; case KVM_MP_STATE_INIT_RECEIVED : break ; default : r = - EINTR ; break ; } } } if ( r <= 0 ) break ; clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ; if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ; if ( dm_request_for_irq_injection ( vcpu ) ) { r = - EINTR ; vcpu -> run -> exit_reason = KVM_EXIT_INTR ; ++ vcpu -> stat . request_irq_exits ; } kvm_check_async_pf_completion ( vcpu ) ; if ( signal_pending ( current ) ) { r = - EINTR ; vcpu -> run -> exit_reason = KVM_EXIT_INTR ; ++ vcpu -> stat . signal_exits ; } if ( need_resched ( ) ) { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; kvm_resched ( vcpu ) ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; } } srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; <S2SV_StartBug> vapic_exit ( vcpu ) ; <S2SV_EndBug> return r ; }",srcu ) ; <S2SV_ModEnd> r = 1 <S2SV_ModStart> srcu_idx ) ; <S2SV_ModEnd> return r ;
327,"int __usb_get_extra_descriptor ( char * buffer , unsigned size , <S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> { struct usb_descriptor_header * header ; while ( size >= sizeof ( struct usb_descriptor_header ) ) { header = ( struct usb_descriptor_header * ) buffer ; <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> printk ( KERN_ERR ""%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n"" , usbcore_name , header -> bDescriptorType , header -> bLength ) ; return - 1 ; } <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> * ptr = header ; return 0 ; } buffer += header -> bLength ; size -= header -> bLength ; } return - 1 ; }","* * ptr , size_t minsize <S2SV_ModStart> bLength < 2 || header -> bLength > size <S2SV_ModStart> bDescriptorType == type && header -> bLength >= minsize"
328,"static void dhcp6opt_print ( netdissect_options * ndo , const u_char * cp , const u_char * ep ) { const struct dhcp6opt * dh6o ; const u_char * tp ; size_t i ; uint16_t opttype ; size_t optlen ; uint8_t auth_proto ; u_int authinfolen , authrealmlen ; int remain_len ; int label_len ; uint16_t subopt_code ; uint16_t subopt_len ; if ( cp == ep ) return ; while ( cp < ep ) { if ( ep < cp + sizeof ( * dh6o ) ) goto trunc ; dh6o = ( const struct dhcp6opt * ) cp ; ND_TCHECK ( * dh6o ) ; optlen = EXTRACT_16BITS ( & dh6o -> dh6opt_len ) ; if ( ep < cp + sizeof ( * dh6o ) + optlen ) goto trunc ; opttype = EXTRACT_16BITS ( & dh6o -> dh6opt_type ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s"" , tok2str ( dh6opt_str , ""opt_%u"" , opttype ) ) ) ; ND_TCHECK2 ( * ( cp + sizeof ( * dh6o ) ) , optlen ) ; switch ( opttype ) { case DH6OPT_CLIENTID : case DH6OPT_SERVERID : if ( optlen < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( EXTRACT_16BITS ( tp ) ) { case 1 : if ( optlen >= 2 + 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>hwaddr/time<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>time<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( & tp [ 2 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) ) ) ; for ( i = 8 ; i < optlen ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; case 2 : if ( optlen >= 2 + 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>vid<S2SV_blank>"" ) ) ; for ( i = 2 ; i < 2 + 8 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; case 3 : if ( optlen >= 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>hwaddr<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( & tp [ 2 ] ) ) ) ; for ( i = 4 ; i < optlen ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type<S2SV_blank>%d)"" , EXTRACT_16BITS ( tp ) ) ) ; break ; } break ; case DH6OPT_IA_ADDR : if ( optlen < 24 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pltime:%u<S2SV_blank>vltime:%u"" , EXTRACT_32BITS ( & tp [ 16 ] ) , EXTRACT_32BITS ( & tp [ 20 ] ) ) ) ; if ( optlen > 24 ) { dhcp6opt_print ( ndo , tp + 24 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_ORO : case DH6OPT_ERO : if ( optlen % 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; for ( i = 0 ; i < optlen ; i += 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( dh6opt_str , ""opt_%u"" , EXTRACT_16BITS ( & tp [ i ] ) ) ) ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_PREFERENCE : if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , * tp ) ) ; break ; case DH6OPT_ELAPSED_TIME : if ( optlen != 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , EXTRACT_16BITS ( tp ) ) ) ; break ; case DH6OPT_RELAY_MSG : ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; tp = ( const u_char * ) ( dh6o + 1 ) ; dhcp6_print ( ndo , tp , optlen ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_AUTH : if ( optlen < 11 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; auth_proto = * tp ; switch ( auth_proto ) { case DH6OPT_AUTHPROTO_DELAYED : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>delayed"" ) ) ; break ; case DH6OPT_AUTHPROTO_RECONFIG : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>reconfigure"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>%d"" , auth_proto ) ) ; break ; } tp ++ ; switch ( * tp ) { case DH6OPT_AUTHALG_HMACMD5 : ND_PRINT ( ( ndo , "",<S2SV_blank>alg:<S2SV_blank>HMAC-MD5"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>alg:<S2SV_blank>%d"" , * tp ) ) ; break ; } tp ++ ; switch ( * tp ) { case DH6OPT_AUTHRDM_MONOCOUNTER : ND_PRINT ( ( ndo , "",<S2SV_blank>RDM:<S2SV_blank>mono"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>RDM:<S2SV_blank>%d"" , * tp ) ) ; break ; } tp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>RD:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 2 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , EXTRACT_16BITS ( tp ) ) ) ; authinfolen = optlen - 11 ; switch ( auth_proto ) { case DH6OPT_AUTHPROTO_DELAYED : if ( authinfolen == 0 ) break ; if ( authinfolen < 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } authrealmlen = authinfolen - 20 ; if ( authrealmlen > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>realm:<S2SV_blank>"" ) ) ; } for ( i = 0 ; i < authrealmlen ; i ++ , tp ++ ) ND_PRINT ( ( ndo , ""%02x"" , * tp ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>key<S2SV_blank>ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; tp += 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>HMAC-MD5:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; break ; case DH6OPT_AUTHPROTO_RECONFIG : if ( authinfolen != 17 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } switch ( * tp ++ ) { case DH6OPT_AUTHRECONFIG_KEY : ND_PRINT ( ( ndo , ""<S2SV_blank>reconfig-key"" ) ) ; break ; case DH6OPT_AUTHRECONFIG_HMACMD5 : ND_PRINT ( ( ndo , ""<S2SV_blank>type:<S2SV_blank>HMAC-MD5"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type:<S2SV_blank>??"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>value:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_RAPID_COMMIT : ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_INTERFACE_ID : case DH6OPT_SUBSCRIBER_ID : tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; for ( i = 0 ; i < optlen && i < 10 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; <S2SV_StartBug> case DH6OPT_RECONF_MSG : <S2SV_EndBug> tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( * tp ) { case DH6_RENEW : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>renew)"" ) ) ; break ; case DH6_INFORM_REQ : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>inf-req)"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>?\\?\\?(%02x))"" , * tp ) ) ; break ; } break ; case DH6OPT_RECONF_ACCEPT : ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_SIP_SERVER_A : case DH6OPT_DNS_SERVERS : case DH6OPT_SNTP_SERVERS : case DH6OPT_NIS_SERVERS : case DH6OPT_NISP_SERVERS : case DH6OPT_BCMCS_SERVER_A : case DH6OPT_PANA_AGENT : case DH6OPT_LQ_CLIENT_LINK : if ( optlen % 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; for ( i = 0 ; i < optlen ; i += 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ i ] ) ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_SIP_SERVER_D : case DH6OPT_DOMAIN_LIST : tp = ( const u_char * ) ( dh6o + 1 ) ; while ( tp < cp + sizeof ( * dh6o ) + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , cp + sizeof ( * dh6o ) + optlen ) ) == NULL ) goto trunc ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_STATUS_CODE : if ( optlen < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s)"" , dhcp6stcode ( EXTRACT_16BITS ( & tp [ 0 ] ) ) ) ) ; break ; case DH6OPT_IA_NA : case DH6OPT_IA_PD : if ( optlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>IAID:%u<S2SV_blank>T1:%u<S2SV_blank>T2:%u"" , EXTRACT_32BITS ( & tp [ 0 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) , EXTRACT_32BITS ( & tp [ 8 ] ) ) ) ; if ( optlen > 12 ) { dhcp6opt_print ( ndo , tp + 12 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_IA_TA : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>IAID:%u"" , EXTRACT_32BITS ( tp ) ) ) ; if ( optlen > 4 ) { dhcp6opt_print ( ndo , tp + 4 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_IA_PD_PREFIX : if ( optlen < 25 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%d"" , ip6addr_string ( ndo , & tp [ 9 ] ) , tp [ 8 ] ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pltime:%u<S2SV_blank>vltime:%u"" , EXTRACT_32BITS ( & tp [ 0 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) ) ) ; if ( optlen > 25 ) { dhcp6opt_print ( ndo , tp + 25 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_LIFETIME : case DH6OPT_CLT_TIME : if ( optlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , EXTRACT_32BITS ( tp ) ) ) ; break ; case DH6OPT_REMOTE_ID : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d<S2SV_blank>"" , EXTRACT_32BITS ( tp ) ) ) ; for ( i = 4 ; i < optlen && i < 14 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; case DH6OPT_LQ_QUERY : if ( optlen < 17 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( * tp ) { case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>by-address"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>by-clientID"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type_%d"" , ( int ) * tp ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 1 ] ) ) ) ; if ( optlen > 17 ) { dhcp6opt_print ( ndo , tp + 17 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_CLIENT_DATA : tp = ( const u_char * ) ( dh6o + 1 ) ; if ( optlen > 0 ) { dhcp6opt_print ( ndo , tp , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_LQ_RELAY_DATA : if ( optlen < 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; for ( i = 16 ; i < optlen && i < 26 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; case DH6OPT_NTP_SERVER : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; while ( tp < cp + sizeof ( * dh6o ) + optlen - 4 ) { subopt_code = EXTRACT_16BITS ( tp ) ; tp += 2 ; subopt_len = EXTRACT_16BITS ( tp ) ; tp += 2 ; if ( tp + subopt_len > cp + sizeof ( * dh6o ) + optlen ) goto trunc ; ND_PRINT ( ( ndo , ""<S2SV_blank>subopt:%d"" , subopt_code ) ) ; switch ( subopt_code ) { case DH6OPT_NTP_SUBOPTION_SRV_ADDR : case DH6OPT_NTP_SUBOPTION_MC_ADDR : if ( subopt_len != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; break ; case DH6OPT_NTP_SUBOPTION_SRV_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ns_nprint ( ndo , tp , tp + subopt_len ) == NULL ) goto trunc ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } tp += subopt_len ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_AFTR_NAME : if ( optlen < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; remain_len = optlen ; ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; while ( remain_len && * tp ) { label_len = * tp ++ ; if ( label_len < remain_len - 1 ) { ( void ) fn_printn ( ndo , tp , label_len , NULL ) ; tp += label_len ; remain_len -= ( label_len + 1 ) ; if ( * tp ) ND_PRINT ( ( ndo , ""."" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_NEW_POSIX_TIMEZONE : case DH6OPT_NEW_TZDB_TIMEZONE : case DH6OPT_MUDURL : if ( optlen < 5 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""="" ) ) ; ( void ) fn_printn ( ndo , tp , ( u_int ) optlen , NULL ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : ND_PRINT ( ( ndo , "")"" ) ) ; break ; } cp += sizeof ( * dh6o ) + optlen ; } return ; trunc : ND_PRINT ( ( ndo , ""[|dhcp6ext]"" ) ) ; }","case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; }"
329,"static void sunkbd_reinit ( struct work_struct * work ) { struct sunkbd * sunkbd = container_of ( work , struct sunkbd , tq ) ; <S2SV_StartBug> wait_event_interruptible_timeout ( sunkbd -> wait , sunkbd -> reset >= 0 , HZ ) ; <S2SV_EndBug> <S2SV_StartBug> serio_write ( sunkbd -> serio , SUNKBD_CMD_SETLED ) ; <S2SV_EndBug> serio_write ( sunkbd -> serio , ( ! ! test_bit ( LED_CAPSL , sunkbd -> dev -> led ) << 3 ) | ( ! ! test_bit ( LED_SCROLLL , sunkbd -> dev -> led ) << 2 ) | ( ! ! test_bit ( LED_COMPOSE , sunkbd -> dev -> led ) << 1 ) | ! ! test_bit ( LED_NUML , sunkbd -> dev -> led ) ) ; serio_write ( sunkbd -> serio , SUNKBD_CMD_NOCLICK - ! ! test_bit ( SND_CLICK , sunkbd -> dev -> snd ) ) ; serio_write ( sunkbd -> serio , SUNKBD_CMD_BELLOFF - ! ! test_bit ( SND_BELL , sunkbd -> dev -> snd ) ) ; }",reset >= 0 || ! sunkbd -> enabled <S2SV_ModStart> HZ ) ; if <S2SV_ModEnd> ( sunkbd -> <S2SV_ModStart> ( sunkbd -> reset >= 0 && sunkbd -> enabled ) sunkbd_set_leds_beeps ( sunkbd <S2SV_ModEnd> ) ; }
330,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) <S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( MATLAB_HDR . ObjectSize + filepos > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }","6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; }"
331,"PHYSICALPATH_FUNC ( mod_alias_physical_handler ) { plugin_data * p = p_d ; int uri_len , basedir_len ; char * uri_ptr ; size_t k ; if ( buffer_is_empty ( con -> physical . path ) ) return HANDLER_GO_ON ; mod_alias_patch_connection ( srv , con , p ) ; basedir_len = buffer_string_length ( con -> physical . basedir ) ; if ( '/' == con -> physical . basedir -> ptr [ basedir_len - 1 ] ) -- basedir_len ; uri_len = buffer_string_length ( con -> physical . path ) - basedir_len ; uri_ptr = con -> physical . path -> ptr + basedir_len ; for ( k = 0 ; k < p -> conf . alias -> used ; k ++ ) { data_string * ds = ( data_string * ) p -> conf . alias -> data [ k ] ; int alias_len = buffer_string_length ( ds -> key ) ; if ( alias_len > uri_len ) continue ; if ( buffer_is_empty ( ds -> key ) ) continue ; if ( 0 == ( con -> conf . force_lowercase_filenames ? strncasecmp ( uri_ptr , ds -> key -> ptr , alias_len ) : strncmp ( uri_ptr , ds -> key -> ptr , alias_len ) ) ) { <S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ; buffer_append_string ( srv -> tmp_buf , uri_ptr + alias_len ) ; buffer_copy_buffer ( con -> physical . path , srv -> tmp_buf ) ; return HANDLER_GO_ON ; } } return HANDLER_GO_ON ; }",) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
332,"int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; <S2SV_StartBug> unsigned int len ; <S2SV_EndBug> unsigned long start = 0 , off ; <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 << 9 ) ; <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - EAGAIN ; } return 0 ; }","* fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>"
333,"static int mount_autodev ( const char * name , const struct lxc_rootfs * rootfs , const char * lxcpath ) { int ret ; size_t clen ; char * path ; INFO ( ""Mounting<S2SV_blank>container<S2SV_blank>/dev"" ) ; clen = ( rootfs -> path ? strlen ( rootfs -> mount ) : 0 ) + 9 ; path = alloca ( clen ) ; ret = snprintf ( path , clen , ""%s/dev"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( ret < 0 || ret >= clen ) return - 1 ; if ( ! dir_exists ( path ) ) { WARN ( ""No<S2SV_blank>/dev<S2SV_blank>in<S2SV_blank>container."" ) ; WARN ( ""Proceeding<S2SV_blank>without<S2SV_blank>autodev<S2SV_blank>setup"" ) ; return 0 ; } <S2SV_StartBug> if ( mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" ) ) { <S2SV_EndBug> SYSERROR ( ""Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\n"" , path ) ; return false ; } INFO ( ""Mounted<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s"" , path ) ; ret = snprintf ( path , clen , ""%s/dev/pts"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( ret < 0 || ret >= clen ) return - 1 ; if ( ! dir_exists ( path ) ) { ret = mkdir ( path , S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH ) ; if ( ret ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>/dev/pts<S2SV_blank>in<S2SV_blank>container"" ) ; return - 1 ; } } INFO ( ""Mounted<S2SV_blank>container<S2SV_blank>/dev"" ) ; return 0 ; }","} if ( safe_mount <S2SV_ModEnd> ( ""none"" , <S2SV_ModStart> 0 , ""size=100000,mode=755"" , rootfs -> path ? rootfs -> mount : NULL"
334,"static int lookupName ( Parse * pParse , const char * zDb , const char * zTab , const char * zCol , NameContext * pNC , Expr * pExpr ) { int i , j ; int cnt = 0 ; int cntTab = 0 ; int nSubquery = 0 ; sqlite3 * db = pParse -> db ; struct SrcList_item * pItem ; struct SrcList_item * pMatch = 0 ; NameContext * pTopNC = pNC ; Schema * pSchema = 0 ; int eNewExprOp = TK_COLUMN ; Table * pTab = 0 ; Column * pCol ; assert ( pNC ) ; assert ( zCol ) ; assert ( ! ExprHasProperty ( pExpr , EP_TokenOnly | EP_Reduced ) ) ; pExpr -> iTable = - 1 ; ExprSetVVAProperty ( pExpr , EP_NoReduce ) ; if ( zDb ) { testcase ( pNC -> ncFlags & NC_PartIdx ) ; testcase ( pNC -> ncFlags & NC_IsCheck ) ; if ( ( pNC -> ncFlags & ( NC_PartIdx | NC_IsCheck ) ) != 0 ) { zDb = 0 ; } else { for ( i = 0 ; i < db -> nDb ; i ++ ) { assert ( db -> aDb [ i ] . zDbSName ) ; if ( sqlite3StrICmp ( db -> aDb [ i ] . zDbSName , zDb ) == 0 ) { pSchema = db -> aDb [ i ] . pSchema ; break ; } } } } assert ( pNC && cnt == 0 ) ; do { ExprList * pEList ; SrcList * pSrcList = pNC -> pSrcList ; if ( pSrcList ) { for ( i = 0 , pItem = pSrcList -> a ; i < pSrcList -> nSrc ; i ++ , pItem ++ ) { pTab = pItem -> pTab ; assert ( pTab != 0 && pTab -> zName != 0 ) ; assert ( pTab -> nCol > 0 ) ; if ( pItem -> pSelect && ( pItem -> pSelect -> selFlags & SF_NestedFrom ) != 0 ) { int hit = 0 ; pEList = pItem -> pSelect -> pEList ; for ( j = 0 ; j < pEList -> nExpr ; j ++ ) { if ( sqlite3MatchSpanName ( pEList -> a [ j ] . zSpan , zCol , zTab , zDb ) ) { cnt ++ ; cntTab = 2 ; pMatch = pItem ; pExpr -> iColumn = j ; hit = 1 ; } } if ( hit || zTab == 0 ) continue ; } if ( zDb && pTab -> pSchema != pSchema ) { continue ; } if ( zTab ) { const char * zTabName = pItem -> zAlias ? pItem -> zAlias : pTab -> zName ; assert ( zTabName != 0 ) ; if ( sqlite3StrICmp ( zTabName , zTab ) != 0 ) { continue ; } if ( IN_RENAME_OBJECT && pItem -> zAlias ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) & pExpr -> y . pTab ) ; } } if ( 0 == ( cntTab ++ ) ) { pMatch = pItem ; } for ( j = 0 , pCol = pTab -> aCol ; j < pTab -> nCol ; j ++ , pCol ++ ) { if ( sqlite3StrICmp ( pCol -> zName , zCol ) == 0 ) { if ( cnt == 1 ) { if ( pItem -> fg . jointype & JT_NATURAL ) continue ; if ( nameInUsingClause ( pItem -> pUsing , zCol ) ) continue ; } cnt ++ ; pMatch = pItem ; pExpr -> iColumn = j == pTab -> iPKey ? - 1 : ( i16 ) j ; break ; } } } if ( pMatch ) { pExpr -> iTable = pMatch -> iCursor ; pExpr -> y . pTab = pMatch -> pTab ; assert ( ( pMatch -> fg . jointype & JT_RIGHT ) == 0 ) ; if ( ( pMatch -> fg . jointype & JT_LEFT ) != 0 ) { ExprSetProperty ( pExpr , EP_CanBeNull ) ; } pSchema = pExpr -> y . pTab -> pSchema ; } } # if ! defined ( SQLITE_OMIT_TRIGGER ) || ! defined ( SQLITE_OMIT_UPSERT ) if ( zDb == 0 && zTab != 0 && cntTab == 0 ) { pTab = 0 ; # ifndef SQLITE_OMIT_TRIGGER if ( pParse -> pTriggerTab != 0 ) { int op = pParse -> eTriggerOp ; assert ( op == TK_DELETE || op == TK_UPDATE || op == TK_INSERT ) ; if ( op != TK_DELETE && sqlite3StrICmp ( ""new"" , zTab ) == 0 ) { pExpr -> iTable = 1 ; pTab = pParse -> pTriggerTab ; } else if ( op != TK_INSERT && sqlite3StrICmp ( ""old"" , zTab ) == 0 ) { pExpr -> iTable = 0 ; pTab = pParse -> pTriggerTab ; } } # endif # ifndef SQLITE_OMIT_UPSERT if ( ( pNC -> ncFlags & NC_UUpsert ) != 0 ) { Upsert * pUpsert = pNC -> uNC . pUpsert ; if ( pUpsert && sqlite3StrICmp ( ""excluded"" , zTab ) == 0 ) { pTab = pUpsert -> pUpsertSrc -> a [ 0 ] . pTab ; pExpr -> iTable = 2 ; } } # endif if ( pTab ) { int iCol ; pSchema = pTab -> pSchema ; cntTab ++ ; for ( iCol = 0 , pCol = pTab -> aCol ; iCol < pTab -> nCol ; iCol ++ , pCol ++ ) { if ( sqlite3StrICmp ( pCol -> zName , zCol ) == 0 ) { if ( iCol == pTab -> iPKey ) { iCol = - 1 ; } break ; } } if ( iCol >= pTab -> nCol && sqlite3IsRowid ( zCol ) && VisibleRowid ( pTab ) ) { iCol = - 1 ; } if ( iCol < pTab -> nCol ) { cnt ++ ; # ifndef SQLITE_OMIT_UPSERT if ( pExpr -> iTable == 2 ) { testcase ( iCol == ( - 1 ) ) ; if ( IN_RENAME_OBJECT ) { pExpr -> iColumn = iCol ; pExpr -> y . pTab = pTab ; eNewExprOp = TK_COLUMN ; } else { pExpr -> iTable = pNC -> uNC . pUpsert -> regData + iCol ; eNewExprOp = TK_REGISTER ; ExprSetProperty ( pExpr , EP_Alias ) ; } } else # endif { # ifndef SQLITE_OMIT_TRIGGER if ( iCol < 0 ) { pExpr -> affExpr = SQLITE_AFF_INTEGER ; } else if ( pExpr -> iTable == 0 ) { testcase ( iCol == 31 ) ; testcase ( iCol == 32 ) ; pParse -> oldmask |= ( iCol >= 32 ? 0xffffffff : ( ( ( u32 ) 1 ) << iCol ) ) ; } else { testcase ( iCol == 31 ) ; testcase ( iCol == 32 ) ; pParse -> newmask |= ( iCol >= 32 ? 0xffffffff : ( ( ( u32 ) 1 ) << iCol ) ) ; } pExpr -> y . pTab = pTab ; pExpr -> iColumn = ( i16 ) iCol ; eNewExprOp = TK_TRIGGER ; # endif } } } } # endif if ( cnt == 0 && cntTab == 1 && pMatch && ( pNC -> ncFlags & ( NC_IdxExpr | NC_GenCol ) ) == 0 && sqlite3IsRowid ( zCol ) && VisibleRowid ( pMatch -> pTab ) ) { cnt = 1 ; pExpr -> iColumn = - 1 ; pExpr -> affExpr = SQLITE_AFF_INTEGER ; } if ( ( pNC -> ncFlags & NC_UEList ) != 0 && cnt == 0 && zTab == 0 ) { pEList = pNC -> uNC . pEList ; assert ( pEList != 0 ) ; for ( j = 0 ; j < pEList -> nExpr ; j ++ ) { char * zAs = pEList -> a [ j ] . zName ; if ( zAs != 0 && sqlite3StrICmp ( zAs , zCol ) == 0 ) { Expr * pOrig ; assert ( pExpr -> pLeft == 0 && pExpr -> pRight == 0 ) ; assert ( pExpr -> x . pList == 0 ) ; assert ( pExpr -> x . pSelect == 0 ) ; pOrig = pEList -> a [ j ] . pExpr ; if ( ( pNC -> ncFlags & NC_AllowAgg ) == 0 && ExprHasProperty ( pOrig , EP_Agg ) ) { sqlite3ErrorMsg ( pParse , ""misuse<S2SV_blank>of<S2SV_blank>aliased<S2SV_blank>aggregate<S2SV_blank>%s"" , zAs ) ; return WRC_Abort ; } if ( ( pNC -> ncFlags & NC_AllowWin ) == 0 && ExprHasProperty ( pOrig , EP_Win ) ) { sqlite3ErrorMsg ( pParse , ""misuse<S2SV_blank>of<S2SV_blank>aliased<S2SV_blank>window<S2SV_blank>function<S2SV_blank>%s"" , zAs ) ; return WRC_Abort ; } if ( sqlite3ExprVectorSize ( pOrig ) != 1 ) { sqlite3ErrorMsg ( pParse , ""row<S2SV_blank>value<S2SV_blank>misused"" ) ; return WRC_Abort ; } resolveAlias ( pParse , pEList , j , pExpr , """" , nSubquery ) ; cnt = 1 ; pMatch = 0 ; assert ( zTab == 0 && zDb == 0 ) ; if ( IN_RENAME_OBJECT ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pExpr ) ; } goto lookupname_end ; } } } if ( cnt ) break ; pNC = pNC -> pNext ; nSubquery ++ ; } while ( pNC ) ; if ( cnt == 0 && zTab == 0 ) { assert ( pExpr -> op == TK_ID ) ; if ( ExprHasProperty ( pExpr , EP_DblQuoted ) && areDoubleQuotedStringsEnabled ( db , pTopNC ) ) { sqlite3_log ( SQLITE_WARNING , ""double-quoted<S2SV_blank>string<S2SV_blank>literal:<S2SV_blank>\\""%w\\"""" , zCol ) ; # ifdef SQLITE_ENABLE_NORMALIZE sqlite3VdbeAddDblquoteStr ( db , pParse -> pVdbe , zCol ) ; # endif pExpr -> op = TK_STRING ; pExpr -> y . pTab = 0 ; return WRC_Prune ; } if ( sqlite3ExprIdToTrueFalse ( pExpr ) ) { return WRC_Prune ; } } if ( cnt != 1 ) { const char * zErr ; zErr = cnt == 0 ? ""no<S2SV_blank>such<S2SV_blank>column"" : ""ambiguous<S2SV_blank>column<S2SV_blank>name"" ; if ( zDb ) { sqlite3ErrorMsg ( pParse , ""%s:<S2SV_blank>%s.%s.%s"" , zErr , zDb , zTab , zCol ) ; } else if ( zTab ) { sqlite3ErrorMsg ( pParse , ""%s:<S2SV_blank>%s.%s"" , zErr , zTab , zCol ) ; } else { sqlite3ErrorMsg ( pParse , ""%s:<S2SV_blank>%s"" , zErr , zCol ) ; } pParse -> checkSchema = 1 ; pTopNC -> nErr ++ ; } if ( pExpr -> iColumn >= 0 && pMatch != 0 ) { int n = pExpr -> iColumn ; testcase ( n == BMS - 1 ) ; if ( n >= BMS ) { n = BMS - 1 ; } <S2SV_StartBug> assert ( pMatch -> iCursor == pExpr -> iTable ) ; <S2SV_EndBug> pMatch -> colUsed |= ( ( Bitmask ) 1 ) << n ; } sqlite3ExprDelete ( db , pExpr -> pLeft ) ; pExpr -> pLeft = 0 ; sqlite3ExprDelete ( db , pExpr -> pRight ) ; pExpr -> pRight = 0 ; pExpr -> op = eNewExprOp ; ExprSetProperty ( pExpr , EP_Leaf ) ; lookupname_end : if ( cnt == 1 ) { assert ( pNC != 0 ) ; if ( ! ExprHasProperty ( pExpr , EP_Alias ) ) { sqlite3AuthRead ( pParse , pExpr , pSchema , pNC -> pSrcList ) ; } for ( ; ; ) { assert ( pTopNC != 0 ) ; pTopNC -> nRef ++ ; if ( pTopNC == pNC ) break ; pTopNC = pTopNC -> pNext ; } return WRC_Prune ; } else { return WRC_Abort ; } }",} assert ( pExpr -> y . pTab != 0 ) ; assert ( <S2SV_ModStart> iTable ) ; if ( pExpr -> y . pTab -> tabFlags & TF_HasGenerated ) { Column * pCol = pExpr -> y . pTab -> aCol + pExpr -> iColumn ; if ( pCol -> colFlags & COLFLAG_GENERATED ) n = BMS - 1 ; }
335,"void vp9_tokens_from_tree ( struct vp9_token * tokens , <S2SV_StartBug> const vp9_tree_index * tree ) { <S2SV_EndBug> tree2tok ( tokens , tree , 0 , 0 , 0 ) ; }","tokens , const vpx_tree_index <S2SV_ModEnd> * tree )"
336,"static void usage ( const char * prog ) { fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank>[OPTION...]\\n"" , prog ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-f,<S2SV_blank>--use-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>configuration<S2SV_blank>file\\n"" ) ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-P,<S2SV_blank>--vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>VRRP<S2SV_blank>subsystem\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-C,<S2SV_blank>--check<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>Health-checker<S2SV_blank>subsystem\\n"" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-B,<S2SV_blank>--no_bfd<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>run<S2SV_blank>BFD<S2SV_blank>subsystem\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--all<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Force<S2SV_blank>all<S2SV_blank>child<S2SV_blank>processes<S2SV_blank>to<S2SV_blank>run,<S2SV_blank>even<S2SV_blank>if<S2SV_blank>have<S2SV_blank>no<S2SV_blank>configuration\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-l,<S2SV_blank>--log-console<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>messages<S2SV_blank>to<S2SV_blank>local<S2SV_blank>console\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-D,<S2SV_blank>--log-detail<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Detailed<S2SV_blank>log<S2SV_blank>messages\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-S,<S2SV_blank>--log-facility=[0-7]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Set<S2SV_blank>syslog<S2SV_blank>facility<S2SV_blank>to<S2SV_blank>LOG_LOCAL[0-7]\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-g,<S2SV_blank>--log-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Also<S2SV_blank>log<S2SV_blank>to<S2SV_blank>FILE<S2SV_blank>(default<S2SV_blank>/tmp/keepalived.log)\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--flush-log-file<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flush<S2SV_blank>log<S2SV_blank>file<S2SV_blank>on<S2SV_blank>write\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n"" ) ; <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-V,<S2SV_blank>--dont-release-vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>VRRP<S2SV_blank>VIPs<S2SV_blank>and<S2SV_blank>VROUTEs<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n"" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-I,<S2SV_blank>--dont-release-ipvs<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>IPVS<S2SV_blank>topology<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-R,<S2SV_blank>--dont-respawn<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>respawn<S2SV_blank>child<S2SV_blank>processes\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-n,<S2SV_blank>--dont-fork<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>fork<S2SV_blank>the<S2SV_blank>daemon<S2SV_blank>process\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--dump-conf<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Dump<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>data\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>process\\n"" ) ; # ifdef _WITH_VRRP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-r,<S2SV_blank>--vrrp_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>VRRP<S2SV_blank>child<S2SV_blank>process\\n"" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-c,<S2SV_blank>--checkers_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>checkers<S2SV_blank>child<S2SV_blank>process\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-a,<S2SV_blank>--address-monitoring<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Report<S2SV_blank>all<S2SV_blank>address<S2SV_blank>additions/deletions<S2SV_blank>notified<S2SV_blank>via<S2SV_blank>netlink\\n"" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-b,<S2SV_blank>--bfd_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>BFD<S2SV_blank>child<S2SV_blank>process\\n"" ) ; # endif # ifdef _WITH_SNMP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--snmp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>SNMP<S2SV_blank>subsystem\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-A,<S2SV_blank>--snmp-agent-socket=FILE<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>master<S2SV_blank>agent\\n"" ) ; # endif # if HAVE_DECL_CLONE_NEWNET fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--namespace=NAME<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Run<S2SV_blank>in<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>NAME<S2SV_blank>(overrides<S2SV_blank>config)\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-m,<S2SV_blank>--core-dump<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Produce<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>if<S2SV_blank>terminate<S2SV_blank>abnormally\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-M,<S2SV_blank>--core-dump-pattern=PATN<S2SV_blank>Also<S2SV_blank>set<S2SV_blank>/proc/sys/kernel/core_pattern<S2SV_blank>to<S2SV_blank>PATN<S2SV_blank>(default<S2SV_blank>\'core\')\\n"" ) ; # ifdef _MEM_CHECK_LOG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-L,<S2SV_blank>--mem-check-log<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>malloc/frees<S2SV_blank>to<S2SV_blank>syslog\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-i,<S2SV_blank>--config-id<S2SV_blank>id<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Skip<S2SV_blank>any<S2SV_blank>configuration<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>\'@\'<S2SV_blank>that<S2SV_blank>don\'t<S2SV_blank>match<S2SV_blank>id\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>or<S2SV_blank>any<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>@^<S2SV_blank>that<S2SV_blank>do<S2SV_blank>match.\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>The<S2SV_blank>config-id<S2SV_blank>defaults<S2SV_blank>to<S2SV_blank>the<S2SV_blank>node<S2SV_blank>name<S2SV_blank>if<S2SV_blank>option<S2SV_blank>not<S2SV_blank>used\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--signum=SIGFUNC<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>signal<S2SV_blank>number<S2SV_blank>for<S2SV_blank>STOP,<S2SV_blank>RELOAD,<S2SV_blank>DATA,<S2SV_blank>STATS"" # ifdef _WITH_JSON_ "",<S2SV_blank>JSON"" # endif ""\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-t,<S2SV_blank>--config-test[=LOG_FILE]<S2SV_blank>Check<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>for<S2SV_blank>obvious<S2SV_blank>errors,<S2SV_blank>output<S2SV_blank>to\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stderr<S2SV_blank>by<S2SV_blank>default\\n"" ) ; # ifdef _WITH_PERF_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--perf[=PERF_TYPE]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Collect<S2SV_blank>perf<S2SV_blank>data,<S2SV_blank>PERF_TYPE=all,<S2SV_blank>run(default)<S2SV_blank>or<S2SV_blank>end\\n"" ) ; # endif # ifdef WITH_DEBUG_OPTIONS fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--debug[=...]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>debug<S2SV_blank>options.<S2SV_blank>p,<S2SV_blank>b,<S2SV_blank>c,<S2SV_blank>v<S2SV_blank>specify<S2SV_blank>parent,<S2SV_blank>bfd,<S2SV_blank>checker<S2SV_blank>and<S2SV_blank>vrrp<S2SV_blank>processes\\n"" ) ; # ifdef _TIMER_CHECK_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T<S2SV_blank>-<S2SV_blank>timer<S2SV_blank>debug\\n"" ) ; # endif # ifdef _SMTP_ALERT_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>M<S2SV_blank>-<S2SV_blank>email<S2SV_blank>alert<S2SV_blank>debug\\n"" ) ; # endif # ifdef _EPOLL_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>E<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>debug\\n"" ) ; # endif # ifdef _EPOLL_THREAD_DUMP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>D<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>thread<S2SV_blank>dump<S2SV_blank>debug\\n"" ) ; # endif # ifdef _VRRP_FD_DEBUG fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>F<S2SV_blank>-<S2SV_blank>vrrp<S2SV_blank>fd<S2SV_blank>dump<S2SV_blank>debug\\n"" ) ; # endif # ifdef _REGEX_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>debug\\n"" ) ; # endif # ifdef _WITH_REGEX_TIMERS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>X<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>timers\\n"" ) ; # endif # ifdef _TSM_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>S<S2SV_blank>-<S2SV_blank>TSM<S2SV_blank>debug\\n"" ) ; # endif # ifdef _NETLINK_TIMERS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>N<S2SV_blank>-<S2SV_blank>netlink<S2SV_blank>timer<S2SV_blank>debug\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Example<S2SV_blank>--debug=TpMEvcp\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>the<S2SV_blank>version<S2SV_blank>number\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-h,<S2SV_blank>--help<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>this<S2SV_blank>help<S2SV_blank>message\\n"" ) ; }","""<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n"" ) ;"
337,"int use_conf ( char * test_path ) { int ret ; size_t flags = 0 ; char filename [ 1024 ] , errstr [ 1024 ] ; char * buffer ; FILE * infile , * conffile ; json_t * json ; json_error_t error ; sprintf ( filename , ""%s%cinput"" , test_path , dir_sep ) ; if ( ! ( infile = fopen ( filename , ""rb"" ) ) ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>\\""%s\\""\\n"" , filename ) ; return 2 ; } sprintf ( filename , ""%s%cenv"" , test_path , dir_sep ) ; conffile = fopen ( filename , ""rb"" ) ; if ( conffile ) { read_conf ( conffile ) ; fclose ( conffile ) ; } if ( conf . indent < 0 || conf . indent > 255 ) { fprintf ( stderr , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>JSON_INDENT:<S2SV_blank>%d\\n"" , conf . indent ) ; return 2 ; } if ( conf . indent ) flags |= JSON_INDENT ( conf . indent ) ; if ( conf . compact ) flags |= JSON_COMPACT ; if ( conf . ensure_ascii ) flags |= JSON_ENSURE_ASCII ; if ( conf . preserve_order ) flags |= JSON_PRESERVE_ORDER ; if ( conf . sort_keys ) flags |= JSON_SORT_KEYS ; <S2SV_StartBug> if ( conf . strip ) { <S2SV_EndBug> buffer = loadfile ( infile ) ; json = json_loads ( strip ( buffer ) , 0 , & error ) ; free ( buffer ) ; } else json = json_loadf ( infile , 0 , & error ) ; fclose ( infile ) ; if ( ! json ) { sprintf ( errstr , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n%s\\n"" , error . line , error . column , error . position , error . text ) ; ret = cmpfile ( errstr , test_path , ""error"" ) ; return ret ; } buffer = json_dumps ( json , flags ) ; ret = cmpfile ( buffer , test_path , ""output"" ) ; free ( buffer ) ; json_decref ( json ) ; return ret ; }",( conf . have_hashseed ) json_object_seed ( conf . hashseed ) ; if ( conf .
338,"static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }",& 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = ff_dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
339,"static void snd_timer_check_master ( struct snd_timer_instance * master ) { struct snd_timer_instance * slave , * tmp ; list_for_each_entry_safe ( slave , tmp , & snd_timer_slave_list , open_list ) { if ( slave -> slave_class == master -> slave_class && slave -> slave_id == master -> slave_id ) { list_move_tail ( & slave -> open_list , & master -> slave_list_head ) ; spin_lock_irq ( & slave_active_lock ) ; <S2SV_StartBug> slave -> master = master ; <S2SV_EndBug> slave -> timer = master -> timer ; if ( slave -> flags & SNDRV_TIMER_IFLG_RUNNING ) list_add_tail ( & slave -> active_list , & master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> } } }",slave_active_lock ) ; spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & master -> timer -> lock ) ;
340,"static int opl3_load_patch ( int dev , int format , const char __user * addr , <S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> { struct sbi_instrument ins ; if ( count < sizeof ( ins ) ) { printk ( KERN_WARNING ""FM<S2SV_blank>Error:<S2SV_blank>Patch<S2SV_blank>record<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <S2SV_EndBug> return - EFAULT ; if ( ins . channel < 0 || ins . channel >= SBFM_MAXINSTR ) { printk ( KERN_WARNING ""FM<S2SV_blank>Error:<S2SV_blank>Invalid<S2SV_blank>instrument<S2SV_blank>number<S2SV_blank>%d\\n"" , ins . channel ) ; return - EINVAL ; } ins . key = format ; return store_instr ( ins . channel , & ins ) ; }","* addr , <S2SV_ModEnd> int count , <S2SV_ModStart> copy_from_user ( & ins , addr <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( ins ) <S2SV_ModEnd> ) ) return"
341,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { DelogoContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; AVFrame * out ; int hsub0 = desc -> log2_chroma_w ; int vsub0 = desc -> log2_chroma_h ; int direct = 0 ; int plane ; AVRational sar ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } sar = in -> sample_aspect_ratio ; if ( ! sar . num ) sar . num = sar . den = 1 ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ; apply_delogo ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , FF_CEIL_RSHIFT ( inlink -> w , hsub ) , FF_CEIL_RSHIFT ( inlink -> h , vsub ) , sar , s -> x >> hsub , s -> y >> vsub , FF_CEIL_RSHIFT ( s -> w + ( s -> x & ( ( 1 << hsub ) - 1 ) ) , hsub ) , FF_CEIL_RSHIFT ( s -> h + ( s -> y & ( ( 1 << vsub ) - 1 ) ) , vsub ) , s -> band >> FFMIN ( hsub , vsub ) , s -> show , direct ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }",in -> data [ plane ] && in -> linesize
342,"static void mpeg4_encode_gop_header ( MpegEncContext * s ) { <S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> int64_t time ; put_bits ( & s -> pb , 16 , 0 ) ; put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; time = s -> current_picture_ptr -> f -> pts ; if ( s -> reordered_input_picture [ 1 ] ) time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> f -> pts ) ; time = time * s -> avctx -> time_base . num ; s -> last_time_base = FFUDIV ( time , s -> avctx -> time_base . den ) ; seconds = FFUDIV ( time , s -> avctx -> time_base . den ) ; minutes = FFUDIV ( seconds , 60 ) ; seconds = FFUMOD ( seconds , 60 ) ; hours = FFUDIV ( minutes , 60 ) ; minutes = FFUMOD ( minutes , 60 ) ; hours = FFUMOD ( hours , 24 ) ; put_bits ( & s -> pb , 5 , hours ) ; put_bits ( & s -> pb , 6 , minutes ) ; put_bits ( & s -> pb , 1 , 1 ) ; put_bits ( & s -> pb , 6 , seconds ) ; put_bits ( & s -> pb , 1 , ! ! ( s -> avctx -> flags & AV_CODEC_FLAG_CLOSED_GOP ) ) ; put_bits ( & s -> pb , 1 , 0 ) ; ff_mpeg4_stuffing ( & s -> pb ) ; }","s ) { int64_t <S2SV_ModEnd> hours , minutes"
343,"node * PyParser_ParseFileObject ( FILE * fp , PyObject * filename , const char * enc , grammar * g , int start , const char * ps1 , const char * ps2 , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( ( tok = PyTokenizer_FromFile ( fp , enc , ps1 , ps2 ) ) == NULL ) { err_ret -> error = E_NOMEM ; return NULL ; } <S2SV_StartBug> # ifndef PGEN <S2SV_EndBug> Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }",NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; }
344,"static __u8 * kye_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { switch ( hdev -> product ) { case USB_DEVICE_ID_KYE_ERGO_525V : <S2SV_StartBug> if ( * rsize >= 74 && <S2SV_EndBug> <S2SV_StartBug> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <S2SV_EndBug> rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 ; } break ; case USB_DEVICE_ID_KYE_EASYPEN_I405X : if ( * rsize == EASYPEN_I405X_RDESC_ORIG_SIZE ) { rdesc = easypen_i405x_rdesc_fixed ; * rsize = sizeof ( easypen_i405x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_KYE_MOUSEPEN_I608X : if ( * rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE ) { rdesc = mousepen_i608x_rdesc_fixed ; * rsize = sizeof ( mousepen_i608x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_KYE_EASYPEN_M610X : if ( * rsize == EASYPEN_M610X_RDESC_ORIG_SIZE ) { rdesc = easypen_m610x_rdesc_fixed ; * rsize = sizeof ( easypen_m610x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 104 , ""Genius<S2SV_blank>Gila<S2SV_blank>Gaming<S2SV_blank>Mouse"" ) ; break ; case USB_DEVICE_ID_GENIUS_GX_IMPERATOR : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 83 , ""Genius<S2SV_blank>Gx<S2SV_blank>Imperator<S2SV_blank>Keyboard"" ) ; break ; case USB_DEVICE_ID_GENIUS_MANTICORE : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 104 , ""Genius<S2SV_blank>Manticore<S2SV_blank>Keyboard"" ) ; break ; } return rdesc ; }","* rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; <S2SV_ModEnd> rdesc [ 62 <S2SV_ModStart> [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> ; } break"
345,"static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof TSRMLS_DC ) { <S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> size_t klen , vlen ; unsigned int new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> if ( ! vsep ) { <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = """" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen TSRMLS_CC ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr TSRMLS_CC ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }","{ char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;"
346,"uint32_t * GetPayload ( size_t handle , uint32_t * lastpayload , uint32_t index ) { mp4object * mp4 = ( mp4object * ) handle ; if ( mp4 == NULL ) return NULL ; uint32_t * MP4buffer = NULL ; if ( index < mp4 -> indexcount && mp4 -> mediafp ) { MP4buffer = ( uint32_t * ) realloc ( ( void * ) lastpayload , mp4 -> metasizes [ index ] ) ; if ( MP4buffer ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , mp4 -> metaoffsets [ index ] , SEEK_SET ) ; <S2SV_EndBug> fread ( MP4buffer , 1 , mp4 -> metasizes [ index ] , mp4 -> mediafp ) ; <S2SV_StartBug> return MP4buffer ; <S2SV_EndBug> } } return NULL ; }",MP4buffer ) { if ( mp4 -> filesize > mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ) { <S2SV_ModStart> mediafp ) ; mp4 -> filepos = mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ; <S2SV_ModStart> return MP4buffer ; }
347,"vpx_codec_err_t vp9_set_reference_dec ( VP9_COMMON * cm , VP9_REFFRAME ref_frame_flag , YV12_BUFFER_CONFIG * sd ) { <S2SV_StartBug> RefBuffer * ref_buf = NULL ; <S2SV_EndBug> if ( ref_frame_flag == VP9_LAST_FLAG ) { ref_buf = & cm -> frame_refs [ 0 ] ; } else if ( ref_frame_flag == VP9_GOLD_FLAG ) { ref_buf = & cm -> frame_refs [ 1 ] ; } else if ( ref_frame_flag == VP9_ALT_FLAG ) { ref_buf = & cm -> frame_refs [ 2 ] ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Invalid<S2SV_blank>reference<S2SV_blank>frame"" ) ; return cm -> error . error_code ; } if ( ! equal_dimensions ( ref_buf -> buf , sd ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions"" ) ; } else { int * ref_fb_ptr = & ref_buf -> idx ; const int free_fb = get_free_fb ( cm ) ; <S2SV_StartBug> cm -> frame_bufs [ free_fb ] . ref_count -- ; <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , ref_fb_ptr , free_fb ) ; <S2SV_EndBug> <S2SV_StartBug> ref_buf -> buf = & cm -> frame_bufs [ * ref_fb_ptr ] . buf ; <S2SV_EndBug> vp8_yv12_copy_frame ( sd , ref_buf -> buf ) ; } return cm -> error . error_code ; }","ref_buf = NULL ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> cm ) ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; -- <S2SV_ModEnd> frame_bufs [ free_fb <S2SV_ModStart> ] . ref_count <S2SV_ModEnd> ; ref_cnt_fb ( <S2SV_ModStart> ; ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , ref_fb_ptr <S2SV_ModStart> buf = & <S2SV_ModEnd> frame_bufs [ *"
348,"WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( ""u1_mb_type"" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; <S2SV_StartBug> } <S2SV_EndBug> i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }",ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
349,"<S2SV_StartBug> static int write_skip ( const VP9_COMP * cpi , int segment_id , const MODE_INFO * mi , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> if ( vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) { return 1 ; } else { const int skip = mi -> mbmi . skip ; <S2SV_StartBug> vp9_write ( w , skip , vp9_get_skip_prob ( & cpi -> common , xd ) ) ; <S2SV_EndBug> return skip ; } }","write_skip ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> int segment_id , <S2SV_ModStart> * mi , vpx_writer <S2SV_ModEnd> * w ) <S2SV_ModStart> w ) { if ( segfeature_active ( & cm -> <S2SV_ModEnd> seg , segment_id <S2SV_ModStart> . skip ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> , vp9_get_skip_prob ( cm <S2SV_ModEnd> , xd )"
350,"static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = """" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , ""%s"" , sep ) ) ; sep = "","" ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( ip_option_values , ""unknown<S2SV_blank>%u"" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : <S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> if ( option_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>value<S2SV_blank>%u"" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","case IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo , <S2SV_ModStart> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case"
351,"static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",") ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"""
352,"long keyctl_update_key ( key_serial_t id , const void __user * _payload , size_t plen ) { key_ref_t key_ref ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > PAGE_SIZE ) goto error ; payload = NULL ; <S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ret = - ENOMEM ; payload = kmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error2 ; } key_ref = lookup_user_key ( id , 0 , KEY_NEED_WRITE ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error2 ; } ret = key_update ( key_ref , payload , plen ) ; key_ref_put ( key_ref ) ; error2 : kfree ( payload ) ; error : return ret ; }",; if ( plen <S2SV_ModEnd> ) { ret
353,"int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( args -> index < ichdr . count ) ; ASSERT ( args -> index >= 0 ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; ASSERT ( namelen == args -> namelen ) ; ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }",( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
354,"asmlinkage void do_sparc_fault ( struct pt_regs * regs , int text_fault , int write , unsigned long address ) { struct vm_area_struct * vma ; struct task_struct * tsk = current ; struct mm_struct * mm = tsk -> mm ; unsigned int fixup ; unsigned long g2 ; int from_user = ! ( regs -> psr & PSR_PS ) ; int fault , code ; if ( text_fault ) address = regs -> pc ; code = SEGV_MAPERR ; if ( ! ARCH_SUN4C && address >= TASK_SIZE ) goto vmalloc_fault ; if ( in_atomic ( ) || ! mm ) goto no_context ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> down_read ( & mm -> mmap_sem ) ; if ( ! from_user && address >= PAGE_OFFSET ) goto bad_area ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto bad_area ; if ( vma -> vm_start <= address ) goto good_area ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto bad_area ; if ( expand_stack ( vma , address ) ) goto bad_area ; good_area : code = SEGV_ACCERR ; if ( write ) { if ( ! ( vma -> vm_flags & VM_WRITE ) ) goto bad_area ; } else { if ( ! ( vma -> vm_flags & ( VM_READ | VM_EXEC ) ) ) goto bad_area ; } fault = handle_mm_fault ( mm , vma , address , write ? FAULT_FLAG_WRITE : 0 ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) { if ( fault & VM_FAULT_OOM ) goto out_of_memory ; else if ( fault & VM_FAULT_SIGBUS ) goto do_sigbus ; BUG ( ) ; } if ( fault & VM_FAULT_MAJOR ) { current -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { current -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } up_read ( & mm -> mmap_sem ) ; return ; bad_area : up_read ( & mm -> mmap_sem ) ; bad_area_nosemaphore : if ( from_user ) { do_fault_siginfo ( code , SIGSEGV , regs , text_fault ) ; return ; } no_context : g2 = regs -> u_regs [ UREG_G2 ] ; if ( ! from_user ) { fixup = search_extables_range ( regs -> pc , & g2 ) ; if ( fixup > 10 ) { extern const unsigned __memset_start [ ] ; extern const unsigned __memset_end [ ] ; extern const unsigned __csum_partial_copy_start [ ] ; extern const unsigned __csum_partial_copy_end [ ] ; # ifdef DEBUG_EXCEPTIONS printk ( ""Exception:<S2SV_blank>PC<%08lx><S2SV_blank>faddr<%08lx>\\n"" , regs -> pc , address ) ; printk ( ""EX_TABLE:<S2SV_blank>insn<%08lx><S2SV_blank>fixup<%08x><S2SV_blank>g2<%08lx>\\n"" , regs -> pc , fixup , g2 ) ; # endif if ( ( regs -> pc >= ( unsigned long ) __memset_start && regs -> pc < ( unsigned long ) __memset_end ) || ( regs -> pc >= ( unsigned long ) __csum_partial_copy_start && regs -> pc < ( unsigned long ) __csum_partial_copy_end ) ) { regs -> u_regs [ UREG_I4 ] = address ; regs -> u_regs [ UREG_I5 ] = regs -> pc ; } regs -> u_regs [ UREG_G2 ] = g2 ; regs -> pc = fixup ; regs -> npc = regs -> pc + 4 ; return ; } } unhandled_fault ( address , tsk , regs ) ; do_exit ( SIGKILL ) ; out_of_memory : up_read ( & mm -> mmap_sem ) ; if ( from_user ) { pagefault_out_of_memory ( ) ; return ; } goto no_context ; do_sigbus : up_read ( & mm -> mmap_sem ) ; do_fault_siginfo ( BUS_ADRERR , SIGBUS , regs , text_fault ) ; if ( ! from_user ) goto no_context ; vmalloc_fault : { int offset = pgd_index ( address ) ; pgd_t * pgd , * pgd_k ; pmd_t * pmd , * pmd_k ; pgd = tsk -> active_mm -> pgd + offset ; pgd_k = init_mm . pgd + offset ; if ( ! pgd_present ( * pgd ) ) { if ( ! pgd_present ( * pgd_k ) ) goto bad_area_nosemaphore ; pgd_val ( * pgd ) = pgd_val ( * pgd_k ) ; return ; } pmd = pmd_offset ( pgd , address ) ; pmd_k = pmd_offset ( pgd_k , address ) ; if ( pmd_present ( * pmd ) || ! pmd_present ( * pmd_k ) ) goto bad_area_nosemaphore ; * pmd = * pmd_k ; return ; } }","PERF_COUNT_SW_PAGE_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address"
355,"static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }","; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :"
356,"int obj2ast_alias ( PyObject * obj , alias_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier name ; identifier asname ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_identifier ( tmp , & name , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_asname ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_asname ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & asname , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { asname = NULL ; } * out = alias ( name , asname , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_asname , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; asname = NULL ; } else { int res ; <S2SV_ModStart> tmp , & asname <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out ="
357,"static void mt76_add_fragment ( struct mt76_dev * dev , struct mt76_queue * q , void * data , int len , bool more ) { struct page * page = virt_to_head_page ( data ) ; int offset = data - page_address ( page ) ; struct sk_buff * skb = q -> rx_head ; <S2SV_StartBug> offset += q -> buf_offset ; <S2SV_EndBug> <S2SV_StartBug> skb_add_rx_frag ( skb , skb_shinfo ( skb ) -> nr_frags , page , offset , len , <S2SV_EndBug> <S2SV_StartBug> q -> buf_size ) ; <S2SV_EndBug> if ( more ) return ; q -> rx_head = NULL ; dev -> drv -> rx_skb ( dev , q - dev -> q_rx , skb ) ; }","-> rx_head ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; if ( shinfo -> nr_frags < ARRAY_SIZE ( shinfo -> frags ) ) { <S2SV_ModStart> ( skb , shinfo <S2SV_ModEnd> -> nr_frags , <S2SV_ModStart> buf_size ) ; }"
358,"<S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> len ++ ; if ( digit3 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> len ++ ; if ( digit4 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }","char * in , size_t olen <S2SV_ModStart> += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ;"
359,"static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; } <S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }",EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
360,bool recovery_cipher_abort ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( awaiting_character ) { awaiting_character = false ; return true ; } return false ; },void ) { recovery_started = false ;
361,"static noinline int btrfs_ioctl_resize ( struct file * file , void __user * arg ) { struct inode * inode = file_inode ( file ) ; struct btrfs_fs_info * fs_info = btrfs_sb ( inode -> i_sb ) ; u64 new_size ; u64 old_size ; u64 devid = 1 ; struct btrfs_root * root = BTRFS_I ( inode ) -> root ; struct btrfs_ioctl_vol_args * vol_args ; struct btrfs_trans_handle * trans ; struct btrfs_device * device = NULL ; char * sizestr ; char * retptr ; char * devstr = NULL ; int ret = 0 ; int mod = 0 ; if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; ret = mnt_want_write_file ( file ) ; if ( ret ) return ret ; if ( test_and_set_bit ( BTRFS_FS_EXCL_OP , & fs_info -> flags ) ) { mnt_drop_write_file ( file ) ; return BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS ; } vol_args = memdup_user ( arg , sizeof ( * vol_args ) ) ; if ( IS_ERR ( vol_args ) ) { ret = PTR_ERR ( vol_args ) ; goto out ; } vol_args -> name [ BTRFS_PATH_NAME_MAX ] = '\\0' ; sizestr = vol_args -> name ; devstr = strchr ( sizestr , ':' ) ; if ( devstr ) { sizestr = devstr + 1 ; * devstr = '\\0' ; devstr = vol_args -> name ; ret = kstrtoull ( devstr , 10 , & devid ) ; if ( ret ) goto out_free ; if ( ! devid ) { ret = - EINVAL ; goto out_free ; } btrfs_info ( fs_info , ""resizing<S2SV_blank>devid<S2SV_blank>%llu"" , devid ) ; } <S2SV_StartBug> device = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <S2SV_EndBug> if ( ! device ) { btrfs_info ( fs_info , ""resizer<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>device<S2SV_blank>%llu"" , devid ) ; ret = - ENODEV ; goto out_free ; } if ( ! test_bit ( BTRFS_DEV_STATE_WRITEABLE , & device -> dev_state ) ) { btrfs_info ( fs_info , ""resizer<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>on<S2SV_blank>readonly<S2SV_blank>device<S2SV_blank>%llu"" , devid ) ; ret = - EPERM ; goto out_free ; } if ( ! strcmp ( sizestr , ""max"" ) ) new_size = device -> bdev -> bd_inode -> i_size ; else { if ( sizestr [ 0 ] == '-' ) { mod = - 1 ; sizestr ++ ; } else if ( sizestr [ 0 ] == '+' ) { mod = 1 ; sizestr ++ ; } new_size = memparse ( sizestr , & retptr ) ; if ( * retptr != '\\0' || new_size == 0 ) { ret = - EINVAL ; goto out_free ; } } if ( test_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & device -> dev_state ) ) { ret = - EPERM ; goto out_free ; } old_size = btrfs_device_get_total_bytes ( device ) ; if ( mod < 0 ) { if ( new_size > old_size ) { ret = - EINVAL ; goto out_free ; } new_size = old_size - new_size ; } else if ( mod > 0 ) { if ( new_size > ULLONG_MAX - old_size ) { ret = - ERANGE ; goto out_free ; } new_size = old_size + new_size ; } if ( new_size < SZ_256M ) { ret = - EINVAL ; goto out_free ; } if ( new_size > device -> bdev -> bd_inode -> i_size ) { ret = - EFBIG ; goto out_free ; } new_size = round_down ( new_size , fs_info -> sectorsize ) ; btrfs_info_in_rcu ( fs_info , ""new<S2SV_blank>size<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%llu"" , rcu_str_deref ( device -> name ) , new_size ) ; if ( new_size > old_size ) { trans = btrfs_start_transaction ( root , 0 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; goto out_free ; } ret = btrfs_grow_device ( trans , device , new_size ) ; btrfs_commit_transaction ( trans ) ; } else if ( new_size < old_size ) { ret = btrfs_shrink_device ( device , new_size ) ; } out_free : kfree ( vol_args ) ; out : clear_bit ( BTRFS_FS_EXCL_OP , & fs_info -> flags ) ; mnt_drop_write_file ( file ) ; return ret ; }","NULL , NULL , true"
362,"static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { EXRContext * s = avctx -> priv_data ; ThreadFrame frame = { . f = data } ; AVFrame * picture = data ; uint8_t * ptr ; int i , y , ret , ymax ; int planes ; int out_line_size ; int nb_blocks ; uint64_t start_offset_table ; uint64_t start_next_scanline ; PutByteContext offset_table_writer ; bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; if ( ( ret = decode_header ( s , picture ) ) < 0 ) return ret ; switch ( s -> pixel_type ) { case EXR_FLOAT : case EXR_HALF : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAYF32 ; } } break ; case EXR_UINT : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64 ; } else { avctx -> pix_fmt = AV_PIX_FMT_YA16 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } } break ; default : av_log ( avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>channel<S2SV_blank>list.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> apply_trc_type != AVCOL_TRC_UNSPECIFIED ) avctx -> color_trc = s -> apply_trc_type ; switch ( s -> compression ) { case EXR_RAW : case EXR_RLE : case EXR_ZIP1 : s -> scan_lines_per_block = 1 ; break ; case EXR_PXR24 : case EXR_ZIP16 : s -> scan_lines_per_block = 16 ; break ; case EXR_PIZ : case EXR_B44 : case EXR_B44A : s -> scan_lines_per_block = 32 ; break ; default : avpriv_report_missing_feature ( avctx , ""Compression<S2SV_blank>%d"" , s -> compression ) ; return AVERROR_PATCHWELCOME ; } if ( s -> xmin > s -> xmax || s -> ymin > s -> ymax || s -> ydelta == 0xFFFFFFFF || s -> xdelta == 0xFFFFFFFF ) { av_log ( avctx , AV_LOG_ERROR , ""Wrong<S2SV_blank>or<S2SV_blank>missing<S2SV_blank>size<S2SV_blank>information.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , s -> w , s -> h ) ) < 0 ) return ret ; s -> desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( ! s -> desc ) return AVERROR_INVALIDDATA ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_FLOAT ) { planes = s -> desc -> nb_components ; out_line_size = avctx -> width * 4 ; } else { planes = 1 ; out_line_size = avctx -> width * 2 * s -> desc -> nb_components ; } if ( s -> is_tile ) { nb_blocks = ( ( s -> xdelta + s -> tile_attr . xSize - 1 ) / s -> tile_attr . xSize ) * ( ( s -> ydelta + s -> tile_attr . ySize - 1 ) / s -> tile_attr . ySize ) ; } else { nb_blocks = ( s -> ydelta + s -> scan_lines_per_block - 1 ) / s -> scan_lines_per_block ; } if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) return ret ; if ( bytestream2_get_bytes_left ( & s -> gb ) / 8 < nb_blocks ) return AVERROR_INVALIDDATA ; if ( ! s -> is_tile && bytestream2_peek_le64 ( & s -> gb ) == 0 ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""recreating<S2SV_blank>invalid<S2SV_blank>scanline<S2SV_blank>offset<S2SV_blank>table\\n"" ) ; start_offset_table = bytestream2_tell ( & s -> gb ) ; start_next_scanline = start_offset_table + nb_blocks * 8 ; bytestream2_init_writer ( & offset_table_writer , & avpkt -> data [ start_offset_table ] , nb_blocks * 8 ) ; for ( y = 0 ; y < nb_blocks ; y ++ ) { bytestream2_put_le64 ( & offset_table_writer , start_next_scanline ) ; bytestream2_seek ( & s -> gb , start_next_scanline + 4 , SEEK_SET ) ; start_next_scanline += ( bytestream2_get_le32 ( & s -> gb ) + 8 ) ; } bytestream2_seek ( & s -> gb , start_offset_table , SEEK_SET ) ; } s -> buf = avpkt -> data ; s -> buf_size = avpkt -> size ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] ; for ( y = 0 ; y < FFMIN ( s -> ymin , s -> h ) ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } s -> picture = picture ; avctx -> execute2 ( avctx , decode_block , s -> thread_data , NULL , nb_blocks ) ; ymax = FFMAX ( 0 , s -> ymax + 1 ) ; <S2SV_StartBug> for ( i = 0 ; i < planes ; i ++ ) { <S2SV_EndBug> ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ; for ( y = ymax ; y < avctx -> height ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } picture -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }",1 ) ; if ( ymax < avctx -> height )
363,"static MagickBooleanType Get8BIMProperty ( const Image * image , const char * key , ExceptionInfo * exception ) { char * attribute , format [ MagickPathExtent ] , name [ MagickPathExtent ] , * resource ; const StringInfo * profile ; const unsigned char * info ; long start , stop ; MagickBooleanType status ; register ssize_t i ; size_t length ; ssize_t count , id , sub_number ; profile = GetImageProfile ( image , ""8bim"" ) ; if ( profile == ( StringInfo * ) NULL ) return ( MagickFalse ) ; count = ( ssize_t ) sscanf ( key , ""8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]"" , & start , & stop , name , format ) ; if ( ( count != 2 ) && ( count != 3 ) && ( count != 4 ) ) return ( MagickFalse ) ; if ( count < 4 ) ( void ) CopyMagickString ( format , ""SVG"" , MagickPathExtent ) ; if ( count < 3 ) * name = '\\0' ; sub_number = 1 ; if ( * name == '#' ) sub_number = ( ssize_t ) StringToLong ( & name [ 1 ] ) ; sub_number = MagickMax ( sub_number , 1L ) ; resource = ( char * ) NULL ; status = MagickFalse ; length = GetStringInfoLength ( profile ) ; info = GetStringInfoDatum ( profile ) ; while ( ( length > 0 ) && ( status == MagickFalse ) ) { if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) '8' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'B' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'I' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'M' ) continue ; id = ( ssize_t ) ReadPropertyMSBShort ( & info , & length ) ; if ( id < ( ssize_t ) start ) continue ; if ( id > ( ssize_t ) stop ) continue ; if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; count = ( ssize_t ) ReadPropertyByte ( & info , & length ) ; if ( ( count != 0 ) && ( ( size_t ) count <= length ) ) { resource = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) resource = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * resource ) ) ; if ( resource != ( char * ) NULL ) { for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) resource [ i ] = ( char ) ReadPropertyByte ( & info , & length ) ; resource [ count ] = '\\0' ; } } if ( ( count & 0x01 ) == 0 ) ( void ) ReadPropertyByte ( & info , & length ) ; count = ( ssize_t ) ReadPropertyMSBLong ( & info , & length ) ; <S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) { info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } if ( ( * name == '#' ) && ( sub_number != 1 ) ) { sub_number -- ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } attribute = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) attribute = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * attribute ) ) ; if ( attribute != ( char * ) NULL ) { ( void ) CopyMagickMemory ( attribute , ( char * ) info , ( size_t ) count ) ; attribute [ count ] = '\\0' ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; if ( ( id <= 1999 ) || ( id >= 2999 ) ) ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) attribute , exception ) ; else { char * path ; if ( LocaleCompare ( format , ""svg"" ) == 0 ) path = TraceSVGClippath ( ( unsigned char * ) attribute , ( size_t ) count , image -> columns , image -> rows ) ; else path = TracePSClippath ( ( unsigned char * ) attribute , ( size_t ) count ) ; ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) path , exception ) ; path = DestroyString ( path ) ; } attribute = DestroyString ( attribute ) ; status = MagickTrue ; } } if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; return ( status ) ; }",if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
364,static void i8042_stop ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ; <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> },-> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart> I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
365,"static struct file * path_openat ( int dfd , struct filename * pathname , struct nameidata * nd , const struct open_flags * op , int flags ) { struct file * file ; struct path path ; int opened = 0 ; int error ; file = get_empty_filp ( ) ; if ( IS_ERR ( file ) ) return file ; file -> f_flags = op -> open_flag ; if ( unlikely ( file -> f_flags & __O_TMPFILE ) ) { error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } error = path_init ( dfd , pathname , flags , nd ) ; if ( unlikely ( error ) ) goto out ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; while ( unlikely ( error > 0 ) ) { struct path link = path ; void * cookie ; if ( ! ( nd -> flags & LOOKUP_FOLLOW ) ) { path_put_conditional ( & path , nd ) ; path_put ( & nd -> path ) ; error = - ELOOP ; break ; } error = may_follow_link ( & link , nd ) ; if ( unlikely ( error ) ) break ; nd -> flags |= LOOKUP_PARENT ; nd -> flags &= ~ ( LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_EXCL ) ; error = follow_link ( & link , nd , & cookie ) ; if ( unlikely ( error ) ) break ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; put_link ( nd , & link , cookie ) ; } out : path_cleanup ( nd ) ; <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug> BUG_ON ( ! error ) ; put_filp ( file ) ; } if ( unlikely ( error ) ) { if ( error == - EOPENSTALE ) { if ( flags & LOOKUP_RCU ) error = - ECHILD ; else error = - ESTALE ; } file = ERR_PTR ( error ) ; } return file ; }",) ; goto out2 <S2SV_ModEnd> ; } error <S2SV_ModStart> nd ) ; out2 :
366,"static void emulate_load_store_insn ( struct pt_regs * regs , void __user * addr , unsigned int __user * pc ) { union mips_instruction insn ; unsigned long value ; unsigned int res ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> __get_user ( insn . word , pc ) ; switch ( insn . i_format . opcode ) { case ll_op : case lld_op : case sc_op : case scd_op : case ldl_op : case ldr_op : case lwl_op : case lwr_op : case sdl_op : case sdr_op : case swl_op : case swr_op : case lb_op : case lbu_op : case sb_op : goto sigbus ; case lh_op : if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __BIG_ENDIAN ""1:\\tlb\\t%0,<S2SV_blank>0(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>1(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlb\\t%0,<S2SV_blank>1(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>0(%2)\\n\\t"" # endif ""sll\\t%0,<S2SV_blank>0x8\\n\\t"" ""or\\t%0,<S2SV_blank>$1\\n\\t"" ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lw_op : if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>3(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lhu_op : if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __BIG_ENDIAN ""1:\\tlbu\\t%0,<S2SV_blank>0(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>1(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlbu\\t%0,<S2SV_blank>1(%2)\\n"" ""2:\\tlbu\\t$1,<S2SV_blank>0(%2)\\n\\t"" # endif ""sll\\t%0,<S2SV_blank>0x8\\n\\t"" ""or\\t%0,<S2SV_blank>$1\\n\\t"" ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lwu_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlwl\\t%0,<S2SV_blank>3(%2)\\n"" ""2:\\tlwr\\t%0,<S2SV_blank>(%2)\\n\\t"" # endif ""dsll\\t%0,<S2SV_blank>%0,<S2SV_blank>32\\n\\t"" ""dsrl\\t%0,<S2SV_blank>%0,<S2SV_blank>32\\n\\t"" ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case ld_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_READ , addr , 8 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tldl\\t%0,<S2SV_blank>(%2)\\n"" ""2:\\tldr\\t%0,<S2SV_blank>7(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tldl\\t%0,<S2SV_blank>7(%2)\\n"" ""2:\\tldr\\t%0,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%1,<S2SV_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case sh_op : if ( ! access_ok ( VERIFY_WRITE , addr , 2 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN "".set\\tnoat\\n"" ""1:\\tsb\\t%1,<S2SV_blank>1(%2)\\n\\t"" ""srl\\t$1,<S2SV_blank>%1,<S2SV_blank>0x8\\n"" ""2:\\tsb\\t$1,<S2SV_blank>0(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif # ifdef __LITTLE_ENDIAN "".set\\tnoat\\n"" ""1:\\tsb\\t%1,<S2SV_blank>0(%2)\\n\\t"" ""srl\\t$1,%1,<S2SV_blank>0x8\\n"" ""2:\\tsb\\t$1,<S2SV_blank>1(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif ""li\\t%0,<S2SV_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sw_op : if ( ! access_ok ( VERIFY_WRITE , addr , 4 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tswl\\t%1,(%2)\\n"" ""2:\\tswr\\t%1,<S2SV_blank>3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tswl\\t%1,<S2SV_blank>3(%2)\\n"" ""2:\\tswr\\t%1,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%0,<S2SV_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sd_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_WRITE , addr , 8 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tsdl\\t%1,(%2)\\n"" ""2:\\tsdr\\t%1,<S2SV_blank>7(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tsdl\\t%1,<S2SV_blank>7(%2)\\n"" ""2:\\tsdr\\t%1,<S2SV_blank>(%2)\\n\\t"" # endif ""li\\t%0,<S2SV_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<S2SV_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,<S2SV_blank>4b\\n\\t"" STR ( PTR ) ""\\t2b,<S2SV_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; # endif goto sigill ; case lwc1_op : case ldc1_op : case swc1_op : case sdc1_op : goto sigbus ; case lwc2_op : cu2_notifier_call_chain ( CU2_LWC2_OP , regs ) ; break ; case ldc2_op : cu2_notifier_call_chain ( CU2_LDC2_OP , regs ) ; break ; case swc2_op : cu2_notifier_call_chain ( CU2_SWC2_OP , regs ) ; break ; case sdc2_op : cu2_notifier_call_chain ( CU2_SDC2_OP , regs ) ; break ; default : goto sigill ; } # ifdef CONFIG_DEBUG_FS unaligned_instructions ++ ; # endif return ; fault : if ( fixup_exception ( regs ) ) return ; die_if_kernel ( ""Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access"" , regs ) ; force_sig ( SIGSEGV , current ) ; return ; sigbus : die_if_kernel ( ""Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access"" , regs ) ; force_sig ( SIGBUS , current ) ; return ; sigill : die_if_kernel ( ""Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>instruction"" , regs ) ; force_sig ( SIGILL , current ) ; }","PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,"
367,"static x86newTokenType getToken ( const char * str , size_t * begin , size_t * end ) { <S2SV_StartBug> while ( begin && isspace ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> ++ ( * begin ) ; } if ( ! str [ * begin ] ) { * end = * begin ; return TT_EOF ; <S2SV_StartBug> } else if ( isalpha ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> * end = * begin ; <S2SV_StartBug> while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { <S2SV_EndBug> ++ ( * end ) ; } return TT_WORD ; <S2SV_StartBug> } else if ( isdigit ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> * end = * begin ; while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { ++ ( * end ) ; } return TT_NUMBER ; } else { * end = * begin + 1 ; return TT_SPECIAL ; } }",end ) { if ( * begin > strlen ( str ) ) { return TT_EOF ; } <S2SV_ModStart> ( begin && str [ * begin ] && <S2SV_ModStart> TT_EOF ; } <S2SV_ModEnd> if ( isalpha <S2SV_ModStart> ( end && str [ * end ] && <S2SV_ModStart> TT_WORD ; } <S2SV_ModEnd> if ( isdigit
368,"void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , ""authorization"" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , ""basic"" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , ""content-length:"" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , ""content-type:"" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , ""x-www-form-urlencoded"" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , ""HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n"" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : """" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , ""<tr>"" ""<td>%s</td><td><A<S2SV_blank>HREF=\\\'/C%c%d\\\'>%s</A></td><td>"" , ( cp -> comment ) ? cp -> comment : ""&nbsp;"" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? ""NO"" : ""YES"" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , "",<br<S2SV_blank>/>\\r\\n"" ) ; } inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , "",<br<S2SV_blank>/>\\r\\n"" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , ""</td><td<S2SV_blank>colspan=\\\'6\\\'<S2SV_blank>align=\\\'center\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\r\\n"" ) ; } else { inbuf += sprintf ( buf + inbuf , ""</td><td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>MB%s</td>"" ""<td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>%s</td>"" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : ""never"" ) ; inbuf += sprintf ( buf + inbuf , ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\\r\\n"" , cp -> updated ? ctime ( & cp -> updated ) : ""never"" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , ""<h3>Reload<S2SV_blank>scheduled</h3>"" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , ""<h3><font<S2SV_blank>color=\\""red\\"">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>"" ) ; break ; } printstr ( & pp , ""<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>"" ) ; <S2SV_StartBug> printstr ( & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , ""</textarea><br><input<S2SV_blank>type=\\""Submit\\""></form>"" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , ""conffile="" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , ""%s"" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? ""<h3><font<S2SV_blank>color=\\""red\\"">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\""writable\\""<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file"" : ""<h3>Configuration<S2SV_blank>updated</h3>"" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }","printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , ""%u"" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""<S2SV_blank>enctype=\\""application/x-www-form-urlencoded\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if"
369,"static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , ""block<S2SV_blank>multicast<S2SV_blank>loopback<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , ""cross-channel<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EINVAL ; } if ( init_attr -> create_flags & IB_QP_CREATE_CROSS_CHANNEL ) qp -> flags |= MLX5_IB_QP_CROSS_CHANNEL ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_SEND ) qp -> flags |= MLX5_IB_QP_MANAGED_SEND ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_RECV ) qp -> flags |= MLX5_IB_QP_MANAGED_RECV ; } if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) if ( ! MLX5_CAP_GEN ( mdev , ipoib_basic_offloads ) ) { mlx5_ib_dbg ( dev , ""ipoib<S2SV_blank>UD<S2SV_blank>lso<S2SV_blank>qp<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } if ( init_attr -> create_flags & IB_QP_CREATE_SCATTER_FCS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { mlx5_ib_dbg ( dev , ""Scatter<S2SV_blank>FCS<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>only<S2SV_blank>for<S2SV_blank>Raw<S2SV_blank>Packet<S2SV_blank>QPs"" ) ; return - EOPNOTSUPP ; } if ( ! MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) || ! MLX5_CAP_ETH ( dev -> mdev , scatter_fcs ) ) { mlx5_ib_dbg ( dev , ""Scatter<S2SV_blank>FCS<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_CAP_SCATTER_FCS ; } if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) qp -> sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE ; if ( init_attr -> create_flags & IB_QP_CREATE_CVLAN_STRIPPING ) { if ( ! ( MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) && MLX5_CAP_ETH ( dev -> mdev , vlan_cap ) ) || ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) ) return - EOPNOTSUPP ; qp -> flags |= MLX5_IB_QP_CVLAN_STRIPPING ; } if ( pd && pd -> uobject ) { if ( ib_copy_from_udata ( & ucmd , udata , sizeof ( ucmd ) ) ) { mlx5_ib_dbg ( dev , ""copy<S2SV_blank>failed\\n"" ) ; return - EFAULT ; } err = get_qp_user_index ( to_mucontext ( pd -> uobject -> context ) , & ucmd , udata -> inlen , & uidx ) ; if ( err ) return err ; qp -> wq_sig = ! ! ( ucmd . flags & MLX5_QP_FLAG_SIGNATURE ) ; qp -> scat_cqe = ! ! ( ucmd . flags & MLX5_QP_FLAG_SCATTER_CQE ) ; if ( ucmd . flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET || ! tunnel_offload_supported ( mdev ) ) { mlx5_ib_dbg ( dev , ""Tunnel<S2SV_blank>offload<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> tunnel_offload_en = true ; } if ( init_attr -> create_flags & IB_QP_CREATE_SOURCE_QPN ) { if ( init_attr -> qp_type != IB_QPT_UD || ( MLX5_CAP_GEN ( dev -> mdev , port_type ) != MLX5_CAP_PORT_TYPE_IB ) || ! mlx5_get_flow_namespace ( dev -> mdev , MLX5_FLOW_NAMESPACE_BYPASS ) ) { mlx5_ib_dbg ( dev , ""Source<S2SV_blank>QP<S2SV_blank>option<S2SV_blank>isn\'t<S2SV_blank>supported\\n"" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_UNDERLAY ; qp -> underlay_qpn = init_attr -> source_qpn ; } } else { qp -> wq_sig = ! ! wq_signature ; } base = ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) ? & qp -> raw_packet_qp . rq . base : & qp -> trans_qp . base ; qp -> has_rq = qp_has_rq ( init_attr ) ; err = set_rq_size ( dev , & init_attr -> cap , qp -> has_rq , qp , ( pd && pd -> uobject ) ? & ucmd : NULL ) ; if ( err ) { mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; return err ; } if ( pd ) { if ( pd -> uobject ) { __u32 max_wqes = 1 << MLX5_CAP_GEN ( mdev , log_max_qp_sz ) ; mlx5_ib_dbg ( dev , ""requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)\\n"" , ucmd . sq_wqe_count ) ; if ( ucmd . rq_wqe_shift != qp -> rq . wqe_shift || ucmd . rq_wqe_count != qp -> rq . wqe_cnt ) { mlx5_ib_dbg ( dev , ""invalid<S2SV_blank>rq<S2SV_blank>params\\n"" ) ; return - EINVAL ; } if ( ucmd . sq_wqe_count > max_wqes ) { mlx5_ib_dbg ( dev , ""requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)<S2SV_blank>><S2SV_blank>max<S2SV_blank>allowed<S2SV_blank>(%d)\\n"" , ucmd . sq_wqe_count , max_wqes ) ; return - EINVAL ; } if ( init_attr -> create_flags & mlx5_ib_create_qp_sqpn_qp1 ( ) ) { mlx5_ib_dbg ( dev , ""user-space<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>UD<S2SV_blank>QPs<S2SV_blank>spoofing<S2SV_blank>as<S2SV_blank>QP1\\n"" ) ; return - EINVAL ; } err = create_user_qp ( dev , pd , qp , udata , init_attr , & in , & resp , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; } else { err = create_kernel_qp ( dev , init_attr , qp , & in , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , ""err<S2SV_blank>%d\\n"" , err ) ; } if ( err ) return err ; } else { in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) return - ENOMEM ; qp -> create_type = MLX5_QP_EMPTY ; } if ( is_sqp ( init_attr -> qp_type ) ) qp -> port = init_attr -> port_num ; qpc = MLX5_ADDR_OF ( create_qp_in , in , qpc ) ; MLX5_SET ( qpc , qpc , st , mlx5_st ) ; MLX5_SET ( qpc , qpc , pm_state , MLX5_QP_PM_MIGRATED ) ; if ( init_attr -> qp_type != MLX5_IB_QPT_REG_UMR ) MLX5_SET ( qpc , qpc , pd , to_mpd ( pd ? pd : devr -> p0 ) -> pdn ) ; else MLX5_SET ( qpc , qpc , latency_sensitive , 1 ) ; if ( qp -> wq_sig ) MLX5_SET ( qpc , qpc , wq_signature , 1 ) ; if ( qp -> flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ) MLX5_SET ( qpc , qpc , block_lb_mc , 1 ) ; if ( qp -> flags & MLX5_IB_QP_CROSS_CHANNEL ) MLX5_SET ( qpc , qpc , cd_master , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_SEND ) MLX5_SET ( qpc , qpc , cd_slave_send , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_RECV ) MLX5_SET ( qpc , qpc , cd_slave_receive , 1 ) ; if ( qp -> scat_cqe && is_connected ( init_attr -> qp_type ) ) { int rcqe_sz ; int scqe_sz ; rcqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> recv_cq ) ; scqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> send_cq ) ; if ( rcqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA32_CQE ) ; if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) { if ( scqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA32_CQE ) ; } } if ( qp -> rq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_rq_stride , qp -> rq . wqe_shift - 4 ) ; MLX5_SET ( qpc , qpc , log_rq_size , ilog2 ( qp -> rq . wqe_cnt ) ) ; } MLX5_SET ( qpc , qpc , rq_type , get_rx_type ( qp , init_attr ) ) ; if ( qp -> sq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_sq_size , ilog2 ( qp -> sq . wqe_cnt ) ) ; } else { MLX5_SET ( qpc , qpc , no_sq , 1 ) ; if ( init_attr -> srq && init_attr -> srq -> srq_type == IB_SRQT_TM ) MLX5_SET ( qpc , qpc , offload_type , MLX5_QPC_OFFLOAD_TYPE_RNDV ) ; } switch ( init_attr -> qp_type ) { case IB_QPT_XRC_TGT : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( init_attr -> xrcd ) -> xrcdn ) ; break ; case IB_QPT_XRC_INI : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; break ; default : if ( init_attr -> srq ) { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x0 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( init_attr -> srq ) -> msrq . srqn ) ; } else { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s1 ) -> msrq . srqn ) ; } } if ( init_attr -> send_cq ) MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( init_attr -> send_cq ) -> mcq . cqn ) ; if ( init_attr -> recv_cq ) MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( init_attr -> recv_cq ) -> mcq . cqn ) ; MLX5_SET64 ( qpc , qpc , dbr_addr , qp -> db . dma ) ; if ( MLX5_CAP_GEN ( mdev , cqe_version ) == MLX5_CQE_VERSION_V1 ) MLX5_SET ( qpc , qpc , user_index , uidx ) ; if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) { MLX5_SET ( qpc , qpc , ulp_stateless_offload_mode , 1 ) ; qp -> flags |= MLX5_IB_QP_LSO ; } if ( init_attr -> create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING ) { if ( ! MLX5_CAP_GEN ( dev -> mdev , end_pad ) ) { mlx5_ib_dbg ( dev , ""scatter<S2SV_blank>end<S2SV_blank>padding<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; err = - EOPNOTSUPP ; goto err ; } else if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { MLX5_SET ( qpc , qpc , end_padding_mode , MLX5_WQ_END_PAD_MODE_ALIGN ) ; } else { qp -> flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING ; } } if ( inlen < 0 ) { err = - EINVAL ; goto err ; } if ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) { qp -> raw_packet_qp . sq . ubuffer . buf_addr = ucmd . sq_buf_addr ; raw_packet_qp_copy_info ( qp , & qp -> raw_packet_qp ) ; err = create_raw_packet_qp ( dev , qp , in , inlen , pd ) ; } else { err = mlx5_core_create_qp ( dev -> mdev , & base -> mqp , in , inlen ) ; } if ( err ) { mlx5_ib_dbg ( dev , ""create<S2SV_blank>qp<S2SV_blank>failed\\n"" ) ; goto err_create ; } kvfree ( in ) ; base -> container_mibqp = qp ; base -> mqp . event = mlx5_ib_qp_event ; get_cqs ( init_attr -> qp_type , init_attr -> send_cq , init_attr -> recv_cq , & send_cq , & recv_cq ) ; spin_lock_irqsave ( & dev -> reset_flow_resource_lock , flags ) ; mlx5_ib_lock_cqs ( send_cq , recv_cq ) ; list_add_tail ( & qp -> qps_list , & dev -> qp_list ) ; if ( send_cq ) list_add_tail ( & qp -> cq_send_list , & send_cq -> list_send_qp ) ; if ( recv_cq ) list_add_tail ( & qp -> cq_recv_list , & recv_cq -> list_recv_qp ) ; mlx5_ib_unlock_cqs ( send_cq , recv_cq ) ; spin_unlock_irqrestore ( & dev -> reset_flow_resource_lock , flags ) ; return 0 ; err_create : if ( qp -> create_type == MLX5_QP_USER ) destroy_qp_user ( dev , pd , qp , base ) ; else if ( qp -> create_type == MLX5_QP_KERNEL ) destroy_qp_kernel ( dev , qp ) ; err : kvfree ( in ) ; return err ; }",struct mlx5_ib_create_qp_resp resp = { }
370,"static void pack_inter_mode_mvs ( VP9_COMP * cpi , const MODE_INFO * mi , <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> const nmv_context * nmvc = & cm -> fc . nmvc ; <S2SV_EndBug> const MACROBLOCK * const x = & cpi -> mb ; const MACROBLOCKD * const xd = & x -> e_mbd ; const struct segmentation * const seg = & cm -> seg ; const MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_StartBug> const MB_PREDICTION_MODE mode = mbmi -> mode ; <S2SV_EndBug> const int segment_id = mbmi -> segment_id ; const BLOCK_SIZE bsize = mbmi -> sb_type ; const int allow_hp = cm -> allow_high_precision_mv ; const int is_inter = is_inter_block ( mbmi ) ; const int is_compound = has_second_ref ( mbmi ) ; int skip , ref ; if ( seg -> update_map ) { if ( seg -> temporal_update ) { const int pred_flag = mbmi -> seg_id_predicted ; <S2SV_StartBug> vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , pred_flag , pred_prob ) ; <S2SV_EndBug> if ( ! pred_flag ) write_segment_id ( w , seg , segment_id ) ; } else { write_segment_id ( w , seg , segment_id ) ; } } <S2SV_StartBug> skip = write_skip ( cpi , segment_id , mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , is_inter , vp9_get_intra_inter_prob ( cm , xd ) ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT && ! ( is_inter && <S2SV_StartBug> ( skip || vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> } if ( ! is_inter ) { if ( bsize >= BLOCK_8X8 ) { <S2SV_StartBug> write_intra_mode ( w , mode , cm -> fc . y_mode_prob [ size_group_lookup [ bsize ] ] ) ; <S2SV_EndBug> } else { int idx , idy ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { <S2SV_StartBug> const MB_PREDICTION_MODE b_mode = mi -> bmi [ idy * 2 + idx ] . as_mode ; <S2SV_EndBug> <S2SV_StartBug> write_intra_mode ( w , b_mode , cm -> fc . y_mode_prob [ 0 ] ) ; <S2SV_EndBug> } } } <S2SV_StartBug> write_intra_mode ( w , mbmi -> uv_mode , cm -> fc . uv_mode_prob [ mode ] ) ; <S2SV_EndBug> } else { <S2SV_StartBug> const int mode_ctx = mbmi -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * const inter_probs = cm -> fc . inter_mode_probs [ mode_ctx ] ; <S2SV_EndBug> <S2SV_StartBug> write_ref_frames ( cpi , w ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> if ( bsize >= BLOCK_8X8 ) { write_inter_mode ( w , mode , inter_probs ) ; <S2SV_StartBug> ++ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> } } if ( cm -> interp_filter == SWITCHABLE ) { const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ; vp9_write_token ( w , vp9_switchable_interp_tree , <S2SV_StartBug> cm -> fc . switchable_interp_prob [ ctx ] , <S2SV_EndBug> <S2SV_StartBug> & switchable_interp_encodings [ mbmi -> interp_filter ] ) ; <S2SV_EndBug> } else { assert ( mbmi -> interp_filter == cm -> interp_filter ) ; } if ( bsize < BLOCK_8X8 ) { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int j = idy * 2 + idx ; <S2SV_StartBug> const MB_PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; <S2SV_EndBug> <S2SV_StartBug> write_inter_mode ( w , b_mode , inter_probs ) ; <S2SV_EndBug> ++ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ; if ( b_mode == NEWMV ) { for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) vp9_encode_mv ( cpi , w , & mi -> bmi [ j ] . as_mv [ ref ] . as_mv , <S2SV_StartBug> & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , <S2SV_EndBug> nmvc , allow_hp ) ; } } } } else { if ( mode == NEWMV ) { for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) vp9_encode_mv ( cpi , w , & mbmi -> mv [ ref ] . as_mv , <S2SV_StartBug> & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc , <S2SV_EndBug> allow_hp ) ; } } } }","* mi , vpx_writer <S2SV_ModEnd> * w ) <S2SV_ModStart> cm -> fc -> nmvc ; const MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; const <S2SV_ModStart> mbmi ; const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const PREDICTION_MODE <S2SV_ModEnd> mode = mbmi <S2SV_ModStart> -> seg_id_predicted ; vpx_prob <S2SV_ModEnd> pred_prob = vp9_get_pred_prob_seg_id <S2SV_ModStart> xd ) ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> = write_skip ( cm , xd <S2SV_ModEnd> , segment_id , <S2SV_ModStart> if ( ! segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> SEG_LVL_REF_FRAME ) ) vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> ( is_inter && skip <S2SV_ModEnd> ) ) { <S2SV_ModStart> { write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w ) <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> y_mode_prob [ size_group_lookup <S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> b_mode = mi <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> y_mode_prob [ 0 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> uv_mode_prob [ mode <S2SV_ModStart> int mode_ctx = mbmi_ext <S2SV_ModEnd> -> mode_context [ <S2SV_ModStart> ] ; const vpx_prob <S2SV_ModEnd> * const inter_probs <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> inter_mode_probs [ mode_ctx <S2SV_ModStart> ; write_ref_frames ( cm , xd <S2SV_ModEnd> , w ) <S2SV_ModStart> if ( ! segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> inter_probs ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> switchable_interp_prob [ ctx <S2SV_ModStart> interp_filter ] ) ; ++ cpi -> interp_filter_selected [ 0 ] [ mbmi -> interp_filter ] <S2SV_ModStart> idx ; const PREDICTION_MODE <S2SV_ModEnd> b_mode = mi <S2SV_ModStart> , inter_probs ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> as_mv , & mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> as_mv , & mbmi_ext <S2SV_ModEnd> -> ref_mvs ["
371,"static int skcipher_accept_parent ( void * private , struct sock * sk ) { struct skcipher_ctx * ctx ; struct alg_sock * ask = alg_sk ( sk ) ; <S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> GFP_KERNEL ) ; if ( ! ctx -> iv ) { sock_kfree_s ( sk , ctx , len ) ; return - ENOMEM ; } <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug> skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ; sk -> sk_destruct = skcipher_sock_destruct ; return 0 ; }","sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback"
372,"static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ; <S2SV_StartBug> while ( ( c != '\\n' ) && ( c != '\\0' ) ) <S2SV_EndBug> { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ; <S2SV_StartBug> ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , <S2SV_EndBug> & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , <S2SV_StartBug> & white_point [ 0 ] , & white_point [ 1 ] ) ; <S2SV_EndBug> image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ; <S2SV_StartBug> break ; <S2SV_EndBug> } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'Y' : case 'y' : { char target [ ] = ""Y"" ; if ( strcmp ( keyword , target ) == 0 ) { int height , width ; <S2SV_StartBug> ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; <S2SV_EndBug> image -> columns = ( size_t ) width ; <S2SV_StartBug> image -> rows = ( size_t ) height ; <S2SV_EndBug> break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace , exception ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace , exception ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( image , 0 , q ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","!= '\\0' ) && ( c != EOF ) <S2SV_ModStart> 2 ] ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> 1 ] ) == 8 ) { <S2SV_ModEnd> image -> chromaticity <S2SV_ModStart> 1 ] ; } <S2SV_ModStart> , width ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> & width ) == 2 ) { <S2SV_ModEnd> image -> columns <S2SV_ModStart> ) height ; }"
373,"static int msg_cache_check ( const char * id , struct BodyCache * bcache , void * data ) { struct Context * ctx = ( struct Context * ) data ; if ( ! ctx ) return - 1 ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; if ( ! pop_data ) return - 1 ; # ifdef USE_HCACHE if ( strcmp ( HC_FNAME ""."" HC_FEXT , id ) == 0 ) return 0 ; # endif for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> data && ( mutt_str_strcmp ( ctx -> hdrs [ i ] -> data , id ) == 0 ) ) return 0 ; } <S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> }","( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; }"
374,"uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\n"" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\n"" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file"" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid"" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>@<S2SV_blank>%"" PRIu64 ""<S2SV_blank>has<S2SV_blank>%"" PRIu16 ""<S2SV_blank>records\\n"" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%"" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d"" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node"" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf"" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(%"" PRIu64 "")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%"" PRIu8 "")"" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }",uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off
375,"static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; register Quantum * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , "".PAL"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , "".pal"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info , exception ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , ""AH"" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( image , depth , BImgBuff , i , exception ) ; } ( void ) SyncImage ( image , exception ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , exception ) != MagickFalse ) ) { if ( GetCutColors ( image , exception ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( image , q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( image , QuantumRange , q ) ; SetPixelGreen ( image , QuantumRange , q ) ; SetPixelBlue ( image , QuantumRange , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",", tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;"
376,"<S2SV_StartBug> NOEXPORT char * parse_global_option ( CMD cmd , char * opt , char * arg ) { <S2SV_EndBug> void * tmp ; if ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE , ""<S2SV_blank>"" ) ; s_log ( LOG_NOTICE , ""Global<S2SV_blank>options:"" ) ; } # ifdef HAVE_CHROOT switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . chroot_dir = NULL ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : <S2SV_StartBug> tmp = global_options . chroot_dir ; <S2SV_EndBug> global_options . chroot_dir = NULL ; str_free ( tmp ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""chroot"" ) ) break ; <S2SV_StartBug> new_global_options . chroot_dir = str_dup ( arg ) ; <S2SV_EndBug> return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>chroot<S2SV_blank>stunnel<S2SV_blank>process"" , ""chroot"" ) ; break ; } # endif # ifndef OPENSSL_NO_COMP switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . compression = COMP_NONE ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""compression"" ) ) break ; # if OPENSSL_VERSION_NUMBER < 0x10100000L if ( OpenSSL_version_num ( ) < 0x00908051L ) return ""Compression<S2SV_blank>unsupported<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>memory<S2SV_blank>leak"" ; # endif if ( ! strcasecmp ( arg , ""deflate"" ) ) <S2SV_StartBug> new_global_options . compression = COMP_DEFLATE ; <S2SV_EndBug> else if ( ! strcasecmp ( arg , ""zlib"" ) ) <S2SV_StartBug> new_global_options . compression = COMP_ZLIB ; <S2SV_EndBug> else return ""Specified<S2SV_blank>compression<S2SV_blank>type<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>compression<S2SV_blank>type"" , ""compression"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : # ifdef EGD_SOCKET <S2SV_StartBug> new_global_options . egd_sock = EGD_SOCKET ; <S2SV_EndBug> # else <S2SV_StartBug> new_global_options . egd_sock = NULL ; <S2SV_EndBug> # endif break ; case CMD_SET_COPY : break ; case CMD_FREE : <S2SV_StartBug> tmp = global_options . egd_sock ; <S2SV_EndBug> global_options . egd_sock = NULL ; str_free ( tmp ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""EGD"" ) ) break ; <S2SV_StartBug> new_global_options . egd_sock = str_dup ( arg ) ; <S2SV_EndBug> return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # ifdef EGD_SOCKET s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""EGD"" , EGD_SOCKET ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>path<S2SV_blank>to<S2SV_blank>Entropy<S2SV_blank>Gathering<S2SV_blank>Daemon<S2SV_blank>socket"" , ""EGD"" ) ; break ; } # ifndef OPENSSL_NO_ENGINE switch ( cmd ) { case CMD_SET_DEFAULTS : engine_reset_list ( ) ; break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engine"" ) ) break ; if ( ! strcasecmp ( arg , ""auto"" ) ) return engine_auto ( ) ; else return engine_open ( arg ) ; case CMD_INITIALIZE : engine_init ( ) ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>auto|engine_id"" , ""engine"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engineCtrl"" ) ) break ; { char * tmp_str = strchr ( arg , ':' ) ; if ( tmp_str ) * tmp_str ++ = '\\0' ; return engine_ctrl ( arg , tmp_str ) ; } case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>cmd[:arg]"" , ""engineCtrl"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""engineDefault"" ) ) break ; return engine_default ( arg ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>TASK_LIST"" , ""engineDefault"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : # ifdef USE_FIPS <S2SV_StartBug> new_global_options . option . fips = 0 ; <S2SV_EndBug> # endif break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""fips"" ) ) <S2SV_StartBug> break ; <S2SV_EndBug> # ifdef USE_FIPS <S2SV_StartBug> if ( ! strcasecmp ( arg , ""yes"" ) ) <S2SV_EndBug> new_global_options . option . fips = 1 ; <S2SV_StartBug> else if ( ! strcasecmp ( arg , ""no"" ) ) <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . fips = 0 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; <S2SV_StartBug> # else <S2SV_EndBug> if ( strcasecmp ( arg , ""no"" ) ) return ""FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ; # endif return NULL ; case CMD_INITIALIZE : break ; <S2SV_StartBug> case CMD_PRINT_DEFAULTS : <S2SV_EndBug> break ; case CMD_PRINT_HELP : # ifdef USE_FIPS <S2SV_StartBug> s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>FIPS<S2SV_blank>140-2<S2SV_blank>mode"" , <S2SV_EndBug> ""fips"" ) ; # endif break ; } # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . option . foreground = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 0 ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""foreground"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { <S2SV_StartBug> new_global_options . option . foreground = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 1 ; <S2SV_EndBug> } else if ( ! strcasecmp ( arg , ""quiet"" ) ) { <S2SV_StartBug> new_global_options . option . foreground = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 0 ; <S2SV_EndBug> } else if ( ! strcasecmp ( arg , ""no"" ) ) { <S2SV_StartBug> new_global_options . option . foreground = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 0 ; <S2SV_EndBug> } else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\',<S2SV_blank>\'quiet\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|quiet|no<S2SV_blank>foreground<S2SV_blank>mode<S2SV_blank>(don\'t<S2SV_blank>fork,<S2SV_blank>log<S2SV_blank>to<S2SV_blank>stderr)"" , ""foreground"" ) ; break ; } # endif # ifdef ICON_IMAGE switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . icon [ ICON_ACTIVE ] = load_icon_default ( ICON_ACTIVE ) ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""iconActive"" ) ) break ; <S2SV_StartBug> if ( ! ( new_global_options . icon [ ICON_ACTIVE ] = load_icon_file ( arg ) ) ) <S2SV_EndBug> return ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>icon"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>icon<S2SV_blank>when<S2SV_blank>connections<S2SV_blank>are<S2SV_blank>established"" , ""iconActive"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . icon [ ICON_ERROR ] = load_icon_default ( ICON_ERROR ) ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""iconError"" ) ) break ; <S2SV_StartBug> if ( ! ( new_global_options . icon [ ICON_ERROR ] = load_icon_file ( arg ) ) ) <S2SV_EndBug> return ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>icon"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>icon<S2SV_blank>for<S2SV_blank>invalid<S2SV_blank>configuration<S2SV_blank>file"" , ""iconError"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . icon [ ICON_IDLE ] = load_icon_default ( ICON_IDLE ) ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""iconIdle"" ) ) break ; <S2SV_StartBug> if ( ! ( new_global_options . icon [ ICON_IDLE ] = load_icon_file ( arg ) ) ) <S2SV_EndBug> return ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>icon"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>icon<S2SV_blank>when<S2SV_blank>no<S2SV_blank>connections<S2SV_blank>were<S2SV_blank>established"" , ""iconIdle"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . log_file_mode = FILE_MODE_APPEND ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""log"" ) ) break ; if ( ! strcasecmp ( arg , ""append"" ) ) <S2SV_StartBug> new_global_options . log_file_mode = FILE_MODE_APPEND ; <S2SV_EndBug> else if ( ! strcasecmp ( arg , ""overwrite"" ) ) <S2SV_StartBug> new_global_options . log_file_mode = FILE_MODE_OVERWRITE ; <S2SV_EndBug> else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'append\'<S2SV_blank>or<S2SV_blank>\'overwrite\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>append|overwrite<S2SV_blank>log<S2SV_blank>file"" , ""log"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . output_file = NULL ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : <S2SV_StartBug> tmp = global_options . output_file ; <S2SV_EndBug> global_options . output_file = NULL ; str_free ( tmp ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""output"" ) ) break ; <S2SV_StartBug> new_global_options . output_file = str_dup ( arg ) ; <S2SV_EndBug> return NULL ; case CMD_INITIALIZE : # ifndef USE_WIN32 <S2SV_StartBug> if ( ! new_global_options . option . foreground && <S2SV_EndBug> <S2SV_StartBug> new_global_options . output_file && <S2SV_EndBug> new_global_options . output_file [ 0 ] != '/' ) return ""Log<S2SV_blank>file<S2SV_blank>must<S2SV_blank>include<S2SV_blank>full<S2SV_blank>path<S2SV_blank>name"" ; # endif break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>file<S2SV_blank>to<S2SV_blank>append<S2SV_blank>log<S2SV_blank>messages"" , ""output"" ) ; break ; } # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . pidfile = NULL ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : <S2SV_StartBug> tmp = global_options . pidfile ; <S2SV_EndBug> global_options . pidfile = NULL ; str_free ( tmp ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""pid"" ) ) break ; if ( arg [ 0 ] ) <S2SV_StartBug> new_global_options . pidfile = str_dup ( arg ) ; <S2SV_EndBug> else <S2SV_StartBug> new_global_options . pidfile = NULL ; <S2SV_EndBug> return NULL ; case CMD_INITIALIZE : <S2SV_StartBug> if ( ! new_global_options . option . foreground && <S2SV_EndBug> <S2SV_StartBug> new_global_options . pidfile && <S2SV_EndBug> new_global_options . pidfile [ 0 ] != '/' ) return ""Pid<S2SV_blank>file<S2SV_blank>must<S2SV_blank>include<S2SV_blank>full<S2SV_blank>path<S2SV_blank>name"" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>pid<S2SV_blank>file"" , ""pid"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . random_bytes = RANDOM_BYTES ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""RNDbytes"" ) ) break ; { char * tmp_str ; <S2SV_StartBug> new_global_options . random_bytes = ( long ) strtol ( arg , & tmp_str , 10 ) ; <S2SV_EndBug> if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>files"" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""RNDbytes"" , RANDOM_BYTES ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>files"" , ""RNDbytes"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # ifdef RANDOM_FILE <S2SV_StartBug> new_global_options . rand_file = str_dup ( RANDOM_FILE ) ; <S2SV_EndBug> # else <S2SV_StartBug> new_global_options . rand_file = NULL ; <S2SV_EndBug> # endif break ; case CMD_SET_COPY : break ; case CMD_FREE : <S2SV_StartBug> tmp = global_options . rand_file ; <S2SV_EndBug> global_options . rand_file = NULL ; str_free ( tmp ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""RNDfile"" ) ) break ; <S2SV_StartBug> new_global_options . rand_file = str_dup ( arg ) ; <S2SV_EndBug> return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # ifdef RANDOM_FILE s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""RNDfile"" , RANDOM_FILE ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>path<S2SV_blank>to<S2SV_blank>file<S2SV_blank>with<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>data"" , ""RNDfile"" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . option . rand_write = 1 ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""RNDoverwrite"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) <S2SV_StartBug> new_global_options . option . rand_write = 1 ; <S2SV_EndBug> else if ( ! strcasecmp ( arg , ""no"" ) ) <S2SV_StartBug> new_global_options . option . rand_write = 0 ; <S2SV_EndBug> else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes"" , ""RNDoverwrite"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>overwrite<S2SV_blank>seed<S2SV_blank>datafiles<S2SV_blank>with<S2SV_blank>new<S2SV_blank>random<S2SV_blank>data"" , ""RNDoverwrite"" ) ; break ; } # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . option . log_syslog = 1 ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""syslog"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) <S2SV_StartBug> new_global_options . option . log_syslog = 1 ; <S2SV_EndBug> else if ( ! strcasecmp ( arg , ""no"" ) ) <S2SV_StartBug> new_global_options . option . log_syslog = 0 ; <S2SV_EndBug> else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>logging<S2SV_blank>messages<S2SV_blank>to<S2SV_blank>syslog"" , ""syslog"" ) ; break ; } # endif # ifdef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : <S2SV_StartBug> new_global_options . option . taskbar = 1 ; <S2SV_EndBug> break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""taskbar"" ) ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) <S2SV_StartBug> new_global_options . option . taskbar = 1 ; <S2SV_EndBug> else if ( ! strcasecmp ( arg , ""no"" ) ) <S2SV_StartBug> new_global_options . option . taskbar = 0 ; <S2SV_EndBug> else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes"" , ""taskbar"" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>enable<S2SV_blank>the<S2SV_blank>taskbar<S2SV_blank>icon"" , ""taskbar"" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : <S2SV_StartBug> break ; <S2SV_EndBug> case CMD_SET_VALUE : return option_not_found ; case CMD_INITIALIZE : <S2SV_StartBug> if ( ssl_configure ( & new_global_options ) ) <S2SV_EndBug> return ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>TLS"" ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : break ; } return NULL ; }","( CMD cmd , GLOBAL_OPTIONS * options <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> chroot_dir = NULL <S2SV_ModStart> : tmp = options -> chroot_dir ; options -> <S2SV_ModEnd> chroot_dir = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> chroot_dir = str_dup <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> compression = COMP_NONE <S2SV_ModStart> ""deflate"" ) ) options -> <S2SV_ModEnd> compression = COMP_DEFLATE <S2SV_ModStart> ""zlib"" ) ) options -> <S2SV_ModEnd> compression = COMP_ZLIB <S2SV_ModStart> # ifdef EGD_SOCKET options -> <S2SV_ModEnd> egd_sock = EGD_SOCKET <S2SV_ModStart> ; # else options -> <S2SV_ModEnd> egd_sock = NULL <S2SV_ModStart> : tmp = options -> egd_sock ; options -> <S2SV_ModEnd> egd_sock = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> egd_sock = str_dup <S2SV_ModStart> # ifdef USE_FIPS options -> <S2SV_ModEnd> option . fips <S2SV_ModStart> . fips = FIPS_mode ( ) ? 1 : <S2SV_ModStart> ) break ; if ( ! strcasecmp ( arg , ""yes"" ) ) { <S2SV_ModStart> # ifdef USE_FIPS options -> <S2SV_ModEnd> option . fips <S2SV_ModStart> = 1 ; # else return ""FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ; # endif } else <S2SV_ModEnd> if ( ! <S2SV_ModStart> ""no"" ) ) { # ifdef USE_FIPS if ( FIPS_mode ( ) ) return ""Failed<S2SV_blank>to<S2SV_blank>override<S2SV_blank>system-wide<S2SV_blank>FIPS<S2SV_blank>mode"" ; options -> <S2SV_ModEnd> option . fips <S2SV_ModStart> = 0 ; # endif } else { <S2SV_ModEnd> return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; <S2SV_ModStart> return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; } <S2SV_ModEnd> return NULL ; <S2SV_ModStart> ; case CMD_PRINT_DEFAULTS <S2SV_ModEnd> : # ifdef <S2SV_ModStart> ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""fips"" , FIPS_mode ( ) ? ""yes"" : ""no"" ) ; # endif break ; case CMD_PRINT_HELP : # ifdef USE_FIPS s_log ( LOG_NOTICE , <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 0 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> ) ) { options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 1 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> ) ) { options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 1 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> ) ) { options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 0 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> icon [ ICON_ACTIVE <S2SV_ModStart> ( ! ( options -> <S2SV_ModEnd> icon [ ICON_ACTIVE <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> icon [ ICON_ERROR <S2SV_ModStart> ( ! ( options -> <S2SV_ModEnd> icon [ ICON_ERROR <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> icon [ ICON_IDLE <S2SV_ModStart> ( ! ( options -> <S2SV_ModEnd> icon [ ICON_IDLE <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> log_file_mode = FILE_MODE_APPEND <S2SV_ModStart> ""append"" ) ) options -> <S2SV_ModEnd> log_file_mode = FILE_MODE_APPEND <S2SV_ModStart> ""overwrite"" ) ) options -> <S2SV_ModEnd> log_file_mode = FILE_MODE_OVERWRITE <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> output_file = NULL <S2SV_ModStart> : tmp = options -> output_file ; options -> <S2SV_ModEnd> output_file = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> output_file = str_dup <S2SV_ModStart> if ( ! options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> . foreground && options -> output_file && options -> <S2SV_ModEnd> output_file [ 0 <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> pidfile = NULL <S2SV_ModStart> : tmp = options -> pidfile ; options -> <S2SV_ModEnd> pidfile = NULL <S2SV_ModStart> 0 ] ) options -> <S2SV_ModEnd> pidfile = str_dup <S2SV_ModStart> ) ; else options -> <S2SV_ModEnd> pidfile = NULL <S2SV_ModStart> if ( ! options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> . foreground && options -> pidfile && options -> <S2SV_ModEnd> pidfile [ 0 <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> random_bytes = RANDOM_BYTES <S2SV_ModStart> * tmp_str ; options -> <S2SV_ModEnd> random_bytes = ( <S2SV_ModStart> # ifdef RANDOM_FILE options -> <S2SV_ModEnd> rand_file = str_dup <S2SV_ModStart> ; # else options -> <S2SV_ModEnd> rand_file = NULL <S2SV_ModStart> : tmp = options -> rand_file ; options -> <S2SV_ModEnd> rand_file = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> rand_file = str_dup <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . rand_write <S2SV_ModStart> ""yes"" ) ) options -> <S2SV_ModEnd> option . rand_write <S2SV_ModStart> ""no"" ) ) options -> <S2SV_ModEnd> option . rand_write <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . log_syslog <S2SV_ModStart> ""yes"" ) ) options -> <S2SV_ModEnd> option . log_syslog <S2SV_ModStart> ""no"" ) ) options -> <S2SV_ModEnd> option . log_syslog <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . taskbar <S2SV_ModStart> ""yes"" ) ) options -> <S2SV_ModEnd> option . taskbar <S2SV_ModStart> ""no"" ) ) options -> <S2SV_ModEnd> option . taskbar <S2SV_ModStart> case CMD_FREE : memset ( options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_ModStart> ( ssl_configure ( options <S2SV_ModEnd> ) ) return"
377,"static char * lxclock_name ( const char * p , const char * n ) { int ret ; int len ; char * dest ; char * rundir ; <S2SV_StartBug> len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ; <S2SV_EndBug> rundir = get_rundir ( ) ; if ( ! rundir ) return NULL ; len += strlen ( rundir ) ; if ( ( dest = malloc ( len ) ) == NULL ) { free ( rundir ) ; return NULL ; } <S2SV_StartBug> ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ; <S2SV_EndBug> if ( ret < 0 || ret >= len ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = mkdir_p ( dest , 0755 ) ; if ( ret < 0 ) { <S2SV_StartBug> int l2 = 22 + strlen ( n ) + strlen ( p ) ; <S2SV_EndBug> if ( l2 > len ) { char * d ; d = realloc ( dest , l2 ) ; if ( ! d ) { free ( dest ) ; free ( rundir ) ; return NULL ; } len = l2 ; dest = d ; } ret = snprintf ( dest , len , ""/tmp/%d/lxc%s"" , geteuid ( ) , p ) ; if ( ret < 0 || ret >= len ) { free ( dest ) ; <S2SV_StartBug> free ( rundir ) ; <S2SV_EndBug> return NULL ; } ret = mkdir_p ( dest , 0755 ) ; if ( ret < 0 ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , ""/tmp/%d/lxc%s/.%s"" , geteuid ( ) , p , n ) ; } else ret = snprintf ( dest , len , ""%s/lock/lxc/%s/.%s"" , rundir , p , n ) ; free ( rundir ) ; if ( ret < 0 || ret >= len ) { free ( dest ) ; return NULL ; } return dest ; }","= strlen ( ""/lxc/lock/"" <S2SV_ModEnd> ) + strlen <S2SV_ModStart> , len , ""%s/lxc/lock/%s"" <S2SV_ModEnd> , rundir , <S2SV_ModStart> 0 ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ; free ( rundir <S2SV_ModEnd> ) ; if <S2SV_ModStart> dest ) ; <S2SV_ModEnd> return NULL ;"
378,"static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev , <S2SV_StartBug> void * data ) <S2SV_EndBug> { struct xcopy_dev_search_info * info = data ; unsigned char tmp_dev_wwn [ XCOPY_NAA_IEEE_REGEX_LEN ] ; int rc ; <S2SV_StartBug> if ( ! se_dev -> dev_attrib . emulate_3pc ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> memset ( & tmp_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ; target_xcopy_gen_naa_ieee ( se_dev , & tmp_dev_wwn [ 0 ] ) ; <S2SV_StartBug> rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> info -> found_dev = se_dev ; <S2SV_EndBug> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_StartBug> rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; <S2SV_EndBug> if ( rc != 0 ) { pr_err ( ""configfs_depend_item<S2SV_blank>attempt<S2SV_blank>failed:<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" , rc , se_dev ) ; return rc ; } pr_debug ( ""Called<S2SV_blank>configfs_depend_item<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , se_dev , & se_dev -> dev_group ) ; return 1 ; }","* se_dev , const unsigned char * dev_wwn ) { <S2SV_ModEnd> unsigned char tmp_dev_wwn <S2SV_ModStart> . emulate_3pc ) { pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> 0 ] , <S2SV_ModEnd> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN <S2SV_ModStart> != 0 ) { pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n"" <S2SV_ModStart> se_dev ) ; <S2SV_ModEnd> return 1 ;"
379,"static int acp_hw_init ( void * handle ) { int r , i ; uint64_t acp_base ; u32 val = 0 ; u32 count = 0 ; struct device * dev ; <S2SV_StartBug> struct i2s_platform_data * i2s_pdata ; <S2SV_EndBug> struct amdgpu_device * adev = ( struct amdgpu_device * ) handle ; const struct amdgpu_ip_block * ip_block = amdgpu_device_ip_get_ip_block ( adev , AMD_IP_BLOCK_TYPE_ACP ) ; if ( ! ip_block ) return - EINVAL ; r = amd_acp_hw_init ( adev -> acp . cgs_device , ip_block -> version -> major , ip_block -> version -> minor ) ; if ( r == - ENODEV ) { amdgpu_dpm_set_powergating_by_smu ( adev , AMD_IP_BLOCK_TYPE_ACP , true ) ; return 0 ; } else if ( r ) { return r ; } if ( adev -> rmmio_size == 0 || adev -> rmmio_size < 0x5289 ) return - EINVAL ; acp_base = adev -> rmmio_base ; adev -> acp . acp_genpd = kzalloc ( sizeof ( struct acp_pm_domain ) , GFP_KERNEL ) ; if ( adev -> acp . acp_genpd == NULL ) return - ENOMEM ; adev -> acp . acp_genpd -> gpd . name = ""ACP_AUDIO"" ; adev -> acp . acp_genpd -> gpd . power_off = acp_poweroff ; adev -> acp . acp_genpd -> gpd . power_on = acp_poweron ; adev -> acp . acp_genpd -> adev = adev ; pm_genpd_init ( & adev -> acp . acp_genpd -> gpd , NULL , false ) ; adev -> acp . acp_cell = kcalloc ( ACP_DEVS , sizeof ( struct mfd_cell ) , GFP_KERNEL ) ; if ( adev -> acp . acp_cell == NULL ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> adev -> acp . acp_res = kcalloc ( 5 , sizeof ( struct resource ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( adev -> acp . acp_res == NULL ) { <S2SV_StartBug> kfree ( adev -> acp . acp_cell ) ; <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> } <S2SV_EndBug> i2s_pdata = kcalloc ( 3 , sizeof ( struct i2s_platform_data ) , GFP_KERNEL ) ; if ( i2s_pdata == NULL ) { <S2SV_StartBug> kfree ( adev -> acp . acp_res ) ; <S2SV_EndBug> kfree ( adev -> acp . acp_cell ) ; return - ENOMEM ; } switch ( adev -> asic_type ) { case CHIP_STONEY : i2s_pdata [ 0 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_16BIT_IDX_OVERRIDE ; break ; default : i2s_pdata [ 0 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET ; } i2s_pdata [ 0 ] . cap = DWC_I2S_PLAY ; i2s_pdata [ 0 ] . snd_rates = SNDRV_PCM_RATE_8000_96000 ; i2s_pdata [ 0 ] . i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET ; i2s_pdata [ 0 ] . i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET ; switch ( adev -> asic_type ) { case CHIP_STONEY : i2s_pdata [ 1 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_COMP_PARAM1 | DW_I2S_QUIRK_16BIT_IDX_OVERRIDE ; break ; default : i2s_pdata [ 1 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_COMP_PARAM1 ; } i2s_pdata [ 1 ] . cap = DWC_I2S_RECORD ; i2s_pdata [ 1 ] . snd_rates = SNDRV_PCM_RATE_8000_96000 ; i2s_pdata [ 1 ] . i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET ; i2s_pdata [ 1 ] . i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET ; i2s_pdata [ 2 ] . quirks = DW_I2S_QUIRK_COMP_REG_OFFSET ; switch ( adev -> asic_type ) { case CHIP_STONEY : i2s_pdata [ 2 ] . quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE ; break ; default : break ; } i2s_pdata [ 2 ] . cap = DWC_I2S_PLAY | DWC_I2S_RECORD ; i2s_pdata [ 2 ] . snd_rates = SNDRV_PCM_RATE_8000_96000 ; i2s_pdata [ 2 ] . i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET ; i2s_pdata [ 2 ] . i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET ; adev -> acp . acp_res [ 0 ] . name = ""acp2x_dma"" ; adev -> acp . acp_res [ 0 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 0 ] . start = acp_base ; adev -> acp . acp_res [ 0 ] . end = acp_base + ACP_DMA_REGS_END ; adev -> acp . acp_res [ 1 ] . name = ""acp2x_dw_i2s_play"" ; adev -> acp . acp_res [ 1 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 1 ] . start = acp_base + ACP_I2S_PLAY_REGS_START ; adev -> acp . acp_res [ 1 ] . end = acp_base + ACP_I2S_PLAY_REGS_END ; adev -> acp . acp_res [ 2 ] . name = ""acp2x_dw_i2s_cap"" ; adev -> acp . acp_res [ 2 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 2 ] . start = acp_base + ACP_I2S_CAP_REGS_START ; adev -> acp . acp_res [ 2 ] . end = acp_base + ACP_I2S_CAP_REGS_END ; adev -> acp . acp_res [ 3 ] . name = ""acp2x_dw_bt_i2s_play_cap"" ; adev -> acp . acp_res [ 3 ] . flags = IORESOURCE_MEM ; adev -> acp . acp_res [ 3 ] . start = acp_base + ACP_BT_PLAY_REGS_START ; adev -> acp . acp_res [ 3 ] . end = acp_base + ACP_BT_PLAY_REGS_END ; adev -> acp . acp_res [ 4 ] . name = ""acp2x_dma_irq"" ; adev -> acp . acp_res [ 4 ] . flags = IORESOURCE_IRQ ; adev -> acp . acp_res [ 4 ] . start = amdgpu_irq_create_mapping ( adev , 162 ) ; adev -> acp . acp_res [ 4 ] . end = adev -> acp . acp_res [ 4 ] . start ; adev -> acp . acp_cell [ 0 ] . name = ""acp_audio_dma"" ; adev -> acp . acp_cell [ 0 ] . num_resources = 5 ; adev -> acp . acp_cell [ 0 ] . resources = & adev -> acp . acp_res [ 0 ] ; adev -> acp . acp_cell [ 0 ] . platform_data = & adev -> asic_type ; adev -> acp . acp_cell [ 0 ] . pdata_size = sizeof ( adev -> asic_type ) ; adev -> acp . acp_cell [ 1 ] . name = ""designware-i2s"" ; adev -> acp . acp_cell [ 1 ] . num_resources = 1 ; adev -> acp . acp_cell [ 1 ] . resources = & adev -> acp . acp_res [ 1 ] ; adev -> acp . acp_cell [ 1 ] . platform_data = & i2s_pdata [ 0 ] ; adev -> acp . acp_cell [ 1 ] . pdata_size = sizeof ( struct i2s_platform_data ) ; adev -> acp . acp_cell [ 2 ] . name = ""designware-i2s"" ; adev -> acp . acp_cell [ 2 ] . num_resources = 1 ; adev -> acp . acp_cell [ 2 ] . resources = & adev -> acp . acp_res [ 2 ] ; adev -> acp . acp_cell [ 2 ] . platform_data = & i2s_pdata [ 1 ] ; adev -> acp . acp_cell [ 2 ] . pdata_size = sizeof ( struct i2s_platform_data ) ; adev -> acp . acp_cell [ 3 ] . name = ""designware-i2s"" ; adev -> acp . acp_cell [ 3 ] . num_resources = 1 ; adev -> acp . acp_cell [ 3 ] . resources = & adev -> acp . acp_res [ 3 ] ; adev -> acp . acp_cell [ 3 ] . platform_data = & i2s_pdata [ 2 ] ; adev -> acp . acp_cell [ 3 ] . pdata_size = sizeof ( struct i2s_platform_data ) ; r = mfd_add_hotplug_devices ( adev -> acp . parent , adev -> acp . acp_cell , ACP_DEVS ) ; if ( r ) <S2SV_StartBug> return r ; <S2SV_EndBug> for ( i = 0 ; i < ACP_DEVS ; i ++ ) { dev = get_mfd_cell_dev ( adev -> acp . acp_cell [ i ] . name , i ) ; r = pm_genpd_add_device ( & adev -> acp . acp_genpd -> gpd , dev ) ; if ( r ) { dev_err ( dev , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>dev<S2SV_blank>to<S2SV_blank>genpd\\n"" ) ; <S2SV_StartBug> return r ; <S2SV_EndBug> } } val = cgs_read_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET ) ; val |= ACP_SOFT_RESET__SoftResetAud_MASK ; cgs_write_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET , val ) ; count = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE ; while ( true ) { val = cgs_read_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET ) ; if ( ACP_SOFT_RESET__SoftResetAudDone_MASK == ( val & ACP_SOFT_RESET__SoftResetAudDone_MASK ) ) break ; if ( -- count == 0 ) { dev_err ( & adev -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } udelay ( 100 ) ; } val = cgs_read_register ( adev -> acp . cgs_device , mmACP_CONTROL ) ; val = val | ACP_CONTROL__ClkEn_MASK ; cgs_write_register ( adev -> acp . cgs_device , mmACP_CONTROL , val ) ; count = ACP_CLOCK_EN_TIME_OUT_VALUE ; while ( true ) { val = cgs_read_register ( adev -> acp . cgs_device , mmACP_STATUS ) ; if ( val & ( u32 ) 0x1 ) break ; if ( -- count == 0 ) { dev_err ( & adev -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } udelay ( 100 ) ; } val = cgs_read_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET ) ; val &= ~ ACP_SOFT_RESET__SoftResetAud_MASK ; cgs_write_register ( adev -> acp . cgs_device , mmACP_SOFT_RESET , val ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug>","i2s_platform_data * i2s_pdata = NULL <S2SV_ModStart> == NULL ) { r = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto failure ; } <S2SV_ModStart> NULL ) { r = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto failure ; <S2SV_ModStart> NULL ) { r = - ENOMEM ; goto failure <S2SV_ModEnd> ; } switch <S2SV_ModStart> ( r ) goto failure <S2SV_ModEnd> ; for ( <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>dev<S2SV_blank>to<S2SV_blank>genpd\\n"" ) ; goto failure <S2SV_ModEnd> ; } } <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> ; } udelay <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n"" ) ; r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> ; } udelay <S2SV_ModStart> return 0 ; failure : kfree ( i2s_pdata ) ; kfree ( adev -> acp . acp_res ) ; kfree ( adev -> acp . acp_cell ) ; kfree ( adev -> acp . acp_genpd ) ; return r ;"
380,"static void * zend_mm_realloc_heap ( zend_mm_heap * heap , void * ptr , size_t size , size_t copy_size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC ) { size_t page_offset ; size_t old_size ; size_t new_size ; void * ret ; # if ZEND_DEBUG size_t real_size ; zend_mm_debug_info * dbg ; # endif page_offset = ZEND_MM_ALIGNED_OFFSET ( ptr , ZEND_MM_CHUNK_SIZE ) ; if ( UNEXPECTED ( page_offset == 0 ) ) { if ( UNEXPECTED ( ptr == NULL ) ) { return zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; } old_size = zend_mm_get_huge_block_size ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_DEBUG real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif if ( size > ZEND_MM_MAX_LARGE_SIZE ) { # if ZEND_DEBUG size = real_size ; # endif # ifdef ZEND_WIN32 new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , MAX ( REAL_PAGE_SIZE , ZEND_MM_CHUNK_SIZE ) ) ; # else new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , REAL_PAGE_SIZE ) ; # endif if ( new_size == old_size ) { # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } else if ( new_size < old_size ) { if ( zend_mm_chunk_truncate ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size -= old_size - new_size ; # endif # if ZEND_MM_STAT heap -> size -= old_size - new_size ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } } else { # if ZEND_MM_LIMIT if ( UNEXPECTED ( heap -> real_size + ( new_size - old_size ) > heap -> limit ) ) { if ( zend_mm_gc ( heap ) && heap -> real_size + ( new_size - old_size ) <= heap -> limit ) { } else if ( heap -> overflow == 0 ) { # if ZEND_DEBUG zend_mm_safe_error ( heap , ""Allowed<S2SV_blank>memory<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>exhausted<S2SV_blank>at<S2SV_blank>%s:%d<S2SV_blank>(tried<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes)"" , heap -> limit , __zend_filename , __zend_lineno , size ) ; # else zend_mm_safe_error ( heap , ""Allowed<S2SV_blank>memory<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>exhausted<S2SV_blank>(tried<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%zu<S2SV_blank>bytes)"" , heap -> limit , size ) ; # endif return NULL ; } } # endif if ( zend_mm_chunk_extend ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size += new_size - old_size ; # endif # if ZEND_MM_STAT heap -> real_peak = MAX ( heap -> real_peak , heap -> real_size ) ; heap -> size += new_size - old_size ; heap -> peak = MAX ( heap -> peak , heap -> size ) ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } } } } else { zend_mm_chunk * chunk = ( zend_mm_chunk * ) ZEND_MM_ALIGNED_BASE ( ptr , ZEND_MM_CHUNK_SIZE ) ; int page_num = ( int ) ( page_offset / ZEND_MM_PAGE_SIZE ) ; zend_mm_page_info info = chunk -> map [ page_num ] ; # if ZEND_DEBUG size_t real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif ZEND_MM_CHECK ( chunk -> heap == heap , ""zend_mm_heap<S2SV_blank>corrupted"" ) ; if ( info & ZEND_MM_IS_SRUN ) { <S2SV_StartBug> int old_bin_num , bin_num ; <S2SV_EndBug> old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ; old_size = bin_data_size [ old_bin_num ] ; <S2SV_StartBug> bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; <S2SV_EndBug> if ( old_bin_num == bin_num ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif <S2SV_StartBug> return ptr ; <S2SV_EndBug> } } else { ZEND_MM_CHECK ( ZEND_MM_ALIGNED_OFFSET ( page_offset , ZEND_MM_PAGE_SIZE ) == 0 , ""zend_mm_heap<S2SV_blank>corrupted"" ) ; old_size = ZEND_MM_LRUN_PAGES ( info ) * ZEND_MM_PAGE_SIZE ; if ( size > ZEND_MM_MAX_SMALL_SIZE && size <= ZEND_MM_MAX_LARGE_SIZE ) { new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , ZEND_MM_PAGE_SIZE ) ; if ( new_size == old_size ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else if ( new_size < old_size ) { int new_pages_count = ( int ) ( new_size / ZEND_MM_PAGE_SIZE ) ; int rest_pages_count = ( int ) ( ( old_size - new_size ) / ZEND_MM_PAGE_SIZE ) ; # if ZEND_MM_STAT heap -> size -= rest_pages_count * ZEND_MM_PAGE_SIZE ; # endif chunk -> map [ page_num ] = ZEND_MM_LRUN ( new_pages_count ) ; chunk -> free_pages += rest_pages_count ; zend_mm_bitset_reset_range ( chunk -> free_map , page_num + new_pages_count , rest_pages_count ) ; # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else { int new_pages_count = ( int ) ( new_size / ZEND_MM_PAGE_SIZE ) ; int old_pages_count = ( int ) ( old_size / ZEND_MM_PAGE_SIZE ) ; if ( page_num + new_pages_count <= ZEND_MM_PAGES && zend_mm_bitset_is_free_range ( chunk -> free_map , page_num + old_pages_count , new_pages_count - old_pages_count ) ) { # if ZEND_MM_STAT do { size_t size = heap -> size + ( new_size - old_size ) ; size_t peak = MAX ( heap -> peak , size ) ; heap -> size = size ; heap -> peak = peak ; } while ( 0 ) ; # endif chunk -> free_pages -= new_pages_count - old_pages_count ; zend_mm_bitset_set_range ( chunk -> free_map , page_num + old_pages_count , new_pages_count - old_pages_count ) ; chunk -> map [ page_num ] = ZEND_MM_LRUN ( new_pages_count ) ; # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap , ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } } } } # if ZEND_DEBUG size = real_size ; # endif } # if ZEND_MM_STAT do { size_t orig_peak = heap -> peak ; size_t orig_real_peak = heap -> real_peak ; # endif ret = zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; memcpy ( ret , ptr , MIN ( old_size , copy_size ) ) ; zend_mm_free_heap ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_MM_STAT heap -> peak = MAX ( orig_peak , heap -> size ) ; heap -> real_peak = MAX ( orig_real_peak , heap -> real_size ) ; } while ( 0 ) ; # endif return ret ; }",{ int old_bin_num <S2SV_ModEnd> = ZEND_MM_SRUN_BIN_NUM ( <S2SV_ModStart> old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> return ptr ; }
381,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4"
382,"static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , ""device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , ""new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , ""updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }","""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; * pp = p -> next ;"
383,"asmlinkage long sys_oabi_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> struct flock64 kernel ; mm_segment_t fs = USER_DS ; unsigned long local_arg = arg ; int ret ; switch ( cmd ) { case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> sizeof ( user ) ) ) return - EFAULT ; kernel . l_type = user . l_type ; kernel . l_whence = user . l_whence ; kernel . l_start = user . l_start ; kernel . l_len = user . l_len ; kernel . l_pid = user . l_pid ; local_arg = ( unsigned long ) & kernel ; fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; } <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> switch ( cmd ) { case F_GETLK64 : if ( ! ret ) { user . l_type = kernel . l_type ; user . l_whence = kernel . l_whence ; user . l_start = kernel . l_start ; user . l_len = kernel . l_len ; user . l_pid = kernel . l_pid ; if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ; } case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }","arg ) { <S2SV_ModEnd> switch ( cmd <S2SV_ModStart> case F_SETLKW64 : return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> sys_fcntl64 ( fd <S2SV_ModStart> , cmd , arg <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
384,"static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len , i ; int insn_processed = 0 ; bool do_print_state = false ; env -> prev_linfo = NULL ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; state -> curframe = 0 ; <S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! state -> frame [ 0 ] ) { kfree ( state ) ; return - ENOMEM ; } env -> cur_state = state ; init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( env -> insn_idx >= insn_cnt ) { verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , env -> insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ env -> insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , env -> insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> else verbose ( env , ""%d:<S2SV_blank>safe\\n"" , env -> insn_idx ) ; } goto process_bpf_exit ; } if ( signal_pending ( current ) ) return - EAGAIN ; if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , env -> insn_idx ) ; else <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; do_print_state = false ; } if ( env -> log . level ) { const struct bpf_insn_cbs cbs = { . cb_print = verbose , . private_data = env , } ; verbose_linfo ( env , env -> insn_idx , "";<S2SV_blank>"" ) ; verbose ( env , ""%d:<S2SV_blank>"" , env -> insn_idx ) ; print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; } if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , env -> prev_insn_idx ) ; if ( err ) return err ; } regs = cur_regs ( env ) ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg , false ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , env -> insn_idx , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg , false ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { verbose ( env , ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_ctx_reg ( env , insn -> dst_reg ) ) { verbose ( env , ""BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , insn -> dst_reg , reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; return - EACCES ; } err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 , false ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || ( insn -> src_reg != BPF_REG_0 && insn -> src_reg != BPF_PSEUDO_CALL ) || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == BPF_PSEUDO_CALL ) err = check_func_call ( env , insn , & env -> insn_idx ) ; else err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } env -> insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( state -> curframe ) { env -> prev_insn_idx = env -> insn_idx ; err = prepare_func_exit ( env , & env -> insn_idx ) ; if ( err ) return err ; do_print_state = true ; continue ; } err = check_reference_leak ( env ) ; if ( err ) return err ; err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & env -> prev_insn_idx , & env -> insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; } else { verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } env -> insn_idx ++ ; } verbose ( env , ""processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>"" , insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { u32 depth = env -> subprog_info [ i ] . stack_depth ; verbose ( env , ""%d"" , depth ) ; if ( i + 1 < env -> subprog_cnt ) verbose ( env , ""+"" ) ; } verbose ( env , ""\\n"" ) ; env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; return 0 ; }","; state -> speculative = false ; state -> <S2SV_ModStart> ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n"" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" <S2SV_ModStart> ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:"" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """""
385,"void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , ""xmlParsePEReference:<S2SV_blank>no<S2SV_blank>name\\n"" ) ; return ; } if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_ENTITYREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name ) ; } else { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n"" , name , NULL ) ; } else if ( ctxt -> input -> free != deallocblankswrapper ) { input = xmlNewBlanksWrapperInputStream ( ctxt , entity ) ; if ( xmlPushInput ( ctxt , input ) < 0 ) return ; } else { <S2SV_StartBug> input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_EndBug> if ( xmlPushInput ( ctxt , input ) < 0 ) return ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; if ( ctxt -> errNo == XML_ERR_UNSUPPORTED_ENCODING ) { xmlHaltParser ( ctxt ) ; return ; } } } } ctxt -> hasPErefs = 1 ; }",} else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;
386,"<S2SV_StartBug> static void dist_block ( int plane , int block , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> struct rdcost_block_args * args ) { <S2SV_EndBug> <S2SV_StartBug> const int ss_txfrm_size = tx_size << 1 ; <S2SV_EndBug> MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblock_plane * const p = & x -> plane [ plane ] ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; int64_t this_sse ; int shift = tx_size == TX_32X32 ? 0 : 2 ; <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , <S2SV_EndBug> <S2SV_StartBug> & this_sse ) >> shift ; <S2SV_EndBug> args -> sse = this_sse >> shift ; if ( x -> skip_encode && ! is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ) { int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * <S2SV_StartBug> ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ; <S2SV_EndBug> args -> dist += ( p >> 4 ) ; <S2SV_StartBug> args -> sse += p ; <S2SV_EndBug> } }","void dist_block ( MACROBLOCK * x , <S2SV_ModStart> TX_SIZE tx_size , int64_t * out_dist , int64_t * out_sse <S2SV_ModEnd> ) { const <S2SV_ModStart> tx_size << 1 <S2SV_ModEnd> ; MACROBLOCKD * <S2SV_ModStart> : 2 ; tran_low_t <S2SV_ModEnd> * const coeff <S2SV_ModStart> block ) ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> block ) ; # if CONFIG_VP9_HIGHBITDEPTH const int bd = ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd : 8 ; * out_dist = vp9_highbd_block_error <S2SV_ModEnd> ( coeff , <S2SV_ModStart> , & this_sse , bd ) >> shift ; # else * out_dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ; # endif * out_sse <S2SV_ModEnd> = this_sse >> <S2SV_ModStart> ) ) >> # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> shift + 2 + ( bd - 8 ) * 2 ) ; # else ( shift + 2 ) ; # endif * out_dist <S2SV_ModEnd> += ( p <S2SV_ModStart> 4 ) ; * out_sse <S2SV_ModEnd> += p ;"
387,"int oidc_handle_redirect_uri_request ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { if ( oidc_proto_is_redirect_authorization_response ( r , c ) ) { return oidc_handle_redirect_authorization_response ( r , c , session ) ; } else if ( oidc_proto_is_post_authorization_response ( r , c ) ) { return oidc_handle_post_authorization_response ( r , c , session ) ; } else if ( oidc_is_discovery_response ( r , c ) ) { return oidc_handle_discovery_response ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""logout"" ) ) { return oidc_handle_logout ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""jwks"" ) ) { return oidc_handle_jwks ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""session"" ) ) { return oidc_handle_session_management ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""refresh"" ) ) { return oidc_handle_refresh_token_request ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""request_uri"" ) ) { return oidc_handle_request_uri ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""remove_at_cache"" ) ) { return oidc_handle_remove_at_cache ( r , c ) ; } else if ( ( r -> args == NULL ) || ( apr_strnatcmp ( r -> args , """" ) == 0 ) ) { return oidc_proto_javascript_implicit ( r , c ) ; } if ( oidc_util_request_has_parameter ( r , ""error"" ) ) { oidc_handle_redirect_authorization_response ( r , c , session ) ; } return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool , <S2SV_StartBug> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , <S2SV_EndBug> r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ; }","-> pool , ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR ) ;"
388,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; <S2SV_StartBug> ps_dec -> u4_cur_bs_mb_num = 0 ; <S2SV_EndBug> DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }",ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk
389,"static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> return max_level ; }","-> fp -> user , scm -> fp ->"
390,"<S2SV_StartBug> static int cipso_v4_delopt ( struct ip_options * * opt_ptr ) <S2SV_EndBug> { int hdr_delta = 0 ; <S2SV_StartBug> struct ip_options * opt = * opt_ptr ; <S2SV_EndBug> <S2SV_StartBug> if ( opt -> srr || opt -> rr || opt -> ts || opt -> router_alert ) { <S2SV_EndBug> u8 cipso_len ; u8 cipso_off ; unsigned char * cipso_ptr ; int iter ; int optlen_new ; <S2SV_StartBug> cipso_off = opt -> cipso - sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> cipso_ptr = & opt -> __data [ cipso_off ] ; <S2SV_EndBug> cipso_len = cipso_ptr [ 1 ] ; <S2SV_StartBug> if ( opt -> srr > opt -> cipso ) <S2SV_EndBug> opt -> srr -= cipso_len ; <S2SV_StartBug> if ( opt -> rr > opt -> cipso ) <S2SV_EndBug> opt -> rr -= cipso_len ; <S2SV_StartBug> if ( opt -> ts > opt -> cipso ) <S2SV_EndBug> opt -> ts -= cipso_len ; <S2SV_StartBug> if ( opt -> router_alert > opt -> cipso ) <S2SV_EndBug> opt -> router_alert -= cipso_len ; <S2SV_StartBug> opt -> cipso = 0 ; <S2SV_EndBug> memmove ( cipso_ptr , cipso_ptr + cipso_len , <S2SV_StartBug> opt -> optlen - cipso_off - cipso_len ) ; <S2SV_EndBug> iter = 0 ; optlen_new = 0 ; <S2SV_StartBug> while ( iter < opt -> optlen ) <S2SV_EndBug> if ( opt -> __data [ iter ] != IPOPT_NOP ) { <S2SV_StartBug> iter += opt -> __data [ iter + 1 ] ; <S2SV_EndBug> optlen_new = iter ; } else iter ++ ; <S2SV_StartBug> hdr_delta = opt -> optlen ; <S2SV_EndBug> opt -> optlen = ( optlen_new + 3 ) & ~ 3 ; <S2SV_StartBug> hdr_delta -= opt -> optlen ; <S2SV_EndBug> } else { * opt_ptr = NULL ; <S2SV_StartBug> hdr_delta = opt -> optlen ; <S2SV_EndBug> kfree ( opt ) ; } return hdr_delta ; }","cipso_v4_delopt ( struct ip_options_rcu <S2SV_ModEnd> * * opt_ptr <S2SV_ModStart> 0 ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> = opt -> opt . <S2SV_ModStart> & opt -> opt . <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> srr -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> rr -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> ts -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> router_alert -= cipso_len <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> , opt -> opt . <S2SV_ModStart> < opt -> opt . optlen ) if ( opt -> opt . <S2SV_ModEnd> __data [ iter <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> = opt -> opt . optlen ; opt -> opt . <S2SV_ModEnd> optlen = ( <S2SV_ModStart> -= opt -> opt . <S2SV_ModStart> = opt -> opt . optlen ; call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; }"
391,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { struct common_audit_data sa ; struct apparmor_audit_data aad = { 0 , } ; <S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> size_t arg_size ; int error ; if ( size == 0 ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( args [ size - 1 ] != '\\0' ) { <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; else goto fail ; <S2SV_StartBug> } else <S2SV_EndBug> return - EINVAL ; if ( ! error ) error = size ; return error ; fail : sa . type = LSM_AUDIT_DATA_NONE ; sa . aad = & aad ; aad . profile = aa_current_profile ( ) ; aad . op = OP_SETPROCATTR ; aad . info = name ; <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> }","command , * largs = NULL , * <S2SV_ModStart> return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> EINVAL ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ( name , ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> , ! AA_DO_TEST <S2SV_ModStart> AA_DO_TEST ) ; <S2SV_ModEnd> else goto fail <S2SV_ModStart> ; } else <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error <S2SV_ModStart> . error = error = <S2SV_ModStart> NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>"
392,"static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <S2SV_StartBug> long timeo ; <S2SV_EndBug> msg -> msg_namelen = 0 ; lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( ""LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n"" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }",; long timeo <S2SV_ModEnd> ; lock_sock (
393,"<S2SV_StartBug> void vp9_write_prob_diff_update ( vp9_writer * w , vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> const int delp = remap_prob ( newp , oldp ) ; encode_term_subexp ( w , delp ) ; }","void vp9_write_prob_diff_update ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * w , vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) {"
394,"<S2SV_StartBug> static int getnum ( lua_State * L , const char * * fmt , int df ) { <S2SV_EndBug> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; do { <S2SV_StartBug> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) <S2SV_EndBug> luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ; a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }",int getnum ( <S2SV_ModEnd> const char * <S2SV_ModStart> ; do { <S2SV_ModEnd> a = a
395,void snd_usb_mixer_disconnect ( struct usb_mixer_interface * mixer ) { <S2SV_StartBug> usb_kill_urb ( mixer -> urb ) ; <S2SV_EndBug> usb_kill_urb ( mixer -> rc_urb ) ; <S2SV_StartBug> } <S2SV_EndBug>,mixer ) { if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> urb ) ; if ( mixer -> rc_urb ) <S2SV_ModStart> rc_urb ) ; mixer -> disconnected = true ;
396,"void qedi_dbg_err ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> va_end ( va ) ; }","struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,"
397,"static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , GFP_KERNEL ) ; if ( ! * ie_ptr ) return - ENOMEM ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; <S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( MWIFIEX_AUTO_IDX_MASK ) ; } * ie_ptr = ie ; return 0 ; }",) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
398,"static uint16_t transmit_data ( serial_data_type_t type , uint8_t * data , uint16_t length ) { assert ( data != NULL ) ; assert ( length > 0 ) ; if ( type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO ) { LOG_ERROR ( ""%s<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>type:<S2SV_blank>%d"" , __func__ , type ) ; return 0 ; } -- data ; uint8_t previous_byte = * data ; * ( data ) = type ; ++ length ; uint16_t transmitted_length = 0 ; while ( length > 0 ) { <S2SV_StartBug> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : LOG_ERROR ( ""In<S2SV_blank>%s,<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>the<S2SV_blank>uart<S2SV_blank>serial<S2SV_blank>port:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto done ; case 0 : goto done ; default : transmitted_length += ret ; length -= ret ; break ; } } done : ; * ( data ) = previous_byte ; if ( transmitted_length > 0 ) -- transmitted_length ; return transmitted_length ; }","ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> transmitted_length , length )"
399,static void clear_evtchn_to_irq_row ( unsigned row ) { unsigned col ; for ( col = 0 ; col < EVTCHN_PER_ROW ; col ++ ) <S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = - 1 ; <S2SV_EndBug> },"col ++ ) WRITE_ONCE ( <S2SV_ModStart> [ col ] , - 1 ) <S2SV_ModEnd> ; } <S2SV_null>"
400,"bool adapter_enable_disable ( ) { int error ; <S2SV_StartBug> CALL_AND_WAIT ( error = bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> TASSERT ( error == BT_STATUS_SUCCESS , ""Error<S2SV_blank>enabling<S2SV_blank>Bluetooth:<S2SV_blank>%d"" , error ) ; TASSERT ( adapter_get_state ( ) == BT_STATE_ON , ""Adapter<S2SV_blank>did<S2SV_blank>not<S2SV_blank>turn<S2SV_blank>on."" ) ; CALL_AND_WAIT ( error = bt_interface -> disable ( ) , adapter_state_changed ) ; TASSERT ( error == BT_STATUS_SUCCESS , ""Error<S2SV_blank>disabling<S2SV_blank>Bluetooth:<S2SV_blank>%d"" , error ) ; TASSERT ( adapter_get_state ( ) == BT_STATE_OFF , ""Adapter<S2SV_blank>did<S2SV_blank>not<S2SV_blank>turn<S2SV_blank>off."" ) ; return true ; }",-> enable ( false
401,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>-o<S2SV_blank>dst_filename<S2SV_blank>src_filename<S2SV_blank>\\n"" , exec_name ) ; fprintf ( stderr , ""\\nOptions:\\n"" ) ; arg_show_usage ( stderr , main_args ) ; fprintf ( stderr , ""\\nEncoder<S2SV_blank>Global<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , global_args ) ; fprintf ( stderr , ""\\nRate<S2SV_blank>Control<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , rc_args ) ; fprintf ( stderr , ""\\nTwopass<S2SV_blank>Rate<S2SV_blank>Control<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , rc_twopass_args ) ; fprintf ( stderr , ""\\nKeyframe<S2SV_blank>Placement<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , kf_args ) ; # if CONFIG_VP8_ENCODER fprintf ( stderr , ""\\nVP8<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp8_args ) ; # endif # if CONFIG_VP9_ENCODER fprintf ( stderr , ""\\nVP9<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp9_args ) ; # endif <S2SV_StartBug> fprintf ( stderr , ""\\nStream<S2SV_blank>timebase<S2SV_blank>(--timebase):\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank>The<S2SV_blank>desired<S2SV_blank>precision<S2SV_blank>of<S2SV_blank>timestamps<S2SV_blank>in<S2SV_blank>the<S2SV_blank>output,<S2SV_blank>expressed\\n"" ""<S2SV_blank><S2SV_blank>in<S2SV_blank>fractional<S2SV_blank>seconds.<S2SV_blank>Default<S2SV_blank>is<S2SV_blank>1/1000.\\n"" ) ; fprintf ( stderr , ""\\nIncluded<S2SV_blank>encoders:\\n\\n"" ) ; <S2SV_StartBug> for ( i = 0 ; i < get_vpx_encoder_count ( ) ; ++ i ) { <S2SV_EndBug> const VpxInterface * const encoder = get_vpx_encoder_by_index ( i ) ; <S2SV_StartBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> encoder -> name , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> exit ( EXIT_FAILURE ) ; }","void usage_exit ( void <S2SV_ModStart> { int i ; const int num_encoder = get_vpx_encoder_count ( ) <S2SV_ModStart> ; # endif # if CONFIG_VP10_ENCODER fprintf ( stderr , ""\\nVP10<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp10_args ) ; # endif <S2SV_ModStart> ; i < num_encoder <S2SV_ModEnd> ; ++ i <S2SV_ModStart> i ) ; const char * defstr = ( i == ( num_encoder - 1 ) ) ? ""(default)"" : """" ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\n"" <S2SV_ModEnd> , encoder -> <S2SV_ModStart> ( encoder -> codec_interface ( ) ) , defstr <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } fprintf ( stderr , ""\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; fprintf ( stderr , ""Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\n\\n"" ) ;"
402,"static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , ""//"" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) <S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( strncmp ( file , ""../"" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , ""/../"" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , ""/.."" ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\\0' ; } }",", strlen ( cp <S2SV_ModEnd> ) - 1"
403,"struct clock_source * dce110_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce110_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }",base ; } kfree ( clk_src ) ;
404,"void * vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; <S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> # ifdef DEBUG g_assert_not_reached ( ) ; # endif vips_error ( ""vips_tracked"" , _ ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB"" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB"" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; # ifdef DEBUG_VERBOSE printf ( ""vips_tracked_malloc:<S2SV_blank>%p,<S2SV_blank>%zd<S2SV_blank>bytes\\n"" , buf , size ) ; # endif g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }",( buf = g_try_malloc0 <S2SV_ModEnd> ( size )
405,"WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>no_output_of_prior_pics_flag"" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>long_term_reference_flag"" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>adaptive_ref_pic_buffering_flag"" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) <S2SV_StartBug> { <S2SV_EndBug> ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }","END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { ALOGE ( ""b/25818142"" ) ; android_errorWriteLog ( 0x534e4554 , ""25818142"" ) ; ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; }"
406,static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; int cpu = smp_processor_id ( ) ; <S2SV_StartBug> read_lock ( & evtchn_rwlock ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; <S2SV_StartBug> xen_evtchn_handle_events ( cpu ) ; <S2SV_EndBug> BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ; <S2SV_StartBug> } <S2SV_EndBug>,"( ) ; struct evtchn_loop_ctrl ctrl = { 0 } ; <S2SV_ModStart> xen_evtchn_handle_events ( cpu , & ctrl <S2SV_ModStart> evtchn_rwlock ) ; __this_cpu_inc ( irq_epoch ) ;"
407,"void tcpUpdateRetransmitQueue ( Socket * socket ) { size_t length ; TcpQueueItem * prevQueueItem ; TcpQueueItem * queueItem ; TcpHeader * header ; prevQueueItem = NULL ; queueItem = socket -> retransmitQueue ; while ( queueItem != NULL ) { header = ( TcpHeader * ) queueItem -> header ; if ( header -> flags & TCP_FLAG_SYN ) <S2SV_StartBug> length = 1 ; <S2SV_EndBug> <S2SV_StartBug> else if ( header -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> length = queueItem -> length + 1 ; <S2SV_StartBug> else <S2SV_EndBug> length = queueItem -> length ; if ( TCP_CMP_SEQ ( socket -> sndUna , ntohl ( header -> seqNum ) + length ) >= 0 ) { if ( prevQueueItem == NULL ) { socket -> retransmitQueue = queueItem -> next ; memPoolFree ( queueItem ) ; queueItem = socket -> retransmitQueue ; } else { prevQueueItem -> next = queueItem -> next ; memPoolFree ( queueItem ) ; queueItem = prevQueueItem -> next ; } tcpTimerStart ( & socket -> retransmitTimer , socket -> rto ) ; socket -> retransmitCount = 0 ; } else { prevQueueItem = queueItem ; queueItem = queueItem -> next ; } } if ( socket -> retransmitQueue == NULL ) tcpTimerStop ( & socket -> retransmitTimer ) ; }",& TCP_FLAG_SYN ) { <S2SV_ModStart> = 1 ; } <S2SV_ModStart> & TCP_FLAG_FIN ) { <S2SV_ModStart> + 1 ; } else { length = queueItem -> length ; } <S2SV_ModEnd> if ( TCP_CMP_SEQ
408,"static int inotify_release ( struct inode * ignored , struct file * file ) { struct fsnotify_group * group = file -> private_data ; <S2SV_StartBug> struct user_struct * user = group -> inotify_data . user ; <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>group=%p\\n"" , __func__ , group ) ; fsnotify_clear_marks_by_group ( group ) ; fsnotify_put_group ( group ) ; <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> return 0 ; }","-> private_data ; <S2SV_ModEnd> pr_debug ( ""%s:<S2SV_blank>group=%p\\n"" <S2SV_ModStart> group ) ; <S2SV_ModEnd> return 0 ;"
409,"static struct ucounts * get_ucounts ( struct user_namespace * ns , kuid_t uid ) { struct hlist_head * hashent = ucounts_hashentry ( ns , uid ) ; struct ucounts * ucounts , * new ; spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ! ucounts ) { spin_unlock_irq ( & ucounts_lock ) ; new = kzalloc ( sizeof ( * new ) , GFP_KERNEL ) ; if ( ! new ) return NULL ; new -> ns = ns ; new -> uid = uid ; <S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ucounts ) { kfree ( new ) ; } else { hlist_add_head ( & new -> node , hashent ) ; ucounts = new ; } } <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ucounts = NULL ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts ; }",= uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (
410,"static void copy_move_file ( CopyMoveJob * copy_job , GFile * src , GFile * dest_dir , gboolean same_fs , gboolean unique_names , char * * dest_fs_type , SourceInfo * source_info , TransferInfo * transfer_info , GHashTable * debuting_files , GdkPoint * position , gboolean overwrite , gboolean * skipped_file , gboolean readonly_source_fs ) { GFile * dest , * new_dest ; g_autofree gchar * dest_uri = NULL ; GError * error ; GFileCopyFlags flags ; char * primary , * secondary , * details ; int response ; ProgressData pdata ; gboolean would_recurse , is_merge ; CommonJob * job ; gboolean res ; int unique_name_nr ; gboolean handled_invalid_filename ; job = ( CommonJob * ) copy_job ; if ( should_skip_file ( job , src ) ) { * skipped_file = TRUE ; return ; } unique_name_nr = 1 ; handled_invalid_filename = * dest_fs_type != NULL ; if ( unique_names ) { dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; } else if ( copy_job -> target_name != NULL ) { dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , copy_job -> target_name ) ; } else { dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; } if ( test_dir_is_parent ( dest_dir , src ) ) { if ( job -> skip_all_error ) { goto out ; } primary = copy_job -> is_move ? g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) : g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) ; secondary = g_strdup ( _ ( ""The<S2SV_blank>destination<S2SV_blank>folder<S2SV_blank>is<S2SV_blank>inside<S2SV_blank>the<S2SV_blank>source<S2SV_blank>folder."" ) ) ; response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } if ( test_dir_is_parent ( src , dest ) ) { if ( job -> skip_all_error ) { goto out ; } primary = copy_job -> is_move ? g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself."" ) ) : g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself."" ) ) ; secondary = g_strdup ( _ ( ""The<S2SV_blank>source<S2SV_blank>file<S2SV_blank>would<S2SV_blank>be<S2SV_blank>overwritten<S2SV_blank>by<S2SV_blank>the<S2SV_blank>destination."" ) ) ; response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } retry : error = NULL ; flags = G_FILE_COPY_NOFOLLOW_SYMLINKS ; if ( overwrite ) { flags |= G_FILE_COPY_OVERWRITE ; } if ( readonly_source_fs ) { flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS ; } pdata . job = copy_job ; pdata . last_size = 0 ; pdata . source_info = source_info ; pdata . transfer_info = transfer_info ; if ( copy_job -> is_move ) { res = g_file_move ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ; } else { res = g_file_copy ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ; } if ( res ) { GFile * real ; real = map_possibly_volatile_file_to_real ( dest , job -> cancellable , & error ) ; if ( real == NULL ) { res = FALSE ; } else { g_object_unref ( dest ) ; dest = real ; } } if ( res ) { transfer_info -> num_files ++ ; report_copy_progress ( copy_job , source_info , transfer_info ) ; if ( debuting_files ) { dest_uri = g_file_get_uri ( dest ) ; if ( position ) { nautilus_file_changes_queue_schedule_position_set ( dest , * position , job -> screen_num ) ; } else if ( eel_uri_is_desktop ( dest_uri ) ) { nautilus_file_changes_queue_schedule_position_remove ( dest ) ; } g_hash_table_replace ( debuting_files , g_object_ref ( dest ) , GINT_TO_POINTER ( TRUE ) ) ; } if ( copy_job -> is_move ) { nautilus_file_changes_queue_file_moved ( src , dest ) ; } else { nautilus_file_changes_queue_file_added ( dest ) ; } if ( copy_job -> desktop_location != NULL && g_file_equal ( copy_job -> desktop_location , dest_dir ) && is_trusted_desktop_file ( src , job -> cancellable ) ) { <S2SV_StartBug> mark_desktop_file_trusted ( job , <S2SV_EndBug> job -> cancellable , dest , FALSE ) ; } if ( job -> undo_info != NULL ) { nautilus_file_undo_info_ext_add_origin_target_pair ( NAUTILUS_FILE_UNDO_INFO_EXT ( job -> undo_info ) , src , dest ) ; } g_object_unref ( dest ) ; return ; } if ( ! handled_invalid_filename && IS_IO_ERROR ( error , INVALID_FILENAME ) ) { handled_invalid_filename = TRUE ; g_assert ( * dest_fs_type == NULL ) ; * dest_fs_type = query_fs_type ( dest_dir , job -> cancellable ) ; if ( unique_names ) { new_dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ) ; } else { new_dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; } if ( ! g_file_equal ( dest , new_dest ) ) { g_object_unref ( dest ) ; dest = new_dest ; g_error_free ( error ) ; goto retry ; } else { g_object_unref ( new_dest ) ; } } if ( ! overwrite && IS_IO_ERROR ( error , EXISTS ) ) { gboolean is_merge ; FileConflictResponse * response ; g_error_free ( error ) ; if ( unique_names ) { g_object_unref ( dest ) ; dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; goto retry ; } is_merge = FALSE ; if ( is_dir ( dest ) && is_dir ( src ) ) { is_merge = TRUE ; } if ( ( is_merge && job -> merge_all ) || ( ! is_merge && job -> replace_all ) ) { overwrite = TRUE ; goto retry ; } if ( job -> skip_all_conflict ) { goto out ; } response = handle_copy_move_conflict ( job , src , dest , dest_dir ) ; if ( response -> id == GTK_RESPONSE_CANCEL || response -> id == GTK_RESPONSE_DELETE_EVENT ) { file_conflict_response_free ( response ) ; abort_job ( job ) ; } else if ( response -> id == CONFLICT_RESPONSE_SKIP ) { if ( response -> apply_to_all ) { job -> skip_all_conflict = TRUE ; } file_conflict_response_free ( response ) ; } else if ( response -> id == CONFLICT_RESPONSE_REPLACE ) { if ( response -> apply_to_all ) { if ( is_merge ) { job -> merge_all = TRUE ; } else { job -> replace_all = TRUE ; } } overwrite = TRUE ; file_conflict_response_free ( response ) ; goto retry ; } else if ( response -> id == CONFLICT_RESPONSE_RENAME ) { g_object_unref ( dest ) ; dest = get_target_file_for_display_name ( dest_dir , response -> new_name ) ; file_conflict_response_free ( response ) ; goto retry ; } else { g_assert_not_reached ( ) ; } } else if ( overwrite && IS_IO_ERROR ( error , IS_DIRECTORY ) ) { gboolean existing_file_deleted ; DeleteExistingFileData data ; g_error_free ( error ) ; data . job = job ; data . source = src ; existing_file_deleted = delete_file_recursively ( dest , job -> cancellable , existing_file_removed_callback , & data ) ; if ( existing_file_deleted ) { goto retry ; } } else if ( IS_IO_ERROR ( error , WOULD_RECURSE ) || IS_IO_ERROR ( error , WOULD_MERGE ) ) { is_merge = error -> code == G_IO_ERROR_WOULD_MERGE ; would_recurse = error -> code == G_IO_ERROR_WOULD_RECURSE ; g_error_free ( error ) ; if ( overwrite && would_recurse ) { error = NULL ; if ( ! g_file_delete ( dest , job -> cancellable , & error ) && ! IS_IO_ERROR ( error , NOT_FOUND ) ) { if ( job -> skip_all_error ) { g_error_free ( error ) ; goto out ; } if ( copy_job -> is_move ) { primary = f ( _ ( ""Error<S2SV_blank>while<S2SV_blank>moving<S2SV_blank>“%B”."" ) , src ) ; } else { primary = f ( _ ( ""Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>“%B”."" ) , src ) ; } secondary = f ( _ ( ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>already<S2SV_blank>existing<S2SV_blank>file<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>name<S2SV_blank>in<S2SV_blank>%F."" ) , dest_dir ) ; details = error -> message ; response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , NULL ) ; g_error_free ( error ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } if ( error ) { g_error_free ( error ) ; error = NULL ; } nautilus_file_changes_queue_file_removed ( dest ) ; } if ( is_merge ) { same_fs = FALSE ; } if ( ! copy_move_directory ( copy_job , src , & dest , same_fs , would_recurse , dest_fs_type , source_info , transfer_info , debuting_files , skipped_file , readonly_source_fs ) ) { g_assert ( * dest_fs_type != NULL ) ; handled_invalid_filename = TRUE ; goto retry ; } g_object_unref ( dest ) ; return ; } else if ( IS_IO_ERROR ( error , CANCELLED ) ) { g_error_free ( error ) ; } else { if ( job -> skip_all_error ) { g_error_free ( error ) ; goto out ; } primary = f ( _ ( ""Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>“%B”."" ) , src ) ; secondary = f ( _ ( ""There<S2SV_blank>was<S2SV_blank>an<S2SV_blank>error<S2SV_blank>copying<S2SV_blank>the<S2SV_blank>file<S2SV_blank>into<S2SV_blank>%F."" ) , dest_dir ) ; details = error -> message ; response = run_cancel_or_skip_warning ( job , primary , secondary , details , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; g_error_free ( error ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } } out : * skipped_file = TRUE ; g_object_unref ( dest ) ; }",") ) { mark_desktop_file_executable <S2SV_ModEnd> ( job ,"
411,"static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }",} else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
412,"static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <S2SV_StartBug> case 0 : <S2SV_EndBug> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)"" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata"" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header"" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 : <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression"" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)"" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }","case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;"
413,"jas_image_t * jp2_decode ( jas_stream_t * in , const char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; JAS_DBGLOG ( 100 , ( ""jp2_decode(%p,<S2SV_blank>\\""%s\\"")\\n"" , in , optstr ) ) ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\n"" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( ""incorrect<S2SV_blank>magic<S2SV_blank>number\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( ""expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ; } switch ( box -> type ) { case JP2_BOX_JP2C : found = 1 ; break ; case JP2_BOX_IHDR : if ( ! dec -> ihdr ) { dec -> ihdr = box ; box = 0 ; } break ; case JP2_BOX_BPCC : if ( ! dec -> bpcc ) { dec -> bpcc = box ; box = 0 ; } break ; case JP2_BOX_CDEF : if ( ! dec -> cdef ) { dec -> cdef = box ; box = 0 ; } break ; case JP2_BOX_PCLR : if ( ! dec -> pclr ) { dec -> pclr = box ; box = 0 ; } break ; case JP2_BOX_CMAP : if ( ! dec -> cmap ) { dec -> cmap = box ; box = 0 ; } break ; case JP2_BOX_COLR : if ( ! dec -> colr ) { dec -> colr = box ; box = 0 ; } break ; } if ( box ) { jp2_box_destroy ( box ) ; box = 0 ; } if ( found ) { break ; } } if ( ! found ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>code<S2SV_blank>stream<S2SV_blank>found\\n"" ) ; goto error ; } if ( ! ( dec -> image = jpc_decode ( in , optstr ) ) ) { jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>code<S2SV_blank>stream\\n"" ) ; goto error ; } if ( ! dec -> ihdr ) { jas_eprintf ( ""error:<S2SV_blank>missing<S2SV_blank>IHDR<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; <S2SV_EndBug> } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } samedtype = true ; dtype = jas_image_cmptdtype ( dec -> image , 0 ) ; for ( i = 1 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) { samedtype = false ; break ; } } if ( ( samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_DTYPETOBPC ( dtype ) ) || ( ! samedtype && dec -> ihdr -> data . ihdr . bpc != JP2_IHDR_BPCNULL ) ) { <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; <S2SV_EndBug> } if ( dec -> ihdr -> data . ihdr . comptype != JP2_IHDR_COMPTYPE ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>compression<S2SV_blank>type\\n"" ) ; goto error ; } if ( dec -> bpcc ) { if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( <S2SV_StartBug> dec -> image ) ) ) { <S2SV_EndBug> jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; } if ( ! samedtype ) { for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { if ( jas_image_cmptdtype ( dec -> image , i ) != JP2_BPCTODTYPE ( dec -> bpcc -> data . bpcc . bpcs [ i ] ) ) { <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; <S2SV_EndBug> } } } else { jas_eprintf ( ""warning:<S2SV_blank>superfluous<S2SV_blank>BPCC<S2SV_blank>box\\n"" ) ; } } if ( ! dec -> colr ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>COLR<S2SV_blank>box\\n"" ) ; goto error ; } switch ( dec -> colr -> data . colr . method ) { case JP2_COLR_ENUM : jas_image_setclrspc ( dec -> image , jp2_getcs ( & dec -> colr -> data . colr ) ) ; break ; case JP2_COLR_ICC : iccprof = jas_iccprof_createfrombuf ( dec -> colr -> data . colr . iccp , dec -> colr -> data . colr . iccplen ) ; if ( ! iccprof ) { jas_eprintf ( ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>ICC<S2SV_blank>profile\\n"" ) ; goto error ; } jas_iccprof_gethdr ( iccprof , & icchdr ) ; jas_eprintf ( ""ICC<S2SV_blank>Profile<S2SV_blank>CS<S2SV_blank>%08x\\n"" , icchdr . colorspc ) ; jas_image_setclrspc ( dec -> image , fromiccpcs ( icchdr . colorspc ) ) ; dec -> image -> cmprof_ = jas_cmprof_createfromiccprof ( iccprof ) ; if ( ! dec -> image -> cmprof_ ) { jas_iccprof_destroy ( iccprof ) ; goto error ; } jas_iccprof_destroy ( iccprof ) ; break ; } if ( dec -> cmap && ! dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>PCLR<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> cmap ) ; dec -> cmap = 0 ; } if ( ! dec -> cmap && dec -> pclr ) { jas_eprintf ( ""warning:<S2SV_blank>missing<S2SV_blank>CMAP<S2SV_blank>box<S2SV_blank>or<S2SV_blank>superfluous<S2SV_blank>PCLR<S2SV_blank>box\\n"" ) ; jp2_box_destroy ( dec -> pclr ) ; dec -> pclr = 0 ; } dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; if ( dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>component<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; goto error ; } if ( dec -> cmap -> data . cmap . ents [ i ] . pcol >= dec -> pclr -> data . pclr . numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>CMAP<S2SV_blank>LUT<S2SV_blank>index\\n"" ) ; goto error ; } } } if ( ! ( dec -> chantocmptlut = jas_alloc2 ( dec -> numchans , sizeof ( uint_fast16_t ) ) ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>memory\\n"" ) ; goto error ; } if ( ! dec -> cmap ) { for ( i = 0 ; i < dec -> numchans ; ++ i ) { dec -> chantocmptlut [ i ] = i ; } } else { cmapd = & dec -> cmap -> data . cmap ; pclrd = & dec -> pclr -> data . pclr ; cdefd = & dec -> cdef -> data . cdef ; for ( channo = 0 ; channo < cmapd -> numchans ; ++ channo ) { cmapent = & cmapd -> ents [ channo ] ; if ( cmapent -> map == JP2_CMAP_DIRECT ) { dec -> chantocmptlut [ channo ] = channo ; } else if ( cmapent -> map == JP2_CMAP_PALETTE ) { if ( ! pclrd -> numlutents ) { goto error ; } lutents = jas_alloc2 ( pclrd -> numlutents , sizeof ( int_fast32_t ) ) ; if ( ! lutents ) { goto error ; } for ( i = 0 ; i < pclrd -> numlutents ; ++ i ) { lutents [ i ] = pclrd -> lutdata [ cmapent -> pcol + i * pclrd -> numchans ] ; } newcmptno = jas_image_numcmpts ( dec -> image ) ; jas_image_depalettize ( dec -> image , cmapent -> cmptno , pclrd -> numlutents , lutents , JP2_BPCTODTYPE ( pclrd -> bpc [ cmapent -> pcol ] ) , newcmptno ) ; dec -> chantocmptlut [ channo ] = newcmptno ; jas_free ( lutents ) ; # if 0 if ( dec -> cdef ) { cdefent = jp2_cdef_lookup ( cdefd , channo ) ; if ( ! cdefent ) { abort ( ) ; } jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , cdefent -> type , cdefent -> assoc ) ) ; } else { jas_image_setcmpttype ( dec -> image , newcmptno , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , channo + 1 ) ) ; } # else ( void ) cdefd ; # endif } else { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>MTYP<S2SV_blank>in<S2SV_blank>CMAP<S2SV_blank>box\\n"" ) ; goto error ; } } } if ( dec -> numchans != jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>mismatch<S2SV_blank>in<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\n"" , dec -> numchans , jas_image_numcmpts ( dec -> image ) ) ; goto error ; } for ( i = 0 ; i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ; } if ( dec -> cdef ) { for ( i = 0 ; i < dec -> cdef -> data . cdef . numchans ; ++ i ) { if ( dec -> cdef -> data . cdef . ents [ i ] . channo >= dec -> numchans ) { jas_eprintf ( ""error:<S2SV_blank>invalid<S2SV_blank>channel<S2SV_blank>number<S2SV_blank>in<S2SV_blank>CDEF<S2SV_blank>box\\n"" ) ; goto error ; } jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ dec -> cdef -> data . cdef . ents [ i ] . channo ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , dec -> cdef -> data . cdef . ents [ i ] . type , dec -> cdef -> data . cdef . ents [ i ] . assoc ) ) ; } } else { for ( i = 0 ; i < dec -> numchans ; ++ i ) { jas_image_setcmpttype ( dec -> image , dec -> chantocmptlut [ i ] , jp2_getct ( jas_image_clrspc ( dec -> image ) , 0 , i + 1 ) ) ; } } for ( i = jas_image_numcmpts ( dec -> image ) ; i > 0 ; -- i ) { if ( jas_image_cmpttype ( dec -> image , i - 1 ) == JAS_IMAGE_CT_UNKNOWN ) { jas_image_delcmpt ( dec -> image , i - 1 ) ; } } if ( ! jas_image_numcmpts ( dec -> image ) ) { jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\n"" ) ; goto error ; } # if 0 jas_eprintf ( ""no<S2SV_blank>of<S2SV_blank>components<S2SV_blank>is<S2SV_blank>%d\\n"" , jas_image_numcmpts ( dec -> image ) ) ; # endif image = dec -> image ; dec -> image = 0 ; jp2_dec_destroy ( dec ) ; return image ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( dec ) { jp2_dec_destroy ( dec ) ; } return 0 ; }","{ jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> ; } }"
414,"date PGTYPESdate_from_asc ( char * str , char * * endptr ) { date dDate ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; <S2SV_StartBug> char lowstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; bool EuroDates = FALSE ; errno = 0 ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , EuroDates ) != 0 ) { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } switch ( dtype ) { case DTK_DATE : break ; case DTK_EPOCH : if ( GetEpochTime ( tm ) < 0 ) { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } break ; default : errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } dDate = ( date2j ( tm -> tm_year , tm -> tm_mon , tm -> tm_mday ) - date2j ( 2000 , 1 , 1 ) ) ; return dDate ; }",[ MAXDATELEN + MAXDATEFIELDS <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno
415,"void js_RegExp_prototype_exec ( js_State * J , js_Regexp * re , const char * text ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int opts ; Resub m ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushnull ( J ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> js_newarray ( J ) ; js_pushstring ( J , text ) ; js_setproperty ( J , - 2 , ""input"" ) ; js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; js_setproperty ( J , - 2 , ""index"" ) ; for ( i = 0 ; i < m . nsub ; ++ i ) { js_pushlstring ( J , m . sub [ i ] . sp , m . sub [ i ] . ep - m . sub [ i ] . sp ) ; js_setindex ( J , - 2 , i ) ; } if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushnull ( J ) ; }",") { int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0"
416,"static struct pid * good_sigevent ( sigevent_t * event ) { struct task_struct * rtn = current -> group_leader ; <S2SV_StartBug> if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) && <S2SV_EndBug> <S2SV_StartBug> ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) || <S2SV_EndBug> <S2SV_StartBug> ! same_thread_group ( rtn , current ) || <S2SV_EndBug> ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_SIGNAL ) ) return NULL ; <S2SV_StartBug> if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && <S2SV_EndBug> <S2SV_StartBug> ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> return task_pid ( rtn ) ; <S2SV_StartBug> } <S2SV_EndBug>","-> group_leader ; switch <S2SV_ModEnd> ( event -> <S2SV_ModStart> event -> sigev_notify ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> rtn = find_task_by_vpid <S2SV_ModStart> -> sigev_notify_thread_id ) ; if ( ! rtn <S2SV_ModEnd> || ! same_thread_group <S2SV_ModStart> , current ) <S2SV_ModEnd> ) return NULL <S2SV_ModStart> return NULL ; case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> ( event -> <S2SV_ModStart> sigev_signo <= 0 || <S2SV_ModEnd> event -> sigev_signo <S2SV_ModStart> > SIGRTMAX ) <S2SV_ModEnd> return NULL ; <S2SV_ModStart> return NULL ; case SIGEV_NONE : <S2SV_ModStart> rtn ) ; default : return NULL ; }"
417,"int _fep_open_control_socket ( Fep * fep ) { struct sockaddr_un sun ; char * path ; int fd ; ssize_t sun_len ; fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( fd < 0 ) { perror ( ""socket"" ) ; return - 1 ; } path = create_socket_name ( ""fep-XXXXXX/control"" ) ; if ( strlen ( path ) + 1 >= sizeof ( sun . sun_path ) ) { fep_log ( FEP_LOG_LEVEL_WARNING , ""unix<S2SV_blank>domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>1<S2SV_blank>>=<S2SV_blank>%d"" , strlen ( path ) , sizeof ( sun . sun_path ) ) ; free ( path ) ; return - 1 ; } memset ( & sun , 0 , sizeof ( sun ) ) ; sun . sun_family = AF_UNIX ; <S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> memcpy ( sun . sun_path + 1 , path , strlen ( path ) ) ; <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ; <S2SV_EndBug> remove_control_socket ( path ) ; # else memcpy ( sun . sun_path , path , strlen ( path ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; # endif if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) { perror ( ""bind"" ) ; free ( path ) ; close ( fd ) ; return - 1 ; } if ( listen ( fd , 5 ) < 0 ) { perror ( ""listen"" ) ; free ( path ) ; close ( fd ) ; return - 1 ; } fep -> server = fd ; fep -> control_socket_path = path ; return 0 ; }","= AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . sun_path <S2SV_ModStart> sun . sun_path <S2SV_ModEnd> , path , <S2SV_ModStart> ; sun_len = sizeof <S2SV_ModEnd> ( struct sockaddr_un <S2SV_ModStart> ( struct sockaddr_un ) ; <S2SV_ModEnd> if ( bind"
418,"int rds_rdma_extra_size ( struct rds_rdma_args * args ) { struct rds_iovec vec ; struct rds_iovec __user * local_vec ; int tot_pages = 0 ; unsigned int nr_pages ; unsigned int i ; <S2SV_StartBug> local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ; <S2SV_EndBug> for ( i = 0 ; i < args -> nr_local ; i ++ ) { if ( copy_from_user ( & vec , & local_vec [ i ] , sizeof ( struct rds_iovec ) ) ) return - EFAULT ; nr_pages = rds_pages_in_vec ( & vec ) ; if ( nr_pages == 0 ) return - EINVAL ; tot_pages += nr_pages ; if ( tot_pages < 0 ) return - EINVAL ; } return tot_pages * sizeof ( struct scatterlist ) ; }",args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
419,"int vp8_yv12_de_alloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf ) { if ( ybf ) { if ( ybf -> buffer_alloc_sz > 0 ) { vpx_free ( ybf -> buffer_alloc ) ; } <S2SV_StartBug> vpx_memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> } else { return - 1 ; } return 0 ; }",") ; } memset <S2SV_ModEnd> ( ybf ,"
420,"rpmRC rpmReadPackageFile ( rpmts ts , FD_t fd , const char * fn , Header * hdrp ) { char * msg = NULL ; Header h = NULL ; Header sigh = NULL ; hdrblob blob = NULL ; hdrblob sigblob = NULL ; rpmVSFlags vsflags = rpmtsVSFlags ( ts ) | RPMVSF_NEEDPAYLOAD ; rpmKeyring keyring = rpmtsGetKeyring ( ts , 1 ) ; struct rpmvs_s * vs = rpmvsCreate ( 0 , vsflags , keyring ) ; struct pkgdata_s pkgdata = { . msgfunc = loghdrmsg , . fn = fn ? fn : Fdescr ( fd ) , . msg = NULL , . rc = RPMRC_OK , } ; if ( hdrp ) * hdrp = NULL ; rpmRC rc = rpmpkgRead ( vs , fd , & sigblob , & blob , & msg ) ; if ( rc ) goto exit ; rc = RPMRC_FAIL ; if ( ! rpmvsVerify ( vs , RPMSIG_VERIFIABLE_TYPE , handleHdrVS , & pkgdata ) ) { if ( hdrp ) { if ( hdrblobImport ( sigblob , 0 , & sigh , & msg ) ) goto exit ; if ( hdrblobImport ( blob , 0 , & h , & msg ) ) goto exit ; <S2SV_StartBug> headerMergeLegacySigs ( h , sigh ) ; <S2SV_EndBug> applyRetrofits ( h ) ; * hdrp = headerLink ( h ) ; } rc = RPMRC_OK ; } if ( rc == RPMRC_OK && pkgdata . rc ) rc = pkgdata . rc ; exit : if ( rc && msg ) rpmlog ( RPMLOG_ERR , ""%s:<S2SV_blank>%s\\n"" , Fdescr ( fd ) , msg ) ; hdrblobFree ( sigblob ) ; hdrblobFree ( blob ) ; headerFree ( sigh ) ; headerFree ( h ) ; rpmKeyringFree ( keyring ) ; rpmvsFree ( vs ) ; free ( msg ) ; return rc ; }","goto exit ; if ( <S2SV_ModStart> h , sigh , & msg ) ) goto exit <S2SV_ModEnd> ; applyRetrofits ("
421,"static void ip_expire ( unsigned long arg ) { struct ipq * qp ; struct net * net ; qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; spin_lock ( & qp -> q . lock ) ; if ( qp -> q . last_in & INET_FRAG_COMPLETE ) goto out ; ipq_kill ( qp ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { struct sk_buff * head = qp -> q . fragments ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; <S2SV_StartBug> if ( ! head -> dev ) <S2SV_EndBug> goto out_rcu_unlock ; <S2SV_StartBug> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <S2SV_EndBug> const struct iphdr * iph = ip_hdr ( head ) ; int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ; <S2SV_StartBug> } <S2SV_EndBug> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; out_rcu_unlock : rcu_read_unlock ( ) ; } out : spin_unlock ( & qp -> q . lock ) ; ipq_put ( qp ) ; }",". fragments ; const struct iphdr * iph ; int err ; <S2SV_ModStart> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart> == IP_DEFRAG_CONNTRACK_IN && <S2SV_ModEnd> skb_rtable ( head <S2SV_ModStart> goto out_rcu_unlock ; <S2SV_ModEnd> icmp_send ( head"
422,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }",": 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds ("
423,"void ieee80211_sta_ps_deliver_wakeup ( struct sta_info * sta ) { struct ieee80211_sub_if_data * sdata = sta -> sdata ; struct ieee80211_local * local = sdata -> local ; struct sk_buff_head pending ; int filtered = 0 , buffered = 0 , ac ; unsigned long flags ; clear_sta_flag ( sta , WLAN_STA_SP ) ; BUILD_BUG_ON ( BITS_TO_LONGS ( IEEE80211_NUM_TIDS ) > 1 ) ; sta -> driver_buffered_tids = 0 ; if ( ! ( local -> hw . flags & IEEE80211_HW_AP_LINK_PS ) ) drv_sta_notify ( local , sdata , STA_NOTIFY_AWAKE , & sta -> sta ) ; skb_queue_head_init ( & pending ) ; <S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> int count = skb_queue_len ( & pending ) , tmp ; spin_lock_irqsave ( & sta -> tx_filtered [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> tx_filtered [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> tx_filtered [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; filtered += tmp - count ; count = tmp ; spin_lock_irqsave ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> ps_tx_buf [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; buffered += tmp - count ; } <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) { ht_dbg ( sdata , ""%pM<S2SV_blank>just<S2SV_blank>woke<S2SV_blank>up<S2SV_blank>and<S2SV_blank>MIMO<S2SV_blank>capable<S2SV_blank>-<S2SV_blank>update<S2SV_blank>SMPS\\n"" , sta -> sta . addr ) ; ieee80211_send_smps_action ( sdata , sdata -> bss -> req_smps , sta -> sta . addr , sdata -> vif . bss_conf . bssid ) ; } local -> total_ps_buffered -= buffered ; sta_info_recalc_tim ( sta ) ; ps_dbg ( sdata , ""STA<S2SV_blank>%pM<S2SV_blank>aid<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>%d<S2SV_blank>filtered/%d<S2SV_blank>PS<S2SV_blank>frames<S2SV_blank>since<S2SV_blank>STA<S2SV_blank>not<S2SV_blank>sleeping<S2SV_blank>anymore\\n"" , sta -> sta . addr , sta -> sta . aid , filtered , buffered ) ; }","pending ) ; spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> clear_sta_ps_flags , sta ) ; spin_unlock ( & sta -> ps_lock"
424,"void iperf_on_connect ( struct iperf_test * test ) { time_t now_secs ; const char * rfc1123_fmt = ""%a,<S2SV_blank>%d<S2SV_blank>%b<S2SV_blank>%Y<S2SV_blank>%H:%M:%S<S2SV_blank>GMT"" ; char now_str [ 100 ] ; char ipr [ INET6_ADDRSTRLEN ] ; int port ; struct sockaddr_storage sa ; struct sockaddr_in * sa_inP ; struct sockaddr_in6 * sa_in6P ; socklen_t len ; int opt ; now_secs = time ( ( time_t * ) 0 ) ; ( void ) strftime ( now_str , sizeof ( now_str ) , rfc1123_fmt , gmtime ( & now_secs ) ) ; if ( test -> json_output ) cJSON_AddItemToObject ( test -> json_start , ""timestamp"" , iperf_json_printf ( ""time:<S2SV_blank>%s<S2SV_blank><S2SV_blank>timesecs:<S2SV_blank>%d"" , now_str , ( int64_t ) now_secs ) ) ; else if ( test -> verbose ) iprintf ( test , report_time , now_str ) ; if ( test -> role == 'c' ) { if ( test -> json_output ) cJSON_AddItemToObject ( test -> json_start , ""connecting_to"" , iperf_json_printf ( ""host:<S2SV_blank>%s<S2SV_blank><S2SV_blank>port:<S2SV_blank>%d"" , test -> server_hostname , ( int64_t ) test -> server_port ) ) ; else { iprintf ( test , report_connecting , test -> server_hostname , test -> server_port ) ; if ( test -> reverse ) iprintf ( test , report_reverse , test -> server_hostname ) ; } } else { len = sizeof ( sa ) ; getpeername ( test -> ctrl_sck , ( struct sockaddr * ) & sa , & len ) ; if ( getsockdomain ( test -> ctrl_sck ) == AF_INET ) { sa_inP = ( struct sockaddr_in * ) & sa ; inet_ntop ( AF_INET , & sa_inP -> sin_addr , ipr , sizeof ( ipr ) ) ; port = ntohs ( sa_inP -> sin_port ) ; } else { sa_in6P = ( struct sockaddr_in6 * ) & sa ; inet_ntop ( AF_INET6 , & sa_in6P -> sin6_addr , ipr , sizeof ( ipr ) ) ; port = ntohs ( sa_in6P -> sin6_port ) ; } mapped_v4_to_regular_v4 ( ipr ) ; if ( test -> json_output ) cJSON_AddItemToObject ( test -> json_start , ""accepted_connection"" , iperf_json_printf ( ""host:<S2SV_blank>%s<S2SV_blank><S2SV_blank>port:<S2SV_blank>%d"" , ipr , ( int64_t ) port ) ) ; else iprintf ( test , report_accepted , ipr , port ) ; } if ( test -> json_output ) { cJSON_AddStringToObject ( test -> json_start , ""cookie"" , test -> cookie ) ; if ( test -> protocol -> id == SOCK_STREAM ) { if ( test -> settings -> mss ) <S2SV_StartBug> cJSON_AddIntToObject ( test -> json_start , ""tcp_mss"" , test -> settings -> mss ) ; <S2SV_EndBug> else { len = sizeof ( opt ) ; getsockopt ( test -> ctrl_sck , IPPROTO_TCP , TCP_MAXSEG , & opt , & len ) ; <S2SV_StartBug> cJSON_AddIntToObject ( test -> json_start , ""tcp_mss_default"" , opt ) ; <S2SV_EndBug> } } } else if ( test -> verbose ) { iprintf ( test , report_cookie , test -> cookie ) ; if ( test -> protocol -> id == SOCK_STREAM ) { if ( test -> settings -> mss ) iprintf ( test , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>MSS:<S2SV_blank>%d\\n"" , test -> settings -> mss ) ; else { len = sizeof ( opt ) ; getsockopt ( test -> ctrl_sck , IPPROTO_TCP , TCP_MAXSEG , & opt , & len ) ; iprintf ( test , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>MSS:<S2SV_blank>%d<S2SV_blank>(default)\\n"" , opt ) ; } } } }",-> mss ) cJSON_AddNumberToObject <S2SV_ModEnd> ( test -> <S2SV_ModStart> len ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( test ->
425,"int fscrypt_setup_filename ( struct inode * dir , const struct qstr * iname , int lookup , struct fscrypt_name * fname ) { int ret = 0 , bigname = 0 ; memset ( fname , 0 , sizeof ( struct fscrypt_name ) ) ; fname -> usr_fname = iname ; if ( ! dir -> i_sb -> s_cop -> is_encrypted ( dir ) || fscrypt_is_dot_dotdot ( iname ) ) { fname -> disk_name . name = ( unsigned char * ) iname -> name ; fname -> disk_name . len = iname -> len ; return 0 ; } <S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> if ( ret && ret != - EOPNOTSUPP ) return ret ; if ( dir -> i_crypt_info ) { ret = fscrypt_fname_alloc_buffer ( dir , iname -> len , & fname -> crypto_buf ) ; if ( ret ) return ret ; ret = fname_encrypt ( dir , iname , & fname -> crypto_buf ) ; if ( ret ) goto errout ; fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; return 0 ; } if ( ! lookup ) return - ENOKEY ; if ( iname -> name [ 0 ] == '_' ) bigname = 1 ; if ( ( bigname && ( iname -> len != 33 ) ) || ( ! bigname && ( iname -> len > 43 ) ) ) return - ENOENT ; fname -> crypto_buf . name = kmalloc ( 32 , GFP_KERNEL ) ; if ( fname -> crypto_buf . name == NULL ) return - ENOMEM ; ret = digest_decode ( iname -> name + bigname , iname -> len - bigname , fname -> crypto_buf . name ) ; if ( ret < 0 ) { ret = - ENOENT ; goto errout ; } fname -> crypto_buf . len = ret ; if ( bigname ) { memcpy ( & fname -> hash , fname -> crypto_buf . name , 4 ) ; memcpy ( & fname -> minor_hash , fname -> crypto_buf . name + 4 , 4 ) ; } else { fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; } return 0 ; errout : fscrypt_fname_free_buffer ( & fname -> crypto_buf ) ; return ret ; }",} ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )
426,"int tcp_test ( const char * ip_str , const short port ) { int sock , i ; struct sockaddr_in s_in ; int packetsize = 1024 ; unsigned char packet [ packetsize ] ; struct timeval tv , tv2 , tv3 ; int caplen = 0 ; int times [ REQUESTS ] ; int min , avg , max , len ; struct net_hdr nh ; tv3 . tv_sec = 0 ; tv3 . tv_usec = 1 ; s_in . sin_family = PF_INET ; s_in . sin_port = htons ( port ) ; if ( ! inet_aton ( ip_str , & s_in . sin_addr ) ) return - 1 ; if ( ( sock = socket ( s_in . sin_family , SOCK_STREAM , IPPROTO_TCP ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , F_SETFL , O_NONBLOCK ) < 0 ) { perror ( ""fcntl(O_NONBLOCK)<S2SV_blank>failed"" ) ; return ( 1 ) ; } gettimeofday ( & tv , NULL ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != EINPROGRESS && errno != EALREADY ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""Failed<S2SV_blank>to<S2SV_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , NULL ) ; break ; } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 3000 * 1000 ) ) { printf ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; close ( sock ) ; return ( - 1 ) ; } usleep ( 10 ) ; } PCT ; printf ( ""TCP<S2SV_blank>connection<S2SV_blank>successful\\n"" ) ; memset ( & nh , 0 , sizeof ( nh ) ) ; nh . nh_type = 2 ; nh . nh_len = htonl ( 0 ) ; if ( send ( sock , & nh , sizeof ( nh ) , 0 ) != sizeof ( nh ) ) { perror ( ""send"" ) ; return - 1 ; } gettimeofday ( & tv , NULL ) ; i = 0 ; while ( 1 ) { caplen = read ( sock , & nh , sizeof ( nh ) ) ; if ( caplen == - 1 ) { if ( errno != EAGAIN ) { perror ( ""read"" ) ; return - 1 ; } } if ( ( unsigned ) caplen == sizeof ( nh ) ) { len = ntohl ( nh . nh_len ) ; <S2SV_StartBug> if ( nh . nh_type == 1 && i == 0 ) <S2SV_EndBug> { i = 1 ; caplen = read ( sock , packet , len ) ; if ( caplen == len ) { i = 2 ; break ; } else { i = 0 ; } } else { caplen = read ( sock , packet , len ) ; } } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } if ( caplen == - 1 ) usleep ( 10 ) ; } if ( i == 2 ) { PCT ; printf ( ""airserv-ng<S2SV_blank>found\\n"" ) ; } else { PCT ; printf ( ""airserv-ng<S2SV_blank>NOT<S2SV_blank>found\\n"" ) ; } close ( sock ) ; for ( i = 0 ; i < REQUESTS ; i ++ ) { if ( ( sock = socket ( s_in . sin_family , SOCK_STREAM , IPPROTO_TCP ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , F_SETFL , O_NONBLOCK ) < 0 ) { perror ( ""fcntl(O_NONBLOCK)<S2SV_blank>failed"" ) ; return ( 1 ) ; } usleep ( 1000 ) ; gettimeofday ( & tv , NULL ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != EINPROGRESS && errno != EALREADY ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""Failed<S2SV_blank>to<S2SV_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , NULL ) ; break ; } gettimeofday ( & tv2 , NULL ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } select ( 1 , NULL , NULL , NULL , & tv3 ) ; } times [ i ] = ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) ; printf ( ""\\r%d/%d\\r"" , i , REQUESTS ) ; fflush ( stdout ) ; close ( sock ) ; } min = INT_MAX ; avg = 0 ; max = 0 ; for ( i = 0 ; i < REQUESTS ; i ++ ) { if ( times [ i ] < min ) min = times [ i ] ; if ( times [ i ] > max ) max = times [ i ] ; avg += times [ i ] ; } avg /= REQUESTS ; PCT ; printf ( ""ping<S2SV_blank>%s:%d<S2SV_blank>(min/avg/max):<S2SV_blank>%.3fms/%.3fms/%.3fms\\n"" , ip_str , port , min / 1000.0 , avg / 1000.0 , max / 1000.0 ) ; return 0 ; }",; if ( len > 1024 || len < 0 ) continue ; if (
427,"<S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> if ( node -> parent ) { <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( child ) { <S2SV_EndBug> if ( node -> right == child ) { add_bit ( 1 , fout ) ; } else { add_bit ( 0 , fout ) ; } } }","byte * fout , int maxoffset <S2SV_ModStart> node , fout , maxoffset <S2SV_ModStart> child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; }"
428,"static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }","sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )"
429,"static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 << 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> if ( len == limit ) return ; js_pushliteral ( J , """" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }","{ if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog"
430,"static ssize_t _epoll_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","= 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ("
431,"void eval_js ( WebKitWebView * web_view , gchar * script , GString * result ) { WebKitWebFrame * frame ; JSGlobalContextRef context ; <S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> JSStringRef var_name ; JSStringRef js_script ; JSValueRef js_result ; JSStringRef js_result_string ; size_t js_result_size ; js_init ( ) ; frame = webkit_web_view_get_main_frame ( WEBKIT_WEB_VIEW ( web_view ) ) ; context = webkit_web_frame_get_global_context ( frame ) ; <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> var_name = JSStringCreateWithUTF8CString ( ""Uzbl"" ) ; JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ; js_script = JSStringCreateWithUTF8CString ( script ) ; js_result = JSEvaluateScript ( context , js_script , globalobject , NULL , 0 , NULL ) ; if ( js_result && ! JSValueIsUndefined ( context , js_result ) ) { js_result_string = JSValueToStringCopy ( context , js_result , NULL ) ; js_result_size = JSStringGetMaximumUTF8CStringSize ( js_result_string ) ; if ( js_result_size ) { char js_result_utf8 [ js_result_size ] ; JSStringGetUTF8CString ( js_result_string , js_result_utf8 , js_result_size ) ; g_string_assign ( result , js_result_utf8 ) ; } JSStringRelease ( js_result_string ) ; } <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> JSStringRelease ( var_name ) ; JSStringRelease ( js_script ) ; }",; JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef js_script <S2SV_ModStart> JSContextGetGlobalObject ( context <S2SV_ModEnd> ) ; js_script <S2SV_ModStart> ) ; } <S2SV_ModEnd> JSStringRelease ( js_script
432,"static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ; <S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , ""mdmp_directory.offset"" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , ""mdmp_directory.format"" , ""[4]E?<S2SV_blank>"" ""(mdmp_stream_type)StreamType<S2SV_blank>"" ""(mdmp_location_descriptor)Location"" , 0 ) ; <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> } return true ; }","int i ; struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set ( <S2SV_ModStart> 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ++ ) { ut32 delta = <S2SV_ModEnd> i * sizeof <S2SV_ModStart> struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> ) ) ; if ( r ) { <S2SV_ModStart> ( obj , & <S2SV_ModStart> entry ) ; }"
433,"int vp8_encode_intra ( VP8_COMP * cpi , MACROBLOCK * x , int use_dc_pred ) { int i ; int intra_pred_var = 0 ; ( void ) cpi ; if ( use_dc_pred ) { x -> e_mbd . mode_info_context -> mbmi . mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; vp8_encode_intra16x16mby ( x ) ; vp8_inverse_transform_mby ( & x -> e_mbd ) ; } else { for ( i = 0 ; i < 16 ; i ++ ) { x -> e_mbd . block [ i ] . bmi . as_mode = B_DC_PRED ; vp8_encode_intra4x4block ( x , i ) ; } } <S2SV_StartBug> intra_pred_var = vp8_get_mb_ss ( x -> src_diff ) ; <S2SV_EndBug> return intra_pred_var ; }",} intra_pred_var = vpx_get_mb_ss <S2SV_ModEnd> ( x ->
434,"void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; pocstruct_t * ps_prev_poc , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size ) ; ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec -> ps_dec_err_status -> u1_err_flag = ACCEPT_ALL_PICS ; ps_dec -> ps_dec_err_status -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; ps_dec -> ps_dec_err_status -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; ps_dec -> ps_dec_err_status -> u4_cur_frm = INIT_FRAME ; ps_dec -> ps_dec_err_status -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; ps_dec -> u1_pr_sl_type = 0xFF ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_prev_poc = & ps_dec -> s_prev_pic_poc ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb = 0 ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_top_field_order_count = ps_cur_poc -> i4_top_field_order_count = 0 ; ps_prev_poc -> i4_bottom_field_order_count = ps_cur_poc -> i4_bottom_field_order_count = 0 ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst = 0 ; ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = 0 ; ps_dec -> i4_max_poc = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> u1_recon_mb_grp = 4 ; ps_dec -> u1_second_field = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; ps_dec -> u2_crop_offset_y = 0 ; ps_dec -> u2_crop_offset_uv = 0 ; ps_dec -> i4_vui_frame_rate = - 1 ; ps_dec -> i4_pic_type = - 1 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u1_res_changed = 0 ; ps_dec -> u1_frame_decoded_flag = 0 ; ps_dec -> u4_skip_frm_mask = SKIP_NONE ; ps_dec -> pf_cavlc_4x4res_block [ 0 ] = ih264d_cavlc_4x4res_block_totalcoeff_1 ; ps_dec -> pf_cavlc_4x4res_block [ 1 ] = ih264d_cavlc_4x4res_block_totalcoeff_2to10 ; ps_dec -> pf_cavlc_4x4res_block [ 2 ] = ih264d_cavlc_4x4res_block_totalcoeff_11to16 ; ps_dec -> pf_cavlc_parse4x4coeff [ 0 ] = ih264d_cavlc_parse4x4coeff_n0to7 ; ps_dec -> pf_cavlc_parse4x4coeff [ 1 ] = ih264d_cavlc_parse4x4coeff_n8 ; ps_dec -> pf_cavlc_parse_8x8block [ 0 ] = ih264d_cavlc_parse_8x8block_none_available ; ps_dec -> pf_cavlc_parse_8x8block [ 1 ] = ih264d_cavlc_parse_8x8block_left_available ; ps_dec -> pf_cavlc_parse_8x8block [ 2 ] = ih264d_cavlc_parse_8x8block_top_available ; ps_dec -> pf_cavlc_parse_8x8block [ 3 ] = ih264d_cavlc_parse_8x8block_both_available ; ps_dec -> pf_fill_bs1 [ 0 ] [ 0 ] = ih264d_fill_bs1_16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 0 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 0 ] = ih264d_fill_bs1_16x16mb_bslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_bslice ; ps_dec -> pf_fill_bs_xtra_left_edge [ 0 ] = ih264d_fill_bs_xtra_left_edge_cur_frm ; ps_dec -> pf_fill_bs_xtra_left_edge [ 1 ] = ih264d_fill_bs_xtra_left_edge_cur_fld ; ih264d_init_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_dec -> u2_prv_frame_num = 0 ; ps_dec -> u1_top_bottom_decoded = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> s_cab_dec_env . cabac_table = gau4_ih264d_cabac_table ; ps_dec -> pu1_left_mv_ctxt_inc = ps_dec -> u1_left_mv_ctxt_inc_arr [ 0 ] ; ps_dec -> pi1_left_ref_idx_ctxt_inc = & ps_dec -> i1_left_ref_idx_ctx_inc_arr [ 0 ] [ 0 ] ; ps_dec -> pu1_left_yuv_dc_csbp = & ps_dec -> u1_yuv_dc_csbp_topmb ; ps_dec -> u1_flushfrm = 0 ; { ps_dec -> s_cab_dec_env . pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_bitstrm -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_cur_slice -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ( void * ) ps_dec ; } memset ( ps_dec -> disp_bufs , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( disp_buf_t ) ) ; memset ( ps_dec -> u4_disp_buf_mapping , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; memset ( ps_dec -> u4_disp_buf_to_be_freed , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; <S2SV_StartBug> ih264d_init_arch ( ps_dec ) ; <S2SV_EndBug> ih264d_init_function_ptr ( ps_dec ) ; ps_dec -> e_frm_out_mode = IVD_DISPLAY_FRAME_OUT ; ps_dec -> init_done = 1 ; }",") ) ; memset ( ps_dec -> ps_cur_slice , 0 , sizeof ( dec_slice_params_t ) ) ;"
435,"bt_status_t btif_dm_pin_reply ( const bt_bdaddr_t * bd_addr , uint8_t accept , uint8_t pin_len , bt_pin_code_t * pin_code ) { BTIF_TRACE_EVENT ( ""%s:<S2SV_blank>accept=%d"" , __FUNCTION__ , accept ) ; <S2SV_StartBug> if ( pin_code == NULL ) <S2SV_EndBug> return BT_STATUS_FAIL ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) if ( pairing_cb . is_le_only ) { int i ; UINT32 passkey = 0 ; int multi [ ] = { 100000 , 10000 , 1000 , 100 , 10 , 1 } ; BD_ADDR remote_bd_addr ; bdcpy ( remote_bd_addr , bd_addr -> address ) ; for ( i = 0 ; i < 6 ; i ++ ) { passkey += ( multi [ i ] * ( pin_code -> pin [ i ] - '0' ) ) ; } BTIF_TRACE_DEBUG ( ""btif_dm_pin_reply:<S2SV_blank>passkey:<S2SV_blank>%d"" , passkey ) ; BTA_DmBlePasskeyReply ( remote_bd_addr , accept , passkey ) ; } else { BTA_DmPinReply ( ( UINT8 * ) bd_addr -> address , accept , pin_len , pin_code -> pin ) ; if ( accept ) pairing_cb . pin_code_len = pin_len ; } # else BTA_DmPinReply ( ( UINT8 * ) bd_addr -> address , accept , pin_len , pin_code -> pin ) ; if ( accept ) pairing_cb . pin_code_len = pin_len ; # endif return BT_STATUS_SUCCESS ; }",pin_code == NULL || pin_len > PIN_CODE_LEN
436,"static ssize_t get_node_path_locked ( struct node * node , char * buf , size_t bufsize ) { const char * name ; size_t namelen ; if ( node -> graft_path ) { name = node -> graft_path ; namelen = node -> graft_pathlen ; } else if ( node -> actual_name ) { name = node -> actual_name ; namelen = node -> namelen ; } else { name = node -> name ; namelen = node -> namelen ; } if ( bufsize < namelen + 1 ) { return - 1 ; } ssize_t pathlen = 0 ; if ( node -> parent && node -> graft_path == NULL ) { <S2SV_StartBug> pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ; <S2SV_EndBug> if ( pathlen < 0 ) { return - 1 ; } buf [ pathlen ++ ] = '/' ; } memcpy ( buf + pathlen , name , namelen + 1 ) ; return pathlen + namelen ; }",- namelen - 1 <S2SV_ModEnd> ) ; if
437,"int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || <S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","& ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> , & bcount <S2SV_ModStart> || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line <S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) {"
438,"static vpx_codec_err_t vp8e_mr_alloc_mem ( const vpx_codec_enc_cfg_t * cfg , void * * mem_loc ) { vpx_codec_err_t res = 0 ; # if CONFIG_MULTI_RES_ENCODING LOWER_RES_FRAME_INFO * shared_mem_loc ; int mb_rows = ( ( cfg -> g_w + 15 ) >> 4 ) ; int mb_cols = ( ( cfg -> g_h + 15 ) >> 4 ) ; shared_mem_loc = calloc ( 1 , sizeof ( LOWER_RES_FRAME_INFO ) ) ; if ( ! shared_mem_loc ) { res = VPX_CODEC_MEM_ERROR ; } shared_mem_loc -> mb_info = calloc ( mb_rows * mb_cols , sizeof ( LOWER_RES_MB_INFO ) ) ; if ( ! ( shared_mem_loc -> mb_info ) ) { res = VPX_CODEC_MEM_ERROR ; } else { * mem_loc = ( void * ) shared_mem_loc ; res = VPX_CODEC_OK ; } <S2SV_StartBug> # endif <S2SV_EndBug> return res ; }",; } # else ( void ) cfg ; ( void ) mem_loc ; #
439,"static int keyring_search_iterator ( const void * object , void * iterator_data ) { struct keyring_search_context * ctx = iterator_data ; const struct key * key = keyring_ptr_to_key ( object ) ; <S2SV_StartBug> unsigned long kflags = key -> flags ; <S2SV_EndBug> kenter ( ""{%d}"" , key -> serial ) ; if ( key -> type != ctx -> index_key . type ) { kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[!type]"" ) ; return 0 ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { if ( kflags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) ) ) { ctx -> result = ERR_PTR ( - EKEYREVOKED ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[invrev]"" , ctx -> skipped_ret ) ; goto skipped ; } if ( key -> expiry && ctx -> now . tv_sec >= key -> expiry ) { if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( - EKEYEXPIRED ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[expire]"" , ctx -> skipped_ret ) ; goto skipped ; } } if ( ! ctx -> match_data . cmp ( key , & ctx -> match_data ) ) { kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[!match]"" ) ; return 0 ; } if ( ! ( ctx -> flags & KEYRING_SEARCH_NO_CHECK_PERM ) && key_task_permission ( make_key_ref ( key , ctx -> possessed ) , ctx -> cred , KEY_NEED_SEARCH ) < 0 ) { ctx -> result = ERR_PTR ( - EACCES ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[!perm]"" , ctx -> skipped_ret ) ; goto skipped ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { <S2SV_StartBug> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <S2SV_EndBug> smp_rmb ( ) ; <S2SV_StartBug> ctx -> result = ERR_PTR ( key -> reject_error ) ; <S2SV_EndBug> kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]"" , ctx -> skipped_ret ) ; goto skipped ; } } ctx -> result = make_key_ref ( key , ctx -> possessed ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>1<S2SV_blank>[found]"" ) ; return 1 ; skipped : return ctx -> skipped_ret ; }",long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( <S2SV_ModStart> { if ( state < 0 ) { <S2SV_ModEnd> ctx -> result <S2SV_ModStart> = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave
440,"int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) { if ( fmtp == NULL ) return VLC_EGENERIC ; char * start = strstr ( fmtp , ""configuration="" ) ; assert ( start != NULL ) ; start += sizeof ( ""configuration="" ) - 1 ; char * end = strchr ( start , ';' ) ; assert ( end != NULL ) ; size_t len = end - start ; <S2SV_StartBug> char b64 [ len + 1 ] ; <S2SV_EndBug> memcpy ( b64 , start , len ) ; b64 [ len ] = '\\0' ; int i_max = rtp_mtu ( id ) - 6 ; uint8_t * p_orig , * p_data ; int i_data ; <S2SV_StartBug> i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ; <S2SV_EndBug> if ( i_data <= 9 ) { free ( p_orig ) ; return VLC_EGENERIC ; } p_data = p_orig + 9 ; i_data -= 9 ; int i_count = ( i_data + i_max - 1 ) / i_max ; for ( int i = 0 ; i < i_count ; i ++ ) { int i_payload = __MIN ( i_max , i_data ) ; block_t * out = block_Alloc ( 18 + i_payload ) ; unsigned fragtype , numpkts ; if ( i_count == 1 ) { fragtype = 0 ; numpkts = 1 ; } else { numpkts = 0 ; if ( i == 0 ) fragtype = 1 ; else if ( i == i_count - 1 ) fragtype = 3 ; else fragtype = 2 ; } uint32_t header = ( ( XIPH_IDENT & 0xffffff ) << 8 ) | ( fragtype << 6 ) | ( 1 << 4 ) | numpkts ; rtp_packetize_common ( id , out , 0 , i_pts ) ; SetDWBE ( out -> p_buffer + 12 , header ) ; SetWBE ( out -> p_buffer + 16 , i_payload ) ; memcpy ( & out -> p_buffer [ 18 ] , p_data , i_payload ) ; out -> i_dts = i_pts ; rtp_packetize_send ( id , out ) ; p_data += i_payload ; i_data -= i_payload ; } free ( p_orig ) ; return VLC_SUCCESS ; }","start ; char * b64 = malloc ( <S2SV_ModEnd> len + 1 <S2SV_ModStart> len + 1 ) ; if ( ! b64 ) return VLC_EGENERIC <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> & p_orig , b64 ) ; free ("
441,"u_int fr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { int ret ; uint16_t extracted_ethertype ; u_int dlci ; u_int addr_len ; uint16_t nlpid ; u_int hdr_len ; uint8_t flags [ 4 ] ; ret = parse_q922_addr ( ndo , p , & dlci , & addr_len , flags , length ) ; if ( ret == - 1 ) goto trunc ; if ( ret == 0 ) { ND_PRINT ( ( ndo , ""Q.922,<S2SV_blank>invalid<S2SV_blank>address"" ) ) ; return 0 ; } ND_TCHECK ( p [ addr_len ] ) ; if ( length < addr_len + 1 ) goto trunc ; if ( p [ addr_len ] != LLC_UI && dlci != 0 ) { if ( ! ND_TTEST2 ( p [ addr_len ] , 2 ) || length < addr_len + 2 ) { ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; } else { extracted_ethertype = EXTRACT_16BITS ( p + addr_len ) ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , extracted_ethertype ) ; if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; else return addr_len + 2 ; } } ND_TCHECK ( p [ addr_len + 1 ] ) ; if ( length < addr_len + 2 ) goto trunc ; if ( p [ addr_len + 1 ] == 0 ) { if ( addr_len != 3 ) ND_PRINT ( ( ndo , ""Pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 + 1 ; } else { if ( addr_len == 3 ) ND_PRINT ( ( ndo , ""No<S2SV_blank>pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 ; } ND_TCHECK ( p [ hdr_len - 1 ] ) ; if ( length < hdr_len ) goto trunc ; nlpid = p [ hdr_len - 1 ] ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , nlpid ) ; p += hdr_len ; length -= hdr_len ; switch ( nlpid ) { case NLPID_IP : ip_print ( ndo , p , length ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p , length ) ; break ; case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : <S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug> break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , addr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p , length ) ; } return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|fr]"" ) ) ; return 0 ; }","length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> ndo_snapend - p <S2SV_ModEnd> , NULL ,"
442,"void SWFShape_setLeftFillStyle ( SWFShape shape , SWFFillStyle fill ) { ShapeRecord record ; int idx ; if ( shape -> isEnded || shape -> isMorph ) return ; if ( fill == NOFILL ) { record = addStyleRecord ( shape ) ; record . record . stateChange -> leftFill = 0 ; record . record . stateChange -> flags |= SWF_SHAPE_FILLSTYLE0FLAG ; return ; } idx = getFillIdx ( shape , fill ) ; if ( idx == 0 ) { SWFFillStyle_addDependency ( fill , ( SWFCharacter ) shape ) ; if ( addFillStyle ( shape , fill ) < 0 ) return ; idx = getFillIdx ( shape , fill ) ; } <S2SV_StartBug> record = addStyleRecord ( shape ) ; <S2SV_EndBug> record . record . stateChange -> leftFill = idx ; record . record . stateChange -> flags |= SWF_SHAPE_FILLSTYLE0FLAG ; }",") ; } else if ( idx >= 255 && shape -> useVersion == SWF_SHAPE1 ) { SWF_error ( ""Too<S2SV_blank>many<S2SV_blank>fills<S2SV_blank>for<S2SV_blank>SWFShape<S2SV_blank>V1.\\n"" ""Use<S2SV_blank>a<S2SV_blank>higher<S2SV_blank>SWFShape<S2SV_blank>version\\n"" ) ; }"
443,"static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }",sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
444,"void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( ! mp ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; <S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else"
445,"int vp8_get_preview_raw_frame ( VP8_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp8_ppflags_t * flags ) { if ( cpi -> common . refresh_alt_ref_frame ) return - 1 ; else { int ret ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif # if CONFIG_POSTPROC cpi -> common . show_frame_mi = cpi -> common . mi ; ret = vp8_post_proc_frame ( & cpi -> common , dest , flags ) ; # else <S2SV_StartBug> if ( cpi -> common . frame_to_show ) <S2SV_EndBug> { * dest = * cpi -> common . frame_to_show ; dest -> y_width = cpi -> common . Width ; dest -> y_height = cpi -> common . Height ; dest -> uv_height = cpi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; } }",; # else ( void ) flags ;
446,"static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }",{ rq = <S2SV_ModEnd> hctx -> tags <S2SV_ModStart> hctx -> tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; if (
447,"static void pick_quickcompress_mode ( vpx_codec_alg_priv_t * ctx , unsigned long duration , unsigned long deadline ) { <S2SV_StartBug> MODE new_qc = MODE_BESTQUALITY ; <S2SV_EndBug> <S2SV_StartBug> if ( deadline ) { <S2SV_EndBug> const uint64_t duration_us = ( uint64_t ) duration * 1000000 * <S2SV_StartBug> ( uint64_t ) ctx -> cfg . g_timebase . num / <S2SV_EndBug> <S2SV_StartBug> ( uint64_t ) ctx -> cfg . g_timebase . den ; <S2SV_EndBug> <S2SV_StartBug> new_qc = ( deadline > duration_us ) ? MODE_GOODQUALITY : MODE_REALTIME ; <S2SV_EndBug> } if ( ctx -> cfg . g_pass == VPX_RC_FIRST_PASS ) new_qc = MODE_FIRSTPASS ; else if ( ctx -> cfg . g_pass == VPX_RC_LAST_PASS ) new_qc = ( new_qc == MODE_BESTQUALITY ) ? MODE_SECONDPASS_BEST : MODE_SECONDPASS ; <S2SV_StartBug> if ( ctx -> oxcf . mode != new_qc ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> oxcf . mode = new_qc ; <S2SV_EndBug> vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; } }",) { MODE new_mode = BEST ; switch ( ctx -> cfg . g_pass ) { case VPX_RC_ONE_PASS : <S2SV_ModEnd> if ( deadline <S2SV_ModStart> if ( deadline > 0 ) { const vpx_codec_enc_cfg_t * const cfg = & ctx -> cfg ; <S2SV_ModEnd> const uint64_t duration_us <S2SV_ModStart> ( uint64_t ) cfg -> <S2SV_ModEnd> g_timebase . num <S2SV_ModStart> ( uint64_t ) cfg -> <S2SV_ModEnd> g_timebase . den <S2SV_ModStart> . den ; new_mode <S2SV_ModEnd> = ( deadline <S2SV_ModStart> duration_us ) ? GOOD : REALTIME ; } else { new_mode = BEST ; } break ; case VPX_RC_FIRST_PASS : break ; case VPX_RC_LAST_PASS : new_mode = deadline > 0 ? GOOD : BEST ; break ; } <S2SV_ModEnd> if ( ctx <S2SV_ModStart> . mode != new_mode <S2SV_ModEnd> ) { ctx <S2SV_ModStart> . mode = new_mode <S2SV_ModEnd> ; vp9_change_config (
448,"<S2SV_StartBug> static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) { <S2SV_EndBug> int i ; const double minqtarget = MIN ( ( ( x3 * maxq + x2 ) * maxq + x1 ) * maxq , maxq ) ; if ( minqtarget <= 2.0 ) return 0 ; <S2SV_StartBug> for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) <S2SV_EndBug> <S2SV_StartBug> return i ; <S2SV_EndBug> return QINDEX_RANGE - 1 ; }",", double x1 , vpx_bit_depth_t bit_depth <S2SV_ModStart> i ++ ) { <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> return i ; }"
449,"static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_EndBug> bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( ( MagickSizeType ) length / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"""
450,"static void show_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> if ( info -> flags & REV_LIST_QUIET ) return ; <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> }","* obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> ( obj , name <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> , obj , name <S2SV_ModEnd> ) ; }"
451,"static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; <S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( newnp -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }","( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> -> hop_limit ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> np -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( opt <S2SV_ModEnd> ) inet_csk ( <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; dccp_sync_mss ("
452,"sctp_disposition_t sctp_sf_ootb ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sk_buff * skb = chunk -> skb ; sctp_chunkhdr_t * ch ; sctp_errhdr_t * err ; __u8 * ch_end ; int ootb_shut_ack = 0 ; int ootb_cookie_ack = 0 ; SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; ch = ( sctp_chunkhdr_t * ) chunk -> chunk_hdr ; do { if ( ntohs ( ch -> length ) < sizeof ( sctp_chunkhdr_t ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; <S2SV_StartBug> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) <S2SV_EndBug> ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } } ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ; if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; <S2SV_StartBug> ch = ( sctp_chunkhdr_t * ) ch_end ; <S2SV_EndBug> } while ( ch_end < skb_tail_pointer ( skb ) ) ; if ( ootb_shut_ack ) return sctp_sf_shut_8_4_5 ( net , ep , asoc , type , arg , commands ) ; else if ( ootb_cookie_ack ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; else return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; }","commands ) ; <S2SV_ModEnd> ch_end = ( <S2SV_ModStart> commands ) ; if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } }"
453,"static int snd_ctl_tlv_ioctl ( struct snd_ctl_file * file , struct snd_ctl_tlv __user * _tlv , int op_flag ) { struct snd_card * card = file -> card ; struct snd_ctl_tlv tlv ; struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int len ; int err = 0 ; if ( copy_from_user ( & tlv , _tlv , sizeof ( tlv ) ) ) return - EFAULT ; if ( tlv . length < sizeof ( unsigned int ) * 2 ) return - EINVAL ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_numid ( card , tlv . numid ) ; if ( kctl == NULL ) { err = - ENOENT ; goto __kctl_end ; } if ( kctl -> tlv . p == NULL ) { err = - ENXIO ; goto __kctl_end ; } vd = & kctl -> vd [ tlv . numid - kctl -> id . numid ] ; if ( ( op_flag == 0 && ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_READ ) == 0 ) || ( op_flag > 0 && ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE ) == 0 ) || ( op_flag < 0 && ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND ) == 0 ) ) { err = - ENXIO ; goto __kctl_end ; } if ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ) { if ( vd -> owner != NULL && vd -> owner != file ) { err = - EPERM ; goto __kctl_end ; } err = kctl -> tlv . c ( kctl , op_flag , tlv . length , _tlv -> tlv ) ; if ( err > 0 ) { <S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ; <S2SV_EndBug> return 0 ; } } else { if ( op_flag ) { err = - ENXIO ; goto __kctl_end ; } len = kctl -> tlv . p [ 1 ] + 2 * sizeof ( unsigned int ) ; if ( tlv . length < len ) { err = - ENOMEM ; goto __kctl_end ; } if ( copy_to_user ( _tlv -> tlv , kctl -> tlv . p , len ) ) err = - EFAULT ; } __kctl_end : up_read ( & card -> controls_rwsem ) ; return err ; }","0 ) { struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart> SNDRV_CTL_EVENT_MASK_TLV , & <S2SV_ModEnd> id ) ;"
454,"static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( ""Boot<S2SV_blank>sector<S2SV_blank>contents:\\n"" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( ""System<S2SV_blank>ID<S2SV_blank>\\""%s\\""\\n"" , id ) ; } else { printf ( ""Serial<S2SV_blank>number<S2SV_blank>0x%x\\n"" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( ""Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\n"" , b -> media , get_media_descr ( b -> media ) ) ; printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\n"" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\n"" , fs -> cluster_size ) ; printf ( ""%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\n"" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? """" : ""s"" ) ; printf ( ""First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n"" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( ""%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\n"" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n"" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( ""Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n"" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( ""%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\n"" , fs -> root_entries ) ; } else { printf ( ""Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\n"" , ( unsigned long ) fs -> root_cluster ) ; } printf ( ""Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n"" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( ""%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\n"" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( ""%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\n"" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( ""%10u<S2SV_blank>hidden<S2SV_blank>sectors\\n"" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( ""%10u<S2SV_blank>sectors<S2SV_blank>total\\n"" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }","; printf ( ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n"" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )"
455,"static long media_device_enum_entities ( struct media_device * mdev , struct media_entity_desc __user * uent ) { struct media_entity * ent ; struct media_entity_desc u_ent ; <S2SV_StartBug> if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) <S2SV_EndBug> return - EFAULT ; ent = find_entity ( mdev , u_ent . id ) ; if ( ent == NULL ) return - EINVAL ; u_ent . id = ent -> id ; if ( ent -> name ) { strncpy ( u_ent . name , ent -> name , sizeof ( u_ent . name ) ) ; u_ent . name [ sizeof ( u_ent . name ) - 1 ] = '\\0' ; } else { memset ( u_ent . name , 0 , sizeof ( u_ent . name ) ) ; } u_ent . type = ent -> type ; u_ent . revision = ent -> revision ; u_ent . flags = ent -> flags ; u_ent . group_id = ent -> group_id ; u_ent . pads = ent -> num_pads ; u_ent . links = ent -> num_links - ent -> num_backlinks ; memcpy ( & u_ent . raw , & ent -> info , sizeof ( ent -> info ) ) ; if ( copy_to_user ( uent , & u_ent , sizeof ( u_ent ) ) ) return - EFAULT ; return 0 ; }","media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;"
456,"static void sycc444_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> int offset , upb ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < max ; ++ i ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ cb ; ++ cr ; ++ r ; ++ g ; ++ b ; } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> return ; <S2SV_EndBug> fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> if ( g ) free ( g ) ; if ( b ) free ( b ) ; }","* cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b"
457,"static int fst_get_iface ( struct fst_card_info * card , struct fst_port_info * port , struct ifreq * ifr ) { sync_serial_settings sync ; int i ; switch ( port -> hwif ) { case E1 : ifr -> ifr_settings . type = IF_IFACE_E1 ; break ; case T1 : ifr -> ifr_settings . type = IF_IFACE_T1 ; break ; case V35 : ifr -> ifr_settings . type = IF_IFACE_V35 ; break ; case V24 : ifr -> ifr_settings . type = IF_IFACE_V24 ; break ; case X21D : ifr -> ifr_settings . type = IF_IFACE_X21D ; break ; case X21 : default : ifr -> ifr_settings . type = IF_IFACE_X21 ; break ; } if ( ifr -> ifr_settings . size == 0 ) { return 0 ; } if ( ifr -> ifr_settings . size < sizeof ( sync ) ) { return - ENOMEM ; } i = port -> index ; <S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ; sync . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & sync , sizeof ( sync ) ) ) { return - EFAULT ; } ifr -> ifr_settings . size = sizeof ( sync ) ; return 0 ; }","-> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;"
458,"static int read_header ( FFV1Context * f ) { uint8_t state [ CONTEXT_SIZE ] ; int i , j , context_count = - 1 ; RangeCoder * const c = & f -> slice_context [ 0 ] -> c ; memset ( state , 128 , sizeof ( state ) ) ; if ( f -> version < 2 ) { <S2SV_StartBug> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_EndBug> unsigned v = get_symbol ( c , state , 0 ) ; if ( v >= 2 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\n"" , v ) ; return AVERROR_INVALIDDATA ; } f -> version = v ; f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ; if ( f -> ac > 1 ) { for ( i = 1 ; i < 256 ; i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ; } <S2SV_StartBug> f -> colorspace = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( f -> version > 0 ) <S2SV_EndBug> <S2SV_StartBug> f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; if ( f -> plane_count ) { <S2SV_StartBug> if ( chroma_planes != f -> chroma_planes <S2SV_EndBug> || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } <S2SV_EndBug> f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency ; f -> plane_count = 2 + f -> transparency ; } if ( f -> colorspace == 0 ) { if ( ! f -> transparency && ! f -> chroma_planes ) { if ( f -> avctx -> bits_per_raw_sample <= 8 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } else if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; break ; case 0x01 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; break ; case 0x20 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P ; break ; case 0x22 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 9 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 10 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""format<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } } else if ( f -> colorspace == 1 ) { if ( f -> chroma_h_shift || f -> chroma_v_shift ) { av_log ( f -> avctx , AV_LOG_ERROR , ""chroma<S2SV_blank>subsampling<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>colorspace\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( f -> avctx -> bits_per_raw_sample == 9 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9 ; else if ( f -> avctx -> bits_per_raw_sample == 10 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10 ; else if ( f -> avctx -> bits_per_raw_sample == 12 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12 ; else if ( f -> avctx -> bits_per_raw_sample == 14 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14 ; else if ( f -> transparency ) f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32 ; } else { av_log ( f -> avctx , AV_LOG_ERROR , ""colorspace<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; return AVERROR ( ENOSYS ) ; } av_dlog ( f -> avctx , ""%d<S2SV_blank>%d<S2SV_blank>%d\\n"" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ) ; if ( f -> version < 2 ) { context_count = read_quant_tables ( c , f -> quant_table ) ; if ( context_count < 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""read_quant_table<S2SV_blank>error\\n"" ) ; return AVERROR_INVALIDDATA ; } } else if ( f -> version < 3 ) { f -> slice_count = get_symbol ( c , state , 0 ) ; } else { const uint8_t * p = c -> bytestream_end ; for ( f -> slice_count = 0 ; f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start ; f -> slice_count ++ ) { int trailer = 3 + 5 * ! ! f -> ec ; int size = AV_RB24 ( p - trailer ) ; if ( size + trailer > p - c -> bytestream_start ) break ; p -= size + trailer ; } } if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>count<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , f -> slice_count ) ; return AVERROR_INVALIDDATA ; } for ( j = 0 ; j < f -> slice_count ; j ++ ) { FFV1Context * fs = f -> slice_context [ j ] ; fs -> ac = f -> ac ; fs -> packed_at_lsb = f -> packed_at_lsb ; fs -> slice_damaged = 0 ; if ( f -> version == 2 ) { fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width ; fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height ; fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x ; fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y ; fs -> slice_x /= f -> num_h_slices ; fs -> slice_y /= f -> num_v_slices ; fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x ; fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y ; if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < f -> plane_count ; i ++ ) { PlaneContext * const p = & fs -> plane [ i ] ; if ( f -> version == 2 ) { int idx = get_symbol ( c , state , 0 ) ; if ( idx > ( unsigned ) f -> quant_table_count ) { av_log ( f -> avctx , AV_LOG_ERROR , ""quant_table_index<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" ) ; return AVERROR_INVALIDDATA ; } p -> quant_table_index = idx ; memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ) ; context_count = f -> context_count [ idx ] ; } else { memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ) ; } if ( f -> version <= 2 ) { av_assert0 ( context_count >= 0 ) ; if ( p -> context_count < context_count ) { av_freep ( & p -> state ) ; av_freep ( & p -> vlc_state ) ; } p -> context_count = context_count ; } } } return 0 ; }","chroma_v_shift , transparency , colorspace , bits_per_raw_sample <S2SV_ModStart> ] ; } <S2SV_ModEnd> colorspace = get_symbol <S2SV_ModStart> 0 ) ; bits_per_raw_sample = <S2SV_ModEnd> f -> version <S2SV_ModStart> version > 0 ? get_symbol ( c , state , 0 ) : <S2SV_ModEnd> f -> avctx <S2SV_ModStart> avctx -> bits_per_raw_sample ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModStart> 0 ) ; chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency <S2SV_ModEnd> = get_rac ( <S2SV_ModStart> state ) ; <S2SV_ModEnd> if ( f <S2SV_ModStart> { if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> ; } } f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;"
459,int fscrypt_get_encryption_info ( struct inode * inode ) { <S2SV_StartBug> struct fscrypt_info * ci = inode -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ci || <S2SV_EndBug> ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ) return fscrypt_get_crypt_info ( inode ) ; return 0 ; },"struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> inode -> i_crypt_info <S2SV_ModStart> inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n"" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null>"
460,"<S2SV_StartBug> static void update_skip_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> int k ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ; <S2SV_EndBug> }","* cm , vpx_writer * w , FRAME_COUNTS * counts <S2SV_ModEnd> ) { int <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> skip_probs [ k <S2SV_ModStart> k ] , counts -> <S2SV_ModEnd> skip [ k"
461,"asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( regs , insn ) ; int orig_asi , asi ; current_thread_info ( ) -> kern_una_regs = regs ; current_thread_info ( ) -> kern_una_insn = insn ; orig_asi = asi = decode_asi ( insn , regs ) ; if ( asi == ASI_AIUS ) { kernel_mna_trap_fault ( 0 ) ; return ; } log_unaligned ( regs ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""Unsupported<S2SV_blank>unaligned<S2SV_blank>load/store<S2SV_blank>trap<S2SV_blank>for<S2SV_blank>kernel<S2SV_blank>"" ""at<S2SV_blank><%016lx>.\\n"" , regs -> tpc ) ; unaligned_panic ( ""Kernel<S2SV_blank>does<S2SV_blank>fpu/atomic<S2SV_blank>"" ""unaligned<S2SV_blank>load/store."" , regs ) ; kernel_mna_trap_fault ( 0 ) ; } else { unsigned long addr , * reg_addr ; int err ; addr = compute_effective_address ( regs , insn , ( ( insn >> 25 ) & 0x1f ) ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> switch ( asi ) { case ASI_NL : case ASI_AIUPL : case ASI_AIUSL : case ASI_PL : case ASI_SL : case ASI_PNFL : case ASI_SNFL : asi &= ~ 0x08 ; break ; } switch ( dir ) { case load : reg_addr = fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) ; err = do_int_load ( reg_addr , size , ( unsigned long * ) addr , decode_signedness ( insn ) , asi ) ; if ( likely ( ! err ) && unlikely ( asi != orig_asi ) ) { unsigned long val_in = * reg_addr ; switch ( size ) { case 2 : val_in = swab16 ( val_in ) ; break ; case 4 : val_in = swab32 ( val_in ) ; break ; case 8 : val_in = swab64 ( val_in ) ; break ; case 16 : default : BUG ( ) ; break ; } * reg_addr = val_in ; } break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs , asi , orig_asi ) ; break ; default : panic ( ""Impossible<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>trap."" ) ; } if ( unlikely ( err ) ) kernel_mna_trap_fault ( 1 ) ; else advance ( regs ) ; } }",", 1 , <S2SV_ModEnd> regs , addr"
462,"static void * bpf_obj_do_get ( const struct filename * pathname , enum bpf_type * type ) { struct inode * inode ; struct path path ; void * raw ; int ret ; ret = kern_path ( pathname -> name , LOOKUP_FOLLOW , & path ) ; if ( ret ) return ERR_PTR ( ret ) ; inode = d_backing_inode ( path . dentry ) ; ret = inode_permission ( inode , MAY_WRITE ) ; if ( ret ) goto out ; ret = bpf_inode_type ( inode , type ) ; if ( ret ) goto out ; raw = bpf_any_get ( inode -> i_private , * type ) ; <S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> path_put ( & path ) ; return raw ; out : path_put ( & path ) ; return ERR_PTR ( ret ) ; }",type ) ; if ( ! IS_ERR ( raw ) )
463,"static VTermScreen * screen_new ( VTerm * vt ) { VTermState * state = vterm_obtain_state ( vt ) ; VTermScreen * screen ; int rows , cols ; <S2SV_StartBug> if ( ! state ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> screen = vterm_allocator_malloc ( vt , sizeof ( VTermScreen ) ) ; <S2SV_EndBug> vterm_get_size ( vt , & rows , & cols ) ; screen -> vt = vt ; screen -> state = state ; screen -> damage_merge = VTERM_DAMAGE_CELL ; screen -> damaged . start_row = - 1 ; screen -> pending_scrollrect . start_row = - 1 ; screen -> rows = rows ; screen -> cols = cols ; screen -> callbacks = NULL ; screen -> cbdata = NULL ; screen -> buffers [ 0 ] = realloc_buffer ( screen , NULL , rows , cols ) ; screen -> buffer = screen -> buffers [ 0 ] ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( VTermScreenCell ) * cols ) ; <S2SV_StartBug> vterm_state_set_callbacks ( screen -> state , & state_cbs , screen ) ; <S2SV_EndBug> return screen ; }",; if ( state == NULL <S2SV_ModEnd> ) return NULL <S2SV_ModStart> VTermScreen ) ) ; if ( screen == NULL ) return NULL <S2SV_ModStart> cols ) ; if ( screen -> buffer == NULL || screen -> sb_buffer == NULL ) { vterm_screen_free ( screen ) ; return NULL ; }
464,"static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! IS_ERR ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ; <S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> } else { mntput ( m ) ; } return new_ns ; }",= mnt ; new_ns -> mounts ++ ;
465,"int encode_msg ( struct sip_msg * msg , char * payload , int len ) { int i , j , k , u , request ; unsigned short int h ; struct hdr_field * hf ; struct msg_start * ms ; struct sip_uri miuri ; char * myerror = NULL ; ptrdiff_t diff ; if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { myerror = ""in<S2SV_blank>parse_headers"" ; goto error ; } memset ( payload , 0 , len ) ; ms = & msg -> first_line ; if ( ms -> type == SIP_REQUEST ) request = 1 ; else if ( ms -> type == SIP_REPLY ) request = 0 ; else { myerror = ""message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response"" ; goto error ; } if ( request ) { for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ; } else { h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; } if ( h == 32 ) { myerror = ""unknown<S2SV_blank>message<S2SV_blank>type\\n"" ; goto error ; } h = htons ( h ) ; memcpy ( payload , & h , 2 ) ; h = htons ( ( unsigned short int ) msg -> len ) ; memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { myerror = ""body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)"" ; goto error ; } else h = htons ( ( unsigned short int ) diff ) ; memcpy ( payload + CONTENT_IDX , & h , 2 ) ; payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ; payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ; payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ; payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ; payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ; if ( request ) { if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { LM_ERR ( ""<%.*s>\\n"" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; myerror = ""while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI"" ; goto error ; } if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) { myerror = ""ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI"" ; goto error ; } payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; k = REQUEST_URI_IDX + 1 + j ; } else k = REQUEST_URI_IDX ; u = k ; k ++ ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; i ++ ; j = k + 3 * i ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; h = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & h , 2 ) ; if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { LM_ERR ( ""encoding<S2SV_blank>header<S2SV_blank>%.*s\\n"" , hf -> name . len , hf -> name . s ) ; goto error ; k -= 3 ; continue ; } j += ( unsigned short int ) i ; } payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; j = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & j , 2 ) ; k += 3 ; j = ntohs ( j ) ; <S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , msg -> len , j ) ; j = htons ( j ) ; memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; return GET_PAY_SIZE ( payload ) ; error : LM_ERR ( ""%s\\n"" , myerror ) ; return - 1 ; }","j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n"" ) ; return - 1 ; }"
466,"static int ipx_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct ipx_sock * ipxs = ipx_sk ( sk ) ; struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; struct ipxhdr * ipx = NULL ; struct sk_buff * skb ; int copied , rc ; lock_sock ( sk ) ; if ( ! ipxs -> port ) { struct sockaddr_ipx uaddr ; uaddr . sipx_port = 0 ; uaddr . sipx_network = 0 ; # ifdef CONFIG_IPX_INTERN rc = - ENETDOWN ; if ( ! ipxs -> intrfc ) goto out ; memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ) ; # endif rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ) ; if ( rc ) goto out ; } rc = - ENOTCONN ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ) ; if ( ! skb ) goto out ; ipx = ipx_hdr ( skb ) ; copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ) ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ) ; if ( rc ) goto out_free ; if ( skb -> tstamp . tv64 ) sk -> sk_stamp = skb -> tstamp ; <S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; } rc = copied ; out_free : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }","-> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc"
467,"static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= VHOST_NET_VQ_MAX ) { r = - ENOBUFS ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - EFAULT ; goto err_vq ; } sock = get_socket ( fd ) ; if ( IS_ERR ( sock ) ) { r = PTR_ERR ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( IS_ERR ( ubufs ) ) { r = PTR_ERR ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto err_used ; oldubufs = nvq -> ubufs ; nvq -> ubufs = ubufs ; n -> tx_packets = 0 ; n -> tx_zcopy_err = 0 ; n -> tx_flush = false ; } mutex_unlock ( & vq -> mutex ) ; if ( oldubufs ) { <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> mutex_lock ( & vq -> mutex ) ; vhost_zerocopy_signal_used ( n , vq ) ; mutex_unlock ( & vq -> mutex ) ; } if ( oldsock ) { vhost_net_flush_vq ( n , index ) ; fput ( oldsock -> file ) ; } mutex_unlock ( & n -> dev . mutex ) ; return 0 ; err_used : rcu_assign_pointer ( vq -> private_data , oldsock ) ; vhost_net_enable_vq ( n , vq ) ; if ( ubufs ) <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug> err_ubufs : fput ( sock -> file ) ; err_vq : mutex_unlock ( & vq -> mutex ) ; err : mutex_unlock ( & n -> dev . mutex ) ; return r ; }",oldubufs ) { vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( oldubufs ) <S2SV_ModStart> ( ubufs ) vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( ubufs )
468,"static ssize_t _consolefs_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! file || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ("
469,"NOEXPORT char * base64 ( int encode , const char * in , int len ) { BIO * bio , * b64 ; char * out ; int n ; b64 = BIO_new ( BIO_f_base64 ( ) ) ; if ( ! b64 ) return NULL ; BIO_set_flags ( b64 , BIO_FLAGS_BASE64_NO_NL ) ; bio = BIO_new ( BIO_s_mem ( ) ) ; if ( ! bio ) { <S2SV_StartBug> str_free ( b64 ) ; <S2SV_EndBug> return NULL ; } if ( encode ) bio = BIO_push ( b64 , bio ) ; BIO_write ( bio , in , len ) ; ( void ) BIO_flush ( bio ) ; if ( encode ) { bio = BIO_pop ( bio ) ; BIO_free ( b64 ) ; } else { bio = BIO_push ( b64 , bio ) ; } n = BIO_pending ( bio ) ; out = str_alloc ( n < 32 ? 32 : ( size_t ) n + 1 ) ; n = BIO_read ( bio , out , n ) ; if ( n < 0 ) { BIO_free_all ( bio ) ; str_free ( out ) ; return NULL ; } BIO_free_all ( bio ) ; return out ; }",bio ) { BIO_free <S2SV_ModEnd> ( b64 )
470,"void * jas_malloc ( size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\n"" , size ) ) ; <S2SV_EndBug> result = malloc ( size ) ; JAS_DBGLOG ( 100 , ( ""jas_malloc(%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , size , result ) ) ; return result ; }","101 , ( ""jas_malloc(%zu)\\n"" <S2SV_ModEnd> , size )"
471,"SYSCALL_DEFINE6 ( sendto , int , fd , void __user * , buff , size_t , len , unsigned int , flags , struct sockaddr __user * , addr , int , addr_len ) { struct socket * sock ; struct sockaddr_storage address ; int err ; struct msghdr msg ; struct iovec iov ; int fput_needed ; if ( len > INT_MAX ) <S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; iov . iov_base = buff ; iov . iov_len = len ; msg . msg_name = NULL ; iov_iter_init ( & msg . msg_iter , WRITE , & iov , 1 , len ) ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_namelen = 0 ; if ( addr ) { err = move_addr_to_kernel ( addr , addr_len , & address ) ; if ( err < 0 ) goto out_put ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = addr_len ; } if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; msg . msg_flags = flags ; err = sock_sendmsg ( sock , & msg , len ) ; out_put : fput_light ( sock -> file , fput_needed ) ; out : return err ; }","len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT"
472,"static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * ieee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx ; int err ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) return - EMSGSIZE ; ieee = nla_nest_start ( skb , DCB_ATTR_IEEE ) ; if ( ! ieee ) return - EMSGSIZE ; if ( ops -> ieee_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_getmaxrate ) { struct ieee_maxrate maxrate ; <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> if ( ! err ) { err = nla_put ( skb , DCB_ATTR_IEEE_MAXRATE , sizeof ( maxrate ) , & maxrate ) ; if ( err ) return - EMSGSIZE ; } } if ( ops -> ieee_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } app = nla_nest_start ( skb , DCB_ATTR_IEEE_APP_TABLE ) ; if ( ! app ) return - EMSGSIZE ; spin_lock ( & dcb_lock ) ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { err = nla_put ( skb , DCB_ATTR_IEEE_APP , sizeof ( itr -> app ) , & itr -> app ) ; if ( err ) { spin_unlock ( & dcb_lock ) ; return - EMSGSIZE ; } } } if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; nla_nest_end ( skb , app ) ; if ( ops -> ieee_peer_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_peer_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_IEEE_PEER_APP , DCB_ATTR_IEEE_APP_UNSPEC , DCB_ATTR_IEEE_APP ) ; if ( err ) return - EMSGSIZE ; } nla_nest_end ( skb , ieee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) return - EMSGSIZE ; } return 0 ; }","ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )"
473,"static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { sco_conn_defer_accept ( pi -> conn -> hcon , pi -> setting ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }",= BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
474,"bool agoo_ws_create_req ( agooCon c , long mlen ) { uint8_t op = 0x0F & * c -> buf ; if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { agoo_log_cat ( & agoo_error_cat , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>request."" ) ; return true ; } if ( NULL == c -> up || agoo_server . ctx_nil_value == c -> up -> ctx ) { return true ; } memset ( c -> req , 0 , sizeof ( struct _agooReq ) ) ; if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\\0' ; c -> req -> mlen = mlen ; c -> req -> method = ( AGOO_WS_OP_BIN == op ) ? AGOO_ON_BIN : AGOO_ON_MSG ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = c -> up ; <S2SV_StartBug> c -> req -> res = NULL ; <S2SV_EndBug> if ( c -> up -> on_msg ) { c -> req -> hook = agoo_hook_create ( AGOO_NONE , NULL , c -> up -> ctx , PUSH_HOOK , & agoo_server . eval_queue ) ; } return false ; }","-> up ; memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;"
475,"WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ; ps_dec -> u2_total_mbs_coded = 0 ; { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } } H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }",; WORD32 ret <S2SV_ModEnd> ; ps_dec ->
476,"static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , apr_size_t len , int linelimit ) { apr_size_t i = 0 ; while ( i < len ) { char c = buffer [ i ] ; ap_xlate_proto_from_ascii ( & c , 1 ) ; <S2SV_StartBug> if ( ctx -> state == BODY_CHUNK_END ) { <S2SV_EndBug> if ( c == LF ) { <S2SV_StartBug> ctx -> state = BODY_CHUNK ; <S2SV_EndBug> } i ++ ; continue ; } if ( ctx -> state == BODY_CHUNK ) { if ( ! apr_isxdigit ( c ) ) { <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> } else { ctx -> state = BODY_CHUNK_PART ; } ctx -> remaining = 0 ; <S2SV_StartBug> ctx -> chunkbits = sizeof ( long ) * 8 ; <S2SV_EndBug> ctx -> chunk_used = 0 ; } <S2SV_StartBug> if ( c == ';' || c == CR ) { <S2SV_EndBug> ctx -> state = BODY_CHUNK_EXT ; } <S2SV_StartBug> else if ( c == LF ) { <S2SV_EndBug> if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state != BODY_CHUNK_EXT ) { <S2SV_StartBug> int xvalue = 0 ; <S2SV_EndBug> if ( ! ctx -> remaining && c == '0' ) { i ++ ; <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( c >= '0' && c <= '9' ) { xvalue = c - '0' ; } else if ( c >= 'A' && c <= 'F' ) { xvalue = c - 'A' + 0xa ; } else if ( c >= 'a' && c <= 'f' ) { xvalue = c - 'a' + 0xa ; } else { <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> } ctx -> remaining = ( ctx -> remaining << 4 ) | xvalue ; <S2SV_StartBug> ctx -> chunkbits -= 4 ; <S2SV_EndBug> if ( ctx -> chunkbits <= 0 || ctx -> remaining < 0 ) { return APR_ENOSPC ; <S2SV_StartBug> } <S2SV_EndBug> } i ++ ; } ctx -> chunk_used += len ; if ( ctx -> chunk_used < 0 || ctx -> chunk_used > linelimit ) { return APR_ENOSPC ; } return APR_SUCCESS ; }",state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> ) { return APR_EINVAL <S2SV_ModEnd> ; } else <S2SV_ModStart> = sizeof ( apr_off_t <S2SV_ModEnd> ) * 8 <S2SV_ModStart> ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { ctx <S2SV_ModStart> else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> ) { int <S2SV_ModStart> { int xvalue <S2SV_ModEnd> ; if ( <S2SV_ModStart> ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> else { return APR_EINVAL <S2SV_ModEnd> ; } ctx <S2SV_ModStart> | xvalue ; if ( <S2SV_ModEnd> ctx -> remaining <S2SV_ModStart> APR_ENOSPC ; } } else { return APR_EGENERAL ;
477,"void serveloop ( GArray * servers ) { struct sockaddr_storage addrin ; socklen_t addrinlen = sizeof ( addrin ) ; int i ; int max ; fd_set mset ; fd_set rset ; max = 0 ; FD_ZERO ( & mset ) ; for ( i = 0 ; i < servers -> len ; i ++ ) { int sock ; if ( ( sock = ( g_array_index ( servers , SERVER , i ) ) . socket ) >= 0 ) { FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } } for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; FD_SET ( sock , & mset ) ; max = sock > max ? sock : max ; } for ( ; ; ) { if ( is_sighup_caught ) { int n ; GError * gerror = NULL ; msg ( LOG_INFO , ""reconfiguration<S2SV_blank>request<S2SV_blank>received"" ) ; is_sighup_caught = 0 ; n = append_new_servers ( servers , & gerror ) ; if ( n == - 1 ) msg ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s"" , gerror -> message ) ; for ( i = servers -> len - n ; i < servers -> len ; ++ i ) { const SERVER server = g_array_index ( servers , SERVER , i ) ; if ( server . socket >= 0 ) { FD_SET ( server . socket , & mset ) ; max = server . socket > max ? server . socket : max ; } msg ( LOG_INFO , ""reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s"" , server . servename ) ; } } memcpy ( & rset , & mset , sizeof ( fd_set ) ) ; if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) { <S2SV_StartBug> int net ; <S2SV_EndBug> DEBUG ( ""accept,<S2SV_blank>"" ) ; for ( i = 0 ; i < modernsocks -> len ; i ++ ) { int sock = g_array_index ( modernsocks , int , i ) ; if ( ! FD_ISSET ( sock , & rset ) ) { continue ; } <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ; continue ; } <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> if ( ! client ) { close ( net ) ; continue ; } handle_connection ( servers , net , client -> server , client ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { if ( ( net = accept ( serve -> socket , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ; continue ; } handle_connection ( servers , net , serve , NULL ) ; } } } } }","0 ) { <S2SV_ModEnd> DEBUG ( ""accept,<S2SV_blank>"" <S2SV_ModStart> continue ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = accept ( serve -> socket <S2SV_ModEnd> , ( struct <S2SV_ModStart> continue ; } handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> ) ; }"
478,"int main ( ) { CU_pSuite pSuite = NULL ; unsigned int num_tests_failed ; nghttp2_enable_strict_preface = 0 ; if ( CUE_SUCCESS != CU_initialize_registry ( ) ) return ( int ) CU_get_error ( ) ; pSuite = CU_add_suite ( ""libnghttp2_TestSuite"" , init_suite1 , clean_suite1 ) ; if ( NULL == pSuite ) { CU_cleanup_registry ( ) ; return ( int ) CU_get_error ( ) ; } if ( ! CU_add_test ( pSuite , ""pq"" , test_nghttp2_pq ) || ! CU_add_test ( pSuite , ""pq_update"" , test_nghttp2_pq_update ) || ! CU_add_test ( pSuite , ""pq_remove"" , test_nghttp2_pq_remove ) || ! CU_add_test ( pSuite , ""map"" , test_nghttp2_map ) || ! CU_add_test ( pSuite , ""map_functional"" , test_nghttp2_map_functional ) || ! CU_add_test ( pSuite , ""map_each_free"" , test_nghttp2_map_each_free ) || ! CU_add_test ( pSuite , ""queue"" , test_nghttp2_queue ) || ! CU_add_test ( pSuite , ""npn"" , test_nghttp2_npn ) || ! CU_add_test ( pSuite , ""session_recv"" , test_nghttp2_session_recv ) || ! CU_add_test ( pSuite , ""session_recv_invalid_stream_id"" , test_nghttp2_session_recv_invalid_stream_id ) || ! CU_add_test ( pSuite , ""session_recv_invalid_frame"" , test_nghttp2_session_recv_invalid_frame ) || ! CU_add_test ( pSuite , ""session_recv_eof"" , test_nghttp2_session_recv_eof ) || ! CU_add_test ( pSuite , ""session_recv_data"" , test_nghttp2_session_recv_data ) || ! CU_add_test ( pSuite , ""session_recv_data_no_auto_flow_control"" , test_nghttp2_session_recv_data_no_auto_flow_control ) || ! CU_add_test ( pSuite , ""session_recv_continuation"" , test_nghttp2_session_recv_continuation ) || ! CU_add_test ( pSuite , ""session_recv_headers_with_priority"" , test_nghttp2_session_recv_headers_with_priority ) || ! CU_add_test ( pSuite , ""session_recv_headers_with_padding"" , test_nghttp2_session_recv_headers_with_padding ) || ! CU_add_test ( pSuite , ""session_recv_headers_early_response"" , test_nghttp2_session_recv_headers_early_response ) || ! CU_add_test ( pSuite , ""session_recv_headers_for_closed_stream"" , test_nghttp2_session_recv_headers_for_closed_stream ) || ! CU_add_test ( pSuite , ""session_server_recv_push_response"" , test_nghttp2_session_server_recv_push_response ) || ! CU_add_test ( pSuite , ""session_recv_premature_headers"" , test_nghttp2_session_recv_premature_headers ) || ! CU_add_test ( pSuite , ""session_recv_unknown_frame"" , test_nghttp2_session_recv_unknown_frame ) || ! CU_add_test ( pSuite , ""session_recv_unexpected_continuation"" , test_nghttp2_session_recv_unexpected_continuation ) || ! CU_add_test ( pSuite , ""session_recv_settings_header_table_size"" , test_nghttp2_session_recv_settings_header_table_size ) || ! CU_add_test ( pSuite , ""session_recv_too_large_frame_length"" , test_nghttp2_session_recv_too_large_frame_length ) || ! CU_add_test ( pSuite , ""session_recv_extension"" , test_nghttp2_session_recv_extension ) || ! CU_add_test ( pSuite , ""session_recv_altsvc"" , test_nghttp2_session_recv_altsvc ) || ! CU_add_test ( pSuite , ""session_recv_origin"" , test_nghttp2_session_recv_origin ) || ! CU_add_test ( pSuite , ""session_continue"" , test_nghttp2_session_continue ) || ! CU_add_test ( pSuite , ""session_add_frame"" , test_nghttp2_session_add_frame ) || ! CU_add_test ( pSuite , ""session_on_request_headers_received"" , test_nghttp2_session_on_request_headers_received ) || ! CU_add_test ( pSuite , ""session_on_response_headers_received"" , test_nghttp2_session_on_response_headers_received ) || ! CU_add_test ( pSuite , ""session_on_headers_received"" , test_nghttp2_session_on_headers_received ) || ! CU_add_test ( pSuite , ""session_on_push_response_headers_received"" , test_nghttp2_session_on_push_response_headers_received ) || ! CU_add_test ( pSuite , ""session_on_priority_received"" , test_nghttp2_session_on_priority_received ) || ! CU_add_test ( pSuite , ""session_on_rst_stream_received"" , test_nghttp2_session_on_rst_stream_received ) || ! CU_add_test ( pSuite , ""session_on_settings_received"" , test_nghttp2_session_on_settings_received ) || ! CU_add_test ( pSuite , ""session_on_push_promise_received"" , test_nghttp2_session_on_push_promise_received ) || ! CU_add_test ( pSuite , ""session_on_ping_received"" , test_nghttp2_session_on_ping_received ) || ! CU_add_test ( pSuite , ""session_on_goaway_received"" , test_nghttp2_session_on_goaway_received ) || ! CU_add_test ( pSuite , ""session_on_window_update_received"" , test_nghttp2_session_on_window_update_received ) || ! CU_add_test ( pSuite , ""session_on_data_received"" , test_nghttp2_session_on_data_received ) || ! CU_add_test ( pSuite , ""session_on_data_received_fail_fast"" , test_nghttp2_session_on_data_received_fail_fast ) || ! CU_add_test ( pSuite , ""session_on_altsvc_received"" , test_nghttp2_session_on_altsvc_received ) || ! CU_add_test ( pSuite , ""session_send_headers_start_stream"" , test_nghttp2_session_send_headers_start_stream ) || ! CU_add_test ( pSuite , ""session_send_headers_reply"" , test_nghttp2_session_send_headers_reply ) || ! CU_add_test ( pSuite , ""session_send_headers_frame_size_error"" , test_nghttp2_session_send_headers_frame_size_error ) || ! CU_add_test ( pSuite , ""session_send_headers_push_reply"" , test_nghttp2_session_send_headers_push_reply ) || ! CU_add_test ( pSuite , ""session_send_rst_stream"" , test_nghttp2_session_send_rst_stream ) || ! CU_add_test ( pSuite , ""session_send_push_promise"" , test_nghttp2_session_send_push_promise ) || ! CU_add_test ( pSuite , ""session_is_my_stream_id"" , test_nghttp2_session_is_my_stream_id ) || ! CU_add_test ( pSuite , ""session_upgrade2"" , test_nghttp2_session_upgrade2 ) || ! CU_add_test ( pSuite , ""session_reprioritize_stream"" , test_nghttp2_session_reprioritize_stream ) || ! CU_add_test ( pSuite , ""session_reprioritize_stream_with_idle_stream_dep"" , test_nghttp2_session_reprioritize_stream_with_idle_stream_dep ) || ! CU_add_test ( pSuite , ""submit_data"" , test_nghttp2_submit_data ) || ! CU_add_test ( pSuite , ""submit_data_read_length_too_large"" , test_nghttp2_submit_data_read_length_too_large ) || ! CU_add_test ( pSuite , ""submit_data_read_length_smallest"" , test_nghttp2_submit_data_read_length_smallest ) || ! CU_add_test ( pSuite , ""submit_data_twice"" , test_nghttp2_submit_data_twice ) || ! CU_add_test ( pSuite , ""submit_request_with_data"" , test_nghttp2_submit_request_with_data ) || ! CU_add_test ( pSuite , ""submit_request_without_data"" , test_nghttp2_submit_request_without_data ) || ! CU_add_test ( pSuite , ""submit_response_with_data"" , test_nghttp2_submit_response_with_data ) || ! CU_add_test ( pSuite , ""submit_response_without_data"" , test_nghttp2_submit_response_without_data ) || ! CU_add_test ( pSuite , ""Submit_response_push_response"" , test_nghttp2_submit_response_push_response ) || ! CU_add_test ( pSuite , ""submit_trailer"" , test_nghttp2_submit_trailer ) || ! CU_add_test ( pSuite , ""submit_headers_start_stream"" , test_nghttp2_submit_headers_start_stream ) || ! CU_add_test ( pSuite , ""submit_headers_reply"" , test_nghttp2_submit_headers_reply ) || ! CU_add_test ( pSuite , ""submit_headers_push_reply"" , test_nghttp2_submit_headers_push_reply ) || ! CU_add_test ( pSuite , ""submit_headers"" , test_nghttp2_submit_headers ) || ! CU_add_test ( pSuite , ""submit_headers_continuation"" , test_nghttp2_submit_headers_continuation ) || ! CU_add_test ( pSuite , ""submit_headers_continuation_extra_large"" , test_nghttp2_submit_headers_continuation_extra_large ) || ! CU_add_test ( pSuite , ""submit_priority"" , test_nghttp2_submit_priority ) || ! CU_add_test ( pSuite , ""session_submit_settings"" , test_nghttp2_submit_settings ) || ! CU_add_test ( pSuite , ""session_submit_settings_update_local_window_size"" , test_nghttp2_submit_settings_update_local_window_size ) || ! CU_add_test ( pSuite , ""session_submit_settings_multiple_times"" , test_nghttp2_submit_settings_multiple_times ) || ! CU_add_test ( pSuite , ""session_submit_push_promise"" , test_nghttp2_submit_push_promise ) || ! CU_add_test ( pSuite , ""submit_window_update"" , test_nghttp2_submit_window_update ) || ! CU_add_test ( pSuite , ""submit_window_update_local_window_size"" , test_nghttp2_submit_window_update_local_window_size ) || ! CU_add_test ( pSuite , ""submit_shutdown_notice"" , test_nghttp2_submit_shutdown_notice ) || ! CU_add_test ( pSuite , ""submit_invalid_nv"" , test_nghttp2_submit_invalid_nv ) || ! CU_add_test ( pSuite , ""submit_extension"" , test_nghttp2_submit_extension ) || ! CU_add_test ( pSuite , ""submit_altsvc"" , test_nghttp2_submit_altsvc ) || ! CU_add_test ( pSuite , ""submit_origin"" , test_nghttp2_submit_origin ) || ! CU_add_test ( pSuite , ""session_open_stream"" , test_nghttp2_session_open_stream ) || ! CU_add_test ( pSuite , ""session_open_stream_with_idle_stream_dep"" , test_nghttp2_session_open_stream_with_idle_stream_dep ) || ! CU_add_test ( pSuite , ""session_get_next_ob_item"" , test_nghttp2_session_get_next_ob_item ) || ! CU_add_test ( pSuite , ""session_pop_next_ob_item"" , test_nghttp2_session_pop_next_ob_item ) || ! CU_add_test ( pSuite , ""session_reply_fail"" , test_nghttp2_session_reply_fail ) || ! CU_add_test ( pSuite , ""session_max_concurrent_streams"" , test_nghttp2_session_max_concurrent_streams ) || ! CU_add_test ( pSuite , ""session_stop_data_with_rst_stream"" , test_nghttp2_session_stop_data_with_rst_stream ) || ! CU_add_test ( pSuite , ""session_defer_data"" , test_nghttp2_session_defer_data ) || ! CU_add_test ( pSuite , ""session_flow_control"" , test_nghttp2_session_flow_control ) || ! CU_add_test ( pSuite , ""session_flow_control_data_recv"" , test_nghttp2_session_flow_control_data_recv ) || ! CU_add_test ( pSuite , ""session_flow_control_data_with_padding_recv"" , test_nghttp2_session_flow_control_data_with_padding_recv ) || ! CU_add_test ( pSuite , ""session_data_read_temporal_failure"" , test_nghttp2_session_data_read_temporal_failure ) || ! CU_add_test ( pSuite , ""session_on_stream_close"" , test_nghttp2_session_on_stream_close ) || ! CU_add_test ( pSuite , ""session_on_ctrl_not_send"" , test_nghttp2_session_on_ctrl_not_send ) || ! CU_add_test ( pSuite , ""session_get_outbound_queue_size"" , test_nghttp2_session_get_outbound_queue_size ) || ! CU_add_test ( pSuite , ""session_get_effective_local_window_size"" , test_nghttp2_session_get_effective_local_window_size ) || ! CU_add_test ( pSuite , ""session_set_option"" , test_nghttp2_session_set_option ) || ! CU_add_test ( pSuite , ""session_data_backoff_by_high_pri_frame"" , test_nghttp2_session_data_backoff_by_high_pri_frame ) || ! CU_add_test ( pSuite , ""session_pack_data_with_padding"" , test_nghttp2_session_pack_data_with_padding ) || ! CU_add_test ( pSuite , ""session_pack_headers_with_padding"" , test_nghttp2_session_pack_headers_with_padding ) || ! CU_add_test ( pSuite , ""pack_settings_payload"" , test_nghttp2_pack_settings_payload ) || ! CU_add_test ( pSuite , ""session_stream_dep_add"" , test_nghttp2_session_stream_dep_add ) || ! CU_add_test ( pSuite , ""session_stream_dep_remove"" , test_nghttp2_session_stream_dep_remove ) || ! CU_add_test ( pSuite , ""session_stream_dep_add_subtree"" , test_nghttp2_session_stream_dep_add_subtree ) || ! CU_add_test ( pSuite , ""session_stream_dep_remove_subtree"" , test_nghttp2_session_stream_dep_remove_subtree ) || ! CU_add_test ( pSuite , ""session_stream_dep_all_your_stream_are_belong_to_us"" , test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us ) || ! CU_add_test ( pSuite , ""session_stream_attach_item"" , test_nghttp2_session_stream_attach_item ) || ! CU_add_test ( pSuite , ""session_stream_attach_item_subtree"" , test_nghttp2_session_stream_attach_item_subtree ) || ! CU_add_test ( pSuite , ""session_stream_get_state"" , test_nghttp2_session_stream_get_state ) || ! CU_add_test ( pSuite , ""session_stream_get_something"" , test_nghttp2_session_stream_get_something ) || ! CU_add_test ( pSuite , ""session_find_stream"" , test_nghttp2_session_find_stream ) || ! CU_add_test ( pSuite , ""session_keep_closed_stream"" , test_nghttp2_session_keep_closed_stream ) || ! CU_add_test ( pSuite , ""session_keep_idle_stream"" , test_nghttp2_session_keep_idle_stream ) || ! CU_add_test ( pSuite , ""session_detach_idle_stream"" , test_nghttp2_session_detach_idle_stream ) || ! CU_add_test ( pSuite , ""session_large_dep_tree"" , test_nghttp2_session_large_dep_tree ) || ! CU_add_test ( pSuite , ""session_graceful_shutdown"" , test_nghttp2_session_graceful_shutdown ) || ! CU_add_test ( pSuite , ""session_on_header_temporal_failure"" , test_nghttp2_session_on_header_temporal_failure ) || ! CU_add_test ( pSuite , ""session_recv_client_magic"" , test_nghttp2_session_recv_client_magic ) || ! CU_add_test ( pSuite , ""session_delete_data_item"" , test_nghttp2_session_delete_data_item ) || ! CU_add_test ( pSuite , ""session_open_idle_stream"" , test_nghttp2_session_open_idle_stream ) || ! CU_add_test ( pSuite , ""session_cancel_reserved_remote"" , test_nghttp2_session_cancel_reserved_remote ) || ! CU_add_test ( pSuite , ""session_reset_pending_headers"" , test_nghttp2_session_reset_pending_headers ) || ! CU_add_test ( pSuite , ""session_send_data_callback"" , test_nghttp2_session_send_data_callback ) || ! CU_add_test ( pSuite , ""session_on_begin_headers_temporal_failure"" , test_nghttp2_session_on_begin_headers_temporal_failure ) || ! CU_add_test ( pSuite , ""session_defer_then_close"" , test_nghttp2_session_defer_then_close ) || ! CU_add_test ( pSuite , ""session_detach_item_from_closed_stream"" , test_nghttp2_session_detach_item_from_closed_stream ) || ! CU_add_test ( pSuite , ""session_flooding"" , test_nghttp2_session_flooding ) || ! CU_add_test ( pSuite , ""session_change_stream_priority"" , test_nghttp2_session_change_stream_priority ) || ! CU_add_test ( pSuite , ""session_create_idle_stream"" , test_nghttp2_session_create_idle_stream ) || ! CU_add_test ( pSuite , ""session_repeated_priority_change"" , test_nghttp2_session_repeated_priority_change ) || ! CU_add_test ( pSuite , ""session_repeated_priority_submission"" , test_nghttp2_session_repeated_priority_submission ) || ! CU_add_test ( pSuite , ""session_set_local_window_size"" , test_nghttp2_session_set_local_window_size ) || ! CU_add_test ( pSuite , ""session_cancel_from_before_frame_send"" , test_nghttp2_session_cancel_from_before_frame_send ) || <S2SV_StartBug> ! CU_add_test ( pSuite , ""session_removed_closed_stream"" , <S2SV_EndBug> test_nghttp2_session_removed_closed_stream ) || ! CU_add_test ( pSuite , ""session_pause_data"" , test_nghttp2_session_pause_data ) || ! CU_add_test ( pSuite , ""session_no_closed_streams"" , test_nghttp2_session_no_closed_streams ) || ! CU_add_test ( pSuite , ""session_set_stream_user_data"" , test_nghttp2_session_set_stream_user_data ) || ! CU_add_test ( pSuite , ""http_mandatory_headers"" , test_nghttp2_http_mandatory_headers ) || ! CU_add_test ( pSuite , ""http_content_length"" , test_nghttp2_http_content_length ) || ! CU_add_test ( pSuite , ""http_content_length_mismatch"" , test_nghttp2_http_content_length_mismatch ) || ! CU_add_test ( pSuite , ""http_non_final_response"" , test_nghttp2_http_non_final_response ) || ! CU_add_test ( pSuite , ""http_trailer_headers"" , test_nghttp2_http_trailer_headers ) || ! CU_add_test ( pSuite , ""http_ignore_regular_header"" , test_nghttp2_http_ignore_regular_header ) || ! CU_add_test ( pSuite , ""http_ignore_content_length"" , test_nghttp2_http_ignore_content_length ) || ! CU_add_test ( pSuite , ""http_record_request_method"" , test_nghttp2_http_record_request_method ) || ! CU_add_test ( pSuite , ""http_push_promise"" , test_nghttp2_http_push_promise ) || ! CU_add_test ( pSuite , ""http_head_method_upgrade_workaround"" , test_nghttp2_http_head_method_upgrade_workaround ) || ! CU_add_test ( pSuite , ""frame_pack_headers"" , test_nghttp2_frame_pack_headers ) || ! CU_add_test ( pSuite , ""frame_pack_headers_frame_too_large"" , test_nghttp2_frame_pack_headers_frame_too_large ) || ! CU_add_test ( pSuite , ""frame_pack_priority"" , test_nghttp2_frame_pack_priority ) || ! CU_add_test ( pSuite , ""frame_pack_rst_stream"" , test_nghttp2_frame_pack_rst_stream ) || ! CU_add_test ( pSuite , ""frame_pack_settings"" , test_nghttp2_frame_pack_settings ) || ! CU_add_test ( pSuite , ""frame_pack_push_promise"" , test_nghttp2_frame_pack_push_promise ) || ! CU_add_test ( pSuite , ""frame_pack_ping"" , test_nghttp2_frame_pack_ping ) || ! CU_add_test ( pSuite , ""frame_pack_goaway"" , test_nghttp2_frame_pack_goaway ) || ! CU_add_test ( pSuite , ""frame_pack_window_update"" , test_nghttp2_frame_pack_window_update ) || ! CU_add_test ( pSuite , ""frame_pack_altsvc"" , test_nghttp2_frame_pack_altsvc ) || ! CU_add_test ( pSuite , ""frame_pack_origin"" , test_nghttp2_frame_pack_origin ) || ! CU_add_test ( pSuite , ""nv_array_copy"" , test_nghttp2_nv_array_copy ) || ! CU_add_test ( pSuite , ""iv_check"" , test_nghttp2_iv_check ) || ! CU_add_test ( pSuite , ""hd_deflate"" , test_nghttp2_hd_deflate ) || ! CU_add_test ( pSuite , ""hd_deflate_same_indexed_repr"" , test_nghttp2_hd_deflate_same_indexed_repr ) || ! CU_add_test ( pSuite , ""hd_inflate_indexed"" , test_nghttp2_hd_inflate_indexed ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_noinc"" , test_nghttp2_hd_inflate_indname_noinc ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_inc"" , test_nghttp2_hd_inflate_indname_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_inc_eviction"" , test_nghttp2_hd_inflate_indname_inc_eviction ) || ! CU_add_test ( pSuite , ""hd_inflate_newname_noinc"" , test_nghttp2_hd_inflate_newname_noinc ) || ! CU_add_test ( pSuite , ""hd_inflate_newname_inc"" , test_nghttp2_hd_inflate_newname_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_clearall_inc"" , test_nghttp2_hd_inflate_clearall_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_zero_length_huffman"" , test_nghttp2_hd_inflate_zero_length_huffman ) || ! CU_add_test ( pSuite , ""hd_inflate_expect_table_size_update"" , test_nghttp2_hd_inflate_expect_table_size_update ) || ! CU_add_test ( pSuite , ""hd_inflate_unexpected_table_size_update"" , test_nghttp2_hd_inflate_unexpected_table_size_update ) || ! CU_add_test ( pSuite , ""hd_ringbuf_reserve"" , test_nghttp2_hd_ringbuf_reserve ) || ! CU_add_test ( pSuite , ""hd_change_table_size"" , test_nghttp2_hd_change_table_size ) || ! CU_add_test ( pSuite , ""hd_deflate_inflate"" , test_nghttp2_hd_deflate_inflate ) || ! CU_add_test ( pSuite , ""hd_no_index"" , test_nghttp2_hd_no_index ) || ! CU_add_test ( pSuite , ""hd_deflate_bound"" , test_nghttp2_hd_deflate_bound ) || ! CU_add_test ( pSuite , ""hd_public_api"" , test_nghttp2_hd_public_api ) || ! CU_add_test ( pSuite , ""hd_deflate_hd_vec"" , test_nghttp2_hd_deflate_hd_vec ) || ! CU_add_test ( pSuite , ""hd_decode_length"" , test_nghttp2_hd_decode_length ) || ! CU_add_test ( pSuite , ""hd_huff_encode"" , test_nghttp2_hd_huff_encode ) || ! CU_add_test ( pSuite , ""hd_huff_decode"" , test_nghttp2_hd_huff_decode ) || ! CU_add_test ( pSuite , ""adjust_local_window_size"" , test_nghttp2_adjust_local_window_size ) || ! CU_add_test ( pSuite , ""check_header_name"" , test_nghttp2_check_header_name ) || ! CU_add_test ( pSuite , ""check_header_value"" , test_nghttp2_check_header_value ) || ! CU_add_test ( pSuite , ""bufs_add"" , test_nghttp2_bufs_add ) || ! CU_add_test ( pSuite , ""bufs_add_stack_buffer_overflow_bug"" , test_nghttp2_bufs_add_stack_buffer_overflow_bug ) || ! CU_add_test ( pSuite , ""bufs_addb"" , test_nghttp2_bufs_addb ) || ! CU_add_test ( pSuite , ""bufs_orb"" , test_nghttp2_bufs_orb ) || ! CU_add_test ( pSuite , ""bufs_remove"" , test_nghttp2_bufs_remove ) || ! CU_add_test ( pSuite , ""bufs_reset"" , test_nghttp2_bufs_reset ) || ! CU_add_test ( pSuite , ""bufs_advance"" , test_nghttp2_bufs_advance ) || ! CU_add_test ( pSuite , ""bufs_next_present"" , test_nghttp2_bufs_next_present ) || ! CU_add_test ( pSuite , ""bufs_realloc"" , test_nghttp2_bufs_realloc ) ) { CU_cleanup_registry ( ) ; return ( int ) CU_get_error ( ) ; } CU_basic_set_mode ( CU_BRM_VERBOSE ) ; CU_basic_run_tests ( ) ; num_tests_failed = CU_get_number_of_tests_failed ( ) ; CU_cleanup_registry ( ) ; if ( CU_get_error ( ) == CUE_SUCCESS ) { return ( int ) num_tests_failed ; } else { printf ( ""CUnit<S2SV_blank>Error:<S2SV_blank>%s\\n"" , CU_get_error_msg ( ) ) ; return ( int ) CU_get_error ( ) ; } }","( pSuite , ""session_too_many_settings"" , test_nghttp2_session_too_many_settings ) || ! CU_add_test ( pSuite ,"
479,"IHEVCD_ERROR_T ihevcd_parse_slice_header ( codec_t * ps_codec , nal_header_t * ps_nal ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i , j ; WORD32 sps_id ; pps_t * ps_pps ; sps_t * ps_sps ; slice_header_t * ps_slice_hdr ; WORD32 disable_deblocking_filter_flag ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 idr_pic_flag ; WORD32 pps_id ; WORD32 first_slice_in_pic_flag ; WORD32 no_output_of_prior_pics_flag = 0 ; WORD8 i1_nal_unit_type = ps_nal -> i1_nal_unit_type ; WORD32 num_poc_total_curr = 0 ; <S2SV_StartBug> WORD32 slice_address ; <S2SV_EndBug> if ( ps_codec -> i4_slice_error == 1 ) return ret ; idr_pic_flag = ( NAL_IDR_W_LP == i1_nal_unit_type ) || ( NAL_IDR_N_LP == i1_nal_unit_type ) ; BITS_PARSE ( ""first_slice_in_pic_flag"" , first_slice_in_pic_flag , ps_bitstrm , 1 ) ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { BITS_PARSE ( ""no_output_of_prior_pics_flag"" , no_output_of_prior_pics_flag , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""pic_parameter_set_id"" , pps_id , ps_bitstrm ) ; pps_id = CLIP3 ( pps_id , 0 , MAX_PPS_CNT - 2 ) ; ps_pps = ps_codec -> s_parse . ps_pps_base + pps_id ; if ( 0 == ps_pps -> i1_pps_valid ) { pps_t * ps_pps_ref = ps_codec -> ps_pps_base ; while ( 0 == ps_pps_ref -> i1_pps_valid ) { ps_pps_ref ++ ; if ( ( ps_pps_ref - ps_codec -> ps_pps_base >= MAX_PPS_CNT - 1 ) ) return IHEVCD_INVALID_HEADER ; } ihevcd_copy_pps ( ps_codec , pps_id , ps_pps_ref -> i1_pps_id ) ; } sps_id = ps_pps -> i1_sps_id ; ps_sps = ps_codec -> s_parse . ps_sps_base + sps_id ; if ( ( 0 != ps_codec -> u4_pic_cnt || ps_codec -> i4_pic_present ) && first_slice_in_pic_flag ) { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { ps_codec -> i4_slice_error = 0 ; } } if ( first_slice_in_pic_flag ) { ps_codec -> s_parse . i4_cur_slice_idx = 0 ; } else { if ( 0 == ps_codec -> i4_pic_present ) ps_codec -> s_parse . i4_cur_slice_idx = 1 ; } ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; if ( ( ps_pps -> i1_dependent_slice_enabled_flag ) && ( ! first_slice_in_pic_flag ) ) { BITS_PARSE ( ""dependent_slice_flag"" , value , ps_bitstrm , 1 ) ; if ( value && ( ps_codec -> s_parse . i4_cur_slice_idx > 0 ) ) { ihevcd_copy_slice_hdr ( ps_codec , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) , ( ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; } ps_slice_hdr -> i1_dependent_slice_flag = value ; } else { ps_slice_hdr -> i1_dependent_slice_flag = 0 ; } ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ; ps_slice_hdr -> i1_pps_id = pps_id ; ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ; ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ; } ps_slice_hdr -> i1_pps_id = pps_id ; if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { WORD32 num_bits ; num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ; BITS_PARSE ( ""slice_address"" , value , ps_bitstrm , num_bits ) ; slice_address = value ; if ( value >= ps_sps -> i4_pic_size_in_ctb ) return IHEVCD_IGNORE_SLICE ; } else { slice_address = 0 ; } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i1_pic_output_flag = 1 ; ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ; ps_slice_hdr -> i1_num_long_term_sps = 0 ; ps_slice_hdr -> i1_num_long_term_pics = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_extra_slice_header_bits ; i ++ ) { BITS_PARSE ( ""slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""slice_type"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_type = value ; if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) ps_slice_hdr -> i1_slice_type = ISLICE ; if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || ( ps_slice_hdr -> i1_slice_type > 2 ) ) return IHEVCD_IGNORE_SLICE ; if ( ps_pps -> i1_output_flag_present_flag ) { BITS_PARSE ( ""pic_output_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_pic_output_flag = value ; } ps_slice_hdr -> i1_colour_plane_id = 0 ; if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) { BITS_PARSE ( ""colour_plane_id"" , value , ps_bitstrm , 2 ) ; ps_slice_hdr -> i1_colour_plane_id = value ; } ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ; if ( ! idr_pic_flag ) { WORD32 st_rps_idx ; WORD32 num_neg_pics ; WORD32 num_pos_pics ; WORD8 * pi1_used ; BITS_PARSE ( ""pic_order_cnt_lsb"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> i4_pic_order_cnt_lsb = value ; BITS_PARSE ( ""short_term_ref_pic_set_sps_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { WORD32 numbits ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ; if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) { numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ; BITS_PARSE ( ""short_term_ref_pic_set_idx"" , value , ps_bitstrm , numbits ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ; } st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; } else { ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , ps_sps -> i1_num_short_term_ref_pic_sets , & ps_slice_hdr -> s_stref_picset ) ; st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; } if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) { UEV_PARSE ( ""num_long_term_sps"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_sps = value ; ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ; } UEV_PARSE ( ""num_long_term_pics"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_pics = value ; ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - ps_slice_hdr -> i1_num_long_term_sps ) ; for ( i = 0 ; i < ( ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ) ; i ++ ) { if ( i < ps_slice_hdr -> i1_num_long_term_sps ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 1 ) { WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps - 1 ) ; BITS_PARSE ( ""lt_idx_sps[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , num_bits ) ; } else { value = 0 ; } ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> au2_lt_ref_pic_poc_lsb_sps [ value ] ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ; } else { BITS_PARSE ( ""poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ; BITS_PARSE ( ""used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ; } BITS_PARSE ( ""delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { UEV_PARSE ( ""delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ; } if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) { ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ; } } } for ( i = 0 ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { num_poc_total_curr ++ ; } } for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { num_poc_total_curr ++ ; } } if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) { BITS_PARSE ( ""enable_temporal_mvp_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ; } } ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ; ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ; if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) { BITS_PARSE ( ""slice_sao_luma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_luma_flag = value ; BITS_PARSE ( ""slice_sao_chroma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_chroma_flag = value ; } ps_slice_hdr -> i1_max_num_merge_cand = 1 ; ps_slice_hdr -> i1_cabac_init_flag = 0 ; ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ; ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ; ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ; ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { BITS_PARSE ( ""num_ref_idx_active_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ; if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) { UEV_PARSE ( ""num_ref_idx_l0_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { UEV_PARSE ( ""num_ref_idx_l1_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ; } } else { ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ; } } ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ; if ( 0 == num_poc_total_curr ) return IHEVCD_IGNORE_SLICE ; if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) { ihevcd_ref_pic_list_modification ( ps_bitstrm , ps_slice_hdr , num_poc_total_curr ) ; } else { ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ; ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ; } if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""mvd_l1_zero_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_mvd_l1_zero_flag = value ; } ps_slice_hdr -> i1_cabac_init_flag = 0 ; if ( ps_pps -> i1_cabac_init_present_flag ) { BITS_PARSE ( ""cabac_init_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_cabac_init_flag = value ; } ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ; ps_slice_hdr -> i1_collocated_ref_idx = 0 ; if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) { if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""collocated_from_l0_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_collocated_from_l0_flag = value ; } if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) { UEV_PARSE ( ""collocated_ref_idx"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_collocated_ref_idx = value ; } } ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ; if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) { ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ; } UEV_PARSE ( ""five_minus_max_num_merge_cand"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ; } ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ; SEV_PARSE ( ""slice_qp_delta"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_qp_delta = value ; if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) { SEV_PARSE ( ""slice_cb_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cb_qp_offset = value ; SEV_PARSE ( ""slice_cr_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cr_qp_offset = value ; } ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ; ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ; disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) { BITS_PARSE ( ""deblocking_filter_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_deblocking_filter_override_flag = value ; } if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) { BITS_PARSE ( ""slice_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ; disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ; if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) { SEV_PARSE ( ""beta_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""tc_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_tc_offset_div2 = value ; } } } ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ; if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) { BITS_PARSE ( ""slice_loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ; } } if ( ( ! first_slice_in_pic_flag ) && ( ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ; if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) { return IHEVCD_IGNORE_SLICE ; } } if ( 0 == ps_codec -> i4_pic_present ) { ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ; } else { ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ; } if ( ! first_slice_in_pic_flag ) { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) { if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) { if ( ps_codec -> i4_pic_present ) { <S2SV_StartBug> slice_header_t * ps_slice_hdr_next ; <S2SV_EndBug> ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr_next -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; return ret ; } else { return IHEVCD_IGNORE_SLICE ; } } else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) { return IHEVCD_IGNORE_SLICE ; } else { ps_codec -> i4_slice_error = 0 ; } } else { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { if ( ps_slice_hdr -> i1_dependent_slice_flag ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } } } else { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } ps_slice_hdr -> i4_num_entry_point_offsets = 0 ; if ( ( ps_pps -> i1_tiles_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { UEV_PARSE ( ""num_entry_point_offsets"" , value , ps_bitstrm ) ; ps_slice_hdr -> i4_num_entry_point_offsets = value ; { WORD32 max_num_entry_point_offsets ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } else if ( ps_pps -> i1_tiles_enabled_flag ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ; } else { max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , 0 , max_num_entry_point_offsets ) ; } if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) { UEV_PARSE ( ""offset_len_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_offset_len = value + 1 ; for ( i = 0 ; i < ps_slice_hdr -> i4_num_entry_point_offsets ; i ++ ) { BITS_PARSE ( ""entry_point_offset"" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ; } } } if ( ps_pps -> i1_slice_header_extension_present_flag ) { UEV_PARSE ( ""slice_header_extension_length"" , value , ps_bitstrm ) ; ps_slice_hdr -> i2_slice_header_extension_length = value ; for ( i = 0 ; i < ps_slice_hdr -> i2_slice_header_extension_length ; i ++ ) { BITS_PARSE ( ""slice_header_extension_data_byte"" , value , ps_bitstrm , 8 ) ; } } ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; { dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; WORD32 r_idx ; if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( 0 == ps_codec -> u4_pic_cnt ) ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j ++ ) { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ; break ; } ps_mv_buf ++ ; } } } for ( r_idx = 0 ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ; } } else { ret = ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; } } } if ( ps_codec -> i4_pic_present ) { pic_buf_t * ps_pic_buf_ref ; mv_buf_t * ps_mv_buf_ref ; WORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ; if ( NULL == ps_pic_buf_ref ) { ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ; ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ; } else { ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ; } } else { ps_slice_hdr -> i2_ctb_x = 0 ; ps_slice_hdr -> i2_ctb_y = 0 ; ps_slice_hdr -> i2_independent_ctb_x = 0 ; ps_slice_hdr -> i2_independent_ctb_y = 0 ; } if ( ( ! first_slice_in_pic_flag ) && ( 0 == ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; <S2SV_StartBug> ps_codec -> i4_slice_error = 1 ; <S2SV_EndBug> ps_slice_hdr_prev -> i2_ctb_x = 0 ; ps_slice_hdr_prev -> i2_ctb_y = 0 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = 0 ; ps_codec -> s_parse . i4_cur_slice_idx = 0 ; if ( ( ps_slice_hdr -> i2_ctb_x == 0 ) && ( ps_slice_hdr -> i2_ctb_y == 0 ) ) { ps_slice_hdr -> i2_ctb_x ++ ; } } { if ( ( i1_nal_unit_type < NAL_BLA_W_LP ) && ( i1_nal_unit_type % 2 == 0 ) ) { if ( IVD_SKIP_B == ps_codec -> e_pic_skip_mode ) return IHEVCD_IGNORE_SLICE ; } if ( ( IVD_SKIP_PB == ps_codec -> e_pic_skip_mode ) && ( ISLICE != ps_slice_hdr -> i1_slice_type ) ) { return IHEVCD_IGNORE_SLICE ; } } <S2SV_StartBug> return ret ; <S2SV_EndBug> }",; WORD32 slice_address ; WORD32 prev_slice_incomplete_flag = 0 <S2SV_ModStart> i4_pic_present ) { prev_slice_incomplete_flag = 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) ; prev_slice_incomplete_flag = 1 ; ASSERT ( ps_codec -> s_parse . i4_cur_slice_idx == 1 ) <S2SV_ModEnd> ; ps_slice_hdr_prev -> <S2SV_ModStart> ; } } if ( prev_slice_incomplete_flag ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; }
480,"int r_bin_pdb_download ( RCore * core , int isradjson , int * actions_done , SPDBOptions * options ) { int ret ; SPDBDownloaderOpt opt ; SPDBDownloader pdb_downloader ; RBinInfo * info = r_bin_get_info ( core -> bin ) ; if ( ! info || ! info -> debug_file_name ) { <S2SV_StartBug> eprintf ( ""Can\'t<S2SV_blank>find<S2SV_blank>debug<S2SV_blank>filename\\n"" ) ; <S2SV_EndBug> return 1 ; } if ( ! options || ! options -> symbol_server || ! options -> user_agent ) { eprintf ( ""Can\'t<S2SV_blank>retrieve<S2SV_blank>pdb<S2SV_blank>configurations\\n"" ) ; return 1 ; } opt . dbg_file = ( char * ) r_file_basename ( info -> debug_file_name ) ; opt . guid = info -> guid ; opt . symbol_server = options -> symbol_server ; opt . user_agent = options -> user_agent ; opt . symbol_store_path = options -> symbol_store_path ; opt . extract = options -> extract ; init_pdb_downloader ( & opt , & pdb_downloader ) ; ret = pdb_downloader . download ? pdb_downloader . download ( & pdb_downloader ) : 0 ; if ( isradjson && actions_done ) { printf ( ""%s\\""pdb\\"":{\\""file\\"":\\""%s\\"",\\""download\\"":%s}"" , * actions_done ? "","" : """" , opt . dbg_file , ret ? ""true"" : ""false"" ) ; } else { printf ( ""PDB<S2SV_blank>\\""%s\\""<S2SV_blank>download<S2SV_blank>%s\\n"" , opt . dbg_file , ret ? ""success"" : ""failed"" ) ; } if ( actions_done ) { ( * actions_done ) ++ ; } deinit_pdb_downloader ( & pdb_downloader ) ; return 0 ; }","eprintf ( ""Can\'t<S2SV_blank>find<S2SV_blank>debug<S2SV_blank>filename\\n"" ) ; return 1 ; } if ( ! is_valid_guid ( info -> guid ) ) { eprintf ( ""Invalid<S2SV_blank>GUID<S2SV_blank>for<S2SV_blank>file\\n"""
481,"int rxrpc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct rxrpc_skb_priv * sp ; struct rxrpc_call * call = NULL , * continue_call = NULL ; struct rxrpc_sock * rx = rxrpc_sk ( sock -> sk ) ; struct sk_buff * skb ; long timeo ; int copy , ret , ullen , offset , copied = 0 ; u32 abort_code ; DEFINE_WAIT ( wait ) ; _enter ( "",,,%zu,%d"" , len , flags ) ; if ( flags & ( MSG_OOB | MSG_TRUNC ) ) return - EOPNOTSUPP ; ullen = msg -> msg_flags & MSG_CMSG_COMPAT ? 4 : sizeof ( unsigned long ) ; timeo = sock_rcvtimeo ( & rx -> sk , flags & MSG_DONTWAIT ) ; msg -> msg_flags |= MSG_MORE ; lock_sock ( & rx -> sk ) ; for ( ; ; ) { if ( RB_EMPTY_ROOT ( & rx -> calls ) ) { if ( copied ) goto out ; if ( rx -> sk . sk_state != RXRPC_SERVER_LISTENING ) { release_sock ( & rx -> sk ) ; if ( continue_call ) rxrpc_put_call ( continue_call ) ; return - ENODATA ; } } skb = skb_peek ( & rx -> sk . sk_receive_queue ) ; if ( ! skb ) { if ( copied && ( msg -> msg_flags & MSG_PEEK || timeo == 0 ) ) goto out ; release_sock ( & rx -> sk ) ; prepare_to_wait_exclusive ( sk_sleep ( & rx -> sk ) , & wait , TASK_INTERRUPTIBLE ) ; ret = sock_error ( & rx -> sk ) ; if ( ret ) goto wait_error ; if ( skb_queue_empty ( & rx -> sk . sk_receive_queue ) ) { if ( signal_pending ( current ) ) goto wait_interrupted ; timeo = schedule_timeout ( timeo ) ; } finish_wait ( sk_sleep ( & rx -> sk ) , & wait ) ; lock_sock ( & rx -> sk ) ; continue ; } peek_next_packet : sp = rxrpc_skb ( skb ) ; call = sp -> call ; ASSERT ( call != NULL ) ; _debug ( ""next<S2SV_blank>pkt<S2SV_blank>%s"" , rxrpc_pkts [ sp -> hdr . type ] ) ; spin_lock_bh ( & call -> lock ) ; spin_unlock_bh ( & call -> lock ) ; if ( test_bit ( RXRPC_CALL_RELEASED , & call -> flags ) ) { _debug ( ""packet<S2SV_blank>from<S2SV_blank>released<S2SV_blank>call"" ) ; if ( skb_dequeue ( & rx -> sk . sk_receive_queue ) != skb ) BUG ( ) ; rxrpc_free_skb ( skb ) ; continue ; } if ( continue_call ) { _debug ( ""maybe<S2SV_blank>cont"" ) ; if ( call != continue_call || skb -> mark != RXRPC_SKB_MARK_DATA ) { release_sock ( & rx -> sk ) ; rxrpc_put_call ( continue_call ) ; _leave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[noncont]"" , copied ) ; return copied ; } } rxrpc_get_call ( call ) ; if ( ! continue_call ) { <S2SV_StartBug> if ( msg -> msg_name && msg -> msg_namelen > 0 ) <S2SV_EndBug> memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , sizeof ( call -> conn -> trans -> peer -> srx ) ) ; sock_recv_ts_and_drops ( msg , & rx -> sk , skb ) ; } if ( skb -> mark != RXRPC_SKB_MARK_DATA ) goto receive_non_data_message ; _debug ( ""recvmsg<S2SV_blank>DATA<S2SV_blank>#%u<S2SV_blank>{<S2SV_blank>%d,<S2SV_blank>%d<S2SV_blank>}"" , ntohl ( sp -> hdr . seq ) , skb -> len , sp -> offset ) ; if ( ! continue_call ) { ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_USER_CALL_ID , ullen , & call -> user_call_ID ) ; if ( ret < 0 ) goto copy_error ; ASSERT ( test_bit ( RXRPC_CALL_HAS_USERID , & call -> flags ) ) ; } ASSERTCMP ( ntohl ( sp -> hdr . seq ) , >= , call -> rx_data_recv ) ; ASSERTCMP ( ntohl ( sp -> hdr . seq ) , <= , call -> rx_data_recv + 1 ) ; call -> rx_data_recv = ntohl ( sp -> hdr . seq ) ; ASSERTCMP ( ntohl ( sp -> hdr . seq ) , > , call -> rx_data_eaten ) ; offset = sp -> offset ; copy = skb -> len - offset ; if ( copy > len - copied ) copy = len - copied ; if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { ret = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copy ) ; } else { ret = skb_copy_and_csum_datagram_iovec ( skb , offset , msg -> msg_iov ) ; if ( ret == - EINVAL ) goto csum_copy_error ; } if ( ret < 0 ) goto copy_error ; _debug ( ""copied<S2SV_blank>%d+%d"" , copy , copied ) ; offset += copy ; copied += copy ; if ( ! ( flags & MSG_PEEK ) ) sp -> offset = offset ; if ( sp -> offset < skb -> len ) { _debug ( ""buffer<S2SV_blank>full"" ) ; ASSERTCMP ( copied , == , len ) ; break ; } if ( sp -> hdr . flags & RXRPC_LAST_PACKET ) { _debug ( ""last"" ) ; if ( call -> conn -> out_clientflag ) { ret = copied ; goto terminal_message ; } if ( ! ( flags & MSG_PEEK ) ) { _debug ( ""eat<S2SV_blank>packet"" ) ; if ( skb_dequeue ( & rx -> sk . sk_receive_queue ) != skb ) BUG ( ) ; rxrpc_free_skb ( skb ) ; } msg -> msg_flags &= ~ MSG_MORE ; break ; } _debug ( ""next"" ) ; if ( ! continue_call ) continue_call = sp -> call ; else rxrpc_put_call ( call ) ; call = NULL ; if ( flags & MSG_PEEK ) { _debug ( ""peek<S2SV_blank>next"" ) ; skb = skb -> next ; if ( skb == ( struct sk_buff * ) & rx -> sk . sk_receive_queue ) break ; goto peek_next_packet ; } _debug ( ""eat<S2SV_blank>packet"" ) ; if ( skb_dequeue ( & rx -> sk . sk_receive_queue ) != skb ) BUG ( ) ; rxrpc_free_skb ( skb ) ; } _debug ( ""end<S2SV_blank>rcv<S2SV_blank>data"" ) ; out : release_sock ( & rx -> sk ) ; if ( call ) rxrpc_put_call ( call ) ; if ( continue_call ) rxrpc_put_call ( continue_call ) ; _leave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[data]"" , copied ) ; return copied ; receive_non_data_message : _debug ( ""non-data"" ) ; if ( skb -> mark == RXRPC_SKB_MARK_NEW_CALL ) { _debug ( ""RECV<S2SV_blank>NEW<S2SV_blank>CALL"" ) ; ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_NEW_CALL , 0 , & abort_code ) ; if ( ret < 0 ) goto copy_error ; if ( ! ( flags & MSG_PEEK ) ) { if ( skb_dequeue ( & rx -> sk . sk_receive_queue ) != skb ) BUG ( ) ; rxrpc_free_skb ( skb ) ; } goto out ; } ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_USER_CALL_ID , ullen , & call -> user_call_ID ) ; if ( ret < 0 ) goto copy_error ; ASSERT ( test_bit ( RXRPC_CALL_HAS_USERID , & call -> flags ) ) ; switch ( skb -> mark ) { case RXRPC_SKB_MARK_DATA : BUG ( ) ; case RXRPC_SKB_MARK_FINAL_ACK : ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_ACK , 0 , & abort_code ) ; break ; case RXRPC_SKB_MARK_BUSY : ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_BUSY , 0 , & abort_code ) ; break ; case RXRPC_SKB_MARK_REMOTE_ABORT : abort_code = call -> abort_code ; ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_ABORT , 4 , & abort_code ) ; break ; case RXRPC_SKB_MARK_NET_ERROR : _debug ( ""RECV<S2SV_blank>NET<S2SV_blank>ERROR<S2SV_blank>%d"" , sp -> error ) ; abort_code = sp -> error ; ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_NET_ERROR , 4 , & abort_code ) ; break ; case RXRPC_SKB_MARK_LOCAL_ERROR : _debug ( ""RECV<S2SV_blank>LOCAL<S2SV_blank>ERROR<S2SV_blank>%d"" , sp -> error ) ; abort_code = sp -> error ; ret = put_cmsg ( msg , SOL_RXRPC , RXRPC_LOCAL_ERROR , 4 , & abort_code ) ; break ; default : BUG ( ) ; break ; } if ( ret < 0 ) goto copy_error ; terminal_message : _debug ( ""terminal"" ) ; msg -> msg_flags &= ~ MSG_MORE ; msg -> msg_flags |= MSG_EOR ; if ( ! ( flags & MSG_PEEK ) ) { _net ( ""free<S2SV_blank>terminal<S2SV_blank>skb<S2SV_blank>%p"" , skb ) ; if ( skb_dequeue ( & rx -> sk . sk_receive_queue ) != skb ) BUG ( ) ; rxrpc_free_skb ( skb ) ; rxrpc_remove_user_ID ( rx , call ) ; } release_sock ( & rx -> sk ) ; rxrpc_put_call ( call ) ; if ( continue_call ) rxrpc_put_call ( continue_call ) ; _leave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; copy_error : _debug ( ""copy<S2SV_blank>error"" ) ; release_sock ( & rx -> sk ) ; rxrpc_put_call ( call ) ; if ( continue_call ) rxrpc_put_call ( continue_call ) ; _leave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; csum_copy_error : _debug ( ""csum<S2SV_blank>error"" ) ; release_sock ( & rx -> sk ) ; if ( continue_call ) rxrpc_put_call ( continue_call ) ; rxrpc_kill_skb ( skb ) ; skb_kill_datagram ( & rx -> sk , skb , flags ) ; rxrpc_put_call ( call ) ; return - EAGAIN ; wait_interrupted : ret = sock_intr_errno ( timeo ) ; wait_error : finish_wait ( sk_sleep ( & rx -> sk ) , & wait ) ; if ( continue_call ) rxrpc_put_call ( continue_call ) ; if ( copied ) copied = ret ; _leave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[waitfail<S2SV_blank>%d]"" , copied , ret ) ; return copied ; }","msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg"
482,"int virDomainGetTime ( virDomainPtr dom , long long * seconds , unsigned int * nseconds , unsigned int flags ) { VIR_DOMAIN_DEBUG ( dom , ""seconds=%p,<S2SV_blank>nseconds=%p,<S2SV_blank>flags=%x"" , seconds , nseconds , flags ) ; virResetLastError ( ) ; <S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> if ( dom -> conn -> driver -> domainGetTime ) { int ret = dom -> conn -> driver -> domainGetTime ( dom , seconds , nseconds , flags ) ; if ( ret < 0 ) goto error ; return ret ; } virReportUnsupportedError ( ) ; error : virDispatchError ( dom -> conn ) ; return - 1 ; }",", - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error"
483,"static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { <S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> for ( n = m ; ; n = p ) { p = n -> mnt_master ; <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug> while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }",", * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE"
484,"static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { bool disconnect ; p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; } }",disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
485,"static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",") ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"""
486,"<S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> { <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> }",<S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct <S2SV_ModStart> rel ) { return
487,"static int ext4_ext_convert_to_initialized ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path ) { <S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex1 = NULL ; <S2SV_EndBug> struct ext4_extent * ex2 = NULL ; struct ext4_extent * ex3 = NULL ; struct ext4_extent_header * eh ; ext4_lblk_t ee_block , eof_block ; unsigned int allocated , ee_len , depth ; <S2SV_StartBug> ext4_fsblk_t newblock ; <S2SV_EndBug> int err = 0 ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> int may_zeroout ; ext_debug ( ""ext4_ext_convert_to_initialized:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; allocated = ee_len - ( map -> m_lblk - ee_block ) ; <S2SV_StartBug> newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; <S2SV_EndBug> ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; <S2SV_StartBug> if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> if ( err ) <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; <S2SV_StartBug> return allocated ; <S2SV_EndBug> } if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; <S2SV_StartBug> if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> ex -> ee_block = orig_ex . ee_block ; <S2SV_StartBug> ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ; <S2SV_EndBug> ext4_ext_mark_uninitialized ( ex ) ; <S2SV_StartBug> ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; <S2SV_EndBug> ext4_ext_dirty ( handle , inode , path + depth ) ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex3 , newblock ) ; ex3 -> ee_len = cpu_to_le16 ( allocated ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , 0 ) ; if ( err == - ENOSPC ) { <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> if ( err ) <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; <S2SV_StartBug> } else if ( err ) <S2SV_EndBug> goto fix_extent_len ; <S2SV_StartBug> err = ext4_ext_zeroout ( inode , ex3 ) ; <S2SV_EndBug> if ( err ) { depth = ext_depth ( inode ) ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; return err ; } ex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; } return allocated ; } ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; err = ext4_ext_insert_extent ( handle , inode , path , ex3 , 0 ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; if ( le16_to_cpu ( orig_ex . ee_len ) <= EXT4_EXT_ZERO_LEN && map -> m_lblk != ee_block && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; if ( ex2 != ex ) goto insert ; if ( ex2 > EXT_FIRST_EXTENT ( eh ) ) { ret = ext4_ext_try_to_merge ( inode , path , ex2 - 1 ) ; if ( ret ) { err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto out ; depth = ext_depth ( inode ) ; ex2 -- ; } } if ( ! ex3 ) { ret = ext4_ext_try_to_merge ( inode , path , ex2 ) ; if ( ret ) { err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto out ; } } err = ext4_ext_dirty ( handle , inode , path + depth ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , 0 ) ; <S2SV_StartBug> if ( err == - ENOSPC && may_zeroout ) { <S2SV_EndBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : <S2SV_StartBug> ext4_ext_show_leaf ( inode , path ) ; <S2SV_EndBug> <S2SV_StartBug> return err ? err : allocated ; <S2SV_EndBug> fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }",") { struct ext4_map_blocks split_map ; struct ext4_extent zero_ex <S2SV_ModEnd> ; struct ext4_extent <S2SV_ModStart> struct ext4_extent * ex <S2SV_ModEnd> ; ext4_lblk_t ee_block <S2SV_ModStart> , depth ; <S2SV_ModEnd> int err = <S2SV_ModStart> 0 ; int split_flag = 0 <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> inode ) ; ex <S2SV_ModEnd> = path [ <S2SV_ModStart> depth ] . <S2SV_ModEnd> p_ext ; ee_block <S2SV_ModStart> ee_block ) ; WARN_ON ( map -> m_lblk < ee_block ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> * EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) <S2SV_ModEnd> ) { err <S2SV_ModStart> ( inode , ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( inode , path , ex ) ; err = <S2SV_ModEnd> ext4_ext_dirty ( handle <S2SV_ModStart> depth ) ; goto out ; } split_map . m_lblk = map -> m_lblk ; split_map . m_len = map -> m_len ; if ( allocated > map -> m_len ) { <S2SV_ModEnd> if ( allocated <S2SV_ModStart> <= EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { zero_ex . ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; zero_ex . <S2SV_ModEnd> ee_len = cpu_to_le16 <S2SV_ModStart> = cpu_to_le16 ( allocated - map -> m_len <S2SV_ModEnd> ) ; ext4_ext_store_pblock <S2SV_ModStart> ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) + map -> m_lblk - ee_block ) ; <S2SV_ModEnd> err = ext4_ext_zeroout <S2SV_ModStart> inode , & zero_ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; split_map . m_lblk = map -> m_lblk ; split_map . m_len = <S2SV_ModEnd> allocated ; } <S2SV_ModStart> else if ( ( map -> m_lblk - ee_block + map -> m_len < EXT4_EXT_ZERO_LEN ) && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { if ( map -> m_lblk != ee_block ) { zero_ex . ee_block = ex -> ee_block ; zero_ex . ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) ) <S2SV_ModEnd> ; err = <S2SV_ModStart> ( inode , & zero_ex ) ; if ( err ) <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } allocated = map -> m_lblk - ee_block + map -> m_len ; split_map . m_lblk = ee_block ; split_map . m_len = allocated ; } } allocated = ext4_split_extent ( handle , inode , path , & split_map , split_flag <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; if ( allocated < 0 ) err = allocated <S2SV_ModEnd> ; out : <S2SV_ModStart> ; out : <S2SV_ModEnd> return err ? <S2SV_ModStart> err : allocated <S2SV_ModEnd> ; } <S2SV_null>"
488,"node * Ta3Parser_ParseStringObject ( const char * s , PyObject * filename , grammar * g , int start , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; int exec_input = start == file_input ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( * flags & PyPARSE_IGNORE_COOKIE ) tok = Ta3Tokenizer_FromUTF8 ( s , exec_input ) ; else tok = Ta3Tokenizer_FromString ( s , exec_input ) ; if ( tok == NULL ) { err_ret -> error = PyErr_Occurred ( ) ? E_DECODE : E_NOMEM ; return NULL ; } # ifndef PGEN Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif <S2SV_StartBug> return parsetok ( tok , g , start , err_ret , flags ) ; <S2SV_EndBug> }",; # endif if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ;
489,"static int rtmp_packet_read_one_chunk ( URLContext * h , RTMPPacket * p , int chunk_size , RTMPPacket * * prev_pkt_ptr , int * nb_prev_pkt , uint8_t hdr ) { uint8_t buf [ 16 ] ; int channel_id , timestamp , size ; uint32_t ts_field ; uint32_t extra = 0 ; enum RTMPPacketType type ; int written = 0 ; int ret , toread ; RTMPPacket * prev_pkt ; written ++ ; channel_id = hdr & 0x3F ; if ( channel_id < 2 ) { buf [ 1 ] = 0 ; if ( ffurl_read_complete ( h , buf , channel_id + 1 ) != channel_id + 1 ) return AVERROR ( EIO ) ; written += channel_id + 1 ; channel_id = AV_RL16 ( buf ) + 64 ; } if ( ( ret = ff_rtmp_check_alloc_array ( prev_pkt_ptr , nb_prev_pkt , channel_id ) ) < 0 ) return ret ; prev_pkt = * prev_pkt_ptr ; size = prev_pkt [ channel_id ] . size ; type = prev_pkt [ channel_id ] . type ; extra = prev_pkt [ channel_id ] . extra ; hdr >>= 6 ; if ( hdr == RTMP_PS_ONEBYTE ) { ts_field = prev_pkt [ channel_id ] . ts_field ; } else { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; ts_field = AV_RB24 ( buf ) ; if ( hdr != RTMP_PS_FOURBYTES ) { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; size = AV_RB24 ( buf ) ; if ( ffurl_read_complete ( h , buf , 1 ) != 1 ) return AVERROR ( EIO ) ; written ++ ; type = buf [ 0 ] ; if ( hdr == RTMP_PS_TWELVEBYTES ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; written += 4 ; extra = AV_RL32 ( buf ) ; } } } if ( ts_field == 0xFFFFFF ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; timestamp = AV_RB32 ( buf ) ; } else { timestamp = ts_field ; } if ( hdr != RTMP_PS_TWELVEBYTES ) timestamp += prev_pkt [ channel_id ] . timestamp ; <S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ; p -> read = written ; p -> offset = 0 ; prev_pkt [ channel_id ] . ts_field = ts_field ; prev_pkt [ channel_id ] . timestamp = timestamp ; } else { RTMPPacket * prev = & prev_pkt [ channel_id ] ; p -> data = prev -> data ; p -> size = prev -> size ; p -> channel_id = prev -> channel_id ; p -> type = prev -> type ; p -> ts_field = prev -> ts_field ; p -> extra = prev -> extra ; p -> offset = prev -> offset ; p -> read = prev -> read + written ; p -> timestamp = prev -> timestamp ; prev -> data = NULL ; } p -> extra = extra ; prev_pkt [ channel_id ] . channel_id = channel_id ; prev_pkt [ channel_id ] . type = type ; prev_pkt [ channel_id ] . size = size ; prev_pkt [ channel_id ] . extra = extra ; size = size - p -> offset ; toread = FFMIN ( size , chunk_size ) ; if ( ffurl_read_complete ( h , p -> data + p -> offset , toread ) != toread ) { ff_rtmp_packet_destroy ( p ) ; return AVERROR ( EIO ) ; } size -= toread ; p -> read += toread ; p -> offset += toread ; if ( size > 0 ) { RTMPPacket * prev = & prev_pkt [ channel_id ] ; prev -> data = p -> data ; prev -> read = p -> read ; prev -> offset = p -> offset ; p -> data = NULL ; return AVERROR ( EAGAIN ) ; } prev_pkt [ channel_id ] . read = 0 ; return p -> read ; }","; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n"" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if ("
490,"<S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> { xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content ) <S2SV_StartBug> ) ; <S2SV_EndBug> xmlRelaxNGPtr schema ; <S2SV_StartBug> VALUE errors = rb_ary_new ( ) ; <S2SV_EndBug> VALUE rb_schema ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS xmlRelaxNGSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlRelaxNGParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlRelaxNGFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ; <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> }","VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } ctx <S2SV_ModEnd> = xmlRelaxNGNewMemParserCtxt ( <S2SV_ModStart> ( content ) ) ; <S2SV_ModEnd> errors = rb_ary_new <S2SV_ModStart> rb_ary_new ( ) <S2SV_ModEnd> ; xmlSetStructuredErrorFunc ( <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;"
491,"int unquoted_glob_pattern_p ( string ) register char * string ; { register int c ; char * send ; int open , bsquote ; DECLARE_MBSTATE ; open = bsquote = 0 ; send = string + strlen ( string ) ; while ( c = * string ++ ) { switch ( c ) { case '?' : case '*' : return ( 1 ) ; case '[' : open ++ ; continue ; case ']' : if ( open ) return ( 1 ) ; continue ; <S2SV_StartBug> case '+' : <S2SV_EndBug> case '@' : case '!' : if ( * string == '(' ) return ( 1 ) ; continue ; case '\\\\' : if ( * string != '\\0' && * string != '/' ) { bsquote = 1 ; string ++ ; continue ; } <S2SV_StartBug> else if ( * string == 0 ) <S2SV_EndBug> return ( 0 ) ; case CTLESC : if ( * string ++ == '\\0' ) return ( 0 ) ; } # ifdef HANDLE_MULTIBYTE string -- ; ADVANCE_CHAR_P ( string , send - string ) ; string ++ ; # else ADVANCE_CHAR_P ( string , send - string ) ; # endif } return ( ( bsquote && posix_glob_backslash ) ? 2 : 0 ) ; }",continue ; case '/' : if ( open ) open = 0 ; case <S2SV_ModStart> else if ( open && * string == '/' ) { string ++ ; continue ; } else if (
492,"void mwifiex_set_uap_rates ( struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { struct ieee_types_header * rate_ie ; int var_offset = offsetof ( struct ieee80211_mgmt , u . beacon . variable ) ; const u8 * var_pos = params -> beacon . head + var_offset ; int len = params -> beacon . head_len - var_offset ; u8 rate_len = 0 ; rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_SUPP_RATES , var_pos , len ) ; if ( rate_ie ) { <S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> rate_len = rate_ie -> len ; } rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_EXT_SUPP_RATES , params -> beacon . tail , params -> beacon . tail_len ) ; <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> return ; }",rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> len ) ; }
493,"static int key_notify_sa_flush ( const struct km_event * c ) { struct sk_buff * skb ; struct sadb_msg * hdr ; skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = pfkey_proto2satype ( c -> data . proto ) ; hdr -> sadb_msg_type = SADB_FLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }",) ) ; hdr -> sadb_msg_reserved = 0 ;
494,"uint16_t enc624j600ReadPhyReg ( NetInterface * interface , uint8_t address ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> usleep ( 100 ) ; <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> return enc624j600ReadReg ( interface , ENC624J600_REG_MIRD ) ; <S2SV_EndBug> }","address ) { uint16_t status ; <S2SV_ModStart> ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> | address ) <S2SV_ModStart> ( interface , ENC624J600_MICMD , ENC624J600_MICMD_MIIRD <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> 100 ) ; do { status = <S2SV_ModEnd> enc624j600ReadReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> != 0 ) ; <S2SV_ModEnd> enc624j600WriteReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MICMD <S2SV_ModEnd> , 0x00 ) <S2SV_ModStart> ( interface , ENC624J600_MIRD <S2SV_ModEnd> ) ; }"
495,"static void pkinit_server_verify_padata ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * data , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_error_code retval = 0 ; krb5_data authp_data = { 0 , 0 , NULL } , krb5_authz = { 0 , 0 , NULL } ; krb5_pa_pk_as_req * reqp = NULL ; krb5_pa_pk_as_req_draft9 * reqp9 = NULL ; krb5_auth_pack * auth_pack = NULL ; krb5_auth_pack_draft9 * auth_pack9 = NULL ; pkinit_kdc_context plgctx = NULL ; pkinit_kdc_req_context reqctx = NULL ; krb5_checksum cksum = { 0 , 0 , 0 , NULL } ; krb5_data * der_req = NULL ; int valid_eku = 0 , valid_san = 0 ; krb5_data k5data ; int is_signed = 1 ; krb5_pa_data * * e_data = NULL ; krb5_kdcpreauth_modreq modreq = NULL ; pkiDebug ( ""pkinit_verify_padata:<S2SV_blank>entered!\\n"" ) ; if ( data == NULL || data -> length <= 0 || data -> contents == NULL ) { <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> return ; } if ( moddata == NULL ) { ( * respond ) ( arg , EINVAL , NULL , NULL , NULL ) ; return ; } plgctx = pkinit_find_realm_context ( context , moddata , request -> server ) ; if ( plgctx == NULL ) { <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> return ; } # ifdef DEBUG_ASN1 print_buffer_bin ( data -> contents , data -> length , ""/tmp/kdc_as_req"" ) ; # endif retval = pkinit_init_kdc_req_context ( context , & reqctx ) ; if ( retval ) goto cleanup ; reqctx -> pa_type = data -> pa_type ; PADATA_TO_KRB5DATA ( data , & k5data ) ; switch ( ( int ) data -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : pkiDebug ( ""processing<S2SV_blank>KRB5_PADATA_PK_AS_REQ\\n"" ) ; retval = k5int_decode_krb5_pa_pk_as_req ( & k5data , & reqp ) ; if ( retval ) { pkiDebug ( ""decode_krb5_pa_pk_as_req<S2SV_blank>failed\\n"" ) ; goto cleanup ; } # ifdef DEBUG_ASN1 print_buffer_bin ( reqp -> signedAuthPack . data , reqp -> signedAuthPack . length , ""/tmp/kdc_signed_data"" ) ; # endif retval = cms_signeddata_verify ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_CLIENT , plgctx -> opts -> require_crl_checking , ( unsigned char * ) reqp -> signedAuthPack . data , reqp -> signedAuthPack . length , ( unsigned char * * ) & authp_data . data , & authp_data . length , ( unsigned char * * ) & krb5_authz . data , & krb5_authz . length , & is_signed ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : pkiDebug ( ""processing<S2SV_blank>KRB5_PADATA_PK_AS_REQ_OLD\\n"" ) ; retval = k5int_decode_krb5_pa_pk_as_req_draft9 ( & k5data , & reqp9 ) ; if ( retval ) { pkiDebug ( ""decode_krb5_pa_pk_as_req_draft9<S2SV_blank>failed\\n"" ) ; goto cleanup ; } # ifdef DEBUG_ASN1 print_buffer_bin ( reqp9 -> signedAuthPack . data , reqp9 -> signedAuthPack . length , ""/tmp/kdc_signed_data_draft9"" ) ; # endif retval = cms_signeddata_verify ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_DRAFT9 , plgctx -> opts -> require_crl_checking , ( unsigned char * ) reqp9 -> signedAuthPack . data , reqp9 -> signedAuthPack . length , ( unsigned char * * ) & authp_data . data , & authp_data . length , ( unsigned char * * ) & krb5_authz . data , & krb5_authz . length , NULL ) ; break ; default : pkiDebug ( ""unrecognized<S2SV_blank>pa_type<S2SV_blank>=<S2SV_blank>%d\\n"" , data -> pa_type ) ; retval = EINVAL ; goto cleanup ; } if ( retval ) { pkiDebug ( ""pkcs7_signeddata_verify<S2SV_blank>failed\\n"" ) ; goto cleanup ; } if ( is_signed ) { retval = verify_client_san ( context , plgctx , reqctx , request -> client , & valid_san ) ; if ( retval ) goto cleanup ; if ( ! valid_san ) { pkiDebug ( ""%s:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>an<S2SV_blank>acceptable<S2SV_blank>SAN<S2SV_blank>in<S2SV_blank>user<S2SV_blank>"" ""certificate\\n"" , __FUNCTION__ ) ; retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH ; goto cleanup ; } retval = verify_client_eku ( context , plgctx , reqctx , & valid_eku ) ; if ( retval ) goto cleanup ; if ( ! valid_eku ) { pkiDebug ( ""%s:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>an<S2SV_blank>acceptable<S2SV_blank>EKU<S2SV_blank>in<S2SV_blank>user<S2SV_blank>"" ""certificate\\n"" , __FUNCTION__ ) ; retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE ; goto cleanup ; } } else { if ( ! krb5_principal_compare ( context , request -> client , krb5_anonymous_principal ( ) ) ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; krb5_set_error_message ( context , retval , _ ( ""Pkinit<S2SV_blank>request<S2SV_blank>not<S2SV_blank>signed,<S2SV_blank>but<S2SV_blank>client<S2SV_blank>"" ""not<S2SV_blank>anonymous."" ) ) ; goto cleanup ; } } # ifdef DEBUG_ASN1 print_buffer_bin ( authp_data . data , authp_data . length , ""/tmp/kdc_auth_pack"" ) ; # endif OCTETDATA_TO_KRB5DATA ( & authp_data , & k5data ) ; switch ( ( int ) data -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : retval = k5int_decode_krb5_auth_pack ( & k5data , & auth_pack ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>krb5_auth_pack\\n"" ) ; goto cleanup ; } retval = krb5_check_clockskew ( context , auth_pack -> pkAuthenticator . ctime ) ; if ( retval ) goto cleanup ; if ( auth_pack -> clientPublicValue != NULL ) { retval = server_check_dh ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , & auth_pack -> clientPublicValue -> algorithm . parameters , plgctx -> opts -> dh_min_bits ) ; if ( retval ) { pkiDebug ( ""bad<S2SV_blank>dh<S2SV_blank>parameters\\n"" ) ; goto cleanup ; } } else if ( ! is_signed ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; krb5_set_error_message ( context , retval , _ ( ""Anonymous<S2SV_blank>pkinit<S2SV_blank>without<S2SV_blank>DH<S2SV_blank>public<S2SV_blank>"" ""value<S2SV_blank>not<S2SV_blank>supported."" ) ) ; goto cleanup ; } der_req = cb -> request_body ( context , rock ) ; retval = krb5_c_make_checksum ( context , CKSUMTYPE_NIST_SHA , NULL , 0 , der_req , & cksum ) ; if ( retval ) { pkiDebug ( ""unable<S2SV_blank>to<S2SV_blank>calculate<S2SV_blank>AS<S2SV_blank>REQ<S2SV_blank>checksum\\n"" ) ; goto cleanup ; } if ( cksum . length != auth_pack -> pkAuthenticator . paChecksum . length || k5_bcmp ( cksum . contents , auth_pack -> pkAuthenticator . paChecksum . contents , cksum . length ) != 0 ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>match<S2SV_blank>the<S2SV_blank>checksum\\n"" ) ; # ifdef DEBUG_CKSUM pkiDebug ( ""calculating<S2SV_blank>checksum<S2SV_blank>on<S2SV_blank>buf<S2SV_blank>size<S2SV_blank>(%d)\\n"" , req_pkt -> length ) ; print_buffer ( req_pkt -> data , req_pkt -> length ) ; pkiDebug ( ""received<S2SV_blank>checksum<S2SV_blank>type=%d<S2SV_blank>size=%d<S2SV_blank>"" , auth_pack -> pkAuthenticator . paChecksum . checksum_type , auth_pack -> pkAuthenticator . paChecksum . length ) ; print_buffer ( auth_pack -> pkAuthenticator . paChecksum . contents , auth_pack -> pkAuthenticator . paChecksum . length ) ; pkiDebug ( ""expected<S2SV_blank>checksum<S2SV_blank>type=%d<S2SV_blank>size=%d<S2SV_blank>"" , cksum . checksum_type , cksum . length ) ; print_buffer ( cksum . contents , cksum . length ) ; # endif retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED ; goto cleanup ; } if ( reqp -> kdcPkId . data != NULL ) { int valid_kdcPkId = 0 ; retval = pkinit_check_kdc_pkid ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , ( unsigned char * ) reqp -> kdcPkId . data , reqp -> kdcPkId . length , & valid_kdcPkId ) ; if ( retval ) goto cleanup ; if ( ! valid_kdcPkId ) pkiDebug ( ""kdcPkId<S2SV_blank>in<S2SV_blank>AS_REQ<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>KDC\'s<S2SV_blank>cert"" ""RFC<S2SV_blank>says<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>and<S2SV_blank>proceed\\n"" ) ; } reqctx -> rcv_auth_pack = auth_pack ; auth_pack = NULL ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : retval = k5int_decode_krb5_auth_pack_draft9 ( & k5data , & auth_pack9 ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>krb5_auth_pack_draft9\\n"" ) ; goto cleanup ; } if ( auth_pack9 -> clientPublicValue != NULL ) { retval = server_check_dh ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , & auth_pack9 -> clientPublicValue -> algorithm . parameters , plgctx -> opts -> dh_min_bits ) ; if ( retval ) { pkiDebug ( ""bad<S2SV_blank>dh<S2SV_blank>parameters\\n"" ) ; goto cleanup ; } } reqctx -> rcv_auth_pack9 = auth_pack9 ; auth_pack9 = NULL ; break ; } enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; modreq = ( krb5_kdcpreauth_modreq ) reqctx ; reqctx = NULL ; cleanup : if ( retval && data -> pa_type == KRB5_PADATA_PK_AS_REQ ) { pkiDebug ( ""pkinit_verify_padata<S2SV_blank>failed:<S2SV_blank>creating<S2SV_blank>e-data\\n"" ) ; if ( pkinit_create_edata ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , plgctx -> opts , retval , & e_data ) ) pkiDebug ( ""pkinit_create_edata<S2SV_blank>failed\\n"" ) ; } switch ( ( int ) data -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : free_krb5_pa_pk_as_req ( & reqp ) ; free ( cksum . contents ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : free_krb5_pa_pk_as_req_draft9 ( & reqp9 ) ; } free ( authp_data . data ) ; free ( krb5_authz . data ) ; if ( reqctx != NULL ) pkinit_fini_kdc_req_context ( context , reqctx ) ; free_krb5_auth_pack ( & auth_pack ) ; free_krb5_auth_pack_draft9 ( context , & auth_pack9 ) ; ( * respond ) ( arg , retval , modreq , e_data , NULL ) ; }","( arg , EINVAL <S2SV_ModEnd> , NULL , <S2SV_ModStart> ( arg , EINVAL <S2SV_ModEnd> , NULL ,"
496,"__be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }","skb ) { <S2SV_ModEnd> struct in6_addr buf <S2SV_ModStart> return 0 ; <S2SV_ModEnd> id = __ipv6_select_ident <S2SV_ModStart> ( net , <S2SV_ModEnd> & addrs ["
497,"static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , ""found<S2SV_blank>tfra\\n"" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) { <S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug> if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time = time ; index -> items [ i ] . moof_offset = offset ; for ( j = 0 ; j < ( ( fieldlength >> 4 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 2 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 0 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; } avio_seek ( f , pos + size , SEEK_SET ) ; return 0 ; }",", offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }"
498,static void ifb_setup ( struct net_device * dev ) { dev -> destructor = free_netdev ; dev -> netdev_ops = & ifb_netdev_ops ; ether_setup ( dev ) ; dev -> tx_queue_len = TX_Q_LIMIT ; dev -> features |= IFB_FEATURES ; dev -> vlan_features |= IFB_FEATURES ; dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> random_ether_addr ( dev -> dev_addr ) ; },priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; random_ether_addr (
499,"static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && ""TODO"" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , ""Cannot<S2SV_blank>encode<S2SV_blank>tile\\n"" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }","p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; }"
500,"struct r_bin_dyldcache_lib_t * r_bin_dyldcache_extract ( struct r_bin_dyldcache_obj_t * bin , int idx , int * nlib ) { ut64 liboff , linkedit_offset ; ut64 dyld_vmbase ; ut32 addend = 0 ; struct r_bin_dyldcache_lib_t * ret = NULL ; struct dyld_cache_image_info * image_infos = NULL ; struct mach_header * mh ; ut8 * data , * cmdptr ; int cmd , libsz = 0 ; RBuffer * dbuf ; char * libname ; if ( ! bin ) { return NULL ; } if ( bin -> size < 1 ) { eprintf ( ""Empty<S2SV_blank>file?<S2SV_blank>(%s)\\n"" , bin -> file ? bin -> file : ""(null)"" ) ; return NULL ; } if ( bin -> nlibs < 0 || idx < 0 || idx >= bin -> nlibs ) { return NULL ; } * nlib = bin -> nlibs ; ret = R_NEW0 ( struct r_bin_dyldcache_lib_t ) ; if ( ! ret ) { <S2SV_StartBug> perror ( ""malloc<S2SV_blank>(ret)"" ) ; <S2SV_EndBug> return NULL ; } if ( bin -> hdr . startaddr > bin -> size ) { eprintf ( ""corrupted<S2SV_blank>dyldcache"" ) ; free ( ret ) ; return NULL ; } if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) { eprintf ( ""corrupted<S2SV_blank>dyldcache"" ) ; free ( ret ) ; return NULL ; } <S2SV_StartBug> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; <S2SV_EndBug> <S2SV_StartBug> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; <S2SV_EndBug> liboff = image_infos [ idx ] . address - dyld_vmbase ; if ( liboff > bin -> size ) { eprintf ( ""Corrupted<S2SV_blank>file\\n"" ) ; free ( ret ) ; return NULL ; } ret -> offset = liboff ; <S2SV_StartBug> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""corrupted<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> free ( ret ) ; return NULL ; } <S2SV_StartBug> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; <S2SV_EndBug> data = bin -> b -> buf + liboff ; mh = ( struct mach_header * ) data ; if ( mh -> magic != MH_MAGIC && mh -> magic != MH_MAGIC_64 ) { if ( mh -> magic == 0xbebafeca ) { eprintf ( ""FAT<S2SV_blank>Binary\\n"" ) ; } eprintf ( ""Not<S2SV_blank>mach-o\\n"" ) ; free ( ret ) ; return NULL ; } if ( ! ( dbuf = r_buf_new ( ) ) ) { eprintf ( ""new<S2SV_blank>(dbuf)\\n"" ) ; free ( ret ) ; return NULL ; } addend = mh -> magic == MH_MAGIC ? sizeof ( struct mach_header ) : sizeof ( struct mach_header_64 ) ; r_buf_set_bytes ( dbuf , data , addend ) ; cmdptr = data + addend ; for ( cmd = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; r_buf_append_bytes ( dbuf , ( ut8 * ) lc , lc -> cmdsize ) ; cmdptr += lc -> cmdsize ; } cmdptr = data + addend ; for ( cmd = linkedit_offset = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; cmdptr += lc -> cmdsize ; switch ( lc -> cmd ) { case LC_SEGMENT : { struct segment_command * seg = ( struct segment_command * ) lc ; int t = seg -> filesize ; if ( seg -> fileoff + seg -> filesize > bin -> size || seg -> fileoff > bin -> size ) { eprintf ( ""malformed<S2SV_blank>dyldcache\\n"" ) ; free ( ret ) ; r_buf_free ( dbuf ) ; return NULL ; } r_buf_append_bytes ( dbuf , bin -> b -> buf + seg -> fileoff , t ) ; r_bin_dyldcache_apply_patch ( dbuf , dbuf -> length , ( ut64 ) ( ( size_t ) & seg -> fileoff - ( size_t ) data ) ) ; int sect_offset = seg -> fileoff - libsz ; libsz = dbuf -> length ; if ( ! strcmp ( seg -> segname , ""__LINKEDIT"" ) ) { linkedit_offset = sect_offset ; } if ( seg -> nsects > 0 ) { struct section * sects = ( struct section * ) ( ( ut8 * ) seg + sizeof ( struct segment_command ) ) ; int nsect ; for ( nsect = 0 ; nsect < seg -> nsects ; nsect ++ ) { if ( sects [ nsect ] . offset > libsz ) { r_bin_dyldcache_apply_patch ( dbuf , sects [ nsect ] . offset - sect_offset , ( ut64 ) ( ( size_t ) & sects [ nsect ] . offset - ( size_t ) data ) ) ; } } } } break ; case LC_SYMTAB : { struct symtab_command * st = ( struct symtab_command * ) lc ; NZ_OFFSET ( st -> symoff ) ; NZ_OFFSET ( st -> stroff ) ; } break ; case LC_DYSYMTAB : { struct dysymtab_command * st = ( struct dysymtab_command * ) lc ; NZ_OFFSET ( st -> tocoff ) ; NZ_OFFSET ( st -> modtaboff ) ; NZ_OFFSET ( st -> extrefsymoff ) ; NZ_OFFSET ( st -> indirectsymoff ) ; NZ_OFFSET ( st -> extreloff ) ; NZ_OFFSET ( st -> locreloff ) ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { struct dyld_info_command * st = ( struct dyld_info_command * ) lc ; NZ_OFFSET ( st -> rebase_off ) ; NZ_OFFSET ( st -> bind_off ) ; NZ_OFFSET ( st -> weak_bind_off ) ; NZ_OFFSET ( st -> lazy_bind_off ) ; NZ_OFFSET ( st -> export_off ) ; } break ; } } ret -> b = dbuf ; strncpy ( ret -> path , libname , sizeof ( ret -> path ) - 1 ) ; ret -> size = libsz ; return ret ; }","ret ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> NULL ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> hdr . startaddr , ( ut8 * ) image_infos , sz <S2SV_ModStart> ; dyld_vmbase = r_buf_read64le <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> = liboff ; int pfo = <S2SV_ModEnd> image_infos [ idx <S2SV_ModStart> ] . pathFileOffset ; if ( pfo < 0 || pfo <S2SV_ModStart> { eprintf ( ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n"" , pfo <S2SV_ModEnd> ) ; free <S2SV_ModStart> } libname = r_buf_read_string <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , pfo , 64 <S2SV_ModEnd> ) ; data"
501,"static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",") break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
502,"static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , ""mcs_recv_connect_response(),<S2SV_blank>result=%d"" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }","uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }"
503,"static int br_mdb_fill_info ( struct sk_buff * skb , struct netlink_callback * cb , struct net_device * dev ) { struct net_bridge * br = netdev_priv ( dev ) ; struct net_bridge_mdb_htable * mdb ; struct nlattr * nest , * nest2 ; int i , err = 0 ; int idx = 0 , s_idx = cb -> args [ 1 ] ; if ( br -> multicast_disabled ) return 0 ; mdb = rcu_dereference ( br -> mdb ) ; if ( ! mdb ) return 0 ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) return - EMSGSIZE ; for ( i = 0 ; i < mdb -> max ; i ++ ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p , * * pp ; struct net_bridge_port * port ; hlist_for_each_entry_rcu ( mp , & mdb -> mhash [ i ] , hlist [ mdb -> ver ] ) { if ( idx < s_idx ) goto skip ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) { err = - EMSGSIZE ; goto out ; } for ( pp = & mp -> ports ; ( p = rcu_dereference ( * pp ) ) != NULL ; pp = & p -> next ) { port = p -> port ; if ( port ) { struct br_mdb_entry e ; <S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> e . state = p -> state ; if ( p -> addr . proto == htons ( ETH_P_IP ) ) e . addr . u . ip4 = p -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) if ( p -> addr . proto == htons ( ETH_P_IPV6 ) ) e . addr . u . ip6 = p -> addr . u . ip6 ; # endif e . addr . proto = p -> addr . proto ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( e ) , & e ) ) { nla_nest_cancel ( skb , nest2 ) ; err = - EMSGSIZE ; goto out ; } } } nla_nest_end ( skb , nest2 ) ; skip : idx ++ ; } } out : cb -> args [ 1 ] = idx ; nla_nest_end ( skb , nest ) ; return err ; }","br_mdb_entry e ; memset ( & e , 0 , sizeof ( e ) ) ;"
504,"static inline signed short ReadPropertyMSBShort ( const unsigned char * * p , size_t * length ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 2 ] ; unsigned short value ; if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ; for ( i = 0 ; i < 2 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }",unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 8 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
505,"error_t enc28j60UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint8_t hashTable [ 8 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc28j60CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 8 ] |= ( 1 << ( k % 8 ) ) ; } } <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , hashTable [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , hashTable [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , hashTable [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , hashTable [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , hashTable [ 7 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT7 ) ) ; <S2SV_EndBug> return NO_ERROR ; }","( interface , ENC28J60_EHT0 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> ) ) ;"
506,"static bool parse_reconnect ( struct pool * pool , json_t * val ) { <S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> char * url , * port , address [ 256 ] ; <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>forbidden,<S2SV_blank>aborting."" ) ; return false ; } memset ( address , 0 , 255 ) ; <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> if ( ! url ) url = pool -> sockaddr_url ; port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ; <S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_NOTICE , ""Reconnect<S2SV_blank>requested<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s"" , get_pool_name ( pool ) , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }","val ) { if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ; return false ; } <S2SV_ModEnd> char * url <S2SV_ModStart> 256 ] ; char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> = ( char <S2SV_ModStart> ( val , <S2SV_ModEnd> 1 ) ) <S2SV_ModStart> -> stratum_port ; snprintf ( address , sizeof ( address ) <S2SV_ModEnd> , ""%s:%s"" ,"
507,"static int ovl_copy_up_locked ( struct dentry * workdir , struct dentry * upperdir , struct dentry * dentry , struct path * lowerpath , struct kstat * stat , struct iattr * attr , const char * link ) { struct inode * wdir = workdir -> d_inode ; struct inode * udir = upperdir -> d_inode ; struct dentry * newdentry = NULL ; struct dentry * upper = NULL ; umode_t mode = stat -> mode ; int err ; newdentry = ovl_lookup_temp ( workdir , dentry ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out1 ; stat -> mode &= S_IFMT ; err = ovl_create_real ( wdir , newdentry , stat , link , NULL , true ) ; stat -> mode = mode ; if ( err ) goto out2 ; if ( S_ISREG ( stat -> mode ) ) { struct path upperpath ; ovl_path_upper ( dentry , & upperpath ) ; BUG_ON ( upperpath . dentry != NULL ) ; upperpath . dentry = newdentry ; err = ovl_copy_up_data ( lowerpath , & upperpath , stat -> size ) ; if ( err ) goto out_cleanup ; } err = ovl_copy_xattr ( lowerpath -> dentry , newdentry ) ; if ( err ) goto out_cleanup ; mutex_lock ( & newdentry -> d_inode -> i_mutex ) ; err = ovl_set_attr ( newdentry , stat ) ; if ( ! err && attr ) err = notify_change ( newdentry , attr , NULL ) ; mutex_unlock ( & newdentry -> d_inode -> i_mutex ) ; if ( err ) goto out_cleanup ; err = ovl_do_rename ( wdir , newdentry , udir , upper , 0 ) ; if ( err ) goto out_cleanup ; ovl_dentry_update ( dentry , newdentry ) ; newdentry = NULL ; if ( ! S_ISDIR ( stat -> mode ) ) ovl_dentry_set_opaque ( dentry , true ) ; out2 : dput ( upper ) ; out1 : dput ( newdentry ) ; out : return err ; out_cleanup : ovl_cleanup ( wdir , newdentry ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> }",) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null>
508,"static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""and<S2SV_blank>forward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%s<S2SV_blank>merge<S2SV_blank>capability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown<S2SV_blank>%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { <S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }",0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid
509,"static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) ) <S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup : if ( supportedMech != GSS_C_NO_OID ) { generic_gss_release_oid ( & tmpmin , & supportedMech ) ; } return ret ; # undef REMAIN }",if ( REMAIN == 0 || REMAIN
510,"static grub_err_t read_foo ( struct grub_disk * disk , grub_disk_addr_t sector , grub_size_t size , char * buf ) { <S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> int ret ; RIOBind * iob = disk -> data ; <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug> return 0 ; }","{ if ( ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> const int blocksize <S2SV_ModStart> blocksize = 512 <S2SV_ModEnd> ; RIOBind * <S2SV_ModStart> ( bio ) { <S2SV_ModStart> = bio ; } if ( <S2SV_ModEnd> iob -> read_at <S2SV_ModStart> * blocksize ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> - 1 ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ;"
511,"static void sas_resume_port ( struct asd_sas_phy * phy ) { struct domain_device * dev ; struct asd_sas_port * port = phy -> port ; struct sas_ha_struct * sas_ha = phy -> ha ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; if ( si -> dft -> lldd_port_formed ) si -> dft -> lldd_port_formed ( phy ) ; if ( port -> suspended ) port -> suspended = 0 ; else { return ; } list_for_each_entry ( dev , & port -> dev_list , dev_list_node ) { int i , rc ; rc = sas_notify_lldd_dev_found ( dev ) ; if ( rc ) { <S2SV_StartBug> sas_unregister_dev ( port , dev ) ; <S2SV_EndBug> continue ; } if ( dev -> dev_type == SAS_EDGE_EXPANDER_DEVICE || dev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) { dev -> ex_dev . ex_change_count = - 1 ; for ( i = 0 ; i < dev -> ex_dev . num_phys ; i ++ ) { struct ex_phy * phy = & dev -> ex_dev . ex_phy [ i ] ; phy -> phy_change_count = - 1 ; } } } sas_discover_event ( port , DISCE_RESUME ) ; }","port , dev ) ; sas_destruct_devices ( port"
512,"WORD32 ih264d_parse_inter_slice_data_cabac ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD32 uc_more_data_flag ; WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 , u1_mb_idx ; UWORD32 u1_mbaff ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end = 0 ; UWORD32 u1_tfr_n_mb = 0 ; UWORD32 u1_decode_nmb = 0 ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; UWORD32 u1_inter_mb_skip_type ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD32 u1_mb_threshold ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; WORD32 ret = OK ; if ( ps_slice -> u1_slice_type == P_SLICE ) { u1_inter_mb_skip_type = CAB_P_SKIP ; u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; u1_mb_threshold = 5 ; } else { u1_inter_mb_skip_type = CAB_B_SKIP ; u1_inter_mb_type = B_MB ; u1_deblk_mb_type = D_B_SLICE ; u1_mb_threshold = 23 ; } i2_cur_mb_addr = u2_first_mb_in_slice ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; u1_num_mbsNby2 = 0 ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; uc_more_data_flag = 1 ; if ( ps_bitstrm -> u4_ofst & 0x07 ) { ps_bitstrm -> u4_ofst += 8 ; ps_bitstrm -> u4_ofst &= 0xFFFFFFF8 ; } ret = ih264d_init_cabac_dec_envirnoment ( & ( ps_dec -> s_cab_dec_env ) , ps_bitstrm ) ; if ( ret != OK ) return ret ; ps_dec -> i1_prev_mb_qp_delta = 0 ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; UWORD32 u4_mb_skip ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; u4_mb_skip = ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 1 ) ; ps_cur_mb_info -> u1_tran_form8x8 = 0 ; ps_cur_mb_info -> ps_curmb -> u1_tran_form8x8 = 0 ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; if ( u4_mb_skip ) { memset ( ps_dec -> ps_curr_ctxt_mb_info , 0 , sizeof ( ctxt_inc_mb_info_t ) ) ; ps_dec -> ps_curr_ctxt_mb_info -> u1_mb_type = u1_inter_mb_skip_type ; MEMSET_16BYTES ( & ps_dec -> pu1_left_mv_ctxt_inc [ 0 ] [ 0 ] , 0 ) ; * ( ( UWORD32 * ) ps_dec -> pi1_left_ref_idx_ctxt_inc ) = 0 ; * ( ps_dec -> pu1_left_yuv_dc_csbp ) = 0 ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_cbp = 0 ; { parse_part_params_t * ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; } ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CABAC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } else { u1_mb_type = ih264d_parse_mb_type_cabac ( ps_dec ) ; ps_cur_mb_info -> u1_mb_type = u1_mb_type ; if ( u1_mb_type > ( 25 + u1_mb_threshold ) ) return ERROR_MB_TYPE ; if ( u1_mb_type < u1_mb_threshold ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; * ( ps_dec -> pu1_left_yuv_dc_csbp ) &= 0x6 ; ret = ps_dec -> pf_parse_inter_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_num_mbsNby2 ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; } else { ps_parse_mb_data -> u1_num_part = 0 ; ps_parse_mb_data -> u1_isI_mb = 1 ; if ( ( 25 + u1_mb_threshold ) == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { if ( u1_mb_type == u1_mb_threshold ) ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_4x4_MB ; else ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_16x16_MB ; ret = ih264d_parse_imb_cabac ( ps_dec , ps_cur_mb_info , ( UWORD8 ) ( u1_mb_type - u1_mb_threshold ) ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } ps_cur_deblk_mb -> u1_mb_type |= D_INTRA_MB ; } } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; if ( ps_cur_mb_info -> u1_topmb && u1_mbaff ) uc_more_data_flag = 1 ; else { uc_more_data_flag = ih264d_decode_terminate ( & ps_dec -> s_cab_dec_env , ps_bitstrm ) ; uc_more_data_flag = ! uc_more_data_flag ; COPYTHECONTEXT ( ""Decode<S2SV_blank>Sliceterm"" , ! uc_more_data_flag ) ; } u1_num_mbs ++ ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! uc_more_data_flag ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; { ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } } if ( u1_decode_nmb ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }",u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; <S2SV_ModStart> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
513,"rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( ""client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( ""server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n"" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } <S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Open\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Close\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : buffer = malloc ( msg . tc . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( ""Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n"" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }",= malloc ( <S2SV_ModEnd> msg . sct
514,"int obj2ast_type_ignore ( PyObject * obj , type_ignore_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) TypeIgnore_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { int lineno ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res != 0 ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ; return 1 ; } * out = TypeIgnore ( lineno , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>type_ignore,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } * out = TypeIgnore ( <S2SV_ModEnd> lineno , arena <S2SV_ModStart> ; if ( * out == NULL <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; <S2SV_ModEnd> return 0 ;"
515,"int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; const VpxInterface * decoder = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder"" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame"" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { unsigned char digest [ 16 ] ; get_image_md5 ( img , digest ) ; print_md5 ( outfile , digest ) ; fprintf ( outfile , ""<S2SV_blank><S2SV_blank>img-%dx%d-%04d.i420\\n"" , img -> d_w , img -> d_h , ++ frame_cnt ) ; } } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }","( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,"
516,"static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> # if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }","* ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> } # else ( void ) ctx ; ( void ) args ;"
517,"void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; <S2SV_StartBug> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <S2SV_EndBug> # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ; <S2SV_StartBug> ACPI_OPERAND_OBJECT * Next ; <S2SV_EndBug> Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; } <S2SV_StartBug> } <S2SV_EndBug> # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespace<S2SV_blank>freed\\n"" ) ) ; return_VOID ; }",ACPI_STATUS Status ; <S2SV_ModEnd> ACPI_OPERAND_OBJECT * Prev <S2SV_ModStart> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode
518,"error_t tcpAddOption ( TcpHeader * segment , uint8_t kind , const void * value , uint8_t length ) { <S2SV_StartBug> uint_t i ; <S2SV_EndBug> size_t paddingSize ; TcpOption * option ; length += sizeof ( TcpOption ) ; <S2SV_StartBug> if ( ( segment -> dataOffset * 4 + length ) > TCP_MAX_HEADER_LENGTH ) <S2SV_EndBug> return ERROR_FAILURE ; <S2SV_StartBug> i = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> paddingSize = ( length % 4 ) ? 4 - ( length % 4 ) : 0 ; while ( paddingSize -- ) <S2SV_StartBug> segment -> options [ i ++ ] = TCP_OPTION_NOP ; <S2SV_EndBug> <S2SV_StartBug> option = ( TcpOption * ) ( segment -> options + i ) ; <S2SV_EndBug> option -> kind = kind ; option -> length = length ; osMemcpy ( option -> value , value , length - sizeof ( TcpOption ) ) ; i += length ; segment -> dataOffset = ( sizeof ( TcpHeader ) + i ) / 4 ; <S2SV_StartBug> return NO_ERROR ; <S2SV_EndBug> }",length ) { error_t error ; size_t <S2SV_ModEnd> i ; size_t <S2SV_ModStart> + length ) <= TCP_MAX_HEADER_LENGTH ) { i = ( <S2SV_ModEnd> segment -> dataOffset <S2SV_ModStart> dataOffset * 4 ) <S2SV_ModStart> paddingSize -- ) { <S2SV_ModStart> = TCP_OPTION_NOP ; } <S2SV_ModStart> / 4 ; error = NO_ERROR ; } else { error = ERROR_FAILURE ; } return error <S2SV_ModEnd> ; } <S2SV_null>
519,"static int skcipher_setkey ( void * private , const u8 * key , unsigned int keylen ) { <S2SV_StartBug> return crypto_skcipher_setkey ( private , key , keylen ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>","keylen ) { struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> , key , <S2SV_ModStart> keylen ) ; tfm -> has_key = ! err ; return err ;"
520,"static void win_enter_ext ( win_T * wp , int undo_sync , int curwin_invalid , int trigger_new_autocmds , int trigger_enter_autocmds , int trigger_leave_autocmds ) { int other_buffer = FALSE ; if ( wp == curwin && ! curwin_invalid ) return ; # ifdef FEAT_JOB_CHANNEL if ( ! curwin_invalid ) leaving_window ( curwin ) ; # endif if ( ! curwin_invalid && trigger_leave_autocmds ) { if ( wp -> w_buffer != curbuf ) { apply_autocmds ( EVENT_BUFLEAVE , NULL , NULL , FALSE , curbuf ) ; other_buffer = TRUE ; if ( ! win_valid ( wp ) ) return ; } apply_autocmds ( EVENT_WINLEAVE , NULL , NULL , FALSE , curbuf ) ; if ( ! win_valid ( wp ) ) return ; # ifdef FEAT_EVAL if ( aborting ( ) ) return ; # endif } if ( undo_sync && curbuf != wp -> w_buffer ) u_sync ( FALSE ) ; update_topline ( ) ; if ( wp -> w_buffer != curbuf ) buf_copy_options ( wp -> w_buffer , BCO_ENTER | BCO_NOHELP ) ; if ( ! curwin_invalid ) { prevwin = curwin ; curwin -> w_redr_status = TRUE ; } curwin = wp ; curbuf = wp -> w_buffer ; check_cursor ( ) ; if ( ! virtual_active ( ) ) curwin -> w_cursor . coladd = 0 ; changed_line_abv_curs ( ) ; if ( curwin -> w_localdir != NULL || curtab -> tp_localdir != NULL ) { char_u * dirname ; if ( globaldir == NULL ) { char_u cwd [ MAXPATHL ] ; if ( mch_dirname ( cwd , MAXPATHL ) == OK ) globaldir = vim_strsave ( cwd ) ; } if ( curwin -> w_localdir != NULL ) dirname = curwin -> w_localdir ; else dirname = curtab -> tp_localdir ; if ( mch_chdir ( ( char * ) dirname ) == 0 ) shorten_fnames ( TRUE ) ; } else if ( globaldir != NULL ) { vim_ignored = mch_chdir ( ( char * ) globaldir ) ; VIM_CLEAR ( globaldir ) ; shorten_fnames ( TRUE ) ; } # ifdef FEAT_JOB_CHANNEL entering_window ( curwin ) ; # endif if ( trigger_new_autocmds ) apply_autocmds ( EVENT_WINNEW , NULL , NULL , FALSE , curbuf ) ; if ( trigger_enter_autocmds ) { apply_autocmds ( EVENT_WINENTER , NULL , NULL , FALSE , curbuf ) ; if ( other_buffer ) apply_autocmds ( EVENT_BUFENTER , NULL , NULL , FALSE , curbuf ) ; } # ifdef FEAT_TITLE maketitle ( ) ; # endif curwin -> w_redr_status = TRUE ; # ifdef FEAT_TERMINAL <S2SV_StartBug> if ( bt_terminal ( wp -> w_buffer ) ) <S2SV_EndBug> redraw_mode = TRUE ; # endif redraw_tabline = TRUE ; if ( restart_edit ) redraw_later ( VALID ) ; if ( curwin -> w_height < p_wh && ! curwin -> w_p_wfh # ifdef FEAT_TEXT_PROP && ! popup_is_popup ( curwin ) # endif ) win_setheight ( ( int ) p_wh ) ; else if ( curwin -> w_height == 0 ) win_setheight ( 1 ) ; if ( curwin -> w_width < p_wiw && ! curwin -> w_p_wfw ) win_setwidth ( ( int ) p_wiw ) ; setmouse ( ) ; DO_AUTOCHDIR ; }",( bt_terminal ( curwin <S2SV_ModEnd> -> w_buffer )
521,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { DelogoContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; AVFrame * out ; int hsub0 = desc -> log2_chroma_w ; int vsub0 = desc -> log2_chroma_h ; int direct = 0 ; int plane ; AVRational sar ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } sar = in -> sample_aspect_ratio ; if ( ! sar . num ) sar . num = sar . den = 1 ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ; apply_delogo ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , FF_CEIL_RSHIFT ( inlink -> w , hsub ) , FF_CEIL_RSHIFT ( inlink -> h , vsub ) , sar , s -> x >> hsub , s -> y >> vsub , FF_CEIL_RSHIFT ( s -> w + ( s -> x & ( ( 1 << hsub ) - 1 ) ) , hsub ) , FF_CEIL_RSHIFT ( s -> h + ( s -> y & ( ( 1 << vsub ) - 1 ) ) , vsub ) , s -> band >> FFMIN ( hsub , vsub ) , s -> show , direct ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }",in -> data [ plane ] && in -> linesize
522,"static void find_next_key_frame ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) { int i , j ; RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> const FIRSTPASS_STATS first_frame = * this_frame ; <S2SV_StartBug> const FIRSTPASS_STATS * start_position = twopass -> stats_in ; <S2SV_EndBug> FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS last_frame ; <S2SV_StartBug> double decay_accumulator = 1.0 ; <S2SV_EndBug> double zero_motion_accumulator = 1.0 ; double boost_score = 0.0 ; double kf_mod_err = 0.0 ; double kf_group_err = 0.0 ; double recent_loop_decay [ 8 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 } ; vp9_zero ( next_frame ) ; cpi -> common . frame_type = KEY_FRAME ; <S2SV_StartBug> rc -> this_key_frame_forced = rc -> next_key_frame_forced ; <S2SV_EndBug> rc -> source_alt_ref_active = 0 ; <S2SV_StartBug> rc -> frames_till_gf_update_due = 0 ; <S2SV_EndBug> rc -> frames_to_key = 1 ; twopass -> kf_group_bits = 0 ; twopass -> kf_group_error_left = 0 ; <S2SV_StartBug> kf_mod_err = calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> i = 0 ; <S2SV_StartBug> while ( twopass -> stats_in < twopass -> stats_in_end ) { <S2SV_EndBug> <S2SV_StartBug> kf_group_err += calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> last_frame = * this_frame ; input_stats ( twopass , this_frame ) ; if ( cpi -> oxcf . auto_key && <S2SV_StartBug> lookup_next_frame_stats ( twopass , & next_frame ) != EOF ) { <S2SV_EndBug> double loop_decay_rate ; <S2SV_StartBug> if ( test_candidate_kf ( twopass , & last_frame , this_frame , & next_frame ) ) <S2SV_EndBug> break ; <S2SV_StartBug> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; <S2SV_EndBug> recent_loop_decay [ i % 8 ] = loop_decay_rate ; decay_accumulator = 1.0 ; for ( j = 0 ; j < 8 ; ++ j ) decay_accumulator *= recent_loop_decay [ j ] ; <S2SV_StartBug> if ( detect_transition_to_still ( twopass , i , cpi -> key_frame_frequency - i , <S2SV_EndBug> loop_decay_rate , decay_accumulator ) ) break ; ++ rc -> frames_to_key ; <S2SV_StartBug> if ( rc -> frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency ) <S2SV_EndBug> break ; } else { ++ rc -> frames_to_key ; } ++ i ; } if ( cpi -> oxcf . auto_key && <S2SV_StartBug> rc -> frames_to_key > ( int ) cpi -> key_frame_frequency ) { <S2SV_EndBug> FIRSTPASS_STATS tmp_frame = first_frame ; rc -> frames_to_key /= 2 ; reset_fpf_position ( twopass , start_position ) ; <S2SV_StartBug> kf_group_err = 0 ; <S2SV_EndBug> for ( i = 0 ; i < rc -> frames_to_key ; ++ i ) { <S2SV_StartBug> kf_group_err += calculate_modified_err ( cpi , & tmp_frame ) ; <S2SV_EndBug> input_stats ( twopass , & tmp_frame ) ; } rc -> next_key_frame_forced = 1 ; <S2SV_StartBug> } else if ( twopass -> stats_in == twopass -> stats_in_end ) { <S2SV_EndBug> rc -> next_key_frame_forced = 1 ; } else { rc -> next_key_frame_forced = 0 ; } <S2SV_StartBug> if ( twopass -> stats_in >= twopass -> stats_in_end ) { <S2SV_EndBug> <S2SV_StartBug> kf_group_err += calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> } if ( twopass -> bits_left > 0 && twopass -> modified_error_left > 0.0 ) { const int max_bits = frame_max_bits ( rc , & cpi -> oxcf ) ; int64_t max_grp_bits ; twopass -> kf_group_bits = ( int64_t ) ( twopass -> bits_left * ( kf_group_err / twopass -> modified_error_left ) ) ; max_grp_bits = ( int64_t ) max_bits * ( int64_t ) rc -> frames_to_key ; if ( twopass -> kf_group_bits > max_grp_bits ) twopass -> kf_group_bits = max_grp_bits ; } else { twopass -> kf_group_bits = 0 ; } <S2SV_StartBug> reset_fpf_position ( twopass , start_position ) ; <S2SV_EndBug> decay_accumulator = 1.0 ; boost_score = 0.0 ; <S2SV_StartBug> for ( i = 0 ; i < rc -> frames_to_key ; ++ i ) { <S2SV_EndBug> if ( EOF == input_stats ( twopass , & next_frame ) ) break ; <S2SV_StartBug> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < <S2SV_EndBug> zero_motion_accumulator ) { zero_motion_accumulator = ( next_frame . pcnt_inter - next_frame . pcnt_motion ) ; } <S2SV_StartBug> if ( i <= ( rc -> max_gf_interval * 2 ) ) { <S2SV_EndBug> double r ; if ( next_frame . intra_error > twopass -> kf_intra_err_min ) r = ( IIKFACTOR2 * next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; else r = ( IIKFACTOR2 * twopass -> kf_intra_err_min / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; if ( r > RMAX ) r = RMAX ; if ( ! detect_flash ( twopass , 0 ) ) { <S2SV_StartBug> const double loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , <S2SV_EndBug> & next_frame ) ; decay_accumulator *= loop_decay_rate ; decay_accumulator = MAX ( decay_accumulator , MIN_DECAY_FACTOR ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * r ) ; <S2SV_EndBug> } } { FIRSTPASS_STATS sectionstats ; zero_stats ( & sectionstats ) ; reset_fpf_position ( twopass , start_position ) ; <S2SV_StartBug> for ( i = 0 ; i < rc -> frames_to_key ; ++ i ) { <S2SV_EndBug> input_stats ( twopass , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; <S2SV_StartBug> twopass -> section_intra_rating = ( int ) ( sectionstats . intra_error / <S2SV_EndBug> DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; } reset_fpf_position ( twopass , start_position ) ; if ( 1 ) { int kf_boost = ( int ) boost_score ; int allocation_chunks ; if ( kf_boost < ( rc -> frames_to_key * 3 ) ) <S2SV_StartBug> kf_boost = ( rc -> frames_to_key * 3 ) ; <S2SV_EndBug> if ( kf_boost < MIN_KF_BOOST ) kf_boost = MIN_KF_BOOST ; rc -> kf_boost = kf_boost ; twopass -> kf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 100.0 ) ; if ( zero_motion_accumulator >= 0.99 ) { <S2SV_StartBug> allocation_chunks = ( ( rc -> frames_to_key - 1 ) * 10 ) + kf_boost ; <S2SV_EndBug> } else { <S2SV_StartBug> allocation_chunks = ( ( rc -> frames_to_key - 1 ) * 100 ) + kf_boost ; <S2SV_EndBug> } if ( kf_boost > 1028 ) { const int divisor = kf_boost >> 10 ; kf_boost /= divisor ; allocation_chunks /= divisor ; } twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ; twopass -> kf_bits = ( int ) ( ( double ) kf_boost * ( ( double ) twopass -> kf_group_bits / allocation_chunks ) ) ; if ( kf_mod_err < kf_group_err / rc -> frames_to_key ) { double alt_kf_grp_bits = ( ( double ) twopass -> bits_left * ( kf_mod_err * ( double ) rc -> frames_to_key ) / DOUBLE_DIVIDE_CHECK ( twopass -> modified_error_left ) ) ; const int alt_kf_bits = ( int ) ( ( double ) kf_boost * ( alt_kf_grp_bits / ( double ) allocation_chunks ) ) ; if ( twopass -> kf_bits > alt_kf_bits ) twopass -> kf_bits = alt_kf_bits ; } else { const int alt_kf_bits = ( int ) ( ( double ) twopass -> bits_left * ( kf_mod_err / DOUBLE_DIVIDE_CHECK ( twopass -> modified_error_left ) ) ) ; if ( alt_kf_bits > twopass -> kf_bits ) twopass -> kf_bits = alt_kf_bits ; } <S2SV_StartBug> twopass -> kf_group_bits -= twopass -> kf_bits ; <S2SV_EndBug> vp9_rc_set_frame_target ( cpi , twopass -> kf_bits ) ; } twopass -> kf_group_error_left = ( int ) ( kf_group_err - kf_mod_err ) ; twopass -> modified_error_left -= kf_group_err ; <S2SV_StartBug> } <S2SV_EndBug>","-> rc ; TWO_PASS <S2SV_ModEnd> * const twopass <S2SV_ModStart> cpi -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group ; const VP9EncoderConfig * const oxcf = & cpi -> oxcf <S2SV_ModStart> const FIRSTPASS_STATS * const <S2SV_ModStart> FIRSTPASS_STATS last_frame ; int kf_bits = 0 ; int loop_decay_counter = 0 ; <S2SV_ModStart> decay_accumulator = 1.0 ; double av_decay_accumulator = 0.0 <S2SV_ModStart> = KEY_FRAME ; vp9_zero ( * gf_group ) ; <S2SV_ModStart> = 0 ; cpi -> multi_arf_last_grp_enabled = 0 ; <S2SV_ModStart> calculate_modified_err ( cpi , twopass , oxcf <S2SV_ModStart> twopass -> stats_in_end && rc -> frames_to_key < cpi -> oxcf . key_freq <S2SV_ModStart> ( cpi , twopass , oxcf , <S2SV_ModStart> . auto_key && twopass -> stats_in < twopass -> stats_in_end <S2SV_ModEnd> ) { double <S2SV_ModStart> , this_frame , twopass -> stats_in <S2SV_ModEnd> ) ) break <S2SV_ModStart> = get_prediction_decay_rate ( cpi , twopass -> stats_in <S2SV_ModEnd> ) ; recent_loop_decay <S2SV_ModStart> ( detect_transition_to_still ( cpi <S2SV_ModEnd> , i , <S2SV_ModStart> , cpi -> oxcf . key_freq <S2SV_ModEnd> - i , <S2SV_ModStart> >= 2 * cpi -> oxcf . key_freq <S2SV_ModEnd> ) break ; <S2SV_ModStart> -> frames_to_key > cpi -> oxcf . key_freq <S2SV_ModEnd> ) { FIRSTPASS_STATS <S2SV_ModStart> ; kf_group_err = 0.0 <S2SV_ModEnd> ; for ( <S2SV_ModStart> ( cpi , twopass , oxcf , <S2SV_ModStart> twopass -> stats_in_end || rc -> frames_to_key >= cpi -> oxcf . key_freq <S2SV_ModStart> } if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_frame_to_key = ( rc -> frames_to_key + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_frame_to_key - rc -> frames_to_key ; ++ j ) { if ( EOF == input_stats ( twopass , this_frame ) ) break ; <S2SV_ModEnd> kf_group_err += calculate_modified_err <S2SV_ModStart> ( cpi , twopass , oxcf , this_frame ) ; } rc -> frames_to_key = new_frame_to_key ; } if ( twopass -> stats_in >= twopass -> stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , <S2SV_ModStart> 0 ; } twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ; <S2SV_ModStart> ; i < ( rc -> frames_to_key - 1 ) <S2SV_ModEnd> ; ++ i <S2SV_ModStart> ) break ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; if ( <S2SV_ModEnd> ( i <= <S2SV_ModStart> ( i <= <S2SV_ModEnd> rc -> max_gf_interval <S2SV_ModStart> rc -> max_gf_interval ) || ( ( i <= ( rc -> max_gf_interval * 4 ) ) && ( decay_accumulator > 0.5 ) ) ) { const double frame_boost = calc_frame_boost ( cpi , this_frame , 0 , KF_MAX_BOOST ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> = get_prediction_decay_rate ( cpi , <S2SV_ModEnd> & next_frame ) <S2SV_ModStart> MIN_DECAY_FACTOR ) ; av_decay_accumulator += decay_accumulator ; ++ loop_decay_counter ; <S2SV_ModStart> ( decay_accumulator * frame_boost ) ; } } av_decay_accumulator /= ( double ) loop_decay_counter <S2SV_ModEnd> ; reset_fpf_position ( <S2SV_ModStart> start_position ) ; twopass -> kf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 100.0 <S2SV_ModEnd> ) ; twopass <S2SV_ModStart> -> section_intra_rating = calculate_section_intra_ratio ( start_position , twopass -> stats_in_end , rc -> frames_to_key ) ; rc -> kf_boost = <S2SV_ModStart> int ) ( av_decay_accumulator * boost_score ) ; rc -> kf_boost = MAX ( rc -> kf_boost , <S2SV_ModEnd> ( rc -> <S2SV_ModStart> 3 ) ) ; rc -> kf_boost = MAX ( rc -> kf_boost , MIN_KF_BOOST ) ; kf_bits = calculate_boost_bits <S2SV_ModEnd> ( ( rc <S2SV_ModStart> - 1 ) , rc -> kf_boost , twopass -> kf_group_bits ) ; if ( twopass -> kf_group_bits ) { twopass -> kfgroup_inter_fraction = ( double ) ( twopass -> kf_group_bits - kf_bits ) / ( double ) twopass -> kf_group_bits <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { twopass -> kfgroup_inter_fraction = 1.0 <S2SV_ModEnd> ; } twopass <S2SV_ModStart> -> kf_group_bits -= kf_bits ; gf_group -> bit_allocation [ 0 ] = kf_bits ; gf_group -> update_type [ 0 ] = KF_UPDATE ; gf_group -> rf_level [ 0 ] = KF_STD ; <S2SV_ModEnd> twopass -> kf_group_error_left <S2SV_ModStart> -= kf_group_err ; if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED ; }"
523,"<S2SV_StartBug> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <S2SV_EndBug> { static const struct ip6t_ip6 uncond ; <S2SV_StartBug> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> }","( const struct ip6t_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> ipv6 , &"
524,"void safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while ( * p != '\\0' ) { if ( try_wc && ( n = mbtowc ( & wc , p , length ) ) != - 1 ) { length -= n ; if ( iswprint ( wc ) && wc != L'\\\\' ) { while ( n -- > 0 ) outbuff [ i ++ ] = * p ++ ; } else { while ( n -- > 0 ) i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; } } else { i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; try_wc = 0 ; } <S2SV_StartBug> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <S2SV_EndBug> outbuff [ i ] = '\\0' ; fprintf ( f , ""%s"" , outbuff ) ; i = 0 ; } } outbuff [ i ] = '\\0' ; fprintf ( f , ""%s"" , outbuff ) ; free ( fmtbuff_heap ) ; }",outbuff ) - 128 <S2SV_ModEnd> ) ) {
525,"static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> return r ; }","++ r ; if <S2SV_ModEnd> ( pow ( <S2SV_ModStart> , dim ) <= entries ) return - 1 ; if <S2SV_ModEnd> ( ( int <S2SV_ModStart> dim ) ) > entries ) return - 1 <S2SV_ModEnd> ; return r"
526,"sctp_disposition_t sctp_sf_do_5_2_4_dupcook ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { sctp_disposition_t retval ; struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; int error = 0 ; char action ; struct sctp_chunk * err_chk_p ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } action = sctp_tietags_compare ( new_asoc , asoc ) ; switch ( action ) { case 'A' : retval = sctp_sf_do_dupcook_a ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'B' : retval = sctp_sf_do_dupcook_b ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'C' : retval = sctp_sf_do_dupcook_c ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'D' : retval = sctp_sf_do_dupcook_d ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; default : retval = sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; break ; } <S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( ( struct sctp_association * ) asoc ) ) ; return retval ; nomem : return SCTP_DISPOSITION_NOMEM ; }","( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC ("
527,"int nego_recv ( rdpTransport * transport , wStream * s , void * extra ) { BYTE li ; BYTE type ; UINT16 length ; rdpNego * nego = ( rdpNego * ) extra ; if ( ! tpkt_read_header ( s , & length ) ) return - 1 ; if ( ! tpdu_read_connection_confirm ( s , & li , length ) ) return - 1 ; if ( li > 6 ) { Stream_Read_UINT8 ( s , type ) ; switch ( type ) { case TYPE_RDP_NEG_RSP : <S2SV_StartBug> nego_process_negotiation_response ( nego , s ) ; <S2SV_EndBug> WLog_DBG ( TAG , ""selected_protocol:<S2SV_blank>%"" PRIu32 """" , nego -> SelectedProtocol ) ; if ( nego -> SelectedProtocol ) { if ( ( nego -> SelectedProtocol == PROTOCOL_HYBRID ) && ( ! nego -> EnabledProtocols [ PROTOCOL_HYBRID ] ) ) { nego -> state = NEGO_STATE_FAIL ; } if ( ( nego -> SelectedProtocol == PROTOCOL_SSL ) && ( ! nego -> EnabledProtocols [ PROTOCOL_SSL ] ) ) { nego -> state = NEGO_STATE_FAIL ; } } else if ( ! nego -> EnabledProtocols [ PROTOCOL_RDP ] ) { nego -> state = NEGO_STATE_FAIL ; } break ; case TYPE_RDP_NEG_FAILURE : <S2SV_StartBug> nego_process_negotiation_failure ( nego , s ) ; <S2SV_EndBug> break ; } } else if ( li == 6 ) { WLog_DBG ( TAG , ""no<S2SV_blank>rdpNegData"" ) ; if ( ! nego -> EnabledProtocols [ PROTOCOL_RDP ] ) nego -> state = NEGO_STATE_FAIL ; else nego -> state = NEGO_STATE_FINAL ; } else { WLog_ERR ( TAG , ""invalid<S2SV_blank>negotiation<S2SV_blank>response"" ) ; nego -> state = NEGO_STATE_FAIL ; } if ( ! tpkt_ensure_stream_consumed ( s , length ) ) return - 1 ; return 0 ; }","case TYPE_RDP_NEG_RSP : if ( ! <S2SV_ModStart> , s ) ) return - 1 <S2SV_ModStart> case TYPE_RDP_NEG_FAILURE : if ( ! <S2SV_ModStart> , s ) ) return - 1"
528,"static void swap_block_ptr ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , <S2SV_StartBug> int max_plane ) { <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * const p = x -> plane ; <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * const pd = x -> e_mbd . plane ; <S2SV_EndBug> int i ; for ( i = 0 ; i < max_plane ; ++ i ) { <S2SV_StartBug> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> ctx -> coeff_pbuf [ i ] [ 1 ] = ctx -> coeff_pbuf [ i ] [ 0 ] ; ctx -> qcoeff_pbuf [ i ] [ 1 ] = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; ctx -> dqcoeff_pbuf [ i ] [ 1 ] = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; ctx -> eobs_pbuf [ i ] [ 1 ] = ctx -> eobs_pbuf [ i ] [ 0 ] ; ctx -> coeff_pbuf [ i ] [ 0 ] = p [ i ] . coeff ; <S2SV_StartBug> ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ; <S2SV_EndBug> <S2SV_StartBug> ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ; <S2SV_EndBug> <S2SV_StartBug> ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ; <S2SV_EndBug> } }","ctx , int m , int n , int min_plane , int <S2SV_ModStart> max_plane ) { int i ; for ( i = min_plane ; i < max_plane ; ++ i ) { <S2SV_ModStart> const p = & <S2SV_ModStart> x -> plane [ i ] <S2SV_ModStart> const pd = & <S2SV_ModStart> e_mbd . plane [ i ] ; p -> <S2SV_ModEnd> coeff = ctx <S2SV_ModStart> i ] [ m ] ; p -> <S2SV_ModEnd> qcoeff = ctx <S2SV_ModStart> i ] [ m <S2SV_ModEnd> ] ; pd <S2SV_ModStart> ] ; pd -> <S2SV_ModEnd> dqcoeff = ctx <S2SV_ModStart> i ] [ m ] ; p -> <S2SV_ModEnd> eobs = ctx <S2SV_ModStart> i ] [ m ] ; ctx -> coeff_pbuf [ i ] [ m ] = ctx -> coeff_pbuf [ i ] [ n ] ; ctx -> qcoeff_pbuf [ i ] [ m ] = ctx -> qcoeff_pbuf [ i ] [ n ] ; ctx -> dqcoeff_pbuf [ i ] [ m ] = ctx -> dqcoeff_pbuf [ i ] [ n ] ; ctx -> eobs_pbuf [ i ] [ m ] = ctx -> eobs_pbuf [ i ] [ n ] ; ctx -> coeff_pbuf [ i ] [ n ] = p -> <S2SV_ModEnd> coeff ; ctx <S2SV_ModStart> i ] [ n ] = p -> <S2SV_ModEnd> qcoeff ; ctx <S2SV_ModStart> i ] [ n <S2SV_ModEnd> ] = pd <S2SV_ModStart> ] = pd -> <S2SV_ModEnd> dqcoeff ; ctx <S2SV_ModStart> i ] [ n ] = p -> <S2SV_ModEnd> eobs ; }"
529,"size_t OpenMP4Source ( char * filename , uint32_t traktype , uint32_t traksubtype ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; <S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { uint32_t qttag , qtsize32 , skip , type = 0 , subtype = 0 , num ; size_t len ; int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> { if ( ! VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; # if PRINT_MP4_STRUCTURE for ( int i = 1 ; i < nest ; i ++ ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; printf ( ""%c%c%c%c<S2SV_blank>(%lld)\\n"" , ( qttag & 0xff ) , ( ( qttag >> 8 ) & 0xff ) , ( ( qttag >> 16 ) & 0xff ) , ( ( qttag >> 24 ) & 0xff ) , qtsize ) ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) || <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> { <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } # else if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'm' , 'v' , 'h' , 'd' ) && qttag != MAKEID ( 't' , 'r' , 'a' , 'k' ) && qttag != MAKEID ( 'm' , 'd' , 'i' , 'a' ) && qttag != MAKEID ( 'm' , 'd' , 'h' , 'd' ) && qttag != MAKEID ( 'm' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'g' , 'm' , 'i' , 'n' ) && qttag != MAKEID ( 'd' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && qttag != MAKEID ( 's' , 't' , 's' , 'd' ) && <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> qttag != MAKEID ( 'c' , 'o' , '6' , '4' ) && qttag != MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else # endif if ( qttag == MAKEID ( 'm' , 'v' , 'h' , 'd' ) ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & mp4 -> clockdemon , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockdemon = BYTESWAP32 ( mp4 -> clockdemon ) ; len += fread ( & mp4 -> clockcount , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockcount = BYTESWAP32 ( mp4 -> clockcount ) ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'm' , 'd' , 'h' , 'd' ) ) { media_header md ; len = fread ( & md , 1 , sizeof ( md ) , mp4 -> mediafp ) ; if ( len == sizeof ( md ) ) { md . creation_time = BYTESWAP32 ( md . creation_time ) ; md . modification_time = BYTESWAP32 ( md . modification_time ) ; md . time_scale = BYTESWAP32 ( md . time_scale ) ; md . duration = BYTESWAP32 ( md . duration ) ; mp4 -> trak_clockdemon = md . time_scale ; mp4 -> trak_clockcount = md . duration ; if ( mp4 -> videolength == 0.0 ) { mp4 -> videolength = ( float ) ( ( double ) mp4 -> trak_clockcount / ( double ) mp4 -> trak_clockdemon ) ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { uint32_t temp ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & temp , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> type = temp ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'd' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & subtype , 1 , 4 , mp4 -> mediafp ) ; if ( len == 16 ) { if ( subtype != traksubtype ) { type = 0 ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'c' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 12 <= qtsize - 8 - len ) { mp4 -> metastsc_count = num ; if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> if ( mp4 -> metastsc ) { <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> len += fread ( mp4 -> metastsc , 1 , num * sizeof ( SampleToChunk ) , mp4 -> mediafp ) ; do { num -- ; mp4 -> metastsc [ num ] . chunk_num = BYTESWAP32 ( mp4 -> metastsc [ num ] . chunk_num ) ; mp4 -> metastsc [ num ] . samples = BYTESWAP32 ( mp4 -> metastsc [ num ] . samples ) ; mp4 -> metastsc [ num ] . id = BYTESWAP32 ( mp4 -> metastsc [ num ] . id ) ; } while ( num > 0 ) ; } <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> { if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'z' ) ) { if ( type == traktype ) { uint32_t equalsamplesize ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & equalsamplesize , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { mp4 -> metasize_count = num ; if ( mp4 -> metasizes ) free ( mp4 -> metasizes ) ; <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> if ( mp4 -> metasizes ) { if ( equalsamplesize == 0 ) { len += fread ( mp4 -> metasizes , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metasizes [ num ] = BYTESWAP32 ( mp4 -> metasizes [ num ] ) ; } while ( num > 0 ) ; } else { equalsamplesize = BYTESWAP32 ( equalsamplesize ) ; do { num -- ; mp4 -> metasizes [ num ] = equalsamplesize ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 'c' , 'o' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> { <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; int repeat = 1 ; len += fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; metaoffsets32 [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; mp4 -> metaoffsets [ 0 ] = fileoffset = metaoffsets32 [ stco_pos ] ; num = 1 ; <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> { if ( stsc_pos + 1 < ( int ) mp4 -> metastsc_count && num == stsc_pos ) { stco_pos ++ ; stsc_pos ++ ; fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; repeat = 1 ; } else if ( repeat == mp4 -> metastsc [ stsc_pos ] . samples ) { <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets32 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { size_t readlen = fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; len += readlen ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; free ( metaoffsets32 ) ; } } } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'c' , 'o' , '6' , '4' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> { if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) { mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; if ( mp4 -> metaoffsets ) { uint64_t * metaoffsets64 = NULL ; metaoffsets64 = ( uint64_t * ) malloc ( num * 8 ) ; if ( metaoffsets64 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; len += fread ( metaoffsets64 , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; metaoffsets64 [ num ] = BYTESWAP64 ( metaoffsets64 [ num ] ) ; } while ( num > 0 ) ; fileoffset = metaoffsets64 [ 0 ] ; mp4 -> metaoffsets [ 0 ] = fileoffset ; num = 1 ; while ( num < mp4 -> metasize_count ) { if ( num != mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 && 0 == ( num - ( mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 ) ) % mp4 -> metastsc [ stsc_pos ] . samples ) { stco_pos ++ ; fileoffset = ( uint64_t ) metaoffsets64 [ stco_pos ] ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets64 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { len += fread ( mp4 -> metaoffsets , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP64 ( mp4 -> metaoffsets [ num ] ) ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 't' , 's' ) ) { if ( type == traktype ) { uint32_t totaldur = 0 , samples = 0 ; int32_t entries = 0 ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 8 <= qtsize - 8 - len ) { entries = num ; mp4 -> meta_clockdemon = mp4 -> trak_clockdemon ; mp4 -> meta_clockcount = mp4 -> trak_clockcount ; while ( entries > 0 ) { int32_t samplecount ; int32_t duration ; len += fread ( & samplecount , 1 , 4 , mp4 -> mediafp ) ; samplecount = BYTESWAP32 ( samplecount ) ; len += fread ( & duration , 1 , 4 , mp4 -> mediafp ) ; duration = BYTESWAP32 ( duration ) ; samples += samplecount ; entries -- ; totaldur += duration ; mp4 -> metadatalength += ( double ) ( ( double ) samplecount * ( double ) duration / ( double ) mp4 -> meta_clockdemon ) ; } mp4 -> basemetadataduration = mp4 -> metadatalength * ( double ) mp4 -> meta_clockdemon / ( double ) samples ; } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else { NESTSIZE ( 8 ) ; } } else { break ; } } while ( len > 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> else { free ( mp4 ) ; mp4 = NULL ; } return ( size_t ) mp4 ; }","mp4object ) ) ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mediafp ) ; mp4 -> filepos += len ; <S2SV_ModStart> len == 8 && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> ) ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> ; } qtsize32 <S2SV_ModStart> 1 ) { len = <S2SV_ModStart> -> mediafp ) ; mp4 -> filepos += len <S2SV_ModStart> , 'a' ) || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> != MAKEID ( 's' , 't' , 'b' , 'l' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 's' , 't' , 't' <S2SV_ModEnd> , 's' ) <S2SV_ModStart> , 't' , 's' , 'c' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 's' , 'z' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 'c' , 'o' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 'c' , 'o' , '6' , '4' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( <S2SV_ModEnd> 'h' , 'd' <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> clockcount ) ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> , 's' ) && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> = temp ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metastsc ) ; if ( num > 0 ) { <S2SV_ModStart> ( num * sizeof ( SampleToChunk ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> metastsc ) { <S2SV_ModEnd> len += fread <S2SV_ModStart> ) ; } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metasizes ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> len ) { uint32_t metastco_count = num ; <S2SV_ModStart> -> indexcount = num <S2SV_ModEnd> ; if ( <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> ) malloc ( num <S2SV_ModEnd> * 8 ) <S2SV_ModStart> < mp4 -> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> repeat == mp4 <S2SV_ModStart> samples ) { if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart> stco_pos ] ; <S2SV_ModEnd> } else { <S2SV_ModStart> 1 ] ; } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> if ( num == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> metaoffsets ) ; if ( mp4 -> metasize_count ) { <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> samples ; } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> 0 ) ; if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } }"
530,"static int jpeg2000_decode_tile ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile , AVFrame * picture ) { int compno , reslevelno , bandno ; int x , y ; uint8_t * line ; Jpeg2000T1Context t1 ; for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels2decode ; reslevelno ++ ) { Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < rlevel -> nbands ; bandno ++ ) { int nb_precincts , precno ; Jpeg2000Band * band = rlevel -> band + bandno ; int cblkno = 0 , bandpos ; bandpos = bandno + ( reslevelno > 0 ) ; if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] ) continue ; nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { int x , y ; Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ) ; x = cblk -> coord [ 0 ] [ 0 ] ; y = cblk -> coord [ 1 ] [ 0 ] ; if ( codsty -> transform == FF_DWT97 ) dequantization_float ( x , y , cblk , comp , & t1 , band ) ; else dequantization_int ( x , y , cblk , comp , & t1 , band ) ; } } } } ff_dwt_decode ( & comp -> dwt , codsty -> transform == FF_DWT97 ? ( void * ) comp -> f_data : ( void * ) comp -> i_data ) ; } if ( tile -> codsty [ 0 ] . mct ) mct_decode ( s , tile ) ; if ( s -> cdef [ 0 ] < 0 ) { for ( x = 0 ; x < s -> ncomponents ; x ++ ) s -> cdef [ x ] = x + 1 ; if ( ( s -> ncomponents & 1 ) == 0 ) s -> cdef [ s -> ncomponents - 1 ] = 0 ; } if ( s -> precision <= 8 ) { for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; float * datap = comp -> f_data ; int32_t * i_datap = comp -> i_data ; int cbps = s -> cbps [ compno ] ; int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; int planar = ! ! picture -> data [ 2 ] ; int pixelsize = planar ? 1 : s -> ncomponents ; int plane = 0 ; if ( planar ) plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ) ; y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y ; <S2SV_StartBug> line = picture -> data [ plane ] + y * picture -> linesize [ plane ] ; <S2SV_EndBug> for ( ; y < tile -> comp [ compno ] . coord [ 1 ] [ 1 ] - s -> image_offset_y ; y += s -> cdy [ compno ] ) { uint8_t * dst ; x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x ; <S2SV_StartBug> dst = line + x * pixelsize + compno * ! planar ; <S2SV_EndBug> if ( codsty -> transform == FF_DWT97 ) { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 8 - cbps ) ; datap ++ ; dst += pixelsize ; } } else { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 8 - cbps ) ; i_datap ++ ; dst += pixelsize ; } } line += picture -> linesize [ plane ] ; } } } else { for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; float * datap = comp -> f_data ; int32_t * i_datap = comp -> i_data ; uint16_t * linel ; int cbps = s -> cbps [ compno ] ; int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; int planar = ! ! picture -> data [ 2 ] ; int pixelsize = planar ? 1 : s -> ncomponents ; int plane = 0 ; if ( planar ) plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ) ; y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y ; <S2SV_StartBug> linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ) ; <S2SV_EndBug> for ( ; y < tile -> comp [ compno ] . coord [ 1 ] [ 1 ] - s -> image_offset_y ; y += s -> cdy [ compno ] ) { uint16_t * dst ; x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x ; <S2SV_StartBug> dst = linel + ( x * pixelsize + compno * ! planar ) ; <S2SV_EndBug> if ( codsty -> transform == FF_DWT97 ) { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 16 - cbps ) ; datap ++ ; dst += pixelsize ; } } else { for ( ; x < w ; x += s -> cdx [ compno ] ) { int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ) ; * dst = val << ( 16 - cbps ) ; i_datap ++ ; dst += pixelsize ; } } linel += picture -> linesize [ plane ] >> 1 ; } } } return 0 ; }",] + y / s -> cdy [ compno ] <S2SV_ModStart> line + x / s -> cdx [ compno ] <S2SV_ModStart> ] + y / s -> cdy [ compno ] <S2SV_ModStart> + ( x / s -> cdx [ compno ]
531,"static int ext4_split_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_map_blocks * map , int split_flag , int flags ) { ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len , depth ; int err = 0 ; int uninitialized ; int split_flag1 , flags1 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; uninitialized = ext4_ext_is_uninitialized ( ex ) ; if ( map -> m_lblk + map -> m_len < ee_block + ee_len ) { <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> EXT4_EXT_MAY_ZEROOUT : 0 ; flags1 = flags | EXT4_GET_BLOCKS_PRE_IO ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 | EXT4_EXT_MARK_UNINIT2 ; <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ; if ( err ) goto out ; } ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) return PTR_ERR ( path ) ; if ( map -> m_lblk >= ee_block ) { <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> EXT4_EXT_MAY_ZEROOUT : 0 ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) split_flag1 |= EXT4_EXT_MARK_UNINIT2 ; err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk , split_flag1 , flags ) ; if ( err ) goto out ; } ext4_ext_show_leaf ( inode , path ) ; out : return err ? err : map -> m_len ; }",split_flag & EXT4_EXT_MAY_ZEROOUT <S2SV_ModEnd> ; flags1 = <S2SV_ModStart> | EXT4_EXT_MARK_UNINIT2 ; if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> ; if (
532,"static int bnep_sock_ioctl ( struct socket * sock , unsigned int cmd , unsigned long arg ) { struct bnep_connlist_req cl ; struct bnep_connadd_req ca ; struct bnep_conndel_req cd ; struct bnep_conninfo ci ; struct socket * nsock ; void __user * argp = ( void __user * ) arg ; int err ; BT_DBG ( ""cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%lx"" , cmd , arg ) ; switch ( cmd ) { case BNEPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EACCES ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; nsock = sockfd_lookup ( ca . sock , & err ) ; if ( ! nsock ) return err ; if ( nsock -> sk -> sk_state != BT_CONNECTED ) { sockfd_put ( nsock ) ; return - EBADFD ; } <S2SV_StartBug> err = bnep_add_connection ( & ca , nsock ) ; <S2SV_EndBug> if ( ! err ) { if ( copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; } else sockfd_put ( nsock ) ; return err ; case BNEPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EACCES ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return bnep_del_connection ( & cd ) ; case BNEPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = bnep_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case BNEPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = bnep_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; default : return - EINVAL ; } return 0 ; }",EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
533,"int im_vips2dz ( IMAGE * in , const char * filename ) { char * p , * q ; char name [ FILENAME_MAX ] ; char mode [ FILENAME_MAX ] ; char buf [ FILENAME_MAX ] ; int i ; VipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ ; char * suffix = "".jpeg"" ; int overlap = 0 ; int tile_size = 256 ; VipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ; gboolean centre = FALSE ; VipsAngle angle = VIPS_ANGLE_D0 ; im_strncpy ( name , filename , FILENAME_MAX ) ; if ( ( p = strchr ( name , ':' ) ) ) { * p = '\\0' ; im_strncpy ( mode , p + 1 , FILENAME_MAX ) ; } <S2SV_StartBug> strcpy ( buf , mode ) ; <S2SV_EndBug> p = & buf [ 0 ] ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_FOREIGN_DZ_LAYOUT , q ) ) < 0 ) return ( - 1 ) ; layout = i ; } if ( ( q = im_getnextoption ( & p ) ) ) suffix = g_strdup ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) overlap = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) tile_size = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_FOREIGN_DZ_DEPTH , q ) ) < 0 ) return ( - 1 ) ; depth = i ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( im_isprefix ( ""cen"" , q ) ) centre = TRUE ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_ANGLE , q ) ) < 0 ) return ( - 1 ) ; angle = i ; } if ( vips_dzsave ( in , name , ""layout"" , layout , ""suffix"" , suffix , ""overlap"" , overlap , ""tile_size"" , tile_size , ""depth"" , depth , ""centre"" , centre , ""angle"" , angle , NULL ) ) return ( - 1 ) ; return ( 0 ) ; }",") ; } else strcpy ( mode , """" ) ;"
534,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; <S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","if ( q < p ) { DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n"" , q , p ) ) ; goto out ; } if ( q"
535,"WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SPS_PPS_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) <S2SV_StartBug> ps_dec -> ps_parse_cur_slice ++ ; <S2SV_EndBug> ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",== 0 ) { <S2SV_ModStart> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } <S2SV_ModStart> ; ps_dec -> <S2SV_ModEnd> i2_prev_slice_mbx = ps_dec
536,"void sqlite3Pragma ( Parse * pParse , Token * pId1 , Token * pId2 , Token * pValue , int minusFlag ) { char * zLeft = 0 ; char * zRight = 0 ; const char * zDb = 0 ; Token * pId ; char * aFcntl [ 4 ] ; int iDb ; int rc ; sqlite3 * db = pParse -> db ; Db * pDb ; Vdbe * v = sqlite3GetVdbe ( pParse ) ; const PragmaName * pPragma ; if ( v == 0 ) return ; sqlite3VdbeRunOnlyOnce ( v ) ; pParse -> nMem = 2 ; iDb = sqlite3TwoPartName ( pParse , pId1 , pId2 , & pId ) ; if ( iDb < 0 ) return ; pDb = & db -> aDb [ iDb ] ; if ( iDb == 1 && sqlite3OpenTempDatabase ( pParse ) ) { return ; } zLeft = sqlite3NameFromToken ( db , pId ) ; if ( ! zLeft ) return ; if ( minusFlag ) { zRight = sqlite3MPrintf ( db , ""-%T"" , pValue ) ; } else { zRight = sqlite3NameFromToken ( db , pValue ) ; } assert ( pId2 ) ; zDb = pId2 -> n > 0 ? pDb -> zDbSName : 0 ; if ( sqlite3AuthCheck ( pParse , SQLITE_PRAGMA , zLeft , zRight , zDb ) ) { goto pragma_out ; } aFcntl [ 0 ] = 0 ; aFcntl [ 1 ] = zLeft ; aFcntl [ 2 ] = zRight ; aFcntl [ 3 ] = 0 ; db -> busyHandler . nBusy = 0 ; rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_PRAGMA , ( void * ) aFcntl ) ; if ( rc == SQLITE_OK ) { sqlite3VdbeSetNumCols ( v , 1 ) ; sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , aFcntl [ 0 ] , SQLITE_TRANSIENT ) ; returnSingleText ( v , aFcntl [ 0 ] ) ; sqlite3_free ( aFcntl [ 0 ] ) ; goto pragma_out ; } if ( rc != SQLITE_NOTFOUND ) { if ( aFcntl [ 0 ] ) { sqlite3ErrorMsg ( pParse , ""%s"" , aFcntl [ 0 ] ) ; sqlite3_free ( aFcntl [ 0 ] ) ; } pParse -> nErr ++ ; pParse -> rc = rc ; goto pragma_out ; } pPragma = pragmaLocate ( zLeft ) ; if ( pPragma == 0 ) goto pragma_out ; if ( ( pPragma -> mPragFlg & PragFlg_NeedSchema ) != 0 ) { if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; } if ( ( pPragma -> mPragFlg & PragFlg_NoColumns ) == 0 && ( ( pPragma -> mPragFlg & PragFlg_NoColumns1 ) == 0 || zRight == 0 ) ) { setPragmaResultColumnNames ( v , pPragma ) ; } switch ( pPragma -> ePragTyp ) { # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) && ! defined ( SQLITE_OMIT_DEPRECATED ) case PragTyp_DEFAULT_CACHE_SIZE : { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList getCacheSize [ ] = { { OP_Transaction , 0 , 0 , 0 } , { OP_ReadCookie , 0 , 1 , BTREE_DEFAULT_CACHE_SIZE } , { OP_IfPos , 1 , 8 , 0 } , { OP_Integer , 0 , 2 , 0 } , { OP_Subtract , 1 , 2 , 1 } , { OP_IfPos , 1 , 8 , 0 } , { OP_Integer , 0 , 1 , 0 } , { OP_Noop , 0 , 0 , 0 } , { OP_ResultRow , 1 , 1 , 0 } , } ; VdbeOp * aOp ; sqlite3VdbeUsesBtree ( v , iDb ) ; if ( ! zRight ) { pParse -> nMem += 2 ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( getCacheSize ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( getCacheSize ) , getCacheSize , iLn ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 6 ] . p1 = SQLITE_DEFAULT_CACHE_SIZE ; } else { int size = sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ; sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; sqlite3VdbeAddOp3 ( v , OP_SetCookie , iDb , BTREE_DEFAULT_CACHE_SIZE , size ) ; assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; pDb -> pSchema -> cache_size = size ; sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; } break ; } # endif # if ! defined ( SQLITE_OMIT_PAGER_PRAGMAS ) case PragTyp_PAGE_SIZE : { Btree * pBt = pDb -> pBt ; assert ( pBt != 0 ) ; if ( ! zRight ) { int size = ALWAYS ( pBt ) ? sqlite3BtreeGetPageSize ( pBt ) : 0 ; returnSingleInt ( v , size ) ; } else { db -> nextPagesize = sqlite3Atoi ( zRight ) ; if ( SQLITE_NOMEM == sqlite3BtreeSetPageSize ( pBt , db -> nextPagesize , - 1 , 0 ) ) { sqlite3OomFault ( db ) ; } } break ; } case PragTyp_SECURE_DELETE : { Btree * pBt = pDb -> pBt ; int b = - 1 ; assert ( pBt != 0 ) ; if ( zRight ) { if ( sqlite3_stricmp ( zRight , ""fast"" ) == 0 ) { b = 2 ; } else { b = sqlite3GetBoolean ( zRight , 0 ) ; } } if ( pId2 -> n == 0 && b >= 0 ) { int ii ; for ( ii = 0 ; ii < db -> nDb ; ii ++ ) { sqlite3BtreeSecureDelete ( db -> aDb [ ii ] . pBt , b ) ; } } b = sqlite3BtreeSecureDelete ( pBt , b ) ; returnSingleInt ( v , b ) ; break ; } case PragTyp_PAGE_COUNT : { int iReg ; sqlite3CodeVerifySchema ( pParse , iDb ) ; iReg = ++ pParse -> nMem ; if ( sqlite3Tolower ( zLeft [ 0 ] ) == 'p' ) { sqlite3VdbeAddOp2 ( v , OP_Pagecount , iDb , iReg ) ; } else { sqlite3VdbeAddOp3 ( v , OP_MaxPgcnt , iDb , iReg , sqlite3AbsInt32 ( sqlite3Atoi ( zRight ) ) ) ; } sqlite3VdbeAddOp2 ( v , OP_ResultRow , iReg , 1 ) ; break ; } case PragTyp_LOCKING_MODE : { const char * zRet = ""normal"" ; int eMode = getLockingMode ( zRight ) ; if ( pId2 -> n == 0 && eMode == PAGER_LOCKINGMODE_QUERY ) { eMode = db -> dfltLockMode ; } else { Pager * pPager ; if ( pId2 -> n == 0 ) { int ii ; assert ( pDb == & db -> aDb [ 0 ] ) ; for ( ii = 2 ; ii < db -> nDb ; ii ++ ) { pPager = sqlite3BtreePager ( db -> aDb [ ii ] . pBt ) ; sqlite3PagerLockingMode ( pPager , eMode ) ; } db -> dfltLockMode = ( u8 ) eMode ; } pPager = sqlite3BtreePager ( pDb -> pBt ) ; eMode = sqlite3PagerLockingMode ( pPager , eMode ) ; } assert ( eMode == PAGER_LOCKINGMODE_NORMAL || eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) ; if ( eMode == PAGER_LOCKINGMODE_EXCLUSIVE ) { zRet = ""exclusive"" ; } returnSingleText ( v , zRet ) ; break ; } case PragTyp_JOURNAL_MODE : { int eMode ; int ii ; if ( zRight == 0 ) { eMode = PAGER_JOURNALMODE_QUERY ; } else { const char * zMode ; int n = sqlite3Strlen30 ( zRight ) ; for ( eMode = 0 ; ( zMode = sqlite3JournalModename ( eMode ) ) != 0 ; eMode ++ ) { if ( sqlite3StrNICmp ( zRight , zMode , n ) == 0 ) break ; } if ( ! zMode ) { eMode = PAGER_JOURNALMODE_QUERY ; } if ( eMode == PAGER_JOURNALMODE_OFF && ( db -> flags & SQLITE_Defensive ) != 0 ) { eMode = PAGER_JOURNALMODE_QUERY ; } } if ( eMode == PAGER_JOURNALMODE_QUERY && pId2 -> n == 0 ) { iDb = 0 ; pId2 -> n = 1 ; } for ( ii = db -> nDb - 1 ; ii >= 0 ; ii -- ) { if ( db -> aDb [ ii ] . pBt && ( ii == iDb || pId2 -> n == 0 ) ) { sqlite3VdbeUsesBtree ( v , ii ) ; sqlite3VdbeAddOp3 ( v , OP_JournalMode , ii , 1 , eMode ) ; } } sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; break ; } case PragTyp_JOURNAL_SIZE_LIMIT : { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; i64 iLimit = - 2 ; if ( zRight ) { sqlite3DecOrHexToI64 ( zRight , & iLimit ) ; if ( iLimit < - 1 ) iLimit = - 1 ; } iLimit = sqlite3PagerJournalSizeLimit ( pPager , iLimit ) ; returnSingleInt ( v , iLimit ) ; break ; } # endif # ifndef SQLITE_OMIT_AUTOVACUUM case PragTyp_AUTO_VACUUM : { Btree * pBt = pDb -> pBt ; assert ( pBt != 0 ) ; if ( ! zRight ) { returnSingleInt ( v , sqlite3BtreeGetAutoVacuum ( pBt ) ) ; } else { int eAuto = getAutoVacuum ( zRight ) ; assert ( eAuto >= 0 && eAuto <= 2 ) ; db -> nextAutovac = ( u8 ) eAuto ; rc = sqlite3BtreeSetAutoVacuum ( pBt , eAuto ) ; if ( rc == SQLITE_OK && ( eAuto == 1 || eAuto == 2 ) ) { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList setMeta6 [ ] = { { OP_Transaction , 0 , 1 , 0 } , { OP_ReadCookie , 0 , 1 , BTREE_LARGEST_ROOT_PAGE } , { OP_If , 1 , 0 , 0 } , { OP_Halt , SQLITE_OK , OE_Abort , 0 } , { OP_SetCookie , 0 , BTREE_INCR_VACUUM , 0 } , } ; VdbeOp * aOp ; int iAddr = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setMeta6 ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setMeta6 ) , setMeta6 , iLn ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 2 ] . p2 = iAddr + 4 ; aOp [ 4 ] . p1 = iDb ; aOp [ 4 ] . p3 = eAuto - 1 ; sqlite3VdbeUsesBtree ( v , iDb ) ; } } break ; } # endif # ifndef SQLITE_OMIT_AUTOVACUUM case PragTyp_INCREMENTAL_VACUUM : { int iLimit , addr ; if ( zRight == 0 || ! sqlite3GetInt32 ( zRight , & iLimit ) || iLimit <= 0 ) { iLimit = 0x7fffffff ; } sqlite3BeginWriteOperation ( pParse , 0 , iDb ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , iLimit , 1 ) ; addr = sqlite3VdbeAddOp1 ( v , OP_IncrVacuum , iDb ) ; VdbeCoverage ( v ) ; sqlite3VdbeAddOp1 ( v , OP_ResultRow , 1 ) ; sqlite3VdbeAddOp2 ( v , OP_AddImm , 1 , - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , 1 , addr ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; break ; } # endif # ifndef SQLITE_OMIT_PAGER_PRAGMAS case PragTyp_CACHE_SIZE : { assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( ! zRight ) { returnSingleInt ( v , pDb -> pSchema -> cache_size ) ; } else { int size = sqlite3Atoi ( zRight ) ; pDb -> pSchema -> cache_size = size ; sqlite3BtreeSetCacheSize ( pDb -> pBt , pDb -> pSchema -> cache_size ) ; } break ; } case PragTyp_CACHE_SPILL : { assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( ! zRight ) { returnSingleInt ( v , ( db -> flags & SQLITE_CacheSpill ) == 0 ? 0 : sqlite3BtreeSetSpillSize ( pDb -> pBt , 0 ) ) ; } else { int size = 1 ; if ( sqlite3GetInt32 ( zRight , & size ) ) { sqlite3BtreeSetSpillSize ( pDb -> pBt , size ) ; } if ( sqlite3GetBoolean ( zRight , size != 0 ) ) { db -> flags |= SQLITE_CacheSpill ; } else { db -> flags &= ~ ( u64 ) SQLITE_CacheSpill ; } setAllPagerFlags ( db ) ; } break ; } case PragTyp_MMAP_SIZE : { sqlite3_int64 sz ; # if SQLITE_MAX_MMAP_SIZE > 0 assert ( sqlite3SchemaMutexHeld ( db , iDb , 0 ) ) ; if ( zRight ) { int ii ; sqlite3DecOrHexToI64 ( zRight , & sz ) ; if ( sz < 0 ) sz = sqlite3GlobalConfig . szMmap ; if ( pId2 -> n == 0 ) db -> szMmap = sz ; for ( ii = db -> nDb - 1 ; ii >= 0 ; ii -- ) { if ( db -> aDb [ ii ] . pBt && ( ii == iDb || pId2 -> n == 0 ) ) { sqlite3BtreeSetMmapLimit ( db -> aDb [ ii ] . pBt , sz ) ; } } } sz = - 1 ; rc = sqlite3_file_control ( db , zDb , SQLITE_FCNTL_MMAP_SIZE , & sz ) ; # else sz = 0 ; rc = SQLITE_OK ; # endif if ( rc == SQLITE_OK ) { returnSingleInt ( v , sz ) ; } else if ( rc != SQLITE_NOTFOUND ) { pParse -> nErr ++ ; pParse -> rc = rc ; } break ; } case PragTyp_TEMP_STORE : { if ( ! zRight ) { returnSingleInt ( v , db -> temp_store ) ; } else { changeTempStorage ( pParse , zRight ) ; } break ; } case PragTyp_TEMP_STORE_DIRECTORY : { if ( ! zRight ) { returnSingleText ( v , sqlite3_temp_directory ) ; } else { # ifndef SQLITE_OMIT_WSD if ( zRight [ 0 ] ) { int res ; rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; if ( rc != SQLITE_OK || res == 0 ) { sqlite3ErrorMsg ( pParse , ""not<S2SV_blank>a<S2SV_blank>writable<S2SV_blank>directory"" ) ; goto pragma_out ; } } if ( SQLITE_TEMP_STORE == 0 || ( SQLITE_TEMP_STORE == 1 && db -> temp_store <= 1 ) || ( SQLITE_TEMP_STORE == 2 && db -> temp_store == 1 ) ) { invalidateTempStorage ( pParse ) ; } sqlite3_free ( sqlite3_temp_directory ) ; if ( zRight [ 0 ] ) { sqlite3_temp_directory = sqlite3_mprintf ( ""%s"" , zRight ) ; } else { sqlite3_temp_directory = 0 ; } # endif } break ; } # if SQLITE_OS_WIN case PragTyp_DATA_STORE_DIRECTORY : { if ( ! zRight ) { returnSingleText ( v , sqlite3_data_directory ) ; } else { # ifndef SQLITE_OMIT_WSD if ( zRight [ 0 ] ) { int res ; rc = sqlite3OsAccess ( db -> pVfs , zRight , SQLITE_ACCESS_READWRITE , & res ) ; if ( rc != SQLITE_OK || res == 0 ) { sqlite3ErrorMsg ( pParse , ""not<S2SV_blank>a<S2SV_blank>writable<S2SV_blank>directory"" ) ; goto pragma_out ; } } sqlite3_free ( sqlite3_data_directory ) ; if ( zRight [ 0 ] ) { sqlite3_data_directory = sqlite3_mprintf ( ""%s"" , zRight ) ; } else { sqlite3_data_directory = 0 ; } # endif } break ; } # endif # if SQLITE_ENABLE_LOCKING_STYLE case PragTyp_LOCK_PROXY_FILE : { if ( ! zRight ) { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; char * proxy_file_path = NULL ; sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; sqlite3OsFileControlHint ( pFile , SQLITE_GET_LOCKPROXYFILE , & proxy_file_path ) ; returnSingleText ( v , proxy_file_path ) ; } else { Pager * pPager = sqlite3BtreePager ( pDb -> pBt ) ; sqlite3_file * pFile = sqlite3PagerFile ( pPager ) ; int res ; if ( zRight [ 0 ] ) { res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , zRight ) ; } else { res = sqlite3OsFileControl ( pFile , SQLITE_SET_LOCKPROXYFILE , NULL ) ; } if ( res != SQLITE_OK ) { sqlite3ErrorMsg ( pParse , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>lock<S2SV_blank>proxy<S2SV_blank>file"" ) ; goto pragma_out ; } } break ; } # endif case PragTyp_SYNCHRONOUS : { if ( ! zRight ) { returnSingleInt ( v , pDb -> safety_level - 1 ) ; } else { if ( ! db -> autoCommit ) { sqlite3ErrorMsg ( pParse , ""Safety<S2SV_blank>level<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>inside<S2SV_blank>a<S2SV_blank>transaction"" ) ; } else if ( iDb != 1 ) { int iLevel = ( getSafetyLevel ( zRight , 0 , 1 ) + 1 ) & PAGER_SYNCHRONOUS_MASK ; if ( iLevel == 0 ) iLevel = 1 ; pDb -> safety_level = iLevel ; pDb -> bSyncSet = 1 ; setAllPagerFlags ( db ) ; } } break ; } # endif # ifndef SQLITE_OMIT_FLAG_PRAGMAS case PragTyp_FLAG : { if ( zRight == 0 ) { setPragmaResultColumnNames ( v , pPragma ) ; returnSingleInt ( v , ( db -> flags & pPragma -> iArg ) != 0 ) ; } else { u64 mask = pPragma -> iArg ; if ( db -> autoCommit == 0 ) { mask &= ~ ( SQLITE_ForeignKeys ) ; } # if SQLITE_USER_AUTHENTICATION if ( db -> auth . authLevel == UAUTH_User ) { mask &= ~ ( SQLITE_WriteSchema ) ; } # endif if ( sqlite3GetBoolean ( zRight , 0 ) ) { db -> flags |= mask ; } else { db -> flags &= ~ mask ; if ( mask == SQLITE_DeferFKs ) db -> nDeferredImmCons = 0 ; } sqlite3VdbeAddOp0 ( v , OP_Expire ) ; setAllPagerFlags ( db ) ; } break ; } # endif # ifndef SQLITE_OMIT_SCHEMA_PRAGMAS case PragTyp_TABLE_INFO : if ( zRight ) { Table * pTab ; pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ) ; if ( pTab ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; int i , k ; int nHidden = 0 ; Column * pCol ; Index * pPk = sqlite3PrimaryKeyIndex ( pTab ) ; pParse -> nMem = 7 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; sqlite3ViewGetColumnNames ( pParse , pTab ) ; for ( i = 0 , pCol = pTab -> aCol ; i < pTab -> nCol ; i ++ , pCol ++ ) { int isHidden = 0 ; if ( pCol -> colFlags & COLFLAG_NOINSERT ) { if ( pPragma -> iArg == 0 ) { nHidden ++ ; continue ; } if ( pCol -> colFlags & COLFLAG_VIRTUAL ) { isHidden = 2 ; } else if ( pCol -> colFlags & COLFLAG_STORED ) { isHidden = 3 ; } else { assert ( pCol -> colFlags & COLFLAG_HIDDEN ) ; isHidden = 1 ; } } if ( ( pCol -> colFlags & COLFLAG_PRIMKEY ) == 0 ) { k = 0 ; } else if ( pPk == 0 ) { k = 1 ; } else { for ( k = 1 ; k <= pTab -> nCol && pPk -> aiColumn [ k - 1 ] != i ; k ++ ) { } } assert ( pCol -> pDflt == 0 || pCol -> pDflt -> op == TK_SPAN || isHidden >= 2 ) ; sqlite3VdbeMultiLoad ( v , 1 , pPragma -> iArg ? ""issisii"" : ""issisi"" , i - nHidden , pCol -> zName , sqlite3ColumnType ( pCol , """" ) , pCol -> notNull ? 1 : 0 , pCol -> pDflt && isHidden < 2 ? pCol -> pDflt -> u . zToken : 0 , k , isHidden ) ; } } } break ; # ifdef SQLITE_DEBUG case PragTyp_STATS : { Index * pIdx ; HashElem * i ; pParse -> nMem = 5 ; sqlite3CodeVerifySchema ( pParse , iDb ) ; for ( i = sqliteHashFirst ( & pDb -> pSchema -> tblHash ) ; i ; i = sqliteHashNext ( i ) ) { Table * pTab = sqliteHashData ( i ) ; sqlite3VdbeMultiLoad ( v , 1 , ""ssiii"" , pTab -> zName , 0 , pTab -> szTabRow , pTab -> nRowLogEst , pTab -> tabFlags ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3VdbeMultiLoad ( v , 2 , ""siiiX"" , pIdx -> zName , pIdx -> szIdxRow , pIdx -> aiRowLogEst [ 0 ] , pIdx -> hasStat1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 5 ) ; } } } break ; # endif case PragTyp_INDEX_INFO : if ( zRight ) { Index * pIdx ; Table * pTab ; pIdx = sqlite3FindIndex ( db , zRight , zDb ) ; if ( pIdx == 0 ) { pTab = sqlite3LocateTable ( pParse , LOCATE_NOERR , zRight , zDb ) ; if ( pTab && ! HasRowid ( pTab ) ) { pIdx = sqlite3PrimaryKeyIndex ( pTab ) ; } } if ( pIdx ) { int iIdxDb = sqlite3SchemaToIndex ( db , pIdx -> pSchema ) ; int i ; int mx ; if ( pPragma -> iArg ) { mx = pIdx -> nColumn ; pParse -> nMem = 6 ; } else { mx = pIdx -> nKeyCol ; pParse -> nMem = 3 ; } pTab = pIdx -> pTable ; sqlite3CodeVerifySchema ( pParse , iIdxDb ) ; assert ( pParse -> nMem <= pPragma -> nPragCName ) ; for ( i = 0 ; i < mx ; i ++ ) { i16 cnum = pIdx -> aiColumn [ i ] ; sqlite3VdbeMultiLoad ( v , 1 , ""iisX"" , i , cnum , cnum < 0 ? 0 : pTab -> aCol [ cnum ] . zName ) ; if ( pPragma -> iArg ) { sqlite3VdbeMultiLoad ( v , 4 , ""isiX"" , pIdx -> aSortOrder [ i ] , pIdx -> azColl [ i ] , i < pIdx -> nKeyCol ) ; } sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , pParse -> nMem ) ; } } } break ; case PragTyp_INDEX_LIST : if ( zRight ) { Index * pIdx ; Table * pTab ; int i ; pTab = sqlite3FindTable ( db , zRight , zDb ) ; if ( pTab ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; pParse -> nMem = 5 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; for ( pIdx = pTab -> pIndex , i = 0 ; pIdx ; pIdx = pIdx -> pNext , i ++ ) { const char * azOrigin [ ] = { ""c"" , ""u"" , ""pk"" } ; sqlite3VdbeMultiLoad ( v , 1 , ""isisi"" , i , pIdx -> zName , IsUniqueIndex ( pIdx ) , azOrigin [ pIdx -> idxType ] , pIdx -> pPartIdxWhere != 0 ) ; } } } break ; case PragTyp_DATABASE_LIST : { int i ; pParse -> nMem = 3 ; for ( i = 0 ; i < db -> nDb ; i ++ ) { if ( db -> aDb [ i ] . pBt == 0 ) continue ; assert ( db -> aDb [ i ] . zDbSName != 0 ) ; sqlite3VdbeMultiLoad ( v , 1 , ""iss"" , i , db -> aDb [ i ] . zDbSName , sqlite3BtreeGetFilename ( db -> aDb [ i ] . pBt ) ) ; } } break ; case PragTyp_COLLATION_LIST : { int i = 0 ; HashElem * p ; pParse -> nMem = 2 ; for ( p = sqliteHashFirst ( & db -> aCollSeq ) ; p ; p = sqliteHashNext ( p ) ) { CollSeq * pColl = ( CollSeq * ) sqliteHashData ( p ) ; sqlite3VdbeMultiLoad ( v , 1 , ""is"" , i ++ , pColl -> zName ) ; } } break ; # ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS case PragTyp_FUNCTION_LIST : { int i ; HashElem * j ; FuncDef * p ; pParse -> nMem = 2 ; for ( i = 0 ; i < SQLITE_FUNC_HASH_SZ ; i ++ ) { for ( p = sqlite3BuiltinFunctions . a [ i ] ; p ; p = p -> u . pHash ) { if ( p -> funcFlags & SQLITE_FUNC_INTERNAL ) continue ; sqlite3VdbeMultiLoad ( v , 1 , ""si"" , p -> zName , 1 ) ; } } for ( j = sqliteHashFirst ( & db -> aFunc ) ; j ; j = sqliteHashNext ( j ) ) { p = ( FuncDef * ) sqliteHashData ( j ) ; sqlite3VdbeMultiLoad ( v , 1 , ""si"" , p -> zName , 0 ) ; } } break ; # ifndef SQLITE_OMIT_VIRTUALTABLE case PragTyp_MODULE_LIST : { HashElem * j ; pParse -> nMem = 1 ; for ( j = sqliteHashFirst ( & db -> aModule ) ; j ; j = sqliteHashNext ( j ) ) { Module * pMod = ( Module * ) sqliteHashData ( j ) ; sqlite3VdbeMultiLoad ( v , 1 , ""s"" , pMod -> zName ) ; } } break ; # endif case PragTyp_PRAGMA_LIST : { int i ; for ( i = 0 ; i < ArraySize ( aPragmaName ) ; i ++ ) { sqlite3VdbeMultiLoad ( v , 1 , ""s"" , aPragmaName [ i ] . zName ) ; } } break ; # endif # endif # ifndef SQLITE_OMIT_FOREIGN_KEY case PragTyp_FOREIGN_KEY_LIST : if ( zRight ) { FKey * pFK ; Table * pTab ; pTab = sqlite3FindTable ( db , zRight , zDb ) ; if ( pTab ) { pFK = pTab -> pFKey ; if ( pFK ) { int iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; int i = 0 ; pParse -> nMem = 8 ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; while ( pFK ) { int j ; for ( j = 0 ; j < pFK -> nCol ; j ++ ) { sqlite3VdbeMultiLoad ( v , 1 , ""iissssss"" , i , j , pFK -> zTo , pTab -> aCol [ pFK -> aCol [ j ] . iFrom ] . zName , pFK -> aCol [ j ] . zCol , actionName ( pFK -> aAction [ 1 ] ) , actionName ( pFK -> aAction [ 0 ] ) , ""NONE"" ) ; } ++ i ; pFK = pFK -> pNextFrom ; } } } } break ; # endif # ifndef SQLITE_OMIT_FOREIGN_KEY # ifndef SQLITE_OMIT_TRIGGER case PragTyp_FOREIGN_KEY_CHECK : { FKey * pFK ; Table * pTab ; Table * pParent ; Index * pIdx ; int i ; int j ; HashElem * k ; int x ; int regResult ; int regKey ; int regRow ; int addrTop ; int addrOk ; int * aiCols ; regResult = pParse -> nMem + 1 ; pParse -> nMem += 4 ; regKey = ++ pParse -> nMem ; regRow = ++ pParse -> nMem ; k = sqliteHashFirst ( & db -> aDb [ iDb ] . pSchema -> tblHash ) ; while ( k ) { int iTabDb ; if ( zRight ) { pTab = sqlite3LocateTable ( pParse , 0 , zRight , zDb ) ; k = 0 ; } else { pTab = ( Table * ) sqliteHashData ( k ) ; k = sqliteHashNext ( k ) ; } if ( pTab == 0 || pTab -> pFKey == 0 ) continue ; iTabDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; sqlite3CodeVerifySchema ( pParse , iTabDb ) ; sqlite3TableLock ( pParse , iTabDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( pTab -> nCol + regRow > pParse -> nMem ) pParse -> nMem = pTab -> nCol + regRow ; sqlite3OpenTable ( pParse , 0 , iTabDb , pTab , OP_OpenRead ) ; sqlite3VdbeLoadString ( v , regResult , pTab -> zName ) ; for ( i = 1 , pFK = pTab -> pFKey ; pFK ; i ++ , pFK = pFK -> pNextFrom ) { pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ) ; if ( pParent == 0 ) continue ; pIdx = 0 ; sqlite3TableLock ( pParse , iTabDb , pParent -> tnum , 0 , pParent -> zName ) ; x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , 0 ) ; if ( x == 0 ) { if ( pIdx == 0 ) { sqlite3OpenTable ( pParse , i , iTabDb , pParent , OP_OpenRead ) ; } else { sqlite3VdbeAddOp3 ( v , OP_OpenRead , i , pIdx -> tnum , iTabDb ) ; sqlite3VdbeSetP4KeyInfo ( pParse , pIdx ) ; } } else { k = 0 ; break ; } } assert ( pParse -> nErr > 0 || pFK == 0 ) ; if ( pFK ) break ; if ( pParse -> nTab < i ) pParse -> nTab = i ; addrTop = sqlite3VdbeAddOp1 ( v , OP_Rewind , 0 ) ; VdbeCoverage ( v ) ; for ( i = 1 , pFK = pTab -> pFKey ; pFK ; i ++ , pFK = pFK -> pNextFrom ) { pParent = sqlite3FindTable ( db , pFK -> zTo , zDb ) ; pIdx = 0 ; aiCols = 0 ; if ( pParent ) { x = sqlite3FkLocateIndex ( pParse , pParent , pFK , & pIdx , & aiCols ) ; assert ( x == 0 ) ; } addrOk = sqlite3VdbeMakeLabel ( pParse ) ; for ( j = 0 ; j < pFK -> nCol ; j ++ ) { int iCol = aiCols ? aiCols [ j ] : pFK -> aCol [ j ] . iFrom ; sqlite3ExprCodeGetColumnOfTable ( v , pTab , 0 , iCol , regRow + j ) ; sqlite3VdbeAddOp2 ( v , OP_IsNull , regRow + j , addrOk ) ; VdbeCoverage ( v ) ; } if ( pIdx ) { sqlite3VdbeAddOp4 ( v , OP_MakeRecord , regRow , pFK -> nCol , regKey , sqlite3IndexAffinityStr ( db , pIdx ) , pFK -> nCol ) ; sqlite3VdbeAddOp4Int ( v , OP_Found , i , addrOk , regKey , 0 ) ; VdbeCoverage ( v ) ; } else if ( pParent ) { int jmp = sqlite3VdbeCurrentAddr ( v ) + 2 ; sqlite3VdbeAddOp3 ( v , OP_SeekRowid , i , jmp , regRow ) ; VdbeCoverage ( v ) ; sqlite3VdbeGoto ( v , addrOk ) ; assert ( pFK -> nCol == 1 ) ; } if ( HasRowid ( pTab ) ) { sqlite3VdbeAddOp2 ( v , OP_Rowid , 0 , regResult + 1 ) ; } else { sqlite3VdbeAddOp2 ( v , OP_Null , 0 , regResult + 1 ) ; } sqlite3VdbeMultiLoad ( v , regResult + 2 , ""siX"" , pFK -> zTo , i - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , regResult , 4 ) ; sqlite3VdbeResolveLabel ( v , addrOk ) ; sqlite3DbFree ( db , aiCols ) ; } sqlite3VdbeAddOp2 ( v , OP_Next , 0 , addrTop + 1 ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , addrTop ) ; } } break ; # endif # endif # ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA case PragTyp_CASE_SENSITIVE_LIKE : { if ( zRight ) { sqlite3RegisterLikeFunctions ( db , sqlite3GetBoolean ( zRight , 0 ) ) ; } } break ; # endif # ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX # define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100 # endif # ifndef SQLITE_OMIT_INTEGRITY_CHECK case PragTyp_INTEGRITY_CHECK : { int i , j , addr , mxErr ; int isQuick = ( sqlite3Tolower ( zLeft [ 0 ] ) == 'q' ) ; assert ( iDb >= 0 ) ; assert ( iDb == 0 || pId2 -> z ) ; if ( pId2 -> z == 0 ) iDb = - 1 ; pParse -> nMem = 6 ; mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; if ( zRight ) { sqlite3GetInt32 ( zRight , & mxErr ) ; if ( mxErr <= 0 ) { mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX ; } } sqlite3VdbeAddOp2 ( v , OP_Integer , mxErr - 1 , 1 ) ; for ( i = 0 ; i < db -> nDb ; i ++ ) { HashElem * x ; Hash * pTbls ; int * aRoot ; int cnt = 0 ; int mxIdx = 0 ; if ( OMIT_TEMPDB && i == 1 ) continue ; if ( iDb >= 0 && i != iDb ) continue ; sqlite3CodeVerifySchema ( pParse , i ) ; assert ( sqlite3SchemaMutexHeld ( db , i , 0 ) ) ; pTbls = & db -> aDb [ i ] . pSchema -> tblHash ; for ( cnt = 0 , x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx ; int nIdx ; if ( HasRowid ( pTab ) ) cnt ++ ; for ( nIdx = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , nIdx ++ ) { cnt ++ ; } if ( nIdx > mxIdx ) mxIdx = nIdx ; } aRoot = sqlite3DbMallocRawNN ( db , sizeof ( int ) * ( cnt + 1 ) ) ; if ( aRoot == 0 ) break ; for ( cnt = 0 , x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx ; if ( HasRowid ( pTab ) ) aRoot [ ++ cnt ] = pTab -> tnum ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { aRoot [ ++ cnt ] = pIdx -> tnum ; } } aRoot [ 0 ] = cnt ; pParse -> nMem = MAX ( pParse -> nMem , 8 + mxIdx ) ; sqlite3ClearTempRegCache ( pParse ) ; sqlite3VdbeAddOp4 ( v , OP_IntegrityCk , 2 , cnt , 1 , ( char * ) aRoot , P4_INTARRAY ) ; sqlite3VdbeChangeP5 ( v , ( u8 ) i ) ; addr = sqlite3VdbeAddOp1 ( v , OP_IsNull , 2 ) ; VdbeCoverage ( v ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , sqlite3MPrintf ( db , ""***<S2SV_blank>in<S2SV_blank>database<S2SV_blank>%s<S2SV_blank>***\\n"" , db -> aDb [ i ] . zDbSName ) , P4_DYNAMIC ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 2 , 3 , 3 ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; for ( x = sqliteHashFirst ( pTbls ) ; x ; x = sqliteHashNext ( x ) ) { Table * pTab = sqliteHashData ( x ) ; Index * pIdx , * pPk ; Index * pPrior = 0 ; int loopTop ; int iDataCur , iIdxCur ; int r1 = - 1 ; if ( pTab -> tnum < 1 ) continue ; pPk = HasRowid ( pTab ) ? 0 : sqlite3PrimaryKeyIndex ( pTab ) ; sqlite3OpenTableAndIndices ( pParse , pTab , OP_OpenRead , 0 , 1 , 0 , & iDataCur , & iIdxCur ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 7 ) ; for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , 8 + j ) ; } assert ( pParse -> nMem >= 8 + j ) ; assert ( sqlite3NoTempsInRange ( pParse , 1 , 7 + j ) ) ; sqlite3VdbeAddOp2 ( v , OP_Rewind , iDataCur , 0 ) ; VdbeCoverage ( v ) ; loopTop = sqlite3VdbeAddOp2 ( v , OP_AddImm , 7 , 1 ) ; if ( ! isQuick ) { sqlite3VdbeAddOp3 ( v , OP_Column , iDataCur , pTab -> nNVCol - 1 , 3 ) ; sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; } for ( j = 0 ; j < pTab -> nCol ; j ++ ) { char * zErr ; int jmp2 ; if ( j == pTab -> iPKey ) continue ; if ( pTab -> aCol [ j ] . notNull == 0 ) continue ; sqlite3ExprCodeGetColumnOfTable ( v , pTab , iDataCur , j , 3 ) ; <S2SV_StartBug> sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; <S2SV_EndBug> jmp2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , 3 ) ; VdbeCoverage ( v ) ; zErr = sqlite3MPrintf ( db , ""NULL<S2SV_blank>value<S2SV_blank>in<S2SV_blank>%s.%s"" , pTab -> zName , pTab -> aCol [ j ] . zName ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , jmp2 ) ; } if ( pTab -> pCheck && ( db -> flags & SQLITE_IgnoreChecks ) == 0 ) { ExprList * pCheck = sqlite3ExprListDup ( db , pTab -> pCheck , 0 ) ; if ( db -> mallocFailed == 0 ) { int addrCkFault = sqlite3VdbeMakeLabel ( pParse ) ; int addrCkOk = sqlite3VdbeMakeLabel ( pParse ) ; char * zErr ; int k ; pParse -> iSelfTab = iDataCur + 1 ; for ( k = pCheck -> nExpr - 1 ; k > 0 ; k -- ) { sqlite3ExprIfFalse ( pParse , pCheck -> a [ k ] . pExpr , addrCkFault , 0 ) ; } sqlite3ExprIfTrue ( pParse , pCheck -> a [ 0 ] . pExpr , addrCkOk , SQLITE_JUMPIFNULL ) ; sqlite3VdbeResolveLabel ( v , addrCkFault ) ; pParse -> iSelfTab = 0 ; zErr = sqlite3MPrintf ( db , ""CHECK<S2SV_blank>constraint<S2SV_blank>failed<S2SV_blank>in<S2SV_blank>%s"" , pTab -> zName ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , 3 , 0 , zErr , P4_DYNAMIC ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeResolveLabel ( v , addrCkOk ) ; } sqlite3ExprListDelete ( db , pCheck ) ; } if ( ! isQuick ) { for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { int jmp2 , jmp3 , jmp4 , jmp5 ; int ckUniq = sqlite3VdbeMakeLabel ( pParse ) ; if ( pPk == pIdx ) continue ; r1 = sqlite3GenerateIndexKey ( pParse , pIdx , iDataCur , 0 , 0 , & jmp3 , pPrior , r1 ) ; pPrior = pIdx ; sqlite3VdbeAddOp2 ( v , OP_AddImm , 8 + j , 1 ) ; jmp2 = sqlite3VdbeAddOp4Int ( v , OP_Found , iIdxCur + j , ckUniq , r1 , pIdx -> nColumn ) ; VdbeCoverage ( v ) ; sqlite3VdbeLoadString ( v , 3 , ""row<S2SV_blank>"" ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 7 , 3 , 3 ) ; sqlite3VdbeLoadString ( v , 4 , ""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>index<S2SV_blank>"" ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ) ; jmp5 = sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 3 , 3 ) ; jmp4 = integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , jmp2 ) ; if ( IsUniqueIndex ( pIdx ) ) { int uniqOk = sqlite3VdbeMakeLabel ( pParse ) ; int jmp6 ; int kk ; for ( kk = 0 ; kk < pIdx -> nKeyCol ; kk ++ ) { int iCol = pIdx -> aiColumn [ kk ] ; assert ( iCol != XN_ROWID && iCol < pTab -> nCol ) ; if ( iCol >= 0 && pTab -> aCol [ iCol ] . notNull ) continue ; sqlite3VdbeAddOp2 ( v , OP_IsNull , r1 + kk , uniqOk ) ; VdbeCoverage ( v ) ; } jmp6 = sqlite3VdbeAddOp1 ( v , OP_Next , iIdxCur + j ) ; VdbeCoverage ( v ) ; sqlite3VdbeGoto ( v , uniqOk ) ; sqlite3VdbeJumpHere ( v , jmp6 ) ; sqlite3VdbeAddOp4Int ( v , OP_IdxGT , iIdxCur + j , uniqOk , r1 , pIdx -> nKeyCol ) ; VdbeCoverage ( v ) ; sqlite3VdbeLoadString ( v , 3 , ""non-unique<S2SV_blank>entry<S2SV_blank>in<S2SV_blank>index<S2SV_blank>"" ) ; sqlite3VdbeGoto ( v , jmp5 ) ; sqlite3VdbeResolveLabel ( v , uniqOk ) ; } sqlite3VdbeJumpHere ( v , jmp4 ) ; sqlite3ResolvePartIdxLabel ( pParse , jmp3 ) ; } } sqlite3VdbeAddOp2 ( v , OP_Next , iDataCur , loopTop ) ; VdbeCoverage ( v ) ; sqlite3VdbeJumpHere ( v , loopTop - 1 ) ; # ifndef SQLITE_OMIT_BTREECOUNT if ( ! isQuick ) { sqlite3VdbeLoadString ( v , 2 , ""wrong<S2SV_blank>#<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>index<S2SV_blank>"" ) ; for ( j = 0 , pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext , j ++ ) { if ( pPk == pIdx ) continue ; sqlite3VdbeAddOp2 ( v , OP_Count , iIdxCur + j , 3 ) ; addr = sqlite3VdbeAddOp3 ( v , OP_Eq , 8 + j , 0 , 3 ) ; VdbeCoverage ( v ) ; sqlite3VdbeChangeP5 ( v , SQLITE_NOTNULL ) ; sqlite3VdbeLoadString ( v , 4 , pIdx -> zName ) ; sqlite3VdbeAddOp3 ( v , OP_Concat , 4 , 2 , 3 ) ; integrityCheckResultRow ( v ) ; sqlite3VdbeJumpHere ( v , addr ) ; } } # endif } } { static const int iLn = VDBE_OFFSET_LINENO ( 2 ) ; static const VdbeOpList endCode [ ] = { { OP_AddImm , 1 , 0 , 0 } , { OP_IfNotZero , 1 , 4 , 0 } , { OP_String8 , 0 , 3 , 0 } , { OP_ResultRow , 3 , 1 , 0 } , { OP_Halt , 0 , 0 , 0 } , { OP_String8 , 0 , 3 , 0 } , { OP_Goto , 0 , 3 , 0 } , } ; VdbeOp * aOp ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( endCode ) , endCode , iLn ) ; if ( aOp ) { aOp [ 0 ] . p2 = 1 - mxErr ; aOp [ 2 ] . p4type = P4_STATIC ; aOp [ 2 ] . p4 . z = ""ok"" ; aOp [ 5 ] . p4type = P4_STATIC ; aOp [ 5 ] . p4 . z = ( char * ) sqlite3ErrStr ( SQLITE_CORRUPT ) ; } sqlite3VdbeChangeP3 ( v , 0 , sqlite3VdbeCurrentAddr ( v ) - 2 ) ; } } break ; # endif # ifndef SQLITE_OMIT_UTF16 case PragTyp_ENCODING : { static const struct EncName { char * zName ; u8 enc ; } encnames [ ] = { { ""UTF8"" , SQLITE_UTF8 } , { ""UTF-8"" , SQLITE_UTF8 } , { ""UTF-16le"" , SQLITE_UTF16LE } , { ""UTF-16be"" , SQLITE_UTF16BE } , { ""UTF16le"" , SQLITE_UTF16LE } , { ""UTF16be"" , SQLITE_UTF16BE } , { ""UTF-16"" , 0 } , { ""UTF16"" , 0 } , { 0 , 0 } } ; const struct EncName * pEnc ; if ( ! zRight ) { if ( sqlite3ReadSchema ( pParse ) ) goto pragma_out ; assert ( encnames [ SQLITE_UTF8 ] . enc == SQLITE_UTF8 ) ; assert ( encnames [ SQLITE_UTF16LE ] . enc == SQLITE_UTF16LE ) ; assert ( encnames [ SQLITE_UTF16BE ] . enc == SQLITE_UTF16BE ) ; returnSingleText ( v , encnames [ ENC ( pParse -> db ) ] . zName ) ; } else { if ( ! ( DbHasProperty ( db , 0 , DB_SchemaLoaded ) ) || DbHasProperty ( db , 0 , DB_Empty ) ) { for ( pEnc = & encnames [ 0 ] ; pEnc -> zName ; pEnc ++ ) { if ( 0 == sqlite3StrICmp ( zRight , pEnc -> zName ) ) { SCHEMA_ENC ( db ) = ENC ( db ) = pEnc -> enc ? pEnc -> enc : SQLITE_UTF16NATIVE ; break ; } } if ( ! pEnc -> zName ) { sqlite3ErrorMsg ( pParse , ""unsupported<S2SV_blank>encoding:<S2SV_blank>%s"" , zRight ) ; } } } } break ; # endif # ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS case PragTyp_HEADER_VALUE : { int iCookie = pPragma -> iArg ; sqlite3VdbeUsesBtree ( v , iDb ) ; if ( zRight && ( pPragma -> mPragFlg & PragFlg_ReadOnly ) == 0 ) { static const VdbeOpList setCookie [ ] = { { OP_Transaction , 0 , 1 , 0 } , { OP_SetCookie , 0 , 0 , 0 } , } ; VdbeOp * aOp ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( setCookie ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( setCookie ) , setCookie , 0 ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 1 ] . p2 = iCookie ; aOp [ 1 ] . p3 = sqlite3Atoi ( zRight ) ; } else { static const VdbeOpList readCookie [ ] = { { OP_Transaction , 0 , 0 , 0 } , { OP_ReadCookie , 0 , 1 , 0 } , { OP_ResultRow , 1 , 1 , 0 } } ; VdbeOp * aOp ; sqlite3VdbeVerifyNoMallocRequired ( v , ArraySize ( readCookie ) ) ; aOp = sqlite3VdbeAddOpList ( v , ArraySize ( readCookie ) , readCookie , 0 ) ; if ( ONLY_IF_REALLOC_STRESS ( aOp == 0 ) ) break ; aOp [ 0 ] . p1 = iDb ; aOp [ 1 ] . p1 = iDb ; aOp [ 1 ] . p3 = iCookie ; sqlite3VdbeReusable ( v ) ; } } break ; # endif # ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS case PragTyp_COMPILE_OPTIONS : { int i = 0 ; const char * zOpt ; pParse -> nMem = 1 ; while ( ( zOpt = sqlite3_compileoption_get ( i ++ ) ) != 0 ) { sqlite3VdbeLoadString ( v , 1 , zOpt ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 1 ) ; } sqlite3VdbeReusable ( v ) ; } break ; # endif # ifndef SQLITE_OMIT_WAL case PragTyp_WAL_CHECKPOINT : { int iBt = ( pId2 -> z ? iDb : SQLITE_MAX_ATTACHED ) ; int eMode = SQLITE_CHECKPOINT_PASSIVE ; if ( zRight ) { if ( sqlite3StrICmp ( zRight , ""full"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_FULL ; } else if ( sqlite3StrICmp ( zRight , ""restart"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_RESTART ; } else if ( sqlite3StrICmp ( zRight , ""truncate"" ) == 0 ) { eMode = SQLITE_CHECKPOINT_TRUNCATE ; } } pParse -> nMem = 3 ; sqlite3VdbeAddOp3 ( v , OP_Checkpoint , iBt , eMode , 1 ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , 1 , 3 ) ; } break ; case PragTyp_WAL_AUTOCHECKPOINT : { if ( zRight ) { sqlite3_wal_autocheckpoint ( db , sqlite3Atoi ( zRight ) ) ; } returnSingleInt ( v , db -> xWalCallback == sqlite3WalDefaultHook ? SQLITE_PTR_TO_INT ( db -> pWalArg ) : 0 ) ; } break ; # endif case PragTyp_SHRINK_MEMORY : { sqlite3_db_release_memory ( db ) ; break ; } case PragTyp_OPTIMIZE : { int iDbLast ; int iTabCur ; HashElem * k ; Schema * pSchema ; Table * pTab ; Index * pIdx ; LogEst szThreshold ; char * zSubSql ; u32 opMask ; if ( zRight ) { opMask = ( u32 ) sqlite3Atoi ( zRight ) ; if ( ( opMask & 0x02 ) == 0 ) break ; } else { opMask = 0xfffe ; } iTabCur = pParse -> nTab ++ ; for ( iDbLast = zDb ? iDb : db -> nDb - 1 ; iDb <= iDbLast ; iDb ++ ) { if ( iDb == 1 ) continue ; sqlite3CodeVerifySchema ( pParse , iDb ) ; pSchema = db -> aDb [ iDb ] . pSchema ; for ( k = sqliteHashFirst ( & pSchema -> tblHash ) ; k ; k = sqliteHashNext ( k ) ) { pTab = ( Table * ) sqliteHashData ( k ) ; if ( ( pTab -> tabFlags & TF_StatsUsed ) == 0 ) continue ; szThreshold = pTab -> nRowLogEst + 46 ; assert ( sqlite3LogEst ( 25 ) == 46 ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( ! pIdx -> hasStat1 ) { szThreshold = 0 ; break ; } } if ( szThreshold ) { sqlite3OpenTable ( pParse , iTabCur , iDb , pTab , OP_OpenRead ) ; sqlite3VdbeAddOp3 ( v , OP_IfSmaller , iTabCur , sqlite3VdbeCurrentAddr ( v ) + 2 + ( opMask & 1 ) , szThreshold ) ; VdbeCoverage ( v ) ; } zSubSql = sqlite3MPrintf ( db , ""ANALYZE<S2SV_blank>\\""%w\\"".\\""%w\\"""" , db -> aDb [ iDb ] . zDbSName , pTab -> zName ) ; if ( opMask & 0x01 ) { int r1 = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp4 ( v , OP_String8 , 0 , r1 , 0 , zSubSql , P4_DYNAMIC ) ; sqlite3VdbeAddOp2 ( v , OP_ResultRow , r1 , 1 ) ; } else { sqlite3VdbeAddOp4 ( v , OP_SqlExec , 0 , 0 , 0 , zSubSql , P4_DYNAMIC ) ; } } } sqlite3VdbeAddOp0 ( v , OP_Expire ) ; break ; } default : { assert ( pPragma -> ePragTyp == PragTyp_BUSY_TIMEOUT ) ; if ( zRight ) { sqlite3_busy_timeout ( db , sqlite3Atoi ( zRight ) ) ; } returnSingleInt ( v , db -> busyTimeout ) ; break ; } case PragTyp_SOFT_HEAP_LIMIT : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK ) { sqlite3_soft_heap_limit64 ( N ) ; } returnSingleInt ( v , sqlite3_soft_heap_limit64 ( - 1 ) ) ; break ; } case PragTyp_HARD_HEAP_LIMIT : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK ) { sqlite3_int64 iPrior = sqlite3_hard_heap_limit64 ( - 1 ) ; if ( N > 0 && ( iPrior == 0 || iPrior > N ) ) sqlite3_hard_heap_limit64 ( N ) ; } returnSingleInt ( v , sqlite3_hard_heap_limit64 ( - 1 ) ) ; break ; } case PragTyp_THREADS : { sqlite3_int64 N ; if ( zRight && sqlite3DecOrHexToI64 ( zRight , & N ) == SQLITE_OK && N >= 0 ) { sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , ( int ) ( N & 0x7fffffff ) ) ; } returnSingleInt ( v , sqlite3_limit ( db , SQLITE_LIMIT_WORKER_THREADS , - 1 ) ) ; break ; } # if defined ( SQLITE_DEBUG ) || defined ( SQLITE_TEST ) case PragTyp_LOCK_STATUS : { static const char * const azLockName [ ] = { ""unlocked"" , ""shared"" , ""reserved"" , ""pending"" , ""exclusive"" } ; int i ; pParse -> nMem = 2 ; for ( i = 0 ; i < db -> nDb ; i ++ ) { Btree * pBt ; const char * zState = ""unknown"" ; int j ; if ( db -> aDb [ i ] . zDbSName == 0 ) continue ; pBt = db -> aDb [ i ] . pBt ; if ( pBt == 0 || sqlite3BtreePager ( pBt ) == 0 ) { zState = ""closed"" ; } else if ( sqlite3_file_control ( db , i ? db -> aDb [ i ] . zDbSName : 0 , SQLITE_FCNTL_LOCKSTATE , & j ) == SQLITE_OK ) { zState = azLockName [ j ] ; } sqlite3VdbeMultiLoad ( v , 1 , ""ss"" , db -> aDb [ i ] . zDbSName , zState ) ; } break ; } # endif # ifdef SQLITE_HAS_CODEC case PragTyp_KEY : { if ( zRight ) { char zBuf [ 40 ] ; const char * zKey = zRight ; int n ; if ( pPragma -> iArg == 2 || pPragma -> iArg == 3 ) { u8 iByte ; int i ; for ( i = 0 , iByte = 0 ; i < sizeof ( zBuf ) * 2 && sqlite3Isxdigit ( zRight [ i ] ) ; i ++ ) { iByte = ( iByte << 4 ) + sqlite3HexToInt ( zRight [ i ] ) ; if ( ( i & 1 ) != 0 ) zBuf [ i / 2 ] = iByte ; } zKey = zBuf ; n = i / 2 ; } else { n = pPragma -> iArg < 4 ? sqlite3Strlen30 ( zRight ) : - 1 ; } if ( ( pPragma -> iArg & 1 ) == 0 ) { rc = sqlite3_key_v2 ( db , zDb , zKey , n ) ; } else { rc = sqlite3_rekey_v2 ( db , zDb , zKey , n ) ; } if ( rc == SQLITE_OK && n != 0 ) { sqlite3VdbeSetNumCols ( v , 1 ) ; sqlite3VdbeSetColName ( v , 0 , COLNAME_NAME , ""ok"" , SQLITE_STATIC ) ; returnSingleText ( v , ""ok"" ) ; } } break ; } # endif # if defined ( SQLITE_HAS_CODEC ) || defined ( SQLITE_ENABLE_CEROD ) case PragTyp_ACTIVATE_EXTENSIONS : if ( zRight ) { # ifdef SQLITE_HAS_CODEC if ( sqlite3StrNICmp ( zRight , ""see-"" , 4 ) == 0 ) { sqlite3_activate_see ( & zRight [ 4 ] ) ; } # endif # ifdef SQLITE_ENABLE_CEROD if ( sqlite3StrNICmp ( zRight , ""cerod-"" , 6 ) == 0 ) { sqlite3_activate_cerod ( & zRight [ 6 ] ) ; } # endif } break ; # endif } if ( ( pPragma -> mPragFlg & PragFlg_NoColumns1 ) && zRight ) { sqlite3VdbeVerifyNoResultRow ( v ) ; } pragma_out : sqlite3DbFree ( db , zLeft ) ; sqlite3DbFree ( db , zRight ) ; }","3 ) ; if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) { <S2SV_ModStart> OPFLAG_TYPEOFARG ) ; }"
537,"static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > <S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp <= 16 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }",") / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries"
538,"static void Sp_replace_regexp ( js_State * J ) { js_Regexp * re ; const char * source , * s , * r ; js_Buffer * sb = NULL ; int n , x ; Resub m ; source = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; <S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> js_copy ( J , 0 ) ; return ; } re -> last = 0 ; loop : s = m . sub [ 0 ] . sp ; n = m . sub [ 0 ] . ep - m . sub [ 0 ] . sp ; if ( js_iscallable ( J , 2 ) ) { js_copy ( J , 2 ) ; js_pushundefined ( J ) ; for ( x = 0 ; m . sub [ x ] . sp ; ++ x ) js_pushlstring ( J , m . sub [ x ] . sp , m . sub [ x ] . ep - m . sub [ x ] . sp ) ; js_pushnumber ( J , s - source ) ; js_copy ( J , 0 ) ; js_call ( J , 2 + x ) ; r = js_tostring ( J , - 1 ) ; js_putm ( J , & sb , source , s ) ; js_puts ( J , & sb , r ) ; js_pop ( J , 1 ) ; } else { r = js_tostring ( J , 2 ) ; js_putm ( J , & sb , source , s ) ; while ( * r ) { if ( * r == '$' ) { switch ( * ( ++ r ) ) { case 0 : -- r ; case '$' : js_putc ( J , & sb , '$' ) ; break ; case '`' : js_putm ( J , & sb , source , s ) ; break ; case '\\'' : js_puts ( J , & sb , s + n ) ; break ; case '&' : js_putm ( J , & sb , s , s + n ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : x = * r - '0' ; if ( r [ 1 ] >= '0' && r [ 1 ] <= '9' ) x = x * 10 + * ( ++ r ) - '0' ; if ( x > 0 && x < m . nsub ) { js_putm ( J , & sb , m . sub [ x ] . sp , m . sub [ x ] . ep ) ; } else { js_putc ( J , & sb , '$' ) ; if ( x > 10 ) { js_putc ( J , & sb , '0' + x / 10 ) ; js_putc ( J , & sb , '0' + x % 10 ) ; } else { js_putc ( J , & sb , '0' + x ) ; } } break ; default : js_putc ( J , & sb , '$' ) ; js_putc ( J , & sb , * r ) ; break ; } ++ r ; } else { js_putc ( J , & sb , * r ++ ) ; } } } if ( re -> flags & JS_REGEXP_G ) { source = m . sub [ 0 ] . ep ; if ( n == 0 ) { if ( * source ) js_putc ( J , & sb , * source ++ ) ; else goto end ; } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> goto loop ; } end : js_puts ( J , & sb , s + n ) ; js_putc ( J , & sb , 0 ) ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } js_pushstring ( J , sb ? sb -> s : """" ) ; js_endtry ( J ) ; js_free ( J , sb ) ; }","; if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog"
539,"WORD32 ih264d_parse_sei_message ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD32 ui4_payload_type , ui4_payload_size ; UWORD32 u4_bits ; WORD32 i4_status = 0 ; do { ui4_payload_type = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_type += 255 ; } ui4_payload_type += u4_bits ; ui4_payload_size = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_size += 255 ; } ui4_payload_size += u4_bits ; i4_status = ih264d_parse_sei_payload ( ps_bitstrm , ui4_payload_type , ui4_payload_size , ps_dec ) ; if ( i4_status == - 1 ) { i4_status = 0 ; break ; } if ( i4_status != OK ) return i4_status ; if ( ih264d_check_byte_aligned ( ps_bitstrm ) == 0 ) { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( 0 == u4_bits ) { H264_DEC_DEBUG_PRINT ( ""\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message"" ) ; } <S2SV_StartBug> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <S2SV_EndBug> { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( u4_bits ) { H264_DEC_DEBUG_PRINT ( ""\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message"" ) ; } } } } while ( ps_bitstrm -> u4_ofst < ps_bitstrm -> u4_max_ofst ) ; return ( i4_status ) ; }",0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> 0 == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET
540,"static int dissect_usb_video_control_interface_descriptor ( proto_tree * parent_tree , tvbuff_t * tvb , guint8 descriptor_len , packet_info * pinfo , usb_conv_info_t * usb_conv_info ) { video_conv_info_t * video_conv_info = NULL ; video_entity_t * entity = NULL ; proto_item * item = NULL ; proto_item * subtype_item = NULL ; proto_tree * tree = NULL ; guint8 entity_id = 0 ; guint16 terminal_type = 0 ; int offset = 0 ; guint8 subtype ; subtype = tvb_get_guint8 ( tvb , offset + 2 ) ; if ( parent_tree ) { const gchar * subtype_str ; subtype_str = val_to_str_ext ( subtype , & vc_if_descriptor_subtypes_ext , ""Unknown<S2SV_blank>(0x%x)"" ) ; tree = proto_tree_add_subtree_format ( parent_tree , tvb , offset , descriptor_len , ett_descriptor_video_control , & item , ""VIDEO<S2SV_blank>CONTROL<S2SV_blank>INTERFACE<S2SV_blank>DESCRIPTOR<S2SV_blank>[%s]"" , subtype_str ) ; } dissect_usb_descriptor_header ( tree , tvb , offset , & vid_descriptor_type_vals_ext ) ; subtype_item = proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_subtype , tvb , offset + 2 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 3 ; if ( subtype == VC_HEADER ) { guint8 num_vs_interfaces ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bcdUVC , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_ifdesc_wTotalLength , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_dwClockFrequency , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; num_vs_interfaces = tvb_get_guint8 ( tvb , offset + 8 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bInCollection , tvb , offset + 8 , 1 , ENC_LITTLE_ENDIAN ) ; if ( num_vs_interfaces > 0 ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_baInterfaceNr , tvb , offset + 9 , num_vs_interfaces , ENC_NA ) ; } offset += 9 + num_vs_interfaces ; } else if ( ( subtype == VC_INPUT_TERMINAL ) || ( subtype == VC_OUTPUT_TERMINAL ) ) { entity_id = tvb_get_guint8 ( tvb , offset ) ; terminal_type = tvb_get_letohs ( tvb , offset + 1 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_type , tvb , offset + 1 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_assoc_terminal , tvb , offset + 3 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; if ( subtype == VC_OUTPUT_TERMINAL ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_src_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; } proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_iTerminal , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_INPUT_TERMINAL ) { if ( terminal_type == ITT_CAMERA ) { offset = dissect_usb_video_camera_terminal ( tree , tvb , offset ) ; } else if ( terminal_type == ITT_MEDIA_TRANSPORT_INPUT ) { } } if ( subtype == VC_OUTPUT_TERMINAL ) { if ( terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT ) { } } } else { entity_id = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_unit_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_PROCESSING_UNIT ) { offset = dissect_usb_video_processing_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_SELECTOR_UNIT ) { offset = dissect_usb_video_selector_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_EXTENSION_UNIT ) { offset = dissect_usb_video_extension_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_ENCODING_UNIT ) { } else { expert_add_info_format ( pinfo , subtype_item , & ei_usb_vid_subtype_unknown , ""Unknown<S2SV_blank>VC<S2SV_blank>subtype<S2SV_blank>%u"" , subtype ) ; } } if ( offset < descriptor_len ) { proto_tree_add_item ( tree , hf_usb_vid_descriptor_data , tvb , offset , descriptor_len - offset , ENC_NA ) ; } if ( entity_id != 0 ) proto_item_append_text ( item , ""<S2SV_blank>(Entity<S2SV_blank>%d)"" , entity_id ) ; if ( subtype != VC_HEADER && usb_conv_info ) { usb_conv_info = get_usb_iface_conv_info ( pinfo , usb_conv_info -> interfaceNum ) ; video_conv_info = ( video_conv_info_t * ) usb_conv_info -> class_data ; if ( ! video_conv_info ) { video_conv_info = wmem_new ( wmem_file_scope ( ) , video_conv_info_t ) ; video_conv_info -> entities = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = video_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ; if ( ! entity ) { entity = wmem_new ( wmem_file_scope ( ) , video_entity_t ) ; entity -> entityID = entity_id ; entity -> subtype = subtype ; entity -> terminalType = terminal_type ; wmem_tree_insert32 ( video_conv_info -> entities , entity_id , entity ) ; } } return descriptor_len ; }",= video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
541,"void * getHTTPResponse ( int s , int * size ) { char buf [ 2048 ] ; int n ; int endofheaders = 0 ; int chunked = 0 ; int content_length = - 1 ; unsigned int chunksize = 0 ; unsigned int bytestocopy = 0 ; char * header_buf ; unsigned int header_buf_len = 2048 ; unsigned int header_buf_used = 0 ; char * content_buf ; unsigned int content_buf_len = 2048 ; unsigned int content_buf_used = 0 ; char chunksize_buf [ 32 ] ; unsigned int chunksize_buf_index ; header_buf = malloc ( header_buf_len ) ; content_buf = malloc ( content_buf_len ) ; chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; while ( ( n = receivedata ( s , buf , 2048 , 5000 , NULL ) ) > 0 ) { if ( endofheaders == 0 ) { int i ; int linestart = 0 ; int colon = 0 ; int valuestart = 0 ; if ( header_buf_used + n > header_buf_len ) { header_buf = realloc ( header_buf , header_buf_used + n ) ; header_buf_len = header_buf_used + n ; } memcpy ( header_buf + header_buf_used , buf , n ) ; header_buf_used += n ; i = 0 ; while ( i < ( ( int ) header_buf_used - 1 ) && ( endofheaders == 0 ) ) { if ( header_buf [ i ] == '\\r' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\r' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } } } else if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } i ++ ; } if ( endofheaders == 0 ) continue ; for ( i = 0 ; i < endofheaders - 1 ; i ++ ) { if ( colon <= linestart && header_buf [ i ] == ':' ) { colon = i ; while ( i < ( endofheaders - 1 ) && ( header_buf [ i + 1 ] == '<S2SV_blank>' || header_buf [ i + 1 ] == '\\t' ) ) i ++ ; valuestart = i + 1 ; } else if ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) { if ( colon > linestart && valuestart > colon ) { # ifdef DEBUG printf ( ""header=\'%.*s\',<S2SV_blank>value=\'%.*s\'\\n"" , colon - linestart , header_buf + linestart , i - valuestart , header_buf + valuestart ) ; # endif if ( 0 == strncasecmp ( header_buf + linestart , ""content-length"" , colon - linestart ) ) { content_length = atoi ( header_buf + valuestart ) ; # ifdef DEBUG printf ( ""Content-Length:<S2SV_blank>%d\\n"" , content_length ) ; # endif } else if ( 0 == strncasecmp ( header_buf + linestart , ""transfer-encoding"" , colon - linestart ) && 0 == strncasecmp ( header_buf + valuestart , ""chunked"" , 7 ) ) { # ifdef DEBUG printf ( ""chunked<S2SV_blank>transfer-encoding!\\n"" ) ; # endif chunked = 1 ; } } <S2SV_StartBug> while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) <S2SV_EndBug> i ++ ; linestart = i ; colon = linestart ; valuestart = 0 ; } } n = header_buf_used - endofheaders ; memcpy ( buf , header_buf + endofheaders , n ) ; } if ( endofheaders ) { if ( chunked ) { int i = 0 ; while ( i < n ) { if ( chunksize == 0 ) { if ( chunksize_buf_index == 0 ) { if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) i ++ ; } while ( i < n && isxdigit ( buf [ i ] ) && chunksize_buf_index < ( sizeof ( chunksize_buf ) - 1 ) ) { chunksize_buf [ chunksize_buf_index ++ ] = buf [ i ] ; chunksize_buf [ chunksize_buf_index ] = '\\0' ; i ++ ; } while ( i < n && buf [ i ] != '\\r' && buf [ i ] != '\\n' ) i ++ ; if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) { unsigned int j ; for ( j = 0 ; j < chunksize_buf_index ; j ++ ) { if ( chunksize_buf [ j ] >= '0' && chunksize_buf [ j ] <= '9' ) chunksize = ( chunksize << 4 ) + ( chunksize_buf [ j ] - '0' ) ; else chunksize = ( chunksize << 4 ) + ( ( chunksize_buf [ j ] | 32 ) - 'a' + 10 ) ; } chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; i ++ ; } else { continue ; } # ifdef DEBUG printf ( ""chunksize<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(%x)\\n"" , chunksize , chunksize ) ; # endif if ( chunksize == 0 ) { # ifdef DEBUG printf ( ""end<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>%d\\n"" , i , n ) ; # endif goto end_of_stream ; } } bytestocopy = ( ( int ) chunksize < ( n - i ) ) ? chunksize : ( unsigned int ) ( n - i ) ; if ( ( content_buf_used + bytestocopy ) > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + bytestocopy ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + bytestocopy ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf + i , bytestocopy ) ; content_buf_used += bytestocopy ; i += bytestocopy ; chunksize -= bytestocopy ; } } else { if ( content_length > 0 && ( int ) ( content_buf_used + n ) > content_length ) { n = content_length - content_buf_used ; } if ( content_buf_used + n > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + n ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + n ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf , n ) ; content_buf_used += n ; } } if ( content_length > 0 && ( int ) content_buf_used >= content_length ) { # ifdef DEBUG printf ( ""End<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content\\n"" ) ; # endif break ; } } end_of_stream : free ( header_buf ) ; header_buf = NULL ; * size = content_buf_used ; if ( content_buf_used == 0 ) { free ( content_buf ) ; content_buf = NULL ; } return content_buf ; }",} while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ] == '\\n' )
542,"generic_ret * setkey_principal3_2_svc ( setkey3_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setkey_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> keyblocks , arg -> n_keys ) ; } else { log_unauth ( ""kadm5_setkey_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_setkey_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle"
543,"static void __net_random_once_deferred ( struct work_struct * w ) { struct __net_random_once_work * work = container_of ( w , struct __net_random_once_work , work ) ; <S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> static_key_slow_inc ( work -> key ) ; kfree ( work ) ; }",work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->
544,"bool_t mqttSnClientIsShortTopicName ( const char_t * topicName ) { bool_t res ; res = FALSE ; if ( osStrlen ( topicName ) == 2 ) { <S2SV_StartBug> if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> { res = TRUE ; } } return res ; }","{ if ( osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,"
545,"struct pipe_inode_info * alloc_pipe_info ( void ) { struct pipe_inode_info * pipe ; pipe = kzalloc ( sizeof ( struct pipe_inode_info ) , GFP_KERNEL ) ; if ( pipe ) { <S2SV_StartBug> pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ; <S2SV_EndBug> if ( pipe -> bufs ) { init_waitqueue_head ( & pipe -> wait ) ; pipe -> r_counter = pipe -> w_counter = 1 ; <S2SV_StartBug> pipe -> buffers = PIPE_DEF_BUFFERS ; <S2SV_EndBug> mutex_init ( & pipe -> mutex ) ; return pipe ; } <S2SV_StartBug> kfree ( pipe ) ; <S2SV_EndBug> } return NULL ; }","pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_buffer ) * pipe_bufs <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> GFP_KERNEL ) ; } <S2SV_ModStart> -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( <S2SV_ModStart> pipe ; } free_uid ( user ) ;"
546,"int ff_mov_write_packet ( AVFormatContext * s , AVPacket * pkt ) { MOVMuxContext * mov = s -> priv_data ; AVIOContext * pb = s -> pb ; MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; AVCodecParameters * par = trk -> par ; unsigned int samples_in_chunk = 0 ; int size = pkt -> size , ret = 0 ; uint8_t * reformatted_data = NULL ; ret = check_pkt ( s , pkt ) ; if ( ret < 0 ) return ret ; if ( mov -> flags & FF_MOV_FLAG_FRAGMENT ) { int ret ; if ( mov -> moov_written || mov -> flags & FF_MOV_FLAG_EMPTY_MOOV ) { if ( mov -> frag_interleave && mov -> fragments > 0 ) { if ( trk -> entry - trk -> entries_flushed >= mov -> frag_interleave ) { if ( ( ret = mov_flush_fragment_interleaving ( s , trk ) ) < 0 ) return ret ; } } if ( ! trk -> mdat_buf ) { if ( ( ret = avio_open_dyn_buf ( & trk -> mdat_buf ) ) < 0 ) return ret ; } pb = trk -> mdat_buf ; } else { if ( ! mov -> mdat_buf ) { if ( ( ret = avio_open_dyn_buf ( & mov -> mdat_buf ) ) < 0 ) return ret ; } pb = mov -> mdat_buf ; } } if ( par -> codec_id == AV_CODEC_ID_AMR_NB ) { static const uint16_t packed_size [ 16 ] = { 13 , 14 , 16 , 18 , 20 , 21 , 27 , 32 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; int len = 0 ; while ( len < size && samples_in_chunk < 100 ) { len += packed_size [ ( pkt -> data [ len ] >> 3 ) & 0x0F ] ; samples_in_chunk ++ ; } if ( samples_in_chunk > 1 ) { av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>single<S2SV_blank>packet,<S2SV_blank>implement<S2SV_blank>a<S2SV_blank>AVParser<S2SV_blank>for<S2SV_blank>it\\n"" ) ; return - 1 ; } } else if ( par -> codec_id == AV_CODEC_ID_ADPCM_MS || par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { samples_in_chunk = trk -> par -> frame_size ; } else if ( trk -> sample_size ) samples_in_chunk = size / trk -> sample_size ; else samples_in_chunk = 1 ; <S2SV_StartBug> if ( trk -> vos_len == 0 && par -> extradata_size > 0 && <S2SV_EndBug> ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) { trk -> vos_len = par -> extradata_size ; trk -> vos_data = av_malloc ( trk -> vos_len ) ; if ( ! trk -> vos_data ) { ret = AVERROR ( ENOMEM ) ; goto err ; } memcpy ( trk -> vos_data , par -> extradata , trk -> vos_len ) ; } if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , ""Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>"" ""(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n"" ) ; return - 1 ; } av_log ( s , AV_LOG_WARNING , ""aac<S2SV_blank>bitstream<S2SV_blank>error\\n"" ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 && trk -> vos_len > 0 && * ( uint8_t * ) trk -> vos_data != 1 && ! TAG_IS_AVCI ( trk -> tag ) ) { if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { ff_avc_parse_nal_units_buf ( pkt -> data , & reformatted_data , & size ) ; avio_write ( pb , reformatted_data , size ) ; } else { if ( trk -> cenc . aes_ctr ) { size = ff_mov_cenc_avc_parse_nal_units ( & trk -> cenc , pb , pkt -> data , size ) ; if ( size < 0 ) { ret = size ; goto err ; } } else { size = ff_avc_parse_nal_units ( pb , pkt -> data , pkt -> size ) ; } } } else if ( par -> codec_id == AV_CODEC_ID_HEVC && trk -> vos_len > 6 && ( AV_RB24 ( trk -> vos_data ) == 1 || AV_RB32 ( trk -> vos_data ) == 1 ) ) { if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { ff_hevc_annexb2mp4_buf ( pkt -> data , & reformatted_data , & size , 0 , NULL ) ; avio_write ( pb , reformatted_data , size ) ; } else { size = ff_hevc_annexb2mp4 ( pb , pkt -> data , pkt -> size , 0 , NULL ) ; } # if CONFIG_AC3_PARSER } else if ( par -> codec_id == AV_CODEC_ID_EAC3 ) { size = handle_eac3 ( mov , pkt , trk ) ; if ( size < 0 ) return size ; else if ( ! size ) goto end ; avio_write ( pb , pkt -> data , size ) ; # endif } else { if ( trk -> cenc . aes_ctr ) { if ( par -> codec_id == AV_CODEC_ID_H264 && par -> extradata_size > 4 ) { int nal_size_length = ( par -> extradata [ 4 ] & 0x3 ) + 1 ; ret = ff_mov_cenc_avc_write_nal_units ( s , & trk -> cenc , nal_size_length , pb , pkt -> data , size ) ; } else { ret = ff_mov_cenc_write_packet ( & trk -> cenc , pb , pkt -> data , size ) ; } if ( ret ) { goto err ; } } else { avio_write ( pb , pkt -> data , size ) ; } } if ( ( par -> codec_id == AV_CODEC_ID_DNXHD || par -> codec_id == AV_CODEC_ID_AC3 ) && ! trk -> vos_len ) { trk -> vos_len = size ; trk -> vos_data = av_malloc ( size ) ; if ( ! trk -> vos_data ) { ret = AVERROR ( ENOMEM ) ; goto err ; } memcpy ( trk -> vos_data , pkt -> data , size ) ; } if ( trk -> entry >= trk -> cluster_capacity ) { unsigned new_capacity = 2 * ( trk -> entry + MOV_INDEX_CLUSTER_SIZE ) ; if ( av_reallocp_array ( & trk -> cluster , new_capacity , sizeof ( * trk -> cluster ) ) ) { ret = AVERROR ( ENOMEM ) ; goto err ; } trk -> cluster_capacity = new_capacity ; } trk -> cluster [ trk -> entry ] . pos = avio_tell ( pb ) - size ; trk -> cluster [ trk -> entry ] . samples_in_chunk = samples_in_chunk ; trk -> cluster [ trk -> entry ] . chunkNum = 0 ; trk -> cluster [ trk -> entry ] . size = size ; trk -> cluster [ trk -> entry ] . entries = samples_in_chunk ; trk -> cluster [ trk -> entry ] . dts = pkt -> dts ; trk -> cluster [ trk -> entry ] . pts = pkt -> pts ; if ( ! trk -> entry && trk -> start_dts != AV_NOPTS_VALUE ) { if ( ! trk -> frag_discont ) { trk -> cluster [ trk -> entry ] . dts = trk -> start_dts + trk -> track_duration ; if ( ( mov -> flags & FF_MOV_FLAG_DASH && ! ( mov -> flags & FF_MOV_FLAG_GLOBAL_SIDX ) ) || mov -> mode == MODE_ISM ) pkt -> pts = pkt -> dts + trk -> end_pts - trk -> cluster [ trk -> entry ] . dts ; } else { trk -> frag_start = pkt -> dts - trk -> start_dts ; trk -> end_pts = AV_NOPTS_VALUE ; trk -> frag_discont = 0 ; } } if ( ! trk -> entry && trk -> start_dts == AV_NOPTS_VALUE && ! mov -> use_editlist && s -> avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO ) { trk -> cluster [ trk -> entry ] . dts = trk -> start_dts = 0 ; } if ( trk -> start_dts == AV_NOPTS_VALUE ) { trk -> start_dts = pkt -> dts ; if ( trk -> frag_discont ) { if ( mov -> use_editlist ) { trk -> frag_start = pkt -> pts ; trk -> start_dts = pkt -> dts - pkt -> pts ; } else { trk -> frag_start = pkt -> dts ; trk -> start_dts = 0 ; } trk -> frag_discont = 0 ; } else if ( pkt -> dts && mov -> moov_written ) av_log ( s , AV_LOG_WARNING , ""Track<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>a<S2SV_blank>nonzero<S2SV_blank>dts<S2SV_blank>%"" PRId64 "",<S2SV_blank>while<S2SV_blank>the<S2SV_blank>moov<S2SV_blank>"" ""already<S2SV_blank>has<S2SV_blank>been<S2SV_blank>written.<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>delay_moov<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>"" ""this<S2SV_blank>case.\\n"" , pkt -> stream_index , pkt -> dts ) ; } trk -> track_duration = pkt -> dts - trk -> start_dts + pkt -> duration ; trk -> last_sample_is_subtitle_end = 0 ; if ( pkt -> pts == AV_NOPTS_VALUE ) { av_log ( s , AV_LOG_WARNING , ""pts<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value\\n"" ) ; pkt -> pts = pkt -> dts ; } if ( pkt -> dts != pkt -> pts ) trk -> flags |= MOV_TRACK_CTTS ; trk -> cluster [ trk -> entry ] . cts = pkt -> pts - pkt -> dts ; trk -> cluster [ trk -> entry ] . flags = 0 ; if ( trk -> start_cts == AV_NOPTS_VALUE ) trk -> start_cts = pkt -> pts - pkt -> dts ; if ( trk -> end_pts == AV_NOPTS_VALUE ) trk -> end_pts = trk -> cluster [ trk -> entry ] . dts + trk -> cluster [ trk -> entry ] . cts + pkt -> duration ; else trk -> end_pts = FFMAX ( trk -> end_pts , trk -> cluster [ trk -> entry ] . dts + trk -> cluster [ trk -> entry ] . cts + pkt -> duration ) ; if ( par -> codec_id == AV_CODEC_ID_VC1 ) { mov_parse_vc1_frame ( pkt , trk ) ; } else if ( pkt -> flags & AV_PKT_FLAG_KEY ) { if ( mov -> mode == MODE_MOV && par -> codec_id == AV_CODEC_ID_MPEG2VIDEO && trk -> entry > 0 ) { mov_parse_mpeg2_frame ( pkt , & trk -> cluster [ trk -> entry ] . flags ) ; if ( trk -> cluster [ trk -> entry ] . flags & MOV_PARTIAL_SYNC_SAMPLE ) trk -> flags |= MOV_TRACK_STPS ; } else { trk -> cluster [ trk -> entry ] . flags = MOV_SYNC_SAMPLE ; } if ( trk -> cluster [ trk -> entry ] . flags & MOV_SYNC_SAMPLE ) trk -> has_keyframes ++ ; } if ( pkt -> flags & AV_PKT_FLAG_DISPOSABLE ) { trk -> cluster [ trk -> entry ] . flags |= MOV_DISPOSABLE_SAMPLE ; trk -> has_disposable ++ ; } trk -> entry ++ ; trk -> sample_count += samples_in_chunk ; mov -> mdat_size += size ; if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) ff_mov_add_hinted_packet ( s , pkt , trk -> hint_track , trk -> entry , reformatted_data , size ) ; end : err : av_free ( reformatted_data ) ; return ret ; }","; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ("
547,"void xsltGenerateIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { <S2SV_StartBug> xmlNodePtr cur = NULL ; <S2SV_EndBug> long val ; xmlChar str [ 30 ] ; xmlDocPtr doc ; if ( nargs == 0 ) { cur = ctxt -> context -> node ; } else if ( nargs == 1 ) { <S2SV_StartBug> xmlXPathObjectPtr obj ; <S2SV_EndBug> xmlNodeSetPtr nodelist ; int i , ret ; if ( ( ctxt -> value == NULL ) || ( ctxt -> value -> type != XPATH_NODESET ) ) { ctxt -> error = XPATH_INVALID_TYPE ; xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , ""generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>arg<S2SV_blank>expecting<S2SV_blank>a<S2SV_blank>node-set\\n"" ) ; return ; } obj = valuePop ( ctxt ) ; nodelist = obj -> nodesetval ; if ( ( nodelist == NULL ) || ( nodelist -> nodeNr <= 0 ) ) { xmlXPathFreeObject ( obj ) ; valuePush ( ctxt , xmlXPathNewCString ( """" ) ) ; return ; } cur = nodelist -> nodeTab [ 0 ] ; for ( i = 1 ; i < nodelist -> nodeNr ; i ++ ) { ret = xmlXPathCmpNodes ( cur , nodelist -> nodeTab [ i ] ) ; if ( ret == - 1 ) cur = nodelist -> nodeTab [ i ] ; } <S2SV_StartBug> xmlXPathFreeObject ( obj ) ; <S2SV_EndBug> } else { xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , ""generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>args<S2SV_blank>%d\\n"" , nargs ) ; ctxt -> error = XPATH_INVALID_ARITY ; return ; } if ( cur -> type != XML_NAMESPACE_DECL ) doc = cur -> doc ; else { xmlNsPtr ns = ( xmlNsPtr ) cur ; if ( ns -> context != NULL ) doc = ns -> context ; else doc = ctxt -> context -> doc ; } <S2SV_StartBug> val = ( long ) ( ( char * ) cur - ( char * ) doc ) ; <S2SV_EndBug> if ( val >= 0 ) { sprintf ( ( char * ) str , ""idp%ld"" , val ) ; } else { sprintf ( ( char * ) str , ""idm%ld"" , - val ) ; } valuePush ( ctxt , xmlXPathNewString ( str ) ) ; }",{ xmlNodePtr cur = NULL ; xmlXPathObjectPtr obj <S2SV_ModStart> 1 ) { <S2SV_ModEnd> xmlNodeSetPtr nodelist ; <S2SV_ModStart> ] ; } <S2SV_ModEnd> } else { <S2SV_ModStart> doc ; } if ( obj ) xmlXPathFreeObject ( obj ) ;
548,"long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , ""%s\\n"" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }","long len ; qboolean isLocalConfig ; <S2SV_ModStart> ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;"
549,"static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }","walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0"
550,<S2SV_StartBug> static void <S2SV_EndBug> ast_clear ( AST_object * self ) { Py_CLEAR ( self -> dict ) ; <S2SV_StartBug> } <S2SV_EndBug>,<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ast_clear ( AST_object <S2SV_ModStart> dict ) ; return 0 ;
551,"static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = ""Getting<S2SV_blank>sb<S2SV_blank>failed"" ; struct inode * inode ; struct path path ; <S2SV_StartBug> int rc ; <S2SV_EndBug> sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> if ( rc ) { err = ""Error<S2SV_blank>parsing<S2SV_blank>options"" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } s -> s_flags = flags ; rc = bdi_setup_and_register ( & sbi -> bdi , ""ecryptfs"" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = ""Reading<S2SV_blank>sb<S2SV_blank>failed"" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , ""kern_path()<S2SV_blank>failed\\n"" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR ""Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>"" ""eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>"" ""known<S2SV_blank>incompatibilities\\n"" ) ; goto out_free ; } <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_alloc_root ( inode ) ; if ( ! s -> s_root ) { iput ( inode ) ; rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; ecryptfs_set_dentry_lower ( s -> s_root , path . dentry ) ; ecryptfs_set_dentry_lower_mnt ( s -> s_root , path . mnt ) ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR ""%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , err , rc ) ; return ERR_PTR ( rc ) ; }","path path ; uid_t check_ruid ; <S2SV_ModStart> sbi , raw_data , & check_ruid <S2SV_ModStart> out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }"
552,"int check_user_token ( const char * authfile , const char * username , const char * otp_id , int verbose , FILE * debug_file ) { char buf [ 1024 ] ; char * s_user , * s_token ; int retval = AUTH_ERROR ; int fd ; struct stat st ; FILE * opwfile ; fd = open ( authfile , O_RDONLY , 0 ) ; if ( fd < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; return retval ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; close ( fd ) ; return retval ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , authfile ) ; close ( fd ) ; return retval ; } opwfile = fdopen ( fd , ""r"" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , ""fdopen:<S2SV_blank>%s"" , strerror ( errno ) ) ; close ( fd ) ; return retval ; } retval = AUTH_NO_TOKENS ; while ( fgets ( buf , 1024 , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( buf [ 0 ] == '#' ) { if ( verbose ) D ( debug_file , ""Skipping<S2SV_blank>comment<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; continue ; } if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; s_user = strtok_r ( buf , "":"" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , ""Matched<S2SV_blank>user:<S2SV_blank>%s"" , s_user ) ; retval = AUTH_NOT_FOUND ; do { s_token = strtok_r ( NULL , "":"" , & saveptr ) ; if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>token:<S2SV_blank>%s"" , s_token ) ; if ( s_token && otp_id && strcmp ( otp_id , s_token ) == 0 ) { if ( verbose ) D ( debug_file , ""Match<S2SV_blank>user/token<S2SV_blank>as<S2SV_blank>%s/%s"" , username , otp_id ) ; <S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> } } while ( s_token != NULL ) ; } } fclose ( opwfile ) ; return retval ; }",otp_id ) ; fclose ( opwfile ) ;
553,"<S2SV_StartBug> static void <S2SV_EndBug> horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] += wp [ 0 ] ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;"
554,static void tun_net_init ( struct net_device * dev ) { struct tun_struct * tun = netdev_priv ( dev ) ; switch ( tun -> flags & TUN_TYPE_MASK ) { case TUN_TUN_DEV : dev -> netdev_ops = & tun_netdev_ops ; dev -> hard_header_len = 0 ; dev -> addr_len = 0 ; dev -> mtu = 1500 ; dev -> type = ARPHRD_NONE ; dev -> flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST ; dev -> tx_queue_len = TUN_READQ_SIZE ; break ; case TUN_TAP_DEV : dev -> netdev_ops = & tap_netdev_ops ; ether_setup ( dev ) ; <S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> dev -> tx_queue_len = TUN_READQ_SIZE ; break ; } },dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
555,"static enum hrtimer_restart posix_timer_fn ( struct hrtimer * timer ) { struct k_itimer * timr ; unsigned long flags ; int si_private = 0 ; enum hrtimer_restart ret = HRTIMER_NORESTART ; timr = container_of ( timer , struct k_itimer , it . real . timer ) ; spin_lock_irqsave ( & timr -> it_lock , flags ) ; timr -> it_active = 0 ; if ( timr -> it_interval != 0 ) si_private = ++ timr -> it_requeue_pending ; if ( posix_timer_event ( timr , si_private ) ) { if ( timr -> it_interval != 0 ) { ktime_t now = hrtimer_cb_get_time ( timer ) ; # ifdef CONFIG_HIGH_RES_TIMERS { ktime_t kj = NSEC_PER_SEC / HZ ; if ( timr -> it_interval < kj ) now = ktime_add ( now , kj ) ; } # endif <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) <S2SV_EndBug> hrtimer_forward ( timer , now , timr -> it_interval ) ; ret = HRTIMER_RESTART ; ++ timr -> it_requeue_pending ; timr -> it_active = 1 ; } } unlock_timer ( timr , flags ) ; return ret ; }",-> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
556,"static int dhcpv6_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint16_t type , optlen ; i = 0 ; while ( i < length ) { <S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> type = EXTRACT_16BITS ( tlv ) ; optlen = EXTRACT_16BITS ( tlv + 2 ) ; value = tlv + 4 ; ND_PRINT ( ( ndo , ""\\n"" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , ""\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( dh6opt_str , ""Unknown"" , type ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ; <S2SV_EndBug> switch ( type ) { case DH6OPT_DNS_SERVERS : case DH6OPT_SNTP_SERVERS : { if ( optlen % 16 != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , istr ) ) ; return - 1 ; } for ( t = 0 ; t < optlen ; t += 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , value + t ) ) ) ; } break ; case DH6OPT_DOMAIN_LIST : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 4 + optlen ; } return 0 ; }",length ) { if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> 4 ) ) ; if ( i + 4 + optlen > length ) return - 1
557,"void vp8_build_intra_predictors_mby_s_c ( MACROBLOCKD * x , unsigned char * yabove_row , unsigned char * yleft , int left_stride , unsigned char * ypred_ptr , int y_stride ) { unsigned char yleft_col [ 16 ] ; unsigned char ytop_left = yabove_row [ - 1 ] ; int r , c , i ; for ( i = 0 ; i < 16 ; i ++ ) { yleft_col [ i ] = yleft [ i * left_stride ] ; } switch ( x -> mode_info_context -> mbmi . mode ) { case DC_PRED : { int expected_dc ; int shift ; int average = 0 ; if ( x -> up_available || x -> left_available ) { if ( x -> up_available ) { for ( i = 0 ; i < 16 ; i ++ ) { average += yabove_row [ i ] ; } } if ( x -> left_available ) { for ( i = 0 ; i < 16 ; i ++ ) { average += yleft_col [ i ] ; } } shift = 3 + x -> up_available + x -> left_available ; expected_dc = ( average + ( 1 << ( shift - 1 ) ) ) >> shift ; } else { expected_dc = 128 ; } for ( r = 0 ; r < 16 ; r ++ ) { <S2SV_StartBug> vpx_memset ( ypred_ptr , expected_dc , 16 ) ; <S2SV_EndBug> ypred_ptr += y_stride ; } } break ; case V_PRED : { for ( r = 0 ; r < 16 ; r ++ ) { ( ( int * ) ypred_ptr ) [ 0 ] = ( ( int * ) yabove_row ) [ 0 ] ; ( ( int * ) ypred_ptr ) [ 1 ] = ( ( int * ) yabove_row ) [ 1 ] ; ( ( int * ) ypred_ptr ) [ 2 ] = ( ( int * ) yabove_row ) [ 2 ] ; ( ( int * ) ypred_ptr ) [ 3 ] = ( ( int * ) yabove_row ) [ 3 ] ; ypred_ptr += y_stride ; } } break ; case H_PRED : { for ( r = 0 ; r < 16 ; r ++ ) { <S2SV_StartBug> vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; <S2SV_EndBug> ypred_ptr += y_stride ; } } break ; case TM_PRED : { for ( r = 0 ; r < 16 ; r ++ ) { for ( c = 0 ; c < 16 ; c ++ ) { int pred = yleft_col [ r ] + yabove_row [ c ] - ytop_left ; if ( pred < 0 ) pred = 0 ; if ( pred > 255 ) pred = 255 ; ypred_ptr [ c ] = pred ; } ypred_ptr += y_stride ; } } break ; case B_PRED : case NEARESTMV : case NEARMV : case ZEROMV : case NEWMV : case SPLITMV : case MB_MODE_COUNT : break ; } }","++ ) { memset <S2SV_ModEnd> ( ypred_ptr , <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( ypred_ptr ,"
558,"void sctp_association_free ( struct sctp_association * asoc ) { struct sock * sk = asoc -> base . sk ; struct sctp_transport * transport ; struct list_head * pos , * temp ; int i ; <S2SV_StartBug> if ( ! asoc -> temp ) { <S2SV_EndBug> list_del ( & asoc -> asocs ) ; if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) sk -> sk_ack_backlog -- ; } asoc -> base . dead = true ; sctp_outq_free ( & asoc -> outqueue ) ; sctp_ulpq_free ( & asoc -> ulpq ) ; sctp_inq_free ( & asoc -> base . inqueue ) ; sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; sctp_ssnmap_free ( asoc -> ssnmap ) ; sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { if ( del_timer ( & asoc -> timers [ i ] ) ) sctp_association_put ( asoc ) ; } kfree ( asoc -> peer . cookie ) ; kfree ( asoc -> peer . peer_random ) ; kfree ( asoc -> peer . peer_chunks ) ; kfree ( asoc -> peer . peer_hmacs ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { transport = list_entry ( pos , struct sctp_transport , transports ) ; list_del_rcu ( pos ) ; sctp_transport_free ( transport ) ; } asoc -> peer . transport_count = 0 ; sctp_asconf_queue_teardown ( asoc ) ; if ( asoc -> asconf_addr_del_pending != NULL ) kfree ( asoc -> asconf_addr_del_pending ) ; sctp_auth_destroy_keys ( & asoc -> endpoint_shared_keys ) ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_association_put ( asoc ) ; }",if ( ! list_empty ( & asoc -> asocs ) <S2SV_ModEnd> ) { list_del
559,"static int parse_options ( char * options , struct super_block * sb , unsigned long * journal_devnum , unsigned int * journal_ioprio , ext4_fsblk_t * n_blocks_count , int is_remount ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; char * p ; substring_t args [ MAX_OPT_ARGS ] ; int data_opt = 0 ; int option ; # ifdef CONFIG_QUOTA int qfmt ; # endif if ( ! options ) return 1 ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { int token ; if ( ! * p ) continue ; args [ 0 ] . to = args [ 0 ] . from = 0 ; token = match_token ( p , tokens , args ) ; switch ( token ) { case Opt_bsd_df : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; clear_opt ( sbi -> s_mount_opt , MINIX_DF ) ; break ; case Opt_minix_df : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; set_opt ( sbi -> s_mount_opt , MINIX_DF ) ; break ; case Opt_grpid : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; set_opt ( sbi -> s_mount_opt , GRPID ) ; break ; case Opt_nogrpid : ext4_msg ( sb , KERN_WARNING , deprecated_msg , p , ""2.6.38"" ) ; clear_opt ( sbi -> s_mount_opt , GRPID ) ; break ; case Opt_resuid : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; sbi -> s_resuid = option ; break ; case Opt_resgid : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; sbi -> s_resgid = option ; break ; case Opt_sb : break ; case Opt_err_panic : clear_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; clear_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; set_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; break ; case Opt_err_ro : clear_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; clear_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; set_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; break ; case Opt_err_cont : clear_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; clear_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; set_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; break ; case Opt_nouid32 : set_opt ( sbi -> s_mount_opt , NO_UID32 ) ; break ; case Opt_debug : set_opt ( sbi -> s_mount_opt , DEBUG ) ; break ; case Opt_oldalloc : set_opt ( sbi -> s_mount_opt , OLDALLOC ) ; break ; case Opt_orlov : clear_opt ( sbi -> s_mount_opt , OLDALLOC ) ; break ; # ifdef CONFIG_EXT4_FS_XATTR case Opt_user_xattr : set_opt ( sbi -> s_mount_opt , XATTR_USER ) ; break ; case Opt_nouser_xattr : clear_opt ( sbi -> s_mount_opt , XATTR_USER ) ; break ; # else case Opt_user_xattr : case Opt_nouser_xattr : ext4_msg ( sb , KERN_ERR , ""(no)user_xattr<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; # endif # ifdef CONFIG_EXT4_FS_POSIX_ACL case Opt_acl : set_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; break ; case Opt_noacl : clear_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; break ; # else case Opt_acl : case Opt_noacl : ext4_msg ( sb , KERN_ERR , ""(no)acl<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; # endif case Opt_journal_update : if ( is_remount ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>specify<S2SV_blank>journal<S2SV_blank>on<S2SV_blank>remount"" ) ; return 0 ; } set_opt ( sbi -> s_mount_opt , UPDATE_JOURNAL ) ; break ; case Opt_journal_dev : if ( is_remount ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>specify<S2SV_blank>journal<S2SV_blank>on<S2SV_blank>remount"" ) ; return 0 ; } if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; * journal_devnum = option ; break ; case Opt_journal_checksum : set_opt ( sbi -> s_mount_opt , JOURNAL_CHECKSUM ) ; break ; case Opt_journal_async_commit : set_opt ( sbi -> s_mount_opt , JOURNAL_ASYNC_COMMIT ) ; set_opt ( sbi -> s_mount_opt , JOURNAL_CHECKSUM ) ; break ; case Opt_noload : set_opt ( sbi -> s_mount_opt , NOLOAD ) ; break ; case Opt_commit : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; if ( option == 0 ) option = JBD2_DEFAULT_MAX_COMMIT_AGE ; sbi -> s_commit_interval = HZ * option ; break ; case Opt_max_batch_time : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; if ( option == 0 ) option = EXT4_DEF_MAX_BATCH_TIME ; sbi -> s_max_batch_time = option ; break ; case Opt_min_batch_time : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; sbi -> s_min_batch_time = option ; break ; case Opt_data_journal : data_opt = EXT4_MOUNT_JOURNAL_DATA ; goto datacheck ; case Opt_data_ordered : data_opt = EXT4_MOUNT_ORDERED_DATA ; goto datacheck ; case Opt_data_writeback : data_opt = EXT4_MOUNT_WRITEBACK_DATA ; datacheck : if ( is_remount ) { if ( test_opt ( sb , DATA_FLAGS ) != data_opt ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>change<S2SV_blank>data<S2SV_blank>mode<S2SV_blank>on<S2SV_blank>remount"" ) ; return 0 ; } } else { clear_opt ( sbi -> s_mount_opt , DATA_FLAGS ) ; sbi -> s_mount_opt |= data_opt ; } break ; case Opt_data_err_abort : set_opt ( sbi -> s_mount_opt , DATA_ERR_ABORT ) ; break ; case Opt_data_err_ignore : clear_opt ( sbi -> s_mount_opt , DATA_ERR_ABORT ) ; break ; # ifdef CONFIG_QUOTA case Opt_usrjquota : if ( ! set_qf_name ( sb , USRQUOTA , & args [ 0 ] ) ) return 0 ; break ; case Opt_grpjquota : if ( ! set_qf_name ( sb , GRPQUOTA , & args [ 0 ] ) ) return 0 ; break ; case Opt_offusrjquota : if ( ! clear_qf_name ( sb , USRQUOTA ) ) return 0 ; break ; case Opt_offgrpjquota : if ( ! clear_qf_name ( sb , GRPQUOTA ) ) return 0 ; break ; case Opt_jqfmt_vfsold : qfmt = QFMT_VFS_OLD ; goto set_qf_format ; case Opt_jqfmt_vfsv0 : qfmt = QFMT_VFS_V0 ; goto set_qf_format ; case Opt_jqfmt_vfsv1 : qfmt = QFMT_VFS_V1 ; set_qf_format : if ( sb_any_quota_loaded ( sb ) && sbi -> s_jquota_fmt != qfmt ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>change<S2SV_blank>"" ""journaled<S2SV_blank>quota<S2SV_blank>options<S2SV_blank>when<S2SV_blank>"" ""quota<S2SV_blank>turned<S2SV_blank>on"" ) ; return 0 ; } sbi -> s_jquota_fmt = qfmt ; break ; case Opt_quota : case Opt_usrquota : set_opt ( sbi -> s_mount_opt , QUOTA ) ; set_opt ( sbi -> s_mount_opt , USRQUOTA ) ; break ; case Opt_grpquota : set_opt ( sbi -> s_mount_opt , QUOTA ) ; set_opt ( sbi -> s_mount_opt , GRPQUOTA ) ; break ; case Opt_noquota : if ( sb_any_quota_loaded ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>change<S2SV_blank>quota<S2SV_blank>"" ""options<S2SV_blank>when<S2SV_blank>quota<S2SV_blank>turned<S2SV_blank>on"" ) ; return 0 ; } clear_opt ( sbi -> s_mount_opt , QUOTA ) ; clear_opt ( sbi -> s_mount_opt , USRQUOTA ) ; clear_opt ( sbi -> s_mount_opt , GRPQUOTA ) ; break ; # else case Opt_quota : case Opt_usrquota : case Opt_grpquota : ext4_msg ( sb , KERN_ERR , ""quota<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; case Opt_usrjquota : case Opt_grpjquota : case Opt_offusrjquota : case Opt_offgrpjquota : case Opt_jqfmt_vfsold : case Opt_jqfmt_vfsv0 : case Opt_jqfmt_vfsv1 : ext4_msg ( sb , KERN_ERR , ""journaled<S2SV_blank>quota<S2SV_blank>options<S2SV_blank>not<S2SV_blank>supported"" ) ; break ; case Opt_noquota : break ; # endif case Opt_abort : sbi -> s_mount_flags |= EXT4_MF_FS_ABORTED ; break ; case Opt_nobarrier : clear_opt ( sbi -> s_mount_opt , BARRIER ) ; break ; case Opt_barrier : if ( args [ 0 ] . from ) { if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; } else option = 1 ; if ( option ) set_opt ( sbi -> s_mount_opt , BARRIER ) ; else clear_opt ( sbi -> s_mount_opt , BARRIER ) ; break ; case Opt_ignore : break ; case Opt_resize : if ( ! is_remount ) { ext4_msg ( sb , KERN_ERR , ""resize<S2SV_blank>option<S2SV_blank>only<S2SV_blank>available<S2SV_blank>"" ""for<S2SV_blank>remount"" ) ; return 0 ; } if ( match_int ( & args [ 0 ] , & option ) != 0 ) return 0 ; * n_blocks_count = option ; break ; case Opt_nobh : set_opt ( sbi -> s_mount_opt , NOBH ) ; break ; case Opt_bh : clear_opt ( sbi -> s_mount_opt , NOBH ) ; break ; case Opt_i_version : set_opt ( sbi -> s_mount_opt , I_VERSION ) ; sb -> s_flags |= MS_I_VERSION ; break ; case Opt_nodelalloc : clear_opt ( sbi -> s_mount_opt , DELALLOC ) ; break ; case Opt_stripe : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 ) return 0 ; sbi -> s_stripe = option ; break ; case Opt_delalloc : set_opt ( sbi -> s_mount_opt , DELALLOC ) ; break ; case Opt_block_validity : set_opt ( sbi -> s_mount_opt , BLOCK_VALIDITY ) ; break ; case Opt_noblock_validity : clear_opt ( sbi -> s_mount_opt , BLOCK_VALIDITY ) ; break ; case Opt_inode_readahead_blks : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 || option > ( 1 << 30 ) ) return 0 ; if ( ! is_power_of_2 ( option ) ) { ext4_msg ( sb , KERN_ERR , ""EXT4-fs:<S2SV_blank>inode_readahead_blks"" ""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" ) ; return 0 ; } sbi -> s_inode_readahead_blks = option ; break ; case Opt_journal_ioprio : if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; if ( option < 0 || option > 7 ) break ; * journal_ioprio = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_BE , option ) ; break ; case Opt_noauto_da_alloc : set_opt ( sbi -> s_mount_opt , NO_AUTO_DA_ALLOC ) ; break ; case Opt_auto_da_alloc : if ( args [ 0 ] . from ) { if ( match_int ( & args [ 0 ] , & option ) ) return 0 ; } else option = 1 ; if ( option ) clear_opt ( sbi -> s_mount_opt , NO_AUTO_DA_ALLOC ) ; else set_opt ( sbi -> s_mount_opt , NO_AUTO_DA_ALLOC ) ; break ; case Opt_discard : set_opt ( sbi -> s_mount_opt , DISCARD ) ; break ; case Opt_nodiscard : clear_opt ( sbi -> s_mount_opt , DISCARD ) ; break ; <S2SV_StartBug> default : <S2SV_EndBug> ext4_msg ( sb , KERN_ERR , ""Unrecognized<S2SV_blank>mount<S2SV_blank>option<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""or<S2SV_blank>missing<S2SV_blank>value"" , p ) ; return 0 ; } } # ifdef CONFIG_QUOTA if ( sbi -> s_qf_names [ USRQUOTA ] || sbi -> s_qf_names [ GRPQUOTA ] ) { if ( test_opt ( sb , USRQUOTA ) && sbi -> s_qf_names [ USRQUOTA ] ) clear_opt ( sbi -> s_mount_opt , USRQUOTA ) ; if ( test_opt ( sb , GRPQUOTA ) && sbi -> s_qf_names [ GRPQUOTA ] ) clear_opt ( sbi -> s_mount_opt , GRPQUOTA ) ; if ( test_opt ( sb , GRPQUOTA ) || test_opt ( sb , USRQUOTA ) ) { ext4_msg ( sb , KERN_ERR , ""old<S2SV_blank>and<S2SV_blank>new<S2SV_blank>quota<S2SV_blank>"" ""format<S2SV_blank>mixing"" ) ; return 0 ; } if ( ! sbi -> s_jquota_fmt ) { ext4_msg ( sb , KERN_ERR , ""journaled<S2SV_blank>quota<S2SV_blank>format<S2SV_blank>"" ""not<S2SV_blank>specified"" ) ; return 0 ; } } else { if ( sbi -> s_jquota_fmt ) { ext4_msg ( sb , KERN_ERR , ""journaled<S2SV_blank>quota<S2SV_blank>format<S2SV_blank>"" ""specified<S2SV_blank>with<S2SV_blank>no<S2SV_blank>journaling<S2SV_blank>"" ""enabled"" ) ; return 0 ; } } # endif return 1 ; }","; break ; case Opt_dioread_nolock : set_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ; case Opt_dioread_lock : clear_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ;"
560,"int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }",slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
561,"static TX_SIZE read_selected_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_StartBug> TX_SIZE max_tx_size , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const int ctx = vp9_get_tx_size_context ( xd ) ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * tx_probs = get_tx_probs ( max_tx_size , ctx , & cm -> fc . tx_probs ) ; <S2SV_EndBug> <S2SV_StartBug> int tx_size = vp9_read ( r , tx_probs [ 0 ] ) ; <S2SV_EndBug> if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) { <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 1 ] ) ; <S2SV_EndBug> if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 2 ] ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_tx_size , ctx , & cm -> counts . tx ) [ tx_size ] ; <S2SV_EndBug> return ( TX_SIZE ) tx_size ; }","TX_SIZE max_tx_size , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> int ctx = get_tx_size_context <S2SV_ModEnd> ( xd ) <S2SV_ModStart> ) ; const vpx_prob <S2SV_ModEnd> * tx_probs = <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> tx_probs ) ; <S2SV_ModStart> int tx_size = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> { tx_size += vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ) tx_size += vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> } if ( counts <S2SV_ModEnd> ) ++ get_tx_counts <S2SV_ModStart> ctx , & counts -> <S2SV_ModEnd> tx ) ["
562,"static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ; <S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }",tpg -> tport_tpgt <S2SV_ModEnd> ; if (
563,"static int flv_write_packet ( AVFormatContext * s , AVPacket * pkt ) { AVIOContext * pb = s -> pb ; AVCodecParameters * par = s -> streams [ pkt -> stream_index ] -> codecpar ; FLVContext * flv = s -> priv_data ; FLVStreamContext * sc = s -> streams [ pkt -> stream_index ] -> priv_data ; unsigned ts ; int size = pkt -> size ; uint8_t * data = NULL ; int flags = - 1 , flags_size , ret ; <S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) flags_size = 5 ; else flags_size = 1 ; if ( par -> codec_id == AV_CODEC_ID_AAC || par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { int side_size = 0 ; uint8_t * side = av_packet_get_side_data ( pkt , AV_PKT_DATA_NEW_EXTRADATA , & side_size ) ; if ( side && side_size > 0 && ( side_size != par -> extradata_size || memcmp ( side , par -> extradata , side_size ) ) ) { av_free ( par -> extradata ) ; par -> extradata = av_mallocz ( side_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! par -> extradata ) { par -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memcpy ( par -> extradata , side , side_size ) ; par -> extradata_size = side_size ; flv_write_codec_header ( s , par , pkt -> dts ) ; } } if ( flv -> delay == AV_NOPTS_VALUE ) flv -> delay = - pkt -> dts ; if ( pkt -> dts < - flv -> delay ) { av_log ( s , AV_LOG_WARNING , ""Packets<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>proper<S2SV_blank>order<S2SV_blank>with<S2SV_blank>respect<S2SV_blank>to<S2SV_blank>DTS\\n"" ) ; return AVERROR ( EINVAL ) ; } ts = pkt -> dts ; if ( s -> event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED ) { write_metadata ( s , ts ) ; s -> event_flags &= ~ AVSTREAM_EVENT_FLAG_METADATA_UPDATED ; } avio_write_marker ( pb , av_rescale ( ts , AV_TIME_BASE , 1000 ) , pkt -> flags & AV_PKT_FLAG_KEY && ( flv -> video_par ? par -> codec_type == AVMEDIA_TYPE_VIDEO : 1 ) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : avio_w8 ( pb , FLV_TAG_TYPE_VIDEO ) ; flags = ff_codec_get_tag ( flv_video_codec_ids , par -> codec_id ) ; flags |= pkt -> flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER ; break ; case AVMEDIA_TYPE_AUDIO : flags = get_audio_flags ( s , par ) ; av_assert0 ( size ) ; avio_w8 ( pb , FLV_TAG_TYPE_AUDIO ) ; break ; case AVMEDIA_TYPE_SUBTITLE : case AVMEDIA_TYPE_DATA : avio_w8 ( pb , FLV_TAG_TYPE_META ) ; break ; default : return AVERROR ( EINVAL ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( par -> extradata_size > 0 && * ( uint8_t * ) par -> extradata != 1 ) if ( ( ret = ff_avc_parse_nal_units_buf ( pkt -> data , & data , & size ) ) < 0 ) return ret ; } else if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , ""Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>"" ""(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n"" ) ; return AVERROR_INVALIDDATA ; } av_log ( s , AV_LOG_WARNING , ""aac<S2SV_blank>bitstream<S2SV_blank>error\\n"" ) ; } if ( par -> codec_id == AV_CODEC_ID_SPEEX && ts - sc -> last_ts > 160 ) av_log ( s , AV_LOG_WARNING , ""Warning:<S2SV_blank>Speex<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>more<S2SV_blank>than<S2SV_blank>"" ""8<S2SV_blank>frames<S2SV_blank>per<S2SV_blank>packet.<S2SV_blank>Adobe<S2SV_blank>Flash<S2SV_blank>"" ""Player<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>this!\\n"" ) ; if ( sc -> last_ts < ts ) sc -> last_ts = ts ; if ( size + flags_size >= 1 << 24 ) { av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>large<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>%u\\n"" , size + flags_size , 1 << 24 ) ; return AVERROR ( EINVAL ) ; } avio_wb24 ( pb , size + flags_size ) ; put_timestamp ( pb , ts ) ; avio_wb24 ( pb , flv -> reserved ) ; if ( par -> codec_type == AVMEDIA_TYPE_DATA || par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int data_size ; int64_t metadata_size_pos = avio_tell ( pb ) ; if ( par -> codec_id == AV_CODEC_ID_TEXT ) { avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , ""onTextData"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_MIXEDARRAY ) ; avio_wb32 ( pb , 2 ) ; put_amf_string ( pb , ""type"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , ""Text"" ) ; put_amf_string ( pb , ""text"" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , pkt -> data ) ; put_amf_string ( pb , """" ) ; avio_w8 ( pb , AMF_END_OF_OBJECT ) ; } else { avio_write ( pb , data ? data : pkt -> data , size ) ; } data_size = avio_tell ( pb ) - metadata_size_pos ; avio_seek ( pb , metadata_size_pos - 10 , SEEK_SET ) ; avio_wb24 ( pb , data_size ) ; avio_seek ( pb , data_size + 10 - 3 , SEEK_CUR ) ; avio_wb32 ( pb , data_size + 11 ) ; } else { av_assert1 ( flags >= 0 ) ; avio_w8 ( pb , flags ) ; if ( par -> codec_id == AV_CODEC_ID_VP6 ) avio_w8 ( pb , 0 ) ; if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A ) { if ( par -> extradata_size ) avio_w8 ( pb , par -> extradata [ 0 ] ) ; else avio_w8 ( pb , ( ( FFALIGN ( par -> width , 16 ) - par -> width ) << 4 ) | ( FFALIGN ( par -> height , 16 ) - par -> height ) ) ; } else if ( par -> codec_id == AV_CODEC_ID_AAC ) avio_w8 ( pb , 1 ) ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { avio_w8 ( pb , 1 ) ; avio_wb24 ( pb , pkt -> pts - pkt -> dts ) ; } avio_write ( pb , data ? data : pkt -> data , size ) ; avio_wb32 ( pb , size + flags_size + 11 ) ; flv -> duration = FFMAX ( flv -> duration , pkt -> pts + flv -> delay + pkt -> duration ) ; } if ( flv -> flags & FLV_ADD_KEYFRAME_INDEX ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : flv -> videosize += ( avio_tell ( pb ) - cur_offset ) ; flv -> lasttimestamp = flv -> acurframeindex / flv -> framerate ; if ( pkt -> flags & AV_PKT_FLAG_KEY ) { double ts = flv -> acurframeindex / flv -> framerate ; int64_t pos = cur_offset ; flv -> lastkeyframetimestamp = flv -> acurframeindex / flv -> framerate ; flv -> lastkeyframelocation = pos ; flv_append_keyframe_info ( s , flv , ts , pos ) ; } flv -> acurframeindex ++ ; break ; case AVMEDIA_TYPE_AUDIO : flv -> audiosize += ( avio_tell ( pb ) - cur_offset ) ; break ; default : av_log ( s , AV_LOG_WARNING , ""par->codec_type<S2SV_blank>is<S2SV_blank>type<S2SV_blank>=<S2SV_blank>[%d]\\n"" , par -> codec_type ) ; break ; } } av_free ( data ) ; return pb -> error ; }","pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\n"" ) ; return AVERROR ( EINVAL ) ; }"
564,"static int l2tp_ip6_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * addr = ( struct sockaddr_l2tpip6 * ) uaddr ; struct net * net = sock_net ( sk ) ; __be32 v4addr = 0 ; int addr_type ; int err ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; if ( addr -> l2tp_family != AF_INET6 ) return - EINVAL ; if ( addr_len < sizeof ( * addr ) ) return - EINVAL ; addr_type = ipv6_addr_type ( & addr -> l2tp_addr ) ; if ( addr_type == IPV6_ADDR_MAPPED ) return - EADDRNOTAVAIL ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - EADDRNOTAVAIL ; err = - EADDRINUSE ; read_lock_bh ( & l2tp_ip6_lock ) ; if ( __l2tp_ip6_bind_lookup ( net , & addr -> l2tp_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip6_lock ) ; lock_sock ( sk ) ; err = - EINVAL ; <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug> goto out_unlock ; rcu_read_lock ( ) ; if ( addr_type != IPV6_ADDR_ANY ) { struct net_device * dev = NULL ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && addr -> l2tp_scope_id ) { sk -> sk_bound_dev_if = addr -> l2tp_scope_id ; } if ( ! sk -> sk_bound_dev_if ) goto out_unlock_rcu ; err = - ENODEV ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! dev ) goto out_unlock_rcu ; } v4addr = LOOPBACK4_IPV6 ; err = - EADDRNOTAVAIL ; if ( ! ipv6_chk_addr ( sock_net ( sk ) , & addr -> l2tp_addr , dev , 0 ) ) goto out_unlock_rcu ; } rcu_read_unlock ( ) ; inet -> inet_rcv_saddr = inet -> inet_saddr = v4addr ; sk -> sk_v6_rcv_saddr = addr -> l2tp_addr ; np -> saddr = addr -> l2tp_addr ; l2tp_ip6_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip6_lock ) ; sk_add_bind_node ( sk , & l2tp_ip6_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip6_lock ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return 0 ; out_unlock_rcu : rcu_read_unlock ( ) ; out_unlock : release_sock ( sk ) ; return err ; out_in_use : read_unlock_bh ( & l2tp_ip6_lock ) ; return err ; }","; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if ("
565,"void jshGetPinString ( char * result , Pin pin ) { result [ 0 ] = 0 ; # ifdef PIN_NAMES_DIRECT if ( jshIsPinValid ( pin ) ) { result [ 0 ] = ( char ) ( 'A' + ( pinInfo [ pin ] . port & JSH_PORT_MASK ) - JSH_PORTA ) ; itostr ( pinInfo [ pin ] . pin - JSH_PIN0 , & result [ 1 ] , 10 ) ; # else if ( false ) { # if JSH_PORTA_OFFSET != - 1 } else if ( # if JSH_PORTA_OFFSET != 0 pin >= JSH_PORTA_OFFSET && # endif pin < JSH_PORTA_OFFSET + JSH_PORTA_COUNT ) { result [ 0 ] = 'A' ; itostr ( pin - JSH_PORTA_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTB_OFFSET != - 1 } else if ( pin >= JSH_PORTB_OFFSET && pin < JSH_PORTB_OFFSET + JSH_PORTB_COUNT ) { result [ 0 ] = 'B' ; itostr ( pin - JSH_PORTB_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTC_OFFSET != - 1 } else if ( pin >= JSH_PORTC_OFFSET && pin < JSH_PORTC_OFFSET + JSH_PORTC_COUNT ) { result [ 0 ] = 'C' ; itostr ( pin - JSH_PORTC_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTD_OFFSET != - 1 } else if ( # if JSH_PORTD_OFFSET != 0 pin >= JSH_PORTD_OFFSET && # endif pin < JSH_PORTD_OFFSET + JSH_PORTD_COUNT ) { result [ 0 ] = 'D' ; itostr ( pin - JSH_PORTD_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTE_OFFSET != - 1 } else if ( pin >= JSH_PORTE_OFFSET && pin < JSH_PORTE_OFFSET + JSH_PORTE_COUNT ) { result [ 0 ] = 'E' ; itostr ( pin - JSH_PORTE_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTF_OFFSET != - 1 } else if ( pin >= JSH_PORTF_OFFSET && pin < JSH_PORTF_OFFSET + JSH_PORTF_COUNT ) { result [ 0 ] = 'F' ; itostr ( pin - JSH_PORTF_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTG_OFFSET != - 1 } else if ( pin >= JSH_PORTG_OFFSET && pin < JSH_PORTG_OFFSET + JSH_PORTG_COUNT ) { result [ 0 ] = 'G' ; itostr ( pin - JSH_PORTG_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTH_OFFSET != - 1 } else if ( pin >= JSH_PORTH_OFFSET && pin < JSH_PORTH_OFFSET + JSH_PORTH_COUNT ) { result [ 0 ] = 'H' ; itostr ( pin - JSH_PORTH_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTI_OFFSET != - 1 } else if ( pin >= JSH_PORTI_OFFSET && pin < JSH_PORTI_OFFSET + JSH_PORTI_COUNT ) { result [ 0 ] = 'I' ; itostr ( pin - JSH_PORTI_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTV_OFFSET != - 1 } else if ( pin >= JSH_PORTV_OFFSET && pin < JSH_PORTV_OFFSET + JSH_PORTV_COUNT ) { result [ 0 ] = 'V' ; itostr ( pin - JSH_PORTV_OFFSET , & result [ 1 ] , 10 ) ; # endif # endif } else { <S2SV_StartBug> strncpy ( result , ""undefined"" , 10 ) ; <S2SV_EndBug> } }","} else { strcpy <S2SV_ModEnd> ( result , <S2SV_ModStart> result , ""undefined"" <S2SV_ModEnd> ) ; }"
566,"static Status accept_xsmp_connection ( SmsConn sms_conn , GsmXsmpServer * server , unsigned long * mask_ret , SmsCallbacks * callbacks_ret , char * * failure_reason_ret ) { IceConn ice_conn ; <S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> if ( server -> priv -> xsmp_sockets == NULL ) { g_debug ( ""GsmXsmpServer:<S2SV_blank>In<S2SV_blank>shutdown,<S2SV_blank>rejecting<S2SV_blank>new<S2SV_blank>client"" ) ; * failure_reason_ret = strdup ( _ ( ""Refusing<S2SV_blank>new<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>because<S2SV_blank>the<S2SV_blank>session<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>being<S2SV_blank>shut<S2SV_blank>down\\n"" ) ) ; return FALSE ; } ice_conn = SmsGetIceConnection ( sms_conn ) ; <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> return TRUE ; }","IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> ; if ( <S2SV_ModStart> sms_conn ) ; data <S2SV_ModEnd> = ice_conn -> <S2SV_ModStart> -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> ) ; gsm_xsmp_client_connect <S2SV_ModStart> ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn ,"
567,"static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ; int err ; unsigned char * p = kmap ( page ) ; struct udf_inode_info * iinfo ; uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ; if ( ! bh ) { err = - EIO ; goto out_unlock_inode ; } symlink = bh -> b_data ; } <S2SV_StartBug> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; <S2SV_EndBug> <S2SV_StartBug> brelse ( bh ) ; <S2SV_EndBug> up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ; out_unlock_inode : up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ; out_unmap : kunmap ( page ) ; unlock_page ( page ) ; return err ; }","b_data ; } err = <S2SV_ModStart> i_size , p , PAGE_SIZE <S2SV_ModStart> ( bh ) ; if ( err ) goto out_unlock_inode"
568,"<S2SV_StartBug> static char * print_array ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> { char * * entries ; char * out = 0 , * ptr , * ret ; int len = 5 ; cJSON * child = item -> child ; int numentries = 0 , i = 0 , fail = 0 ; <S2SV_StartBug> while ( child ) { <S2SV_EndBug> ++ numentries ; child = child -> next ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) <S2SV_EndBug> return 0 ; memset ( entries , 0 , numentries * sizeof ( char * ) ) ; child = item -> child ; <S2SV_StartBug> while ( child && ! fail ) { <S2SV_EndBug> <S2SV_StartBug> ret = print_value ( child , depth + 1 , fmt ) ; <S2SV_EndBug> entries [ i ++ ] = ret ; if ( ret ) len += strlen ( ret ) + 2 + ( fmt ? 1 : 0 ) ; else fail = 1 ; child = child -> next ; } <S2SV_StartBug> if ( ! fail ) { <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len ) ; if ( ! out ) fail = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( fail ) { <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) <S2SV_EndBug> if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; cJSON_free ( entries ) ; return 0 ; } * out = '[' ; ptr = out + 1 ; * ptr = 0 ; <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> strcpy ( ptr , entries [ i ] ) ; <S2SV_StartBug> ptr += strlen ( entries [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i != numentries - 1 ) { <S2SV_EndBug> * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; } <S2SV_StartBug> cJSON_free ( entries [ i ] ) ; <S2SV_EndBug> } cJSON_free ( entries ) ; * ptr ++ = ']' ; <S2SV_StartBug> * ptr ++ = 0 ; <S2SV_EndBug> return out ; }",", int fmt , printbuffer * p <S2SV_ModStart> = 0 ; size_t tmplen = 0 ; <S2SV_ModStart> ( child ) numentries ++ , <S2SV_ModEnd> child = child <S2SV_ModStart> -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , 3 ) ; else out = ( char <S2SV_ModEnd> * ) cJSON_malloc <S2SV_ModStart> ) cJSON_malloc ( 3 ) ; if ( out ) strcpy ( out , ""[]"" ) ; return out ; } if ( p ) { i = p -> offset ; ptr = ensure ( p , 1 ) ; if ( ! ptr ) return 0 ; * ptr = '[' ; p -> offset ++ <S2SV_ModEnd> ; child = <S2SV_ModStart> ! fail ) { <S2SV_ModEnd> print_value ( child <S2SV_ModStart> 1 , fmt , p ) ; p -> offset = update ( p ) ; if ( child -> next ) { len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; p -> offset += len ; } child = child -> next ; } ptr = ensure ( p , 2 ) ; if ( ! ptr ) return 0 ; * ptr ++ = ']' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; memset ( entries , 0 , numentries * sizeof ( char * ) ) ; child = item -> child ; while ( child && ! fail ) { ret = print_value ( child , depth + 1 , fmt , 0 <S2SV_ModStart> ! fail ) <S2SV_ModEnd> out = ( <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( fail <S2SV_ModStart> < numentries ; i ++ ) <S2SV_ModEnd> if ( entries <S2SV_ModStart> < numentries ; i ++ ) { tmplen = strlen ( <S2SV_ModEnd> entries [ i <S2SV_ModStart> ] ) ; memcpy ( ptr , entries [ i ] , tmplen ) ; ptr += tmplen ; if ( i != numentries - 1 ) { * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; } cJSON_free <S2SV_ModEnd> ( entries [ <S2SV_ModStart> ] ) ; <S2SV_ModEnd> } cJSON_free ( <S2SV_ModStart> cJSON_free ( entries <S2SV_ModEnd> ) ; * <S2SV_ModStart> = ']' ; * ptr ++ = 0 ; } <S2SV_ModEnd> return out ;"
569,"static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; <S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }",) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
570,"static int cg_open ( const char * path , struct fuse_file_info * fi ) { const char * cgroup ; char * fpath = NULL , * path1 , * path2 , * cgdir = NULL , * controller ; struct cgfs_files * k = NULL ; struct file_info * file_info ; struct fuse_context * fc = fuse_get_context ( ) ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } k = cgfs_get_key ( controller , path1 , path2 ) ; if ( ! k ) { ret = - EINVAL ; goto out ; } free_key ( k ) ; <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) { <S2SV_EndBug> ret = - EACCES ; goto out ; } file_info = malloc ( sizeof ( * file_info ) ) ; if ( ! file_info ) { ret = - ENOMEM ; goto out ; } file_info -> controller = must_copy_string ( controller ) ; file_info -> cgroup = must_copy_string ( path1 ) ; file_info -> file = must_copy_string ( path2 ) ; file_info -> type = LXC_TYPE_CGFILE ; file_info -> buf = NULL ; file_info -> buflen = 0 ; fi -> fh = ( unsigned long ) file_info ; ret = 0 ; out : free ( cgdir ) ; return ret ; }","if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( !"
571,"void vp9_setup_block_planes ( MACROBLOCKD * xd , int ss_x , int ss_y ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { xd -> plane [ i ] . plane_type = i ? PLANE_TYPE_UV : PLANE_TYPE_Y ; xd -> plane [ i ] . subsampling_x = i ? ss_x : 0 ; xd -> plane [ i ] . subsampling_y = i ? ss_y : 0 ; } <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> xd -> plane [ 3 ] . plane_type = PLANE_TYPE_Y ; xd -> plane [ 3 ] . subsampling_x = 0 ; xd -> plane [ 3 ] . subsampling_y = 0 ; # endif }",0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
572,void usb_serial_console_disconnect ( struct usb_serial * serial ) { <S2SV_StartBug> if ( serial -> port [ 0 ] == usbcons_info . port ) { <S2SV_EndBug> usb_serial_console_exit ( ) ; usb_serial_put ( serial ) ; } },{ if ( serial -> port [ 0 ] &&
573,"<S2SV_StartBug> static int ion_handle_put ( struct ion_handle * handle ) <S2SV_EndBug> { struct ion_client * client = handle -> client ; int ret ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> ret = kref_put ( & handle -> ref , ion_handle_destroy ) ; <S2SV_EndBug> mutex_unlock ( & client -> lock ) ; return ret ; }",<S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ion_handle_put ( <S2SV_ModStart> ; ret = ion_handle_put_nolock ( handle <S2SV_ModEnd> ) ; mutex_unlock
574,"static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }",( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
575,"static void copy_and_extend_plane ( unsigned char * s , int sp , unsigned char * d , int dp , int h , int w , int et , int el , int eb , int er ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; int linesize ; src_ptr1 = s ; src_ptr2 = s + w - 1 ; dest_ptr1 = d - el ; dest_ptr2 = d + w ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ; src_ptr1 += sp ; src_ptr2 += sp ; dest_ptr1 += dp ; dest_ptr2 += dp ; } src_ptr1 = d - el ; src_ptr2 = d + dp * ( h - 1 ) - el ; dest_ptr1 = d + dp * ( - et ) - el ; dest_ptr2 = d + dp * ( h ) - el ; linesize = el + er + w ; for ( i = 0 ; i < et ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dest_ptr1 += dp ; } for ( i = 0 ; i < eb ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dest_ptr2 += dp ; } }","++ ) { memset <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> el ) ; memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dest_ptr2 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 ,"
576,"int my_redel ( const char * org_name , const char * tmp_name , time_t backup_time_stamp , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( ""my_redel"" ) ; DBUG_PRINT ( ""my"" , ( ""org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d"" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> goto end ; if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH ] ; my_create_backup_name ( name_buff , org_name , backup_time_stamp ) ; if ( my_rename ( org_name , name_buff , MyFlags ) ) goto end ; } else if ( my_delete ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }",; if ( ! my_disable_copystat_in_redel &&
577,"<S2SV_StartBug> static inline int <S2SV_EndBug> addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) { return 0 == tor_addr_compare_masked ( a1 , a2 , 16 , CMP_SEMANTIC ) ; }",<S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int addrs_in_same_network_family (
578,"static int dissect_usb_video_control_interface_descriptor ( proto_tree * parent_tree , tvbuff_t * tvb , guint8 descriptor_len , packet_info * pinfo , usb_conv_info_t * usb_conv_info ) { video_conv_info_t * video_conv_info = NULL ; video_entity_t * entity = NULL ; proto_item * item = NULL ; proto_item * subtype_item = NULL ; proto_tree * tree = NULL ; guint8 entity_id = 0 ; guint16 terminal_type = 0 ; int offset = 0 ; guint8 subtype ; subtype = tvb_get_guint8 ( tvb , offset + 2 ) ; if ( parent_tree ) { const gchar * subtype_str ; subtype_str = val_to_str_ext ( subtype , & vc_if_descriptor_subtypes_ext , ""Unknown<S2SV_blank>(0x%x)"" ) ; tree = proto_tree_add_subtree_format ( parent_tree , tvb , offset , descriptor_len , ett_descriptor_video_control , & item , ""VIDEO<S2SV_blank>CONTROL<S2SV_blank>INTERFACE<S2SV_blank>DESCRIPTOR<S2SV_blank>[%s]"" , subtype_str ) ; } dissect_usb_descriptor_header ( tree , tvb , offset , & vid_descriptor_type_vals_ext ) ; subtype_item = proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_subtype , tvb , offset + 2 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 3 ; if ( subtype == VC_HEADER ) { guint8 num_vs_interfaces ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bcdUVC , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_ifdesc_wTotalLength , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_dwClockFrequency , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; num_vs_interfaces = tvb_get_guint8 ( tvb , offset + 8 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bInCollection , tvb , offset + 8 , 1 , ENC_LITTLE_ENDIAN ) ; if ( num_vs_interfaces > 0 ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_baInterfaceNr , tvb , offset + 9 , num_vs_interfaces , ENC_NA ) ; } offset += 9 + num_vs_interfaces ; } else if ( ( subtype == VC_INPUT_TERMINAL ) || ( subtype == VC_OUTPUT_TERMINAL ) ) { entity_id = tvb_get_guint8 ( tvb , offset ) ; terminal_type = tvb_get_letohs ( tvb , offset + 1 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_type , tvb , offset + 1 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_assoc_terminal , tvb , offset + 3 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; if ( subtype == VC_OUTPUT_TERMINAL ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_src_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; } proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_iTerminal , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_INPUT_TERMINAL ) { if ( terminal_type == ITT_CAMERA ) { offset = dissect_usb_video_camera_terminal ( tree , tvb , offset ) ; } else if ( terminal_type == ITT_MEDIA_TRANSPORT_INPUT ) { } } if ( subtype == VC_OUTPUT_TERMINAL ) { if ( terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT ) { } } } else { entity_id = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_unit_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_PROCESSING_UNIT ) { offset = dissect_usb_video_processing_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_SELECTOR_UNIT ) { offset = dissect_usb_video_selector_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_EXTENSION_UNIT ) { offset = dissect_usb_video_extension_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_ENCODING_UNIT ) { } else { expert_add_info_format ( pinfo , subtype_item , & ei_usb_vid_subtype_unknown , ""Unknown<S2SV_blank>VC<S2SV_blank>subtype<S2SV_blank>%u"" , subtype ) ; } } if ( offset < descriptor_len ) { proto_tree_add_item ( tree , hf_usb_vid_descriptor_data , tvb , offset , descriptor_len - offset , ENC_NA ) ; } if ( entity_id != 0 ) proto_item_append_text ( item , ""<S2SV_blank>(Entity<S2SV_blank>%d)"" , entity_id ) ; if ( subtype != VC_HEADER && usb_conv_info ) { usb_conv_info = get_usb_iface_conv_info ( pinfo , usb_conv_info -> interfaceNum ) ; video_conv_info = ( video_conv_info_t * ) usb_conv_info -> class_data ; if ( ! video_conv_info ) { video_conv_info = wmem_new ( wmem_file_scope ( ) , video_conv_info_t ) ; video_conv_info -> entities = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = video_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ; if ( ! entity ) { entity = wmem_new ( wmem_file_scope ( ) , video_entity_t ) ; entity -> entityID = entity_id ; entity -> subtype = subtype ; entity -> terminalType = terminal_type ; wmem_tree_insert32 ( video_conv_info -> entities , entity_id , entity ) ; } } return descriptor_len ; }",= video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
579,"static int setup_ttydir_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console , char * ttydir ) { char path [ MAXPATHLEN ] , lxcpath [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/dev/%s"" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( path ) ) return - 1 ; ret = mkdir ( path , 0755 ) ; if ( ret && errno != EEXIST ) { SYSERROR ( ""failed<S2SV_blank>with<S2SV_blank>errno<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%s"" , errno , path ) ; return - 1 ; } INFO ( ""created<S2SV_blank>%s"" , path ) ; ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/dev/%s/console"" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } snprintf ( path , sizeof ( path ) , ""%s/dev/console"" , rootfs -> mount ) ; ret = unlink ( path ) ; if ( ret && errno != ENOENT ) { SYSERROR ( ""error<S2SV_blank>unlinking<S2SV_blank>%s"" , path ) ; return - 1 ; } ret = creat ( lxcpath , 0660 ) ; if ( ret == - 1 && errno != EEXIST ) { SYSERROR ( ""error<S2SV_blank>%d<S2SV_blank>creating<S2SV_blank>%s"" , errno , lxcpath ) ; return - 1 ; } if ( ret >= 0 ) close ( ret ) ; if ( console -> master < 0 ) { INFO ( ""no<S2SV_blank>console"" ) ; return 0 ; } <S2SV_StartBug> if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , console -> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console"" ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s"" , lxcpath ) ; return 0 ; }","} if ( safe_mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , <S2SV_ModEnd> console -> name <S2SV_ModStart> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console"" ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s"" , lxcpath ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>"
580,"generic_ret * init_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) { static generic_ret ret ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; kadm5_server_handle_t handle ; OM_uint32 minor_stat ; const char * errmsg = NULL ; size_t clen , slen ; char * cdots , * sdots ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( * arg , rqstp , & handle ) ) ) goto exit_func ; if ( ! ( ret . code = check_handle ( ( void * ) handle ) ) ) { ret . api_version = handle -> api_version ; } free_server_handle ( handle ) ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( ret . code != 0 ) errmsg = krb5_get_error_message ( NULL , ret . code ) ; clen = client_name . length ; trunc_name ( & clen , & cdots ) ; slen = service_name . length ; trunc_name ( & slen , & sdots ) ; krb5_klog_syslog ( LOG_NOTICE , _ ( ""Request:<S2SV_blank>kadm5_init,<S2SV_blank>%.*s%s,<S2SV_blank>%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s,<S2SV_blank>"" ""vers=%d,<S2SV_blank>flavor=%d"" ) , ( int ) clen , ( char * ) client_name . value , cdots , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) , ret . api_version & ~ ( KADM5_API_VERSION_MASK ) , rqstp -> rq_cred . oa_flavor ) ; if ( errmsg != NULL ) krb5_free_error_message ( NULL , errmsg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : return ( & ret ) ; }","; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; kadm5_server_handle_t handle <S2SV_ModStart> errmsg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> return ( &"
581,"static void mldv2_report_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int group , nsrcs , ngroups ; u_int i , j ; if ( len < 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 1 ] ) ; ngroups = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 1 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>record(s)"" , ngroups ) ) ; if ( ndo -> ndo_vflag > 0 ) { group = 8 ; for ( i = 0 ; i < ngroups ; i ++ ) { if ( len < group + 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>groups]"" ) ) ; return ; } ND_TCHECK2 ( bp [ group + 4 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ group + 4 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( mldv2report2str , ""<S2SV_blank>[v2-report-#%d]"" , bp [ group ] ) ) ) ; nsrcs = ( bp [ group + 2 ] << 8 ) + bp [ group + 3 ] ; if ( len < group + 20 + ( nsrcs * sizeof ( struct in6_addr ) ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources<S2SV_blank>%d]"" , nsrcs ) ) ; return ; } if ( ndo -> ndo_vflag == 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( j = 0 ; j < nsrcs ; j ++ ) { ND_TCHECK2 ( bp [ group + 20 + j * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ group + 20 + j * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } group += 20 + nsrcs * sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""]"" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> return ; }","( ndo , ""%s"" , mldv2_tstr <S2SV_ModEnd> ) ) ;"
582,"char * path_name ( const struct name_path * path , const char * name ) { const struct name_path * p ; char * n , * m ; int nlen = strlen ( name ) ; int len = nlen + 1 ; for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) len += p -> elem_len + 1 ; } n = xmalloc ( len ) ; m = n + len - ( nlen + 1 ) ; <S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) { m -= p -> elem_len + 1 ; memcpy ( m , p -> elem , p -> elem_len ) ; m [ p -> elem_len ] = '/' ; } } return n ; }","1 ) ; memcpy <S2SV_ModEnd> ( m , <S2SV_ModStart> m , name , nlen + 1"
583,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { return ERROR_INV_SLICE_HDR_T ; } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug> } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",} } } <S2SV_ModEnd> } else {
584,"static int <S2SV_StartBug> mptctl_eventenable ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_eventenable __user * uarg = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_eventenable karg ; <S2SV_EndBug> MPT_ADAPTER * ioc ; int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventenable ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventenable<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_eventenable<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventenable()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventenable<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> events == NULL ) { int sz = MPTCTL_EVENT_LOG_SIZE * sizeof ( MPT_IOCTL_EVENTS ) ; ioc -> events = kzalloc ( sz , GFP_KERNEL ) ; if ( ! ioc -> events ) { printk ( MYIOC_s_ERR_FMT "":<S2SV_blank>ERROR<S2SV_blank>-<S2SV_blank>Insufficient<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>add<S2SV_blank>adapter!\\n"" , ioc -> name ) ; return - ENOMEM ; } ioc -> alloc_total += sz ; ioc -> eventContext = 0 ; } ioc -> eventTypes = karg . eventTypes ; return 0 ; }","int mptctl_eventenable ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_eventenable karg <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk"
585,"static ssize_t _hostsock_send ( oe_fd_t * sock_ , const void * buf , size_t count , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_send_ocall ( & ret , sock -> host_fd , buf , count , flags ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }",! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
586,"static void set_entropy_context_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; <S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ; <S2SV_EndBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; int aoff , loff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , p -> eobs [ block ] > 0 , aoff , loff ) ; }",= arg ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> const xd = & x -> e_mbd <S2SV_ModEnd> ; struct macroblock_plane <S2SV_ModStart> p = & x -> <S2SV_ModEnd> plane [ plane
587,"generic_ret * modify_principal_2_svc ( mprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_MODIFY ; log_unauth ( ""kadm5_modify_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_modify_principal ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
588,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ALIGN16 ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; return SET_IVD_FATAL_ERROR ( e_error ) ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug> impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }",4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }
589,"char * cJSON_PrintUnformatted ( cJSON * item ) { <S2SV_StartBug> return print_value ( item , 0 , 0 ) ; <S2SV_EndBug> }","0 , 0 , 0"
590,"int obj2ast_arguments ( PyObject * obj , arguments_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; asdl_seq * args ; arg_ty vararg ; asdl_seq * kwonlyargs ; asdl_seq * kw_defaults ; arg_ty kwarg ; asdl_seq * defaults ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; args = _Ta3_asdl_seq_new ( len , arena ) ; if ( args == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> arg_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( args , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_vararg ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_vararg ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_arg ( tmp , & vararg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { vararg = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_kwonlyargs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_kwonlyargs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""kwonlyargs\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; kwonlyargs = _Ta3_asdl_seq_new ( len , arena ) ; if ( kwonlyargs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> arg_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""kwonlyargs\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( kwonlyargs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""kwonlyargs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_kw_defaults ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_kw_defaults ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""kw_defaults\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; kw_defaults = _Ta3_asdl_seq_new ( len , arena ) ; if ( kw_defaults == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""kw_defaults\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( kw_defaults , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""kw_defaults\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_kwarg ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_kwarg ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_arg ( tmp , & kwarg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { kwarg = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_defaults ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_defaults ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""defaults\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; defaults = _Ta3_asdl_seq_new ( len , arena ) ; if ( defaults == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""arguments<S2SV_blank>field<S2SV_blank>\\""defaults\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( defaults , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""defaults\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } <S2SV_StartBug> * out = arguments ( args , vararg , kwonlyargs , kw_defaults , kwarg , defaults , <S2SV_EndBug> arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { arg_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_vararg , & tmp ) < 0 ) { <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; vararg = NULL ; } else { int res ; res = obj2ast_arg ( tmp , & vararg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_kwonlyargs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""kwonlyargs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { arg_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_kw_defaults , & tmp ) < 0 ) { <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""kw_defaults\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_kwarg , & tmp ) < 0 ) { <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; kwarg = NULL ; } else { int res ; res = obj2ast_arg ( tmp , & kwarg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_defaults , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""defaults\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = arguments ( args , vararg , kwonlyargs , kw_defaults , kwarg , defaults , arena ) ; return 0 ; failed : Py_XDECREF ( tmp <S2SV_ModEnd> ) ; return <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
591,"static void __inet_del_ifa ( struct in_device * in_dev , struct in_ifaddr * * ifap , int destroy , struct nlmsghdr * nlh , u32 portid ) { struct in_ifaddr * promote = NULL ; struct in_ifaddr * ifa , * ifa1 = * ifap ; struct in_ifaddr * last_prim = in_dev -> ifa_list ; struct in_ifaddr * prev_prom = NULL ; int do_promote = IN_DEV_PROMOTE_SECONDARIES ( in_dev ) ; ASSERT_RTNL ( ) ; <S2SV_StartBug> if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) { <S2SV_EndBug> struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ; while ( ( ifa = * ifap1 ) != NULL ) { if ( ! ( ifa -> ifa_flags & IFA_F_SECONDARY ) && ifa1 -> ifa_scope <= ifa -> ifa_scope ) last_prim = ifa ; if ( ! ( ifa -> ifa_flags & IFA_F_SECONDARY ) || ifa1 -> ifa_mask != ifa -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , ifa ) ) { ifap1 = & ifa -> ifa_next ; prev_prom = ifa ; continue ; } if ( ! do_promote ) { inet_hash_remove ( ifa ) ; * ifap1 = ifa -> ifa_next ; rtmsg_ifa ( RTM_DELADDR , ifa , nlh , portid ) ; blocking_notifier_call_chain ( & inetaddr_chain , NETDEV_DOWN , ifa ) ; inet_free_ifa ( ifa ) ; } else { promote = ifa ; break ; } } } for ( ifa = promote ; ifa ; ifa = ifa -> ifa_next ) { if ( ifa1 -> ifa_mask == ifa -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , ifa ) ) fib_del_ifaddr ( ifa , ifa1 ) ; <S2SV_StartBug> } <S2SV_EndBug> * ifap = ifa1 -> ifa_next ; inet_hash_remove ( ifa1 ) ; rtmsg_ifa ( RTM_DELADDR , ifa1 , nlh , portid ) ; blocking_notifier_call_chain ( & inetaddr_chain , NETDEV_DOWN , ifa1 ) ; if ( promote ) { struct in_ifaddr * next_sec = promote -> ifa_next ; if ( prev_prom ) { prev_prom -> ifa_next = promote -> ifa_next ; promote -> ifa_next = last_prim -> ifa_next ; last_prim -> ifa_next = promote ; } promote -> ifa_flags &= ~ IFA_F_SECONDARY ; rtmsg_ifa ( RTM_NEWADDR , promote , nlh , portid ) ; blocking_notifier_call_chain ( & inetaddr_chain , NETDEV_UP , promote ) ; for ( ifa = next_sec ; ifa ; ifa = ifa -> ifa_next ) { if ( ifa1 -> ifa_mask != ifa -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , ifa ) ) continue ; fib_add_ifaddr ( ifa ) ; } } if ( destroy ) inet_free_ifa ( ifa1 ) ; }",; if ( in_dev -> dead ) goto no_promotions ; if ( <S2SV_ModStart> ) ; } no_promotions :
592,"static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }",iv ) ; <S2SV_ModEnd> while ( walk
593,"static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <S2SV_EndBug> if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }",") ) ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;"
594,"MagickExport void * AcquireAlignedMemory ( const size_t count , const size_t quantum ) { # define AlignedExtent ( size , alignment ) ( ( ( size ) + ( ( alignment ) - 1 ) ) & ~ ( ( alignment ) - 1 ) ) size_t alignment , extent , size ; void * memory ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; memory = NULL ; alignment = CACHE_LINE_SIZE ; size = count * quantum ; extent = AlignedExtent ( size , alignment ) ; if ( ( size == 0 ) || ( alignment < sizeof ( void * ) ) || ( extent < size ) ) return ( ( void * ) NULL ) ; # if defined ( MAGICKCORE_HAVE_POSIX_MEMALIGN ) if ( posix_memalign ( & memory , alignment , extent ) != 0 ) memory = NULL ; # elif defined ( MAGICKCORE_HAVE__ALIGNED_MALLOC ) memory = _aligned_malloc ( extent , alignment ) ; # else { void * p ; extent = ( size + alignment - 1 ) + sizeof ( void * ) ; if ( extent > size ) { p = malloc ( extent ) ; if ( p != NULL ) { memory = ( void * ) AlignedExtent ( ( size_t ) p + sizeof ( void * ) , alignment ) ; * ( ( void * * ) memory - 1 ) = p ; } } } # endif return ( memory ) ; }","; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,"
595,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , <S2SV_StartBug> number_planes , <S2SV_EndBug> one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","number_colormaps , number_planes , number_planes_filled <S2SV_ModStart> -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) != ( <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException <S2SV_ModStart> -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info ="
596,"struct dst_entry * inet6_csk_route_req ( const struct sock * sk , struct flowi6 * fl6 , const struct request_sock * req , u8 proto ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = proto ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> fl6 -> flowi6_oif = ireq -> ir_iif ; fl6 -> flowi6_mark = ireq -> ir_mark ; fl6 -> fl6_dport = ireq -> ir_rmt_port ; fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( IS_ERR ( dst ) ) return NULL ; return dst ; }","-> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;"
597,"dfa * Ta3Grammar_FindDFA ( grammar * g , int type ) { dfa * d ; # if 1 d = & g -> g_dfa [ type - NT_OFFSET ] ; assert ( d -> d_type == type ) ; return d ; # else int i ; for ( i = g -> g_ndfas , d = g -> g_dfa ; -- i >= 0 ; d ++ ) { if ( d -> d_type == type ) return d ; } <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> # endif }",d ; } abort ( <S2SV_ModEnd> ) ; #
598,"static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof TSRMLS_DC ) { <S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> size_t klen , vlen ; unsigned int new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> if ( ! vsep ) { <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = """" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen TSRMLS_CC ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr TSRMLS_CC ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }","{ char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;"
599,"static int ape_read_header ( AVFormatContext * s , AVFormatParameters * ap ) { AVIOContext * pb = s -> pb ; APEContext * ape = s -> priv_data ; AVStream * st ; uint32_t tag ; int i ; int total_blocks ; int64_t pts ; ape -> junklength = 0 ; tag = avio_rl32 ( pb ) ; if ( tag != MKTAG ( 'M' , 'A' , 'C' , '<S2SV_blank>' ) ) return - 1 ; ape -> fileversion = avio_rl16 ( pb ) ; if ( ape -> fileversion < APE_MIN_VERSION || ape -> fileversion > APE_MAX_VERSION ) { av_log ( s , AV_LOG_ERROR , ""Unsupported<S2SV_blank>file<S2SV_blank>version<S2SV_blank>-<S2SV_blank>%d.%02d\\n"" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 ) ; return - 1 ; } if ( ape -> fileversion >= 3980 ) { ape -> padding1 = avio_rl16 ( pb ) ; ape -> descriptorlength = avio_rl32 ( pb ) ; ape -> headerlength = avio_rl32 ( pb ) ; ape -> seektablelength = avio_rl32 ( pb ) ; ape -> wavheaderlength = avio_rl32 ( pb ) ; ape -> audiodatalength = avio_rl32 ( pb ) ; ape -> audiodatalength_high = avio_rl32 ( pb ) ; ape -> wavtaillength = avio_rl32 ( pb ) ; avio_read ( pb , ape -> md5 , 16 ) ; if ( ape -> descriptorlength > 52 ) avio_seek ( pb , ape -> descriptorlength - 52 , SEEK_CUR ) ; ape -> compressiontype = avio_rl16 ( pb ) ; ape -> formatflags = avio_rl16 ( pb ) ; ape -> blocksperframe = avio_rl32 ( pb ) ; ape -> finalframeblocks = avio_rl32 ( pb ) ; ape -> totalframes = avio_rl32 ( pb ) ; ape -> bps = avio_rl16 ( pb ) ; ape -> channels = avio_rl16 ( pb ) ; ape -> samplerate = avio_rl32 ( pb ) ; } else { ape -> descriptorlength = 0 ; ape -> headerlength = 32 ; ape -> compressiontype = avio_rl16 ( pb ) ; ape -> formatflags = avio_rl16 ( pb ) ; ape -> channels = avio_rl16 ( pb ) ; ape -> samplerate = avio_rl32 ( pb ) ; ape -> wavheaderlength = avio_rl32 ( pb ) ; ape -> wavtaillength = avio_rl32 ( pb ) ; ape -> totalframes = avio_rl32 ( pb ) ; ape -> finalframeblocks = avio_rl32 ( pb ) ; if ( ape -> formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL ) { avio_seek ( pb , 4 , SEEK_CUR ) ; ape -> headerlength += 4 ; } if ( ape -> formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS ) { ape -> seektablelength = avio_rl32 ( pb ) ; ape -> headerlength += 4 ; ape -> seektablelength *= sizeof ( int32_t ) ; } else ape -> seektablelength = ape -> totalframes * sizeof ( int32_t ) ; if ( ape -> formatflags & MAC_FORMAT_FLAG_8_BIT ) ape -> bps = 8 ; else if ( ape -> formatflags & MAC_FORMAT_FLAG_24_BIT ) ape -> bps = 24 ; else ape -> bps = 16 ; if ( ape -> fileversion >= 3950 ) ape -> blocksperframe = 73728 * 4 ; else if ( ape -> fileversion >= 3900 || ( ape -> fileversion >= 3800 && ape -> compressiontype >= 4000 ) ) ape -> blocksperframe = 73728 ; else ape -> blocksperframe = 9216 ; if ( ! ( ape -> formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER ) ) avio_seek ( pb , ape -> wavheaderlength , SEEK_CUR ) ; } <S2SV_StartBug> if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) { <S2SV_EndBug> av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>many<S2SV_blank>frames:<S2SV_blank>%d\\n"" , ape -> totalframes ) ; return - 1 ; } ape -> frames = av_malloc ( ape -> totalframes * sizeof ( APEFrame ) ) ; if ( ! ape -> frames ) return AVERROR ( ENOMEM ) ; ape -> firstframe = ape -> junklength + ape -> descriptorlength + ape -> headerlength + ape -> seektablelength + ape -> wavheaderlength ; ape -> currentframe = 0 ; ape -> totalsamples = ape -> finalframeblocks ; if ( ape -> totalframes > 1 ) ape -> totalsamples += ape -> blocksperframe * ( ape -> totalframes - 1 ) ; if ( ape -> seektablelength > 0 ) { ape -> seektable = av_malloc ( ape -> seektablelength ) ; for ( i = 0 ; i < ape -> seektablelength / sizeof ( uint32_t ) ; i ++ ) ape -> seektable [ i ] = avio_rl32 ( pb ) ; } ape -> frames [ 0 ] . pos = ape -> firstframe ; ape -> frames [ 0 ] . nblocks = ape -> blocksperframe ; ape -> frames [ 0 ] . skip = 0 ; for ( i = 1 ; i < ape -> totalframes ; i ++ ) { ape -> frames [ i ] . pos = ape -> seektable [ i ] ; ape -> frames [ i ] . nblocks = ape -> blocksperframe ; ape -> frames [ i - 1 ] . size = ape -> frames [ i ] . pos - ape -> frames [ i - 1 ] . pos ; ape -> frames [ i ] . skip = ( ape -> frames [ i ] . pos - ape -> frames [ 0 ] . pos ) & 3 ; } ape -> frames [ ape -> totalframes - 1 ] . size = ape -> finalframeblocks * 4 ; ape -> frames [ ape -> totalframes - 1 ] . nblocks = ape -> finalframeblocks ; for ( i = 0 ; i < ape -> totalframes ; i ++ ) { if ( ape -> frames [ i ] . skip ) { ape -> frames [ i ] . pos -= ape -> frames [ i ] . skip ; ape -> frames [ i ] . size += ape -> frames [ i ] . skip ; } ape -> frames [ i ] . size = ( ape -> frames [ i ] . size + 3 ) & ~ 3 ; } ape_dumpinfo ( s , ape ) ; if ( ! url_is_streamed ( pb ) ) { ff_ape_parse_tag ( s ) ; avio_seek ( pb , 0 , SEEK_SET ) ; } av_log ( s , AV_LOG_DEBUG , ""Decoding<S2SV_blank>file<S2SV_blank>-<S2SV_blank>v%d.%02d,<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d\\n"" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 , ape -> compressiontype ) ; st = av_new_stream ( s , 0 ) ; if ( ! st ) return - 1 ; total_blocks = ( ape -> totalframes == 0 ) ? 0 : ( ( ape -> totalframes - 1 ) * ape -> blocksperframe ) + ape -> finalframeblocks ; st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codec -> codec_id = CODEC_ID_APE ; st -> codec -> codec_tag = MKTAG ( 'A' , 'P' , 'E' , '<S2SV_blank>' ) ; st -> codec -> channels = ape -> channels ; st -> codec -> sample_rate = ape -> samplerate ; st -> codec -> bits_per_coded_sample = ape -> bps ; st -> codec -> frame_size = MAC_SUBFRAME_SIZE ; st -> nb_frames = ape -> totalframes ; st -> start_time = 0 ; st -> duration = total_blocks / MAC_SUBFRAME_SIZE ; av_set_pts_info ( st , 64 , MAC_SUBFRAME_SIZE , ape -> samplerate ) ; st -> codec -> extradata = av_malloc ( APE_EXTRADATA_SIZE ) ; st -> codec -> extradata_size = APE_EXTRADATA_SIZE ; AV_WL16 ( st -> codec -> extradata + 0 , ape -> fileversion ) ; AV_WL16 ( st -> codec -> extradata + 2 , ape -> compressiontype ) ; AV_WL16 ( st -> codec -> extradata + 4 , ape -> formatflags ) ; pts = 0 ; for ( i = 0 ; i < ape -> totalframes ; i ++ ) { ape -> frames [ i ] . pts = pts ; av_add_index_entry ( st , ape -> frames [ i ] . pos , ape -> frames [ i ] . pts , 0 , 0 , AVINDEX_KEYFRAME ) ; pts += ape -> blocksperframe / MAC_SUBFRAME_SIZE ; } return 0 ; }","} if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , ""No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n"" ) ; return AVERROR ( EINVAL ) ; } if ("
600,"static int snd_hrtimer_stop ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
601,"<S2SV_StartBug> static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> int mi_row , int mi_col , int bsize ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> const struct segmentation * const seg = & cm -> seg ; <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = ctx -> mic ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) { <S2SV_EndBug> <S2SV_StartBug> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , bsize , 1 ) ; <S2SV_EndBug> vp9_init_plane_quantizers ( cpi , x ) ; } if ( is_inter_block ( mbmi ) ) { <S2SV_StartBug> vp9_update_mv_count ( cm , xd ) ; <S2SV_EndBug> if ( cm -> interp_filter == SWITCHABLE ) { const int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ; <S2SV_StartBug> ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug> x -> skip = ctx -> skip ; <S2SV_StartBug> } <S2SV_EndBug>","* cpi , ThreadData * td , <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> e_mbd ; MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_ModStart> -> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; <S2SV_ModStart> -> mic ; * ( x -> mbmi_ext ) = ctx -> mbmi_ext ; if ( seg -> enabled && cpi -> oxcf . aq_mode ) { if <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> . aq_mode == COMPLEXITY_AQ || cpi -> oxcf . aq_mode == VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; } else <S2SV_ModEnd> { vp9_cyclic_refresh_update_segment ( <S2SV_ModStart> ( cpi , mbmi , <S2SV_ModEnd> mi_row , mi_col <S2SV_ModStart> , bsize , ctx -> rate , ctx -> dist , x -> skip ) ; } <S2SV_ModEnd> vp9_init_plane_quantizers ( cpi <S2SV_ModStart> { vp9_update_mv_count ( td <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ; ++ td -> counts -> <S2SV_ModEnd> switchable_interp [ pred_ctx <S2SV_ModStart> ] ; } if ( mbmi -> sb_type < BLOCK_8X8 ) { mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; } } if ( cm -> use_prev_frame_mvs ) { MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h ; for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } } <S2SV_ModStart> -> skip ; x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;"
602,"int nfssvc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readargs * args ) { unsigned int len ; int v ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; args -> offset = ntohl ( * p ++ ) ; len = args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> p ++ ; <S2SV_EndBug> len = min_t ( unsigned int , len , NFSSVC_MAXBLKSIZE_V2 ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }","; p ++ ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> v ; return 1 <S2SV_ModEnd> ; } <S2SV_null>"
603,"static int grub_ext2_iterate_dir ( grub_fshelp_node_t dir , int ( * hook ) ( const char * filename , enum grub_fshelp_filetype filetype , grub_fshelp_node_t node , void * closure ) , void * closure ) { unsigned int fpos = 0 ; struct grub_fshelp_node * diro = ( struct grub_fshelp_node * ) dir ; if ( ! diro -> inode_read ) { grub_ext2_read_inode ( diro -> data , diro -> ino , & diro -> inode ) ; if ( grub_errno ) return 0 ; } if ( hook ) while ( fpos < grub_le_to_cpu32 ( diro -> inode . size ) ) { struct ext2_dirent dirent ; grub_ext2_read_file ( diro , NULL , NULL , 0 , fpos , sizeof ( dirent ) , ( char * ) & dirent ) ; if ( grub_errno ) return 0 ; if ( dirent . direntlen == 0 ) return 0 ; if ( dirent . namelen != 0 ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char filename [ dirent . namelen + 1 ] ; <S2SV_EndBug> # else char * filename = grub_malloc ( dirent . namelen + 1 ) ; # endif struct grub_fshelp_node * fdiro ; <S2SV_StartBug> enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; <S2SV_EndBug> grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ; if ( grub_errno ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ; if ( ! fdiro ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> fdiro -> data = diro -> data ; fdiro -> ino = grub_le_to_cpu32 ( dirent . inode ) ; filename [ dirent . namelen ] = '\\0' ; if ( dirent . filetype != FILETYPE_UNKNOWN ) { fdiro -> inode_read = 0 ; if ( dirent . filetype == FILETYPE_DIRECTORY ) type = GRUB_FSHELP_DIR ; else if ( dirent . filetype == FILETYPE_SYMLINK ) type = GRUB_FSHELP_SYMLINK ; else if ( dirent . filetype == FILETYPE_REG ) type = GRUB_FSHELP_REG ; } else { grub_ext2_read_inode ( diro -> data , grub_le_to_cpu32 ( dirent . inode ) , & fdiro -> inode ) ; if ( grub_errno ) <S2SV_StartBug> { <S2SV_EndBug> grub_free ( fdiro ) ; return 0 ; } fdiro -> inode_read = 1 ; if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_DIRECTORY ) type = GRUB_FSHELP_DIR ; else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_SYMLINK ) type = GRUB_FSHELP_SYMLINK ; else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_REG ) type = GRUB_FSHELP_REG ; } <S2SV_StartBug> if ( hook ( filename , type , fdiro , closure ) ) <S2SV_EndBug> return 1 ; } fpos += grub_le_to_cpu16 ( dirent . direntlen ) ; } return 0 ; }",0 ) { char * filename = grub_malloc ( <S2SV_ModEnd> dirent . namelen <S2SV_ModStart> namelen + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node * <S2SV_ModStart> = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = grub_malloc <S2SV_ModStart> ! fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> data <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; <S2SV_ModEnd> grub_free ( fdiro <S2SV_ModStart> closure ) ) { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> ; } fpos
604,"void xgroupCommand ( client * c ) { const char * help [ ] = { ""CREATE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>consumer<S2SV_blank>group."" , ""SETID<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>current<S2SV_blank>group<S2SV_blank>ID."" , ""DELGROUP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>group."" , ""DELCONSUMER<S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><consumer><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>conusmer."" , ""HELP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Prints<S2SV_blank>this<S2SV_blank>help."" , NULL } ; stream * s = NULL ; sds grpname = NULL ; streamCG * cg = NULL ; char * opt = c -> argv [ 1 ] -> ptr ; if ( c -> argc >= 4 ) { robj * o = lookupKeyWriteOrReply ( c , c -> argv [ 2 ] , shared . nokeyerr ) ; <S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> s = o -> ptr ; grpname = c -> argv [ 3 ] -> ptr ; if ( ( cg = streamLookupCG ( s , grpname ) ) == NULL && ( ! strcasecmp ( opt , ""SETID"" ) || ! strcasecmp ( opt , ""DELCONSUMER"" ) ) ) { addReplyErrorFormat ( c , ""-NOGROUP<S2SV_blank>No<S2SV_blank>such<S2SV_blank>consumer<S2SV_blank>group<S2SV_blank>\'%s\'<S2SV_blank>"" ""for<S2SV_blank>key<S2SV_blank>name<S2SV_blank>\'%s\'"" , ( char * ) grpname , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } } if ( ! strcasecmp ( opt , ""CREATE"" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , ""$"" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } streamCG * cg = streamCreateCG ( s , grpname , sdslen ( grpname ) , & id ) ; if ( cg ) { addReply ( c , shared . ok ) ; server . dirty ++ ; } else { addReplySds ( c , sdsnew ( ""-BUSYGROUP<S2SV_blank>Consumer<S2SV_blank>Group<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists\\r\\n"" ) ) ; } } else if ( ! strcasecmp ( opt , ""SETID"" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , ""$"" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } cg -> last_id = id ; addReply ( c , shared . ok ) ; } else if ( ! strcasecmp ( opt , ""DESTROY"" ) && c -> argc == 4 ) { if ( cg ) { raxRemove ( s -> cgroups , ( unsigned char * ) grpname , sdslen ( grpname ) , NULL ) ; streamFreeCG ( cg ) ; addReply ( c , shared . cone ) ; } else { addReply ( c , shared . czero ) ; } } else if ( ! strcasecmp ( opt , ""DELCONSUMER"" ) && c -> argc == 5 ) { long long pending = streamDelConsumer ( cg , c -> argv [ 4 ] -> ptr ) ; addReplyLongLong ( c , pending ) ; server . dirty ++ ; } else if ( ! strcasecmp ( opt , ""HELP"" ) ) { addReplyHelp ( c , help ) ; } else { addReply ( c , shared . syntaxerr ) ; } }","o == NULL || checkType ( c , o , OBJ_STREAM )"
605,"static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
606,"int <S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> { struct vendor_attribute * attr ; <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> * data = attr -> attrib_data ; * len = attr -> attrib_len - 2 ; <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> }","u_int32_t * vendor , unsigned char * type <S2SV_ModStart> size_t * len , const void * raw , size_t raw_len <S2SV_ModStart> * attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> vendor_attribute * ) raw <S2SV_ModEnd> ; * vendor <S2SV_ModStart> -> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> - 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }"
607,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : <S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( image ) ; }",; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image <S2SV_ModStart> -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
608,"rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( ""client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( ""server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n"" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( ""%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n"" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n"" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; <S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Open\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Close\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n"" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : buffer = malloc ( msg . tc . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( ""Received<S2SV_blank>TextChat<S2SV_blank>\\""%s\\""\\n"" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( ""Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n"" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( ""Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n"" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }","length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) msg . sct . length ) ; return FALSE ; }"
609,"int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) return - E2BIG ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ; <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; if ( error == 0 ) acl = NULL ; <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> inode -> i_mode = mode ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , GFP_NOFS ) ; if ( data == NULL ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = NULL ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }","; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } if ("
610,"static int http_buf_read ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int len ; len = s -> buf_end - s -> buf_ptr ; if ( len > 0 ) { if ( len > size ) len = size ; memcpy ( buf , s -> buf_ptr , len ) ; s -> buf_ptr += len ; } else { <S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ; len = ffurl_read ( s -> hd , buf , size ) ; <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off < target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug> s -> off , target_end ) ; return AVERROR ( EIO ) ; } } if ( len > 0 ) { s -> off += len ; if ( s -> chunksize > 0 ) s -> chunksize -= len ; } return len ; }","} else { uint64_t <S2SV_ModEnd> target_end = s <S2SV_ModStart> s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> <S2SV_ModStart> s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { <S2SV_ModStart> AV_LOG_ERROR , ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> ""\\n"" , s"
611,void vp8_end_second_pass ( VP8_COMP * cpi ) { <S2SV_StartBug> } <S2SV_EndBug>,cpi ) { ( void ) cpi ;
612,"char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) { int length ; length = strlen ( filename ) ; <S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> { if ( ( filename [ 0 ] == \'\\""\' ) && ( filename [ length - 1 ] == \'\\""\' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ; } return strdup ( filename ) ; }",( length > 1 <S2SV_ModEnd> ) { if
613,"int v3d_submit_cl_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct v3d_dev * v3d = to_v3d_dev ( dev ) ; struct v3d_file_priv * v3d_priv = file_priv -> driver_priv ; struct drm_v3d_submit_cl * args = data ; struct v3d_bin_job * bin = NULL ; struct v3d_render_job * render ; struct ww_acquire_ctx acquire_ctx ; int ret = 0 ; trace_v3d_submit_cl_ioctl ( & v3d -> drm , args -> rcl_start , args -> rcl_end ) ; if ( args -> pad != 0 ) { DRM_INFO ( ""pad<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero:<S2SV_blank>%d\\n"" , args -> pad ) ; return - EINVAL ; } render = kcalloc ( 1 , sizeof ( * render ) , GFP_KERNEL ) ; if ( ! render ) return - ENOMEM ; render -> start = args -> rcl_start ; render -> end = args -> rcl_end ; INIT_LIST_HEAD ( & render -> unref_list ) ; ret = v3d_job_init ( v3d , file_priv , & render -> base , v3d_render_job_free , args -> in_sync_rcl ) ; if ( ret ) { kfree ( render ) ; return ret ; } if ( args -> bcl_start != args -> bcl_end ) { bin = kcalloc ( 1 , sizeof ( * bin ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! bin ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> ret = v3d_job_init ( v3d , file_priv , & bin -> base , <S2SV_EndBug> v3d_job_free , args -> in_sync_bcl ) ; if ( ret ) { <S2SV_StartBug> v3d_job_put ( & render -> base ) ; <S2SV_EndBug> return ret ; } bin -> start = args -> bcl_start ; bin -> end = args -> bcl_end ; bin -> qma = args -> qma ; bin -> qms = args -> qms ; bin -> qts = args -> qts ; bin -> render = render ; } ret = v3d_lookup_bos ( dev , file_priv , & render -> base , args -> bo_handles , args -> bo_handle_count ) ; if ( ret ) goto fail ; ret = v3d_lock_bo_reservations ( & render -> base , & acquire_ctx ) ; if ( ret ) goto fail ; mutex_lock ( & v3d -> sched_lock ) ; if ( bin ) { ret = v3d_push_job ( v3d_priv , & bin -> base , V3D_BIN ) ; if ( ret ) goto fail_unreserve ; ret = drm_gem_fence_array_add ( & render -> base . deps , dma_fence_get ( bin -> base . done_fence ) ) ; if ( ret ) goto fail_unreserve ; } ret = v3d_push_job ( v3d_priv , & render -> base , V3D_RENDER ) ; if ( ret ) goto fail_unreserve ; mutex_unlock ( & v3d -> sched_lock ) ; v3d_attach_fences_and_unlock_reservation ( file_priv , & render -> base , & acquire_ctx , args -> out_sync , render -> base . done_fence ) ; if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return 0 ; fail_unreserve : mutex_unlock ( & v3d -> sched_lock ) ; drm_gem_unlock_reservations ( render -> base . bo , render -> base . bo_count , & acquire_ctx ) ; fail : if ( bin ) v3d_job_put ( & bin -> base ) ; v3d_job_put ( & render -> base ) ; return ret ; }",! bin ) { v3d_job_put ( & render -> base ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> render -> base ) ; kfree ( bin
614,"stmt_ty <S2SV_StartBug> With ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = With_kind ; p -> v . With . items = items ; p -> v . With . body = body ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","* body , string type_comment , <S2SV_ModStart> ; p -> v . With . type_comment = type_comment ; p ->"
615,"static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec , <S2SV_StartBug> bool compat ) <S2SV_EndBug> { ssize_t ret ; * nr_segs = * len ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( rw , ( struct compat_iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; else # endif ret = rw_copy_check_uvector ( rw , ( struct iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; if ( ret < 0 ) return ret ; * len = ret ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",", bool compat , struct iov_iter * iter <S2SV_ModStart> = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;"
616,"static int packet_set_ring ( struct sock * sk , union tpacket_req_u * req_u , int closing , int tx_ring ) { struct pgv * pg_vec = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; int was_running , order = 0 ; struct packet_ring_buffer * rb ; struct sk_buff_head * rb_queue ; __be16 num ; int err = - EINVAL ; <S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) { net_warn_ratelimited ( ""Tx-ring<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\\n"" ) ; goto out ; } rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ; rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ; err = - EBUSY ; if ( ! closing ) { if ( atomic_read ( & po -> mapped ) ) goto out ; if ( packet_read_pending ( rb ) ) goto out ; } if ( req -> tp_block_nr ) { err = - EBUSY ; if ( unlikely ( rb -> pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ; break ; case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ; break ; case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ; break ; } err = - EINVAL ; if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ; if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ; if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ; if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ; if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ; rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ; if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ; if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ; err = - ENOMEM ; order = get_order ( req -> tp_block_size ) ; pg_vec = alloc_pg_vec ( req , order ) ; if ( unlikely ( ! pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ; break ; default : break ; } } else { err = - EINVAL ; if ( unlikely ( req -> tp_frame_nr ) ) goto out ; } <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> spin_lock ( & po -> bind_lock ) ; was_running = po -> running ; num = po -> num ; if ( was_running ) { po -> num = 0 ; __unregister_prot_hook ( sk , false ) ; } spin_unlock ( & po -> bind_lock ) ; synchronize_net ( ) ; err = - EBUSY ; mutex_lock ( & po -> pg_vec_lock ) ; if ( closing || atomic_read ( & po -> mapped ) == 0 ) { err = 0 ; spin_lock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec , pg_vec ) ; rb -> frame_max = ( req -> tp_frame_nr - 1 ) ; rb -> head = 0 ; rb -> frame_size = req -> tp_frame_size ; spin_unlock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec_order , order ) ; swap ( rb -> pg_vec_len , req -> tp_block_nr ) ; rb -> pg_vec_pages = req -> tp_block_size / PAGE_SIZE ; po -> prot_hook . func = ( po -> rx_ring . pg_vec ) ? tpacket_rcv : packet_rcv ; skb_queue_purge ( rb_queue ) ; if ( atomic_read ( & po -> mapped ) ) pr_err ( ""packet_mmap:<S2SV_blank>vma<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>%d\\n"" , atomic_read ( & po -> mapped ) ) ; } mutex_unlock ( & po -> pg_vec_lock ) ; spin_lock ( & po -> bind_lock ) ; if ( was_running ) { po -> num = num ; register_prot_hook ( sk ) ; } spin_unlock ( & po -> bind_lock ) ; if ( closing && ( po -> tp_version > TPACKET_V2 ) ) { if ( ! tx_ring ) prb_shutdown_retire_blk_timer ( po , rb_queue ) ; } <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : return err ; }","req_u -> req ; lock_sock ( sk ) <S2SV_ModStart> out ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ; } if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart> sk ) ; <S2SV_ModEnd> return err ;"
617,"error_t coapClientSetTxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> txBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }",== 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> txBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
618,"static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = SHOST_TO_SAS_HA ( cmd -> device -> host ) ; <S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> sas_end_task ( cmd , task ) ; <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> }",") ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }"
619,"krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; <S2SV_StartBug> char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; <S2SV_EndBug> char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone = FALSE ; <S2SV_StartBug> krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; <S2SV_EndBug> char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>found"" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_wrapmsg ( context , ost , st , _ ( ""\'%s\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { <S2SV_StartBug> int dnlen = 0 , subtreelen = 0 ; <S2SV_EndBug> char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { ""krbticketpolicyreference"" , ""krbprincipalname"" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY || entry -> mask & KADM5_KEY_HIST ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } } if ( entry -> mask & KADM5_POLICY ) { if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_HIST ) { bersecretkey = krb5_encode_histkey ( & princ_ent ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbpwdhistory"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; free_berdata ( bersecretkey ) ; bersecretkey = NULL ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone ) { st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastPwdChange"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } st = update_ldap_mod_auth_ind ( context , entry , & mods ) ; if ( st != 0 ) goto cleanup ; if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbExtraData"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } free_berdata ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastAdminUnlock"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , ""objectclass"" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( ""ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>"" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbObjectReferences"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = ""krbprincipal"" ; strval [ 1 ] = ""krbprincipalaux"" ; strval [ 2 ] = ""krbTicketPolicyAux"" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { ""krbprincipalaux"" , ""krbTicketPolicyAux"" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , ""objectclass"" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }","NULL ; char <S2SV_ModEnd> * strval [ <S2SV_ModStart> FALSE ; krb5_boolean <S2SV_ModEnd> establish_links = FALSE <S2SV_ModStart> TRUE ) { if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> ntrees ) ; <S2SV_ModStart> ( st ) <S2SV_ModEnd> goto cleanup ;"
620,"unsigned int ipt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; const struct iphdr * ip ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ipt_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; ip = ip_hdr ( skb ) ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . fragoff = ntohs ( ip -> frag_off ) & IP_OFFSET ; acpar . thoff = ip_hdrlen ( skb ) ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ipt_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; if ( ! ip_packet_match ( ip , indev , outdev , & e -> ip , acpar . fragoff ) ) { no_match : e = ipt_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ipt_get_target ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = ipt_next_entry ( e ) ; } continue ; } if ( table_base + v != ipt_next_entry ( e ) && <S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> jumpstack [ stackidx ++ ] = e ; <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { ip = ip_hdr ( skb ) ; e = ipt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }",IPT_F_GOTO ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> = e ; }
621,"static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , struct user_namespace * user_ns , struct fs_struct * fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old = mnt_ns -> root ; struct mount * new ; int copy_flags ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; down_write ( & namespace_sem ) ; copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns -> user_ns ) <S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; br_write_unlock ( & vfsmount_lock ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; if ( fs ) { if ( & p -> mnt == fs -> root . mnt ) { fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == fs -> pwd . mnt ) { fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; } up_write ( & namespace_sem ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }",copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED
622,"static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ MAX_SKB_FRAGS ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; <S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - EFAULT ; } truesize = size * PAGE_SIZE ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ PAGE_MASK ; int size = min_t ( int , len , PAGE_SIZE - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }",>> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
623,"static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , ""%d<S2SV_blank>bytes<S2SV_blank>left\\n"" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , ""chunk<S2SV_blank>too<S2SV_blank>big\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , ""png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n"" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ; if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : case MKTAG ( 't' , 'E' , 'X' , 't' ) : case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : case MKTAG ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto skip_tag ; } } switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) goto fail ; break ; case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) goto fail ; break ; case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) goto fail ; decode_next_dat = 1 ; break ; case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ! decode_next_dat ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_get_be32 ( & s -> gb ) ; length -= 4 ; case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) goto skip_tag ; if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) goto fail ; break ; case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : if ( decode_plte_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'R' , 'N' , 'S' ) : if ( decode_trns_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'E' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 'z' , 'T' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , ""Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n"" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { int mode = bytestream2_get_byte ( & s -> gb ) ; AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; if ( ! stereo3d ) goto fail ; if ( mode == 0 || mode == 1 ) { stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; } else { av_log ( avctx , AV_LOG_WARNING , ""Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n"" , mode ) ; } bytestream2_skip ( & s -> gb , 4 ) ; break ; } case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) av_log ( avctx , AV_LOG_ERROR , ""IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n"" ) ; if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_skip ( & s -> gb , 4 ) ; goto exit_loop ; default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ; break ; } } exit_loop : if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( s -> bits_per_pixel <= 4 ) handle_small_bpp ( s , p ) ; if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; size_t raw_bpp = s -> bpp - byte_depth ; unsigned x , y ; <S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; for ( x = s -> width ; x > 0 ; -- x ) { uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; } else { memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; } } } } if ( s -> last_picture . f -> data [ 0 ] ) { if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( ""MPNG"" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format ) { if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) handle_p_frame_png ( s , p ) ; else if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) goto fail ; } } ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; av_frame_set_metadata ( p , metadata ) ; metadata = NULL ; return 0 ; fail : av_dict_free ( & metadata ) ; ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; return ret ; }",", y ; av_assert0 ( s -> bit_depth > 1 ) ;"
624,"<S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> { size_t n ; uint32_t types = up -> types ; p -> types = types ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { uintptr_t a = up -> vals [ n * 2 ] ; size_t b = up -> vals [ n * 2 + 1 ] ; <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ; p -> u [ n ] . mem . offs = a ; p -> u [ n ] . mem . size = b ; <S2SV_StartBug> break ; <S2SV_EndBug> case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ; p -> u [ n ] . val . b = b ; break ; default : memset ( & p -> u [ n ] , 0 , sizeof ( p -> u [ n ] ) ) ; break ; } <S2SV_StartBug> } <S2SV_EndBug> }","<S2SV_null> <S2SV_null> static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> struct tee_ta_param * <S2SV_ModStart> 1 ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p -> <S2SV_ModStart> = b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> ; } } return TEE_SUCCESS ;"
625,"static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> if ( sk != asoc -> base . sk ) <S2SV_EndBug> goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }",current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk
626,"static void gimp_write_and_read_file ( Gimp * gimp , gboolean with_unusual_stuff , gboolean compat_paths , gboolean use_gimp_2_8_features ) { GimpImage * image ; GimpImage * loaded_image ; GimpPlugInProcedure * proc ; <S2SV_StartBug> gchar * filename ; <S2SV_EndBug> GFile * file ; image = gimp_create_mainimage ( gimp , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; gimp_assert_mainimage ( image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; <S2SV_StartBug> filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ; <S2SV_EndBug> file = g_file_new_for_path ( filename ) ; g_free ( filename ) ; proc = gimp_plug_in_manager_file_procedure_find ( image -> gimp -> plug_in_manager , GIMP_FILE_PROCEDURE_GROUP_SAVE , file , NULL ) ; file_save ( gimp , image , NULL , file , proc , GIMP_RUN_NONINTERACTIVE , FALSE , FALSE , FALSE , NULL ) ; loaded_image = gimp_test_load_image ( image -> gimp , file ) ; gimp_assert_mainimage ( loaded_image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; g_file_delete ( file , NULL , NULL ) ; g_object_unref ( file ) ; }","gchar * filename = NULL ; gint file_handle <S2SV_ModStart> use_gimp_2_8_features ) ; file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> ) ; file"
627,"opj_image_t * bmptoimage ( const char * filename , opj_cparameters_t * parameters ) { opj_image_cmptparm_t cmptparm [ 4 ] ; OPJ_UINT8 lut_R [ 256 ] , lut_G [ 256 ] , lut_B [ 256 ] ; OPJ_UINT8 const * pLUT [ 3 ] ; opj_image_t * image = NULL ; FILE * IN ; OPJ_BITMAPFILEHEADER File_h ; OPJ_BITMAPINFOHEADER Info_h ; OPJ_UINT32 i , palette_len , numcmpts = 1U ; OPJ_BOOL l_result = OPJ_FALSE ; OPJ_UINT8 * pData = NULL ; OPJ_UINT32 stride ; pLUT [ 0 ] = lut_R ; pLUT [ 1 ] = lut_G ; pLUT [ 2 ] = lut_B ; IN = fopen ( filename , ""rb"" ) ; if ( ! IN ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n"" , filename ) ; return NULL ; } if ( ! bmp_read_file_header ( IN , & File_h ) ) { fclose ( IN ) ; return NULL ; } if ( ! bmp_read_info_header ( IN , & Info_h ) ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount <= 8U ) { memset ( & lut_R [ 0 ] , 0 , sizeof ( lut_R ) ) ; memset ( & lut_G [ 0 ] , 0 , sizeof ( lut_G ) ) ; memset ( & lut_B [ 0 ] , 0 , sizeof ( lut_B ) ) ; palette_len = Info_h . biClrUsed ; if ( ( palette_len == 0U ) && ( Info_h . biBitCount <= 8U ) ) { palette_len = ( 1U << Info_h . biBitCount ) ; } if ( palette_len > 256U ) { palette_len = 256U ; } if ( palette_len > 0U ) { OPJ_UINT8 has_color = 0U ; for ( i = 0U ; i < palette_len ; i ++ ) { lut_B [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; lut_G [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; lut_R [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; ( void ) getc ( IN ) ; has_color |= ( lut_B [ i ] ^ lut_G [ i ] ) | ( lut_G [ i ] ^ lut_R [ i ] ) ; } if ( has_color ) { numcmpts = 3U ; } } } else { numcmpts = 3U ; if ( ( Info_h . biCompression == 3 ) && ( Info_h . biAlphaMask != 0U ) ) { numcmpts ++ ; } } <S2SV_StartBug> stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ; <S2SV_EndBug> <S2SV_StartBug> if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { <S2SV_EndBug> stride = ( ( Info_h . biWidth * 8U + 31U ) / 32U ) * 4U ; } <S2SV_StartBug> pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ; <S2SV_EndBug> if ( pData == NULL ) { fclose ( IN ) ; return NULL ; } fseek ( IN , 0 , SEEK_SET ) ; fseek ( IN , ( long ) File_h . bfOffBits , SEEK_SET ) ; switch ( Info_h . biCompression ) { case 0 : case 3 : l_result = bmp_read_raw_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; break ; case 1 : l_result = bmp_read_rle8_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; break ; case 2 : l_result = bmp_read_rle4_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; break ; default : fprintf ( stderr , ""Unsupported<S2SV_blank>BMP<S2SV_blank>compression\\n"" ) ; l_result = OPJ_FALSE ; break ; } if ( ! l_result ) { free ( pData ) ; fclose ( IN ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , sizeof ( cmptparm ) ) ; for ( i = 0 ; i < 4U ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; cmptparm [ i ] . w = Info_h . biWidth ; cmptparm [ i ] . h = Info_h . biHeight ; } image = opj_image_create ( numcmpts , & cmptparm [ 0 ] , ( numcmpts == 1U ) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB ) ; if ( ! image ) { fclose ( IN ) ; free ( pData ) ; return NULL ; } if ( numcmpts == 4U ) { image -> comps [ 3 ] . alpha = 1 ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = image -> x0 + ( Info_h . biWidth - 1U ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1U ; image -> y1 = image -> y0 + ( Info_h . biHeight - 1U ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1U ; if ( Info_h . biBitCount == 24 && Info_h . biCompression == 0 ) { bmp24toimage ( pData , stride , image ) ; } else if ( Info_h . biBitCount == 8 && Info_h . biCompression == 0 ) { bmp8toimage ( pData , stride , image , pLUT ) ; } else if ( Info_h . biBitCount == 8 && Info_h . biCompression == 1 ) { bmp8toimage ( pData , stride , image , pLUT ) ; } else if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { bmp8toimage ( pData , stride , image , pLUT ) ; } else if ( Info_h . biBitCount == 32 && Info_h . biCompression == 0 ) { bmpmask32toimage ( pData , stride , image , 0x00FF0000U , 0x0000FF00U , 0x000000FFU , 0x00000000U ) ; } else if ( Info_h . biBitCount == 32 && Info_h . biCompression == 3 ) { bmpmask32toimage ( pData , stride , image , Info_h . biRedMask , Info_h . biGreenMask , Info_h . biBlueMask , Info_h . biAlphaMask ) ; } else if ( Info_h . biBitCount == 16 && Info_h . biCompression == 0 ) { bmpmask16toimage ( pData , stride , image , 0x7C00U , 0x03E0U , 0x001FU , 0x0000U ) ; } else if ( Info_h . biBitCount == 16 && Info_h . biCompression == 3 ) { if ( ( Info_h . biRedMask == 0U ) && ( Info_h . biGreenMask == 0U ) && ( Info_h . biBlueMask == 0U ) ) { Info_h . biRedMask = 0xF800U ; Info_h . biGreenMask = 0x07E0U ; Info_h . biBlueMask = 0x001FU ; } bmpmask16toimage ( pData , stride , image , Info_h . biRedMask , Info_h . biGreenMask , Info_h . biBlueMask , Info_h . biAlphaMask ) ; } else { opj_image_destroy ( image ) ; image = NULL ; fprintf ( stderr , ""Other<S2SV_blank>system<S2SV_blank>than<S2SV_blank>24<S2SV_blank>bits/pixels<S2SV_blank>or<S2SV_blank>8<S2SV_blank>bits<S2SV_blank>(no<S2SV_blank>RLE<S2SV_blank>coding)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>implemented<S2SV_blank>[%d]\\n"" , Info_h . biBitCount ) ; } free ( pData ) ; fclose ( IN ) ; return image ; }",; } } if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 2 ) { if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 4U ; } if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) { fclose ( IN ) ; return NULL ; }
628,"static int do_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags , pte_t orig_pte ) { pgoff_t pgoff = ( ( ( address & PAGE_MASK ) - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; <S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug> if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; if ( ! ( vma -> vm_flags & VM_SHARED ) ) return do_cow_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; return do_shared_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; }",( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
629,"<S2SV_StartBug> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <S2SV_EndBug> { struct nfs_inode * nfsi = NFS_I ( inode ) ; struct nfs_open_context * pos , * ctx = NULL ; spin_lock ( & inode -> i_lock ) ; list_for_each_entry ( pos , & nfsi -> open_files , list ) { if ( cred != NULL && pos -> cred != cred ) continue ; if ( ( pos -> mode & mode ) == mode ) { ctx = get_nfs_open_context ( pos ) ; break ; } } spin_unlock ( & inode -> i_lock ) ; return ctx ; }","* cred , fmode_t <S2SV_ModEnd> mode ) {"
630,"static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( ""scripting.html"" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }","-> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type =="
631,"static int ras_putdatastd ( jas_stream_t * out , ras_hdr_t * hdr , jas_image_t * image , int numcmpts , int * cmpts ) { int rowsize ; int pad ; unsigned int z ; int nz ; int c ; int x ; int y ; int v ; jas_matrix_t * data [ 3 ] ; int i ; <S2SV_StartBug> for ( i = 0 ; i < numcmpts ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } rowsize = RAS_ROWSIZE ( hdr ) ; pad = rowsize - ( hdr -> width * hdr -> depth + 7 ) / 8 ; hdr -> length = hdr -> height * rowsize ; for ( y = 0 ; y < hdr -> height ; y ++ ) { for ( i = 0 ; i < numcmpts ; ++ i ) { if ( jas_image_readcmpt ( image , cmpts [ i ] , 0 , y , jas_image_width ( image ) , 1 , data [ i ] ) ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } z = 0 ; nz = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { z <<= hdr -> depth ; if ( RAS_ISRGB ( hdr ) ) { v = RAS_RED ( ( jas_matrix_getv ( data [ 0 ] , x ) ) ) | RAS_GREEN ( ( jas_matrix_getv ( data [ 1 ] , x ) ) ) | RAS_BLUE ( ( jas_matrix_getv ( data [ 2 ] , x ) ) ) ; } else { v = ( jas_matrix_getv ( data [ 0 ] , x ) ) ; } z |= v & RAS_ONES ( hdr -> depth ) ; nz += hdr -> depth ; while ( nz >= 8 ) { c = ( z >> ( nz - 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> nz -= 8 ; <S2SV_EndBug> z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { return - 1 ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { return - 1 ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }","int i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> i ) { if ( ! ( <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize = <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> EOF ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
632,"static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , * header ; size_t cb1_len , cb2_len , alloc_len ; unsigned char * cb1 , * cb2 ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = json_array_string ( val , 5 ) ; nbit = json_array_string ( val , 6 ) ; ntime = json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( prev_hash ) free ( prev_hash ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; if ( bbversion ) free ( bbversion ) ; if ( nbit ) free ( nbit ) ; if ( ntime ) free ( ntime ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; free ( pool -> swork . prev_hash ) ; free ( pool -> swork . bbversion ) ; free ( pool -> swork . nbit ) ; free ( pool -> swork . ntime ) ; pool -> swork . job_id = job_id ; pool -> swork . prev_hash = prev_hash ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; pool -> swork . bbversion = bbversion ; pool -> swork . nbit = nbit ; pool -> swork . ntime = ntime ; pool -> swork . clean = clean ; alloc_len = pool -> swork . cb_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; pool -> nonce2_offset = cb1_len + pool -> n1_len ; for ( i = 0 ; i < pool -> swork . merkles ; i ++ ) free ( pool -> swork . merkle_bin [ i ] ) ; if ( merkles ) { pool -> swork . merkle_bin = ( unsigned char * * ) realloc ( pool -> swork . merkle_bin , sizeof ( char * ) * merkles + 1 ) ; for ( i = 0 ; i < merkles ; i ++ ) { char * merkle = json_array_string ( arr , i ) ; pool -> swork . merkle_bin [ i ] = ( unsigned char * ) malloc ( 32 ) ; if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>malloc<S2SV_blank>pool<S2SV_blank>swork<S2SV_blank>merkle_bin"" ) ; hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; free ( merkle ) ; } } pool -> swork . merkles = merkles ; if ( clean ) pool -> nonce2 = 0 ; pool -> merkle_offset = strlen ( pool -> swork . bbversion ) + strlen ( pool -> swork . prev_hash ) ; pool -> swork . header_len = pool -> merkle_offset + 32 + strlen ( pool -> swork . ntime ) + strlen ( pool -> swork . nbit ) + 8 + 96 ; pool -> merkle_offset /= 2 ; pool -> swork . header_len = pool -> swork . header_len * 2 + 1 ; align_len ( & pool -> swork . header_len ) ; header = ( char * ) alloca ( pool -> swork . header_len ) ; snprintf ( header , pool -> swork . header_len , ""%s%s%s%s%s%s%s"" , pool -> swork . bbversion , pool -> swork . prev_hash , blank_merkel , pool -> swork . ntime , pool -> swork . nbit , ""00000000"" , workpadding ) ; if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) ) <S2SV_StartBug> quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; <S2SV_EndBug> cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ; if ( unlikely ( ! cb1 ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>cb1<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; hex2bin ( cb1 , coinbase1 , cb1_len ) ; cb2 = ( unsigned char * ) calloc ( cb2_len , 1 ) ; if ( unlikely ( ! cb2 ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>cb2<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; hex2bin ( cb2 , coinbase2 , cb2_len ) ; free ( pool -> coinbase ) ; align_len ( & alloc_len ) ; pool -> coinbase = ( unsigned char * ) calloc ( alloc_len , 1 ) ; if ( unlikely ( ! pool -> coinbase ) ) quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool<S2SV_blank>coinbase<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; memcpy ( pool -> coinbase , cb1 , cb1_len ) ; memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; cg_wunlock ( & pool -> data_lock ) ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""job_id:<S2SV_blank>%s"" , job_id ) ; applog ( LOG_DEBUG , ""prev_hash:<S2SV_blank>%s"" , prev_hash ) ; applog ( LOG_DEBUG , ""coinbase1:<S2SV_blank>%s"" , coinbase1 ) ; applog ( LOG_DEBUG , ""coinbase2:<S2SV_blank>%s"" , coinbase2 ) ; applog ( LOG_DEBUG , ""bbversion:<S2SV_blank>%s"" , bbversion ) ; applog ( LOG_DEBUG , ""nbit:<S2SV_blank>%s"" , nbit ) ; applog ( LOG_DEBUG , ""ntime:<S2SV_blank>%s"" , ntime ) ; applog ( LOG_DEBUG , ""clean:<S2SV_blank>%s"" , clean ? ""yes"" : ""no"" ) ; } free ( coinbase1 ) ; free ( coinbase2 ) ; free ( cb1 ) ; free ( cb2 ) ; pool -> getwork_requested ++ ; total_getworks ++ ; ret = true ; if ( pool == current_pool ( ) ) opt_work_update = true ; out : return ret ; }",") ) ) { applog ( LOG_WARNING , ""%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s"" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> cb1 = ("
633,"int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }",| 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
634,"jp2_box_t * jp2_box_create ( int type ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> return 0 ; } <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> box -> type = type ; box -> len = 0 ; if ( ! ( boxinfo = jp2_boxinfolookup ( type ) ) ) { return 0 ; } box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; return box ; }",( box = jp2_box_create0 ( <S2SV_ModEnd> ) ) ) <S2SV_ModStart> 0 ; } <S2SV_ModEnd> box -> type
635,"static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) { unsigned int h , w , s , xcs , ycs , bps ; <S2SV_StartBug> int align ; <S2SV_EndBug> if ( ! buf_align ) buf_align = 1 ; if ( buf_align & ( buf_align - 1 ) ) goto fail ; if ( ! stride_align ) stride_align = 1 ; if ( stride_align & ( stride_align - 1 ) ) goto fail ; switch ( fmt ) { case VPX_IMG_FMT_RGB32 : case VPX_IMG_FMT_RGB32_LE : case VPX_IMG_FMT_ARGB : case VPX_IMG_FMT_ARGB_LE : bps = 32 ; break ; case VPX_IMG_FMT_RGB24 : case VPX_IMG_FMT_BGR24 : bps = 24 ; break ; case VPX_IMG_FMT_RGB565 : case VPX_IMG_FMT_RGB565_LE : case VPX_IMG_FMT_RGB555 : case VPX_IMG_FMT_RGB555_LE : case VPX_IMG_FMT_UYVY : case VPX_IMG_FMT_YUY2 : case VPX_IMG_FMT_YVYU : bps = 16 ; break ; case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : bps = 12 ; break ; <S2SV_StartBug> default : <S2SV_EndBug> bps = 16 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : <S2SV_StartBug> xcs = 1 ; <S2SV_EndBug> break ; default : xcs = 0 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : <S2SV_StartBug> case VPX_IMG_FMT_YV12 : <S2SV_EndBug> case VPX_IMG_FMT_VPXI420 : <S2SV_StartBug> case VPX_IMG_FMT_VPXYV12 : <S2SV_EndBug> ycs = 1 ; break ; default : ycs = 0 ; break ; } align = ( 1 << xcs ) - 1 ; w = ( d_w + align ) & ~ align ; align = ( 1 << ycs ) - 1 ; h = ( d_h + align ) & ~ align ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { <S2SV_StartBug> img -> img_data = img_buf_memalign ( buf_align , ( ( fmt & VPX_IMG_FMT_PLANAR ) ? <S2SV_EndBug> <S2SV_StartBug> h * s * bps / 8 : h * s ) ) ; <S2SV_EndBug> img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; <S2SV_StartBug> img -> fmt = fmt ; <S2SV_EndBug> img -> w = w ; img -> h = h ; img -> x_chroma_shift = xcs ; img -> y_chroma_shift = ycs ; img -> bps = bps ; <S2SV_StartBug> img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = s ; <S2SV_EndBug> <S2SV_StartBug> img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = s >> xcs ; <S2SV_EndBug> if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ; fail : vpx_img_free ( img ) ; return NULL ; }",", bps ; unsigned int stride_in_bytes ; <S2SV_ModStart> ; break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; <S2SV_ModStart> case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : <S2SV_ModStart> VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case <S2SV_ModStart> : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 <S2SV_ModStart> 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_ModStart> img_data ) { const uint64_t alloc_size = <S2SV_ModEnd> ( fmt & <S2SV_ModStart> VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) <S2SV_ModStart> / 8 : ( uint64_t ) <S2SV_ModStart> h * s ; if ( alloc_size != ( size_t ) alloc_size <S2SV_ModEnd> ) goto fail <S2SV_ModStart> ; img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 <S2SV_ModEnd> ; img -> <S2SV_ModStart> VPX_PLANE_ALPHA ] = stride_in_bytes <S2SV_ModEnd> ; img -> <S2SV_ModStart> VPX_PLANE_V ] = stride_in_bytes <S2SV_ModEnd> >> xcs ;"
636,"<S2SV_StartBug> static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out ) <S2SV_EndBug> { Resub scratch ; <S2SV_StartBug> int i ; <S2SV_EndBug> Rune c ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> switch ( pc -> opcode ) { case I_END : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case I_JUMP : pc = pc -> x ; break ; case I_SPLIT : scratch = * out ; <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) { <S2SV_EndBug> * out = scratch ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> } pc = pc -> y ; break ; case I_PLA : <S2SV_StartBug> if ( ! match ( pc -> x , sp , bol , flags , out ) ) <S2SV_EndBug> return 0 ; pc = pc -> y ; break ; case I_NLA : scratch = * out ; <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) <S2SV_EndBug> return 0 ; pc = pc -> y ; break ; case I_ANYNL : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_ANY : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( isnewline ( c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_CHAR : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) c = canon ( c ) ; if ( c != pc -> c ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_CCLASS : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) { if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( ! incclass ( pc -> cc , c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } pc = pc + 1 ; break ; case I_NCCLASS : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) { if ( incclasscanon ( pc -> cc , canon ( c ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( incclass ( pc -> cc , c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } pc = pc + 1 ; break ; case I_REF : i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ; if ( flags & REG_ICASE ) { if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( i > 0 ) sp += i ; pc = pc + 1 ; break ; case I_BOL : if ( sp == bol && ! ( flags & REG_NOTBOL ) ) { pc = pc + 1 ; break ; } if ( flags & REG_NEWLINE ) { if ( sp > bol && isnewline ( sp [ - 1 ] ) ) { pc = pc + 1 ; break ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> case I_EOL : if ( * sp == 0 ) { pc = pc + 1 ; break ; } if ( flags & REG_NEWLINE ) { if ( isnewline ( * sp ) ) { pc = pc + 1 ; break ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ; i ^= iswordchar ( sp [ 0 ] ) ; if ( ! i ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_NWORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ; i ^= iswordchar ( sp [ 0 ] ) ; if ( i ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_LPAR : out -> sub [ pc -> n ] . sp = sp ; pc = pc + 1 ; break ; case I_RPAR : out -> sub [ pc -> n ] . ep = sp ; pc = pc + 1 ; break ; default : <S2SV_StartBug> return 0 ; <S2SV_EndBug> } } }","Resub * out , int depth <S2SV_ModStart> scratch ; int result ; int <S2SV_ModStart> Rune c ; if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> I_END : return 0 <S2SV_ModEnd> ; case I_JUMP <S2SV_ModStart> * out ; result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> ) { * <S2SV_ModStart> scratch ; return 0 <S2SV_ModEnd> ; } pc <S2SV_ModStart> case I_PLA : result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> flags , out , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> * out ; result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> c ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } pc <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } pc <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> } } return 1 <S2SV_ModEnd> ; case I_EOL <S2SV_ModStart> } } return 1 <S2SV_ModEnd> ; case I_WORD <S2SV_ModStart> i ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> i ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> default : return 1 <S2SV_ModEnd> ; } }"
637,"static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != AF_UNSPEC ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = NULL ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ; <S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }","= other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;"
638,"int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) <S2SV_StartBug> return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; <S2SV_EndBug> buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { lua_pushvalue ( L , i ) ; mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }","0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."""
639,"const char * string_of_NPNVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPNVxDisplay ) ; _ ( NPNVxtAppContext ) ; _ ( NPNVnetscapeWindow ) ; _ ( NPNVjavascriptEnabledBool ) ; _ ( NPNVasdEnabledBool ) ; _ ( NPNVisOfflineBool ) ; _ ( NPNVserviceManager ) ; _ ( NPNVDOMElement ) ; _ ( NPNVDOMWindow ) ; _ ( NPNVToolkit ) ; _ ( NPNVSupportsXEmbedBool ) ; _ ( NPNVWindowNPObject ) ; _ ( NPNVPluginElementNPObject ) ; _ ( NPNVSupportsWindowless ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPNVserviceManager ) ; _ ( 11 , NPNVDOMElement ) ; _ ( 12 , NPNVDOMWindow ) ; _ ( 13 , NPNVToolkit ) ; # undef _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }",NPNVSupportsWindowless ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
640,"static int readContigTilesIntoBuffer ( TIFF * in , uint8 * buf , uint32 imagelength , uint32 imagewidth , uint32 tw , uint32 tl , tsample_t spp , uint16 bps ) { int status = 1 ; tsample_t sample = 0 ; tsample_t count = spp ; uint32 row , col , trow ; uint32 nrow , ncol ; uint32 dst_rowsize , shift_width ; uint32 bytes_per_sample , bytes_per_pixel ; uint32 trailing_bits , prev_trailing_bits ; uint32 tile_rowsize = TIFFTileRowSize ( in ) ; uint32 src_offset , dst_offset ; uint32 row_offset , col_offset ; uint8 * bufp = ( uint8 * ) buf ; unsigned char * src = NULL ; unsigned char * dst = NULL ; tsize_t tbytes = 0 , tile_buffsize = 0 ; tsize_t tilesize = TIFFTileSize ( in ) ; unsigned char * tilebuf = NULL ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( ( bps % 8 ) == 0 ) shift_width = 0 ; else { if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; } tile_buffsize = tilesize ; if ( tilesize == 0 || tile_rowsize == 0 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Tile<S2SV_blank>size<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero"" ) ; exit ( - 1 ) ; } if ( tilesize < ( tsize_t ) ( tl * tile_rowsize ) ) { # ifdef DEBUG2 TIFFError ( ""readContigTilesIntoBuffer"" , ""Tilesize<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>alternate<S2SV_blank>calculation<S2SV_blank>%u"" , tilesize , tl * tile_rowsize ) ; # endif tile_buffsize = tl * tile_rowsize ; if ( tl != ( tile_buffsize / tile_rowsize ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } } <S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> if ( tilebuf == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ; for ( row = 0 ; row < imagelength ; row += tl ) { nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; for ( col = 0 ; col < imagewidth ; col += tw ) { tbytes = TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) ; if ( tbytes < tilesize && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>row<S2SV_blank>%lu<S2SV_blank>col<S2SV_blank>%lu,<S2SV_blank>Read<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row , ( unsigned long ) tbytes , ( unsigned long ) tilesize ) ; status = 0 ; _TIFFfree ( tilebuf ) ; return status ; } row_offset = row * dst_rowsize ; col_offset = ( ( col * bps * spp ) + 7 ) / 8 ; bufp = buf + row_offset + col_offset ; if ( col + tw > imagewidth ) ncol = imagewidth - col ; else ncol = tw ; if ( ( ( bps % 8 ) == 0 ) && ( count == spp ) ) { for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; _TIFFmemcpy ( bufp , tilebuf + src_offset , ( ncol * spp * bps ) / 8 ) ; bufp += ( imagewidth * bps * spp ) / 8 ; } } else { prev_trailing_bits = trailing_bits = 0 ; trailing_bits = ( ncol * bps * spp ) % 8 ; for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; src = tilebuf + src_offset ; dst_offset = ( row + trow ) * dst_rowsize ; dst = buf + dst_offset + col_offset ; switch ( shift_width ) { case 0 : if ( extractContigSamplesBytes ( src , dst , ncol , sample , spp , bps , count , 0 , ncol ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 1 : if ( bps == 1 ) { if ( extractContigSamplesShifted8bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; } else if ( extractContigSamplesShifted16bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 2 : if ( extractContigSamplesShifted24bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 3 : case 4 : case 5 : if ( extractContigSamplesShifted32bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; default : TIFFError ( ""readContigTilesIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return 1 ; } } prev_trailing_bits += trailing_bits ; } } } _TIFFfree ( tilebuf ) ; return status ; }","; } } if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } <S2SV_ModStart> _TIFFmalloc ( tile_buffsize + 3 <S2SV_ModStart> 0 ) return 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] ="
641,"TEE_Result syscall_asymm_verify ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * data , size_t data_len , const void * sig , size_t sig_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; struct tee_obj * o ; size_t hash_size ; int salt_len = 0 ; TEE_Attribute * params = NULL ; uint32_t hash_algo ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; if ( cs -> mode != TEE_MODE_VERIFY ) return TEE_ERROR_BAD_PARAMETERS ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) data , data_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) sig , sig_len ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) ) { case TEE_MAIN_ALGO_RSA : if ( cs -> algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len != hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , hash_size ) ; } res = crypto_acipher_rsassa_verify ( cs -> algo , o -> attr , salt_len , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_DSA : hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len > hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } res = crypto_acipher_dsa_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_ECDSA : res = crypto_acipher_ecc_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; default : res = TEE_ERROR_NOT_SUPPORTED ; } out : free ( params ) ; return res ; }","return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if"
642,"static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }","= 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; }"
643,"static int PredictorDecodeRow ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decoderow != NULL ) ; assert ( sp -> decodepfunc != NULL ) ; if ( ( * sp -> decoderow ) ( tif , op0 , occ0 , s ) ) { <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> } else return 0 ; }",) ) { return <S2SV_ModStart> occ0 ) ; <S2SV_ModEnd> } else return
644,"static int _c2s_sx_sasl_callback ( int cb , void * arg , void * * res , sx_t s , void * cbarg ) { c2s_t c2s = ( c2s_t ) cbarg ; const char * my_realm , * mech ; sx_sasl_creds_t creds ; static char buf [ 3072 ] ; char mechbuf [ 256 ] ; struct jid_st jid ; jid_static_buf jid_buf ; int i , r ; sess_t sess ; char skey [ 44 ] ; host_t host ; jid_static ( & jid , & jid_buf ) ; assert ( s != NULL ) ; sprintf ( skey , ""%d"" , s -> tag ) ; sess = xhash_get ( c2s -> sessions , skey ) ; switch ( cb ) { case sx_sasl_cb_GET_REALM : if ( s -> req_to == NULL ) my_realm = """" ; else { host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_ERR , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; * res = ( void * ) NULL ; return sx_sasl_ret_FAIL ; } my_realm = host -> realm ; if ( my_realm == NULL ) my_realm = s -> req_to ; } strncpy ( buf , my_realm , 256 ) ; * res = ( void * ) buf ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>realm:<S2SV_blank>realm<S2SV_blank>is<S2SV_blank>\'%s\'"" , buf ) ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_GET_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> get_password && ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) == 0 ) { * res = buf ; return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_CHECK_PASS : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)"" , creds -> authnid , creds -> realm ) ; if ( sess -> host -> ar -> check_password != NULL ) { if ( ( sess -> host -> ar -> check_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , ( char * ) creds -> pass ) == 0 ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; } if ( sess -> host -> ar -> get_password != NULL ) { if ( ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : """" , buf ) != 0 ) return sx_sasl_ret_FAIL ; if ( strcmp ( creds -> pass , buf ) == 0 ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; break ; case sx_sasl_cb_CHECK_AUTHZID : assert ( sess != NULL ) ; creds = ( sx_sasl_creds_t ) arg ; if ( creds -> authzid == NULL || creds -> authzid [ 0 ] == '\\0' ) return sx_sasl_ret_FAIL ; if ( jid_reset ( & jid , creds -> authzid , - 1 ) == NULL ) return sx_sasl_ret_FAIL ; if ( ! s -> req_to || ( strcmp ( jid . domain , s -> req_to ) != 0 ) ) return sx_sasl_ret_FAIL ; if ( jid . resource [ 0 ] != '\\0' ) return sx_sasl_ret_FAIL ; if ( sess -> host -> ar -> user_authz_allowed ) { if ( sess -> host -> ar -> user_authz_allowed ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( char * ) creds -> realm , ( char * ) creds -> authzid ) ) return sx_sasl_ret_OK ; } else { if ( strcmp ( creds -> authnid , jid . node ) == 0 && ( sess -> host -> ar -> user_exists ) ( sess -> host -> ar , sess , jid . node , jid . domain ) ) return sx_sasl_ret_OK ; } return sx_sasl_ret_FAIL ; case sx_sasl_cb_GEN_AUTHZID : jid_reset ( & jid , s -> req_to , - 1 ) ; jid_random_part ( & jid , jid_NODE ) ; strcpy ( buf , jid . node ) ; * res = ( void * ) buf ; return sx_sasl_ret_OK ; break ; case sx_sasl_cb_CHECK_MECH : mech = ( char * ) arg ; strncpy ( mechbuf , mech , sizeof ( mechbuf ) ) ; mechbuf [ sizeof ( mechbuf ) - 1 ] = '\\0' ; <S2SV_StartBug> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; <S2SV_EndBug> host = xhash_get ( c2s -> hosts , s -> req_to ) ; if ( host == NULL ) { log_write ( c2s -> log , LOG_WARNING , ""SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s"" , s -> req_to ) ; return sx_sasl_ret_FAIL ; } if ( strcmp ( mechbuf , ""digest-md5"" ) == 0 ) { if ( host -> ar -> get_password == NULL ) return sx_sasl_ret_FAIL ; } else if ( strcmp ( mechbuf , ""plain"" ) == 0 ) { if ( host -> ar -> get_password == NULL && host -> ar -> check_password == NULL ) return sx_sasl_ret_FAIL ; } if ( s -> ssf > 0 ) { r = snprintf ( buf , sizeof ( buf ) , ""authreg.ssl-mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; } r = snprintf ( buf , sizeof ( buf ) , ""authreg.mechanisms.sasl.%s"" , mechbuf ) ; if ( r < - 1 || r > sizeof ( buf ) ) return sx_sasl_ret_FAIL ; if ( config_get ( c2s -> config , buf ) != NULL ) return sx_sasl_ret_OK ; else return sx_sasl_ret_FAIL ; default : break ; } return sx_sasl_ret_FAIL ; }","[ i ] ) ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf"
645,"<S2SV_StartBug> static int jas_iccputsint ( jas_stream_t * out , int n , longlong val ) <S2SV_EndBug> { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ; return jas_iccputuint ( out , n , tmp ) ; }","int n , jas_longlong <S2SV_ModEnd> val ) { <S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; tmp"
646,"static ssize_t _hostsock_recvmsg ( oe_fd_t * sock_ , struct oe_msghdr * msg , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_StartBug> { <S2SV_EndBug> if ( oe_syscall_recvmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , <S2SV_StartBug> & msg -> msg_namelen , <S2SV_EndBug> buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , <S2SV_StartBug> & msg -> msg_controllen , <S2SV_EndBug> flags ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret == - 1 ) OE_RAISE_ERRNO ( oe_errno ) ; } <S2SV_StartBug> if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","; size_t buf_size = 0 ; size_t data_size = 0 ; oe_socklen_t namelen_out = 0 ; size_t controllen_out <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_ModStart> msg_namelen , & namelen_out <S2SV_ModEnd> , buf , <S2SV_ModStart> msg_controllen , & controllen_out <S2SV_ModEnd> , flags ) <S2SV_ModStart> } if ( ! msg -> msg_name ) msg -> msg_namelen = 0 ; else { if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ; } if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ; else { if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ; else msg -> msg_flags |= OE_MSG_CTRUNC ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ("
647,"static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { <S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }",port ) { <S2SV_ModEnd> return usb_serial_generic_open (
648,"int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; } <S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> } <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> err = handle -> h_err ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }",0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err ? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =
649,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
650,"l_int32 gplotMakeOutput ( GPLOT * gplot ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * cmdname ; l_int32 ignore ; PROCNAME ( ""gplotMakeOutput"" ) ; if ( ! gplot ) return ERROR_INT ( ""gplot<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; gplotGenCommandFile ( gplot ) ; gplotGenDataFiles ( gplot ) ; cmdname = genPathname ( gplot -> cmdname , NULL ) ; # ifndef _WIN32 <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> # else <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> # endif # ifndef OS_IOS ignore = system ( buf ) ; # endif LEPT_FREE ( cmdname ) ; return 0 ; }","char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""gnuplot<S2SV_blank>%s"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""wgnuplot<S2SV_blank>%s"" ,"
651,"int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= TS_USEDFPU ; } return fpu_emulate ( inst , fpu , regs ) ; }","PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,"
652,"krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; <S2SV_StartBug> char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; <S2SV_EndBug> char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone = FALSE ; <S2SV_StartBug> krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; <S2SV_EndBug> char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>found"" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_wrapmsg ( context , ost , st , _ ( ""\'%s\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { <S2SV_StartBug> int dnlen = 0 , subtreelen = 0 ; <S2SV_EndBug> char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { ""krbticketpolicyreference"" , ""krbprincipalname"" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY || entry -> mask & KADM5_KEY_HIST ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } } if ( entry -> mask & KADM5_POLICY ) { if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_HIST ) { bersecretkey = krb5_encode_histkey ( & princ_ent ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbpwdhistory"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; free_berdata ( bersecretkey ) ; bersecretkey = NULL ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone ) { st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastPwdChange"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } st = update_ldap_mod_auth_ind ( context , entry , & mods ) ; if ( st != 0 ) goto cleanup ; if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbExtraData"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } free_berdata ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastAdminUnlock"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , ""objectclass"" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( ""ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>"" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbObjectReferences"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = ""krbprincipal"" ; strval [ 1 ] = ""krbprincipalaux"" ; strval [ 2 ] = ""krbTicketPolicyAux"" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { ""krbprincipalaux"" , ""krbTicketPolicyAux"" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , ""objectclass"" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }","NULL ; char <S2SV_ModEnd> * strval [ <S2SV_ModStart> FALSE ; krb5_boolean <S2SV_ModEnd> establish_links = FALSE <S2SV_ModStart> TRUE ) { if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> ntrees ) ; <S2SV_ModStart> ( st ) <S2SV_ModEnd> goto cleanup ;"
653,"int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> return 0 ; if ( error == 0 ) acl = NULL ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }","{ error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode"
654,"static int read_private_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; const sc_acl_entry_t * e ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( ""I0012"" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n"" , sc_strerror ( r ) ) ; return 2 ; } e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL || e -> method == SC_AC_NEVER ) return 10 ; <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n"" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( ""Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\n"" , opt_key_num ) ; return 2 ; } return parse_private_key ( p , keysize , rsa ) ; }","; bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )"
655,"static inline void handle_socket_receive_unknown ( fastd_socket_t * sock , const fastd_peer_address_t * local_addr , const fastd_peer_address_t * remote_addr , fastd_buffer_t * buffer ) { const uint8_t * packet_type = buffer -> data ; switch ( * packet_type ) { case PACKET_DATA : fastd_buffer_free ( buffer ) ; if ( ! backoff_unknown ( remote_addr ) ) { pr_debug ( ""unexpectedly<S2SV_blank>received<S2SV_blank>payload<S2SV_blank>data<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I"" , remote_addr ) ; conf . protocol -> handshake_init ( sock , local_addr , remote_addr , NULL ) ; } break ; case PACKET_HANDSHAKE : fastd_handshake_handle ( sock , local_addr , remote_addr , NULL , buffer ) ; <S2SV_StartBug> } <S2SV_EndBug> }","buffer ) ; break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I"" , remote_addr ) ;"
656,<S2SV_StartBug> static LAYER_CONTEXT * get_layer_context ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> return svc -> number_temporal_layers > 1 ? <S2SV_EndBug> & svc -> layer_context [ svc -> temporal_layer_id ] : <S2SV_StartBug> & svc -> layer_context [ svc -> spatial_layer_id ] ; <S2SV_EndBug> },* get_layer_context ( VP9_COMP * const cpi ) { if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ; else return ( cpi -> svc . <S2SV_ModEnd> number_temporal_layers > 1 <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> temporal_layer_id ] : <S2SV_ModStart> ] : & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> spatial_layer_id ] ;
657,"<S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; } <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug> spin_unlock ( & unix_gc_lock ) ; }","void unix_inflight ( struct user_struct * user , <S2SV_ModStart> ++ ; } <S2SV_ModEnd> user -> unix_inflight"
658,"static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , ""RSDS"" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>read<S2SV_blank>PE<S2SV_blank>debug<S2SV_blank>info\\n"" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , ""%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x"" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; rsds_hdr . free ( ( struct SCV_RSDS_HEADER * ) & rsds_hdr ) ; } else if ( strncmp ( ( const char * ) dbg_data , ""NB10"" , 4 ) == 0 ) { <S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( dbg_data , & nb10_hdr ) ; snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , <S2SV_StartBug> ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> strncpy ( res -> file_name , ( const char * ) <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug> res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; nb10_hdr . free ( ( struct SCV_NB10_HEADER * ) & nb10_hdr ) ; } else { bprintf ( ""CodeView<S2SV_blank>section<S2SV_blank>not<S2SV_blank>NB10<S2SV_blank>or<S2SV_blank>RSDS\\n"" ) ; return 0 ; } break ; default : return 0 ; } while ( i < 33 ) { res -> guidstr [ i ] = toupper ( ( int ) res -> guidstr [ i ] ) ; i ++ ; } return 1 ; }","0 ) { if ( dbg_data_len < 20 ) { eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n"" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> ; init_cv_nb10_header ( <S2SV_ModStart> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> 1 ) ; }"
659,"void init_directory_config ( directory_config * dcfg ) { if ( dcfg == NULL ) return ; if ( dcfg -> is_enabled == NOT_SET ) dcfg -> is_enabled = 0 ; if ( dcfg -> reqbody_access == NOT_SET ) dcfg -> reqbody_access = 0 ; if ( dcfg -> reqintercept_oe == NOT_SET ) dcfg -> reqintercept_oe = 0 ; if ( dcfg -> reqbody_buffering == NOT_SET ) dcfg -> reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF ; if ( dcfg -> reqbody_inmemory_limit == NOT_SET ) dcfg -> reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT ; if ( dcfg -> reqbody_limit == NOT_SET ) dcfg -> reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT ; if ( dcfg -> reqbody_no_files_limit == NOT_SET ) dcfg -> reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT ; if ( dcfg -> resbody_access == NOT_SET ) dcfg -> resbody_access = 0 ; if ( dcfg -> of_limit == NOT_SET ) dcfg -> of_limit = RESPONSE_BODY_DEFAULT_LIMIT ; if ( dcfg -> if_limit_action == NOT_SET ) dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT ; if ( dcfg -> of_limit_action == NOT_SET ) dcfg -> of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT ; if ( dcfg -> of_mime_types == NOT_SET_P ) { dcfg -> of_mime_types = apr_table_make ( dcfg -> mp , 3 ) ; if ( dcfg -> of_mime_types_cleared != 1 ) { apr_table_setn ( dcfg -> of_mime_types , ""text/plain"" , ""1"" ) ; apr_table_setn ( dcfg -> of_mime_types , ""text/html"" , ""1"" ) ; } } if ( dcfg -> debuglog_fd == NOT_SET_P ) dcfg -> debuglog_fd = NULL ; if ( dcfg -> debuglog_name == NOT_SET_P ) dcfg -> debuglog_name = NULL ; if ( dcfg -> debuglog_level == NOT_SET ) dcfg -> debuglog_level = 0 ; if ( dcfg -> cookie_format == NOT_SET ) dcfg -> cookie_format = 0 ; if ( dcfg -> argument_separator == NOT_SET ) dcfg -> argument_separator = '&' ; if ( dcfg -> cookiev0_separator == NOT_SET_P ) dcfg -> cookiev0_separator = NULL ; if ( dcfg -> rule_inheritance == NOT_SET ) dcfg -> rule_inheritance = 1 ; if ( dcfg -> auditlog_flag == NOT_SET ) dcfg -> auditlog_flag = 0 ; if ( dcfg -> auditlog_type == NOT_SET ) dcfg -> auditlog_type = AUDITLOG_SERIAL ; if ( dcfg -> max_rule_time == NOT_SET ) dcfg -> max_rule_time = 0 ; if ( dcfg -> auditlog_dirperms == NOT_SET ) dcfg -> auditlog_dirperms = CREATEMODE_DIR ; if ( dcfg -> auditlog_fileperms == NOT_SET ) dcfg -> auditlog_fileperms = CREATEMODE ; if ( dcfg -> auditlog_fd == NOT_SET_P ) dcfg -> auditlog_fd = NULL ; if ( dcfg -> auditlog2_fd == NOT_SET_P ) dcfg -> auditlog2_fd = NULL ; if ( dcfg -> auditlog_name == NOT_SET_P ) dcfg -> auditlog_name = NULL ; if ( dcfg -> auditlog2_name == NOT_SET_P ) dcfg -> auditlog2_name = NULL ; if ( dcfg -> auditlog_storage_dir == NOT_SET_P ) dcfg -> auditlog_storage_dir = NULL ; if ( dcfg -> auditlog_parts == NOT_SET_P ) dcfg -> auditlog_parts = ""ABCFHZ"" ; if ( dcfg -> auditlog_relevant_regex == NOT_SET_P ) dcfg -> auditlog_relevant_regex = NULL ; if ( dcfg -> tmp_dir == NOT_SET_P ) dcfg -> tmp_dir = guess_tmp_dir ( dcfg -> mp ) ; if ( dcfg -> upload_dir == NOT_SET_P ) dcfg -> upload_dir = NULL ; if ( dcfg -> upload_keep_files == NOT_SET ) dcfg -> upload_keep_files = KEEP_FILES_OFF ; if ( dcfg -> upload_validates_files == NOT_SET ) dcfg -> upload_validates_files = 0 ; if ( dcfg -> upload_filemode == NOT_SET ) dcfg -> upload_filemode = 0600 ; if ( dcfg -> upload_file_limit == NOT_SET ) dcfg -> upload_file_limit = 100 ; if ( dcfg -> data_dir == NOT_SET_P ) dcfg -> data_dir = NULL ; if ( dcfg -> webappid == NOT_SET_P ) dcfg -> webappid = ""default"" ; if ( dcfg -> sensor_id == NOT_SET_P ) dcfg -> sensor_id = ""default"" ; if ( dcfg -> httpBlkey == NOT_SET_P ) dcfg -> httpBlkey = NULL ; if ( dcfg -> content_injection_enabled == NOT_SET ) dcfg -> content_injection_enabled = 0 ; if ( dcfg -> stream_inbody_inspection == NOT_SET ) dcfg -> stream_inbody_inspection = 0 ; if ( dcfg -> stream_outbody_inspection == NOT_SET ) dcfg -> stream_outbody_inspection = 0 ; if ( dcfg -> geo == NOT_SET_P ) dcfg -> geo = NULL ; if ( dcfg -> gsb == NOT_SET_P ) dcfg -> gsb = NULL ; if ( dcfg -> u_map == NOT_SET_P ) dcfg -> u_map = NULL ; if ( dcfg -> cache_trans == NOT_SET ) dcfg -> cache_trans = MODSEC_CACHE_DISABLED ; if ( dcfg -> cache_trans_incremental == NOT_SET ) dcfg -> cache_trans_incremental = 0 ; if ( dcfg -> cache_trans_min == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_min = 32 ; if ( dcfg -> cache_trans_max == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_max = 1024 ; if ( dcfg -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_maxitems = 512 ; if ( dcfg -> request_encoding == NOT_SET_P ) dcfg -> request_encoding = NULL ; if ( dcfg -> disable_backend_compression == NOT_SET ) dcfg -> disable_backend_compression = 0 ; if ( dcfg -> col_timeout == NOT_SET ) dcfg -> col_timeout = 3600 ; if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ; if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ; if ( dcfg -> crypto_key_add == NOT_SET ) dcfg -> crypto_key_add = HASH_KEYONLY ; if ( dcfg -> crypto_param_name == NOT_SET_P ) dcfg -> crypto_param_name = ""crypt"" ; if ( dcfg -> hash_is_enabled == NOT_SET ) dcfg -> hash_is_enabled = HASH_DISABLED ; if ( dcfg -> hash_enforcement == NOT_SET ) dcfg -> hash_enforcement = HASH_DISABLED ; if ( dcfg -> crypto_hash_href_rx == NOT_SET ) dcfg -> crypto_hash_href_rx = 0 ; if ( dcfg -> crypto_hash_faction_rx == NOT_SET ) dcfg -> crypto_hash_faction_rx = 0 ; if ( dcfg -> crypto_hash_location_rx == NOT_SET ) dcfg -> crypto_hash_location_rx = 0 ; if ( dcfg -> crypto_hash_iframesrc_rx == NOT_SET ) dcfg -> crypto_hash_iframesrc_rx = 0 ; if ( dcfg -> crypto_hash_framesrc_rx == NOT_SET ) dcfg -> crypto_hash_framesrc_rx = 0 ; if ( dcfg -> crypto_hash_href_pm == NOT_SET ) dcfg -> crypto_hash_href_pm = 0 ; if ( dcfg -> crypto_hash_faction_pm == NOT_SET ) dcfg -> crypto_hash_faction_pm = 0 ; if ( dcfg -> crypto_hash_location_pm == NOT_SET ) dcfg -> crypto_hash_location_pm = 0 ; if ( dcfg -> crypto_hash_iframesrc_pm == NOT_SET ) dcfg -> crypto_hash_iframesrc_pm = 0 ; if ( dcfg -> crypto_hash_framesrc_pm == NOT_SET ) dcfg -> crypto_hash_framesrc_pm = 0 ; <S2SV_StartBug> } <S2SV_EndBug>",= 0 ; if ( dcfg -> xml_external_entity == NOT_SET ) dcfg -> xml_external_entity = 0 ;
660,"void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"""
661,"Datum lquery_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; char * ptr ; int num = 0 , totallen = 0 , numOR = 0 ; int state = LQPRS_WAITLEVEL ; lquery * result ; nodeitem * lptr = NULL ; lquery_level * cur , * curqlevel , * tmpql ; lquery_variant * lrptr = NULL ; bool hasnot = false ; bool wasbad = false ; int charlen ; int pos = 0 ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( charlen == 1 ) { if ( t_iseq ( ptr , '.' ) ) num ++ ; else if ( t_iseq ( ptr , '|' ) ) numOR ++ ; } ptr += charlen ; } <S2SV_StartBug> num ++ ; <S2SV_EndBug> curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( state == LQPRS_WAITLEVEL ) { if ( ISALNUM ( ptr ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; } else if ( charlen == 1 && t_iseq ( ptr , '!' ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr + 1 ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; curqlevel -> flag |= LQL_NOT ; hasnot = true ; } else if ( charlen == 1 && t_iseq ( ptr , '*' ) ) state = LQPRS_WAITOPEN ; else UNCHAR ; } else if ( state == LQPRS_WAITVAR ) { if ( ISALNUM ( ptr ) ) { lptr ++ ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar ++ ; } else UNCHAR ; } else if ( state == LQPRS_WAITDELIM ) { if ( charlen == 1 && t_iseq ( ptr , '@' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_INCASE ; curqlevel -> flag |= LVAR_INCASE ; } else if ( charlen == 1 && t_iseq ( ptr , '*' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_ANYEND ; curqlevel -> flag |= LVAR_ANYEND ; } else if ( charlen == 1 && t_iseq ( ptr , '%' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_SUBLEXEME ; curqlevel -> flag |= LVAR_SUBLEXEME ; } else if ( charlen == 1 && t_iseq ( ptr , '|' ) ) { lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; state = LQPRS_WAITVAR ; } else if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; state = LQPRS_WAITLEVEL ; curqlevel = NEXTLEV ( curqlevel ) ; } else if ( ISALNUM ( ptr ) ) { if ( lptr -> flag ) UNCHAR ; } else UNCHAR ; } else if ( state == LQPRS_WAITOPEN ) { if ( charlen == 1 && t_iseq ( ptr , '{' ) ) state = LQPRS_WAITFNUM ; else if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { curqlevel -> low = 0 ; curqlevel -> high = 0xffff ; curqlevel = NEXTLEV ( curqlevel ) ; state = LQPRS_WAITLEVEL ; } else UNCHAR ; } else if ( state == LQPRS_WAITFNUM ) { if ( charlen == 1 && t_iseq ( ptr , ',' ) ) state = LQPRS_WAITSNUM ; else if ( t_isdigit ( ptr ) ) { curqlevel -> low = atoi ( ptr ) ; state = LQPRS_WAITND ; } else UNCHAR ; } else if ( state == LQPRS_WAITSNUM ) { if ( t_isdigit ( ptr ) ) { curqlevel -> high = atoi ( ptr ) ; state = LQPRS_WAITCLOSE ; } else if ( charlen == 1 && t_iseq ( ptr , '}' ) ) { curqlevel -> high = 0xffff ; state = LQPRS_WAITEND ; } else UNCHAR ; } else if ( state == LQPRS_WAITCLOSE ) { if ( charlen == 1 && t_iseq ( ptr , '}' ) ) state = LQPRS_WAITEND ; else if ( ! t_isdigit ( ptr ) ) UNCHAR ; } else if ( state == LQPRS_WAITND ) { if ( charlen == 1 && t_iseq ( ptr , '}' ) ) { curqlevel -> high = curqlevel -> low ; state = LQPRS_WAITEND ; } else if ( charlen == 1 && t_iseq ( ptr , ',' ) ) state = LQPRS_WAITSNUM ; else if ( ! t_isdigit ( ptr ) ) UNCHAR ; } else if ( state == LQPRS_WAITEND ) { if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { state = LQPRS_WAITLEVEL ; curqlevel = NEXTLEV ( curqlevel ) ; } else UNCHAR ; } else elog ( ERROR , ""internal<S2SV_blank>error<S2SV_blank>in<S2SV_blank>parser"" ) ; ptr += charlen ; if ( state == LQPRS_WAITDELIM ) lptr -> wlen ++ ; pos ++ ; } if ( state == LQPRS_WAITDELIM ) { if ( lptr -> start == ptr ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> len == 0 ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; } else if ( state == LQPRS_WAITOPEN ) curqlevel -> high = 0xffff ; else if ( state != LQPRS_WAITEND ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; curqlevel = tmpql ; totallen = LQUERY_HDRSIZE ; while ( ( char * ) curqlevel - ( char * ) tmpql < num * ITEMSIZE ) { totallen += LQL_HDRSIZE ; if ( curqlevel -> numvar ) { lptr = GETVAR ( curqlevel ) ; while ( lptr - GETVAR ( curqlevel ) < curqlevel -> numvar ) { totallen += MAXALIGN ( LVAR_HDRSIZE + lptr -> len ) ; lptr ++ ; } } else if ( curqlevel -> low > curqlevel -> high ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Low<S2SV_blank>limit(%d)<S2SV_blank>is<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>upper(%d)."" , curqlevel -> low , curqlevel -> high ) ) ) ; curqlevel = NEXTLEV ( curqlevel ) ; } result = ( lquery * ) palloc0 ( totallen ) ; SET_VARSIZE ( result , totallen ) ; result -> numlevel = num ; result -> firstgood = 0 ; result -> flag = 0 ; if ( hasnot ) result -> flag |= LQUERY_HASNOT ; cur = LQUERY_FIRST ( result ) ; curqlevel = tmpql ; while ( ( char * ) curqlevel - ( char * ) tmpql < num * ITEMSIZE ) { memcpy ( cur , curqlevel , LQL_HDRSIZE ) ; cur -> totallen = LQL_HDRSIZE ; if ( curqlevel -> numvar ) { lrptr = LQL_FIRST ( cur ) ; lptr = GETVAR ( curqlevel ) ; while ( lptr - GETVAR ( curqlevel ) < curqlevel -> numvar ) { cur -> totallen += MAXALIGN ( LVAR_HDRSIZE + lptr -> len ) ; lrptr -> len = lptr -> len ; lrptr -> flag = lptr -> flag ; lrptr -> val = ltree_crc32_sz ( lptr -> start , lptr -> len ) ; memcpy ( lrptr -> name , lptr -> start , lptr -> len ) ; lptr ++ ; lrptr = LVAR_NEXT ( lrptr ) ; } pfree ( GETVAR ( curqlevel ) ) ; if ( cur -> numvar > 1 || cur -> flag != 0 ) wasbad = true ; else if ( wasbad == false ) ( result -> firstgood ) ++ ; } else wasbad = true ; curqlevel = NEXTLEV ( curqlevel ) ; cur = LQL_NEXT ( cur ) ; } pfree ( tmpql ) ; PG_RETURN_POINTER ( result ) ; }","} num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) )"
662,"u_int mfr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int tlen , idx , hdr_len = 0 ; uint16_t sequence_num ; uint8_t ie_type , ie_len ; const uint8_t * tptr ; ND_TCHECK2 ( * p , 4 ) ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) , tok2str ( mfr_ctrl_msg_values , ""Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)"" , p [ 2 ] ) , length ) ) ; tptr = p + 3 ; tlen = length - 3 ; hdr_len = 3 ; if ( ! ndo -> ndo_vflag ) return hdr_len ; while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; ie_type = tptr [ 0 ] ; ie_len = tptr [ 1 ] ; ND_PRINT ( ( ndo , ""\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>"" , tok2str ( mfr_ctrl_ie_values , ""Unknown"" , ie_type ) , ie_type , ie_len ) ) ; if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) return hdr_len ; ND_TCHECK2 ( * tptr , ie_len ) ; tptr += sizeof ( struct ie_tlv_header_t ) ; ie_len -= sizeof ( struct ie_tlv_header_t ) ; tlen -= sizeof ( struct ie_tlv_header_t ) ; switch ( ie_type ) { <S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case MFR_CTRL_IE_BUNDLE_ID : case MFR_CTRL_IE_LINK_ID : for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { if ( * ( tptr + idx ) != 0 ) safeputchar ( ndo , * ( tptr + idx ) ) ; else break ; } break ; case MFR_CTRL_IE_TIMESTAMP : if ( ie_len == sizeof ( struct timeval ) ) { ts_print ( ndo , ( const struct timeval * ) tptr ) ; break ; } case MFR_CTRL_IE_VENDOR_EXT : case MFR_CTRL_IE_CAUSE : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ie_len ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ie_len ) ; tlen -= ie_len ; tptr += ie_len ; } return hdr_len ; } sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>"" , sequence_num , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; hdr_len = 2 ; fr_print ( ndo , p + hdr_len , length - hdr_len ) ; return hdr_len ; } ND_PRINT ( ( ndo , ""FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" , sequence_num , bittok2str ( frf_flag_values , ""none"" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; print_unknown_data ( ndo , p , ""\\n\\t"" , length ) ; return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|mfr]"" ) ) ; return length ; }","case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>length)"" ) ) ; break ; }"
663,"static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""USBMS"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , ""USB<S2SV_blank>Mass<S2SV_blank>Storage"" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWDataTransferLength , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; datalen = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWFlags , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTarget , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_ms_dCBWLUN , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; lun = tvb_get_guint8 ( tvb , offset ) & 0x0f ; offset += 1 ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , lun ) ; if ( ! itl ) { itl = wmem_new ( wmem_file_scope ( ) , itl_nexus_t ) ; itl -> cmdset = 0xff ; itl -> conversation = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itl , lun , itl ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { itlq = wmem_new ( wmem_file_scope ( ) , itlq_nexus_t ) ; itlq -> lun = lun ; itlq -> scsi_opcode = 0xffff ; itlq -> task_flags = 0 ; if ( datalen ) { if ( flags & 0x80 ) { itlq -> task_flags |= SCSI_DATA_READ ; } else { itlq -> task_flags |= SCSI_DATA_WRITE ; } } itlq -> data_length = datalen ; itlq -> bidir_data_length = 0 ; itlq -> fc_time = pinfo -> abs_ts ; itlq -> first_exchange_frame = pinfo -> num ; itlq -> last_exchange_frame = 0 ; itlq -> flags = 0 ; itlq -> alloc_len = 0 ; itlq -> extra_data = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itlq , pinfo -> num , itlq ) ; } proto_tree_add_item ( tree , hf_usb_ms_dCBWCBLength , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; cdbrlen = tvb_get_guint8 ( tvb , offset ) & 0x1f ; offset += 1 ; cdblen = cdbrlen ; if ( cdblen > tvb_captured_length_remaining ( tvb , offset ) ) { cdblen = tvb_captured_length_remaining ( tvb , offset ) ; } if ( cdblen ) { cdb_tvb = tvb_new_subset ( tvb , offset , cdblen , cdbrlen ) ; dissect_scsi_cdb ( cdb_tvb , pinfo , parent_tree , SCSI_DEV_UNKNOWN , itlq , itl ) ; } return tvb_captured_length ( tvb ) ; } if ( ( ! is_request ) && ( signature == 0x53425355 ) && ( tvb_reported_length ( tvb ) == 13 ) ) { guint8 status ; proto_tree_add_item ( tree , hf_usb_ms_dCSWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWDataResidue , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWStatus , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; status = tvb_get_guint8 ( tvb , offset ) ; itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itlq -> last_exchange_frame = pinfo -> num ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } if ( ! status ) { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0 ) ; } else { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0x02 ) ; } return tvb_captured_length ( tvb ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } dissect_scsi_payload ( tvb , pinfo , parent_tree , is_request , itlq , itl , 0 ) ; return tvb_captured_length ( tvb ) ; }",= usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
664,static int i8042_start ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> return 0 ; },-> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return
665,"void nsexec ( void ) { int pipenum ; jmp_buf env ; int sync_child_pipe [ 2 ] , sync_grandchild_pipe [ 2 ] ; struct nlconfig_t config = { 0 } ; pipenum = initpipe ( ) ; if ( pipenum == - 1 ) return ; <S2SV_StartBug> nl_parse ( pipenum , & config ) ; <S2SV_EndBug> update_oom_score_adj ( config . oom_score_adj , config . oom_score_adj_len ) ; if ( config . namespaces ) { if ( prctl ( PR_SET_DUMPABLE , 0 , 0 , 0 , 0 ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>process<S2SV_blank>as<S2SV_blank>non-dumpable"" ) ; } if ( socketpair ( AF_LOCAL , SOCK_STREAM , 0 , sync_child_pipe ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>setup<S2SV_blank>sync<S2SV_blank>pipe<S2SV_blank>between<S2SV_blank>parent<S2SV_blank>and<S2SV_blank>child"" ) ; if ( socketpair ( AF_LOCAL , SOCK_STREAM , 0 , sync_grandchild_pipe ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>setup<S2SV_blank>sync<S2SV_blank>pipe<S2SV_blank>between<S2SV_blank>parent<S2SV_blank>and<S2SV_blank>grandchild"" ) ; switch ( setjmp ( env ) ) { case JUMP_PARENT : { int len ; pid_t child , first_child = - 1 ; bool ready = false ; prctl ( PR_SET_NAME , ( unsigned long ) ""runc:[0:PARENT]"" , 0 , 0 , 0 ) ; child = clone_parent ( & env , JUMP_CHILD ) ; if ( child < 0 ) bail ( ""unable<S2SV_blank>to<S2SV_blank>fork:<S2SV_blank>child_func"" ) ; while ( ! ready ) { enum sync_t s ; int ret ; syncfd = sync_child_pipe [ 1 ] ; close ( sync_child_pipe [ 0 ] ) ; if ( read ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>next<S2SV_blank>state"" ) ; switch ( s ) { case SYNC_ERR : if ( read ( syncfd , & ret , sizeof ( ret ) ) != sizeof ( ret ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>read(error<S2SV_blank>code)"" ) ; exit ( ret ) ; case SYNC_USERMAP_PLS : if ( config . is_rootless_euid && ! config . is_setgroup ) update_setgroups ( child , SETGROUPS_DENY ) ; update_uidmap ( config . uidmappath , child , config . uidmap , config . uidmap_len ) ; update_gidmap ( config . gidmappath , child , config . gidmap , config . gidmap_len ) ; s = SYNC_USERMAP_ACK ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>write(SYNC_USERMAP_ACK)"" ) ; } break ; case SYNC_RECVPID_PLS : { first_child = child ; if ( read ( syncfd , & child , sizeof ( child ) ) != sizeof ( child ) ) { kill ( first_child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>read(childpid)"" ) ; } s = SYNC_RECVPID_ACK ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) { kill ( first_child , SIGKILL ) ; kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>write(SYNC_RECVPID_ACK)"" ) ; } len = dprintf ( pipenum , ""{\\""pid\\"":<S2SV_blank>%d,<S2SV_blank>\\""pid_first\\"":<S2SV_blank>%d}\\n"" , child , first_child ) ; if ( len < 0 ) { kill ( child , SIGKILL ) ; bail ( ""unable<S2SV_blank>to<S2SV_blank>generate<S2SV_blank>JSON<S2SV_blank>for<S2SV_blank>child<S2SV_blank>pid"" ) ; } } break ; case SYNC_CHILD_READY : ready = true ; break ; default : bail ( ""unexpected<S2SV_blank>sync<S2SV_blank>value:<S2SV_blank>%u"" , s ) ; } } ready = false ; while ( ! ready ) { enum sync_t s ; int ret ; syncfd = sync_grandchild_pipe [ 1 ] ; close ( sync_grandchild_pipe [ 0 ] ) ; s = SYNC_GRANDCHILD ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>write(SYNC_GRANDCHILD)"" ) ; } if ( read ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>next<S2SV_blank>state"" ) ; switch ( s ) { case SYNC_ERR : if ( read ( syncfd , & ret , sizeof ( ret ) ) != sizeof ( ret ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>child:<S2SV_blank>read(error<S2SV_blank>code)"" ) ; exit ( ret ) ; case SYNC_CHILD_READY : ready = true ; break ; default : bail ( ""unexpected<S2SV_blank>sync<S2SV_blank>value:<S2SV_blank>%u"" , s ) ; } } exit ( 0 ) ; } case JUMP_CHILD : { pid_t child ; enum sync_t s ; syncfd = sync_child_pipe [ 0 ] ; close ( sync_child_pipe [ 1 ] ) ; prctl ( PR_SET_NAME , ( unsigned long ) ""runc:[1:CHILD]"" , 0 , 0 , 0 ) ; if ( config . namespaces ) join_namespaces ( config . namespaces ) ; if ( config . cloneflags & CLONE_NEWUSER ) { if ( unshare ( CLONE_NEWUSER ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>unshare<S2SV_blank>user<S2SV_blank>namespace"" ) ; config . cloneflags &= ~ CLONE_NEWUSER ; if ( config . namespaces ) { if ( prctl ( PR_SET_DUMPABLE , 1 , 0 , 0 , 0 ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>process<S2SV_blank>as<S2SV_blank>dumpable"" ) ; } s = SYNC_USERMAP_PLS ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>write(SYNC_USERMAP_PLS)"" ) ; if ( read ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>read(SYNC_USERMAP_ACK)"" ) ; if ( s != SYNC_USERMAP_ACK ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>SYNC_USERMAP_ACK:<S2SV_blank>got<S2SV_blank>%u"" , s ) ; if ( config . namespaces ) { if ( prctl ( PR_SET_DUMPABLE , 0 , 0 , 0 , 0 ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>process<S2SV_blank>as<S2SV_blank>dumpable"" ) ; } if ( setresuid ( 0 , 0 , 0 ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>become<S2SV_blank>root<S2SV_blank>in<S2SV_blank>user<S2SV_blank>namespace"" ) ; } if ( unshare ( config . cloneflags & ~ CLONE_NEWCGROUP ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>unshare<S2SV_blank>namespaces"" ) ; child = clone_parent ( & env , JUMP_INIT ) ; if ( child < 0 ) bail ( ""unable<S2SV_blank>to<S2SV_blank>fork:<S2SV_blank>init_func"" ) ; s = SYNC_RECVPID_PLS ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>write(SYNC_RECVPID_PLS)"" ) ; } if ( write ( syncfd , & child , sizeof ( child ) ) != sizeof ( child ) ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>write(childpid)"" ) ; } if ( read ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>read(SYNC_RECVPID_ACK)"" ) ; } if ( s != SYNC_RECVPID_ACK ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>SYNC_RECVPID_ACK:<S2SV_blank>got<S2SV_blank>%u"" , s ) ; } s = SYNC_CHILD_READY ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) { kill ( child , SIGKILL ) ; bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>write(SYNC_CHILD_READY)"" ) ; } exit ( 0 ) ; } case JUMP_INIT : { enum sync_t s ; syncfd = sync_grandchild_pipe [ 0 ] ; close ( sync_grandchild_pipe [ 1 ] ) ; close ( sync_child_pipe [ 0 ] ) ; close ( sync_child_pipe [ 1 ] ) ; prctl ( PR_SET_NAME , ( unsigned long ) ""runc:[2:INIT]"" , 0 , 0 , 0 ) ; if ( read ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>read(SYNC_GRANDCHILD)"" ) ; if ( s != SYNC_GRANDCHILD ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>parent:<S2SV_blank>SYNC_GRANDCHILD:<S2SV_blank>got<S2SV_blank>%u"" , s ) ; if ( setsid ( ) < 0 ) bail ( ""setsid<S2SV_blank>failed"" ) ; if ( setuid ( 0 ) < 0 ) bail ( ""setuid<S2SV_blank>failed"" ) ; if ( setgid ( 0 ) < 0 ) bail ( ""setgid<S2SV_blank>failed"" ) ; if ( ! config . is_rootless_euid && config . is_setgroup ) { if ( setgroups ( 0 , NULL ) < 0 ) bail ( ""setgroups<S2SV_blank>failed"" ) ; } if ( config . cloneflags & CLONE_NEWCGROUP ) { uint8_t value ; if ( read ( pipenum , & value , sizeof ( value ) ) != sizeof ( value ) ) bail ( ""read<S2SV_blank>synchronisation<S2SV_blank>value<S2SV_blank>failed"" ) ; if ( value == CREATECGROUPNS ) { if ( unshare ( CLONE_NEWCGROUP ) < 0 ) bail ( ""failed<S2SV_blank>to<S2SV_blank>unshare<S2SV_blank>cgroup<S2SV_blank>namespace"" ) ; } else bail ( ""received<S2SV_blank>unknown<S2SV_blank>synchronisation<S2SV_blank>value"" ) ; } s = SYNC_CHILD_READY ; if ( write ( syncfd , & s , sizeof ( s ) ) != sizeof ( s ) ) bail ( ""failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>with<S2SV_blank>patent:<S2SV_blank>write(SYNC_CHILD_READY)"" ) ; close ( sync_grandchild_pipe [ 0 ] ) ; nl_free ( & config ) ; return ; } default : bail ( ""unexpected<S2SV_blank>jump<S2SV_blank>value"" ) ; } bail ( ""should<S2SV_blank>never<S2SV_blank>be<S2SV_blank>reached"" ) ; }",") return ; if ( ensure_cloned_binary ( ) < 0 ) bail ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>we<S2SV_blank>are<S2SV_blank>a<S2SV_blank>cloned<S2SV_blank>binary"" ) ;"
666,"asmlinkage void do_ade ( struct pt_regs * regs ) { unsigned int __user * pc ; mm_segment_t seg ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , <S2SV_StartBug> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <S2SV_EndBug> if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ; pc = ( unsigned int __user * ) exception_epc ( regs ) ; if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) goto sigbus ; if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) goto sigbus ; else if ( unaligned_action == UNALIGNED_ACTION_SHOW ) show_registers ( regs ) ; seg = get_fs ( ) ; if ( ! user_mode ( regs ) ) set_fs ( KERNEL_DS ) ; emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; set_fs ( seg ) ; return ; sigbus : die_if_kernel ( ""Kernel<S2SV_blank>unaligned<S2SV_blank>instruction<S2SV_blank>access"" , regs ) ; force_sig ( SIGBUS , current ) ; }","PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,"
667,"int hugepage_madvise ( struct vm_area_struct * vma , unsigned long * vm_flags , int advice ) { switch ( advice ) { case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_NOHUGEPAGE ; * vm_flags |= VM_HUGEPAGE ; if ( unlikely ( khugepaged_enter_vma_merge ( vma ) ) ) return - ENOMEM ; break ; case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_HUGEPAGE ; * vm_flags |= VM_NOHUGEPAGE ; break ; } return 0 ; }",( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return
668,"static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , ""Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\n"" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , ""Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\n"" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n"" ""<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n"" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\n"" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\n"" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\n"" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , ""Bad<S2SV_blank>type<S2SV_blank>count.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\n"" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , ""No<S2SV_blank>\'STR<S2SV_blank>\'<S2SV_blank>resource.\\n"" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }","+ 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> rsrc . type_offset <S2SV_ModStart> k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8"
669,"int ssl_hook_Access ( request_rec * r ) { SSLDirConfigRec * dc = myDirConfig ( r ) ; SSLSrvConfigRec * sc = mySrvConfig ( r -> server ) ; SSLConnRec * sslconn = myConnConfig ( r -> connection ) ; SSL * ssl = sslconn ? sslconn -> ssl : NULL ; server_rec * handshakeserver = sslconn ? sslconn -> server : NULL ; SSLSrvConfigRec * hssc = handshakeserver ? mySrvConfig ( handshakeserver ) : NULL ; SSL_CTX * ctx = NULL ; apr_array_header_t * requires ; ssl_require_t * ssl_requires ; int ok , i ; BOOL renegotiate = FALSE , renegotiate_quick = FALSE ; X509 * cert ; X509 * peercert ; X509_STORE * cert_store = NULL ; X509_STORE_CTX * cert_store_ctx ; STACK_OF ( SSL_CIPHER ) * cipher_list_old = NULL , * cipher_list = NULL ; const SSL_CIPHER * cipher = NULL ; int depth , verify_old , verify , n , is_slave = 0 ; const char * ncipher_suite ; if ( ! ( sslconn && ssl ) && r -> connection -> master ) { sslconn = myConnConfig ( r -> connection -> master ) ; ssl = sslconn ? sslconn -> ssl : NULL ; handshakeserver = sslconn ? sslconn -> server : NULL ; hssc = handshakeserver ? mySrvConfig ( handshakeserver ) : NULL ; is_slave = 1 ; } if ( ssl ) { if ( ! SSL_is_init_finished ( ssl ) ) { return HTTP_FORBIDDEN ; } ctx = SSL_get_SSL_CTX ( ssl ) ; } if ( dc -> bSSLRequired && ! ssl ) { if ( ( sc -> enabled == SSL_ENABLED_OPTIONAL ) && ! is_slave ) { apr_table_setn ( r -> err_headers_out , ""Upgrade"" , ""TLS/1.0,<S2SV_blank>HTTP/1.1"" ) ; apr_table_setn ( r -> err_headers_out , ""Connection"" , ""Upgrade"" ) ; return HTTP_UPGRADE_REQUIRED ; } ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02219 ) ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>%s"" , r -> filename , ""SSL<S2SV_blank>connection<S2SV_blank>required"" ) ; apr_table_setn ( r -> notes , ""ssl-access-forbidden"" , ""1"" ) ; return HTTP_FORBIDDEN ; } if ( sc -> enabled == SSL_ENABLED_FALSE || ! ssl ) { return DECLINED ; } # ifdef HAVE_SRP if ( SSL_get_srp_username ( ssl ) ) { return DECLINED ; } # endif ncipher_suite = ( dc -> szCipherSuite ? dc -> szCipherSuite : ( r -> server != handshakeserver ) ? sc -> server -> auth . cipher_suite : NULL ) ; if ( ncipher_suite && ( ! sslconn -> cipher_suite || strcmp ( ncipher_suite , sslconn -> cipher_suite ) ) ) { if ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) { cipher = SSL_get_current_cipher ( ssl ) ; } else { cipher_list_old = ( STACK_OF ( SSL_CIPHER ) * ) SSL_get_ciphers ( ssl ) ; if ( cipher_list_old ) { cipher_list_old = sk_SSL_CIPHER_dup ( cipher_list_old ) ; } } if ( is_slave ) { apr_table_setn ( r -> notes , ""ssl-renegotiate-forbidden"" , ""cipher-suite"" ) ; return HTTP_FORBIDDEN ; } if ( ! SSL_set_cipher_list ( ssl , ncipher_suite ) ) { ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , APLOGNO ( 02253 ) ""Unable<S2SV_blank>to<S2SV_blank>reconfigure<S2SV_blank>(per-directory)<S2SV_blank>"" ""permitted<S2SV_blank>SSL<S2SV_blank>ciphers"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; if ( cipher_list_old ) { sk_SSL_CIPHER_free ( cipher_list_old ) ; } return HTTP_FORBIDDEN ; } cipher_list = ( STACK_OF ( SSL_CIPHER ) * ) SSL_get_ciphers ( ssl ) ; if ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) { if ( ( ! cipher && cipher_list ) || ( cipher && ! cipher_list ) ) { renegotiate = TRUE ; } else if ( cipher && cipher_list && ( sk_SSL_CIPHER_find ( cipher_list , cipher ) < 0 ) ) { renegotiate = TRUE ; } } else { if ( ( ! cipher_list_old && cipher_list ) || ( cipher_list_old && ! cipher_list ) ) { renegotiate = TRUE ; } else if ( cipher_list_old && cipher_list ) { for ( n = 0 ; ! renegotiate && ( n < sk_SSL_CIPHER_num ( cipher_list ) ) ; n ++ ) { const SSL_CIPHER * value = sk_SSL_CIPHER_value ( cipher_list , n ) ; if ( sk_SSL_CIPHER_find ( cipher_list_old , value ) < 0 ) { renegotiate = TRUE ; } } for ( n = 0 ; ! renegotiate && ( n < sk_SSL_CIPHER_num ( cipher_list_old ) ) ; n ++ ) { const SSL_CIPHER * value = sk_SSL_CIPHER_value ( cipher_list_old , n ) ; if ( sk_SSL_CIPHER_find ( cipher_list , value ) < 0 ) { renegotiate = TRUE ; } } } } if ( cipher_list_old ) { sk_SSL_CIPHER_free ( cipher_list_old ) ; } if ( renegotiate ) { if ( is_slave ) { apr_table_setn ( r -> notes , ""ssl-renegotiate-forbidden"" , ""cipher-suite"" ) ; return HTTP_FORBIDDEN ; } # ifdef SSL_OP_CIPHER_SERVER_PREFERENCE if ( sc -> cipher_server_pref == TRUE ) { SSL_set_options ( ssl , SSL_OP_CIPHER_SERVER_PREFERENCE ) ; } # endif ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02220 ) ""Reconfigured<S2SV_blank>cipher<S2SV_blank>suite<S2SV_blank>will<S2SV_blank>force<S2SV_blank>renegotiation"" ) ; } } if ( ( dc -> nVerifyClient != SSL_CVERIFY_UNSET ) || ( sc -> server -> auth . verify_mode != SSL_CVERIFY_UNSET ) ) { verify_old = SSL_get_verify_mode ( ssl ) ; verify = SSL_VERIFY_NONE ; if ( ( dc -> nVerifyClient == SSL_CVERIFY_REQUIRE ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_REQUIRE ) ) { verify |= SSL_VERIFY_PEER_STRICT ; } if ( ( dc -> nVerifyClient == SSL_CVERIFY_OPTIONAL ) || ( dc -> nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_OPTIONAL ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA ) ) { verify |= SSL_VERIFY_PEER ; } SSL_set_verify ( ssl , verify , ssl_callback_SSLVerify ) ; SSL_set_verify_result ( ssl , X509_V_OK ) ; if ( ! renegotiate && verify != verify_old ) { if ( ( ( verify_old == SSL_VERIFY_NONE ) && ( verify != SSL_VERIFY_NONE ) ) || ( ! ( verify_old & SSL_VERIFY_PEER ) && ( verify & SSL_VERIFY_PEER ) ) || ( ! ( verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) && ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) ) { renegotiate = TRUE ; if ( is_slave ) { apr_table_setn ( r -> notes , ""ssl-renegotiate-forbidden"" , ""verify-client"" ) ; <S2SV_StartBug> return HTTP_FORBIDDEN ; <S2SV_EndBug> } if ( ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) && ( verify_old == SSL_VERIFY_NONE ) && ( ( peercert = SSL_get_peer_certificate ( ssl ) ) != NULL ) ) { renegotiate_quick = TRUE ; X509_free ( peercert ) ; } ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02255 ) ""Changed<S2SV_blank>client<S2SV_blank>verification<S2SV_blank>type<S2SV_blank>will<S2SV_blank>force<S2SV_blank>"" ""%srenegotiation"" , renegotiate_quick ? ""quick<S2SV_blank>"" : """" ) ; } else if ( verify != SSL_VERIFY_NONE ) { n = ( sslconn -> verify_depth != UNSET ) ? sslconn -> verify_depth : hssc -> server -> auth . verify_depth ; sslconn -> verify_depth = ( dc -> nVerifyDepth != UNSET ) ? dc -> nVerifyDepth : sc -> server -> auth . verify_depth ; if ( sslconn -> verify_depth < n ) { renegotiate = TRUE ; ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02254 ) ""Reduced<S2SV_blank>client<S2SV_blank>verification<S2SV_blank>depth<S2SV_blank>will<S2SV_blank>"" ""force<S2SV_blank>renegotiation"" ) ; } } } if ( ( r -> server != handshakeserver ) && renegotiate && ( ( verify & SSL_VERIFY_PEER ) || ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) ) { # define MODSSL_CFG_CA_NE ( f , sc1 , sc2 ) ( sc1 -> server -> auth . f && ( ! sc2 -> server -> auth . f || strNE ( sc1 -> server -> auth . f , sc2 -> server -> auth . f ) ) ) if ( MODSSL_CFG_CA_NE ( ca_cert_file , sc , hssc ) || MODSSL_CFG_CA_NE ( ca_cert_path , sc , hssc ) ) { if ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02256 ) ""Non-default<S2SV_blank>virtual<S2SV_blank>host<S2SV_blank>with<S2SV_blank>SSLVerify<S2SV_blank>set<S2SV_blank>to<S2SV_blank>"" ""\'require\'<S2SV_blank>and<S2SV_blank>VirtualHost-specific<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>"" ""list<S2SV_blank>is<S2SV_blank>only<S2SV_blank>available<S2SV_blank>to<S2SV_blank>clients<S2SV_blank>with<S2SV_blank>TLS<S2SV_blank>server<S2SV_blank>"" ""name<S2SV_blank>indication<S2SV_blank>(SNI)<S2SV_blank>support"" ) ; SSL_set_verify ( ssl , verify_old , NULL ) ; return HTTP_FORBIDDEN ; } else sslconn -> verify_info = ""GENEROUS"" ; } } } if ( renegotiate && ! renegotiate_quick && ( apr_table_get ( r -> headers_in , ""transfer-encoding"" ) || ( apr_table_get ( r -> headers_in , ""content-length"" ) && strcmp ( apr_table_get ( r -> headers_in , ""content-length"" ) , ""0"" ) ) ) && ! r -> expecting_100 ) { int rv ; apr_size_t rsize ; rsize = dc -> nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE : dc -> nRenegBufferSize ; if ( rsize > 0 ) { rv = ssl_io_buffer_fill ( r , rsize ) ; } else { rv = HTTP_REQUEST_ENTITY_TOO_LARGE ; } if ( rv ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02257 ) ""could<S2SV_blank>not<S2SV_blank>buffer<S2SV_blank>message<S2SV_blank>body<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>"" ""SSL<S2SV_blank>renegotiation<S2SV_blank>to<S2SV_blank>proceed"" ) ; return rv ; } } if ( renegotiate ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02221 ) ""Requesting<S2SV_blank>connection<S2SV_blank>re-negotiation"" ) ; if ( renegotiate_quick ) { STACK_OF ( X509 ) * cert_stack ; ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02258 ) ""Performing<S2SV_blank>quick<S2SV_blank>renegotiation:<S2SV_blank>"" ""just<S2SV_blank>re-verifying<S2SV_blank>the<S2SV_blank>peer"" ) ; cert_stack = ( STACK_OF ( X509 ) * ) SSL_get_peer_cert_chain ( ssl ) ; cert = SSL_get_peer_certificate ( ssl ) ; if ( ! cert_stack && cert ) { cert_stack = sk_X509_new_null ( ) ; sk_X509_push ( cert_stack , cert ) ; } if ( ! cert_stack || ( sk_X509_num ( cert_stack ) == 0 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02222 ) ""Cannot<S2SV_blank>find<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>chain"" ) ; return HTTP_FORBIDDEN ; } if ( ! ( cert_store || ( cert_store = SSL_CTX_get_cert_store ( ctx ) ) ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02223 ) ""Cannot<S2SV_blank>find<S2SV_blank>certificate<S2SV_blank>storage"" ) ; return HTTP_FORBIDDEN ; } if ( ! cert ) { cert = sk_X509_value ( cert_stack , 0 ) ; } cert_store_ctx = X509_STORE_CTX_new ( ) ; X509_STORE_CTX_init ( cert_store_ctx , cert_store , cert , cert_stack ) ; depth = SSL_get_verify_depth ( ssl ) ; if ( depth >= 0 ) { X509_STORE_CTX_set_depth ( cert_store_ctx , depth ) ; } X509_STORE_CTX_set_ex_data ( cert_store_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) , ( char * ) ssl ) ; if ( ! X509_verify_cert ( cert_store_ctx ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02224 ) ""Re-negotiation<S2SV_blank>verification<S2SV_blank>step<S2SV_blank>failed"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; } SSL_set_verify_result ( ssl , X509_STORE_CTX_get_error ( cert_store_ctx ) ) ; X509_STORE_CTX_cleanup ( cert_store_ctx ) ; X509_STORE_CTX_free ( cert_store_ctx ) ; if ( cert_stack != SSL_get_peer_cert_chain ( ssl ) ) { sk_X509_pop_free ( cert_stack , X509_free ) ; } } else { char peekbuf [ 1 ] ; const char * reneg_support ; request_rec * id = r -> main ? r -> main : r ; if ( has_buffered_data ( r ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02259 ) ""insecure<S2SV_blank>SSL<S2SV_blank>re-negotiation<S2SV_blank>required,<S2SV_blank>but<S2SV_blank>"" ""a<S2SV_blank>pipelined<S2SV_blank>request<S2SV_blank>is<S2SV_blank>present;<S2SV_blank>keepalive<S2SV_blank>"" ""disabled"" ) ; r -> connection -> keepalive = AP_CONN_CLOSE ; } # if defined ( SSL_get_secure_renegotiation_support ) reneg_support = SSL_get_secure_renegotiation_support ( ssl ) ? ""client<S2SV_blank>does"" : ""client<S2SV_blank>does<S2SV_blank>not"" ; # else reneg_support = ""server<S2SV_blank>does<S2SV_blank>not"" ; # endif ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02260 ) ""Performing<S2SV_blank>full<S2SV_blank>renegotiation:<S2SV_blank>complete<S2SV_blank>handshake<S2SV_blank>"" ""protocol<S2SV_blank>(%s<S2SV_blank>support<S2SV_blank>secure<S2SV_blank>renegotiation)"" , reneg_support ) ; SSL_set_session_id_context ( ssl , ( unsigned char * ) & id , sizeof ( id ) ) ; sslconn -> reneg_state = RENEG_ALLOW ; SSL_renegotiate ( ssl ) ; SSL_do_handshake ( ssl ) ; if ( ! SSL_is_init_finished ( ssl ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02225 ) ""Re-negotiation<S2SV_blank>request<S2SV_blank>failed"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; r -> connection -> keepalive = AP_CONN_CLOSE ; return HTTP_FORBIDDEN ; } ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02226 ) ""Awaiting<S2SV_blank>re-negotiation<S2SV_blank>handshake"" ) ; SSL_peek ( ssl , peekbuf , 0 ) ; sslconn -> reneg_state = RENEG_REJECT ; if ( ! SSL_is_init_finished ( ssl ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02261 ) ""Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed"" ) ; ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; r -> connection -> keepalive = AP_CONN_CLOSE ; return HTTP_FORBIDDEN ; } sslconn -> server = r -> server ; } if ( ( cert = SSL_get_peer_certificate ( ssl ) ) ) { if ( sslconn -> client_cert ) { X509_free ( sslconn -> client_cert ) ; } sslconn -> client_cert = cert ; sslconn -> client_dn = NULL ; } if ( ( dc -> nVerifyClient != SSL_CVERIFY_NONE ) || ( sc -> server -> auth . verify_mode != SSL_CVERIFY_NONE ) ) { BOOL do_verify = ( ( dc -> nVerifyClient == SSL_CVERIFY_REQUIRE ) || ( sc -> server -> auth . verify_mode == SSL_CVERIFY_REQUIRE ) ) ; if ( do_verify && ( SSL_get_verify_result ( ssl ) != X509_V_OK ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02262 ) ""Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed:<S2SV_blank>"" ""Client<S2SV_blank>verification<S2SV_blank>failed"" ) ; return HTTP_FORBIDDEN ; } if ( do_verify ) { if ( ( peercert = SSL_get_peer_certificate ( ssl ) ) == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02263 ) ""Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed:<S2SV_blank>"" ""Client<S2SV_blank>certificate<S2SV_blank>missing"" ) ; return HTTP_FORBIDDEN ; } X509_free ( peercert ) ; } } if ( cipher_list ) { cipher = SSL_get_current_cipher ( ssl ) ; if ( sk_SSL_CIPHER_find ( cipher_list , cipher ) < 0 ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02264 ) ""SSL<S2SV_blank>cipher<S2SV_blank>suite<S2SV_blank>not<S2SV_blank>renegotiated:<S2SV_blank>"" ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>denied<S2SV_blank>using<S2SV_blank>cipher<S2SV_blank>%s"" , r -> filename , SSL_CIPHER_get_name ( cipher ) ) ; return HTTP_FORBIDDEN ; } } if ( ncipher_suite ) { sslconn -> cipher_suite = ncipher_suite ; } } if ( ( dc -> nOptions & SSL_OPT_FAKEBASICAUTH ) == 0 && dc -> szUserName ) { char * val = ssl_var_lookup ( r -> pool , r -> server , r -> connection , r , ( char * ) dc -> szUserName ) ; if ( val && val [ 0 ] ) r -> user = val ; else ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , APLOGNO ( 02227 ) ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>r->user<S2SV_blank>to<S2SV_blank>\'%s\'"" , dc -> szUserName ) ; } requires = dc -> aRequirement ; ssl_requires = ( ssl_require_t * ) requires -> elts ; for ( i = 0 ; i < requires -> nelts ; i ++ ) { ssl_require_t * req = & ssl_requires [ i ] ; const char * errstring ; ok = ap_expr_exec ( r , req -> mpExpr , & errstring ) ; if ( ok < 0 ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02265 ) ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>"" ""SSL<S2SV_blank>requirement<S2SV_blank>expression:<S2SV_blank>%s"" , r -> filename , errstring ) ; apr_table_setn ( r -> notes , ""ssl-access-forbidden"" , ""1"" ) ; return HTTP_FORBIDDEN ; } if ( ok != 1 ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02266 ) ""Access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>denied<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""(requirement<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>fulfilled)"" , r -> filename , r -> useragent_ip ) ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02228 ) ""Failed<S2SV_blank>expression:<S2SV_blank>%s"" , req -> cpExpr ) ; ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02229 ) ""access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>%s"" , r -> filename , ""SSL<S2SV_blank>requirement<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>fulfilled"" ) ; apr_table_setn ( r -> notes , ""ssl-access-forbidden"" , ""1"" ) ; return HTTP_FORBIDDEN ; } } return DECLINED ; }","""verify-client"" ) ; SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify ) ;"
670,"int main ( int argc , char * * argv ) { FILE * infile = NULL ; <S2SV_StartBug> vpx_codec_ctx_t codec = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_enc_cfg_t cfg = { 0 } ; <S2SV_EndBug> int frame_count = 0 ; <S2SV_StartBug> vpx_image_t raw = { 0 } ; <S2SV_EndBug> vpx_codec_err_t res ; <S2SV_StartBug> VpxVideoInfo info = { 0 } ; <S2SV_EndBug> VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; const int fps = 2 ; const double bits_per_pixel_per_frame = 0.067 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; <S2SV_StartBug> encoder = get_vpx_encoder_by_name ( argv [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! encoder ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Unsupported<S2SV_blank>codec."" ) ; <S2SV_EndBug> info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 2 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 3 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; } <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = ( unsigned int ) ( bits_per_pixel_per_frame * cfg . g_w * cfg . g_h * fps / 1000 ) ; cfg . g_lag_in_frames = 0 ; writer = vpx_video_writer_open ( argv [ 5 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 5 ] ) ; if ( ! ( infile = fopen ( argv [ 4 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 4 ] ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { ++ frame_count ; if ( frame_count == 22 && encoder -> fourcc == VP8_FOURCC ) { set_roi_map ( & cfg , & codec ) ; } else if ( frame_count == 33 ) { set_active_map ( & cfg , & codec ) ; } else if ( frame_count == 44 ) { unset_active_map ( & cfg , & codec ) ; } encode_frame ( & codec , & raw , frame_count , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","; vpx_codec_ctx_t codec <S2SV_ModEnd> ; vpx_codec_enc_cfg_t cfg <S2SV_ModStart> ; vpx_codec_enc_cfg_t cfg <S2SV_ModEnd> ; int frame_count <S2SV_ModStart> ; vpx_image_t raw <S2SV_ModEnd> ; vpx_codec_err_t res <S2SV_ModStart> ; VpxVideoInfo info <S2SV_ModEnd> ; VpxVideoWriter * <S2SV_ModStart> ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; memset ( & info , 0 , sizeof ( info ) ) ; <S2SV_ModStart> ; if ( encoder == NULL ) { <S2SV_ModEnd> die ( ""Unsupported<S2SV_blank>codec."" <S2SV_ModStart> die ( ""Unsupported<S2SV_blank>codec."" ) ; } assert ( encoder != NULL <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> ) ; } while ( <S2SV_ModStart> , writer ) ) { } <S2SV_ModEnd> printf ( ""\\n"""
671,static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } },vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
672,<S2SV_StartBug> void close_connection ( h2o_http2_conn_t * conn ) <S2SV_EndBug> { conn -> state = H2O_HTTP2_CONN_STATE_IS_CLOSING ; if ( conn -> _write . buf_in_flight != NULL || h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { } else { close_connection_now ( conn ) ; <S2SV_StartBug> } <S2SV_EndBug> },<S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> close_connection ( h2o_http2_conn_t <S2SV_ModStart> conn ) ; return - 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
673,"static int aa_read_header ( AVFormatContext * s ) { int i , j , idx , largest_idx = - 1 ; uint32_t nkey , nval , toc_size , npairs , header_seed = 0 , start ; char key [ 128 ] , val [ 128 ] , codec_name [ 64 ] = { 0 } ; uint8_t output [ 24 ] , dst [ 8 ] , src [ 8 ] ; int64_t largest_size = - 1 , current_size = - 1 , chapter_pos ; struct toc_entry { uint32_t offset ; uint32_t size ; } TOC [ MAX_TOC_ENTRIES ] ; uint32_t header_key_part [ 4 ] ; uint8_t header_key [ 16 ] = { 0 } ; AADemuxContext * c = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st ; <S2SV_StartBug> avio_skip ( pb , 4 ) ; <S2SV_EndBug> avio_skip ( pb , 4 ) ; toc_size = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; if ( toc_size > MAX_TOC_ENTRIES ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < toc_size ; i ++ ) { avio_skip ( pb , 4 ) ; TOC [ i ] . offset = avio_rb32 ( pb ) ; TOC [ i ] . size = avio_rb32 ( pb ) ; } avio_skip ( pb , 24 ) ; npairs = avio_rb32 ( pb ) ; if ( npairs > MAX_DICTIONARY_ENTRIES ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < npairs ; i ++ ) { memset ( val , 0 , sizeof ( val ) ) ; memset ( key , 0 , sizeof ( key ) ) ; avio_skip ( pb , 1 ) ; nkey = avio_rb32 ( pb ) ; nval = avio_rb32 ( pb ) ; avio_get_str ( pb , nkey , key , sizeof ( key ) ) ; avio_get_str ( pb , nval , val , sizeof ( val ) ) ; if ( ! strcmp ( key , ""codec"" ) ) { av_log ( s , AV_LOG_DEBUG , ""Codec<S2SV_blank>is<S2SV_blank><%s>\\n"" , val ) ; strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ; } else if ( ! strcmp ( key , ""HeaderSeed"" ) ) { av_log ( s , AV_LOG_DEBUG , ""HeaderSeed<S2SV_blank>is<S2SV_blank><%s>\\n"" , val ) ; header_seed = atoi ( val ) ; } else if ( ! strcmp ( key , ""HeaderKey"" ) ) { av_log ( s , AV_LOG_DEBUG , ""HeaderKey<S2SV_blank>is<S2SV_blank><%s>\\n"" , val ) ; <S2SV_StartBug> sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 , <S2SV_EndBug> & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ; <S2SV_StartBug> for ( idx = 0 ; idx < 4 ; idx ++ ) { <S2SV_EndBug> AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ; } av_log ( s , AV_LOG_DEBUG , ""Processed<S2SV_blank>HeaderKey<S2SV_blank>is<S2SV_blank>"" ) ; for ( i = 0 ; i < 16 ; i ++ ) av_log ( s , AV_LOG_DEBUG , ""%02x"" , header_key [ i ] ) ; av_log ( s , AV_LOG_DEBUG , ""\\n"" ) ; } else { av_dict_set ( & s -> metadata , key , val , 0 ) ; } } if ( c -> aa_fixed_key_len != 16 ) { av_log ( s , AV_LOG_ERROR , ""aa_fixed_key<S2SV_blank>value<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>16<S2SV_blank>bytes!\\n"" ) ; return AVERROR ( EINVAL ) ; } if ( ( c -> codec_second_size = get_second_size ( codec_name ) ) == - 1 ) { av_log ( s , AV_LOG_ERROR , ""unknown<S2SV_blank>codec<S2SV_blank><%s>!\\n"" , codec_name ) ; return AVERROR ( EINVAL ) ; } c -> tea_ctx = av_tea_alloc ( ) ; if ( ! c -> tea_ctx ) return AVERROR ( ENOMEM ) ; av_tea_init ( c -> tea_ctx , c -> aa_fixed_key , 16 ) ; output [ 0 ] = output [ 1 ] = 0 ; memcpy ( output + 2 , header_key , 16 ) ; idx = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { AV_WB32 ( src , header_seed ) ; AV_WB32 ( src + 4 , header_seed + 1 ) ; header_seed += 2 ; av_tea_crypt ( c -> tea_ctx , dst , src , 1 , NULL , 0 ) ; for ( j = 0 ; j < TEA_BLOCK_SIZE && idx < 18 ; j += 1 , idx += 1 ) { output [ idx ] = output [ idx ] ^ dst [ j ] ; } } memcpy ( c -> file_key , output + 2 , 16 ) ; av_log ( s , AV_LOG_DEBUG , ""File<S2SV_blank>key<S2SV_blank>is<S2SV_blank>"" ) ; for ( i = 0 ; i < 16 ; i ++ ) av_log ( s , AV_LOG_DEBUG , ""%02x"" , c -> file_key [ i ] ) ; av_log ( s , AV_LOG_DEBUG , ""\\n"" ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { av_freep ( & c -> tea_ctx ) ; return AVERROR ( ENOMEM ) ; } st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ! strcmp ( codec_name , ""mp332"" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_MP3 ; st -> codecpar -> sample_rate = 22050 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 32000 * TIMEPREC ) ; } else if ( ! strcmp ( codec_name , ""acelp85"" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; st -> codecpar -> block_align = 19 ; st -> codecpar -> channels = 1 ; st -> codecpar -> sample_rate = 8500 ; st -> codecpar -> bit_rate = 8500 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 8500 * TIMEPREC ) ; } else if ( ! strcmp ( codec_name , ""acelp16"" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; st -> codecpar -> block_align = 20 ; st -> codecpar -> channels = 1 ; st -> codecpar -> sample_rate = 16000 ; st -> codecpar -> bit_rate = 16000 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 16000 * TIMEPREC ) ; } for ( i = 1 ; i < toc_size ; i ++ ) { current_size = TOC [ i ] . size ; if ( current_size > largest_size ) { largest_idx = i ; largest_size = current_size ; } } start = TOC [ largest_idx ] . offset ; avio_seek ( pb , start , SEEK_SET ) ; st -> start_time = 0 ; c -> content_start = start ; c -> content_end = start + largest_size ; while ( ( chapter_pos = avio_tell ( pb ) ) >= 0 && chapter_pos < c -> content_end ) { int chapter_idx = s -> nb_chapters ; uint32_t chapter_size = avio_rb32 ( pb ) ; if ( chapter_size == 0 ) break ; chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx ; avio_skip ( pb , 4 + chapter_size ) ; if ( ! avpriv_new_chapter ( s , chapter_idx , st -> time_base , chapter_pos * TIMEPREC , ( chapter_pos + chapter_size ) * TIMEPREC , NULL ) ) return AVERROR ( ENOMEM ) ; } st -> duration = ( largest_size - CHAPTER_HEADER_SIZE * s -> nb_chapters ) * TIMEPREC ; ff_update_cur_dts ( s , st , 0 ) ; avio_seek ( pb , start , SEEK_SET ) ; c -> current_chapter_size = 0 ; c -> seek_offset = 0 ; return 0 ; }",* st ; int ret ; <S2SV_ModStart> val ) ; ret = <S2SV_ModStart> ] ) ; if ( ret != 4 ) return AVERROR_INVALIDDATA ;
674,"static size_t read_uncompressed_header ( VP9Decoder * pbi , <S2SV_StartBug> struct vp9_read_bit_buffer * rb ) { <S2SV_EndBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_StartBug> size_t sz ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> cm -> last_frame_type = cm -> frame_type ; <S2SV_StartBug> if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>marker"" ) ; <S2SV_StartBug> cm -> profile = read_profile ( rb ) ; <S2SV_EndBug> if ( cm -> profile >= MAX_PROFILES ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; <S2SV_StartBug> cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> if ( cm -> show_existing_frame ) { <S2SV_StartBug> const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame"" , frame_to_show ) ; <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; <S2SV_EndBug> pbi -> refresh_frame_flags = 0 ; cm -> lf . filter_level = 0 ; cm -> show_frame = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } <S2SV_StartBug> cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> if ( cm -> profile > PROFILE_1 ) cm -> bit_depth = vp9_rb_read_bit ( rb ) ? BITS_12 : BITS_10 ; cm -> color_space = ( COLOR_SPACE ) vp9_rb_read_literal ( rb , 3 ) ; if ( cm -> color_space != SRGB ) { vp9_rb_read_bit ( rb ) ; if ( cm -> profile >= PROFILE_1 ) { cm -> subsampling_x = vp9_rb_read_bit ( rb ) ; cm -> subsampling_y = vp9_rb_read_bit ( rb ) ; vp9_rb_read_bit ( rb ) ; } else { cm -> subsampling_y = cm -> subsampling_x = 1 ; } } else { if ( cm -> profile >= PROFILE_1 ) { cm -> subsampling_y = cm -> subsampling_x = 0 ; vp9_rb_read_bit ( rb ) ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , <S2SV_StartBug> ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ; <S2SV_EndBug> } } pbi -> refresh_frame_flags = ( 1 << REF_FRAMES ) - 1 ; for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { <S2SV_StartBug> cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ; <S2SV_EndBug> } <S2SV_StartBug> setup_frame_size ( cm , rb ) ; <S2SV_EndBug> } else { <S2SV_StartBug> cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> reset_frame_context = cm -> error_resilient_mode ? <S2SV_StartBug> 0 : vp9_rb_read_literal ( rb , 2 ) ; <S2SV_EndBug> if ( cm -> intra_only ) { <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> setup_frame_size ( cm , rb ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { <S2SV_StartBug> const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; <S2SV_EndBug> const int idx = cm -> ref_frame_map [ ref ] ; <S2SV_StartBug> cm -> frame_refs [ i ] . idx = idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ; <S2SV_EndBug> <S2SV_StartBug> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> } setup_frame_size_with_refs ( cm , rb ) ; <S2SV_StartBug> cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> interp_filter = read_interp_filter ( rb ) ; for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { RefBuffer * const ref_buf = & cm -> frame_refs [ i ] ; <S2SV_StartBug> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , <S2SV_EndBug> ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , <S2SV_StartBug> cm -> width , cm -> height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( & ref_buf -> sf ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_extend_frame_borders ( ref_buf -> buf ) ; <S2SV_EndBug> } } } if ( ! cm -> error_resilient_mode ) { <S2SV_StartBug> cm -> coding_use_prev_mi = 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> cm -> frame_parallel_decoding_mode = vp9_rb_read_bit ( rb ) ; } else { <S2SV_StartBug> cm -> coding_use_prev_mi = 0 ; <S2SV_EndBug> cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode = 1 ; <S2SV_StartBug> } <S2SV_EndBug> cm -> frame_context_idx = vp9_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; if ( frame_is_intra_only ( cm ) || cm -> error_resilient_mode ) vp9_setup_past_independence ( cm ) ; setup_loopfilter ( & cm -> lf , rb ) ; setup_quantization ( cm , & pbi -> mb , rb ) ; setup_segmentation ( & cm -> seg , rb ) ; <S2SV_StartBug> setup_tile_info ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> sz = vp9_rb_read_literal ( rb , 16 ) ; <S2SV_EndBug> if ( sz == 0 ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ; return sz ; }","pbi , struct vpx_read_bit_buffer <S2SV_ModEnd> * rb ) <S2SV_ModStart> -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; int i , mask , ref_index = 0 ; <S2SV_ModStart> size_t sz ; <S2SV_ModEnd> cm -> last_frame_type <S2SV_ModStart> -> frame_type ; cm -> last_intra_only = cm -> intra_only ; if ( vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> -> profile = vp9_read_profile ( rb ) ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModEnd> if ( cm <S2SV_ModStart> ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # endif <S2SV_ModStart> -> show_existing_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> ref_frame_map [ vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> ) ] ; lock_buffer_pool ( pool ) ; if ( frame_to_show < 0 || <S2SV_ModEnd> frame_bufs [ frame_to_show <S2SV_ModStart> < 1 ) { unlock_buffer_pool ( pool ) ; <S2SV_ModStart> frame_to_show ) ; } ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , & <S2SV_ModStart> new_fb_idx , frame_to_show ) ; unlock_buffer_pool ( pool <S2SV_ModStart> = 1 ; if ( pbi -> frame_parallel_decode ) { for ( i = 0 ; i < REF_FRAMES ; ++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; } <S2SV_ModStart> ( FRAME_TYPE ) vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> show_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> error_resilient_mode = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> KEY_FRAME ) { if ( ! vp9_read_sync_code ( rb ) ) <S2SV_ModEnd> vpx_internal_error ( & <S2SV_ModStart> , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; read_bitdepth_colorspace_sampling ( cm , rb ) ; <S2SV_ModEnd> pbi -> refresh_frame_flags <S2SV_ModStart> . idx = INVALID_IDX <S2SV_ModEnd> ; cm -> <S2SV_ModStart> . buf = NULL <S2SV_ModEnd> ; } setup_frame_size <S2SV_ModStart> rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> ? 0 : vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> ? 0 : vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> intra_only ) { if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; if ( cm -> profile > PROFILE_0 ) { read_bitdepth_colorspace_sampling ( cm , rb ) ; } else { cm -> color_space = VPX_CS_BT_601 ; cm -> subsampling_y = cm -> subsampling_x = 1 ; cm -> bit_depth = VPX_BITS_8 ; # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth = 0 ; # endif } <S2SV_ModEnd> pbi -> refresh_frame_flags <S2SV_ModStart> -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } } else if ( pbi -> need_resync != 1 ) <S2SV_ModEnd> { pbi -> <S2SV_ModStart> -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> int ref = vpx_rb_read_literal <S2SV_ModEnd> ( rb , <S2SV_ModStart> ref ] ; RefBuffer * const ref_frame = & <S2SV_ModStart> [ i ] ; ref_frame -> <S2SV_ModEnd> idx = idx <S2SV_ModStart> = idx ; ref_frame -> buf = & frame_bufs [ idx <S2SV_ModEnd> ] . buf <S2SV_ModStart> ] . buf <S2SV_ModEnd> ; cm -> <S2SV_ModStart> i ] = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> -> allow_high_precision_mv = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) <S2SV_ModStart> i ] ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame <S2SV_ModEnd> ( & ref_buf <S2SV_ModStart> ref_buf -> sf , <S2SV_ModEnd> ref_buf -> buf <S2SV_ModStart> ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height ) ; # endif } } } # if CONFIG_VP9_HIGHBITDEPTH get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; # endif get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; if ( pbi -> need_resync ) { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder"" ""<S2SV_blank>state"" ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> { cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ; cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; } else { cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; } cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; lock_buffer_pool ( pool ) ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { if ( mask & 1 ) { cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; ++ frame_bufs [ cm -> new_fb_idx ] . ref_count <S2SV_ModEnd> ; } else <S2SV_ModStart> { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; } if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( frame_is_intra_only <S2SV_ModStart> rb ) ; setup_segmentation_dequant ( cm ) ; <S2SV_ModStart> ; sz = vpx_rb_read_literal <S2SV_ModEnd> ( rb ,"
675,"void wb_print ( netdissect_options * ndo , register const void * hdr , register u_int len ) { register const struct pkt_hdr * ph ; ph = ( const struct pkt_hdr * ) hdr ; if ( len < sizeof ( * ph ) || ! ND_TTEST ( * ph ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } len -= sizeof ( * ph ) ; if ( ph -> ph_flags ) ND_PRINT ( ( ndo , ""*"" ) ) ; switch ( ph -> ph_type ) { case PT_KILL : ND_PRINT ( ( ndo , ""<S2SV_blank>wb-kill"" ) ) ; return ; case PT_ID : if ( wb_id ( ndo , ( const struct pkt_id * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 ) <S2SV_StartBug> return ; <S2SV_EndBug> break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>wb-%d!"" , ph -> ph_type ) ) ; return ; } }",") return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> 0 ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) )"
676,"static int snd_timer_user_release ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; if ( file -> private_data ) { tu = file -> private_data ; file -> private_data = NULL ; <S2SV_StartBug> if ( tu -> timeri ) <S2SV_EndBug> <S2SV_StartBug> snd_timer_close ( tu -> timeri ) ; <S2SV_EndBug> kfree ( tu -> queue ) ; kfree ( tu -> tqueue ) ; kfree ( tu ) ; } return 0 ; }",= NULL ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> tu -> timeri ) ; mutex_unlock ( & tu -> ioctl_lock
677,"static void vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , ""No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing"" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , ""Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { <S2SV_EndBug> fprintf ( tf , ""%d\\n"" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , ""Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s"" , tfile -> fname ) ; } }",( tf = fopen_safe <S2SV_ModEnd> ( tfile ->
678,"static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; <S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> }",refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
679,"static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ; <S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , ""packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>"" ""extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n"" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , ""Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n"" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , ""Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; } <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\n"" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ; <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Error<S2SV_blank>decoding<S2SV_blank>frame\\n"" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }","; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if"
680,"int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; <S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }",; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
681,"int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }","2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd"
682,"<S2SV_StartBug> static void fdct4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int16_t step [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> step [ 0 ] = input [ 0 ] + input [ 3 ] ; step [ 1 ] = input [ 1 ] + input [ 2 ] ; step [ 2 ] = input [ 1 ] - input [ 2 ] ; step [ 3 ] = input [ 0 ] - input [ 3 ] ; temp1 = ( step [ 0 ] + step [ 1 ] ) * cospi_16_64 ; temp2 = ( step [ 0 ] - step [ 1 ] ) * cospi_16_64 ; <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> output [ 2 ] = fdct_round_shift ( temp2 ) ; temp1 = step [ 2 ] * cospi_24_64 + step [ 3 ] * cospi_8_64 ; temp2 = - step [ 2 ] * cospi_8_64 + step [ 3 ] * cospi_24_64 ; <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> output [ 3 ] = fdct_round_shift ( temp2 ) ; }","fdct4 ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output ) <S2SV_ModStart> output ) { tran_high_t <S2SV_ModEnd> step [ 4 <S2SV_ModStart> 4 ] ; tran_high_t <S2SV_ModEnd> temp1 , temp2 <S2SV_ModStart> 0 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 2 ] = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( temp2 <S2SV_ModStart> 1 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 3 ] = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( temp2"
683,"GPLOT * gplotCreate ( const char * rootname , l_int32 outformat , const char * title , const char * xlabel , const char * ylabel ) { char * newroot ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 badchar ; GPLOT * gplot ; PROCNAME ( ""gplotCreate"" ) ; if ( ! rootname ) return ( GPLOT * ) ERROR_PTR ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( outformat != GPLOT_PNG && outformat != GPLOT_PS && outformat != GPLOT_EPS && outformat != GPLOT_LATEX ) return ( GPLOT * ) ERROR_PTR ( ""outformat<S2SV_blank>invalid"" , procName , NULL ) ; stringCheckForChars ( rootname , ""`;&|><\\""?*"" , & badchar ) ; if ( badchar ) return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>rootname"" , procName , NULL ) ; if ( ( gplot = ( GPLOT * ) LEPT_CALLOC ( 1 , sizeof ( GPLOT ) ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( ""gplot<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; gplot -> cmddata = sarrayCreate ( 0 ) ; gplot -> datanames = sarrayCreate ( 0 ) ; gplot -> plotdata = sarrayCreate ( 0 ) ; gplot -> plottitles = sarrayCreate ( 0 ) ; gplot -> plotstyles = numaCreate ( 0 ) ; newroot = genPathname ( rootname , NULL ) ; gplot -> rootname = newroot ; gplot -> outformat = outformat ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ; <S2SV_EndBug> gplot -> cmdname = stringNew ( buf ) ; if ( outformat == GPLOT_PNG ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_PS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_EPS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_LATEX ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ; <S2SV_EndBug> gplot -> outname = stringNew ( buf ) ; if ( title ) gplot -> title = stringNew ( title ) ; if ( xlabel ) gplot -> xlabel = stringNew ( xlabel ) ; if ( ylabel ) gplot -> ylabel = stringNew ( ylabel ) ; return gplot ; }","char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.cmd"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.png"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.ps"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.eps"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.tex"" ,"
684,"static int lldp_mgmt_addr_tlv_print ( netdissect_options * ndo , const u_char * pptr , u_int len ) { uint8_t mgmt_addr_len , intf_num_subtype , oid_len ; const u_char * tptr ; u_int tlen ; char * mgmt_addr ; tlen = len ; tptr = pptr ; if ( tlen < 1 ) { return 0 ; } mgmt_addr_len = * tptr ++ ; tlen -- ; if ( tlen < mgmt_addr_len ) { return 0 ; } mgmt_addr = lldp_network_addr_print ( ndo , tptr , mgmt_addr_len ) ; if ( mgmt_addr == NULL ) { return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>%s"" , mgmt_addr_len , mgmt_addr ) ) ; tptr += mgmt_addr_len ; tlen -= mgmt_addr_len ; if ( tlen < LLDP_INTF_NUM_LEN ) { return 0 ; } intf_num_subtype = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Interface<S2SV_blank>Numbering<S2SV_blank>(%u):<S2SV_blank>%u"" , tok2str ( lldp_intf_numb_subtype_values , ""Unknown"" , intf_num_subtype ) , intf_num_subtype , EXTRACT_32BITS ( tptr + 1 ) ) ) ; tptr += LLDP_INTF_NUM_LEN ; tlen -= LLDP_INTF_NUM_LEN ; if ( tlen ) { oid_len = * tptr ; <S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> return 0 ; } if ( oid_len ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>OID<S2SV_blank>length<S2SV_blank>%u"" , oid_len ) ) ; safeputs ( ndo , tptr + 1 , oid_len ) ; } } return 1 ; }",( tlen < 1U +
685,"static void flatpak_proxy_client_init ( FlatpakProxyClient * client ) { init_side ( client , & client -> client_side ) ; init_side ( client , & client -> bus_side ) ; <S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client -> get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; client -> unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ; }",; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client ->
686,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> int i ; fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>filename\\n\\n"" ""Options:\\n"" , exec_name ) ; arg_show_usage ( stderr , all_args ) ; # if CONFIG_VP8_DECODER fprintf ( stderr , ""\\nVP8<S2SV_blank>Postprocessing<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp8_pp_args ) ; # endif fprintf ( stderr , ""\\nOutput<S2SV_blank>File<S2SV_blank>Patterns:\\n\\n"" ""<S2SV_blank><S2SV_blank>The<S2SV_blank>-o<S2SV_blank>argument<S2SV_blank>specifies<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>"" ""write<S2SV_blank>to.<S2SV_blank>If<S2SV_blank>the\\n<S2SV_blank><S2SV_blank>argument<S2SV_blank>does<S2SV_blank>not<S2SV_blank>include<S2SV_blank>any<S2SV_blank>escape<S2SV_blank>"" ""characters,<S2SV_blank>the<S2SV_blank>output<S2SV_blank>will<S2SV_blank>be\\n<S2SV_blank><S2SV_blank>written<S2SV_blank>to<S2SV_blank>a<S2SV_blank>single<S2SV_blank>file.<S2SV_blank>"" ""Otherwise,<S2SV_blank>the<S2SV_blank>filename<S2SV_blank>will<S2SV_blank>be<S2SV_blank>calculated<S2SV_blank>by\\n<S2SV_blank><S2SV_blank>expanding<S2SV_blank>"" ""the<S2SV_blank>following<S2SV_blank>escape<S2SV_blank>characters:\\n"" ) ; fprintf ( stderr , ""\\n\\t%%w<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>Frame<S2SV_blank>width"" ""\\n\\t%%h<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>Frame<S2SV_blank>height"" ""\\n\\t%%<n><S2SV_blank>-<S2SV_blank>Frame<S2SV_blank>number,<S2SV_blank>zero<S2SV_blank>padded<S2SV_blank>to<S2SV_blank><n><S2SV_blank>places<S2SV_blank>(1..9)"" ""\\n\\n<S2SV_blank><S2SV_blank>Pattern<S2SV_blank>arguments<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>conjunction<S2SV_blank>"" ""with<S2SV_blank>the<S2SV_blank>--yv12<S2SV_blank>and\\n<S2SV_blank><S2SV_blank>--i420<S2SV_blank>options.<S2SV_blank>If<S2SV_blank>the<S2SV_blank>-o<S2SV_blank>option<S2SV_blank>is<S2SV_blank>"" ""not<S2SV_blank>specified,<S2SV_blank>the<S2SV_blank>output<S2SV_blank>will<S2SV_blank>be\\n<S2SV_blank><S2SV_blank>directed<S2SV_blank>to<S2SV_blank>stdout.\\n"" ) ; fprintf ( stderr , ""\\nIncluded<S2SV_blank>decoders:\\n\\n"" ) ; for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n"" , <S2SV_StartBug> decoder -> name , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> } exit ( EXIT_FAILURE ) ; }",void usage_exit ( void <S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) )
687,"static int skt_read ( int fd , void * p , size_t len ) { int read ; struct pollfd pfd ; struct timespec ts ; FNLOG ( ) ; ts_log ( ""skt_read<S2SV_blank>recv"" , len , NULL ) ; <S2SV_StartBug> if ( ( read = recv ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> { ERROR ( ""write<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>errno=%d\\n"" , errno ) ; return - 1 ; } return read ; }","( read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_NOSIGNAL )"
688,"void vp8_remove_compressor ( VP8_COMP * * ptr ) { VP8_COMP * cpi = * ptr ; if ( ! cpi ) return ; if ( cpi && ( cpi -> common . current_video_frame > 0 ) ) { # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 2 ) { vp8_end_second_pass ( cpi ) ; } # endif # ifdef VP8_ENTROPY_STATS print_context_counters ( ) ; print_tree_update_probs ( ) ; print_mode_context ( ) ; # endif # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""opsnr.stt"" , ""a"" ) ; double time_encoded = ( cpi -> last_end_time_stamp_seen - cpi -> first_time_stamp_ever ) / 10000000.000 ; double total_encode_time = ( cpi -> time_receive_data + cpi -> time_compress_data ) / 1000.000 ; double dr = ( double ) cpi -> bytes * 8.0 / 1000.0 / time_encoded ; if ( cpi -> b_calculate_psnr ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * lst_yv12 = <S2SV_EndBug> & cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] ; if ( cpi -> oxcf . number_of_layers > 1 ) { int i ; fprintf ( f , ""Layer\\tBitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t"" ""GLPsnrP\\tVPXSSIM\\t\\n"" ) ; for ( i = 0 ; i < ( int ) cpi -> oxcf . number_of_layers ; i ++ ) { double dr = ( double ) cpi -> bytes_in_layer [ i ] * 8.0 / 1000.0 / time_encoded ; double samples = 3.0 / 2 * cpi -> frames_in_layer [ i ] * <S2SV_StartBug> lst_yv12 -> y_width * lst_yv12 -> y_height ; <S2SV_EndBug> double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_error2 [ i ] ) ; double total_psnr2 = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_error2_p [ i ] ) ; double total_ssim = 100 * pow ( cpi -> sum_ssim [ i ] / cpi -> sum_weights [ i ] , 8.0 ) ; fprintf ( f , ""%5d\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t"" ""%7.3f\\t%7.3f\\n"" , i , dr , cpi -> sum_psnr [ i ] / cpi -> frames_in_layer [ i ] , total_psnr , cpi -> sum_psnr_p [ i ] / cpi -> frames_in_layer [ i ] , total_psnr2 , total_ssim ) ; } } else { double samples = 3.0 / 2 * cpi -> count * <S2SV_StartBug> lst_yv12 -> y_width * lst_yv12 -> y_height ; <S2SV_EndBug> double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_sq_error ) ; double total_psnr2 = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_sq_error2 ) ; double total_ssim = 100 * pow ( cpi -> summed_quality / cpi -> summed_weights , 8.0 ) ; fprintf ( f , ""Bitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t"" ""GLPsnrP\\tVPXSSIM\\t<S2SV_blank><S2SV_blank>Time(us)\\n"" ) ; fprintf ( f , ""%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t"" ""%7.3f\\t%8.0f\\n"" , dr , cpi -> total / cpi -> count , total_psnr , cpi -> totalp / cpi -> count , total_psnr2 , total_ssim , total_encode_time ) ; } } if ( cpi -> b_calculate_ssimg ) { if ( cpi -> oxcf . number_of_layers > 1 ) { int i ; fprintf ( f , ""Layer\\tBitRate\\tSSIM_Y\\tSSIM_U\\tSSIM_V\\tSSIM_A\\t"" ""Time(us)\\n"" ) ; for ( i = 0 ; i < ( int ) cpi -> oxcf . number_of_layers ; i ++ ) { double dr = ( double ) cpi -> bytes_in_layer [ i ] * 8.0 / 1000.0 / time_encoded ; fprintf ( f , ""%5d\\t%7.3f\\t%6.4f\\t"" ""%6.4f\\t%6.4f\\t%6.4f\\t%8.0f\\n"" , i , dr , cpi -> total_ssimg_y_in_layer [ i ] / cpi -> frames_in_layer [ i ] , cpi -> total_ssimg_u_in_layer [ i ] / cpi -> frames_in_layer [ i ] , cpi -> total_ssimg_v_in_layer [ i ] / cpi -> frames_in_layer [ i ] , cpi -> total_ssimg_all_in_layer [ i ] / cpi -> frames_in_layer [ i ] , total_encode_time ) ; } } else { fprintf ( f , ""BitRate\\tSSIM_Y\\tSSIM_U\\tSSIM_V\\tSSIM_A\\t"" ""Time(us)\\n"" ) ; fprintf ( f , ""%7.3f\\t%6.4f\\t%6.4f\\t%6.4f\\t%6.4f\\t%8.0f\\n"" , dr , cpi -> total_ssimg_y / cpi -> count , cpi -> total_ssimg_u / cpi -> count , cpi -> total_ssimg_v / cpi -> count , cpi -> total_ssimg_all / cpi -> count , total_encode_time ) ; } } fclose ( f ) ; # if 0 f = fopen ( ""qskip.stt"" , ""a"" ) ; fprintf ( f , ""minq:%d<S2SV_blank>-maxq:%d<S2SV_blank>skiptrue:skipfalse<S2SV_blank>=<S2SV_blank>%d:%d\\n"" , cpi -> oxcf . best_allowed_q , cpi -> oxcf . worst_allowed_q , skiptruecount , skipfalsecount ) ; fclose ( f ) ; # endif } # endif # ifdef SPEEDSTATS if ( cpi -> compressor_speed == 2 ) { int i ; FILE * f = fopen ( ""cxspeed.stt"" , ""a"" ) ; cnt_pm /= cpi -> common . MBs ; for ( i = 0 ; i < 16 ; i ++ ) fprintf ( f , ""%5d"" , frames_at_speed [ i ] ) ; fprintf ( f , ""\\n"" ) ; fclose ( f ) ; } # endif # ifdef MODE_STATS { extern int count_mb_seg [ 4 ] ; FILE * f = fopen ( ""modes.stt"" , ""a"" ) ; double dr = ( double ) cpi -> framerate * ( double ) bytes * ( double ) 8 / ( double ) count / ( double ) 1000 ; fprintf ( f , ""intra_mode<S2SV_blank>in<S2SV_blank>Intra<S2SV_blank>Frames:\\n"" ) ; fprintf ( f , ""Y:<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n"" , y_modes [ 0 ] , y_modes [ 1 ] , y_modes [ 2 ] , y_modes [ 3 ] , y_modes [ 4 ] ) ; fprintf ( f , ""UV:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n"" , uv_modes [ 0 ] , uv_modes [ 1 ] , uv_modes [ 2 ] , uv_modes [ 3 ] ) ; fprintf ( f , ""B:<S2SV_blank>"" ) ; { int i ; for ( i = 0 ; i < 10 ; i ++ ) fprintf ( f , ""%8d,<S2SV_blank>"" , b_modes [ i ] ) ; fprintf ( f , ""\\n"" ) ; } fprintf ( f , ""Modes<S2SV_blank>in<S2SV_blank>Inter<S2SV_blank>Frames:\\n"" ) ; fprintf ( f , ""Y:<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n"" , inter_y_modes [ 0 ] , inter_y_modes [ 1 ] , inter_y_modes [ 2 ] , inter_y_modes [ 3 ] , inter_y_modes [ 4 ] , inter_y_modes [ 5 ] , inter_y_modes [ 6 ] , inter_y_modes [ 7 ] , inter_y_modes [ 8 ] , inter_y_modes [ 9 ] ) ; fprintf ( f , ""UV:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n"" , inter_uv_modes [ 0 ] , inter_uv_modes [ 1 ] , inter_uv_modes [ 2 ] , inter_uv_modes [ 3 ] ) ; fprintf ( f , ""B:<S2SV_blank>"" ) ; { int i ; for ( i = 0 ; i < 15 ; i ++ ) fprintf ( f , ""%8d,<S2SV_blank>"" , inter_b_modes [ i ] ) ; fprintf ( f , ""\\n"" ) ; } fprintf ( f , ""P:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n"" , count_mb_seg [ 0 ] , count_mb_seg [ 1 ] , count_mb_seg [ 2 ] , count_mb_seg [ 3 ] ) ; fprintf ( f , ""PB:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n"" , inter_b_modes [ LEFT4X4 ] , inter_b_modes [ ABOVE4X4 ] , inter_b_modes [ ZERO4X4 ] , inter_b_modes [ NEW4X4 ] ) ; fclose ( f ) ; } # endif # ifdef VP8_ENTROPY_STATS { int i , j , k ; FILE * fmode = fopen ( ""modecontext.c"" , ""w"" ) ; fprintf ( fmode , ""\\n#include<S2SV_blank>\\""entropymode.h\\""\\n\\n"" ) ; fprintf ( fmode , ""const<S2SV_blank>unsigned<S2SV_blank>int<S2SV_blank>vp8_kf_default_bmode_counts<S2SV_blank>"" ) ; fprintf ( fmode , ""[VP8_BINTRAMODES]<S2SV_blank>[VP8_BINTRAMODES]<S2SV_blank>[VP8_BINTRAMODES]<S2SV_blank>=\\n{\\n"" ) ; for ( i = 0 ; i < 10 ; i ++ ) { fprintf ( fmode , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{<S2SV_blank>/*<S2SV_blank>Above<S2SV_blank>Mode<S2SV_blank>:<S2SV_blank><S2SV_blank>%d<S2SV_blank>*/\\n"" , i ) ; for ( j = 0 ; j < 10 ; j ++ ) { fprintf ( fmode , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{"" ) ; for ( k = 0 ; k < 10 ; k ++ ) { if ( ! intra_mode_stats [ i ] [ j ] [ k ] ) fprintf ( fmode , ""<S2SV_blank>%5d,<S2SV_blank>"" , 1 ) ; else fprintf ( fmode , ""<S2SV_blank>%5d,<S2SV_blank>"" , intra_mode_stats [ i ] [ j ] [ k ] ) ; } fprintf ( fmode , ""},<S2SV_blank>/*<S2SV_blank>left_mode<S2SV_blank>%d<S2SV_blank>*/\\n"" , j ) ; } fprintf ( fmode , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>},\\n"" ) ; } fprintf ( fmode , ""};\\n"" ) ; fclose ( fmode ) ; } # endif # if defined ( SECTIONBITS_OUTPUT ) if ( 0 ) { int i ; FILE * f = fopen ( ""tokenbits.stt"" , ""a"" ) ; for ( i = 0 ; i < 28 ; i ++ ) fprintf ( f , ""%8d"" , ( int ) ( Sectionbits [ i ] / 256 ) ) ; fprintf ( f , ""\\n"" ) ; fclose ( f ) ; } # endif # if 0 { printf ( ""\\n_pick_loop_filter_level:%d\\n"" , cpi -> time_pick_lpf / 1000 ) ; printf ( ""\\n_frames<S2SV_blank>recive_data<S2SV_blank>encod_mb_row<S2SV_blank>compress_frame<S2SV_blank><S2SV_blank>Total\\n"" ) ; printf ( ""%6d<S2SV_blank>%10ld<S2SV_blank>%10ld<S2SV_blank>%10ld<S2SV_blank>%10ld\\n"" , cpi -> common . current_video_frame , cpi -> time_receive_data / 1000 , cpi -> time_encode_mb_row / 1000 , cpi -> time_compress_data / 1000 , ( cpi -> time_receive_data + cpi -> time_compress_data ) / 1000 ) ; } # endif } # if CONFIG_MULTITHREAD vp8cx_remove_encoder_threads ( cpi ) ; # endif # if CONFIG_TEMPORAL_DENOISING vp8_denoiser_free ( & cpi -> denoiser ) ; # endif dealloc_compressor_data ( cpi ) ; vpx_free ( cpi -> mb . ss ) ; vpx_free ( cpi -> tok ) ; vpx_free ( cpi -> cyclic_refresh_map ) ; <S2SV_StartBug> vp8_remove_common ( & cpi -> common ) ; <S2SV_EndBug> vpx_free ( cpi ) ; * ptr = 0 ; # ifdef OUTPUT_YUV_SRC fclose ( yuv_file ) ; # endif <S2SV_StartBug> # if 0 <S2SV_EndBug> if ( keyfile ) fclose ( keyfile ) ; if ( framepsnr ) fclose ( framepsnr ) ; if ( kf_list ) fclose ( kf_list ) ; # endif }",b_calculate_psnr ) { <S2SV_ModEnd> if ( cpi <S2SV_ModStart> i ] * cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> ; double total_psnr <S2SV_ModStart> -> count * cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> ; double total_psnr <S2SV_ModStart> cyclic_refresh_map ) ; vpx_free ( cpi -> consec_zero_last ) ; vpx_free ( cpi -> consec_zero_last_mvbias ) ; <S2SV_ModStart> # endif # ifdef OUTPUT_YUV_DENOISED fclose ( yuv_denoised_file ) ; # endif #
689,<S2SV_StartBug> static void init_decoder ( vpx_codec_alg_priv_t * ctx ) { <S2SV_EndBug> <S2SV_StartBug> VP9D_CONFIG oxcf ; <S2SV_EndBug> oxcf . width = ctx -> si . w ; oxcf . height = ctx -> si . h ; oxcf . version = 9 ; <S2SV_StartBug> oxcf . max_threads = ctx -> cfg . threads ; <S2SV_EndBug> oxcf . inv_tile_order = ctx -> invert_tile_order ; <S2SV_StartBug> ctx -> pbi = vp9_decoder_create ( & oxcf ) ; <S2SV_EndBug> if ( ctx -> pbi == NULL ) <S2SV_StartBug> return ; <S2SV_EndBug> vp9_initialize_dec ( ) ; if ( ! ctx -> postproc_cfg_set && ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) ) set_default_ppflags ( & ctx -> postproc_cfg ) ; init_buffer_callbacks ( ctx ) ; <S2SV_StartBug> } <S2SV_EndBug>,"<S2SV_null> <S2SV_null> static vpx_codec_err_t <S2SV_ModEnd> init_decoder ( vpx_codec_alg_priv_t <S2SV_ModStart> ctx ) { int i ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ctx -> last_show_frame = - 1 ; ctx -> next_submit_worker_id = 0 ; ctx -> last_submit_worker_id = 0 ; ctx -> next_output_worker_id = 0 ; ctx -> frame_cache_read = 0 ; ctx -> frame_cache_write = 0 ; ctx -> num_cache_frames = 0 ; ctx -> need_resync = 1 ; ctx -> num_frame_workers = ( ctx -> frame_parallel_decode == 1 ) ? <S2SV_ModEnd> ctx -> cfg <S2SV_ModStart> cfg . threads : 1 ; if ( ctx -> num_frame_workers > MAX_DECODE_THREADS ) ctx -> num_frame_workers = MAX_DECODE_THREADS ; ctx -> available_threads = ctx -> num_frame_workers ; ctx -> flushed = 0 ; ctx -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( ctx -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & ctx -> buffer_pool -> pool_mutex , NULL ) ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>pool<S2SV_blank>mutex"" ) ; return VPX_CODEC_MEM_ERROR ; } # endif ctx -> frame_workers = ( VPxWorker * ) vpx_malloc ( ctx -> num_frame_workers * sizeof ( * ctx -> frame_workers ) ) ; if ( ctx -> frame_workers == NULL ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_workers"" ) ; return VPX_CODEC_MEM_ERROR ; } for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * frame_worker_data = NULL ; winterface -> init ( worker ) ; worker -> data1 = vpx_memalign ( 32 , sizeof ( FrameWorkerData ) ) ; if ( worker -> data1 == NULL ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data"" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data <S2SV_ModEnd> -> pbi = <S2SV_ModStart> = vp9_decoder_create ( ctx -> buffer_pool ) ; if ( frame_worker_data <S2SV_ModEnd> -> pbi == <S2SV_ModStart> == NULL ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data"" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> pbi -> frame_worker_owner = worker ; frame_worker_data -> worker_id = i ; frame_worker_data -> scratch_buffer = NULL ; frame_worker_data -> scratch_buffer_size = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame = 0 ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & frame_worker_data -> stats_mutex , NULL ) ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>mutex"" ) ; return VPX_CODEC_MEM_ERROR ; } if ( pthread_cond_init ( & frame_worker_data -> stats_cond , NULL ) ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>cond"" ) ; return VPX_CODEC_MEM_ERROR ; } # endif frame_worker_data -> pbi -> max_threads = ( ctx -> frame_parallel_decode == 0 ) ? ctx -> cfg . threads : 0 ; frame_worker_data -> pbi -> inv_tile_order = ctx -> invert_tile_order ; frame_worker_data -> pbi -> frame_parallel_decode = ctx -> frame_parallel_decode ; frame_worker_data -> pbi -> common . frame_parallel_decode = ctx -> frame_parallel_decode ; worker -> hook = ( VPxWorkerHook ) frame_worker_hook ; if ( ! winterface -> reset ( worker ) ) { set_error_detail ( ctx , ""Frame<S2SV_blank>Worker<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; return VPX_CODEC_MEM_ERROR ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ctx ) ; return VPX_CODEC_OK ;"
690,"static int <S2SV_StartBug> mptctl_eventreport ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_eventreport __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_eventreport karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int numBytes , maxEvents , max ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventreport ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventreport<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_eventreport<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventreport()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventreport<S2SV_blank>called.\\n"" , ioc -> name ) ) ; numBytes = karg . hdr . maxDataSize - sizeof ( mpt_ioctl_header ) ; maxEvents = numBytes / sizeof ( MPT_IOCTL_EVENTS ) ; max = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents ; if ( ( max < 1 ) || ! ioc -> events ) return - ENODATA ; ioc -> aen_event_read_flag = 0 ; numBytes = max * sizeof ( MPT_IOCTL_EVENTS ) ; if ( copy_to_user ( uarg -> eventData , ioc -> events , numBytes ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventreport<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_eventreport<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , ioc -> events ) ; return - EFAULT ; } return 0 ; }","int mptctl_eventreport ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_eventreport karg ; <S2SV_ModEnd> int numBytes , <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk"
691,"static ssize_t k90_show_current_profile ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int current_profile ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } current_profile = data [ 7 ] ; if ( current_profile < 1 || current_profile > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n"" , data [ 7 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; }","current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>"
692,"long kvm_arch_vm_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) { struct kvm * kvm = filp -> private_data ; void __user * argp = ( void __user * ) arg ; int r = - ENOTTY ; union { struct kvm_pit_state ps ; struct kvm_pit_state2 ps2 ; struct kvm_pit_config pit_config ; } u ; switch ( ioctl ) { case KVM_SET_TSS_ADDR : r = kvm_vm_ioctl_set_tss_addr ( kvm , arg ) ; if ( r < 0 ) goto out ; break ; case KVM_SET_IDENTITY_MAP_ADDR : { u64 ident_addr ; r = - EFAULT ; if ( copy_from_user ( & ident_addr , argp , sizeof ident_addr ) ) goto out ; r = kvm_vm_ioctl_set_identity_map_addr ( kvm , ident_addr ) ; if ( r < 0 ) goto out ; break ; } case KVM_SET_NR_MMU_PAGES : r = kvm_vm_ioctl_set_nr_mmu_pages ( kvm , arg ) ; if ( r ) goto out ; break ; case KVM_GET_NR_MMU_PAGES : r = kvm_vm_ioctl_get_nr_mmu_pages ( kvm ) ; break ; case KVM_CREATE_IRQCHIP : { struct kvm_pic * vpic ; mutex_lock ( & kvm -> lock ) ; r = - EEXIST ; if ( kvm -> arch . vpic ) goto create_irqchip_unlock ; <S2SV_StartBug> r = - ENOMEM ; <S2SV_EndBug> vpic = kvm_create_pic ( kvm ) ; if ( vpic ) { r = kvm_ioapic_init ( kvm ) ; if ( r ) { mutex_lock ( & kvm -> slots_lock ) ; kvm_io_bus_unregister_dev ( kvm , KVM_PIO_BUS , & vpic -> dev_master ) ; kvm_io_bus_unregister_dev ( kvm , KVM_PIO_BUS , & vpic -> dev_slave ) ; kvm_io_bus_unregister_dev ( kvm , KVM_PIO_BUS , & vpic -> dev_eclr ) ; mutex_unlock ( & kvm -> slots_lock ) ; kfree ( vpic ) ; goto create_irqchip_unlock ; } } else goto create_irqchip_unlock ; smp_wmb ( ) ; kvm -> arch . vpic = vpic ; smp_wmb ( ) ; r = kvm_setup_default_irq_routing ( kvm ) ; if ( r ) { mutex_lock ( & kvm -> slots_lock ) ; mutex_lock ( & kvm -> irq_lock ) ; kvm_ioapic_destroy ( kvm ) ; kvm_destroy_pic ( kvm ) ; mutex_unlock ( & kvm -> irq_lock ) ; mutex_unlock ( & kvm -> slots_lock ) ; } create_irqchip_unlock : mutex_unlock ( & kvm -> lock ) ; break ; } case KVM_CREATE_PIT : u . pit_config . flags = KVM_PIT_SPEAKER_DUMMY ; goto create_pit ; case KVM_CREATE_PIT2 : r = - EFAULT ; if ( copy_from_user ( & u . pit_config , argp , sizeof ( struct kvm_pit_config ) ) ) goto out ; create_pit : mutex_lock ( & kvm -> slots_lock ) ; r = - EEXIST ; if ( kvm -> arch . vpit ) goto create_pit_unlock ; r = - ENOMEM ; kvm -> arch . vpit = kvm_create_pit ( kvm , u . pit_config . flags ) ; if ( kvm -> arch . vpit ) r = 0 ; create_pit_unlock : mutex_unlock ( & kvm -> slots_lock ) ; break ; case KVM_IRQ_LINE_STATUS : case KVM_IRQ_LINE : { struct kvm_irq_level irq_event ; r = - EFAULT ; if ( copy_from_user ( & irq_event , argp , sizeof irq_event ) ) goto out ; r = - ENXIO ; if ( irqchip_in_kernel ( kvm ) ) { __s32 status ; status = kvm_set_irq ( kvm , KVM_USERSPACE_IRQ_SOURCE_ID , irq_event . irq , irq_event . level ) ; if ( ioctl == KVM_IRQ_LINE_STATUS ) { r = - EFAULT ; irq_event . status = status ; if ( copy_to_user ( argp , & irq_event , sizeof irq_event ) ) goto out ; } r = 0 ; } break ; } case KVM_GET_IRQCHIP : { struct kvm_irqchip * chip ; chip = memdup_user ( argp , sizeof ( * chip ) ) ; if ( IS_ERR ( chip ) ) { r = PTR_ERR ( chip ) ; goto out ; } r = - ENXIO ; if ( ! irqchip_in_kernel ( kvm ) ) goto get_irqchip_out ; r = kvm_vm_ioctl_get_irqchip ( kvm , chip ) ; if ( r ) goto get_irqchip_out ; r = - EFAULT ; if ( copy_to_user ( argp , chip , sizeof * chip ) ) goto get_irqchip_out ; r = 0 ; get_irqchip_out : kfree ( chip ) ; if ( r ) goto out ; break ; } case KVM_SET_IRQCHIP : { struct kvm_irqchip * chip ; chip = memdup_user ( argp , sizeof ( * chip ) ) ; if ( IS_ERR ( chip ) ) { r = PTR_ERR ( chip ) ; goto out ; } r = - ENXIO ; if ( ! irqchip_in_kernel ( kvm ) ) goto set_irqchip_out ; r = kvm_vm_ioctl_set_irqchip ( kvm , chip ) ; if ( r ) goto set_irqchip_out ; r = 0 ; set_irqchip_out : kfree ( chip ) ; if ( r ) goto out ; break ; } case KVM_GET_PIT : { r = - EFAULT ; if ( copy_from_user ( & u . ps , argp , sizeof ( struct kvm_pit_state ) ) ) goto out ; r = - ENXIO ; if ( ! kvm -> arch . vpit ) goto out ; r = kvm_vm_ioctl_get_pit ( kvm , & u . ps ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , & u . ps , sizeof ( struct kvm_pit_state ) ) ) goto out ; r = 0 ; break ; } case KVM_SET_PIT : { r = - EFAULT ; if ( copy_from_user ( & u . ps , argp , sizeof u . ps ) ) goto out ; r = - ENXIO ; if ( ! kvm -> arch . vpit ) goto out ; r = kvm_vm_ioctl_set_pit ( kvm , & u . ps ) ; if ( r ) goto out ; r = 0 ; break ; } case KVM_GET_PIT2 : { r = - ENXIO ; if ( ! kvm -> arch . vpit ) goto out ; r = kvm_vm_ioctl_get_pit2 ( kvm , & u . ps2 ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , & u . ps2 , sizeof ( u . ps2 ) ) ) goto out ; r = 0 ; break ; } case KVM_SET_PIT2 : { r = - EFAULT ; if ( copy_from_user ( & u . ps2 , argp , sizeof ( u . ps2 ) ) ) goto out ; r = - ENXIO ; if ( ! kvm -> arch . vpit ) goto out ; r = kvm_vm_ioctl_set_pit2 ( kvm , & u . ps2 ) ; if ( r ) goto out ; r = 0 ; break ; } case KVM_REINJECT_CONTROL : { struct kvm_reinject_control control ; r = - EFAULT ; if ( copy_from_user ( & control , argp , sizeof ( control ) ) ) goto out ; r = kvm_vm_ioctl_reinject ( kvm , & control ) ; if ( r ) goto out ; r = 0 ; break ; } case KVM_XEN_HVM_CONFIG : { r = - EFAULT ; if ( copy_from_user ( & kvm -> arch . xen_hvm_config , argp , sizeof ( struct kvm_xen_hvm_config ) ) ) goto out ; r = - EINVAL ; if ( kvm -> arch . xen_hvm_config . flags ) goto out ; r = 0 ; break ; } case KVM_SET_CLOCK : { struct kvm_clock_data user_ns ; u64 now_ns ; s64 delta ; r = - EFAULT ; if ( copy_from_user ( & user_ns , argp , sizeof ( user_ns ) ) ) goto out ; r = - EINVAL ; if ( user_ns . flags ) goto out ; r = 0 ; local_irq_disable ( ) ; now_ns = get_kernel_ns ( ) ; delta = user_ns . clock - now_ns ; local_irq_enable ( ) ; kvm -> arch . kvmclock_offset = delta ; break ; } case KVM_GET_CLOCK : { struct kvm_clock_data user_ns ; u64 now_ns ; local_irq_disable ( ) ; now_ns = get_kernel_ns ( ) ; user_ns . clock = kvm -> arch . kvmclock_offset + now_ns ; local_irq_enable ( ) ; user_ns . flags = 0 ; memset ( & user_ns . pad , 0 , sizeof ( user_ns . pad ) ) ; r = - EFAULT ; if ( copy_to_user ( argp , & user_ns , sizeof ( user_ns ) ) ) goto out ; r = 0 ; break ; } default : ; } out : return r ; }",r = - EINVAL ; if ( atomic_read ( & kvm -> online_vcpus ) ) goto create_irqchip_unlock ; r = -
693,static void nodeDestruct ( struct SaveNode * node ) { <S2SV_StartBug> if ( node -> v == & node -> sorted ) <S2SV_EndBug> { <S2SV_StartBug> tr_free ( node -> sorted . val . l . vals ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> },node ) { TR_ASSERT ( node != NULL ) ; <S2SV_ModStart> ( node -> sorted != NULL <S2SV_ModEnd> ) { tr_free <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> vals ) ; tr_free ( node -> sorted ) ;
694,"TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }","return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if"
695,"PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( ""ptaReadStream"" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( ! strcmp ( typestr , ""float"" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( ""pta<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n"" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>floats"" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>ints"" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }","( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> , & n"
696,"static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }",arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
697,"static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * image ; QuantumInfo * quantum_info ; QuantumType quantum_type ; MagickBooleanType status ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } SetImageColorspace ( image , GRAYColorspace ) ; quantum_type = IndexQuantum ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register PixelPacket * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; ( void ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , GetQuantumPixels ( quantum_info ) , & count ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",") length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; }"
698,char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; },) { return NULL <S2SV_ModEnd> ; } while
699,"int main ( int argc , char * * argv ) { char * oldshell ; int nullshell = 0 ; const uid_t uid = getuid ( ) ; struct sinfo info = { 0 } ; struct passwd * pw ; sanitize_env ( ) ; setlocale ( LC_ALL , """" ) ; bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; atexit ( close_stdout ) ; parse_argv ( argc , argv , & info ) ; if ( ! info . username ) { pw = getpwuid ( uid ) ; if ( ! pw ) errx ( EXIT_FAILURE , _ ( ""you<S2SV_blank>(user<S2SV_blank>%d)<S2SV_blank>don\'t<S2SV_blank>exist."" ) , uid ) ; } else { pw = getpwnam ( info . username ) ; if ( ! pw ) errx ( EXIT_FAILURE , _ ( ""user<S2SV_blank>\\""%s\\""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist."" ) , info . username ) ; } # ifndef HAVE_LIBUSER if ( ! ( is_local ( pw -> pw_name ) ) ) errx ( EXIT_FAILURE , _ ( ""can<S2SV_blank>only<S2SV_blank>change<S2SV_blank>local<S2SV_blank>entries"" ) ) ; # endif # ifdef HAVE_LIBSELINUX if ( is_selinux_enabled ( ) > 0 ) { if ( uid == 0 ) { if ( checkAccess ( pw -> pw_name , PASSWD__CHSH ) != 0 ) { security_context_t user_context ; if ( getprevcon ( & user_context ) < 0 ) user_context = ( security_context_t ) NULL ; errx ( EXIT_FAILURE , _ ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>change<S2SV_blank>the<S2SV_blank>shell<S2SV_blank>of<S2SV_blank>%s"" ) , user_context ? : _ ( ""Unknown<S2SV_blank>user<S2SV_blank>context"" ) , pw -> pw_name ) ; } } if ( setupDefaultContext ( _PATH_PASSWD ) != 0 ) errx ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>set<S2SV_blank>default<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%s"" ) , _PATH_PASSWD ) ; } # endif oldshell = pw -> pw_shell ; if ( oldshell == NULL || * oldshell == '\\0' ) { oldshell = _PATH_BSHELL ; nullshell = 1 ; } # ifdef HAVE_LIBUSER if ( geteuid ( ) != getuid ( ) && uid != pw -> pw_uid ) { # else if ( uid != 0 && uid != pw -> pw_uid ) { # endif errno = EACCES ; err ( EXIT_FAILURE , _ ( ""running<S2SV_blank>UID<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>UID<S2SV_blank>of<S2SV_blank>user<S2SV_blank>we\'re<S2SV_blank>"" ""altering,<S2SV_blank>shell<S2SV_blank>change<S2SV_blank>denied"" ) ) ; } if ( uid != 0 && ! get_shell_list ( oldshell ) ) { errno = EACCES ; err ( EXIT_FAILURE , _ ( ""your<S2SV_blank>shell<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>%s,<S2SV_blank>"" ""shell<S2SV_blank>change<S2SV_blank>denied"" ) , _PATH_SHELLS ) ; } printf ( _ ( ""Changing<S2SV_blank>shell<S2SV_blank>for<S2SV_blank>%s.\\n"" ) , pw -> pw_name ) ; # if ! defined ( HAVE_LIBUSER ) && defined ( CHFN_CHSH_PASSWORD ) if ( ! auth_pam ( ""chsh"" , uid , pw -> pw_name ) ) { return EXIT_FAILURE ; } # endif if ( ! info . shell ) { info . shell = ask_new_shell ( _ ( ""New<S2SV_blank>shell"" ) , oldshell ) ; if ( ! info . shell ) return EXIT_SUCCESS ; } check_shell ( info . shell ) ; if ( ! nullshell && strcmp ( oldshell , info . shell ) == 0 ) errx ( EXIT_SUCCESS , _ ( ""Shell<S2SV_blank>not<S2SV_blank>changed."" ) ) ; # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chsh"" , pw -> pw_name , uid , LU_LOGINSHELL , info . shell ) < 0 ) errx ( EXIT_FAILURE , _ ( ""Shell<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later."" ) ) ; # else pw -> pw_shell = info . shell ; <S2SV_StartBug> if ( setpwnam ( pw ) < 0 ) <S2SV_EndBug> err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\n"" ""Shell<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later."" ) ) ; # endif printf ( _ ( ""Shell<S2SV_blank>changed.\\n"" ) ) ; return EXIT_SUCCESS ; }","setpwnam ( pw , "".chsh"""
700,"void ndpi_parse_packet_line_info ( struct ndpi_detection_module_struct * ndpi_str , struct ndpi_flow_struct * flow ) { u_int32_t a ; struct ndpi_packet_struct * packet = & flow -> packet ; if ( ( packet -> payload_packet_len < 3 ) || ( packet -> payload == NULL ) ) return ; if ( packet -> packet_lines_parsed_complete != 0 ) return ; packet -> packet_lines_parsed_complete = 1 ; ndpi_reset_packet_line_info ( packet ) ; packet -> line [ packet -> parsed_lines ] . ptr = packet -> payload ; packet -> line [ packet -> parsed_lines ] . len = 0 ; for ( a = 0 ; ( a < packet -> payload_packet_len ) && ( packet -> parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET ) ; a ++ ) { if ( ( a + 1 ) >= packet -> payload_packet_len ) return ; if ( get_u_int16_t ( packet -> payload , a ) == ntohs ( 0x0d0a ) ) { if ( ( ( a + 3 ) <= packet -> payload_packet_len ) && ( get_u_int16_t ( packet -> payload , a + 2 ) == ntohs ( 0x0d0a ) ) ) { int diff ; u_int32_t a1 = a + 4 ; <S2SV_StartBug> diff = ndpi_min ( packet -> payload_packet_len - a1 , sizeof ( flow -> initial_binary_bytes ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( diff > 0 ) { <S2SV_EndBug> memcpy ( & flow -> initial_binary_bytes , & packet -> payload [ a1 ] , diff ) ; flow -> initial_binary_bytes_len = diff ; } } packet -> line [ packet -> parsed_lines ] . len = ( u_int16_t ) ( ( ( unsigned long ) & packet -> payload [ a ] ) - ( ( unsigned long ) packet -> line [ packet -> parsed_lines ] . ptr ) ) ; if ( packet -> parsed_lines == 0 && packet -> line [ 0 ] . len >= NDPI_STATICSTRING_LEN ( ""HTTP/1.X<S2SV_blank>200<S2SV_blank>"" ) && strncasecmp ( ( const char * ) packet -> line [ 0 ] . ptr , ""HTTP/1."" , NDPI_STATICSTRING_LEN ( ""HTTP/1."" ) ) == 0 && packet -> line [ 0 ] . ptr [ NDPI_STATICSTRING_LEN ( ""HTTP/1.X<S2SV_blank>"" ) ] > '0' && packet -> line [ 0 ] . ptr [ NDPI_STATICSTRING_LEN ( ""HTTP/1.X<S2SV_blank>"" ) ] < '6' ) { packet -> http_response . ptr = & packet -> line [ 0 ] . ptr [ NDPI_STATICSTRING_LEN ( ""HTTP/1.1<S2SV_blank>"" ) ] ; packet -> http_response . len = packet -> line [ 0 ] . len - NDPI_STATICSTRING_LEN ( ""HTTP/1.1<S2SV_blank>"" ) ; packet -> http_num_headers ++ ; if ( packet -> payload_packet_len >= 12 ) { char buf [ 4 ] ; strncpy ( buf , ( char * ) & packet -> payload [ 9 ] , 3 ) ; buf [ 3 ] = '\\0' ; flow -> http . response_status_code = atoi ( buf ) ; if ( ( flow -> http . response_status_code < 100 ) || ( flow -> http . response_status_code > 509 ) ) flow -> http . response_status_code = 0 ; } } if ( packet -> line [ packet -> parsed_lines ] . len > NDPI_STATICSTRING_LEN ( ""Server:"" ) + 1 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Server:"" , NDPI_STATICSTRING_LEN ( ""Server:"" ) ) == 0 ) { if ( packet -> line [ packet -> parsed_lines ] . ptr [ NDPI_STATICSTRING_LEN ( ""Server:"" ) ] == '<S2SV_blank>' ) { packet -> server_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ NDPI_STATICSTRING_LEN ( ""Server:"" ) + 1 ] ; packet -> server_line . len = packet -> line [ packet -> parsed_lines ] . len - ( NDPI_STATICSTRING_LEN ( ""Server:"" ) + 1 ) ; } else { packet -> server_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ NDPI_STATICSTRING_LEN ( ""Server:"" ) ] ; packet -> server_line . len = packet -> line [ packet -> parsed_lines ] . len - NDPI_STATICSTRING_LEN ( ""Server:"" ) ; } packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 6 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Host:"" , 5 ) == 0 ) { if ( packet -> line [ packet -> parsed_lines ] . ptr [ 5 ] == '<S2SV_blank>' ) { packet -> host_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 6 ] ; packet -> host_line . len = packet -> line [ packet -> parsed_lines ] . len - 6 ; } else { packet -> host_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 5 ] ; packet -> host_line . len = packet -> line [ packet -> parsed_lines ] . len - 5 ; } packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 17 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""X-Forwarded-For:"" , 16 ) == 0 ) { if ( packet -> line [ packet -> parsed_lines ] . ptr [ 16 ] == '<S2SV_blank>' ) { packet -> forwarded_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 17 ] ; packet -> forwarded_line . len = packet -> line [ packet -> parsed_lines ] . len - 17 ; } else { packet -> forwarded_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 16 ] ; packet -> forwarded_line . len = packet -> line [ packet -> parsed_lines ] . len - 16 ; } packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 14 && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Content-Type:<S2SV_blank>"" , 14 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Content-type:<S2SV_blank>"" , 14 ) == 0 ) ) { packet -> content_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 14 ] ; packet -> content_line . len = packet -> line [ packet -> parsed_lines ] . len - 14 ; while ( ( packet -> content_line . len > 0 ) && ( packet -> content_line . ptr [ 0 ] == '<S2SV_blank>' ) ) packet -> content_line . len -- , packet -> content_line . ptr ++ ; packet -> http_num_headers ++ ; } if ( ( packet -> content_line . len == 0 ) && ( packet -> line [ packet -> parsed_lines ] . len > 13 ) && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Content-type:"" , 13 ) == 0 ) ) { packet -> content_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 13 ] ; packet -> content_line . len = packet -> line [ packet -> parsed_lines ] . len - 13 ; packet -> http_num_headers ++ ; } if ( packet -> content_line . len > 0 ) { char separator [ ] = { ';' , '\\r' , '\\0' } ; int i ; for ( i = 0 ; separator [ i ] != '\\0' ; i ++ ) { char * c = memchr ( ( char * ) packet -> content_line . ptr , separator [ i ] , packet -> content_line . len ) ; if ( c != NULL ) packet -> content_line . len = c - ( char * ) packet -> content_line . ptr ; } } if ( packet -> line [ packet -> parsed_lines ] . len > 8 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Accept:<S2SV_blank>"" , 8 ) == 0 ) { packet -> accept_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 8 ] ; packet -> accept_line . len = packet -> line [ packet -> parsed_lines ] . len - 8 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 9 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Referer:<S2SV_blank>"" , 9 ) == 0 ) { packet -> referer_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 9 ] ; packet -> referer_line . len = packet -> line [ packet -> parsed_lines ] . len - 9 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 12 && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""User-Agent:<S2SV_blank>"" , 12 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""User-agent:<S2SV_blank>"" , 12 ) == 0 ) ) { packet -> user_agent_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 12 ] ; packet -> user_agent_line . len = packet -> line [ packet -> parsed_lines ] . len - 12 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 18 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Content-Encoding:<S2SV_blank>"" , 18 ) == 0 ) { packet -> http_encoding . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 18 ] ; packet -> http_encoding . len = packet -> line [ packet -> parsed_lines ] . len - 18 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 19 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Transfer-Encoding:<S2SV_blank>"" , 19 ) == 0 ) { packet -> http_transfer_encoding . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 19 ] ; packet -> http_transfer_encoding . len = packet -> line [ packet -> parsed_lines ] . len - 19 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 16 && ( ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Content-Length:<S2SV_blank>"" , 16 ) == 0 ) || ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""content-length:<S2SV_blank>"" , 16 ) == 0 ) ) ) { packet -> http_contentlen . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 16 ] ; packet -> http_contentlen . len = packet -> line [ packet -> parsed_lines ] . len - 16 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 21 && ( ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Content-Disposition:<S2SV_blank>"" , 21 ) == 0 ) ) ) { packet -> content_disposition_line . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 21 ] ; packet -> content_disposition_line . len = packet -> line [ packet -> parsed_lines ] . len - 21 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 8 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Cookie:<S2SV_blank>"" , 8 ) == 0 ) { packet -> http_cookie . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 8 ] ; packet -> http_cookie . len = packet -> line [ packet -> parsed_lines ] . len - 8 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 8 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Origin:<S2SV_blank>"" , 8 ) == 0 ) { packet -> http_origin . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 8 ] ; packet -> http_origin . len = packet -> line [ packet -> parsed_lines ] . len - 8 ; packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len > 16 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""X-Session-Type:<S2SV_blank>"" , 16 ) == 0 ) { packet -> http_x_session_type . ptr = & packet -> line [ packet -> parsed_lines ] . ptr [ 16 ] ; packet -> http_x_session_type . len = packet -> line [ packet -> parsed_lines ] . len - 16 ; packet -> http_num_headers ++ ; } if ( ( packet -> line [ packet -> parsed_lines ] . len > 6 && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Date:<S2SV_blank>"" , 6 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Vary:<S2SV_blank>"" , 6 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""ETag:<S2SV_blank>"" , 6 ) == 0 ) ) || ( packet -> line [ packet -> parsed_lines ] . len > 8 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Pragma:<S2SV_blank>"" , 8 ) == 0 ) || ( packet -> line [ packet -> parsed_lines ] . len > 9 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Expires:<S2SV_blank>"" , 9 ) == 0 ) || ( packet -> line [ packet -> parsed_lines ] . len > 12 && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Set-Cookie:<S2SV_blank>"" , 12 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Keep-Alive:<S2SV_blank>"" , 12 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Connection:<S2SV_blank>"" , 12 ) == 0 ) ) || ( packet -> line [ packet -> parsed_lines ] . len > 15 && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Last-Modified:<S2SV_blank>"" , 15 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Accept-Ranges:<S2SV_blank>"" , 15 ) == 0 ) ) || ( packet -> line [ packet -> parsed_lines ] . len > 17 && ( strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Accept-Language:<S2SV_blank>"" , 17 ) == 0 || strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Accept-Encoding:<S2SV_blank>"" , 17 ) == 0 ) ) || ( packet -> line [ packet -> parsed_lines ] . len > 27 && strncasecmp ( ( const char * ) packet -> line [ packet -> parsed_lines ] . ptr , ""Upgrade-Insecure-Requests:<S2SV_blank>"" , 27 ) == 0 ) ) { packet -> http_num_headers ++ ; } if ( packet -> line [ packet -> parsed_lines ] . len == 0 ) { packet -> empty_line_position = a ; packet -> empty_line_position_set = 1 ; } if ( packet -> parsed_lines >= ( NDPI_MAX_PARSE_LINES_PER_PACKET - 1 ) ) return ; packet -> parsed_lines ++ ; packet -> line [ packet -> parsed_lines ] . ptr = & packet -> payload [ a + 2 ] ; packet -> line [ packet -> parsed_lines ] . len = 0 ; a ++ ; } } if ( packet -> parsed_lines >= 1 ) { packet -> line [ packet -> parsed_lines ] . len = ( u_int16_t ) ( ( ( unsigned long ) & packet -> payload [ packet -> payload_packet_len ] ) - ( ( unsigned long ) packet -> line [ packet -> parsed_lines ] . ptr ) ) ; packet -> parsed_lines ++ ; } }","; diff = <S2SV_ModEnd> packet -> payload_packet_len <S2SV_ModStart> payload_packet_len - a1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ) { diff = ndpi_min ( diff , sizeof ( flow -> initial_binary_bytes ) ) ;"
701,"static RList * r_bin_wasm_get_data_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmDataEntry * ptr = NULL ; <S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; size_t n = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> offset . len = n ; if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> size , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> data = sec -> payload_data + i ; r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>",= NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
702,"void pango_glyph_string_set_size ( PangoGlyphString * string , gint new_len ) { g_return_if_fail ( new_len >= 0 ) ; while ( new_len > string -> space ) { if ( string -> space == 0 ) <S2SV_StartBug> string -> space = 1 ; <S2SV_EndBug> else <S2SV_StartBug> string -> space *= 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( string -> space < 0 ) <S2SV_EndBug> { g_warning ( ""glyph<S2SV_blank>string<S2SV_blank>length<S2SV_blank>overflows<S2SV_blank>maximum<S2SV_blank>integer<S2SV_blank>size,<S2SV_blank>truncated"" ) ; <S2SV_StartBug> new_len = string -> space = G_MAXINT - 8 ; <S2SV_EndBug> } } string -> glyphs = g_realloc ( string -> glyphs , string -> space * sizeof ( PangoGlyphInfo ) ) ; string -> log_clusters = g_realloc ( string -> log_clusters , string -> space * sizeof ( gint ) ) ; string -> num_glyphs = new_len ; }","== 0 ) { <S2SV_ModStart> -> space = 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> string -> space <S2SV_ModStart> string -> space * <S2SV_ModEnd> 2 ; if <S2SV_ModStart> ; if ( more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n"" , G_STRLOC , new_len ) ; } } <S2SV_ModEnd> string -> space <S2SV_ModStart> -> space = more_space <S2SV_ModEnd> ; } }"
703,"static RList * r_bin_wasm_get_data_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmDataEntry * ptr = NULL ; <S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; size_t n = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> offset . len = n ; if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> size , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ptr -> data = sec -> payload_data + i ; r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>",= NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
704,"static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) { struct path lowerpath ; struct path upperpath ; struct path workpath ; struct inode * root_inode ; struct dentry * root_dentry ; struct ovl_entry * oe ; struct ovl_fs * ufs ; struct kstatfs statfs ; int err ; err = - ENOMEM ; ufs = kzalloc ( sizeof ( struct ovl_fs ) , GFP_KERNEL ) ; if ( ! ufs ) goto out ; err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; if ( err ) goto out_free_config ; err = - EINVAL ; if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || ! ufs -> config . workdir ) { pr_err ( ""overlayfs:<S2SV_blank>missing<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir\\n"" ) ; goto out_free_config ; } err = - ENOMEM ; oe = ovl_alloc_entry ( ) ; if ( oe == NULL ) goto out_free_config ; err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; if ( err ) goto out_free_oe ; err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; if ( err ) goto out_put_upperpath ; err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; if ( err ) goto out_put_lowerpath ; err = - EINVAL ; if ( ! S_ISDIR ( upperpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( lowerpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( workpath . dentry -> d_inode -> i_mode ) ) { pr_err ( ""overlayfs:<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory\\n"" ) ; goto out_put_workpath ; } if ( upperpath . mnt != workpath . mnt ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>reside<S2SV_blank>under<S2SV_blank>the<S2SV_blank>same<S2SV_blank>mount\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>be<S2SV_blank>separate<S2SV_blank>subtrees\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>upperdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>lowerdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } err = vfs_statfs ( & lowerpath , & statfs ) ; if ( err ) { pr_err ( ""overlayfs:<S2SV_blank>statfs<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>lowerpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_namelen = statfs . f_namelen ; <S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> err = PTR_ERR ( ufs -> upper_mnt ) ; if ( IS_ERR ( ufs -> upper_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>upperpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; err = PTR_ERR ( ufs -> lower_mnt ) ; if ( IS_ERR ( ufs -> lower_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>lowerpath\\n"" ) ; goto out_put_upper_mnt ; } ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; err = PTR_ERR ( ufs -> workdir ) ; if ( IS_ERR ( ufs -> workdir ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>directory<S2SV_blank>%s/%s\\n"" , ufs -> config . workdir , OVL_WORKDIR_NAME ) ; goto out_put_lower_mnt ; } ufs -> lower_mnt -> mnt_flags |= MNT_READONLY ; if ( ufs -> upper_mnt -> mnt_sb -> s_flags & MS_RDONLY ) sb -> s_flags |= MS_RDONLY ; sb -> s_d_op = & ovl_dentry_operations ; err = - ENOMEM ; root_inode = ovl_new_inode ( sb , S_IFDIR , oe ) ; if ( ! root_inode ) goto out_put_workdir ; root_dentry = d_make_root ( root_inode ) ; if ( ! root_dentry ) goto out_put_workdir ; mntput ( upperpath . mnt ) ; mntput ( lowerpath . mnt ) ; path_put ( & workpath ) ; oe -> __upperdentry = upperpath . dentry ; oe -> lowerdentry = lowerpath . dentry ; root_dentry -> d_fsdata = oe ; sb -> s_magic = OVERLAYFS_SUPER_MAGIC ; sb -> s_op = & ovl_super_operations ; sb -> s_root = root_dentry ; sb -> s_fs_info = ufs ; return 0 ; out_put_workdir : dput ( ufs -> workdir ) ; out_put_lower_mnt : mntput ( ufs -> lower_mnt ) ; out_put_upper_mnt : mntput ( ufs -> upper_mnt ) ; out_put_workpath : path_put ( & workpath ) ; out_put_lowerpath : path_put ( & lowerpath ) ; out_put_upperpath : path_put ( & upperpath ) ; out_free_oe : kfree ( oe ) ; out_free_config : kfree ( ufs -> config . lowerdir ) ; kfree ( ufs -> config . upperdir ) ; kfree ( ufs -> config . workdir ) ; kfree ( ufs ) ; out : return err ; }",". f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; }"
705,"static int handle_vmon ( struct kvm_vcpu * vcpu ) { int ret ; gpa_t vmptr ; struct page * page ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED | FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX ; <S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx -> nested . vmxon ) { nested_vmx_failValid ( vcpu , VMXERR_VMXON_IN_VMX_ROOT_OPERATION ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( ( vmx -> msr_ia32_feature_control & VMXON_NEEDED_FEATURES ) != VMXON_NEEDED_FEATURES ) { kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } if ( nested_vmx_get_vmptr ( vcpu , & vmptr ) ) return 1 ; if ( ! PAGE_ALIGNED ( vmptr ) || ( vmptr >> cpuid_maxphyaddr ( vcpu ) ) ) { nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } page = kvm_vcpu_gpa_to_page ( vcpu , vmptr ) ; if ( is_error_page ( page ) ) { nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( * ( u32 * ) kmap ( page ) != VMCS12_REVISION ) { kunmap ( page ) ; kvm_release_page_clean ( page ) ; nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } kunmap ( page ) ; kvm_release_page_clean ( page ) ; vmx -> nested . vmxon_ptr = vmptr ; ret = enter_vmx_operation ( vcpu ) ; if ( ret ) return ret ; nested_vmx_succeed ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; }","vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu"
706,"static int verify_source_vc ( char * * ret_path , const char * src_vc ) { _cleanup_close_ int fd = - 1 ; char * path ; int r ; fd = open_terminal ( src_vc , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) return log_error_errno ( fd , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m"" , src_vc ) ; r = verify_vc_device ( fd ) ; if ( r < 0 ) return log_error_errno ( r , ""Device<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>virtual<S2SV_blank>console:<S2SV_blank>%m"" , src_vc ) ; r = verify_vc_allocation_byfd ( fd ) ; if ( r < 0 ) return log_error_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allocated:<S2SV_blank>%m"" , src_vc ) ; <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) return log_error_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , src_vc ) ; path = strdup ( src_vc ) ; if ( ! path ) return log_oom ( ) ; * ret_path = path ; return TAKE_FD ( fd ) ; }",; r = vt_verify_kbmode <S2SV_ModEnd> ( fd )
707,"<S2SV_StartBug> static void <S2SV_EndBug> ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; int hoplen ; const char * type ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } ND_PRINT ( ( ndo , ""<S2SV_blank>TS{"" ) ) ; hoplen = ( ( cp [ 3 ] & 0xF ) != IPOPT_TS_TSONLY ) ? 8 : 4 ; if ( ( length - 4 ) & ( hoplen - 1 ) ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> len = 0 ; if ( ptr < 4 || ( ( ptr - 4 ) & ( hoplen - 1 ) ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>ptr<S2SV_blank>%u]"" , cp [ 2 ] ) ) ; <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ; break ; case IPOPT_TS_TSANDADDR : ND_PRINT ( ( ndo , ""TS+ADDR"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""PRESPEC2.0"" ) ) ; break ; case 3 : ND_PRINT ( ( ndo , ""PRESPEC"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""[bad<S2SV_blank>ts<S2SV_blank>type<S2SV_blank>%d]"" , cp [ 3 ] & 0xF ) ) ; goto done ; } type = ""<S2SV_blank>"" ; for ( len = 4 ; len < length ; len += hoplen ) { if ( ptr == len ) <S2SV_StartBug> type = ""<S2SV_blank>^<S2SV_blank>"" ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ; type = ""<S2SV_blank>"" ; } done : ND_PRINT ( ( ndo , ""%s"" , ptr == len ? ""<S2SV_blank>^<S2SV_blank>"" : """" ) ) ; if ( cp [ 3 ] >> 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%d<S2SV_blank>hops<S2SV_blank>not<S2SV_blank>recorded]}<S2SV_blank>"" , cp [ 3 ] >> 4 ) ) ; else ND_PRINT ( ( ndo , ""}"" ) ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> type = ""<S2SV_blank>^<S2SV_blank>"" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ) ) ; return ( 0 ) ; trunc : return ( - 1 ) ;"
708,"static void sctp_close ( struct sock * sk , long timeout ) { struct net * net = sock_net ( sk ) ; struct sctp_endpoint * ep ; struct sctp_association * asoc ; struct list_head * pos , * temp ; unsigned int data_was_unread ; pr_debug ( ""%s:<S2SV_blank>sk:%p,<S2SV_blank>timeout:%ld\\n"" , __func__ , sk , timeout ) ; lock_sock ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; sk -> sk_state = SCTP_SS_CLOSING ; ep = sctp_sk ( sk ) -> ep ; data_was_unread = sctp_queue_purge_ulpevents ( & sk -> sk_receive_queue ) ; data_was_unread += sctp_queue_purge_ulpevents ( & sctp_sk ( sk ) -> pd_lobby ) ; list_for_each_safe ( pos , temp , & ep -> asocs ) { asoc = list_entry ( pos , struct sctp_association , asocs ) ; if ( sctp_style ( sk , TCP ) ) { if ( sctp_state ( asoc , CLOSED ) ) { sctp_unhash_established ( asoc ) ; sctp_association_free ( asoc ) ; continue ; } } if ( data_was_unread || ! skb_queue_empty ( & asoc -> ulpq . lobby ) || ! skb_queue_empty ( & asoc -> ulpq . reasm ) || ( sock_flag ( sk , SOCK_LINGER ) && ! sk -> sk_lingertime ) ) { struct sctp_chunk * chunk ; chunk = sctp_make_abort_user ( asoc , NULL , 0 ) ; if ( chunk ) sctp_primitive_ABORT ( net , asoc , chunk ) ; } else sctp_primitive_SHUTDOWN ( net , asoc , NULL ) ; } if ( sctp_style ( sk , TCP ) && timeout ) sctp_wait_for_close ( sk , timeout ) ; release_sock ( sk ) ; <S2SV_StartBug> local_bh_disable ( ) ; <S2SV_EndBug> bh_lock_sock ( sk ) ; sock_hold ( sk ) ; sk_common_release ( sk ) ; bh_unlock_sock ( sk ) ; <S2SV_StartBug> local_bh_enable ( ) ; <S2SV_EndBug> sock_put ( sk ) ; SCTP_DBG_OBJCNT_DEC ( sock ) ; }",sk ) ; spin_lock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> ) ; bh_lock_sock <S2SV_ModStart> sk ) ; spin_unlock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> ) ; sock_put
709,"static int br_multicast_add_group ( struct net_bridge * br , struct net_bridge_port * port , struct br_ip * group ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; unsigned long now = jiffies ; int err ; spin_lock ( & br -> multicast_lock ) ; if ( ! netif_running ( br -> dev ) || ( port && port -> state == BR_STATE_DISABLED ) ) goto out ; mp = br_multicast_new_group ( br , port , group ) ; err = PTR_ERR ( mp ) ; if ( IS_ERR ( mp ) ) goto err ; if ( ! port ) { <S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug> mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; goto out ; } for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p -> port == port ) goto found ; if ( ( unsigned long ) p -> port < ( unsigned long ) port ) break ; } p = kzalloc ( sizeof ( * p ) , GFP_ATOMIC ) ; err = - ENOMEM ; if ( unlikely ( ! p ) ) goto err ; p -> addr = * group ; p -> port = port ; p -> next = * pp ; hlist_add_head ( & p -> mglist , & port -> mglist ) ; setup_timer ( & p -> timer , br_multicast_port_group_expired , ( unsigned long ) p ) ; setup_timer ( & p -> query_timer , br_multicast_port_group_query_expired , ( unsigned long ) p ) ; rcu_assign_pointer ( * pp , p ) ; found : mod_timer ( & p -> timer , now + br -> multicast_membership_interval ) ; out : err = 0 ; err : spin_unlock ( & br -> multicast_lock ) ; return err ; }",port ) { if ( hlist_unhashed ( & mp -> mglist ) )
710,"VTerm * vterm_new_with_allocator ( int rows , int cols , VTermAllocatorFunctions * funcs , void * allocdata ) { VTerm * vt = ( * funcs -> malloc ) ( sizeof ( VTerm ) , allocdata ) ; <S2SV_StartBug> vt -> allocator = funcs ; <S2SV_EndBug> vt -> allocdata = allocdata ; vt -> rows = rows ; vt -> cols = cols ; vt -> parser . state = NORMAL ; vt -> parser . callbacks = NULL ; vt -> parser . cbdata = NULL ; vt -> parser . strbuffer_len = 500 ; vt -> parser . strbuffer_cur = 0 ; vt -> parser . strbuffer = vterm_allocator_malloc ( vt , vt -> parser . strbuffer_len ) ; <S2SV_StartBug> vt -> outbuffer_len = 200 ; <S2SV_EndBug> vt -> outbuffer_cur = 0 ; <S2SV_StartBug> vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ; <S2SV_EndBug> return vt ; }","allocdata ) ; if ( vt == NULL ) return NULL ; <S2SV_ModStart> strbuffer_len ) ; if ( vt -> parser . strbuffer == NULL ) { vterm_allocator_free ( vt , vt ) ; return NULL ; } <S2SV_ModStart> outbuffer_len ) ; if ( vt -> outbuffer == NULL ) { vterm_allocator_free ( vt , vt -> parser . strbuffer ) ; vterm_allocator_free ( vt , vt ) ; return NULL ; }"
711,"static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { <S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> struct ext4_extent * ex1 = NULL ; struct ext4_extent * ex2 = NULL ; struct ext4_extent * ex3 = NULL ; ext4_lblk_t ee_block , eof_block ; <S2SV_StartBug> unsigned int allocated , ee_len , depth ; <S2SV_EndBug> ext4_fsblk_t newblock ; int err = 0 ; int may_zeroout ; ext_debug ( ""ext4_split_unwritten_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_StartBug> allocated = ee_len - ( map -> m_lblk - ee_block ) ; <S2SV_EndBug> newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; ex2 = ex ; orig_ex . ee_block = ex -> ee_block ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ; <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> if ( ( map -> m_lblk == ee_block ) && ( allocated <= map -> m_len ) ) return allocated ; <S2SV_StartBug> err = ext4_ext_get_access ( handle , inode , path + depth ) ; <S2SV_EndBug> if ( err ) goto out ; if ( map -> m_lblk > ee_block ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } if ( ! ex1 && allocated > map -> m_len ) ex2 -> ee_len = cpu_to_le16 ( map -> m_len ) ; if ( allocated > map -> m_len ) { unsigned int newdepth ; ex3 = & newex ; ex3 -> ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; ext4_ext_store_pblock ( ex3 , newblock + map -> m_len ) ; ex3 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ; ext4_ext_mark_uninitialized ( ex3 ) ; <S2SV_StartBug> err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; <S2SV_EndBug> if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; newdepth = ext_depth ( inode ) ; ee_len -= ext4_ext_get_actual_len ( ex3 ) ; orig_ex . ee_len = cpu_to_le16 ( ee_len ) ; may_zeroout = ee_block + ee_len <= eof_block ; depth = newdepth ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } ex = path [ depth ] . p_ext ; if ( ex2 != & newex ) ex2 = ex ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; allocated = map -> m_len ; } if ( ex1 && ex1 != ex ) { ex1 = ex ; ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_mark_uninitialized ( ex1 ) ; ex2 = & newex ; } ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; ex2 -> ee_len = cpu_to_le16 ( allocated ) ; ext4_ext_mark_uninitialized ( ex2 ) ; if ( ex2 != ex ) goto insert ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; ext_debug ( ""out<S2SV_blank>here\\n"" ) ; goto out ; insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && may_zeroout ) { err = ext4_ext_zeroout ( inode , & orig_ex ) ; if ( err ) goto fix_extent_len ; ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return allocated ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ? err : allocated ; fix_extent_len : ex -> ee_block = orig_ex . ee_block ; ex -> ee_len = orig_ex . ee_len ; ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; ext4_ext_mark_uninitialized ( ex ) ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; <S2SV_ModStart> ext4_extent * ex <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ; unsigned int ee_len ; int split_flag = 0 , depth <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> ex ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent <S2SV_ModEnd> ( handle , <S2SV_ModStart> inode , path , map , split_flag <S2SV_ModEnd> , flags ) <S2SV_ModStart> , flags ) <S2SV_ModEnd> ; } <S2SV_null>"
712,"static unsigned int do_encrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , <S2SV_StartBug> encT ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> # else return do_encrypt_fn ( ctx , bx , ax ) ; # endif }","-> rounds , enc_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; #"
713,"static void show_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> if ( info -> flags & REV_LIST_QUIET ) return ; <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> }","* obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> ( obj , name <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> , obj , name <S2SV_ModEnd> ) ; }"
714,"static int rt_fill_info ( struct net * net , __be32 dst , __be32 src , struct flowi4 * fl4 , struct sk_buff * skb , u32 portid , u32 seq , int event , int nowait , unsigned int flags ) { struct rtable * rt = skb_rtable ( skb ) ; struct rtmsg * r ; struct nlmsghdr * nlh ; unsigned long expires = 0 ; u32 error ; u32 metrics [ RTAX_MAX ] ; nlh = nlmsg_put ( skb , portid , seq , event , sizeof ( * r ) , flags ) ; if ( nlh == NULL ) return - EMSGSIZE ; r = nlmsg_data ( nlh ) ; r -> rtm_family = AF_INET ; r -> rtm_dst_len = 32 ; r -> rtm_src_len = 0 ; r -> rtm_tos = fl4 -> flowi4_tos ; r -> rtm_table = RT_TABLE_MAIN ; if ( nla_put_u32 ( skb , RTA_TABLE , RT_TABLE_MAIN ) ) goto nla_put_failure ; r -> rtm_type = rt -> rt_type ; r -> rtm_scope = RT_SCOPE_UNIVERSE ; r -> rtm_protocol = RTPROT_UNSPEC ; r -> rtm_flags = ( rt -> rt_flags & ~ 0xFFFF ) | RTM_F_CLONED ; if ( rt -> rt_flags & RTCF_NOTIFY ) <S2SV_StartBug> r -> rtm_flags |= RTM_F_NOTIFY ; <S2SV_EndBug> if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ; if ( src ) { r -> rtm_src_len = 32 ; if ( nla_put_be32 ( skb , RTA_SRC , src ) ) goto nla_put_failure ; } if ( rt -> dst . dev && nla_put_u32 ( skb , RTA_OIF , rt -> dst . dev -> ifindex ) ) goto nla_put_failure ; # ifdef CONFIG_IP_ROUTE_CLASSID if ( rt -> dst . tclassid && nla_put_u32 ( skb , RTA_FLOW , rt -> dst . tclassid ) ) goto nla_put_failure ; # endif if ( ! rt_is_input_route ( rt ) && fl4 -> saddr != src ) { if ( nla_put_be32 ( skb , RTA_PREFSRC , fl4 -> saddr ) ) goto nla_put_failure ; } if ( rt -> rt_uses_gateway && nla_put_be32 ( skb , RTA_GATEWAY , rt -> rt_gateway ) ) goto nla_put_failure ; expires = rt -> dst . expires ; if ( expires ) { unsigned long now = jiffies ; if ( time_before ( now , expires ) ) expires -= now ; else expires = 0 ; } memcpy ( metrics , dst_metrics_ptr ( & rt -> dst ) , sizeof ( metrics ) ) ; if ( rt -> rt_pmtu && expires ) metrics [ RTAX_MTU - 1 ] = rt -> rt_pmtu ; if ( rtnetlink_put_metrics ( skb , metrics ) < 0 ) goto nla_put_failure ; if ( fl4 -> flowi4_mark && nla_put_u32 ( skb , RTA_MARK , fl4 -> flowi4_mark ) ) goto nla_put_failure ; error = rt -> dst . error ; if ( rt_is_input_route ( rt ) ) { # ifdef CONFIG_IP_MROUTE if ( ipv4_is_multicast ( dst ) && ! ipv4_is_local_multicast ( dst ) && IPV4_DEVCONF_ALL ( net , MC_FORWARDING ) ) { int err = ipmr_get_route ( net , skb , fl4 -> saddr , fl4 -> daddr , r , nowait ) ; if ( err <= 0 ) { if ( ! nowait ) { if ( err == 0 ) return 0 ; goto nla_put_failure ; } else { if ( err == - EMSGSIZE ) goto nla_put_failure ; error = err ; } } } else # endif if ( nla_put_u32 ( skb , RTA_IIF , skb -> dev -> ifindex ) ) goto nla_put_failure ; } if ( rtnl_put_cacheinfo ( skb , & rt -> dst , 0 , expires , error ) < 0 ) goto nla_put_failure ; return nlmsg_end ( skb , nlh ) ; nla_put_failure : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }",rtm_flags |= RTM_F_NOTIFY ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT
715,"static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; char common_name [ FIELD_SIZE + 1 ] ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST <S2SV_StartBug> if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) ) <S2SV_EndBug> cert_valid = 1 ; # else if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>succeeded.\\n"" ) ; ret = 0 ; goto free_cert ; } log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed.\\n"" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( ""Could<S2SV_blank>not<S2SV_blank>compute<S2SV_blank>certificate<S2SV_blank>sha256<S2SV_blank>digest.\\n"" ) ; goto free_cert ; } for ( i = 0 ; i < SHA256LEN ; i ++ ) sprintf ( & digest_str [ 2 * i ] , ""%02x"" , digest [ i ] ) ; digest_str [ SHA256STRLEN - 1 ] = '\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != NULL ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , SHA256STRLEN - 1 ) == 0 ) break ; if ( elem != NULL ) { log_debug ( ""Gateway<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>found<S2SV_blank>in<S2SV_blank>white<S2SV_blank>list.\\n"" ) ; ret = 0 ; goto free_cert ; } subject = X509_NAME_oneline ( subj , NULL , 0 ) ; issuer = X509_NAME_oneline ( X509_get_issuer_name ( cert ) , NULL , 0 ) ; log_error ( ""Gateway<S2SV_blank>certificate<S2SV_blank>validation<S2SV_blank>failed,<S2SV_blank>and<S2SV_blank>the<S2SV_blank>certificate<S2SV_blank>digest<S2SV_blank>in<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>local<S2SV_blank>whitelist.<S2SV_blank>If<S2SV_blank>you<S2SV_blank>trust<S2SV_blank>it,<S2SV_blank>rerun<S2SV_blank>with:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--trusted-cert<S2SV_blank>%s\\n"" , digest_str ) ; log_error ( ""or<S2SV_blank>add<S2SV_blank>this<S2SV_blank>line<S2SV_blank>to<S2SV_blank>your<S2SV_blank>config<S2SV_blank>file:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>trusted-cert<S2SV_blank>=<S2SV_blank>%s\\n"" , digest_str ) ; log_error ( ""Gateway<S2SV_blank>certificate:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>subject:\\n"" ) ; for ( line = strtok ( subject , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , line ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>issuer:\\n"" ) ; for ( line = strtok ( issuer , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , line ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>sha256<S2SV_blank>digest:\\n"" ) ; log_error ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" , digest_str ) ; free_cert : X509_free ( cert ) ; return ret ; }",", NULL ) == 1"
716,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> { static const struct ipt_ip uncond ; <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> # undef FWINV }","( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &"
717,static av_cold int xpm_decode_close ( AVCodecContext * avctx ) { XPMDecContext * x = avctx -> priv_data ; av_freep ( & x -> pixels ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> },pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
718,"void jiffies_to_timeval ( const unsigned long jiffies , struct timeval * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> long tv_usec ; <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> tv_usec /= NSEC_PER_USEC ; <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> }","value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , <S2SV_ModEnd> NSEC_PER_SEC , & <S2SV_ModStart> NSEC_PER_SEC , & rem ) <S2SV_ModEnd> ; value -> <S2SV_ModStart> -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null>"
719,"static void tty_set_termios_ldisc ( struct tty_struct * tty , int num ) { down_write ( & tty -> termios_rwsem ) ; tty -> termios . c_line = num ; up_write ( & tty -> termios_rwsem ) ; <S2SV_StartBug> } <S2SV_EndBug>",termios_rwsem ) ; tty -> disc_data = NULL ; tty -> receive_room = 0 ;
720,"int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <S2SV_StartBug> init_thread : <S2SV_EndBug> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }","= fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;"
721,"static gboolean side_in_cb ( GSocket * socket , GIOCondition condition , gpointer user_data ) { ProxySide * side = user_data ; FlatpakProxyClient * client = side -> client ; GError * error = NULL ; Buffer * buffer ; gboolean retval = G_SOURCE_CONTINUE ; g_object_ref ( client ) ; while ( ! side -> closed ) { if ( ! side -> got_first_byte ) buffer = buffer_new ( 1 , NULL ) ; else if ( ! client -> authenticated ) buffer = buffer_new ( 64 , NULL ) ; else buffer = side -> current_read_buffer ; if ( ! buffer_read ( side , buffer , socket ) ) { if ( buffer != side -> current_read_buffer ) buffer_unref ( buffer ) ; break ; } if ( ! client -> authenticated ) { if ( buffer -> pos > 0 ) { gboolean found_auth_end = FALSE ; gsize extra_data ; buffer -> size = buffer -> pos ; if ( ! side -> got_first_byte ) { buffer -> send_credentials = TRUE ; side -> got_first_byte = TRUE ; } else if ( side == & client -> client_side ) { gssize auth_end = find_auth_end ( client , buffer ) ; if ( auth_end >= 0 ) { found_auth_end = TRUE ; buffer -> size = auth_end ; extra_data = buffer -> pos - buffer -> size ; if ( extra_data > 0 ) side -> extra_input_data = g_bytes_new ( buffer -> data + buffer -> size , extra_data ) ; } <S2SV_StartBug> } <S2SV_EndBug> got_buffer_from_side ( side , buffer ) ; if ( found_auth_end ) client -> authenticated = TRUE ; } else { buffer_unref ( buffer ) ; } } else if ( buffer -> pos == buffer -> size ) { if ( buffer == & side -> header_buffer ) { gssize required ; required = g_dbus_message_bytes_needed ( buffer -> data , buffer -> size , & error ) ; if ( required < 0 ) { g_warning ( ""Invalid<S2SV_blank>message<S2SV_blank>header<S2SV_blank>read"" ) ; side_closed ( side ) ; } else { side -> current_read_buffer = buffer_new ( required , buffer ) ; } } else { got_buffer_from_side ( side , buffer ) ; side -> header_buffer . pos = 0 ; side -> current_read_buffer = & side -> header_buffer ; } } } if ( side -> closed ) { side -> in_source = NULL ; retval = G_SOURCE_REMOVE ; } g_object_unref ( client ) ; return retval ; }",") ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( ""Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n"" ) ; side_closed ( side ) ; break ; }"
722,"static void ext4_xattr_release_block ( handle_t * handle , struct inode * inode , struct buffer_head * bh ) { <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ce = mb_cache_entry_get ( ext4_mb_cache , bh -> b_bdev , bh -> b_blocknr ) ; BUFFER_TRACE ( bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bh ) ; if ( error ) goto out ; lock_buffer ( bh ) ; if ( BHDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; get_bh ( bh ) ; unlock_buffer ( bh ) ; ext4_free_blocks ( handle , inode , bh , 0 , 1 , EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET ) ; } else { le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_release ( ce ) ; if ( ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; unlock_buffer ( bh ) ; if ( ! ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( inode -> i_sb ) , 1 ) ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d;<S2SV_blank>releasing"" , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; } out : ext4_std_error ( inode -> i_sb , error ) ; return ; }","bh ) { <S2SV_ModEnd> int error = <S2SV_ModStart> error = 0 <S2SV_ModEnd> ; BUFFER_TRACE ( <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; get_bh <S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_handle_valid ( handle"
723,"Expr * sqlite3CreateColumnExpr ( sqlite3 * db , SrcList * pSrc , int iSrc , int iCol ) { Expr * p = sqlite3ExprAlloc ( db , TK_COLUMN , 0 , 0 ) ; if ( p ) { struct SrcList_item * pItem = & pSrc -> a [ iSrc ] ; <S2SV_StartBug> p -> y . pTab = pItem -> pTab ; <S2SV_EndBug> p -> iTable = pItem -> iCursor ; if ( p -> y . pTab -> iPKey == iCol ) { p -> iColumn = - 1 ; } else { p -> iColumn = ( ynVar ) iCol ; <S2SV_StartBug> testcase ( iCol == BMS ) ; <S2SV_EndBug> testcase ( iCol == BMS - 1 ) ; pItem -> colUsed |= ( ( Bitmask ) 1 ) << ( iCol >= BMS ? BMS - 1 : iCol ) ; } } <S2SV_StartBug> return p ; <S2SV_EndBug> }",iSrc ] ; Table * pTab = <S2SV_ModStart> ) iCol ; if ( pTab -> tabFlags & TF_HasGenerated ) { Column * pColumn = pTab -> aCol + iCol ; if ( pColumn -> colFlags & COLFLAG_GENERATED ) { testcase ( pTab -> nCol == 63 ) ; testcase ( pTab -> nCol == 64 ) ; if ( pTab -> nCol >= 64 ) { pItem -> colUsed = ALLBITS ; } else { pItem -> colUsed = MASKBIT ( pTab -> nCol ) - 1 ; } } } else { <S2SV_ModStart> ; } } }
724,"u32 h264bsdInit ( storage_t * pStorage , u32 noOutputReordering ) { u32 size ; ASSERT ( pStorage ) ; h264bsdInitStorage ( pStorage ) ; size = ( sizeof ( macroblockLayer_t ) + 63 ) & ~ 0x3F ; <S2SV_StartBug> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <S2SV_EndBug> if ( ! pStorage -> mbLayer ) return HANTRO_NOK ; if ( noOutputReordering ) pStorage -> noReordering = HANTRO_TRUE ; return HANTRO_OK ; }","H264SwDecMalloc ( size , 1"
725,"static void setup_decoding_thread_data ( VP8D_COMP * pbi , MACROBLOCKD * xd , MB_ROW_DEC * mbrd , int count ) { VP8_COMMON * const pc = & pbi -> common ; int i ; for ( i = 0 ; i < count ; i ++ ) { MACROBLOCKD * mbd = & mbrd [ i ] . mbd ; mbd -> subpixel_predict = xd -> subpixel_predict ; mbd -> subpixel_predict8x4 = xd -> subpixel_predict8x4 ; mbd -> subpixel_predict8x8 = xd -> subpixel_predict8x8 ; mbd -> subpixel_predict16x16 = xd -> subpixel_predict16x16 ; mbd -> mode_info_context = pc -> mi + pc -> mode_info_stride * ( i + 1 ) ; mbd -> mode_info_stride = pc -> mode_info_stride ; mbd -> frame_type = pc -> frame_type ; mbd -> pre = xd -> pre ; mbd -> dst = xd -> dst ; mbd -> segmentation_enabled = xd -> segmentation_enabled ; mbd -> mb_segement_abs_delta = xd -> mb_segement_abs_delta ; <S2SV_StartBug> vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> mbd -> mode_ref_lf_delta_enabled = xd -> mode_ref_lf_delta_enabled ; mbd -> mode_ref_lf_delta_update = xd -> mode_ref_lf_delta_update ; mbd -> current_bc = & pbi -> mbc [ 0 ] ; <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <S2SV_EndBug> mbd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) mbd -> fullpixel_mask = 0xfffffff8 ; } for ( i = 0 ; i < pc -> mb_rows ; i ++ ) pbi -> mt_current_mb_col [ i ] = - 1 ; }",-> mb_segement_abs_delta ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> 0 ] ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd ->
726,"static void zz_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , YV12_BUFFER_CONFIG * raw_buffer , int * raw_motion_err , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; unsigned char * src_ptr = ( * ( b -> base_src ) + b -> src ) ; int src_stride = b -> src_stride ; unsigned char * raw_ptr ; int raw_stride = raw_buffer -> y_stride ; unsigned char * ref_ptr ; int ref_stride = x -> e_mbd . pre . y_stride ; <S2SV_StartBug> raw_ptr = ( unsigned char * ) ( raw_buffer -> y_buffer + recon_yoffset <S2SV_EndBug> + d -> offset ) ; <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , raw_ptr , raw_stride , <S2SV_EndBug> ( unsigned int * ) ( raw_motion_err ) ) ; xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; ref_ptr = ( unsigned char * ) ( xd -> pre . y_buffer + d -> offset ) ; <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , ref_ptr , ref_stride , <S2SV_EndBug> ( unsigned int * ) ( best_motion_err ) ) ; }",". y_stride ; ( void ) cpi ; <S2SV_ModStart> offset ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr , <S2SV_ModStart> offset ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr ,"
727,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_roi_map_t * data = va_arg ( args , vpx_roi_map_t * ) ; if ( data ) { vpx_roi_map_t * roi = ( vpx_roi_map_t * ) data ; if ( ! vp8_set_roimap ( ctx -> cpi , roi -> roi_map , roi -> rows , roi -> cols , roi -> delta_q , roi -> delta_lf , roi -> static_threshold ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }","vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args"
728,"int table_regex_match ( const char * string , const char * pattern ) { regex_t preg ; <S2SV_StartBug> int cflags = REG_EXTENDED | REG_NOSUB ; <S2SV_EndBug> if ( strncmp ( pattern , ""(?i)"" , 4 ) == 0 ) { cflags |= REG_ICASE ; pattern += 4 ; } if ( regcomp ( & preg , pattern , cflags ) != 0 ) return ( 0 ) ; <S2SV_StartBug> if ( regexec ( & preg , string , 0 , NULL , 0 ) != 0 ) <S2SV_EndBug> return ( 0 ) ; return ( 1 ) ; }","REG_EXTENDED | REG_NOSUB ; int ret <S2SV_ModStart> 0 ) ; ret = <S2SV_ModEnd> regexec ( & <S2SV_ModStart> , 0 ) ; regfree ( & preg ) ; if ( ret"
729,"int ssl3_get_record ( SSL * s ) { int ssl_major , ssl_minor , al ; int enc_err , n , i , ret = - 1 ; SSL3_RECORD * rr ; SSL3_BUFFER * rbuf ; SSL_SESSION * sess ; unsigned char * p ; unsigned char md [ EVP_MAX_MD_SIZE ] ; short version ; unsigned mac_size ; unsigned int num_recs = 0 ; unsigned int max_recs ; unsigned int j ; rr = RECORD_LAYER_get_rrec ( & s -> rlayer ) ; rbuf = RECORD_LAYER_get_rbuf ( & s -> rlayer ) ; max_recs = s -> max_pipelines ; if ( max_recs == 0 ) max_recs = 1 ; sess = s -> session ; do { if ( ( RECORD_LAYER_get_rstate ( & s -> rlayer ) != SSL_ST_READ_BODY ) || ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) < SSL3_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , SSL3_RT_HEADER_LENGTH , SSL3_BUFFER_get_len ( rbuf ) , 0 , num_recs == 0 ? 1 : 0 ) ; if ( n <= 0 ) return ( n ) ; RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_BODY ) ; p = RECORD_LAYER_get_packet ( & s -> rlayer ) ; if ( s -> server && RECORD_LAYER_is_first_record ( & s -> rlayer ) && ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) { rr [ num_recs ] . type = SSL3_RT_HANDSHAKE ; rr [ num_recs ] . rec_version = SSL2_VERSION ; rr [ num_recs ] . length = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ; if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) - SSL2_RT_HEADER_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ; goto f_err ; } if ( rr [ num_recs ] . length < MIN_SSL2_RECORD_LEN ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } } else { if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , 5 , s , s -> msg_callback_arg ) ; rr [ num_recs ] . type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; rr [ num_recs ] . rec_version = version ; n2s ( p , rr [ num_recs ] . length ) ; if ( ! s -> first_packet && version != s -> version ) { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; if ( ( s -> version & 0xFF00 ) == ( version & 0xFF00 ) && ! s -> enc_write_ctx && ! s -> write_hash ) { if ( rr -> type == SSL3_RT_ALERT ) { goto err ; } s -> version = ( unsigned short ) version ; } al = SSL_AD_PROTOCOL_VERSION ; goto f_err ; } if ( ( version >> 8 ) != SSL3_VERSION_MAJOR ) { if ( RECORD_LAYER_is_first_record ( & s -> rlayer ) ) { p = RECORD_LAYER_get_packet ( & s -> rlayer ) ; if ( strncmp ( ( char * ) p , ""GET<S2SV_blank>"" , 4 ) == 0 || strncmp ( ( char * ) p , ""POST<S2SV_blank>"" , 5 ) == 0 || strncmp ( ( char * ) p , ""HEAD<S2SV_blank>"" , 5 ) == 0 || strncmp ( ( char * ) p , ""PUT<S2SV_blank>"" , 4 ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTP_REQUEST ) ; goto err ; } else if ( strncmp ( ( char * ) p , ""CONNE"" , 5 ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTPS_PROXY_REQUEST ) ; goto err ; } SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; goto err ; } else { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; al = SSL_AD_PROTOCOL_VERSION ; goto f_err ; } } if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) - SSL3_RT_HEADER_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ; goto f_err ; } } } if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) { i = rr [ num_recs ] . length + SSL2_RT_HEADER_LENGTH - SSL3_RT_HEADER_LENGTH ; } else { i = rr [ num_recs ] . length ; } if ( i > 0 ) { n = ssl3_read_n ( s , i , i , 1 , 0 ) ; if ( n <= 0 ) return ( n ) ; } RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_HEADER ) ; if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) { rr [ num_recs ] . input = & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL2_RT_HEADER_LENGTH ] ) ; } else { rr [ num_recs ] . input = & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL3_RT_HEADER_LENGTH ] ) ; } if ( rr [ num_recs ] . length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; goto f_err ; } rr [ num_recs ] . data = rr [ num_recs ] . input ; rr [ num_recs ] . orig_len = rr [ num_recs ] . length ; rr [ num_recs ] . read = 0 ; num_recs ++ ; RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ; RECORD_LAYER_clear_first_record ( & s -> rlayer ) ; } while ( num_recs < max_recs && rr [ num_recs - 1 ] . type == SSL3_RT_APPLICATION_DATA && SSL_USE_EXPLICIT_IV ( s ) && s -> enc_read_ctx != NULL && ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_read_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) && ssl3_record_app_data_waiting ( s ) ) ; <S2SV_StartBug> if ( SSL_USE_ETM ( s ) && s -> read_hash ) { <S2SV_EndBug> unsigned char * mac ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; for ( j = 0 ; j < num_recs ; j ++ ) { if ( rr [ j ] . length < mac_size ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } rr [ j ] . length -= mac_size ; mac = rr [ j ] . data + rr [ j ] . length ; i = s -> method -> ssl3_enc -> mac ( s , & rr [ j ] , md , 0 ) ; if ( i < 0 || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) { al = SSL_AD_BAD_RECORD_MAC ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC ) ; goto f_err ; } } } enc_err = s -> method -> ssl3_enc -> enc ( s , rr , num_recs , 0 ) ; if ( enc_err == 0 ) { al = SSL_AD_DECRYPTION_FAILED ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_BLOCK_CIPHER_PAD_IS_WRONG ) ; goto f_err ; } # ifdef SSL_DEBUG printf ( ""dec<S2SV_blank>%d\\n"" , rr -> length ) ; { unsigned int z ; for ( z = 0 ; z < rr -> length ; z ++ ) printf ( ""%02X%c"" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( ""\\n"" ) ; # endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && <S2SV_StartBug> ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) { <S2SV_EndBug> unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; for ( j = 0 ; j < num_recs ; j ++ ) { if ( rr [ j ] . orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr [ j ] . orig_len < mac_size + 1 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) { mac = mac_tmp ; ssl3_cbc_copy_mac ( mac_tmp , & rr [ j ] , mac_size ) ; rr [ j ] . length -= mac_size ; } else { rr [ j ] . length -= mac_size ; mac = & rr [ j ] . data [ rr [ j ] . length ] ; } i = s -> method -> ssl3_enc -> mac ( s , & rr [ j ] , md , 0 ) ; if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ; if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ; } } if ( enc_err < 0 ) { al = SSL_AD_BAD_RECORD_MAC ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC ) ; goto f_err ; } for ( j = 0 ; j < num_recs ; j ++ ) { if ( s -> expand != NULL ) { if ( rr [ j ] . length > SSL3_RT_MAX_COMPRESSED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; goto f_err ; } if ( ! ssl3_do_uncompress ( s , & rr [ j ] ) ) { al = SSL_AD_DECOMPRESSION_FAILURE ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_BAD_DECOMPRESSION ) ; goto f_err ; } } if ( rr [ j ] . length > SSL3_RT_MAX_PLAIN_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } rr [ j ] . off = 0 ; if ( rr [ j ] . length == 0 ) { RECORD_LAYER_inc_empty_record_count ( & s -> rlayer ) ; if ( RECORD_LAYER_get_empty_record_count ( & s -> rlayer ) > MAX_EMPTY_RECORDS ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_RECORD_TOO_SMALL ) ; goto f_err ; } } else { RECORD_LAYER_reset_empty_record_count ( & s -> rlayer ) ; } } RECORD_LAYER_set_numrpipes ( & s -> rlayer , num_recs ) ; return 1 ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ret ; }",; if ( SSL_READ_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) && ( ! SSL_READ_ETM ( s ) && <S2SV_ModStart> ) != NULL <S2SV_ModEnd> ) ) {
730,"<S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> { int c ; unsigned int value ; do { c = ReadBlobByte ( image ) ; if ( c == EOF ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } while ( ( c == '<S2SV_blank>' ) || ( c == '\\t' ) || ( c == '\\n' ) || ( c == '\\r' ) ) ; value = 0 ; while ( hex_digits [ c ] >= 0 ) { if ( value > ( unsigned int ) ( INT_MAX / 10 ) ) break ; value *= 16 ; c &= 0xff ; if ( value > ( unsigned int ) ( INT_MAX - hex_digits [ c ] ) ) break ; value += hex_digits [ c ] ; c = ReadBlobByte ( image ) ; if ( c == EOF ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } <S2SV_StartBug> return ( value ) ; <S2SV_EndBug> }",<S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> } return ( ( int )
731,"void mm_release ( struct task_struct * tsk , struct mm_struct * mm ) { <S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> deactivate_mm ( tsk , mm ) ; if ( vfork_done ) { tsk -> vfork_done = NULL ; complete ( vfork_done ) ; } if ( tsk -> clear_child_tid && ! ( tsk -> flags & PF_SIGNALED ) && atomic_read ( & mm -> mm_users ) > 1 ) { u32 __user * tidptr = tsk -> clear_child_tid ; tsk -> clear_child_tid = NULL ; put_user ( 0 , tidptr ) ; sys_futex ( tidptr , FUTEX_WAKE , 1 , NULL , NULL , 0 ) ; } }",-> vfork_done ; # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif
732,"static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; if ( count != 512 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( ( MagickSizeType ) ( viff_info . map_rows * image -> colors ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( MagickSizeType ) viff_info . map_rows > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( MagickSizeType ) viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { image -> colors = 2 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colorspace = GRAYColorspace ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( HeapOverflowSanityCheck ( ( size_t ) number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } if ( ( MagickSizeType ) ( bytes_per_pixel * max_packets ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( pixels , 0 , MagickMax ( number_pixels , max_packets ) * bytes_per_pixel * sizeof ( * pixels ) ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }",NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image
733,"static int rfcomm_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct bt_security sec ; int len , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; if ( level == SOL_RFCOMM ) return rfcomm_sock_getsockopt_old ( sock , optname , optval , optlen ) ; if ( level != SOL_BLUETOOTH ) return - ENOPROTOOPT ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case BT_SECURITY : if ( sk -> sk_type != SOCK_STREAM ) { err = - EINVAL ; break ; } sec . level = rfcomm_pi ( sk ) -> sec_level ; <S2SV_StartBug> len = min_t ( unsigned int , len , sizeof ( sec ) ) ; <S2SV_EndBug> if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ; break ; case BT_DEFER_SETUP : if ( sk -> sk_state != BT_BOUND && sk -> sk_state != BT_LISTEN ) { err = - EINVAL ; break ; } if ( put_user ( test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) , ( u32 __user * ) optval ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }",-> sec_level ; sec . key_size = 0 ;
734,"static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , ""M-SEARCH<S2SV_blank>*"" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , ""No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , ""Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , ""\\r\\nST:"" ) ; if ( ! type ) { logit ( LOG_DEBUG , ""No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>"" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , ""\\r\\n"" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , ""M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , ""M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }",buf [ MAX_PKT_SIZE + 1 <S2SV_ModStart> ( buf ) - 1 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( sa
735,"static long madvise_remove ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { loff_t offset ; int error ; <S2SV_StartBug> * prev = NULL ; <S2SV_EndBug> if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ; <S2SV_StartBug> if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping <S2SV_EndBug> <S2SV_StartBug> || ! vma -> vm_file -> f_mapping -> host ) { <S2SV_EndBug> return - EINVAL ; } if ( ( vma -> vm_flags & ( VM_SHARED | VM_WRITE ) ) != ( VM_SHARED | VM_WRITE ) ) return - EACCES ; offset = ( loff_t ) ( start - vma -> vm_start ) + ( ( loff_t ) vma -> vm_pgoff << PAGE_SHIFT ) ; <S2SV_StartBug> up_read ( & current -> mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> error = do_fallocate ( vma -> vm_file , <S2SV_EndBug> FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , <S2SV_StartBug> offset , end - start ) ; <S2SV_EndBug> down_read ( & current -> mm -> mmap_sem ) ; return error ; }","int error ; struct file * f ; <S2SV_ModStart> - EINVAL ; f = vma -> vm_file ; <S2SV_ModStart> if ( ! f || ! f <S2SV_ModEnd> -> f_mapping || <S2SV_ModStart> f_mapping || ! f <S2SV_ModEnd> -> f_mapping -> <S2SV_ModStart> PAGE_SHIFT ) ; get_file ( f ) ; <S2SV_ModStart> = do_fallocate ( f <S2SV_ModEnd> , FALLOC_FL_PUNCH_HOLE | <S2SV_ModStart> end - start ) ; fput ( f"
736,"static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; <S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> if ( len > 0xFFFF ) <S2SV_StartBug> goto out ; <S2SV_EndBug> err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( ""%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\n"" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> inet_sk_flowi_flags ( sk ) | <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> daddr , saddr , 0 , 0 , sk -> sk_uid ) ; <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }","raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err"
737,"private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , <S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { size_t i ; cdf_timestamp_t tp ; struct timespec ts ; char buf [ 64 ] ; const char * str = NULL ; const char * s ; int len ; <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> for ( i = 0 ; i < count ; i ++ ) { cdf_print_property_name ( buf , sizeof ( buf ) , info [ i ] . pi_id ) ; switch ( info [ i ] . pi_type ) { case CDF_NULL : break ; case CDF_SIGNED16 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%hd"" , buf , info [ i ] . pi_s16 ) == - 1 ) return - 1 ; break ; case CDF_SIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%d"" , buf , info [ i ] . pi_s32 ) == - 1 ) return - 1 ; break ; case CDF_UNSIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%u"" , buf , info [ i ] . pi_u32 ) == - 1 ) return - 1 ; break ; case CDF_FLOAT : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%g"" , buf , info [ i ] . pi_f ) == - 1 ) return - 1 ; break ; case CDF_DOUBLE : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%g"" , buf , info [ i ] . pi_d ) == - 1 ) return - 1 ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : len = info [ i ] . pi_str . s_len ; if ( len > 1 ) { char vbuf [ 1024 ] ; size_t j , k = 1 ; if ( info [ i ] . pi_type == CDF_LENGTH32_WSTRING ) k ++ ; s = info [ i ] . pi_str . s_buf ; for ( j = 0 ; j < sizeof ( vbuf ) && len -- ; j ++ , s += k ) { if ( * s == '\\0' ) break ; if ( isprint ( ( unsigned char ) * s ) ) vbuf [ j ] = * s ; } if ( j == sizeof ( vbuf ) ) -- j ; vbuf [ j ] = '\\0' ; if ( NOTMIME ( ms ) ) { if ( vbuf [ 0 ] ) { if ( file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , vbuf ) == - 1 ) return - 1 ; } } else if ( str == NULL && info [ i ] . pi_id == CDF_PROPERTY_NAME_OF_APPLICATION ) { str = cdf_app_to_mime ( vbuf , app2mime ) ; } } break ; case CDF_FILETIME : tp = info [ i ] . pi_tp ; if ( tp != 0 ) { char tbuf [ 64 ] ; if ( tp < 1000000000000000LL ) { cdf_print_elapsed_time ( tbuf , sizeof ( tbuf ) , tp ) ; if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , tbuf ) == - 1 ) return - 1 ; } else { char * c , * ec ; cdf_timestamp_to_timespec ( & ts , tp ) ; c = cdf_ctime ( & ts . tv_sec , tbuf ) ; if ( c != NULL && ( ec = strchr ( c , '\\n' ) ) != NULL ) * ec = '\\0' ; if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , c ) == - 1 ) return - 1 ; } } break ; case CDF_CLIPBOARD : break ; default : return - 1 ; } } if ( ! NOTMIME ( ms ) ) { if ( str == NULL ) return 0 ; if ( file_printf ( ms , ""application/%s"" , str ) == - 1 ) return - 1 ; } return 1 ; }","count , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ( ms ) && root_storage <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2mime )"
738,"static int prepend_path ( const struct path * path , const struct path * root , char * * buffer , int * buflen ) { struct dentry * dentry ; struct vfsmount * vfsmnt ; struct mount * mnt ; int error = 0 ; unsigned seq , m_seq = 0 ; char * bptr ; int blen ; rcu_read_lock ( ) ; restart_mnt : read_seqbegin_or_lock ( & mount_lock , & m_seq ) ; seq = 0 ; rcu_read_lock ( ) ; restart : bptr = * buffer ; blen = * buflen ; error = 0 ; dentry = path -> dentry ; vfsmnt = path -> mnt ; mnt = real_mount ( vfsmnt ) ; read_seqbegin_or_lock ( & rename_lock , & seq ) ; while ( dentry != root -> dentry || vfsmnt != root -> mnt ) { struct dentry * parent ; if ( dentry == vfsmnt -> mnt_root || IS_ROOT ( dentry ) ) { <S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> if ( mnt != parent ) { dentry = ACCESS_ONCE ( mnt -> mnt_mountpoint ) ; mnt = parent ; vfsmnt = & mnt -> mnt ; continue ; } if ( ! error ) error = is_mounted ( vfsmnt ) ? 1 : 2 ; break ; } parent = dentry -> d_parent ; prefetch ( parent ) ; error = prepend_name ( & bptr , & blen , & dentry -> d_name ) ; if ( error ) break ; dentry = parent ; } if ( ! ( seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & rename_lock , seq ) ) { seq = 1 ; goto restart ; } done_seqretry ( & rename_lock , seq ) ; if ( ! ( m_seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & mount_lock , m_seq ) ) { m_seq = 1 ; goto restart_mnt ; } done_seqretry ( & mount_lock , m_seq ) ; if ( error >= 0 && bptr == * buffer ) { if ( -- blen < 0 ) error = - ENAMETOOLONG ; else * -- bptr = '/' ; } * buffer = bptr ; * buflen = blen ; return error ; }",mnt_parent ) ; if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; }
739,"int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 1 ) ; if ( bp [ hlen ] & 0xf0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ; hlen += 1 ; hlen += 1 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 16 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> }",; return ( - 1 <S2SV_ModEnd> ) ; }
740,"<S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> { <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> return FALSE ; <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug> }","const char * cooke_domain <S2SV_ModEnd> , const char <S2SV_ModStart> const char * hostname <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ) { size_t cookie_domain_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( cooke_domain <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> ) ; size_t hostname_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( hostname <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( hostname_len < cookie_domain_len <S2SV_ModEnd> ) return FALSE <S2SV_ModStart> return FALSE ; if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> FALSE ; }"
741,"static void r_bin_dwarf_dump_debug_info ( FILE * f , const RBinDwarfDebugInfo * inf ) { size_t i , j , k ; RBinDwarfDIE * dies ; RBinDwarfAttrValue * values ; if ( ! inf || ! f ) { return ; } for ( i = 0 ; i < inf -> length ; i ++ ) { fprintf ( f , ""<S2SV_blank><S2SV_blank>Compilation<S2SV_blank>Unit<S2SV_blank>@<S2SV_blank>offset<S2SV_blank>0x%"" PFMT64x "":\\n"" , inf -> comp_units [ i ] . offset ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n"" , inf -> comp_units [ i ] . hdr . length ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Version:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , inf -> comp_units [ i ] . hdr . version ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Abbrev<S2SV_blank>Offset:<S2SV_blank>0x%x\\n"" , inf -> comp_units [ i ] . hdr . abbrev_offset ) ; fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank>Pointer<S2SV_blank>Size:<S2SV_blank><S2SV_blank>%d\\n"" , inf -> comp_units [ i ] . hdr . pointer_size ) ; dies = inf -> comp_units [ i ] . dies ; for ( j = 0 ; j < inf -> comp_units [ i ] . length ; j ++ ) { fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Abbrev<S2SV_blank>Number:<S2SV_blank>%"" PFMT64u ""<S2SV_blank>"" , dies [ j ] . abbrev_code ) ; if ( dies [ j ] . tag && dies [ j ] . tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings [ dies [ j ] . tag ] ) { fprintf ( f , ""(%s)\\n"" , dwarf_tag_name_encodings [ dies [ j ] . tag ] ) ; } else { fprintf ( f , ""(Unknown<S2SV_blank>abbrev<S2SV_blank>tag)\\n"" ) ; } if ( ! dies [ j ] . abbrev_code ) { continue ; } values = dies [ j ] . attr_values ; for ( k = 0 ; k < dies [ j ] . length ; k ++ ) { <S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug> continue ; if ( values [ k ] . name < DW_AT_vtable_elem_location && dwarf_attr_encodings [ values [ k ] . name ] ) { fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-18s<S2SV_blank>:<S2SV_blank>"" , dwarf_attr_encodings [ values [ k ] . name ] ) ; } else { fprintf ( f , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TODO\\t"" ) ; } r_bin_dwarf_dump_attr_value ( & values [ k ] , f ) ; fprintf ( f , ""\\n"" ) ; } } } }",. name ) { continue ; } <S2SV_ModEnd> if ( values
742,"static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps ) { return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } <S2SV_StartBug> siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; <S2SV_EndBug> siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }","1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }"
743,"static int ssl_scan_serverhello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int length , type , size ; int tlsext_servername = 0 ; int renegotiate_seen = 0 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif s -> tlsext_ticket_expected = 0 ; OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> s -> s3 -> flags &= ~ TLS1_FLAGS_RECEIVED_EXTMS ; if ( ! PACKET_get_net_2 ( pkt , & length ) ) goto ri_check ; if ( PACKET_remaining ( pkt ) != length ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( ! tls1_check_duplicate_extensions ( pkt ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } while ( PACKET_get_net_2 ( pkt , & type ) && PACKET_get_net_2 ( pkt , & size ) ) { const unsigned char * data ; PACKET spkt ; if ( ! PACKET_get_sub_packet ( pkt , & spkt , size ) || ! PACKET_peek_bytes ( & spkt , & data , size ) ) goto ri_check ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_serverhello_renegotiate_ext ( s , & spkt , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { if ( s -> tlsext_hostname == NULL || size > 0 ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } tlsext_servername = 1 ; } # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { unsigned int ecpointformatlist_length ; if ( ! PACKET_get_1 ( & spkt , & ecpointformatlist_length ) || ecpointformatlist_length != size - 1 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( ! s -> hit ) { s -> session -> tlsext_ecpointformatlist_length = 0 ; OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ) ; if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length ; if ( ! PACKET_copy_bytes ( & spkt , s -> session -> tlsext_ecpointformatlist , ecpointformatlist_length ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } if ( ! tls_use_ticket ( s ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_ticket_expected = 1 ; } else if ( type == TLSEXT_TYPE_status_request ) { if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_status_expected = 1 ; } # ifndef OPENSSL_NO_CT else if ( type == TLSEXT_TYPE_signed_certificate_timestamp && s -> ct_validation_callback != NULL ) { if ( s -> tlsext_scts != NULL ) { OPENSSL_free ( s -> tlsext_scts ) ; s -> tlsext_scts = NULL ; } s -> tlsext_scts_len = size ; if ( size > 0 ) { s -> tlsext_scts = OPENSSL_malloc ( size ) ; if ( s -> tlsext_scts == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> tlsext_scts , data , size ) ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { unsigned char * selected ; unsigned char selected_len ; if ( s -> ctx -> next_proto_select_cb == NULL ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( ! ssl_next_proto_validate ( & spkt ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } OPENSSL_free ( s -> next_proto_negotiated ) ; s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ) ; if ( s -> next_proto_negotiated == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> next_proto_negotiated , selected , selected_len ) ; s -> next_proto_negotiated_len = selected_len ; s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation ) { unsigned len ; if ( ! s -> s3 -> alpn_sent ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( ! PACKET_get_net_2 ( & spkt , & len ) || PACKET_remaining ( & spkt ) != len || ! PACKET_get_1 ( & spkt , & len ) || PACKET_remaining ( & spkt ) != len ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = OPENSSL_malloc ( len ) ; if ( s -> s3 -> alpn_selected == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } if ( ! PACKET_copy_bytes ( & spkt , s -> s3 -> alpn_selected , len ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } s -> s3 -> alpn_selected_len = len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & spkt , & hbtype ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_serverhello_use_srtp_ext ( s , & spkt , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) { if ( s -> s3 -> tmp . new_cipher -> algorithm_mac != SSL_AEAD && s -> s3 -> tmp . new_cipher -> algorithm_enc != SSL_RC4 ) <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> } else if ( type == TLSEXT_TYPE_extended_master_secret ) { s -> s3 -> flags |= TLS1_FLAGS_RECEIVED_EXTMS ; if ( ! s -> hit ) s -> session -> flags |= SSL_SESS_FLAG_EXTMS ; } else if ( custom_ext_parse ( s , 0 , type , data , size , al ) <= 0 ) return 0 ; } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( ! s -> hit && tlsext_servername == 1 ) { if ( s -> tlsext_hostname ) { if ( s -> session -> tlsext_hostname == NULL ) { s -> session -> tlsext_hostname = OPENSSL_strdup ( s -> tlsext_hostname ) ; if ( ! s -> session -> tlsext_hostname ) { * al = SSL_AD_UNRECOGNIZED_NAME ; return 0 ; } } else { * al = SSL_AD_DECODE_ERROR ; return 0 ; } } } ri_check : if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } if ( s -> hit ) { if ( ! ( s -> s3 -> flags & TLS1_FLAGS_RECEIVED_EXTMS ) != ! ( s -> session -> flags & SSL_SESS_FLAG_EXTMS ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT , SSL_R_INCONSISTENT_EXTMS ) ; return 0 ; } } return 1 ; }",endif s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; s -> <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; } else
744,"static int compile_bag_node ( BagNode * node , regex_t * reg , ScanEnv * env ) { int r , len ; switch ( node -> type ) { case BAG_MEMORY : r = compile_bag_memory_node ( node , reg , env ) ; break ; case BAG_OPTION : r = compile_option_node ( node , reg , env ) ; break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { QuantNode * qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; r = compile_tree_n_times ( NODE_QUANT_BODY ( qn ) , qn -> lower , reg , env ) ; if ( r != 0 ) return r ; len = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( len < 0 ) return len ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; r = compile_tree ( NODE_QUANT_BODY ( qn ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_POP_OUT ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; COP ( reg ) -> jump . addr = - ( ( int ) SIZE_OP_PUSH + len + ( int ) SIZE_OP_POP_OUT ) ; } else { r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; r = compile_tree ( NODE_BAG_BODY ( node ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; } break ; case BAG_IF_ELSE : { <S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; cond_len = compile_length_tree ( cond , reg ) ; if ( cond_len < 0 ) return cond_len ; if ( IS_NOT_NULL ( Then ) ) { then_len = compile_length_tree ( Then , reg ) ; if ( then_len < 0 ) return then_len ; } else then_len = 0 ; <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + jump_len ; r = compile_tree ( cond , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Then ) ) { r = compile_tree ( Then , reg , env ) ; if ( r != 0 ) return r ; } if ( IS_NOT_NULL ( Else ) ) { <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> } } break ; } return r ; }",", then_len , else_len , <S2SV_ModStart> then_len + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; r <S2SV_ModStart> ) ) { <S2SV_ModEnd> else_len = compile_length_tree <S2SV_ModStart> , reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> . addr = SIZE_OP_ATOMIC_END + <S2SV_ModStart> ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r ="
745,"int xfs_attr_rmtval_get ( struct xfs_da_args * args ) { struct xfs_bmbt_irec map [ ATTR_RMTVALUE_MAPSIZE ] ; struct xfs_mount * mp = args -> dp -> i_mount ; struct xfs_buf * bp ; xfs_dablk_t lblkno = args -> rmtblkno ; __uint8_t * dst = args -> value ; <S2SV_StartBug> int valuelen = args -> valuelen ; <S2SV_EndBug> int nmap ; int error ; int blkcnt = args -> rmtblkcnt ; int i ; int offset = 0 ; trace_xfs_attr_rmtval_get ( args ) ; <S2SV_StartBug> ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ; <S2SV_EndBug> while ( valuelen > 0 ) { nmap = ATTR_RMTVALUE_MAPSIZE ; error = xfs_bmapi_read ( args -> dp , ( xfs_fileoff_t ) lblkno , blkcnt , map , & nmap , XFS_BMAPI_ATTRFORK ) ; if ( error ) return error ; ASSERT ( nmap >= 1 ) ; for ( i = 0 ; ( i < nmap ) && ( valuelen > 0 ) ; i ++ ) { xfs_daddr_t dblkno ; int dblkcnt ; ASSERT ( ( map [ i ] . br_startblock != DELAYSTARTBLOCK ) && ( map [ i ] . br_startblock != HOLESTARTBLOCK ) ) ; dblkno = XFS_FSB_TO_DADDR ( mp , map [ i ] . br_startblock ) ; dblkcnt = XFS_FSB_TO_BB ( mp , map [ i ] . br_blockcount ) ; error = xfs_trans_read_buf ( mp , NULL , mp -> m_ddev_targp , dblkno , dblkcnt , 0 , & bp , & xfs_attr3_rmt_buf_ops ) ; if ( error ) return error ; error = xfs_attr_rmtval_copyout ( mp , bp , args -> dp -> i_ino , & offset , & valuelen , & dst ) ; xfs_buf_relse ( bp ) ; if ( error ) return error ; lblkno += map [ i ] . br_blockcount ; blkcnt -= map [ i ] . br_blockcount ; } } ASSERT ( valuelen == 0 ) ; return 0 ; }",; int valuelen <S2SV_ModEnd> ; int nmap <S2SV_ModStart> ATTR_KERNOVAL ) ) ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen
746,"void ipc_rcu_putref ( void * ptr ) { <S2SV_StartBug> if ( -- container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount > 0 ) <S2SV_EndBug> return ; if ( container_of ( ptr , struct ipc_rcu_hdr , data ) -> is_vmalloc ) { call_rcu ( & container_of ( ptr , struct ipc_rcu_grace , data ) -> rcu , ipc_schedule_free ) ; } else { kfree_rcu ( container_of ( ptr , struct ipc_rcu_grace , data ) , rcu ) ; } }",{ if ( ! atomic_dec_and_test ( & <S2SV_ModEnd> container_of ( ptr <S2SV_ModStart> ) -> refcount ) <S2SV_ModEnd> ) return ;
747,"static const u_char * ikev2_ke_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_ke ke ; const struct ikev2_ke * k ; k = ( const struct ikev2_ke * ) ext ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , ke . h . critical ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>group=%s"" , ntohs ( ke . h . len ) - 8 , STR_OR_ID ( ntohs ( ke . ke_group ) , dh_p_map ) ) ) ; if ( 2 < ndo -> ndo_vflag && 8 < ntohs ( ke . h . len ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( k + 1 ) , ntohs ( ke . h . len ) - 8 ) ) goto trunc ; } return ( const u_char * ) ext + ntohs ( ke . h . len ) ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",ND_TCHECK ( * k <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
748,"<S2SV_StartBug> static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent ) <S2SV_EndBug> { FD_t wfd = NULL ; int rc = 0 ; { mode_t old_umask = umask ( 0577 ) ; <S2SV_StartBug> wfd = Fopen ( dest , ""w.ufdio"" ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( old_umask ) ; <S2SV_EndBug> } if ( Ferror ( wfd ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; } if ( ! nocontent ) rc = rpmfiArchiveReadToFilePsm ( fi , wfd , nodigest , psm ) ; exit : if ( wfd ) { int myerrno = errno ; Fclose ( wfd ) ; errno = myerrno ; } return rc ; }",", rpmpsm psm , int exclusive <S2SV_ModStart> ( dest , exclusive ? ""wx.ufdio"" : ""a.ufdio"" <S2SV_ModEnd> ) ; umask <S2SV_ModStart> old_umask ) ; if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; }"
749,jas_image_t * jas_image_create0 ( ) { jas_image_t * image ; if ( ! ( image = jas_malloc ( sizeof ( jas_image_t ) ) ) ) { return 0 ; } image -> tlx_ = 0 ; image -> tly_ = 0 ; image -> brx_ = 0 ; image -> bry_ = 0 ; image -> clrspc_ = JAS_CLRSPC_UNKNOWN ; image -> numcmpts_ = 0 ; image -> maxcmpts_ = 0 ; image -> cmpts_ = 0 ; <S2SV_StartBug> image -> inmem_ = true ; <S2SV_EndBug> image -> cmprof_ = 0 ; return image ; },; image -> <S2SV_ModEnd> cmprof_ = 0
750,"static int mboxlist_do_find ( struct find_rock * rock , const strarray_t * patterns ) { const char * userid = rock -> userid ; int isadmin = rock -> isadmin ; int crossdomains = config_getswitch ( IMAPOPT_CROSSDOMAINS ) ; char inbox [ MAX_MAILBOX_BUFFER ] ; size_t inboxlen = 0 ; size_t prefixlen , len ; size_t domainlen = 0 ; size_t userlen = userid ? strlen ( userid ) : 0 ; char domainpat [ MAX_MAILBOX_BUFFER ] ; char commonpat [ MAX_MAILBOX_BUFFER ] ; int r = 0 ; int i ; const char * p ; if ( patterns -> count < 1 ) return 0 ; for ( i = 0 ; i < patterns -> count ; i ++ ) { glob * g = glob_init ( strarray_nth ( patterns , i ) , rock -> namespace -> hier_sep ) ; ptrarray_append ( & rock -> globs , g ) ; } if ( config_virtdomains && userid && ( p = strchr ( userid , '@' ) ) ) { userlen = p - userid ; domainlen = strlen ( p ) ; snprintf ( domainpat , sizeof ( domainpat ) , ""%s!"" , p + 1 ) ; } else domainpat [ 0 ] = '\\0' ; if ( userid && ( ! ( p = strchr ( userid , rock -> namespace -> hier_sep ) ) || ( ( p - userid ) > ( int ) userlen ) ) && strlen ( userid ) + 7 < MAX_MAILBOX_BUFFER ) { char * t , * tmpuser = NULL ; const char * inboxuser ; if ( domainlen ) snprintf ( inbox , sizeof ( inbox ) , ""%s!"" , userid + userlen + 1 ) ; if ( rock -> namespace -> hier_sep == '/' && ( p = strchr ( userid , '.' ) ) ) { tmpuser = xmalloc ( userlen ) ; memcpy ( tmpuser , userid , userlen ) ; t = tmpuser + ( p - userid ) ; while ( t < ( tmpuser + userlen ) ) { if ( * t == '.' ) * t = '^' ; t ++ ; } inboxuser = tmpuser ; } else inboxuser = userid ; snprintf ( inbox + domainlen , sizeof ( inbox ) - domainlen , ""user.%.*s.INBOX."" , ( int ) userlen , inboxuser ) ; free ( tmpuser ) ; inboxlen = strlen ( inbox ) - 7 ; } else { userid = 0 ; } const char * firstpat = strarray_nth ( patterns , 0 ) ; for ( prefixlen = 0 ; firstpat [ prefixlen ] ; prefixlen ++ ) { if ( prefixlen >= MAX_MAILBOX_NAME ) { r = IMAP_MAILBOX_BADNAME ; goto done ; } char c = firstpat [ prefixlen ] ; for ( i = 1 ; i < patterns -> count ; i ++ ) { const char * pat = strarray_nth ( patterns , i ) ; if ( pat [ prefixlen ] != c ) break ; } if ( i < patterns -> count ) break ; if ( c == '*' || c == '%' || c == '?' ) break ; commonpat [ prefixlen ] = c ; } commonpat [ prefixlen ] = '\\0' ; if ( patterns -> count == 1 ) { if ( ! strcmp ( firstpat + prefixlen , ""%"" ) ) rock -> singlepercent = 2 ; if ( ! strcmp ( firstpat + prefixlen , ""*%"" ) ) rock -> singlepercent = 1 ; } if ( userid && ! isadmin ) { rock -> mb_category = MBNAME_INBOX ; r = cyrusdb_forone ( rock -> db , inbox , inboxlen , & find_p , & find_cb , rock , NULL ) ; if ( r == CYRUSDB_DONE ) r = 0 ; if ( r ) goto done ; if ( rock -> namespace -> isalt ) { rock -> mb_category = MBNAME_INBOXSUB ; r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 7 , & find_p , & find_cb , rock , NULL ) ; if ( r == CYRUSDB_DONE ) r = 0 ; if ( r ) goto done ; r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; if ( r ) goto done ; } rock -> mb_category = MBNAME_OWNER ; r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 1 , & find_p , & find_cb , rock , NULL ) ; if ( r == CYRUSDB_DONE ) r = 0 ; if ( r ) goto done ; if ( rock -> namespace -> isalt ) { r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; if ( r ) goto done ; rock -> mb_category = MBNAME_ALTINBOX ; r = cyrusdb_forone ( rock -> db , inbox , inboxlen + 6 , & find_p , & find_cb , rock , NULL ) ; if ( r == CYRUSDB_DONE ) goto skipalt ; if ( r ) goto done ; rock -> mb_category = MBNAME_ALTPREFIX ; r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 1 , & find_p , & find_cb , rock , NULL ) ; skipalt : if ( r == CYRUSDB_DONE ) r = 0 ; if ( r ) goto done ; } } if ( isadmin || rock -> namespace -> accessible [ NAMESPACE_USER ] ) { len = strlen ( rock -> namespace -> prefix [ NAMESPACE_USER ] ) ; if ( len ) len -- ; if ( ! strncmp ( rock -> namespace -> prefix [ NAMESPACE_USER ] , commonpat , MIN ( len , prefixlen ) ) ) { <S2SV_StartBug> if ( prefixlen < len ) { <S2SV_EndBug> strlcpy ( domainpat + domainlen , ""user."" , sizeof ( domainpat ) - domainlen ) ; } else { strlcpy ( domainpat + domainlen , ""user."" , sizeof ( domainpat ) - domainlen ) ; strlcpy ( domainpat + domainlen + 5 , commonpat + len + 1 , sizeof ( domainpat ) - domainlen - 5 ) ; } rock -> mb_category = MBNAME_OTHERUSER ; size_t thislen = ( isadmin || crossdomains ) ? 0 : strlen ( domainpat ) ; r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; if ( r ) goto done ; r = mboxlist_find_category ( rock , domainpat , thislen ) ; if ( r ) goto done ; } } if ( isadmin || rock -> namespace -> accessible [ NAMESPACE_SHARED ] ) { len = strlen ( rock -> namespace -> prefix [ NAMESPACE_SHARED ] ) ; if ( len ) len -- ; if ( ! strncmp ( rock -> namespace -> prefix [ NAMESPACE_SHARED ] , commonpat , MIN ( len , prefixlen ) ) ) { rock -> mb_category = MBNAME_SHARED ; r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; if ( r ) goto done ; r = mboxlist_find_category ( rock , domainpat , domainlen ) ; if ( r ) goto done ; } } r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; done : for ( i = 0 ; i < rock -> globs . count ; i ++ ) { glob * g = ptrarray_nth ( & rock -> globs , i ) ; glob_free ( & g ) ; } ptrarray_fini ( & rock -> globs ) ; return r ; }",if ( prefixlen <= <S2SV_ModEnd> len ) {
751,"int main ( int argc , char * * argv ) { mode_t old_umask ; cleanup_free char * base_path = NULL ; int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( ""prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed"" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , & argv ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; if ( opt_unshare_user_try && stat ( ""/proc/self/ns/user"" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( ""/sys/module/user_namespace/parameters/enable"" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , ""/sys/module/user_namespace/parameters/enable"" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( ""Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n"" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( ""Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( ""Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user"" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( ""Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts"" ) ; proc_fd = open ( ""/proc"" , O_RDONLY | O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>open<S2SV_blank>/proc"" ) ; base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; if ( mkdir ( base_path , 0755 ) && errno != EEXIST ) { free ( base_path ) ; base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ; if ( mkdir ( base_path , 0755 ) && errno != EEXIST ) die_with_error ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ; } __debug__ ( ( ""creating<S2SV_blank>new<S2SV_blank>namespace\\n"" ) ) ; if ( opt_unshare_pid ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) { if ( errno == ENOENT ) die ( ""Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it"" ) ; else die_with_error ( ""stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed"" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems."" ) ; else if ( errno == EPERM && ! is_privileged ) die ( ""No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'."" ) ; } die_with_error ( ""Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed"" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( ) ; val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\""child-pid\\"":<S2SV_blank>%i\\n}\\n"" , pid ) ; size_t len = strlen ( output ) ; if ( write ( opt_info_fd , output , len ) != len ) die_with_error ( ""Write<S2SV_blank>to<S2SV_blank>info_fd"" ) ; close ( opt_info_fd ) ; } monitor_child ( event_fd ) ; exit ( 0 ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net && loopback_setup ( ) != 0 ) die ( ""Can\'t<S2SV_blank>create<S2SV_blank>loopback<S2SV_blank>device"" ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave"" ) ; if ( mount ( """" , base_path , ""tmpfs"" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs"" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( ""chdir<S2SV_blank>base_path"" ) ; if ( mkdir ( ""newroot"" , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>newroot<S2SV_blank>failed"" ) ; if ( mkdir ( ""oldroot"" , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>oldroot<S2SV_blank>failed"" ) ; if ( pivot_root ( base_path , ""oldroot"" ) ) die_with_error ( ""pivot_root"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)"" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( ""Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket"" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper"" ) ; if ( child == 0 ) { drop_privs ( ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( ""Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket"" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } if ( mount ( ""oldroot"" , ""oldroot"" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate"" ) ; if ( umount2 ( ""oldroot"" , MNT_DETACH ) ) die_with_error ( ""unmount<S2SV_blank>old<S2SV_blank>root"" ) ; if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( ""unshare<S2SV_blank>user<S2SV_blank>ns"" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } if ( chdir ( ""/newroot"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>newroot"" ) ; if ( chroot ( ""/newroot"" ) != 0 ) die_with_error ( ""chroot<S2SV_blank>/newroot"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir<S2SV_blank>/"" ) ; drop_privs ( ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; read ( opt_block_fd , b , 1 ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog prog ; seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( ""Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data"" ) ; if ( seccomp_len % 8 != 0 ) die ( ""Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8"" ) ; prog . len = seccomp_len / 8 ; prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; if ( prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & prog ) != 0 ) die_with_error ( ""prctl(PR_SET_SECCOMP)"" ) ; } umask ( old_umask ) ; new_cwd = ""/"" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s"" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( ""HOME"" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( ""PWD"" , new_cwd , 1 ) ; free ( old_cwd ) ; __debug__ ( ( ""forking<S2SV_blank>for<S2SV_blank>child\\n"" ) ) ; if ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( ""Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1"" ) ; if ( pid != 0 ) { { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid ) ; } } __debug__ ( ( ""launch<S2SV_blank>executable<S2SV_blank>%s\\n"" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; unblock_sigchild ( ) ; <S2SV_StartBug> if ( label_exec ( opt_exec_label ) == - 1 ) <S2SV_EndBug> die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ; if ( execvp ( argv [ 0 ] , argv ) == - 1 ) die_with_error ( ""execvp<S2SV_blank>%s"" , argv [ 0 ] ) ; return 0 ; }","; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ("
752,"int tpm_open ( struct inode * inode , struct file * file ) { int minor = iminor ( inode ) ; struct tpm_chip * chip = NULL , * pos ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( pos , & tpm_chip_list , list ) { if ( pos -> vendor . miscdev . minor == minor ) { chip = pos ; get_device ( chip -> dev ) ; break ; } } rcu_read_unlock ( ) ; if ( ! chip ) return - ENODEV ; if ( test_and_set_bit ( 0 , & chip -> is_open ) ) { dev_dbg ( chip -> dev , ""Another<S2SV_blank>process<S2SV_blank>owns<S2SV_blank>this<S2SV_blank>TPM\\n"" ) ; put_device ( chip -> dev ) ; return - EBUSY ; } <S2SV_StartBug> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( chip -> data_buffer == NULL ) { clear_bit ( 0 , & chip -> is_open ) ; put_device ( chip -> dev ) ; return - ENOMEM ; } atomic_set ( & chip -> data_pending , 0 ) ; file -> private_data = chip ; return 0 ; }","-> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL )"
753,"static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ; <S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> err = hci_uart_register_dev ( hu ) ; if ( err ) { <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> } return 0 ; }","= p ; <S2SV_ModEnd> err = hci_uart_register_dev <S2SV_ModStart> err ) { return err ; } set_bit <S2SV_ModEnd> ( HCI_UART_PROTO_READY , <S2SV_ModStart> ) ; return <S2SV_ModEnd> 0 ; }"
754,"int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; <S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> if ( len == PKT_LEN_SIZE ) { * head = NULL ; * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR<S2SV_blank>"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }",return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
755,"static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i ) ) ) { free ( ptr ) ; return ret ; } } r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>",-> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ut32 <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
756,"static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MaxTextExtent ] , id [ MaxTextExtent ] , keyword [ MaxTextExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MaxTextExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MaxTextExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MaxTextExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MaxTextExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MaxTextExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""matte"" ) == 0 ) { ssize_t matte ; matte = ParseCommandOption ( MagickBooleanOptions , MagickFalse , options ) ; if ( matte < 0 ) break ; image -> matte = ( MagickBooleanType ) matte ; break ; } if ( LocaleCompare ( keyword , ""matte-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""opaque"" ) == 0 ) { ssize_t matte ; matte = ParseCommandOption ( MagickBooleanOptions , MagickFalse , options ) ; if ( matte < 0 ) break ; image -> matte = ( MagickBooleanType ) matte ; break ; } if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MaxTextExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MaxTextExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MaxTextExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; ( void ) ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { <S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = colormap ; switch ( depth ) { default : ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <S2SV_EndBug> if ( status == MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","PseudoClass ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> colors <S2SV_ModStart> image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ) break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> -> rows ) <S2SV_ModEnd> == MagickFalse ) <S2SV_ModStart> == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; <S2SV_ModEnd> status = PersistPixelCache"
757,"int ip_options_echo ( struct ip_options * dopt , struct sk_buff * skb ) { <S2SV_StartBug> struct ip_options * sopt ; <S2SV_EndBug> unsigned char * sptr , * dptr ; int soffset , doffset ; int optlen ; __be32 daddr ; memset ( dopt , 0 , sizeof ( struct ip_options ) ) ; sopt = & ( IPCB ( skb ) -> opt ) ; <S2SV_StartBug> if ( sopt -> optlen == 0 ) { <S2SV_EndBug> dopt -> optlen = 0 ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> sptr = skb_network_header ( skb ) ; dptr = dopt -> __data ; daddr = skb_rtable ( skb ) -> rt_spec_dst ; if ( sopt -> rr ) { optlen = sptr [ sopt -> rr + 1 ] ; soffset = sptr [ sopt -> rr + 2 ] ; dopt -> rr = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> rr , optlen ) ; if ( sopt -> rr_needaddr && soffset <= optlen ) { if ( soffset + 3 > optlen ) return - EINVAL ; dptr [ 2 ] = soffset + 4 ; dopt -> rr_needaddr = 1 ; } dptr += optlen ; dopt -> optlen += optlen ; } if ( sopt -> ts ) { optlen = sptr [ sopt -> ts + 1 ] ; soffset = sptr [ sopt -> ts + 2 ] ; dopt -> ts = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> ts , optlen ) ; if ( soffset <= optlen ) { if ( sopt -> ts_needaddr ) { if ( soffset + 3 > optlen ) return - EINVAL ; dopt -> ts_needaddr = 1 ; soffset += 4 ; } if ( sopt -> ts_needtime ) { if ( soffset + 3 > optlen ) return - EINVAL ; if ( ( dptr [ 3 ] & 0xF ) != IPOPT_TS_PRESPEC ) { dopt -> ts_needtime = 1 ; soffset += 4 ; } else { dopt -> ts_needtime = 0 ; if ( soffset + 7 <= optlen ) { __be32 addr ; memcpy ( & addr , dptr + soffset - 1 , 4 ) ; if ( inet_addr_type ( dev_net ( skb_dst ( skb ) -> dev ) , addr ) != RTN_UNICAST ) { dopt -> ts_needtime = 1 ; soffset += 8 ; } } } } dptr [ 2 ] = soffset ; } dptr += optlen ; dopt -> optlen += optlen ; } if ( sopt -> srr ) { unsigned char * start = sptr + sopt -> srr ; __be32 faddr ; optlen = start [ 1 ] ; soffset = start [ 2 ] ; doffset = 0 ; if ( soffset > optlen ) soffset = optlen + 1 ; soffset -= 4 ; if ( soffset > 3 ) { memcpy ( & faddr , & start [ soffset - 1 ] , 4 ) ; for ( soffset -= 4 , doffset = 4 ; soffset > 3 ; soffset -= 4 , doffset += 4 ) memcpy ( & dptr [ doffset - 1 ] , & start [ soffset - 1 ] , 4 ) ; if ( memcmp ( & ip_hdr ( skb ) -> saddr , & start [ soffset + 3 ] , 4 ) == 0 ) doffset -= 4 ; } if ( doffset > 3 ) { memcpy ( & start [ doffset - 1 ] , & daddr , 4 ) ; dopt -> faddr = faddr ; dptr [ 0 ] = start [ 0 ] ; dptr [ 1 ] = doffset + 3 ; dptr [ 2 ] = 4 ; dptr += doffset + 3 ; dopt -> srr = dopt -> optlen + sizeof ( struct iphdr ) ; dopt -> optlen += doffset + 3 ; dopt -> is_strictroute = sopt -> is_strictroute ; } } if ( sopt -> cipso ) { optlen = sptr [ sopt -> cipso + 1 ] ; dopt -> cipso = dopt -> optlen + sizeof ( struct iphdr ) ; memcpy ( dptr , sptr + sopt -> cipso , optlen ) ; dptr += optlen ; dopt -> optlen += optlen ; } while ( dopt -> optlen & 3 ) { * dptr ++ = IPOPT_END ; dopt -> optlen ++ ; } return 0 ; }",skb ) { const <S2SV_ModStart> == 0 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> sptr = skb_network_header
758,"static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn , <S2SV_StartBug> unsigned long size ) <S2SV_EndBug> { gfn_t end_gfn ; pfn_t pfn ; pfn = gfn_to_pfn_memslot ( slot , gfn ) ; <S2SV_StartBug> end_gfn = gfn + ( size >> PAGE_SHIFT ) ; <S2SV_EndBug> gfn += 1 ; if ( is_error_noslot_pfn ( pfn ) ) return pfn ; while ( gfn < end_gfn ) gfn_to_pfn_memslot ( slot , gfn ++ ) ; return pfn ; }",", unsigned long npages <S2SV_ModEnd> ) { gfn_t <S2SV_ModStart> = gfn + npages <S2SV_ModEnd> ; gfn +="
759,"vpx_codec_err_t vpx_codec_enc_config_set ( vpx_codec_ctx_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; if ( ! ctx || ! ctx -> iface || ! ctx -> priv || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> res = ctx -> iface -> enc . cfg_set ( ctx -> priv -> alg_priv , cfg ) ; <S2SV_EndBug> return SAVE_STATUS ( ctx , res ) ; }",". cfg_set ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cfg )"
760,"static __init int sctp_init ( void ) { int i ; int status = - EINVAL ; unsigned long goal ; unsigned long limit ; int max_share ; int order ; sock_skb_cb_check_size ( sizeof ( struct sctp_ulpevent ) ) ; status = - ENOBUFS ; sctp_bucket_cachep = kmem_cache_create ( ""sctp_bind_bucket"" , sizeof ( struct sctp_bind_bucket ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_bucket_cachep ) goto out ; sctp_chunk_cachep = kmem_cache_create ( ""sctp_chunk"" , sizeof ( struct sctp_chunk ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_chunk_cachep ) goto err_chunk_cachep ; status = percpu_counter_init ( & sctp_sockets_allocated , 0 , GFP_KERNEL ) ; if ( status ) goto err_percpu_counter_init ; sctp_max_instreams = SCTP_DEFAULT_INSTREAMS ; sctp_max_outstreams = SCTP_DEFAULT_OUTSTREAMS ; idr_init ( & sctp_assocs_id ) ; limit = nr_free_buffer_pages ( ) / 8 ; limit = max ( limit , 128UL ) ; sysctl_sctp_mem [ 0 ] = limit / 4 * 3 ; sysctl_sctp_mem [ 1 ] = limit ; sysctl_sctp_mem [ 2 ] = sysctl_sctp_mem [ 0 ] * 2 ; limit = ( sysctl_sctp_mem [ 1 ] ) << ( PAGE_SHIFT - 7 ) ; max_share = min ( 4UL * 1024 * 1024 , limit ) ; sysctl_sctp_rmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_rmem [ 1 ] = 1500 * SKB_TRUESIZE ( 1 ) ; sysctl_sctp_rmem [ 2 ] = max ( sysctl_sctp_rmem [ 1 ] , max_share ) ; sysctl_sctp_wmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_wmem [ 1 ] = 16 * 1024 ; sysctl_sctp_wmem [ 2 ] = max ( 64 * 1024 , max_share ) ; if ( totalram_pages >= ( 128 * 1024 ) ) goal = totalram_pages >> ( 22 - PAGE_SHIFT ) ; else goal = totalram_pages >> ( 24 - PAGE_SHIFT ) ; for ( order = 0 ; ( 1UL << order ) < goal ; order ++ ) ; do { sctp_assoc_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_hashbucket ) ; if ( ( sctp_assoc_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_assoc_hashtable = ( struct sctp_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_assoc_hashtable && -- order > 0 ) ; if ( ! sctp_assoc_hashtable ) { pr_err ( ""Failed<S2SV_blank>association<S2SV_blank>hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_ahash_alloc ; } for ( i = 0 ; i < sctp_assoc_hashsize ; i ++ ) { rwlock_init ( & sctp_assoc_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_assoc_hashtable [ i ] . chain ) ; } sctp_ep_hashsize = 64 ; sctp_ep_hashtable = kmalloc ( 64 * sizeof ( struct sctp_hashbucket ) , GFP_KERNEL ) ; if ( ! sctp_ep_hashtable ) { pr_err ( ""Failed<S2SV_blank>endpoint_hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_ehash_alloc ; } for ( i = 0 ; i < sctp_ep_hashsize ; i ++ ) { rwlock_init ( & sctp_ep_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_ep_hashtable [ i ] . chain ) ; } do { sctp_port_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_bind_hashbucket ) ; if ( ( sctp_port_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_port_hashtable = ( struct sctp_bind_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_port_hashtable && -- order > 0 ) ; if ( ! sctp_port_hashtable ) { pr_err ( ""Failed<S2SV_blank>bind<S2SV_blank>hash<S2SV_blank>alloc\\n"" ) ; status = - ENOMEM ; goto err_bhash_alloc ; } for ( i = 0 ; i < sctp_port_hashsize ; i ++ ) { spin_lock_init ( & sctp_port_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_port_hashtable [ i ] . chain ) ; } pr_info ( ""Hash<S2SV_blank>tables<S2SV_blank>configured<S2SV_blank>(established<S2SV_blank>%d<S2SV_blank>bind<S2SV_blank>%d)\\n"" , sctp_assoc_hashsize , sctp_port_hashsize ) ; sctp_sysctl_register ( ) ; INIT_LIST_HEAD ( & sctp_address_families ) ; sctp_v4_pf_init ( ) ; sctp_v6_pf_init ( ) ; <S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> if ( status ) goto err_protosw_init ; status = sctp_v6_protosw_init ( ) ; if ( status ) goto err_v6_protosw_init ; <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> if ( status ) goto err_register_pernet_subsys ; status = sctp_v4_add_protocol ( ) ; if ( status ) goto err_add_protocol ; status = sctp_v6_add_protocol ( ) ; if ( status ) goto err_v6_add_protocol ; out : return status ; err_v6_add_protocol : sctp_v4_del_protocol ( ) ; err_add_protocol : <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ; err_v6_protosw_init : sctp_v4_protosw_exit ( ) ; <S2SV_StartBug> err_protosw_init : <S2SV_EndBug> sctp_v4_pf_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; err_bhash_alloc : kfree ( sctp_ep_hashtable ) ; err_ehash_alloc : free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; err_ahash_alloc : percpu_counter_destroy ( & sctp_sockets_allocated ) ; err_percpu_counter_init : kmem_cache_destroy ( sctp_chunk_cachep ) ; err_chunk_cachep : kmem_cache_destroy ( sctp_bucket_cachep ) ; goto out ; }",; status = register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> register_pernet_subsys ( & sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> ; status = <S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> : sctp_v6_protosw_exit ( <S2SV_ModStart> ) ; err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults
761,"static int br_mdb_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net_device * dev ; struct net * net = sock_net ( skb -> sk ) ; struct nlmsghdr * nlh = NULL ; int idx = 0 , s_idx ; s_idx = cb -> args [ 0 ] ; rcu_read_lock ( ) ; cb -> seq = net -> dev_base_seq + br_mdb_rehash_seq ; for_each_netdev_rcu ( net , dev ) { if ( dev -> priv_flags & IFF_EBRIDGE ) { struct br_port_msg * bpm ; if ( idx < s_idx ) goto skip ; nlh = nlmsg_put ( skb , NETLINK_CB ( cb -> skb ) . portid , cb -> nlh -> nlmsg_seq , RTM_GETMDB , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( nlh == NULL ) break ; <S2SV_StartBug> bpm = nlmsg_data ( nlh ) ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; if ( br_mdb_fill_info ( skb , cb , dev ) < 0 ) goto out ; if ( br_rports_fill_info ( skb , cb , dev ) < 0 ) goto out ; cb -> args [ 1 ] = 0 ; nlmsg_end ( skb , nlh ) ; skip : idx ++ ; } } out : if ( nlh ) nlmsg_end ( skb , nlh ) ; rcu_read_unlock ( ) ; cb -> args [ 0 ] = idx ; return skb -> len ; }","nlmsg_data ( nlh ) ; memset ( bpm , 0 , sizeof ( * bpm )"
762,"static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) <S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> return 0 ; }",) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
763,"static void encode_block_pass1 ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { MACROBLOCK * const x = ( MACROBLOCK * ) arg ; MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> int i , j ; uint8_t * dst ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ; vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; if ( p -> eobs [ block ] > 0 ) <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> }","plane ] ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> > 0 ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; return ; } # endif x <S2SV_ModEnd> -> itxm_add ( <S2SV_ModStart> ] ) ; }"
764,"<S2SV_StartBug> void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> if ( eob == 1 ) <S2SV_StartBug> vp9_idct8x8_1_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( eob <= 10 ) <S2SV_EndBug> vp9_idct8x8_10_add ( input , dest , stride ) ; else <S2SV_StartBug> vp9_idct8x8_64_add ( input , dest , stride ) ; <S2SV_EndBug> }","vp9_idct8x8_add ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> == 1 ) vpx_idct8x8_1_add <S2SV_ModEnd> ( input , <S2SV_ModStart> ( eob <= 12 ) vpx_idct8x8_12_add <S2SV_ModEnd> ( input , <S2SV_ModStart> ) ; else vpx_idct8x8_64_add <S2SV_ModEnd> ( input ,"
765,"Bool GPAC_EventProc ( void * ptr , GF_Event * evt ) { if ( ! term ) return 0 ; if ( gui_mode == 1 ) { if ( evt -> type == GF_EVENT_QUIT ) { Run = 0 ; } else if ( evt -> type == GF_EVENT_KEYDOWN ) { switch ( evt -> key . key_code ) { case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( shell_visible ) gui_mode = 2 ; } break ; default : break ; } } return 0 ; } switch ( evt -> type ) { case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ; CanSeek = evt -> duration . can_seek ; break ; case GF_EVENT_MESSAGE : { const char * servName ; if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) { servName = """" ; } else if ( ! strnicmp ( evt -> message . service , ""data:"" , 5 ) ) { servName = ""(embedded<S2SV_blank>data)"" ; } else { servName = evt -> message . service ; } if ( ! evt -> message . message ) return 0 ; if ( evt -> message . error ) { if ( ! is_connected ) last_error = evt -> message . error ; if ( evt -> message . error == GF_SCRIPT_INFO ) { GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s\\n"" , evt -> message . message ) ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s:<S2SV_blank>%s\\n"" , servName , evt -> message . message , gf_error_to_string ( evt -> message . error ) ) ) ; } } else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s\\n"" , servName , evt -> message . message ) ) ; } break ; case GF_EVENT_PROGRESS : { char * szTitle = """" ; if ( evt -> progress . progress_type == 0 ) { szTitle = ""Buffer<S2SV_blank>"" ; if ( bench_mode && ( bench_mode != 3 ) ) { if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ; else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ; break ; } } else if ( evt -> progress . progress_type == 1 ) { if ( bench_mode ) break ; szTitle = ""Download<S2SV_blank>"" ; } else if ( evt -> progress . progress_type == 2 ) szTitle = ""Import<S2SV_blank>"" ; gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ; } break ; case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; return 0 ; case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 1 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 0 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) { GF_Event move ; move . move . x = evt -> mouse . x - last_x ; move . move . y = last_y - evt -> mouse . y ; move . type = GF_EVENT_MOVE ; move . move . relative = 1 ; gf_term_user_event ( term , & move ) ; } return 0 ; case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ; break ; } break ; case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ; switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) { if ( ! bench_mode ) switch_bench ( ! bench_mode ) ; } break ; case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ; break ; case GF_KEY_MEDIAPREVIOUSTRACK : break ; case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; break ; case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( ! shell_visible ) gui_mode = 1 ; } break ; case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\n"" , gf_term_get_framerate ( term , 0 ) ) ; break ; case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\n"" , gf_term_get_time_in_ms ( term ) / 1000.0 ) ; break ; case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ; break ; case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) { fprintf ( stderr , ""Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\n"" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { fprintf ( stderr , ""Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\n"" ) ; } } break ; case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\n"" , pause_state ? ""Playing"" : ""Paused"" ) ; if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } } break ; case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""\\n"" ) ; } break ; case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ; break ; case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ; break ; case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 1 ) ; } break ; case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 0 ) ; } break ; case GF_KEY_F5 : if ( is_connected ) reload = 1 ; break ; case GF_KEY_A : addon_visible = ! addon_visible ; gf_term_toggle_addons ( term , addon_visible ) ; break ; case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed * 2 ) ; } break ; case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed / 2 ) ; } break ; case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( - 1 * playback_speed ) ; } break ; } break ; case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) { is_connected = 1 ; fprintf ( stderr , ""Service<S2SV_blank>Connected\\n"" ) ; eos_seen = GF_FALSE ; if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ; } else if ( is_connected ) { fprintf ( stderr , ""Service<S2SV_blank>%s\\n"" , is_connected ? ""Disconnected"" : ""Connection<S2SV_blank>Failed"" ) ; is_connected = 0 ; Duration = 0 ; } if ( init_w && init_h ) { gf_term_set_size ( term , init_w , init_h ) ; } ResetCaption ( ) ; break ; case GF_EVENT_EOS : eos_seen = GF_TRUE ; if ( playlist ) { if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ; } else if ( loop_at_end ) { restart = 1 ; } break ; case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) { GF_Event move ; move . type = GF_EVENT_MOVE ; move . move . align_x = align_mode & 0xFF ; move . move . align_y = ( align_mode >> 8 ) & 0xFF ; move . move . relative = 2 ; gf_term_user_event ( term , & move ) ; } break ; case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) { GF_Event size ; size . type = GF_EVENT_SIZE ; size . size . width = forced_width ; size . size . height = forced_height ; gf_term_user_event ( term , & size ) ; } break ; case GF_EVENT_METADATA : ResetCaption ( ) ; break ; case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ; break ; case GF_EVENT_DROPFILE : { u32 i , pos ; if ( readonly_playlist ) { gf_fclose ( playlist ) ; playlist = NULL ; } readonly_playlist = 0 ; if ( ! playlist ) { readonly_playlist = 0 ; playlist = gf_temp_file_new ( NULL ) ; } pos = ftell ( playlist ) ; i = 0 ; while ( i < evt -> open_file . nb_files ) { if ( evt -> open_file . files [ i ] != NULL ) { fprintf ( playlist , ""%s\\n"" , evt -> open_file . files [ i ] ) ; } i ++ ; } fseek ( playlist , pos , SEEK_SET ) ; request_next_playlist_item = 1 ; } return 1 ; case GF_EVENT_QUIT : if ( evt -> message . error ) { fprintf ( stderr , ""A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\n"" , evt -> message . message ? evt -> message . message : ""no<S2SV_blank>details"" , gf_error_to_string ( evt -> message . error ) ) ; } Run = 0 ; break ; case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ; break ; case GF_EVENT_MIGRATE : { } break ; case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , ""Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\""%s\\""\\r"" , evt -> navigate . to_url ) ; break ; case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) { <S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n"" , the_url ) ; gf_term_navigate_to ( term , evt -> navigate . to_url ) ; return 1 ; } else { fprintf ( stderr , ""Navigation<S2SV_blank>destination<S2SV_blank>not<S2SV_blank>supported\\nGo<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>%s\\n"" , evt -> navigate . to_url ) ; } break ; case GF_EVENT_SET_CAPTION : gf_term_user_event ( term , evt ) ; break ; case GF_EVENT_AUTHORIZATION : { int maxTries = 1 ; assert ( evt -> type == GF_EVENT_AUTHORIZATION ) ; assert ( evt -> auth . user ) ; assert ( evt -> auth . password ) ; assert ( evt -> auth . site_url ) ; while ( ( ! strlen ( evt -> auth . user ) || ! strlen ( evt -> auth . password ) ) && ( maxTries -- ) >= 0 ) { fprintf ( stderr , ""****<S2SV_blank>Authorization<S2SV_blank>required<S2SV_blank>for<S2SV_blank>site<S2SV_blank>%s<S2SV_blank>****\\n"" , evt -> auth . site_url ) ; fprintf ( stderr , ""login<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>"" ) ; read_line_input ( evt -> auth . user , 50 , 1 ) ; fprintf ( stderr , ""\\npassword:<S2SV_blank>"" ) ; read_line_input ( evt -> auth . password , 50 , 0 ) ; fprintf ( stderr , ""*********\\n"" ) ; } if ( maxTries < 0 ) { fprintf ( stderr , ""****<S2SV_blank>No<S2SV_blank>User<S2SV_blank>or<S2SV_blank>password<S2SV_blank>has<S2SV_blank>been<S2SV_blank>filled,<S2SV_blank>aborting<S2SV_blank>***\\n"" ) ; return 0 ; } return 1 ; } case GF_EVENT_ADDON_DETECTED : if ( enable_add_ons ) { fprintf ( stderr , ""Media<S2SV_blank>Addon<S2SV_blank>%s<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>enabling<S2SV_blank>it\\n"" , evt -> addon_connect . addon_url ) ; addon_visible = 1 ; } return enable_add_ons ; } return 0 ; }",") ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf ("
766,"static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , ""Attempt<S2SV_blank>to<S2SV_blank>alias<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>key<S2SV_blank>%s;<S2SV_blank>Ignored\\n"" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , ""Attempt<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alias<S2SV_blank>with<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>a<S2SV_blank>real<S2SV_blank>key;<S2SV_blank>"" ""Alias<S2SV_blank>\\""%s<S2SV_blank>=<S2SV_blank>%s\\""<S2SV_blank>ignored\\n"" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ; <S2SV_StartBug> } <S2SV_EndBug> i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } } <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> keymap -> key_aliases = key_aliases ; return true ; }",return false ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; } } }
767,"<S2SV_StartBug> static inline struct enamemem * <S2SV_EndBug> lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) { <S2SV_StartBug> struct enamemem * tp ; <S2SV_EndBug> register u_int i , j , k ; if ( nlen >= 6 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = ( bs [ 4 ] << 8 ) | bs [ 5 ] ; } else if ( nlen >= 4 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = 0 ; } else i = j = k = 0 ; tp = & bytestringtable [ ( i ^ j ) & ( HASHNAMESIZE - 1 ) ] ; <S2SV_StartBug> while ( tp -> e_nxt ) <S2SV_EndBug> if ( tp -> e_addr0 == i && <S2SV_StartBug> tp -> e_addr1 == j && <S2SV_EndBug> <S2SV_StartBug> tp -> e_addr2 == k && <S2SV_EndBug> <S2SV_StartBug> memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 ) <S2SV_EndBug> return tp ; else <S2SV_StartBug> tp = tp -> e_nxt ; <S2SV_EndBug> tp -> e_addr0 = i ; tp -> e_addr1 = j ; tp -> e_addr2 = k ; tp -> e_bs = ( u_char * ) calloc ( 1 , nlen + 1 ) ; <S2SV_StartBug> if ( tp -> e_bs == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ; <S2SV_StartBug> memcpy ( tp -> e_bs , bs , nlen ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_nxt == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ; return tp ; }","static inline struct bsnamemem <S2SV_ModEnd> * lookup_bytestring ( <S2SV_ModStart> ) { struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes <S2SV_ModEnd> && tp -> <S2SV_ModStart> && tp -> bs_addr0 == i <S2SV_ModEnd> && tp -> <S2SV_ModStart> && tp -> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> == k && <S2SV_ModStart> ( tp -> bs_bytes <S2SV_ModEnd> ) , nlen <S2SV_ModStart> = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> = ( u_char <S2SV_ModStart> ( tp -> bs_bytes <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <S2SV_ModEnd> = ( struct <S2SV_ModStart> = ( struct bsnamemem <S2SV_ModEnd> * ) calloc <S2SV_ModStart> ( tp -> bs_nxt <S2SV_ModEnd> == NULL )"
768,"int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; const int fps = 30 ; const int bitrate = 200 ; int keyframe_interval = 0 ; const char * codec_arg = NULL ; const char * width_arg = NULL ; const char * height_arg = NULL ; const char * infile_arg = NULL ; const char * outfile_arg = NULL ; const char * keyframe_interval_arg = NULL ; exec_name = argv [ 0 ] ; if ( argc < 7 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; codec_arg = argv [ 1 ] ; width_arg = argv [ 2 ] ; height_arg = argv [ 3 ] ; infile_arg = argv [ 4 ] ; outfile_arg = argv [ 5 ] ; keyframe_interval_arg = argv [ 6 ] ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; info . frame_height = strtol ( height_arg , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; } keyframe_interval = strtol ( keyframe_interval_arg , NULL , 0 ) ; if ( keyframe_interval < 0 ) die ( ""Invalid<S2SV_blank>keyframe<S2SV_blank>interval<S2SV_blank>value."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; cfg . g_error_resilient = argc > 7 ? strtol ( argv [ 7 ] , NULL , 0 ) : 0 ; writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , outfile_arg ) ; if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , infile_arg ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { int flags = 0 ; if ( keyframe_interval > 0 && frame_count % keyframe_interval == 0 ) flags |= VPX_EFLAG_FORCE_KF ; encode_frame ( & codec , & raw , frame_count ++ , flags , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , 0 , writer ) ; <S2SV_EndBug> printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }","( encoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> ) ; } while ( <S2SV_ModStart> , writer ) ) { }"
769,"int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) { unsigned int len , avail ; char * old , * new ; struct kvec * vec ; if ( ! ( p = decode_fh ( p , & args -> ffh ) ) || ! ( p = decode_filename ( p , & args -> fname , & args -> flen ) ) ) return 0 ; p = decode_sattr3 ( p , & args -> attrs ) ; len = ntohl ( * p ++ ) ; if ( len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE ) return 0 ; args -> tname = new = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; args -> tlen = len ; old = ( char * ) p ; vec = & rqstp -> rq_arg . head [ 0 ] ; <S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } if ( len && ! avail && rqstp -> rq_arg . page_len ) { avail = min_t ( unsigned int , rqstp -> rq_arg . page_len , PAGE_SIZE ) ; old = page_address ( rqstp -> rq_arg . pages [ 0 ] ) ; } while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } * new = '\\0' ; if ( len ) return 0 ; return 1 ; }",0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
770,"static inline int btif_hl_select_wake_reset ( void ) { char sig_recv = 0 ; BTIF_TRACE_DEBUG ( ""btif_hl_select_wake_reset"" ) ; <S2SV_StartBug> recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> return ( int ) sig_recv ; }","""btif_hl_select_wake_reset"" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )"
771,"<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> * offset = bloc ; }","int * offset , int maxoffset <S2SV_ModStart> NULL , fout , maxoffset"
772,"jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; <S2SV_StartBug> box -> info = boxinfo ; <S2SV_EndBug> box -> ops = & boxinfo -> ops ; box -> len = len ; JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) ; if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <S2SV_StartBug> box -> ops = & jp2_boxinfo_unk . ops ; <S2SV_EndBug> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } <S2SV_StartBug> jas_stream_rewind ( tmpstream ) ; <S2SV_EndBug> if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }","info = boxinfo <S2SV_ModEnd> ; box -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" <S2SV_ModStart> ( tmpstream ) ; box -> ops = & boxinfo -> ops"
773,"static void record_recent_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , <S2SV_EndBug> void * data ) { sha1_array_append ( & recent_objects , obj -> oid . hash ) ; }","* obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *"
774,"void big_key_revoke ( struct key * key ) { struct path * path = ( struct path * ) & key -> payload . data [ big_key_path ] ; key_payload_reserve ( key , 0 ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }",; if ( key_is_positive <S2SV_ModEnd> ( key )
775,"int read_xattrs_from_disk ( int fd , struct squashfs_super_block * sBlk , int flag , long long * table_start ) { <S2SV_StartBug> int res , bytes , i , indexes , index_bytes , ids ; <S2SV_EndBug> long long * index , start , end ; struct squashfs_xattr_table id_table ; TRACE ( ""read_xattrs_from_disk\\n"" ) ; if ( sBlk -> xattr_id_table_start == SQUASHFS_INVALID_BLK ) return SQUASHFS_INVALID_BLK ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start , sizeof ( id_table ) , & id_table ) ; if ( res == 0 ) return 0 ; SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ; <S2SV_StartBug> if ( flag ) { <S2SV_EndBug> * table_start = id_table . xattr_table_start ; <S2SV_StartBug> return id_table . xattr_ids ; <S2SV_EndBug> } ids = id_table . xattr_ids ; xattr_table_start = id_table . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ids ) ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , <S2SV_EndBug> index_bytes , index ) ; if ( res == 0 ) goto failed1 ; SQUASHFS_INSWAP_LONG_LONGS ( index , indexes ) ; <S2SV_StartBug> bytes = SQUASHFS_XATTR_BYTES ( ids ) ; <S2SV_EndBug> xattr_ids = malloc ( bytes ) ; if ( xattr_ids == NULL ) MEM_ERROR ( ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + <S2SV_StartBug> ( i * SQUASHFS_METADATA_SIZE ) ) ; <S2SV_EndBug> TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\n"" , i , index [ i ] , length ) ; if ( length == 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>"" ""from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>%d\\n"" , i , index [ i ] , length ) ; goto failed2 ; } } start = xattr_table_start ; end = index [ 0 ] ; for ( i = 0 ; start < end ; i ++ ) { int length ; xattrs = realloc ( xattrs , ( i + 1 ) * SQUASHFS_METADATA_SIZE ) ; if ( xattrs == NULL ) MEM_ERROR ( ) ; save_xattr_block ( start , i * SQUASHFS_METADATA_SIZE ) ; length = read_block ( fd , start , & start , 0 , ( ( unsigned char * ) xattrs ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d\\n"" , i , length ) ; if ( length == 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>xattr<S2SV_blank>block<S2SV_blank>%d\\n"" , i ) ; goto failed3 ; } if ( start != end && length != SQUASHFS_METADATA_SIZE ) { ERROR ( ""Xattr<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>length,<S2SV_blank>"" ""it<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\\n"" , i , SQUASHFS_METADATA_SIZE , length ) ; goto failed3 ; } } for ( i = 0 ; i < ids ; i ++ ) SQUASHFS_INSWAP_XATTR_ID ( & xattr_ids [ i ] ) ; free ( index ) ; return ids ; failed3 : free ( xattrs ) ; failed2 : free ( xattr_ids ) ; failed1 : free ( index ) ; return 0 ; }","int res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long long <S2SV_ModStart> id_table ) ; ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> = id_table . <S2SV_ModStart> . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> sBlk -> xattr_id_table_start <S2SV_ModStart> ( id_table ) ) ) ) { ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> = SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> ) + ( ( long long )"
776,"static int pad_pkcs2 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t pad , h1 [ RLC_MD_LEN ] , h2 [ RLC_MD_LEN ] ; uint8_t * mask = RLC_ALLOCA ( uint8_t , k_len ) ; <S2SV_StartBug> int result = RLC_OK ; <S2SV_EndBug> bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : md_map ( h1 , NULL , 0 ) ; bn_read_bin ( m , h1 , RLC_MD_LEN ) ; * p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len ; bn_lsh ( m , m , * p_len * 8 ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0x01 ) ; bn_lsh ( m , m , m_len * 8 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_ENC_FIN : rand_bytes ( h1 , RLC_MD_LEN ) ; md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < t -> used ; i ++ ) { m -> dp [ i ] ^= t -> dp [ i ] ; } bn_write_bin ( mask , k_len - RLC_MD_LEN - 1 , m ) ; md_mgf ( h2 , RLC_MD_LEN , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < RLC_MD_LEN ; i ++ ) { h1 [ i ] ^= h2 [ i ] ; } bn_read_bin ( t , h1 , RLC_MD_LEN ) ; bn_lsh ( t , t , 8 * ( k_len - RLC_MD_LEN - 1 ) ) ; bn_add ( t , t , m ) ; bn_copy ( m , t ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } m_len -= RLC_MD_LEN ; bn_rsh ( t , m , 8 * m_len ) ; bn_write_bin ( h1 , RLC_MD_LEN , t ) ; bn_mod_2b ( m , m , 8 * m_len ) ; bn_write_bin ( mask , m_len , m ) ; md_mgf ( h2 , RLC_MD_LEN , mask , m_len ) ; for ( int i = 0 ; i < RLC_MD_LEN ; i ++ ) { h1 [ i ] ^= h2 [ i ] ; } md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < t -> used ; i ++ ) { m -> dp [ i ] ^= t -> dp [ i ] ; } m_len -= RLC_MD_LEN ; bn_rsh ( t , m , 8 * m_len ) ; bn_write_bin ( h2 , RLC_MD_LEN , t ) ; md_map ( h1 , NULL , 0 ) ; pad = 0 ; for ( int i = 0 ; i < RLC_MD_LEN ; i ++ ) { <S2SV_StartBug> pad |= h1 [ i ] - h2 [ i ] ; <S2SV_EndBug> } <S2SV_StartBug> if ( result == RLC_OK ) { <S2SV_EndBug> result = ( pad ? RLC_ERR : RLC_OK ) ; } <S2SV_StartBug> bn_mod_2b ( m , m , 8 * m_len ) ; <S2SV_EndBug> * p_len = bn_size_bin ( m ) ; ( * p_len ) -- ; bn_rsh ( t , m , * p_len * 8 ) ; if ( bn_cmp_dig ( t , 1 ) != RLC_EQ ) { result = RLC_ERR ; } bn_mod_2b ( m , m , * p_len * 8 ) ; * p_len = k_len - * p_len ; break ; case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 64 ) ; bn_lsh ( m , m , RLC_MD_LEN * 8 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_SIG_FIN : memset ( mask , 0 , 8 ) ; bn_write_bin ( mask + 8 , RLC_MD_LEN , m ) ; md_map ( h1 , mask , RLC_MD_LEN + 8 ) ; bn_read_bin ( m , h1 , RLC_MD_LEN ) ; md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; t -> dp [ 0 ] ^= 0x01 ; bn_lsh ( t , t , 8 * RLC_MD_LEN ) ; bn_add ( m , t , m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PSS ) ; for ( int i = m_len - 1 ; i < 8 * k_len ; i ++ ) { bn_set_bit ( m , i , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_VER : case RSA_VER_HASH : bn_mod_2b ( t , m , 8 ) ; <S2SV_StartBug> if ( bn_cmp_dig ( t , RSA_PSS ) != RLC_EQ ) { <S2SV_EndBug> result = RLC_ERR ; } else { for ( int i = m_len ; i < 8 * k_len ; i ++ ) { if ( bn_get_bit ( m , i ) != 0 ) { result = RLC_ERR ; } } bn_rsh ( m , m , 8 ) ; bn_mod_2b ( t , m , 8 * RLC_MD_LEN ) ; bn_write_bin ( h2 , RLC_MD_LEN , t ) ; bn_rsh ( m , m , 8 * RLC_MD_LEN ) ; bn_write_bin ( h1 , RLC_MD_LEN , t ) ; md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ; bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ; for ( int i = 0 ; i < t -> used ; i ++ ) { m -> dp [ i ] ^= t -> dp [ i ] ; } m -> dp [ 0 ] ^= 0x01 ; for ( int i = m_len - 1 ; i < 8 * k_len ; i ++ ) { bn_set_bit ( m , i - ( ( RLC_MD_LEN + 1 ) * 8 ) , 0 ) ; } <S2SV_StartBug> if ( ! bn_is_zero ( m ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } bn_read_bin ( m , h2 , RLC_MD_LEN ) ; * p_len = k_len - RLC_MD_LEN ; } break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } RLC_FREE ( mask ) ; return result ; }","int result = RLC_ERR <S2SV_ModEnd> ; bn_t t <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> t ) ; result = RLC_OK ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> m_len -= RLC_MD_LEN <S2SV_ModStart> [ i ] ^ <S2SV_ModEnd> h2 [ i <S2SV_ModStart> ] ; } bn_mod_2b ( m , m , 8 * m_len ) ; * p_len = bn_size_bin ( m ) ; ( * p_len ) -- ; bn_rsh ( t , m , * p_len * 8 ) ; if ( pad == 0 && bn_cmp_dig ( t , 1 ) == RLC_EQ ) { result = RLC_OK <S2SV_ModEnd> ; } bn_mod_2b <S2SV_ModStart> , m , * p_len * 8 ) ; * p_len = k_len - * p_len ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> ) ; } result = RLC_OK ; <S2SV_ModStart> 8 ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PSS ) { int r = 1 ; for ( int i = m_len ; i < 8 * k_len ; i ++ ) { if ( bn_get_bit ( m , i ) != 0 ) { r = 0 <S2SV_ModEnd> ; } } <S2SV_ModStart> } if ( r == 1 && <S2SV_ModEnd> bn_is_zero ( m <S2SV_ModStart> { result = RLC_OK <S2SV_ModEnd> ; } bn_read_bin"
777,"void vp9_setup_mask ( VP9_COMMON * const cm , const int mi_row , const int mi_col , <S2SV_StartBug> MODE_INFO * * mi_8x8 , const int mode_info_stride , <S2SV_EndBug> LOOP_FILTER_MASK * lfm ) { int idx_32 , idx_16 , idx_8 ; const loop_filter_info_n * const lfi_n = & cm -> lf_info ; <S2SV_StartBug> MODE_INFO * * mip = mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mip2 = mi_8x8 ; <S2SV_EndBug> const int offset_32 [ ] = { 4 , ( mode_info_stride << 2 ) - 4 , 4 , - ( mode_info_stride << 2 ) - 4 } ; const int offset_16 [ ] = { 2 , ( mode_info_stride << 1 ) - 2 , 2 , - ( mode_info_stride << 1 ) - 2 } ; const int offset [ ] = { 1 , mode_info_stride - 1 , 1 , - mode_info_stride - 1 } ; const int shift_32_y [ ] = { 0 , 4 , 32 , 36 } ; const int shift_16_y [ ] = { 0 , 2 , 16 , 18 } ; const int shift_8_y [ ] = { 0 , 1 , 8 , 9 } ; const int shift_32_uv [ ] = { 0 , 2 , 8 , 10 } ; const int shift_16_uv [ ] = { 0 , 1 , 4 , 5 } ; int i ; const int max_rows = ( mi_row + MI_BLOCK_SIZE > cm -> mi_rows ? cm -> mi_rows - mi_row : MI_BLOCK_SIZE ) ; const int max_cols = ( mi_col + MI_BLOCK_SIZE > cm -> mi_cols ? cm -> mi_cols - mi_col : MI_BLOCK_SIZE ) ; <S2SV_StartBug> vp9_zero ( * lfm ) ; <S2SV_EndBug> switch ( mip [ 0 ] -> mbmi . sb_type ) { case BLOCK_64X64 : build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; break ; case BLOCK_64X32 : build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; mip2 = mip + mode_info_stride * 4 ; if ( 4 >= max_rows ) break ; build_masks ( lfi_n , mip2 [ 0 ] , 32 , 8 , lfm ) ; break ; case BLOCK_32X64 : build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; mip2 = mip + 4 ; if ( 4 >= max_cols ) break ; build_masks ( lfi_n , mip2 [ 0 ] , 4 , 2 , lfm ) ; break ; default : for ( idx_32 = 0 ; idx_32 < 4 ; mip += offset_32 [ idx_32 ] , ++ idx_32 ) { const int shift_y = shift_32_y [ idx_32 ] ; const int shift_uv = shift_32_uv [ idx_32 ] ; const int mi_32_col_offset = ( ( idx_32 & 1 ) << 2 ) ; const int mi_32_row_offset = ( ( idx_32 >> 1 ) << 2 ) ; if ( mi_32_col_offset >= max_cols || mi_32_row_offset >= max_rows ) continue ; switch ( mip [ 0 ] -> mbmi . sb_type ) { case BLOCK_32X32 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; break ; case BLOCK_32X16 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_32_row_offset + 2 >= max_rows ) continue ; mip2 = mip + mode_info_stride * 2 ; build_masks ( lfi_n , mip2 [ 0 ] , shift_y + 16 , shift_uv + 4 , lfm ) ; break ; case BLOCK_16X32 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_32_col_offset + 2 >= max_cols ) continue ; mip2 = mip + 2 ; build_masks ( lfi_n , mip2 [ 0 ] , shift_y + 2 , shift_uv + 1 , lfm ) ; break ; default : for ( idx_16 = 0 ; idx_16 < 4 ; mip += offset_16 [ idx_16 ] , ++ idx_16 ) { const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] ; const int shift_uv = shift_32_uv [ idx_32 ] + shift_16_uv [ idx_16 ] ; const int mi_16_col_offset = mi_32_col_offset + ( ( idx_16 & 1 ) << 1 ) ; const int mi_16_row_offset = mi_32_row_offset + ( ( idx_16 >> 1 ) << 1 ) ; if ( mi_16_col_offset >= max_cols || mi_16_row_offset >= max_rows ) continue ; switch ( mip [ 0 ] -> mbmi . sb_type ) { case BLOCK_16X16 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; break ; case BLOCK_16X8 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_16_row_offset + 1 >= max_rows ) continue ; mip2 = mip + mode_info_stride ; build_y_mask ( lfi_n , mip2 [ 0 ] , shift_y + 8 , lfm ) ; break ; case BLOCK_8X16 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_16_col_offset + 1 >= max_cols ) continue ; mip2 = mip + 1 ; build_y_mask ( lfi_n , mip2 [ 0 ] , shift_y + 1 , lfm ) ; break ; default : { const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] + shift_8_y [ 0 ] ; build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; mip += offset [ 0 ] ; for ( idx_8 = 1 ; idx_8 < 4 ; mip += offset [ idx_8 ] , ++ idx_8 ) { const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] + shift_8_y [ idx_8 ] ; const int mi_8_col_offset = mi_16_col_offset + ( ( idx_8 & 1 ) ) ; const int mi_8_row_offset = mi_16_row_offset + ( ( idx_8 >> 1 ) ) ; if ( mi_8_col_offset >= max_cols || mi_8_row_offset >= max_rows ) continue ; build_y_mask ( lfi_n , mip [ 0 ] , shift_y , lfm ) ; } break ; } } } break ; } } break ; } lfm -> left_y [ TX_16X16 ] |= lfm -> left_y [ TX_32X32 ] ; lfm -> above_y [ TX_16X16 ] |= lfm -> above_y [ TX_32X32 ] ; lfm -> left_uv [ TX_16X16 ] |= lfm -> left_uv [ TX_32X32 ] ; lfm -> above_uv [ TX_16X16 ] |= lfm -> above_uv [ TX_32X32 ] ; lfm -> left_y [ TX_8X8 ] |= lfm -> left_y [ TX_4X4 ] & left_border ; lfm -> left_y [ TX_4X4 ] &= ~ left_border ; lfm -> above_y [ TX_8X8 ] |= lfm -> above_y [ TX_4X4 ] & above_border ; lfm -> above_y [ TX_4X4 ] &= ~ above_border ; lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_4X4 ] & left_border_uv ; lfm -> left_uv [ TX_4X4 ] &= ~ left_border_uv ; lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_4X4 ] & above_border_uv ; lfm -> above_uv [ TX_4X4 ] &= ~ above_border_uv ; if ( mi_row + MI_BLOCK_SIZE > cm -> mi_rows ) { const uint64_t rows = cm -> mi_rows - mi_row ; const uint64_t mask_y = ( ( ( uint64_t ) 1 << ( rows << 3 ) ) - 1 ) ; const uint16_t mask_uv = ( ( ( uint16_t ) 1 << ( ( ( rows + 1 ) >> 1 ) << 2 ) ) - 1 ) ; for ( i = 0 ; i < TX_32X32 ; i ++ ) { lfm -> left_y [ i ] &= mask_y ; lfm -> above_y [ i ] &= mask_y ; lfm -> left_uv [ i ] &= mask_uv ; lfm -> above_uv [ i ] &= mask_uv ; } lfm -> int_4x4_y &= mask_y ; lfm -> int_4x4_uv &= mask_uv ; if ( rows == 1 ) { lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] ; lfm -> above_uv [ TX_16X16 ] = 0 ; } if ( rows == 5 ) { lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] & 0xff00 ; lfm -> above_uv [ TX_16X16 ] &= ~ ( lfm -> above_uv [ TX_16X16 ] & 0xff00 ) ; } } if ( mi_col + MI_BLOCK_SIZE > cm -> mi_cols ) { const uint64_t columns = cm -> mi_cols - mi_col ; <S2SV_StartBug> const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101 ; <S2SV_EndBug> const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ; const uint16_t mask_uv_int = ( ( 1 << ( columns >> 1 ) ) - 1 ) * 0x1111 ; for ( i = 0 ; i < TX_32X32 ; i ++ ) { lfm -> left_y [ i ] &= mask_y ; lfm -> above_y [ i ] &= mask_y ; lfm -> left_uv [ i ] &= mask_uv ; lfm -> above_uv [ i ] &= mask_uv ; } lfm -> int_4x4_y &= mask_y ; lfm -> int_4x4_uv &= mask_uv_int ; if ( columns == 1 ) { lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_16X16 ] ; lfm -> left_uv [ TX_16X16 ] = 0 ; } if ( columns == 5 ) { lfm -> left_uv [ TX_8X8 ] |= ( lfm -> left_uv [ TX_16X16 ] & 0xcccc ) ; lfm -> left_uv [ TX_16X16 ] &= ~ ( lfm -> left_uv [ TX_16X16 ] & 0xcccc ) ; } } if ( mi_col == 0 ) { for ( i = 0 ; i < TX_32X32 ; i ++ ) { <S2SV_StartBug> lfm -> left_y [ i ] &= 0xfefefefefefefefe ; <S2SV_EndBug> lfm -> left_uv [ i ] &= 0xeeee ; } } assert ( ! ( lfm -> left_y [ TX_16X16 ] & lfm -> left_y [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> left_y [ TX_16X16 ] & lfm -> left_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> left_y [ TX_8X8 ] & lfm -> left_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_y & lfm -> left_y [ TX_16X16 ] ) ) ; assert ( ! ( lfm -> left_uv [ TX_16X16 ] & lfm -> left_uv [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> left_uv [ TX_16X16 ] & lfm -> left_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> left_uv [ TX_8X8 ] & lfm -> left_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_uv & lfm -> left_uv [ TX_16X16 ] ) ) ; assert ( ! ( lfm -> above_y [ TX_16X16 ] & lfm -> above_y [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> above_y [ TX_16X16 ] & lfm -> above_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> above_y [ TX_8X8 ] & lfm -> above_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_y & lfm -> above_y [ TX_16X16 ] ) ) ; assert ( ! ( lfm -> above_uv [ TX_16X16 ] & lfm -> above_uv [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> above_uv [ TX_16X16 ] & lfm -> above_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> above_uv [ TX_8X8 ] & lfm -> above_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_uv & lfm -> above_uv [ TX_16X16 ] ) ) ; }","MODE_INFO * * mi <S2SV_ModEnd> , const int <S2SV_ModStart> * mip = mi <S2SV_ModEnd> ; MODE_INFO * <S2SV_ModStart> * mip2 = mi <S2SV_ModEnd> ; const int <S2SV_ModStart> ( * lfm ) ; assert ( mip [ 0 ] != NULL <S2SV_ModStart> ) ) * 0x0101010101010101ULL <S2SV_ModEnd> ; const uint16_t <S2SV_ModStart> i ] &= 0xfefefefefefefefeULL <S2SV_ModEnd> ; lfm ->"
778,"void test_path_dotgit__dotgit_modules_symlink ( void ) { cl_assert_equal_b ( true , git_path_isvalid ( NULL , "".gitmodules"" , 0 , GIT_PATH_REJECT_DOT_GIT_HFS | GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_HFS ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; <S2SV_StartBug> } <S2SV_EndBug>",") ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules<S2SV_blank>.<S2SV_blank>.::$DATA"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ;"
779,"void addReply ( redisClient * c , robj * obj ) { if ( _installWriteEvent ( c ) != REDIS_OK ) return ; <S2SV_StartBug> redisAssert ( ! server . vm_enabled || obj -> storage == REDIS_VM_MEMORY ) ; <S2SV_EndBug> if ( obj -> encoding == REDIS_ENCODING_RAW ) { if ( _addReplyToBuffer ( c , obj -> ptr , sdslen ( obj -> ptr ) ) != REDIS_OK ) _addReplyObjectToList ( c , obj ) ; } else { obj = getDecodedObject ( obj ) ; if ( _addReplyToBuffer ( c , obj -> ptr , sdslen ( obj -> ptr ) ) != REDIS_OK ) _addReplyObjectToList ( c , obj ) ; decrRefCount ( obj ) ; } }",! server . ds_enabled <S2SV_ModEnd> || obj ->
780,"static ngx_int_t ngx_http_send_error_page ( ngx_http_request_t * r , ngx_http_err_page_t * err_page ) { ngx_int_t overwrite ; ngx_str_t uri , args ; ngx_table_elt_t * location ; ngx_http_core_loc_conf_t * clcf ; overwrite = err_page -> overwrite ; if ( overwrite && overwrite != NGX_HTTP_OK ) { r -> expect_tested = 1 ; } if ( overwrite >= 0 ) { r -> err_status = overwrite ; } if ( ngx_http_complex_value ( r , & err_page -> value , & uri ) != NGX_OK ) { return NGX_ERROR ; } if ( uri . len && uri . data [ 0 ] == '/' ) { if ( err_page -> value . lengths ) { ngx_http_split_args ( r , & uri , & args ) ; } else { args = err_page -> args ; } if ( r -> method != NGX_HTTP_HEAD ) { r -> method = NGX_HTTP_GET ; r -> method_name = ngx_http_core_get_method ; } return ngx_http_internal_redirect ( r , & uri , & args ) ; } if ( uri . len && uri . data [ 0 ] == '@' ) { return ngx_http_named_location ( r , & uri ) ; } <S2SV_StartBug> location = ngx_list_push ( & r -> headers_out . headers ) ; <S2SV_EndBug> if ( location == NULL ) { return NGX_ERROR ; } if ( overwrite != NGX_HTTP_MOVED_PERMANENTLY && overwrite != NGX_HTTP_MOVED_TEMPORARILY && overwrite != NGX_HTTP_SEE_OTHER && overwrite != NGX_HTTP_TEMPORARY_REDIRECT && overwrite != NGX_HTTP_PERMANENT_REDIRECT ) { r -> err_status = NGX_HTTP_MOVED_TEMPORARILY ; } location -> hash = 1 ; ngx_str_set ( & location -> key , ""Location"" ) ; location -> value = uri ; ngx_http_clear_location ( r ) ; r -> headers_out . location = location ; clcf = ngx_http_get_module_loc_conf ( r , ngx_http_core_module ) ; if ( clcf -> msie_refresh && r -> headers_in . msie ) { return ngx_http_send_refresh ( r ) ; } return ngx_http_send_special_response ( r , clcf , r -> err_status - NGX_HTTP_MOVED_PERMANENTLY + NGX_HTTP_OFF_3XX ) ; }",) ; } r -> expect_tested = 1 ; if ( ngx_http_discard_request_body ( r ) != NGX_OK ) { r -> keepalive = 0 ; }
781,"static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }",! unconditional ( e <S2SV_ModEnd> ) ) return
782,"void dump_global_data ( FILE * fp , data_t * data ) { # ifdef _WITH_VRRP_ char buf [ 64 ] ; # endif if ( ! data ) return ; conf_write ( fp , ""------<<S2SV_blank>Global<S2SV_blank>definitions<S2SV_blank>>------"" ) ; # if HAVE_DECL_CLONE_NEWNET conf_write ( fp , ""<S2SV_blank>Network<S2SV_blank>namespace<S2SV_blank>=<S2SV_blank>%s"" , data -> network_namespace ? data -> network_namespace : ""(default)"" ) ; # endif if ( data -> instance_name ) conf_write ( fp , ""<S2SV_blank>Instance<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> instance_name ) ; if ( data -> router_id ) conf_write ( fp , ""<S2SV_blank>Router<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%s"" , data -> router_id ) ; if ( data -> smtp_server . ss_family ) { conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( & data -> smtp_server ) ) ; conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%u"" , ntohs ( inet_sockaddrport ( & data -> smtp_server ) ) ) ; } if ( data -> smtp_helo_name ) conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>HELO<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_helo_name ) ; if ( data -> smtp_connection_to ) conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>connection<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%lu"" , data -> smtp_connection_to / TIMER_HZ ) ; if ( data -> email_from ) { conf_write ( fp , ""<S2SV_blank>Email<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>=<S2SV_blank>%s"" , data -> email_from ) ; dump_list ( fp , data -> email ) ; } conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert == - 1 ? ""unset"" : data -> smtp_alert ? ""on"" : ""off"" ) ; # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert_vrrp<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert_vrrp == - 1 ? ""unset"" : data -> smtp_alert_vrrp ? ""on"" : ""off"" ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert_checker<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert_checker == - 1 ? ""unset"" : data -> smtp_alert_checker ? ""on"" : ""off"" ) ; # endif # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>Dynamic<S2SV_blank>interfaces<S2SV_blank>=<S2SV_blank>%s"" , data -> dynamic_interfaces ? ""true"" : ""false"" ) ; if ( data -> dynamic_interfaces ) conf_write ( fp , ""<S2SV_blank>Allow<S2SV_blank>interface<S2SV_blank>changes<S2SV_blank>=<S2SV_blank>%s"" , data -> allow_if_changes ? ""true"" : ""false"" ) ; if ( data -> no_email_faults ) conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>emails<S2SV_blank>for<S2SV_blank>fault<S2SV_blank>transitions<S2SV_blank>=<S2SV_blank>off"" ) ; # endif # ifdef _WITH_LVS_ if ( data -> lvs_tcp_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_tcp_timeout ) ; if ( data -> lvs_tcpfin_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>FIN<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_tcpfin_timeout ) ; if ( data -> lvs_udp_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_udp_timeout ) ; # ifdef _WITH_VRRP_ # ifndef _DEBUG_ if ( prog_type == PROG_TYPE_VRRP ) # endif conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s"" , data -> default_ifp ? data -> default_ifp -> ifname : DFLT_INT ) ; if ( data -> lvs_syncd . vrrp ) { conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>vrrp<S2SV_blank>instance<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_syncd . vrrp -> iname ) ; if ( data -> lvs_syncd . ifname ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_syncd . ifname ) ; conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>syncid<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . syncid ) ; # ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_ if ( data -> lvs_syncd . sync_maxlen ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>maxlen<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . sync_maxlen ) ; if ( data -> lvs_syncd . mcast_group . ss_family != AF_UNSPEC ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>%s"" , inet_sockaddrtos ( & data -> lvs_syncd . mcast_group ) ) ; if ( data -> lvs_syncd . mcast_port ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_syncd . mcast_port ) ; if ( data -> lvs_syncd . mcast_ttl ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>ttl<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . mcast_ttl ) ; # endif } # endif conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>flush<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_flush ? ""true"" : ""false"" ) ; # endif if ( data -> notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> notify_fifo . name ) ; if ( data -> notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> notify_fifo . script ) , data -> notify_fifo . script -> uid , data -> notify_fifo . script -> gid ) ; } # ifdef _WITH_VRRP_ if ( data -> vrrp_notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_notify_fifo . name ) ; if ( data -> vrrp_notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> vrrp_notify_fifo . script ) , data -> vrrp_notify_fifo . script -> uid , data -> vrrp_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_LVS_ if ( data -> lvs_notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_notify_fifo . name ) ; if ( data -> lvs_notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> lvs_notify_fifo . script ) , data -> lvs_notify_fifo . script -> uid , data -> lvs_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_VRRP_ if ( data -> vrrp_mcast_group4 . sin_family ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>IPv4<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group4 ) ) ; } if ( data -> vrrp_mcast_group6 . sin6_family ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>IPv6<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group6 ) ) ; } conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_garp_delay / TIMER_HZ ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_garp_rep ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>timer<S2SV_blank>=<S2SV_blank>%lu"" , data -> vrrp_garp_refresh . tv_sec ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_refresh_rep ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data -> vrrp_garp_lower_prio_delay / TIMER_HZ ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_lower_prio_rep ) ; conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_lower_prio_no_advert ? ""false"" : ""true"" ) ; conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>higher<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_higher_prio_send_advert ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_interval ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>NA<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_gna_interval ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>default<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_version ) ; if ( data -> vrrp_iptables_inchain [ 0 ] ) conf_write ( fp , ""<S2SV_blank>Iptables<S2SV_blank>input<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_iptables_inchain ) ; if ( data -> vrrp_iptables_outchain [ 0 ] ) conf_write ( fp , ""<S2SV_blank>Iptables<S2SV_blank>output<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_iptables_outchain ) ; # ifdef _HAVE_LIBIPSET_ conf_write ( fp , ""<S2SV_blank>Using<S2SV_blank>ipsets<S2SV_blank>=<S2SV_blank>%s"" , data -> using_ipsets ? ""true"" : ""false"" ) ; if ( data -> vrrp_ipset_address [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address ) ; if ( data -> vrrp_ipset_address6 [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address6 ) ; if ( data -> vrrp_ipset_address_iface6 [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address,iface<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address_iface6 ) ; # endif conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>check<S2SV_blank>unicast_src<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_check_unicast_src ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>skip<S2SV_blank>check<S2SV_blank>advert<S2SV_blank>addresses<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_skip_check_adv_addr ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>strict<S2SV_blank>mode<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_strict ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_process_priority ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> vrrp_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> checker_process_priority ) ; conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> checker_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> checker_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> checker_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_BFD_ conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> bfd_process_priority ) ; conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> bfd_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> bfd_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> bfd_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_SNMP_VRRP_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>vrrp<S2SV_blank>%s"" , data -> enable_snmp_vrrp ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_CHECKER_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>checker<S2SV_blank>%s"" , data -> enable_snmp_checker ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_RFCV2_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>RFCv2<S2SV_blank>%s"" , data -> enable_snmp_rfcv2 ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_RFCV3_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>RFCv3<S2SV_blank>%s"" , data -> enable_snmp_rfcv3 ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>traps<S2SV_blank>%s"" , data -> enable_traps ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>socket<S2SV_blank>=<S2SV_blank>%s"" , data -> snmp_socket ? data -> snmp_socket : ""default<S2SV_blank>(unix:/var/agentx/master)"" ) ; # endif # ifdef _WITH_DBUS_ conf_write ( fp , ""<S2SV_blank>DBus<S2SV_blank>%s"" , data -> enable_dbus ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>DBus<S2SV_blank>service<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> dbus_service_name ? data -> dbus_service_name : """" ) ; # endif conf_write ( fp , ""<S2SV_blank>Script<S2SV_blank>security<S2SV_blank>%s"" , script_security ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>script<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , default_script_uid , default_script_gid ) ; # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>vrrp_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_cmd_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_monitor_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_monitor_rcv_bufs_force ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>lvs_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_cmd_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_monitor_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_monitor_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>rs_init_notifies<S2SV_blank>=<S2SV_blank>%u"" , global_data -> rs_init_notifies ) ; conf_write ( fp , ""<S2SV_blank>no_checker_emails<S2SV_blank>=<S2SV_blank>%u"" , global_data -> no_checker_emails ) ; # endif # ifdef _WITH_VRRP_ buf [ 0 ] = '\\0' ; if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU ) strcpy ( buf , ""<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>MTU"" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT ) strcpy ( buf , ""<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>ADVERT"" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_SIZE ) sprintf ( buf , ""<S2SV_blank>rx_bufs_size<S2SV_blank>=<S2SV_blank>%lu"" , global_data -> vrrp_rx_bufs_size ) ; if ( buf [ 0 ] ) conf_write ( fp , ""%s"" , buf ) ; conf_write ( fp , ""<S2SV_blank>rx_bufs_multiples<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_rx_bufs_multiples ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }","vrrp_rx_bufs_multiples ) ; conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ;"
783,"int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb ; unsigned int maxfraglen , fragheaderlen ; int exthdrlen ; int hh_len ; int mtu ; int copy ; int err ; int offset = 0 ; int csummode = CHECKSUM_NONE ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kmalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; sk -> sk_sndmsg_page = NULL ; sk -> sk_sndmsg_off = 0 ; exthdrlen = rt -> dst . header_len + ( opt ? opt -> opt_flen : 0 ) - rt -> rt6i_nfheader_len ; length += exthdrlen ; transhdrlen += exthdrlen ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) { err = sock_tx_timestamp ( sk , & tx_flags ) ; if ( err ) goto error ; } cork -> length += length ; if ( length > mtu ) { int proto = sk -> sk_protocol ; if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } if ( proto == IPPROTO_UDP && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , <S2SV_StartBug> transhdrlen , mtu , flags ) ; <S2SV_EndBug> if ( err ) goto error ; return 0 ; } } if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; struct sk_buff * skb_prev ; alloc_new_skb : skb_prev = skb ; if ( skb_prev ) fraggap = skb_prev -> len - maxfraglen ; else fraggap = 0 ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen ; fraglen = datalen + fragheaderlen ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; if ( datalen == length + fraggap ) alloclen += rt -> dst . trailer_len ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; csummode = CHECKSUM_NONE ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; skb_frag_t * frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; struct page * page = sk -> sk_sndmsg_page ; int off = sk -> sk_sndmsg_off ; unsigned int left ; if ( page && ( left = PAGE_SIZE - off ) > 0 ) { if ( copy >= left ) copy = left ; if ( page != frag -> page ) { if ( i == MAX_SKB_FRAGS ) { err = - EMSGSIZE ; goto error ; } get_page ( page ) ; skb_fill_page_desc ( skb , i , page , sk -> sk_sndmsg_off , 0 ) ; frag = & skb_shinfo ( skb ) -> frags [ i ] ; } } else if ( i < MAX_SKB_FRAGS ) { if ( copy > PAGE_SIZE ) copy = PAGE_SIZE ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( page == NULL ) { err = - ENOMEM ; goto error ; } sk -> sk_sndmsg_page = page ; sk -> sk_sndmsg_off = 0 ; skb_fill_page_desc ( skb , i , page , 0 , 0 ) ; frag = & skb_shinfo ( skb ) -> frags [ i ] ; } else { err = - EMSGSIZE ; goto error ; } if ( getfrag ( from , page_address ( frag -> page ) + frag -> page_offset + frag -> size , offset , copy , skb -> len , skb ) < 0 ) { err = - EFAULT ; goto error ; } sk -> sk_sndmsg_off += copy ; frag -> size += copy ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }","mtu , flags , rt"
784,"static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 << 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> if ( len == limit ) return ; js_pushliteral ( J , """" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }","{ if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog"
785,"static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n"" , size ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n"" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%"" PRId64 ""<S2SV_blank>ms\\n"" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n"" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n"" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ; <S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%"" PRId64 ""\\n"" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }",i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + size ; }
786,"<S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> { int sock [ 2 ] = { - 1 , - 1 } ; pid_t qpid , cpid = - 1 ; FILE * pids_file = NULL ; bool answer = false , fail = false ; pids_file = open_pids_file ( contrl , cg ) ; if ( ! pids_file ) return false ; if ( socketpair ( AF_UNIX , SOCK_DGRAM , 0 , sock ) < 0 ) { perror ( ""socketpair"" ) ; goto out ; } cpid = fork ( ) ; if ( cpid == - 1 ) goto out ; if ( ! cpid ) { fclose ( pids_file ) ; pid_from_ns_wrapper ( sock [ 1 ] , tpid ) ; } const char * ptr = buf ; while ( sscanf ( ptr , ""%d"" , & qpid ) == 1 ) { struct ucred cred ; char v ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) { fprintf ( stderr , ""%s:<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>pid<S2SV_blank>to<S2SV_blank>child:<S2SV_blank>%s\\n"" , __func__ , strerror ( errno ) ) ; goto out ; } if ( recv_creds ( sock [ 0 ] , & cred , & v ) ) { if ( v == '0' ) { <S2SV_StartBug> if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> fail = true ; } } ptr = strchr ( ptr , '\\n' ) ; if ( ! ptr ) break ; ptr ++ ; } qpid = - 1 ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) fprintf ( stderr , ""Warning:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ask<S2SV_blank>child<S2SV_blank>to<S2SV_blank>exit\\n"" ) ; if ( ! fail ) answer = true ; out : if ( cpid != - 1 ) wait_for_pid ( cpid ) ; if ( sock [ 0 ] != - 1 ) { close ( sock [ 0 ] ) ; close ( sock [ 1 ] ) ; } if ( pids_file ) { if ( fclose ( pids_file ) != 0 ) answer = false ; } return answer ; }","pid_t tpid , uid_t tuid , <S2SV_ModStart> { if ( ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> cred . pid <S2SV_ModStart> . pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid )"
787,"static void tcp_illinois_info ( struct sock * sk , u32 ext , struct sk_buff * skb ) { const struct illinois * ca = inet_csk_ca ( sk ) ; if ( ext & ( 1 << ( INET_DIAG_VEGASINFO - 1 ) ) ) { struct tcpvegas_info info = { . tcpv_enabled = 1 , . tcpv_rttcnt = ca -> cnt_rtt , . tcpv_minrtt = ca -> base_rtt , } ; <S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ; } }",", } ; if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> ( t , info . tcpv_rttcnt <S2SV_ModEnd> ) ; info <S2SV_ModStart> = t ; }"
788,"static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; if ( sock -> type == SOCK_PACKET ) msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; else msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ; if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } <S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }",0 ; } aux . tp_padding = 0 ;
789,"static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }",current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
790,"const char * string_of_NPNVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPNVxDisplay ) ; _ ( NPNVxtAppContext ) ; _ ( NPNVnetscapeWindow ) ; _ ( NPNVjavascriptEnabledBool ) ; _ ( NPNVasdEnabledBool ) ; _ ( NPNVisOfflineBool ) ; _ ( NPNVserviceManager ) ; _ ( NPNVDOMElement ) ; _ ( NPNVDOMWindow ) ; _ ( NPNVToolkit ) ; _ ( NPNVSupportsXEmbedBool ) ; _ ( NPNVWindowNPObject ) ; _ ( NPNVPluginElementNPObject ) ; _ ( NPNVSupportsWindowless ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPNVserviceManager ) ; _ ( 11 , NPNVDOMElement ) ; _ ( 12 , NPNVDOMWindow ) ; _ ( 13 , NPNVToolkit ) ; # undef _ default : str = ""<unknown<S2SV_blank>variable>"" ; break ; } break ; } return str ; }",NPNVSupportsWindowless ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
791,"void btif_config_save ( void ) { assert ( alarm_timer != NULL ) ; assert ( config != NULL ) ; <S2SV_StartBug> alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save , NULL ) ; <S2SV_EndBug> }",", CONFIG_SETTLE_PERIOD_MS , timer_config_save_cb <S2SV_ModEnd> , NULL )"
792,"cJSON * cJSON_DetachItemFromObject ( cJSON * object , const char * string ) { int i = 0 ; cJSON * c = object -> child ; <S2SV_StartBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) { <S2SV_EndBug> ++ i ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> if ( c ) return cJSON_DetachItemFromArray ( object , i ) ; return 0 ; }","string ) ) i ++ , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> if ( c"
793,"static int rose_parse_national ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char * pt ; unsigned char l , lg , n = 0 ; int fac_national_digis_received = 0 ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : if ( * p == FAC_NATIONAL_RAND ) facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ; p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ; if ( * p == FAC_NATIONAL_DEST_DIGI ) { if ( ! fac_national_digis_received ) { memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; facilities -> source_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_SRC_DIGI ) { if ( ! fac_national_digis_received ) { memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; facilities -> dest_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_FAIL_CALL ) { memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; } else if ( * p == FAC_NATIONAL_FAIL_ADD ) { memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; } else if ( * p == FAC_NATIONAL_DIGIS ) { fac_national_digis_received = 1 ; facilities -> source_ndigis = 0 ; facilities -> dest_ndigis = 0 ; for ( pt = p + 2 , lg = 0 ; lg < l ; pt += AX25_ADDR_LEN , lg += AX25_ADDR_LEN ) { <S2SV_StartBug> if ( pt [ 6 ] & AX25_HBIT ) <S2SV_EndBug> memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_EndBug> } } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }",& AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> AX25_ADDR_LEN ) ; }
794,"static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union { struct tpacket_hdr * h1 ; struct tpacket2_hdr * h2 ; void * raw ; } h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_LOSING | TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timeval tv ; struct timespec ts ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; macoff = netoff - maclen ; } if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize < ( unsigned ) sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) snaplen = 0 ; } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_frame ( po , & po -> rx_ring , TP_STATUS_KERNEL ) ; if ( ! h . raw ) goto ring_is_full ; packet_increment_head ( & po -> rx_ring ) ; po -> stats . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } if ( ! po -> stats . tp_drops ) status &= ~ TP_STATUS_LOSING ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) tv = ktime_to_timeval ( skb -> tstamp ) ; else do_gettimeofday ( & tv ) ; h . h1 -> tp_sec = tv . tv_sec ; h . h1 -> tp_usec = tv . tv_usec ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) ts = ktime_to_timespec ( skb -> tstamp ) ; else getnstimeofday ( & ts ) ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( vlan_tx_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = vlan_tx_tag_get ( skb ) ; status |= TP_STATUS_VLAN_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; } <S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; __packet_set_status ( po , h . raw , status ) ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } # endif sk -> sk_data_ready ( sk , 0 ) ; drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : kfree_skb ( skb ) ; return 0 ; ring_is_full : po -> stats . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk , 0 ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }",0 ; } h . h2 -> tp_padding = 0 ;
795,"int nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) { struct svc_export * exp = * expp , * exp2 = NULL ; struct dentry * dentry = * dpp ; struct path path = { . mnt = mntget ( exp -> ex_path . mnt ) , . dentry = dget ( dentry ) } ; int err = 0 ; err = follow_down ( & path ) ; if ( err < 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> exp2 = rqst_exp_get_by_name ( rqstp , & path ) ; if ( IS_ERR ( exp2 ) ) { err = PTR_ERR ( exp2 ) ; if ( err == - ENOENT && ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) err = 0 ; path_put ( & path ) ; goto out ; } if ( nfsd_v4client ( rqstp ) || ( exp -> ex_flags & NFSEXP_CROSSMOUNT ) || EX_NOHIDE ( exp2 ) ) { * dpp = path . dentry ; path . dentry = dentry ; * expp = exp2 ; exp2 = exp ; } path_put ( & path ) ; exp_put ( exp2 ) ; out : return err ; }","goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }"
796,"static int nft_flush_table ( struct nft_ctx * ctx ) { int err ; struct nft_chain * chain , * nc ; struct nft_set * set , * ns ; <S2SV_StartBug> list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) { <S2SV_EndBug> ctx -> chain = chain ; err = nft_delrule_by_chain ( ctx ) ; if ( err < 0 ) goto out ; <S2SV_StartBug> err = nft_delchain ( ctx ) ; <S2SV_EndBug> if ( err < 0 ) goto out ; } <S2SV_StartBug> list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { <S2SV_EndBug> <S2SV_StartBug> if ( set -> flags & NFT_SET_ANONYMOUS && <S2SV_EndBug> ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set ) ; if ( err < 0 ) goto out ; } err = nft_deltable ( ctx ) ; out : return err ; }","* ns ; list_for_each_entry ( chain <S2SV_ModEnd> , & ctx <S2SV_ModStart> goto out ; } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> ) ; if <S2SV_ModStart> } list_for_each_entry_safe ( chain , nc <S2SV_ModEnd> , & ctx <S2SV_ModStart> -> table -> chains <S2SV_ModEnd> , list ) <S2SV_ModStart> list ) { ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> ) ; if"
797,static int hns_gmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ; },stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
798,"int parse_config ( char * filename , bridge_t * * bridges ) { dictionary * ubridge_config = NULL ; const char * value ; const char * bridge_name ; int i , nsec ; <S2SV_StartBug> if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) { <S2SV_EndBug> return FALSE ; } nsec = iniparser_getnsec ( ubridge_config ) ; for ( i = 0 ; i < nsec ; i ++ ) { bridge_t * bridge ; nio_t * source_nio = NULL ; nio_t * destination_nio = NULL ; bridge_name = iniparser_getsecname ( ubridge_config , i ) ; printf ( ""Parsing<S2SV_blank>%s\\n"" , bridge_name ) ; if ( getstr ( ubridge_config , bridge_name , ""source_udp"" , & value ) ) source_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_unix"" , & value ) ) source_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_ethernet"" , & value ) ) source_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_tap"" , & value ) ) source_nio = open_tap_device ( value ) ; # ifdef LINUX_RAW else if ( getstr ( ubridge_config , bridge_name , ""source_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __APPLE__ else if ( getstr ( ubridge_config , bridge_name , ""source_fusion_vmnet"" , & value ) ) source_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""source<S2SV_blank>NIO<S2SV_blank>not<S2SV_blank>found\\n"" ) ; if ( getstr ( ubridge_config , bridge_name , ""destination_udp"" , & value ) ) destination_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_unix"" , & value ) ) destination_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_ethernet"" , & value ) ) destination_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_tap"" , & value ) ) destination_nio = open_tap_device ( value ) ; # ifdef LINUX_RAW else if ( getstr ( ubridge_config , bridge_name , ""destination_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __APPLE__ else if ( getstr ( ubridge_config , bridge_name , ""destination_fusion_vmnet"" , & value ) ) destination_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""destination<S2SV_blank>NIO<S2SV_blank>not<S2SV_blank>found\\n"" ) ; if ( source_nio && destination_nio ) { bridge = add_bridge ( bridges ) ; bridge -> source_nio = source_nio ; bridge -> destination_nio = destination_nio ; if ( ! ( bridge -> name = strdup ( bridge_name ) ) ) { fprintf ( stderr , ""bridge<S2SV_blank>creation:<S2SV_blank>insufficient<S2SV_blank>memory\\n"" ) ; return FALSE ; } parse_capture ( ubridge_config , bridge_name , bridge ) ; parse_filter ( ubridge_config , bridge_name , bridge ) ; } else if ( source_nio != NULL ) free_nio ( source_nio ) ; else if ( destination_nio != NULL ) free_nio ( destination_nio ) ; } iniparser_freedict ( ubridge_config ) ; return TRUE ; }","iniparser_load ( filename , HIDE_ERRORED_LINE_CONTENT"
799,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; <S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr ) ; segs = skb_segment ( skb , features ) ; out : return segs ; }",if ( ( skb_mac_header <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) < skb -> head +
800,"static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }",+= 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
801,"Datum bit_in ( PG_FUNCTION_ARGS ) { char * input_string = PG_GETARG_CSTRING ( 0 ) ; # ifdef NOT_USED Oid typelem = PG_GETARG_OID ( 1 ) ; # endif int32 atttypmod = PG_GETARG_INT32 ( 2 ) ; VarBit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'B' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'X' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else <S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug> if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen != atttypmod ) ereport ( ERROR , ( errcode ( ERRCODE_STRING_DATA_LENGTH_MISMATCH ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>type<S2SV_blank>bit(%d)"" , bitlen , atttypmod ) ) ) ; len = VARBITTOTALLEN ( atttypmod ) ; result = ( VarBit * ) palloc0 ( len ) ; SET_VARSIZE ( result , len ) ; VARBITLEN ( result ) = atttypmod ; r = VARBITS ( result ) ; if ( bit_not_hex ) { x = HIGHBIT ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>binary<S2SV_blank>digit"" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = HIGHBIT ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'A' && * sp <= 'F' ) x = ( bits8 ) ( * sp - 'A' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>hexadecimal<S2SV_blank>digit"" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x << 4 ; bc = 1 ; } } } PG_RETURN_VARBIT_P ( result ) ; }","slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }"
802,"<S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ; <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( ""Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\n"" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( ""Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\n"" , sname ) ; goto out2 ; } } else goto out2 ; <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }","* sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,"
803,"static UINT serial_process_irp_create ( SERIAL_DEVICE * serial , IRP * irp ) { DWORD DesiredAccess ; DWORD SharedAccess ; DWORD CreateDisposition ; UINT32 PathLength ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; Stream_Read_UINT32 ( irp -> input , DesiredAccess ) ; Stream_Seek_UINT64 ( irp -> input ) ; Stream_Seek_UINT32 ( irp -> input ) ; Stream_Read_UINT32 ( irp -> input , SharedAccess ) ; Stream_Read_UINT32 ( irp -> input , CreateDisposition ) ; Stream_Seek_UINT32 ( irp -> input ) ; Stream_Read_UINT32 ( irp -> input , PathLength ) ; <S2SV_StartBug> if ( Stream_GetRemainingLength ( irp -> input ) < PathLength ) <S2SV_EndBug> <S2SV_StartBug> return ERROR_INVALID_DATA ; <S2SV_EndBug> Stream_Seek ( irp -> input , PathLength ) ; assert ( PathLength == 0 ) ; # ifndef _WIN32 WLog_Print ( serial -> log , WLOG_DEBUG , ""DesiredAccess:<S2SV_blank>0x%"" PRIX32 "",<S2SV_blank>SharedAccess:<S2SV_blank>0x%"" PRIX32 "",<S2SV_blank>CreateDisposition:<S2SV_blank>0x%"" PRIX32 """" , DesiredAccess , SharedAccess , CreateDisposition ) ; DesiredAccess = GENERIC_READ | GENERIC_WRITE ; SharedAccess = 0 ; CreateDisposition = OPEN_EXISTING ; # endif serial -> hComm = CreateFile ( serial -> device . name , DesiredAccess , SharedAccess , NULL , CreateDisposition , 0 , NULL ) ; if ( ! serial -> hComm || ( serial -> hComm == INVALID_HANDLE_VALUE ) ) { WLog_Print ( serial -> log , WLOG_WARN , ""CreateFile<S2SV_blank>failure:<S2SV_blank>%s<S2SV_blank>last-error:<S2SV_blank>0x%08"" PRIX32 """" , serial -> device . name , GetLastError ( ) ) ; irp -> IoStatus = STATUS_UNSUCCESSFUL ; goto error_handle ; } _comm_setServerSerialDriver ( serial -> hComm , serial -> ServerSerialDriverId ) ; _comm_set_permissive ( serial -> hComm , serial -> permissive ) ; assert ( irp -> FileId == 0 ) ; irp -> FileId = irp -> devman -> id_sequence ++ ; irp -> IoStatus = STATUS_SUCCESS ; WLog_Print ( serial -> log , WLOG_DEBUG , ""%s<S2SV_blank>(DeviceId:<S2SV_blank>%"" PRIu32 "",<S2SV_blank>FileId:<S2SV_blank>%"" PRIu32 "")<S2SV_blank>created."" , serial -> device . name , irp -> device -> id , irp -> FileId ) ; error_handle : Stream_Write_UINT32 ( irp -> output , irp -> FileId ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return CHANNEL_RC_OK ; }","; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) <S2SV_ModEnd> ) return ERROR_INVALID_DATA <S2SV_ModStart> ) return ERROR_INVALID_DATA <S2SV_ModEnd> ; assert ("
804,"static void pimv2_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , const u_char * bp2 ) { register const u_char * ep ; register const struct pim * pim = ( const struct pim * ) bp ; int advance ; enum checksum_status cksum_status ; ep = ( const u_char * ) ndo -> ndo_snapend ; if ( bp >= ep ) return ; if ( ep > bp + len ) ep = bp + len ; ND_TCHECK ( pim -> pim_rsv ) ; pimv2_addr_len = pim -> pim_rsv ; if ( pimv2_addr_len != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ; if ( EXTRACT_16BITS ( & pim -> pim_cksum ) == 0 ) { ND_PRINT ( ( ndo , ""(unverified)"" ) ) ; } else { if ( PIM_TYPE ( pim -> pim_typever ) == PIMV2_TYPE_REGISTER ) { cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , 8 ) ; if ( cksum_status == INCORRECT ) { cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , len ) ; } } else { cksum_status = pimv2_check_checksum ( ndo , bp , bp2 , len ) ; } switch ( cksum_status ) { case CORRECT : ND_PRINT ( ( ndo , ""(correct)"" ) ) ; break ; case INCORRECT : ND_PRINT ( ( ndo , ""(incorrect)"" ) ) ; break ; case UNVERIFIED : ND_PRINT ( ( ndo , ""(unverified)"" ) ) ; break ; } } switch ( PIM_TYPE ( pim -> pim_typever ) ) { case PIMV2_TYPE_HELLO : { uint16_t otype , olen ; bp += 4 ; while ( bp < ep ) { ND_TCHECK2 ( bp [ 0 ] , 4 ) ; otype = EXTRACT_16BITS ( & bp [ 0 ] ) ; olen = EXTRACT_16BITS ( & bp [ 2 ] ) ; ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>Value:<S2SV_blank>"" , tok2str ( pimv2_hello_option_values , ""Unknown"" , otype ) , otype , olen ) ) ; bp += 4 ; switch ( otype ) { case PIMV2_HELLO_OPTION_HOLDTIME : <S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <S2SV_EndBug> break ; case PIMV2_HELLO_OPTION_LANPRUNEDELAY : if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { char t_bit ; uint16_t lan_delay , override_interval ; lan_delay = EXTRACT_16BITS ( bp ) ; override_interval = EXTRACT_16BITS ( bp + 2 ) ; t_bit = ( lan_delay & 0x8000 ) ? 1 : 0 ; lan_delay &= ~ 0x8000 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T-bit=%d,<S2SV_blank>LAN<S2SV_blank>delay<S2SV_blank>%dms,<S2SV_blank>Override<S2SV_blank>interval<S2SV_blank>%dms"" , t_bit , lan_delay , override_interval ) ) ; } break ; case PIMV2_HELLO_OPTION_DR_PRIORITY_OLD : case PIMV2_HELLO_OPTION_DR_PRIORITY : switch ( olen ) { case 0 : ND_PRINT ( ( ndo , ""Bi-Directional<S2SV_blank>Capability<S2SV_blank>(Old)"" ) ) ; break ; case 4 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( bp ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; break ; } break ; case PIMV2_HELLO_OPTION_GENID : <S2SV_StartBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> break ; case PIMV2_HELLO_OPTION_REFRESH_CAP : <S2SV_StartBug> ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ; <S2SV_EndBug> if ( * ( bp + 1 ) != 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>interval<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , * ( bp + 1 ) ) ; } if ( EXTRACT_16BITS ( bp + 2 ) != 0 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ; <S2SV_EndBug> } break ; case PIMV2_HELLO_OPTION_BIDIR_CAP : break ; case PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD : case PIMV2_HELLO_OPTION_ADDRESS_LIST : if ( ndo -> ndo_vflag > 1 ) { const u_char * ptr = bp ; while ( ptr < ( bp + olen ) ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } ptr += advance ; } } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , olen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , olen ) ; bp += olen ; } break ; } case PIMV2_TYPE_REGISTER : { const struct ip * ip ; ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]\\n\\t"" , tok2str ( pimv2_register_flag_values , ""none"" , EXTRACT_32BITS ( bp + 4 ) ) ) ) ; bp += 8 ; len -= 8 ; ip = ( const struct ip * ) bp ; switch ( IP_V ( ip ) ) { case 0 : ND_PRINT ( ( ndo , ""IP-Null-header<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; break ; case 4 : ip_print ( ndo , bp , len ) ; break ; case 6 : ip6_print ( ndo , bp , len ) ; break ; default : ND_PRINT ( ( ndo , ""IP<S2SV_blank>ver<S2SV_blank>%d"" , IP_V ( ip ) ) ) ; break ; } break ; } case PIMV2_TYPE_REGISTER_STOP : bp += 4 ; len -= 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>source="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; break ; case PIMV2_TYPE_JOIN_PRUNE : case PIMV2_TYPE_GRAFT : case PIMV2_TYPE_GRAFT_ACK : { uint8_t ngroup ; uint16_t holdtime ; uint16_t njoin ; uint16_t nprune ; int i , j ; bp += 4 ; len -= 4 ; if ( PIM_TYPE ( pim -> pim_typever ) != 7 ) { if ( bp >= ep ) break ; ND_PRINT ( ( ndo , "",<S2SV_blank>upstream-neighbor:<S2SV_blank>"" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; } if ( bp + 4 > ep ) break ; ngroup = bp [ 1 ] ; holdtime = EXTRACT_16BITS ( & bp [ 2 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%u<S2SV_blank>group(s)"" , ngroup ) ) ; if ( PIM_TYPE ( pim -> pim_typever ) != 7 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>holdtime:<S2SV_blank>"" ) ) ; if ( holdtime == 0xffff ) ND_PRINT ( ( ndo , ""infinite"" ) ) ; else unsigned_relts_print ( ndo , holdtime ) ; } bp += 4 ; len -= 4 ; for ( i = 0 ; i < ngroup ; i ++ ) { if ( bp >= ep ) goto jp_done ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>group<S2SV_blank>#%u:<S2SV_blank>"" , i + 1 ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } bp += advance ; len -= advance ; if ( bp + 4 > ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } njoin = EXTRACT_16BITS ( & bp [ 0 ] ) ; nprune = EXTRACT_16BITS ( & bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>joined<S2SV_blank>sources:<S2SV_blank>%u,<S2SV_blank>pruned<S2SV_blank>sources:<S2SV_blank>%u"" , njoin , nprune ) ) ; bp += 4 ; len -= 4 ; for ( j = 0 ; j < njoin ; j ++ ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>joined<S2SV_blank>source<S2SV_blank>#%u:<S2SV_blank>"" , j + 1 ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } bp += advance ; len -= advance ; } for ( j = 0 ; j < nprune ; j ++ ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>pruned<S2SV_blank>source<S2SV_blank>#%u:<S2SV_blank>"" , j + 1 ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto jp_done ; } bp += advance ; len -= advance ; } } jp_done : break ; } case PIMV2_TYPE_BOOTSTRAP : { int i , j , frpcnt ; bp += 4 ; if ( bp + sizeof ( uint16_t ) >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>tag=%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += sizeof ( uint16_t ) ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>hashmlen=%d"" , bp [ 0 ] ) ) ; if ( bp + 1 >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>BSRprio=%d"" , bp [ 1 ] ) ) ; bp += 2 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>BSR="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; for ( i = 0 ; bp < ep ; i ++ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(group%d:<S2SV_blank>"" , i ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } bp += advance ; if ( bp >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , ""<S2SV_blank>RPcnt=%d"" , bp [ 0 ] ) ) ; if ( bp + 1 >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ; bp += 4 ; for ( j = 0 ; j < frpcnt && bp < ep ; j ++ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>RP%d="" , j ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } bp += advance ; if ( bp + 1 >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , "",holdtime="" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; if ( bp + 2 >= ep ) { ND_PRINT ( ( ndo , ""...)"" ) ) ; goto bs_done ; } ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ; bp += 4 ; } ND_PRINT ( ( ndo , "")"" ) ) ; } bs_done : break ; } case PIMV2_TYPE_ASSERT : bp += 4 ; len -= 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>src="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; len -= advance ; if ( bp + 8 > ep ) break ; if ( bp [ 0 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>RPT"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pref=%u"" , EXTRACT_32BITS ( & bp [ 0 ] ) & 0x7fffffff ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>metric=%u"" , EXTRACT_32BITS ( & bp [ 4 ] ) ) ) ; break ; case PIMV2_TYPE_CANDIDATE_RP : { int i , pfxcnt ; bp += 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>prefix-cnt=%d"" , bp [ 0 ] ) ) ; pfxcnt = bp [ 0 ] ; if ( bp + 1 >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ; if ( bp + 3 >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>holdtime="" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; bp += 4 ; if ( bp >= ep ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>RP="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; for ( i = 0 ; i < pfxcnt && bp < ep ; i ++ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Group%d="" , i ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; } break ; } case PIMV2_TYPE_PRUNE_REFRESH : ND_PRINT ( ( ndo , ""<S2SV_blank>src="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { ND_PRINT ( ( ndo , ""..."" ) ) ; break ; } bp += advance ; ND_TCHECK2 ( bp [ 0 ] , 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>TUNR<S2SV_blank>"" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>[type<S2SV_blank>%d]"" , PIM_TYPE ( pim -> pim_typever ) ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; }","case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; }"
805,"static const char * escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; <S2SV_StartBug> if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ; <S2SV_EndBug> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = NULL ; escaped_size = 0 ; return "">>><S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank><<<"" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , ""&amp;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , ""&lt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , ""&gt;"" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\x0' ; return escaped ; }",") ) return """" <S2SV_ModEnd> ; for ("
806,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; <S2SV_StartBug> arg = arg ( argname , annotation , LINENO ( ch ) , ch -> n_col_offset , <S2SV_EndBug> ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; <S2SV_StartBug> i += 2 ; <S2SV_EndBug> break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }",", annotation , NULL , <S2SV_ModStart> ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 <S2SV_ModEnd> ; break ;"
807,"static void xen_netbk_tx_submit ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops ; struct sk_buff * skb ; while ( ( skb = __skb_dequeue ( & netbk -> tx_queue ) ) != NULL ) { struct xen_netif_tx_request * txp ; struct xenvif * vif ; u16 pending_idx ; unsigned data_len ; pending_idx = * ( ( u16 * ) skb -> data ) ; vif = netbk -> pending_tx_info [ pending_idx ] . vif ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; if ( unlikely ( xen_netbk_tx_check_gop ( netbk , skb , & gop ) ) ) { netdev_dbg ( vif -> dev , ""netback<S2SV_blank>grant<S2SV_blank>failed.\\n"" ) ; skb_shinfo ( skb ) -> nr_frags = 0 ; kfree_skb ( skb ) ; continue ; } data_len = skb -> len ; memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ; if ( data_len < txp -> size ) { txp -> offset += data_len ; txp -> size -= data_len ; } else { <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } if ( txp -> flags & XEN_NETTXF_csum_blank ) skb -> ip_summed = CHECKSUM_PARTIAL ; else if ( txp -> flags & XEN_NETTXF_data_validated ) skb -> ip_summed = CHECKSUM_UNNECESSARY ; xen_netbk_fill_frags ( netbk , skb ) ; if ( skb_headlen ( skb ) < PKT_PROT_LEN && skb_is_nonlinear ( skb ) ) { int target = min_t ( int , skb -> len , PKT_PROT_LEN ) ; __pskb_pull_tail ( skb , target - skb_headlen ( skb ) ) ; } skb -> dev = vif -> dev ; skb -> protocol = eth_type_trans ( skb , skb -> dev ) ; if ( checksum_setup ( vif , skb ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\n"" ) ; kfree_skb ( skb ) ; continue ; } vif -> dev -> stats . rx_bytes += skb -> len ; vif -> dev -> stats . rx_packets ++ ; xenvif_receive_skb ( vif , skb ) ; } }","netbk , pending_idx , XEN_NETIF_RSP_OKAY"
808,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",", sizeof ( double <S2SV_ModEnd> ) ) ;"
809,"static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , ""tune"" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , ""ERROR"" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , ""ERROR<S2SV_blank>hot<S2SV_blank>and<S2SV_blank>warm<S2SV_blank>pcts<S2SV_blank>must<S2SV_blank>not<S2SV_blank>exceed<S2SV_blank>80"" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , ""ERROR<S2SV_blank>hot/warm<S2SV_blank>age<S2SV_blank>factors<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , ""OK"" ) ; } } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , ""mode"" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , ""flat"" ) == 0 ) { settings . lru_segmented = false ; out_string ( c , ""OK"" ) ; } else if ( strcmp ( tokens [ 2 ] . value , ""segmented"" ) == 0 ) { settings . lru_segmented = true ; out_string ( c , ""OK"" ) ; } else { out_string ( c , ""ERROR"" ) ; } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { out_string ( c , ""ERROR"" ) ; } else { if ( ttl < 0 ) { settings . temp_lru = false ; } else { settings . temp_lru = true ; settings . temporary_ttl = ttl ; } out_string ( c , ""OK"" ) ; } } else { out_string ( c , ""ERROR"" ) ; } }",&& ntokens >= 4 <S2SV_ModEnd> && settings . <S2SV_ModStart> && ntokens >= 4 <S2SV_ModEnd> && settings .
810,"void vp8_mbpost_proc_down_c ( unsigned char * dst , int pitch , int rows , int cols , int flimit ) { int r , c , i ; const short * rv3 = & vp8_rv [ 63 & rand ( ) ] ; for ( c = 0 ; c < cols ; c ++ ) { unsigned char * s = & dst [ c ] ; int sumsq = 0 ; int sum = 0 ; unsigned char d [ 16 ] ; const short * rv2 = rv3 + ( ( c * 17 ) & 127 ) ; for ( i = - 8 ; i < 0 ; i ++ ) s [ i * pitch ] = s [ 0 ] ; <S2SV_StartBug> for ( i = rows ; i < rows + 17 ; i ++ ) <S2SV_EndBug> s [ i * pitch ] = s [ ( rows - 1 ) * pitch ] ; for ( i = - 8 ; i <= 6 ; i ++ ) { sumsq += s [ i * pitch ] * s [ i * pitch ] ; sum += s [ i * pitch ] ; } for ( r = 0 ; r < rows + 8 ; r ++ ) { sumsq += s [ 7 * pitch ] * s [ 7 * pitch ] - s [ - 8 * pitch ] * s [ - 8 * pitch ] ; sum += s [ 7 * pitch ] - s [ - 8 * pitch ] ; d [ r & 15 ] = s [ 0 ] ; if ( sumsq * 15 - sum * sum < flimit ) { d [ r & 15 ] = ( rv2 [ r & 127 ] + sum + s [ 0 ] ) >> 4 ; } if ( r >= 8 ) s [ - 8 * pitch ] = d [ ( r - 8 ) & 15 ] ; s += pitch ; } } }",( i = 0 ; i < 17 ; i ++ ) s [ ( i + rows ) <S2SV_ModEnd> * pitch ]
811,"static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }",if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
812,"int readfile ( char_u * fname , char_u * sfname , linenr_T from , linenr_T lines_to_skip , linenr_T lines_to_read , exarg_T * eap , int flags ) { int fd = 0 ; int newfile = ( flags & READ_NEW ) ; int check_readonly ; int filtering = ( flags & READ_FILTER ) ; int read_stdin = ( flags & READ_STDIN ) ; int read_buffer = ( flags & READ_BUFFER ) ; int read_fifo = ( flags & READ_FIFO ) ; int set_options = newfile || read_buffer || ( eap != NULL && eap -> read_edit ) ; linenr_T read_buf_lnum = 1 ; colnr_T read_buf_col = 0 ; char_u c ; linenr_T lnum = from ; char_u * ptr = NULL ; char_u * buffer = NULL ; char_u * new_buffer = NULL ; char_u * line_start = NULL ; int wasempty ; colnr_T len ; long size = 0 ; char_u * p ; off_T filesize = 0 ; int skip_read = FALSE ; # ifdef FEAT_CRYPT char_u * cryptkey = NULL ; int did_ask_for_key = FALSE ; # endif # ifdef FEAT_PERSISTENT_UNDO context_sha256_T sha_ctx ; int read_undo_file = FALSE ; # endif int split = 0 ; # define UNKNOWN 0x0fffffff linenr_T linecnt ; int error = FALSE ; int ff_error = EOL_UNKNOWN ; long linerest = 0 ; # ifdef UNIX int perm = 0 ; int swap_mode = - 1 ; # else int perm ; # endif int fileformat = 0 ; int keep_fileformat = FALSE ; stat_T st ; int file_readonly ; linenr_T skip_count = 0 ; linenr_T read_count = 0 ; int msg_save = msg_scroll ; linenr_T read_no_eol_lnum = 0 ; int try_mac ; int try_dos ; int try_unix ; int file_rewind = FALSE ; # ifdef FEAT_MBYTE int can_retry ; linenr_T conv_error = 0 ; linenr_T illegal_byte = 0 ; int keep_dest_enc = FALSE ; int bad_char_behavior = BAD_REPLACE ; char_u * tmpname = NULL ; int fio_flags = 0 ; char_u * fenc ; int fenc_alloced ; char_u * fenc_next = NULL ; int advance_fenc = FALSE ; long real_size = 0 ; # ifdef USE_ICONV iconv_t iconv_fd = ( iconv_t ) - 1 ; # ifdef FEAT_EVAL int did_iconv = FALSE ; # endif # endif int converted = FALSE ; int notconverted = FALSE ; char_u conv_rest [ CONV_RESTLEN ] ; int conv_restlen = 0 ; # endif # ifdef FEAT_AUTOCMD buf_T * old_curbuf ; char_u * old_b_ffname ; char_u * old_b_fname ; int using_b_ffname ; int using_b_fname ; # endif # ifdef FEAT_AUTOCMD au_did_filetype = FALSE ; # endif curbuf -> b_no_eol_lnum = 0 ; if ( curbuf -> b_ffname == NULL && ! filtering && fname != NULL && vim_strchr ( p_cpo , CPO_FNAMER ) != NULL && ! ( flags & READ_DUMMY ) ) { if ( set_rw_fname ( fname , sfname ) == FAIL ) return FAIL ; } # ifdef FEAT_AUTOCMD old_curbuf = curbuf ; old_b_ffname = curbuf -> b_ffname ; old_b_fname = curbuf -> b_fname ; using_b_ffname = ( fname == curbuf -> b_ffname ) || ( sfname == curbuf -> b_ffname ) ; using_b_fname = ( fname == curbuf -> b_fname ) || ( sfname == curbuf -> b_fname ) ; # endif ex_no_reprint = TRUE ; need_fileinfo = FALSE ; if ( sfname == NULL ) sfname = fname ; # if defined ( UNIX ) fname = sfname ; # endif # ifdef FEAT_AUTOCMD if ( ! filtering && ! read_stdin && ! read_buffer ) { pos_T pos ; pos = curbuf -> b_op_start ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; if ( newfile ) { if ( apply_autocmds_exarg ( EVENT_BUFREADCMD , NULL , sfname , FALSE , curbuf , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif } else if ( apply_autocmds_exarg ( EVENT_FILEREADCMD , sfname , sfname , FALSE , NULL , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif curbuf -> b_op_start = pos ; } # endif if ( ( shortmess ( SHM_OVER ) || curbuf -> b_help ) && p_verbose == 0 ) msg_scroll = FALSE ; else msg_scroll = TRUE ; if ( fname != NULL && * fname != NUL ) { p = fname + STRLEN ( fname ) ; if ( after_pathsep ( fname , p ) || STRLEN ( fname ) >= MAXPATHL ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""Illegal<S2SV_blank>file<S2SV_blank>name"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } } if ( ! read_stdin && ! read_buffer && ! read_fifo ) { # ifdef UNIX perm = mch_getperm ( fname ) ; if ( perm >= 0 && ! S_ISREG ( perm ) # ifdef S_ISFIFO && ! S_ISFIFO ( perm ) # endif # ifdef S_ISSOCK && ! S_ISSOCK ( perm ) # endif # ifdef OPEN_CHR_FILES && ! ( S_ISCHR ( perm ) && is_dev_fd_file ( fname ) ) # endif ) { int retval = FAIL ; if ( S_ISDIR ( perm ) ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>directory"" ) , 0 ) ; retval = NOTDONE ; } else filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>file"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return retval ; } # endif # if defined ( MSWIN ) if ( ! p_odev && mch_nodetype ( fname ) == NODE_WRITABLE ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>device<S2SV_blank>(disabled<S2SV_blank>with<S2SV_blank>\'opendevice\'<S2SV_blank>option)"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } # endif } set_file_options ( set_options , eap ) ; check_readonly = ( newfile && ( curbuf -> b_flags & BF_CHECK_RO ) ) ; if ( check_readonly && ! readonlymode ) curbuf -> b_p_ro = FALSE ; if ( newfile && ! read_stdin && ! read_buffer && ! read_fifo ) { if ( mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; # ifdef UNIX swap_mode = ( st . st_mode & 0644 ) | 0600 ; # endif # ifdef FEAT_CW_EDITOR ( void ) GetFSSpecFromPath ( curbuf -> b_ffname , & curbuf -> b_FSSpec ) ; # endif # ifdef VMS curbuf -> b_fab_rfm = st . st_fab_rfm ; curbuf -> b_fab_rat = st . st_fab_rat ; curbuf -> b_fab_mrs = st . st_fab_mrs ; # endif } else { curbuf -> b_mtime = 0 ; curbuf -> b_mtime_read = 0 ; curbuf -> b_orig_size = 0 ; curbuf -> b_orig_mode = 0 ; } curbuf -> b_flags &= ~ ( BF_NEW | BF_NEW_W ) ; } file_readonly = FALSE ; if ( read_stdin ) { # if defined ( MSWIN ) setmode ( 0 , O_BINARY ) ; # endif } else if ( ! read_buffer ) { # ifdef USE_MCH_ACCESS if ( # ifdef UNIX ! ( perm & 0222 ) || # endif mch_access ( ( char * ) fname , W_OK ) ) file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; # else if ( ! newfile || readonlymode || ( fd = mch_open ( ( char * ) fname , O_RDWR | O_EXTRA , 0 ) ) < 0 ) { file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; } # endif } if ( fd < 0 ) { # ifndef UNIX int isdir_f ; # endif msg_scroll = msg_save ; # ifndef UNIX isdir_f = ( mch_isdir ( fname ) ) ; perm = mch_getperm ( fname ) ; if ( isdir_f ) { filemess ( curbuf , sfname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>directory"" ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } else # endif if ( newfile ) { if ( perm < 0 # ifdef ENOENT && errno == ENOENT # endif ) { curbuf -> b_flags |= BF_NEW ; # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; return FAIL ; } # endif } if ( dir_of_file_exists ( fname ) ) filemess ( curbuf , sfname , ( char_u * ) _ ( ""[New<S2SV_blank>File]"" ) , 0 ) ; else filemess ( curbuf , sfname , ( char_u * ) _ ( ""[New<S2SV_blank>DIRECTORY]"" ) , 0 ) ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif # ifdef FEAT_MBYTE if ( eap != NULL ) set_forced_fenc ( eap ) ; # endif # ifdef FEAT_AUTOCMD apply_autocmds_exarg ( EVENT_BUFNEWFILE , sfname , sfname , FALSE , curbuf , eap ) ; # endif save_file_ff ( curbuf ) ; # if defined ( FEAT_AUTOCMD ) && defined ( FEAT_EVAL ) if ( aborting ( ) ) return FAIL ; # endif return OK ; } else { filemess ( curbuf , sfname , ( char_u * ) ( # ifdef EFBIG ( errno == EFBIG ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif # ifdef EOVERFLOW ( errno == EOVERFLOW ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif _ ( ""[Permission<S2SV_blank>Denied]"" ) ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } } return FAIL ; } if ( ( check_readonly && file_readonly ) || curbuf -> b_help ) curbuf -> b_p_ro = TRUE ; if ( set_options ) { if ( ! read_buffer ) { curbuf -> b_p_eol = TRUE ; curbuf -> b_start_eol = TRUE ; } # ifdef FEAT_MBYTE curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; # endif } # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; if ( ! read_buffer ) close ( fd ) ; return FAIL ; } # endif # ifdef UNIX if ( swap_mode > 0 && curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname != NULL ) <S2SV_StartBug> ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ; <S2SV_EndBug> # endif } # if defined ( HAS_SWAP_EXISTS_ACTION ) if ( swap_exists_action == SEA_QUIT ) { if ( ! read_buffer && ! read_stdin ) close ( fd ) ; return FAIL ; } # endif ++ no_wait_return ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; # ifdef FEAT_AUTOCMD if ( ! read_buffer ) { int m = msg_scroll ; int n = msg_scrolled ; if ( ! read_stdin ) close ( fd ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( read_stdin ) apply_autocmds_exarg ( EVENT_STDINREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile ) apply_autocmds_exarg ( EVENT_BUFREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else apply_autocmds_exarg ( EVENT_FILEREADPRE , sfname , sfname , FALSE , NULL , eap ) ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) { -- no_wait_return ; msg_scroll = msg_save ; curbuf -> b_p_ro = TRUE ; return FAIL ; } # endif if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) || ( fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ) < 0 ) ) { -- no_wait_return ; msg_scroll = msg_save ; if ( fd < 0 ) EMSG ( _ ( ""E200:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>made<S2SV_blank>the<S2SV_blank>file<S2SV_blank>unreadable"" ) ) ; else EMSG ( _ ( ""E201:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>must<S2SV_blank>not<S2SV_blank>change<S2SV_blank>current<S2SV_blank>buffer"" ) ) ; curbuf -> b_p_ro = TRUE ; return FAIL ; } } # endif wasempty = ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ; if ( ! recoverymode && ! filtering && ! ( flags & READ_DUMMY ) ) { if ( read_stdin ) { # ifndef ALWAYS_USE_GUI mch_msg ( _ ( ""Vim:<S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin...\\n"" ) ) ; # endif # ifdef FEAT_GUI if ( gui . in_use && ! gui . dying && ! gui . starting ) { p = ( char_u * ) _ ( ""Reading<S2SV_blank>from<S2SV_blank>stdin..."" ) ; gui_write ( p , ( int ) STRLEN ( p ) ) ; } # endif } else if ( ! read_buffer ) filemess ( curbuf , sfname , ( char_u * ) """" , 0 ) ; } msg_scroll = FALSE ; linecnt = curbuf -> b_ml . ml_line_count ; # ifdef FEAT_MBYTE if ( eap != NULL && eap -> bad_char != 0 ) { bad_char_behavior = eap -> bad_char ; if ( set_options ) curbuf -> b_bad_char = eap -> bad_char ; } else curbuf -> b_bad_char = 0 ; if ( eap != NULL && eap -> force_enc != 0 ) { fenc = enc_canonize ( eap -> cmd + eap -> force_enc ) ; fenc_alloced = TRUE ; keep_dest_enc = TRUE ; } else if ( curbuf -> b_p_bin ) { fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } else if ( curbuf -> b_help ) { char_u firstline [ 80 ] ; int fc ; fenc = ( char_u * ) ""latin1"" ; c = enc_utf8 ; if ( ! c && ! read_stdin ) { fc = fname [ STRLEN ( fname ) - 1 ] ; if ( TOLOWER_ASC ( fc ) == 'x' ) { len = read_eintr ( fd , firstline , 80 ) ; vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) ; for ( p = firstline ; p < firstline + len ; ++ p ) if ( * p >= 0x80 ) { c = TRUE ; break ; } } } if ( c ) { fenc_next = fenc ; fenc = ( char_u * ) ""utf-8"" ; if ( ! enc_utf8 ) keep_dest_enc = TRUE ; } fenc_alloced = FALSE ; } else if ( * p_fencs == NUL ) { fenc = curbuf -> b_p_fenc ; fenc_alloced = FALSE ; } else { fenc_next = p_fencs ; fenc = next_fenc ( & fenc_next ) ; fenc_alloced = TRUE ; } # endif retry : if ( file_rewind ) { if ( read_buffer ) { read_buf_lnum = 1 ; read_buf_col = 0 ; } else if ( read_stdin || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) != 0 ) { error = TRUE ; goto failed ; } while ( lnum > from ) ml_delete ( lnum -- , FALSE ) ; file_rewind = FALSE ; # ifdef FEAT_MBYTE if ( set_options ) { curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; } conv_error = 0 ; # endif } if ( keep_fileformat ) keep_fileformat = FALSE ; else { if ( eap != NULL && eap -> force_ff != 0 ) { fileformat = get_fileformat_force ( curbuf , eap ) ; try_unix = try_dos = try_mac = FALSE ; } else if ( curbuf -> b_p_bin ) fileformat = EOL_UNIX ; else if ( * p_ffs == NUL ) fileformat = get_fileformat ( curbuf ) ; else fileformat = EOL_UNKNOWN ; } # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif if ( advance_fenc ) { advance_fenc = FALSE ; if ( eap != NULL && eap -> force_enc != 0 ) { notconverted = TRUE ; conv_error = 0 ; if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; if ( fenc_next != NULL ) { fenc = next_fenc ( & fenc_next ) ; fenc_alloced = ( fenc_next != NULL ) ; } else { fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } } if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; tmpname = NULL ; } } fio_flags = 0 ; converted = need_conversion ( fenc ) ; if ( converted ) { if ( STRCMP ( fenc , ENC_UCSBOM ) == 0 ) fio_flags = FIO_UCSBOM ; else if ( enc_utf8 || STRCMP ( p_enc , ""latin1"" ) == 0 ) fio_flags = get_fio_flags ( fenc ) ; # ifdef WIN3264 if ( fio_flags == 0 ) fio_flags = get_win_fio_flags ( fenc ) ; # endif # ifdef MACOS_CONVERT if ( fio_flags == 0 ) fio_flags = get_mac_fio_flags ( fenc ) ; # endif # ifdef USE_ICONV if ( fio_flags == 0 # ifdef FEAT_EVAL && ! did_iconv # endif ) iconv_fd = ( iconv_t ) my_iconv_open ( enc_utf8 ? ( char_u * ) ""utf-8"" : p_enc , fenc ) ; # endif # ifdef FEAT_EVAL if ( fio_flags == 0 && ! read_stdin && ! read_buffer && * p_ccv != NUL && ! read_fifo # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { # ifdef USE_ICONV did_iconv = FALSE ; # endif if ( tmpname == NULL ) { tmpname = readfile_charconvert ( fname , fenc , & fd ) ; if ( tmpname == NULL ) { advance_fenc = TRUE ; if ( fd < 0 ) { EMSG ( _ ( ""E202:<S2SV_blank>Conversion<S2SV_blank>made<S2SV_blank>file<S2SV_blank>unreadable!"" ) ) ; error = TRUE ; goto failed ; } goto retry ; } } } else # endif { if ( fio_flags == 0 # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { advance_fenc = TRUE ; goto retry ; } } } can_retry = ( * fenc != NUL && ! read_stdin && ! read_fifo && ! keep_dest_enc ) ; # endif if ( ! skip_read ) { linerest = 0 ; filesize = 0 ; skip_count = lines_to_skip ; read_count = lines_to_read ; # ifdef FEAT_MBYTE conv_restlen = 0 ; # endif # ifdef FEAT_PERSISTENT_UNDO read_undo_file = ( newfile && ( flags & READ_KEEP_UNDO ) == 0 && curbuf -> b_ffname != NULL && curbuf -> b_p_udf && ! filtering && ! read_fifo && ! read_stdin && ! read_buffer ) ; if ( read_undo_file ) sha256_start ( & sha_ctx ) ; # endif # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } # endif } while ( ! error && ! got_int ) { # if VIM_SIZEOF_INT <= 2 if ( linerest >= 0x7ff0 ) { ++ split ; * ptr = NL ; size = 1 ; } else # endif { if ( ! skip_read ) { # if VIM_SIZEOF_INT > 2 # if defined ( SSIZE_MAX ) && ( SSIZE_MAX < 0x10000L ) size = SSIZE_MAX ; # else size = 0x10000L ; # endif # else size = 0x7ff0L - linerest ; # endif for ( ; size >= 10 ; size = ( long ) ( ( long_u ) size >> 1 ) ) { if ( ( new_buffer = lalloc ( ( long_u ) ( size + linerest + 1 ) , FALSE ) ) != NULL ) break ; } if ( new_buffer == NULL ) { do_outofmem_msg ( ( long_u ) ( size * 2 + linerest + 1 ) ) ; error = TRUE ; break ; } if ( linerest ) mch_memmove ( new_buffer , ptr - linerest , ( size_t ) linerest ) ; vim_free ( buffer ) ; buffer = new_buffer ; ptr = buffer + linerest ; line_start = buffer ; # ifdef FEAT_MBYTE real_size = ( int ) size ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) size = size / ICONV_MULT ; else # endif if ( fio_flags & FIO_LATIN1 ) size = size / 2 ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) size = ( size * 2 / 3 ) & ~ 1 ; else if ( fio_flags & FIO_UCS4 ) size = ( size * 2 / 3 ) & ~ 3 ; else if ( fio_flags == FIO_UCSBOM ) size = size / ICONV_MULT ; # ifdef WIN3264 else if ( fio_flags & FIO_CODEPAGE ) size = size / ICONV_MULT ; # endif # ifdef MACOS_CONVERT else if ( fio_flags & FIO_MACROMAN ) size = size / ICONV_MULT ; # endif # endif # ifdef FEAT_MBYTE if ( conv_restlen > 0 ) { mch_memmove ( ptr , conv_rest , conv_restlen ) ; ptr += conv_restlen ; size -= conv_restlen ; } # endif if ( read_buffer ) { if ( read_buf_lnum > from ) size = 0 ; else { int n , ni ; long tlen ; tlen = 0 ; for ( ; ; ) { p = ml_get ( read_buf_lnum ) + read_buf_col ; n = ( int ) STRLEN ( p ) ; if ( ( int ) tlen + n + 1 > size ) { n = ( int ) ( size - tlen ) ; for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } read_buf_col += n ; break ; } else { for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } ptr [ tlen ++ ] = NL ; read_buf_col = 0 ; if ( ++ read_buf_lnum > from ) { if ( ! curbuf -> b_p_eol ) -- tlen ; size = tlen ; break ; } } } } } else { size = read_eintr ( fd , ptr , size ) ; } # ifdef FEAT_CRYPT if ( filesize == 0 && size > 0 ) cryptkey = check_for_cryptkey ( cryptkey , ptr , & size , & filesize , newfile , sfname , & did_ask_for_key ) ; if ( cryptkey != NULL && curbuf -> b_cryptstate != NULL && size > 0 ) { if ( crypt_works_inplace ( curbuf -> b_cryptstate ) ) { crypt_decode_inplace ( curbuf -> b_cryptstate , ptr , size ) ; } else { char_u * newptr = NULL ; int decrypted_size ; decrypted_size = crypt_decode_alloc ( curbuf -> b_cryptstate , ptr , size , & newptr ) ; if ( size > 0 && decrypted_size == 0 ) continue ; if ( linerest == 0 ) { new_buffer = newptr ; } else { long_u new_size ; new_size = ( long_u ) ( decrypted_size + linerest + 1 ) ; new_buffer = lalloc ( new_size , FALSE ) ; if ( new_buffer == NULL ) { do_outofmem_msg ( new_size ) ; error = TRUE ; break ; } mch_memmove ( new_buffer , buffer , linerest ) ; if ( newptr != NULL ) mch_memmove ( new_buffer + linerest , newptr , decrypted_size ) ; } if ( new_buffer != NULL ) { vim_free ( buffer ) ; buffer = new_buffer ; new_buffer = NULL ; line_start = buffer ; ptr = buffer + linerest ; } size = decrypted_size ; } } # endif if ( size <= 0 ) { if ( size < 0 ) error = TRUE ; # ifdef FEAT_MBYTE else if ( conv_restlen > 0 ) { if ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = curbuf -> b_ml . ml_line_count - linecnt + 1 ; } else if ( illegal_byte == 0 ) illegal_byte = curbuf -> b_ml . ml_line_count - linecnt + 1 ; if ( bad_char_behavior == BAD_DROP ) { * ( ptr - conv_restlen ) = NUL ; conv_restlen = 0 ; } else { if ( bad_char_behavior != BAD_KEEP && ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) ) { while ( conv_restlen > 0 ) { * ( -- ptr ) = bad_char_behavior ; -- conv_restlen ; } } fio_flags = 0 ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif } } # endif } } skip_read = FALSE ; # ifdef FEAT_MBYTE if ( ( filesize == 0 # ifdef FEAT_CRYPT || ( cryptkey != NULL && filesize == crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) # endif ) && ( fio_flags == FIO_UCSBOM || ( ! curbuf -> b_p_bomb && tmpname == NULL && ( * fenc == 'u' || ( * fenc == NUL && enc_utf8 ) ) ) ) ) { char_u * ccname ; int blen ; if ( size < 2 || curbuf -> b_p_bin ) ccname = NULL ; else ccname = check_for_bom ( ptr , size , & blen , fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags ( fenc ) ) ; if ( ccname != NULL ) { filesize += blen ; size -= blen ; mch_memmove ( ptr , ptr + blen , ( size_t ) size ) ; if ( set_options ) { curbuf -> b_p_bomb = TRUE ; curbuf -> b_start_bomb = TRUE ; } } if ( fio_flags == FIO_UCSBOM ) { if ( ccname == NULL ) { advance_fenc = TRUE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ccname ; fenc_alloced = FALSE ; } skip_read = TRUE ; goto retry ; } } ptr -= conv_restlen ; size += conv_restlen ; conv_restlen = 0 ; # endif if ( size <= 0 ) break ; # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { const char * fromp ; char * top ; size_t from_size ; size_t to_size ; fromp = ( char * ) ptr ; from_size = size ; ptr += size ; top = ( char * ) ptr ; to_size = real_size - size ; while ( ( iconv ( iconv_fd , ( void * ) & fromp , & from_size , & top , & to_size ) == ( size_t ) - 1 && ICONV_ERRNO != ICONV_EINVAL ) || from_size > CONV_RESTLEN ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , ( char_u * ) top ) ; ++ fromp ; -- from_size ; if ( bad_char_behavior == BAD_KEEP ) { * top ++ = * ( fromp - 1 ) ; -- to_size ; } else if ( bad_char_behavior != BAD_DROP ) { * top ++ = bad_char_behavior ; -- to_size ; } } if ( from_size > 0 ) { mch_memmove ( conv_rest , ( char_u * ) fromp , from_size ) ; conv_restlen = ( int ) from_size ; } line_start = ptr - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( char_u * ) top - ptr ) ; } # endif # ifdef WIN3264 if ( fio_flags & FIO_CODEPAGE ) { char_u * src , * dst ; WCHAR ucs2buf [ 3 ] ; int ucs2len ; int codepage = FIO_GET_CP ( fio_flags ) ; int bytelen ; int found_bad ; char replstr [ 2 ] ; if ( bad_char_behavior > 0 ) replstr [ 0 ] = bad_char_behavior ; else replstr [ 0 ] = '?' ; replstr [ 1 ] = NUL ; src = ptr + real_size - size ; mch_memmove ( src , ptr , size ) ; dst = ptr ; size = size ; while ( size > 0 ) { found_bad = FALSE ; # ifdef CP_UTF8 if ( codepage == CP_UTF8 ) { bytelen = ( int ) utf_ptr2len_len ( src , size ) ; if ( bytelen > size ) { if ( bytelen <= CONV_RESTLEN ) break ; bytelen = size ; found_bad = TRUE ; } else { int u8c = utf_ptr2char ( src ) ; if ( u8c > 0xffff || ( * src >= 0x80 && bytelen == 1 ) ) found_bad = TRUE ; ucs2buf [ 0 ] = u8c ; ucs2len = 1 ; } } else # endif { for ( bytelen = 1 ; bytelen <= size && bytelen <= 3 ; ++ bytelen ) { ucs2len = MultiByteToWideChar ( codepage , MB_ERR_INVALID_CHARS , ( LPCSTR ) src , bytelen , ucs2buf , 3 ) ; if ( ucs2len > 0 ) break ; } if ( ucs2len == 0 ) { if ( size == 1 ) break ; found_bad = TRUE ; bytelen = 1 ; } } if ( ! found_bad ) { int i ; if ( enc_utf8 ) { for ( i = 0 ; i < ucs2len ; ++ i ) dst += utf_char2bytes ( ucs2buf [ i ] , dst ) ; } else { BOOL bad = FALSE ; int dstlen ; dstlen = WideCharToMultiByte ( enc_codepage , 0 , ( LPCWSTR ) ucs2buf , ucs2len , ( LPSTR ) dst , ( int ) ( src - dst ) , replstr , & bad ) ; if ( bad ) found_bad = TRUE ; else dst += dstlen ; } } if ( found_bad ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , dst ) ; if ( bad_char_behavior != BAD_DROP ) { if ( bad_char_behavior == BAD_KEEP ) { mch_memmove ( dst , src , bytelen ) ; dst += bytelen ; } else * dst ++ = bad_char_behavior ; } } src += bytelen ; size -= bytelen ; } if ( size > 0 ) { mch_memmove ( conv_rest , src , size ) ; conv_restlen = size ; } size = ( long ) ( dst - ptr ) ; } else # endif # ifdef MACOS_CONVERT if ( fio_flags & FIO_MACROMAN ) { if ( macroman2enc ( ptr , & size , real_size ) == FAIL ) goto rewind_retry ; } else # endif if ( fio_flags != 0 ) { int u8c ; char_u * dest ; char_u * tail = NULL ; dest = ptr + real_size ; if ( fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8 ) { p = ptr + size ; if ( fio_flags == FIO_UTF8 ) { tail = ptr + size - 1 ; while ( tail > ptr && ( * tail & 0xc0 ) == 0x80 ) -- tail ; if ( tail + utf_byte2len ( * tail ) <= ptr + size ) tail = NULL ; else p = tail ; } } else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { p = ptr + ( size & ~ 1 ) ; if ( size & 1 ) tail = p ; if ( ( fio_flags & FIO_UTF16 ) && p > ptr ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( u8c >= 0xd800 && u8c <= 0xdbff ) tail = p ; else p += 2 ; } } else { p = ptr + ( size & ~ 3 ) ; if ( size & 3 ) tail = p ; } if ( tail != NULL ) { conv_restlen = ( int ) ( ( ptr + size ) - tail ) ; mch_memmove ( conv_rest , ( char_u * ) tail , conv_restlen ) ; size -= conv_restlen ; } while ( p > ptr ) { if ( fio_flags & FIO_LATIN1 ) u8c = * -- p ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( ( fio_flags & FIO_UTF16 ) && u8c >= 0xdc00 && u8c <= 0xdfff ) { int u16c ; if ( p == ptr ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } if ( fio_flags & FIO_ENDIAN_L ) { u16c = ( * -- p << 8 ) ; u16c += * -- p ; } else { u16c = * -- p ; u16c += ( * -- p << 8 ) ; } u8c = 0x10000 + ( ( u16c & 0x3ff ) << 10 ) + ( u8c & 0x3ff ) ; if ( u16c < 0xd800 || u16c > 0xdbff ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } else if ( fio_flags & FIO_UCS4 ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( unsigned ) * -- p << 24 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 8 ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( unsigned ) * -- p << 8 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 24 ; } } else { if ( * -- p < 0x80 ) u8c = * p ; else { len = utf_head_off ( ptr , p ) ; p -= len ; u8c = utf_ptr2char ( p ) ; if ( len == 0 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } if ( enc_utf8 ) { dest -= utf_char2len ( u8c ) ; ( void ) utf_char2bytes ( u8c , dest ) ; } else { -- dest ; if ( u8c >= 0x100 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) ++ dest ; else if ( bad_char_behavior == BAD_KEEP ) * dest = u8c ; else if ( eap != NULL && eap -> bad_char != 0 ) * dest = bad_char_behavior ; else * dest = 0xBF ; } else * dest = u8c ; } } line_start = dest - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( ptr + real_size ) - dest ) ; ptr = dest ; } else if ( enc_utf8 && ! curbuf -> b_p_bin ) { int incomplete_tail = FALSE ; for ( p = ptr ; ; ++ p ) { int todo = ( int ) ( ( ptr + size ) - p ) ; int l ; if ( todo <= 0 ) break ; if ( * p >= 0x80 ) { l = utf_ptr2len_len ( p , todo ) ; if ( l > todo && ! incomplete_tail ) { if ( p > ptr || filesize > 0 ) incomplete_tail = TRUE ; if ( p > ptr ) { conv_restlen = todo ; mch_memmove ( conv_rest , p , conv_restlen ) ; size -= conv_restlen ; break ; } } if ( l == 1 || l > todo ) { if ( can_retry && ! incomplete_tail ) break ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 && conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; # endif if ( conv_error == 0 && illegal_byte == 0 ) illegal_byte = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) { mch_memmove ( p , p + 1 , todo - 1 ) ; -- p ; -- size ; } else if ( bad_char_behavior != BAD_KEEP ) * p = bad_char_behavior ; } else p += l - 1 ; } } if ( p < ptr + size && ! incomplete_tail ) { rewind_retry : # if defined ( FEAT_EVAL ) && defined ( USE_ICONV ) if ( * p_ccv != NUL && iconv_fd != ( iconv_t ) - 1 ) did_iconv = TRUE ; else # endif advance_fenc = TRUE ; file_rewind = TRUE ; goto retry ; } } # endif filesize += size ; if ( fileformat == EOL_UNKNOWN ) { if ( try_dos || try_unix ) { if ( try_mac ) try_mac = 1 ; for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) { if ( ! try_unix || ( try_dos && p > ptr && p [ - 1 ] == CAR ) ) fileformat = EOL_DOS ; else fileformat = EOL_UNIX ; break ; } else if ( * p == CAR && try_mac ) try_mac ++ ; } if ( fileformat == EOL_UNIX && try_mac ) { try_mac = 1 ; try_unix = 1 ; for ( ; p >= ptr && * p != CAR ; p -- ) ; if ( p >= ptr ) { for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) try_unix ++ ; else if ( * p == CAR ) try_mac ++ ; } if ( try_mac > try_unix ) fileformat = EOL_MAC ; } } else if ( fileformat == EOL_UNKNOWN && try_mac == 1 ) fileformat = default_fileformat ( ) ; } if ( fileformat == EOL_UNKNOWN && try_mac ) fileformat = EOL_MAC ; if ( fileformat == EOL_UNKNOWN ) fileformat = default_fileformat ( ) ; if ( set_options ) set_fileformat ( fileformat , OPT_LOCAL ) ; } } if ( fileformat == EOL_MAC ) { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != CAR && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else if ( c == NL ) * ptr = CAR ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } else { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( fileformat == EOL_DOS ) { if ( ptr > line_start && ptr [ - 1 ] == CAR ) { ptr [ - 1 ] = NUL ; -- len ; } else if ( ff_error != EOL_DOS ) { if ( try_unix && ! read_stdin && ( read_buffer || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) == 0 ) ) { fileformat = EOL_UNIX ; if ( set_options ) set_fileformat ( EOL_UNIX , OPT_LOCAL ) ; file_rewind = TRUE ; keep_fileformat = TRUE ; goto retry ; } ff_error = EOL_DOS ; } } if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } linerest = ( long ) ( ptr - line_start ) ; ui_breakcheck ( ) ; } failed : if ( error && read_count == 0 ) error = FALSE ; if ( ! error && ! got_int && linerest != 0 && ! ( ! curbuf -> b_p_bin && fileformat == EOL_DOS && * line_start == Ctrl_Z && ptr == line_start + 1 ) ) { if ( set_options ) curbuf -> b_p_eol = FALSE ; * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) error = TRUE ; else { # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif read_no_eol_lnum = ++ lnum ; } } if ( set_options ) save_file_ff ( curbuf ) ; # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } if ( cryptkey != NULL && cryptkey != curbuf -> b_p_key ) crypt_free_key ( cryptkey ) ; # endif # ifdef FEAT_MBYTE if ( set_options ) set_string_option_direct ( ( char_u * ) ""fenc"" , - 1 , fenc , OPT_FREE | OPT_LOCAL , 0 ) ; if ( fenc_alloced ) vim_free ( fenc ) ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif # endif if ( ! read_buffer && ! read_stdin ) close ( fd ) ; # ifdef HAVE_FD_CLOEXEC else { int fdflags = fcntl ( fd , F_GETFD ) ; if ( fdflags >= 0 && ( fdflags & FD_CLOEXEC ) == 0 ) ( void ) fcntl ( fd , F_SETFD , fdflags | FD_CLOEXEC ) ; } # endif vim_free ( buffer ) ; # ifdef HAVE_DUP if ( read_stdin ) { close ( 0 ) ; ignored = dup ( 2 ) ; } # endif # ifdef FEAT_MBYTE if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; } # endif -- no_wait_return ; if ( ! recoverymode ) { if ( newfile && wasempty && ! ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ) { # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 0 ; # endif ml_delete ( curbuf -> b_ml . ml_line_count , FALSE ) ; # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 1 ; # endif -- linecnt ; } linecnt = curbuf -> b_ml . ml_line_count - linecnt ; if ( filesize == 0 ) linecnt = 0 ; if ( newfile || read_buffer ) { redraw_curbuf_later ( NOT_VALID ) ; # ifdef FEAT_DIFF diff_invalidate ( curbuf ) ; # endif # ifdef FEAT_FOLDING foldUpdateAll ( curwin ) ; # endif } else if ( linecnt ) appended_lines_mark ( from , linecnt ) ; # ifndef ALWAYS_USE_GUI if ( read_stdin ) { settmode ( TMODE_RAW ) ; starttermcap ( ) ; screenclear ( ) ; } # endif if ( got_int ) { if ( ! ( flags & READ_DUMMY ) ) { filemess ( curbuf , sfname , ( char_u * ) _ ( e_interr ) , 0 ) ; if ( newfile ) curbuf -> b_p_ro = TRUE ; } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif return OK ; } if ( ! filtering && ! ( flags & READ_DUMMY ) ) { msg_add_fname ( curbuf , sfname ) ; c = FALSE ; # ifdef UNIX # ifdef S_ISFIFO if ( S_ISFIFO ( perm ) ) { STRCAT ( IObuff , _ ( ""[fifo/socket]"" ) ) ; c = TRUE ; } # else # ifdef S_IFIFO if ( ( perm & S_IFMT ) == S_IFIFO ) { STRCAT ( IObuff , _ ( ""[fifo]"" ) ) ; c = TRUE ; } # endif # ifdef S_IFSOCK if ( ( perm & S_IFMT ) == S_IFSOCK ) { STRCAT ( IObuff , _ ( ""[socket]"" ) ) ; c = TRUE ; } # endif # endif # ifdef OPEN_CHR_FILES if ( S_ISCHR ( perm ) ) { STRCAT ( IObuff , _ ( ""[character<S2SV_blank>special]"" ) ) ; c = TRUE ; } # endif # endif if ( curbuf -> b_p_ro ) { STRCAT ( IObuff , shortmess ( SHM_RO ) ? _ ( ""[RO]"" ) : _ ( ""[readonly]"" ) ) ; c = TRUE ; } if ( read_no_eol_lnum ) { msg_add_eol ( ) ; c = TRUE ; } if ( ff_error == EOL_DOS ) { STRCAT ( IObuff , _ ( ""[CR<S2SV_blank>missing]"" ) ) ; c = TRUE ; } if ( split ) { STRCAT ( IObuff , _ ( ""[long<S2SV_blank>lines<S2SV_blank>split]"" ) ) ; c = TRUE ; } # ifdef FEAT_MBYTE if ( notconverted ) { STRCAT ( IObuff , _ ( ""[NOT<S2SV_blank>converted]"" ) ) ; c = TRUE ; } else if ( converted ) { STRCAT ( IObuff , _ ( ""[converted]"" ) ) ; c = TRUE ; } # endif # ifdef FEAT_CRYPT if ( cryptkey != NULL ) { crypt_append_msg ( curbuf ) ; c = TRUE ; } # endif # ifdef FEAT_MBYTE if ( conv_error != 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( ""[CONVERSION<S2SV_blank>ERROR<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]"" ) , ( long ) conv_error ) ; c = TRUE ; } else if ( illegal_byte > 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( ""[ILLEGAL<S2SV_blank>BYTE<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]"" ) , ( long ) illegal_byte ) ; c = TRUE ; } else # endif if ( error ) { STRCAT ( IObuff , _ ( ""[READ<S2SV_blank>ERRORS]"" ) ) ; c = TRUE ; } if ( msg_add_fileformat ( fileformat ) ) c = TRUE ; # ifdef FEAT_CRYPT if ( cryptkey != NULL ) msg_add_lines ( c , ( long ) linecnt , filesize - crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) ; else # endif msg_add_lines ( c , ( long ) linecnt , filesize ) ; vim_free ( keep_msg ) ; keep_msg = NULL ; msg_scrolled_ign = TRUE ; # ifdef ALWAYS_USE_GUI if ( read_stdin || read_buffer ) p = msg_may_trunc ( FALSE , IObuff ) ; else # endif p = msg_trunc_attr ( IObuff , FALSE , 0 ) ; if ( read_stdin || read_buffer || restart_edit != 0 || ( msg_scrolled != 0 && ! need_wait_return ) ) set_keep_msg ( p , 0 ) ; msg_scrolled_ign = FALSE ; } if ( newfile && ( error # ifdef FEAT_MBYTE || conv_error != 0 || ( illegal_byte > 0 && bad_char_behavior != BAD_KEEP ) # endif ) ) curbuf -> b_p_ro = TRUE ; u_clearline ( ) ; if ( exmode_active ) curwin -> w_cursor . lnum = from + linecnt ; else curwin -> w_cursor . lnum = from + 1 ; check_cursor_lnum ( ) ; beginline ( BL_WHITE | BL_FIX ) ; curbuf -> b_op_start . lnum = from + 1 ; curbuf -> b_op_start . col = 0 ; curbuf -> b_op_end . lnum = from + linecnt ; curbuf -> b_op_end . col = 0 ; # ifdef WIN32 if ( newfile && ! read_stdin && ! read_buffer && mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; } # endif } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif curbuf -> b_no_eol_lnum = read_no_eol_lnum ; if ( flags & READ_KEEP_UNDO ) u_find_first_changed ( ) ; # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) { char_u hash [ UNDO_HASH_SIZE ] ; sha256_finish ( & sha_ctx , hash ) ; u_read_undo ( NULL , hash , fname ) ; } # endif # ifdef FEAT_AUTOCMD if ( ! read_stdin && ! read_fifo && ( ! read_buffer || sfname != NULL ) ) { int m = msg_scroll ; int n = msg_scrolled ; if ( set_options ) save_file_ff ( curbuf ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile || ( read_buffer && sfname != NULL ) ) { apply_autocmds_exarg ( EVENT_BUFREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; if ( ! au_did_filetype && * curbuf -> b_p_ft != NUL ) apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } else apply_autocmds_exarg ( EVENT_FILEREADPOST , sfname , sfname , FALSE , NULL , eap ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) return FAIL ; # endif } # endif if ( recoverymode && error ) return FAIL ; return OK ; }","!= NULL ) { char_u * swap_fname = <S2SV_ModEnd> curbuf -> b_ml <S2SV_ModStart> ml_mfp -> mf_fname ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> swap_mode ) ; }"
813,"static int br_mdb_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net_device * dev ; struct net * net = sock_net ( skb -> sk ) ; struct nlmsghdr * nlh = NULL ; int idx = 0 , s_idx ; s_idx = cb -> args [ 0 ] ; rcu_read_lock ( ) ; cb -> seq = net -> dev_base_seq + br_mdb_rehash_seq ; for_each_netdev_rcu ( net , dev ) { if ( dev -> priv_flags & IFF_EBRIDGE ) { struct br_port_msg * bpm ; if ( idx < s_idx ) goto skip ; nlh = nlmsg_put ( skb , NETLINK_CB ( cb -> skb ) . portid , cb -> nlh -> nlmsg_seq , RTM_GETMDB , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( nlh == NULL ) break ; <S2SV_StartBug> bpm = nlmsg_data ( nlh ) ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; if ( br_mdb_fill_info ( skb , cb , dev ) < 0 ) goto out ; if ( br_rports_fill_info ( skb , cb , dev ) < 0 ) goto out ; cb -> args [ 1 ] = 0 ; nlmsg_end ( skb , nlh ) ; skip : idx ++ ; } } out : if ( nlh ) nlmsg_end ( skb , nlh ) ; rcu_read_unlock ( ) ; cb -> args [ 0 ] = idx ; return skb -> len ; }","nlmsg_data ( nlh ) ; memset ( bpm , 0 , sizeof ( * bpm )"
814,"PHP_FUNCTION ( imagecrop ) { zval * IM ; gdImagePtr im ; gdImagePtr im_crop ; gdRect rect ; zval * z_rect ; zval * * tmp ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra"" , & IM , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } im_crop = gdImageCrop ( im , & rect ) ; if ( im_crop == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , im_crop , le_gd ) ; } }",FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
815,"static void update_layer_buffer_level ( SVC * svc , int encoded_frame_size ) { <S2SV_StartBug> int temporal_layer = 0 ; <S2SV_EndBug> int current_temporal_layer = svc -> temporal_layer_id ; <S2SV_StartBug> for ( temporal_layer = current_temporal_layer + 1 ; <S2SV_EndBug> <S2SV_StartBug> temporal_layer < svc -> number_temporal_layers ; ++ temporal_layer ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * lc = & svc -> layer_context [ temporal_layer ] ; <S2SV_EndBug> RATE_CONTROL * lrc = & lc -> rc ; int bits_off_for_this_layer = ( int ) ( lc -> target_bandwidth / lc -> framerate - encoded_frame_size ) ; lrc -> bits_off_target += bits_off_for_this_layer ; <S2SV_StartBug> lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; <S2SV_EndBug> lrc -> buffer_level = lrc -> bits_off_target ; } }",") { int i <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; for ( i <S2SV_ModEnd> = current_temporal_layer + <S2SV_ModStart> + 1 ; i <S2SV_ModEnd> < svc -> <S2SV_ModStart> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; <S2SV_ModEnd> LAYER_CONTEXT * lc <S2SV_ModStart> -> layer_context [ layer <S2SV_ModEnd> ] ; RATE_CONTROL <S2SV_ModStart> -> bits_off_target , lrc <S2SV_ModEnd> -> maximum_buffer_size )"
816,"struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }",( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
817,"static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",|= MSG_TRUNC ; msg -> msg_namelen = 0 ;
818,"static int spk_ttyio_ldisc_open ( struct tty_struct * tty ) { struct spk_ldisc_data * ldisc_data ; if ( ! tty -> ops -> write ) return - EOPNOTSUPP ; <S2SV_StartBug> speakup_tty = tty ; <S2SV_EndBug> ldisc_data = kmalloc ( sizeof ( * ldisc_data ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! ldisc_data ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> init_completion ( & ldisc_data -> completion ) ; ldisc_data -> buf_free = true ; speakup_tty -> disc_data = ldisc_data ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }",- EOPNOTSUPP ; mutex_lock ( & speakup_tty_mutex ) ; if ( speakup_tty ) { mutex_unlock ( & speakup_tty_mutex ) ; return - EBUSY ; } <S2SV_ModStart> ! ldisc_data ) { speakup_tty = NULL ; mutex_unlock ( & speakup_tty_mutex ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> = ldisc_data ; mutex_unlock ( & speakup_tty_mutex ) ;
819,"int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_bindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : <S2SV_StartBug> if ( val > sysctl_wmem_max ) <S2SV_EndBug> val = sysctl_wmem_max ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_SNDBUF ) <S2SV_EndBug> sk -> sk_sndbuf = SOCK_MIN_SNDBUF ; else sk -> sk_sndbuf = val * 2 ; sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : <S2SV_StartBug> if ( val > sysctl_rmem_max ) <S2SV_EndBug> val = sysctl_rmem_max ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_RCVBUF ) <S2SV_EndBug> sk -> sk_rcvbuf = SOCK_MIN_RCVBUF ; else sk -> sk_rcvbuf = val * 2 ; break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP ) tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || capable ( CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""setsockopt"" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE , val & SOF_TIMESTAMPING_TX_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE , val & SOF_TIMESTAMPING_TX_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE , val & SOF_TIMESTAMPING_RX_HARDWARE ) ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE , val & SOF_TIMESTAMPING_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE , val & SOF_TIMESTAMPING_SYS_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE , val & SOF_TIMESTAMPING_RAW_HARDWARE ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }","case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> ; set_sndbuf : <S2SV_ModStart> |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> ; sk -> <S2SV_ModStart> case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> ; set_rcvbuf : <S2SV_ModStart> |= SOCK_RCVBUF_LOCK ; sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> ; break ;"
820,"static int pgx_gethdr ( jas_stream_t * in , pgx_hdr_t * hdr ) { int c ; <S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } buf [ 0 ] = c ; if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } buf [ 1 ] = c ; hdr -> magic = buf [ 0 ] << 8 | buf [ 1 ] ; if ( hdr -> magic != PGX_MAGIC ) { jas_eprintf ( ""invalid<S2SV_blank>PGX<S2SV_blank>signature\\n"" ) ; goto error ; } if ( ( c = pgx_getc ( in ) ) == EOF || ! isspace ( c ) ) { goto error ; } if ( pgx_getbyteorder ( in , & hdr -> bigendian ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; goto error ; } if ( pgx_getsgnd ( in , & hdr -> sgnd ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>signedness\\n"" ) ; goto error ; } if ( pgx_getuint32 ( in , & hdr -> prec ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>precision\\n"" ) ; goto error ; } if ( pgx_getuint32 ( in , & hdr -> width ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>width\\n"" ) ; goto error ; } if ( pgx_getuint32 ( in , & hdr -> height ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>height\\n"" ) ; goto error ; } return 0 ; error : return - 1 ; }",int c ; jas_uchar <S2SV_ModEnd> buf [ 2
821,"static int tok_nextc ( struct tok_state * tok ) { for ( ; ; ) { if ( tok -> cur != tok -> inp ) { return Py_CHARMASK ( * tok -> cur ++ ) ; } if ( tok -> done != E_OK ) return EOF ; if ( tok -> fp == NULL ) { char * end = strchr ( tok -> inp , '\\n' ) ; if ( end != NULL ) end ++ ; else { end = strchr ( tok -> inp , '\\0' ) ; if ( end == tok -> inp ) { tok -> done = E_EOF ; return EOF ; } } if ( tok -> start == NULL ) tok -> buf = tok -> cur ; tok -> line_start = tok -> cur ; tok -> lineno ++ ; tok -> inp = end ; return Py_CHARMASK ( * tok -> cur ++ ) ; } if ( tok -> prompt != NULL ) { char * newtok = PyOS_Readline ( stdin , stdout , tok -> prompt ) ; # ifndef PGEN if ( newtok != NULL ) { char * translated = translate_newlines ( newtok , 0 , tok ) ; PyMem_FREE ( newtok ) ; if ( translated == NULL ) return EOF ; newtok = translated ; } if ( tok -> encoding && newtok && * newtok ) { Py_ssize_t buflen ; const char * buf ; PyObject * u = translate_into_utf8 ( newtok , tok -> encoding ) ; PyMem_FREE ( newtok ) ; if ( ! u ) { tok -> done = E_DECODE ; return EOF ; } buflen = PyBytes_GET_SIZE ( u ) ; buf = PyBytes_AS_STRING ( u ) ; <S2SV_StartBug> newtok = PyMem_MALLOC ( buflen + 1 ) ; <S2SV_EndBug> strcpy ( newtok , buf ) ; Py_DECREF ( u ) ; } # endif if ( tok -> nextprompt != NULL ) tok -> prompt = tok -> nextprompt ; if ( newtok == NULL ) tok -> done = E_INTR ; else if ( * newtok == '\\0' ) { PyMem_FREE ( newtok ) ; tok -> done = E_EOF ; } else if ( tok -> start != NULL ) { size_t start = tok -> start - tok -> buf ; size_t oldlen = tok -> cur - tok -> buf ; size_t newlen = oldlen + strlen ( newtok ) ; char * buf = tok -> buf ; buf = ( char * ) PyMem_REALLOC ( buf , newlen + 1 ) ; tok -> lineno ++ ; if ( buf == NULL ) { PyMem_FREE ( tok -> buf ) ; tok -> buf = NULL ; PyMem_FREE ( newtok ) ; tok -> done = E_NOMEM ; return EOF ; } tok -> buf = buf ; tok -> cur = tok -> buf + oldlen ; tok -> line_start = tok -> cur ; strcpy ( tok -> buf + oldlen , newtok ) ; PyMem_FREE ( newtok ) ; tok -> inp = tok -> buf + newlen ; tok -> end = tok -> inp + 1 ; tok -> start = tok -> buf + start ; } else { tok -> lineno ++ ; if ( tok -> buf != NULL ) PyMem_FREE ( tok -> buf ) ; tok -> buf = newtok ; tok -> cur = tok -> buf ; tok -> line_start = tok -> buf ; tok -> inp = strchr ( tok -> buf , '\\0' ) ; tok -> end = tok -> inp + 1 ; } } else { int done = 0 ; Py_ssize_t cur = 0 ; char * pt ; if ( tok -> start == NULL ) { if ( tok -> buf == NULL ) { tok -> buf = ( char * ) PyMem_MALLOC ( BUFSIZ ) ; if ( tok -> buf == NULL ) { tok -> done = E_NOMEM ; return EOF ; } tok -> end = tok -> buf + BUFSIZ ; } if ( decoding_fgets ( tok -> buf , ( int ) ( tok -> end - tok -> buf ) , tok ) == NULL ) { if ( ! tok -> decoding_erred ) tok -> done = E_EOF ; done = 1 ; } else { tok -> done = E_OK ; tok -> inp = strchr ( tok -> buf , '\\0' ) ; done = tok -> inp == tok -> buf || tok -> inp [ - 1 ] == '\\n' ; } } else { cur = tok -> cur - tok -> buf ; if ( decoding_feof ( tok ) ) { tok -> done = E_EOF ; done = 1 ; } else tok -> done = E_OK ; } tok -> lineno ++ ; while ( ! done ) { Py_ssize_t curstart = tok -> start == NULL ? - 1 : tok -> start - tok -> buf ; Py_ssize_t curvalid = tok -> inp - tok -> buf ; Py_ssize_t newsize = curvalid + BUFSIZ ; char * newbuf = tok -> buf ; newbuf = ( char * ) PyMem_REALLOC ( newbuf , newsize ) ; if ( newbuf == NULL ) { tok -> done = E_NOMEM ; tok -> cur = tok -> inp ; return EOF ; } tok -> buf = newbuf ; tok -> cur = tok -> buf + cur ; tok -> line_start = tok -> cur ; tok -> inp = tok -> buf + curvalid ; tok -> end = tok -> buf + newsize ; tok -> start = curstart < 0 ? NULL : tok -> buf + curstart ; if ( decoding_fgets ( tok -> inp , ( int ) ( tok -> end - tok -> inp ) , tok ) == NULL ) { if ( tok -> decoding_erred ) return EOF ; strcpy ( tok -> inp , ""\\n"" ) ; } tok -> inp = strchr ( tok -> inp , '\\0' ) ; done = tok -> inp [ - 1 ] == '\\n' ; } if ( tok -> buf != NULL ) { tok -> cur = tok -> buf + cur ; tok -> line_start = tok -> cur ; pt = tok -> inp - 2 ; if ( pt >= tok -> buf && * pt == '\\r' ) { * pt ++ = '\\n' ; * pt = '\\0' ; tok -> inp = pt ; } } } if ( tok -> done != E_OK ) { if ( tok -> prompt != NULL ) PySys_WriteStderr ( ""\\n"" ) ; tok -> cur = tok -> inp ; return EOF ; } } }",1 ) ; if ( newtok == NULL ) { Py_DECREF ( u ) ; tok -> done = E_NOMEM ; return EOF ; }
822,"int ext4_punch_hole ( struct inode * inode , loff_t offset , loff_t length ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t first_block , stop_block ; struct address_space * mapping = inode -> i_mapping ; loff_t first_block_offset , last_block_offset ; handle_t * handle ; unsigned int credits ; int ret = 0 ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_punch_hole ( inode , offset , length , 0 ) ; if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + length - 1 ) ; if ( ret ) return ret ; } mutex_lock ( & inode -> i_mutex ) ; if ( offset >= inode -> i_size ) goto out_mutex ; if ( offset + length > inode -> i_size ) { length = inode -> i_size + PAGE_CACHE_SIZE - ( inode -> i_size & ( PAGE_CACHE_SIZE - 1 ) ) - offset ; } if ( offset & ( sb -> s_blocksize - 1 ) || ( offset + length ) & ( sb -> s_blocksize - 1 ) ) { ret = ext4_inode_attach_jinode ( inode ) ; if ( ret < 0 ) goto out_mutex ; } <S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ; if ( last_block_offset > first_block_offset ) truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) credits = ext4_writepage_trans_blocks ( inode ) ; else credits = ext4_blocks_for_truncate ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( sb , ret ) ; goto out_dio ; } ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ; if ( ret ) goto out_stop ; first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( first_block >= stop_block ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ; else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; out_dio : <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }",out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> last_block_offset ) ; <S2SV_ModEnd> if ( ext4_test_inode_flag <S2SV_ModStart> handle ) ; <S2SV_ModEnd> inode -> i_mtime <S2SV_ModStart> ; out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
823,"static ssize_t aio_setup_vectored_rw ( int type , struct kiocb * kiocb , bool compat ) { ssize_t ret ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( type , ( struct compat_iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; else # endif ret = rw_copy_check_uvector ( type , ( struct iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; if ( ret < 0 ) goto out ; <S2SV_StartBug> kiocb -> ki_nr_segs = kiocb -> ki_nbytes ; <S2SV_EndBug> kiocb -> ki_cur_seg = 0 ; kiocb -> ki_nbytes = ret ; kiocb -> ki_left = ret ; ret = 0 ; out : return ret ; }","goto out ; ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ;"
824,"static vpx_codec_err_t decode_one ( vpx_codec_alg_priv_t * ctx , const uint8_t * * data , unsigned int data_sz , void * user_priv , int64_t deadline ) { <S2SV_StartBug> YV12_BUFFER_CONFIG sd = { 0 } ; <S2SV_EndBug> int64_t time_stamp = 0 , time_end_stamp = 0 ; vp9_ppflags_t flags = { 0 } ; VP9_COMMON * cm = NULL ; ctx -> img_avail = 0 ; if ( ! ctx -> si . h ) { <S2SV_StartBug> const vpx_codec_err_t res = <S2SV_EndBug> <S2SV_StartBug> ctx -> base . iface -> dec . peek_si ( * data , data_sz , & ctx -> si ) ; <S2SV_EndBug> if ( res != VPX_CODEC_OK ) return res ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! ctx -> decoder_init ) { <S2SV_EndBug> init_decoder ( ctx ) ; <S2SV_StartBug> if ( ctx -> pbi == NULL ) <S2SV_EndBug> return VPX_CODEC_ERROR ; ctx -> decoder_init = 1 ; <S2SV_StartBug> } <S2SV_EndBug> cm = & ctx -> pbi -> common ; if ( vp9_receive_compressed_data ( ctx -> pbi , data_sz , data , deadline ) ) return update_error_state ( ctx , & cm -> error ) ; if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ; if ( vp9_get_raw_frame ( ctx -> pbi , & sd , & time_stamp , & time_end_stamp , & flags ) ) return update_error_state ( ctx , & cm -> error ) ; yuvconfig2image ( & ctx -> img , & sd , user_priv ) ; ctx -> img . fb_priv = cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ; ctx -> img_avail = 1 ; return VPX_CODEC_OK ; }","deadline ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ( void ) deadline <S2SV_ModEnd> ; if ( <S2SV_ModStart> h ) { int is_intra_only = 0 ; <S2SV_ModStart> vpx_codec_err_t res = decoder_peek_si_internal <S2SV_ModEnd> ( * data <S2SV_ModStart> ctx -> si , & is_intra_only , ctx -> decrypt_cb , ctx -> decrypt_state <S2SV_ModStart> return res ; if ( ! ctx -> si . is_kf && ! is_intra_only ) return VPX_CODEC_ERROR ; <S2SV_ModStart> ! ctx -> frame_parallel_decode ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data -> data = * data ; frame_worker_data -> data_size = data_sz ; frame_worker_data -> user_priv = user_priv ; frame_worker_data -> received_frame = 1 ; frame_worker_data -> pbi -> decrypt_cb = ctx -> decrypt_cb ; frame_worker_data -> pbi -> decrypt_state = ctx -> decrypt_state ; worker -> had_error = 0 ; winterface -> execute ( worker ) ; * data = frame_worker_data -> data_end ; if ( worker -> had_error ) return update_error_state ( ctx , & frame_worker_data -> pbi -> common . error ) ; check_resync ( ctx , frame_worker_data -> pbi ) ; } else { VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_submit_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) vp9_frameworker_copy_context ( & ctx -> frame_workers [ ctx -> next_submit_worker_id ] , & ctx -> frame_workers [ ctx -> last_submit_worker_id ] ) ; frame_worker_data -> pbi -> ready_for_new_data = 0 ; if ( frame_worker_data -> scratch_buffer_size < data_sz ) { frame_worker_data -> scratch_buffer = ( uint8_t * ) vpx_realloc ( frame_worker_data -> scratch_buffer , data_sz ) ; if ( frame_worker_data -> scratch_buffer <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>reallocate<S2SV_blank>scratch<S2SV_blank>buffer"" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> scratch_buffer_size = data_sz ; } frame_worker_data -> data_size = data_sz ; memcpy ( frame_worker_data -> scratch_buffer , * data , data_sz ) ; frame_worker_data -> frame_decoded = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; frame_worker_data -> data = frame_worker_data -> scratch_buffer ; frame_worker_data -> user_priv = user_priv ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) ctx -> last_submit_worker_id = ( ctx -> last_submit_worker_id + 1 ) % ctx -> num_frame_workers ; ctx -> next_submit_worker_id = ( ctx -> next_submit_worker_id + 1 ) % ctx -> num_frame_workers ; -- ctx -> available_threads ; worker -> had_error = 0 ; winterface -> launch ( worker ) ; } <S2SV_ModEnd> return VPX_CODEC_OK ;"
825,"int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( ""%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!"" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , ""desc"" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( ""format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g"" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( ""packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames"" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( ""channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d"" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , ""lpcm"" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point"" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""chan"" , 4 ) ) { <S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( ""this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( ""channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( ""%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!"" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( ""chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d"" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( ""warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d"" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = ""12345678"" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\""%s\\""\\n"" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) { uint32_t mEditCount ; if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( ""problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)"" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }","CAFChannelLayout * caf_channel_layout <S2SV_ModEnd> ; if ( <S2SV_ModStart> CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> } else { uint32_t <S2SV_ModEnd> bytes_to_copy = ( <S2SV_ModStart> ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }"
826,"static void sync_lockstate_on_connect ( btif_hh_device_t * p_dev ) { int keylockstates ; BTIF_TRACE_EVENT ( ""%s:<S2SV_blank>Syncing<S2SV_blank>keyboard<S2SV_blank>lock<S2SV_blank>states<S2SV_blank>after<S2SV_blank>"" ""reconnect..."" , __FUNCTION__ ) ; update_keyboard_lockstates ( p_dev ) ; keylockstates = get_keylockstates ( ) ; if ( keylockstates ) { BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank>Sending<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>to<S2SV_blank>kernel<S2SV_blank>"" ""indicating<S2SV_blank>lock<S2SV_blank>key<S2SV_blank>state<S2SV_blank>0x%x"" , __FUNCTION__ , keylockstates ) ; <S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> toggle_os_keylockstates ( p_dev -> fd , keylockstates ) ; } else { BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank>NOT<S2SV_blank>sending<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>to<S2SV_blank>kernel<S2SV_blank>"" ""indicating<S2SV_blank>lock<S2SV_blank>key<S2SV_blank>state<S2SV_blank>0x%x"" , __FUNCTION__ , keylockstates ) ; } }",keylockstates ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 200000 )
827,"static int do_16x16_zerozero_search ( VP9_COMP * cpi , int_mv * dst_mv ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err ; <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <S2SV_EndBug> INT_MAX ) ; dst_mv -> as_int = 0 ; return err ; }",& cpi -> td . <S2SV_ModStart> ; err = vpx_sad16x16 <S2SV_ModEnd> ( x -> <S2SV_ModStart> ] . stride <S2SV_ModEnd> ) ; dst_mv
828,"int obj2ast_stmt ( PyObject * obj , stmt_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; int lineno ; int col_offset ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; arguments_ty args ; asdl_seq * body ; asdl_seq * decorator_list ; expr_ty returns ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_decorator_list ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_decorator_list ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Ta3_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_returns ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { returns = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } * out = FunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncFunctionDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; arguments_ty args ; asdl_seq * body ; asdl_seq * decorator_list ; expr_ty returns ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_decorator_list ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_decorator_list ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Ta3_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_returns ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { returns = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } * out = AsyncFunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ClassDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; asdl_seq * bases ; asdl_seq * keywords ; asdl_seq * body ; asdl_seq * decorator_list ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_bases ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_bases ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; bases = _Ta3_asdl_seq_new ( len , arena ) ; if ( bases == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( bases , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_keywords ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_keywords ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; keywords = _Ta3_asdl_seq_new ( len , arena ) ; if ( keywords == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> keyword_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( keywords , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_decorator_list ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_decorator_list ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Ta3_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } * out = ClassDef ( name , bases , keywords , body , decorator_list , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Return_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { value = NULL ; } * out = Return ( value , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Delete_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * targets ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_targets ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_targets ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Delete<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; targets = _Ta3_asdl_seq_new ( len , arena ) ; if ( targets == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Delete<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( targets , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete"" ) ; return 1 ; } * out = Delete ( targets , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Assign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * targets ; expr_ty value ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_targets ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_targets ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Assign<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; targets = _Ta3_asdl_seq_new ( len , arena ) ; if ( targets == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Assign<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( targets , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } * out = Assign ( targets , value , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AugAssign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; operator_ty op ; expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } * out = AugAssign ( target , op , value , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AnnAssign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty annotation ; expr_ty value ; int simple ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; <S2SV_EndBug> return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_annotation ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & annotation , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""annotation\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { value = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_simple ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_simple ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & simple , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""simple\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } * out = AnnAssign ( target , annotation , value , simple , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) For_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty iter ; asdl_seq * body ; asdl_seq * orelse ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""For<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""For<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""For<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""For<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = For ( target , iter , body , orelse , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncFor_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty iter ; asdl_seq * body ; asdl_seq * orelse ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = AsyncFor ( target , iter , body , orelse , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) While_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; asdl_seq * body ; asdl_seq * orelse ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""While<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""While<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""While<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""While<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } * out = While ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) If_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; asdl_seq * body ; asdl_seq * orelse ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""If<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""If<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""If<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""If<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } * out = If ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) With_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * items ; asdl_seq * body ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_items ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_items ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""With<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; items = _Ta3_asdl_seq_new ( len , arena ) ; if ( items == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> withitem_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""With<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( items , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""With<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""With<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = With ( items , body , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncWith_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * items ; asdl_seq * body ; string type_comment ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_items ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_items ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; items = _Ta3_asdl_seq_new ( len , arena ) ; if ( items == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> withitem_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( items , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { type_comment = NULL ; } * out = AsyncWith ( items , body , type_comment , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Raise_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty exc ; expr_ty cause ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_exc ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_exc ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & exc , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { exc = NULL ; } if ( exists_not_none ( obj , & PyId_cause ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_cause ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & cause , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { cause = NULL ; } * out = Raise ( exc , cause , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Try_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * handlers ; asdl_seq * orelse ; asdl_seq * finalbody ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_handlers ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_handlers ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; handlers = _Ta3_asdl_seq_new ( len , arena ) ; if ( handlers == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> excepthandler_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_excepthandler ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( handlers , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_orelse ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_orelse ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Ta3_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_finalbody ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_finalbody ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; finalbody = _Ta3_asdl_seq_new ( len , arena ) ; if ( finalbody == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( finalbody , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } * out = Try ( body , handlers , orelse , finalbody , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Assert_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; expr_ty msg ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & test , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_msg ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_msg ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & msg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { msg = NULL ; } * out = Assert ( test , msg , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Import_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Import<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> alias_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Import<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import"" ) ; return 1 ; } * out = Import ( names , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ImportFrom_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier module ; asdl_seq * names ; int level ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_module ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_module ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { module = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ImportFrom<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> alias_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ImportFrom<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom"" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_level ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_level ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_int ( tmp , & level , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { level = 0 ; } * out = ImportFrom ( module , names , level , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Global_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Global<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> identifier value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Global<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global"" ) ; return 1 ; } * out = Global ( names , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Nonlocal_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_names ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Nonlocal<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Ta3_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> identifier value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Nonlocal<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal"" ) ; return 1 ; } * out = Nonlocal ( names , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expr_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr"" ) ; return 1 ; } * out = Expr ( value , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Pass_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Pass ( lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Break_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Break ( lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Continue_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Continue ( lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>stmt,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }","} if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & col_offset <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } isinstance <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_bases , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { keyword_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_ModEnd> Py_CLEAR ( tmp <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & value <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""annotation\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & annotation <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_simple , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""simple\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & simple <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & iter <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & iter <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { withitem_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { withitem_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_exc , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; exc = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & exc , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_cause , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; cause = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & cause <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_handlers , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { excepthandler_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_finalbody , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_msg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; msg = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & msg <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { alias_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_module , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; module = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { alias_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_level , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; level = 0 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_int <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { identifier val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { identifier val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *"
829,"static void * arm_coherent_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , true , __builtin_return_address ( 0 ) ) ; }","( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void"
830,"static int cop1Emulate ( struct pt_regs * xcp , struct mips_fpu_struct * ctx , void * __user * fault_addr ) { mips_instruction ir ; unsigned long emulpc , contpc ; unsigned int cond ; if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGSEGV ; } if ( ( xcp -> cp0_cause & CAUSEF_BD ) && ! isBranchInstr ( & ir ) ) xcp -> cp0_cause &= ~ CAUSEF_BD ; if ( xcp -> cp0_cause & CAUSEF_BD ) { emulpc = xcp -> cp0_epc + 4 ; if ( __compute_return_epc ( xcp ) ) { # ifdef CP1DBG printk ( ""failed<S2SV_blank>to<S2SV_blank>emulate<S2SV_blank>branch<S2SV_blank>at<S2SV_blank>%p\\n"" , ( void * ) ( xcp -> cp0_epc ) ) ; # endif return SIGILL ; } if ( ! access_ok ( VERIFY_READ , emulpc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) emulpc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return SIGSEGV ; } contpc = xcp -> cp0_epc ; xcp -> cp0_epc = emulpc - 4 ; } else { emulpc = xcp -> cp0_epc ; contpc = xcp -> cp0_epc + 4 ; } emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug> MIPS_FPU_EMU_INC_STATS ( emulated ) ; switch ( MIPSInst_OPCODE ( ir ) ) { case ldc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u64 val ; MIPS_FPU_EMU_INC_STATS ( loads ) ; if ( ! access_ok ( VERIFY_READ , va , sizeof ( u64 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __get_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } DITOREG ( val , MIPSInst_RT ( ir ) ) ; break ; } case sdc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u64 val ; MIPS_FPU_EMU_INC_STATS ( stores ) ; DIFROMREG ( val , MIPSInst_RT ( ir ) ) ; if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u64 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __put_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } break ; } case lwc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u32 val ; MIPS_FPU_EMU_INC_STATS ( loads ) ; if ( ! access_ok ( VERIFY_READ , va , sizeof ( u32 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __get_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } SITOREG ( val , MIPSInst_RT ( ir ) ) ; break ; } case swc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + MIPSInst_SIMM ( ir ) ) ; u32 val ; MIPS_FPU_EMU_INC_STATS ( stores ) ; SIFROMREG ( val , MIPSInst_RT ( ir ) ) ; if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u32 ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGBUS ; } if ( __put_user ( val , va ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = va ; return SIGSEGV ; } break ; } case cop1_op : switch ( MIPSInst_RS ( ir ) ) { # if defined ( __mips64 ) case dmfc_op : if ( MIPSInst_RT ( ir ) != 0 ) { DIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; } break ; case dmtc_op : DITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; break ; # endif case mfc_op : if ( MIPSInst_RT ( ir ) != 0 ) { SIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; } break ; case mtc_op : SITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; break ; case cfc_op : { u32 value ; if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { value = ctx -> fcr31 ; value = ( value & ~ FPU_CSR_RM ) | mips_rm [ modeindex ( value ) ] ; # ifdef CSRTRACE printk ( ""%p<S2SV_blank>gpr[%d]<-csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , MIPSInst_RT ( ir ) , value ) ; # endif } else if ( MIPSInst_RD ( ir ) == FPCREG_RID ) value = 0 ; else value = 0 ; if ( MIPSInst_RT ( ir ) ) xcp -> regs [ MIPSInst_RT ( ir ) ] = value ; break ; } case ctc_op : { u32 value ; if ( MIPSInst_RT ( ir ) == 0 ) value = 0 ; else value = xcp -> regs [ MIPSInst_RT ( ir ) ] ; if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { # ifdef CSRTRACE printk ( ""%p<S2SV_blank>gpr[%d]->csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , MIPSInst_RT ( ir ) , value ) ; # endif ctx -> fcr31 = ( value & ~ ( FPU_CSR_RSVD | FPU_CSR_RM ) ) | ieee_rm [ modeindex ( value ) ] ; } if ( ( ctx -> fcr31 >> 5 ) & ctx -> fcr31 & FPU_CSR_ALL_E ) { return SIGFPE ; } break ; } case bc_op : { int likely = 0 ; if ( xcp -> cp0_cause & CAUSEF_BD ) return SIGILL ; # if __mips >= 4 cond = ctx -> fcr31 & fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; # else cond = ctx -> fcr31 & FPU_CSR_COND ; # endif switch ( MIPSInst_RT ( ir ) & 3 ) { case bcfl_op : likely = 1 ; case bcf_op : cond = ! cond ; break ; case bctl_op : likely = 1 ; case bct_op : break ; default : return SIGILL ; } xcp -> cp0_cause |= CAUSEF_BD ; if ( cond ) { xcp -> cp0_epc += 4 ; contpc = ( xcp -> cp0_epc + ( MIPSInst_SIMM ( ir ) << 2 ) ) ; if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGBUS ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { MIPS_FPU_EMU_INC_STATS ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return SIGSEGV ; } switch ( MIPSInst_OPCODE ( ir ) ) { case lwc1_op : case swc1_op : # if ( __mips >= 2 || defined ( __mips64 ) ) case ldc1_op : case sdc1_op : # endif case cop1_op : # if __mips >= 4 && __mips != 32 case cop1x_op : # endif goto emul ; # if __mips >= 4 case spec_op : if ( MIPSInst_FUNC ( ir ) == movc_op ) goto emul ; break ; # endif } return mips_dsemul ( xcp , ir , contpc ) ; } else { if ( likely ) { xcp -> cp0_epc += 4 ; contpc += 4 ; } } break ; } default : if ( ! ( MIPSInst_RS ( ir ) & 0x10 ) ) return SIGILL ; { int sig ; if ( ( sig = fpu_emu ( xcp , ctx , ir ) ) ) return sig ; } } break ; # if __mips >= 4 && __mips != 32 case cop1x_op : { int sig = fpux_emu ( xcp , ctx , ir , fault_addr ) ; if ( sig ) return sig ; break ; } # endif # if __mips >= 4 case spec_op : if ( MIPSInst_FUNC ( ir ) != movc_op ) return SIGILL ; cond = fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; if ( ( ( ctx -> fcr31 & cond ) != 0 ) == ( ( MIPSInst_RT ( ir ) & 1 ) != 0 ) ) xcp -> regs [ MIPSInst_RD ( ir ) ] = xcp -> regs [ MIPSInst_RS ( ir ) ] ; break ; # endif default : return SIGILL ; } xcp -> cp0_epc = contpc ; xcp -> cp0_cause &= ~ CAUSEF_BD ; return 0 ; }","PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,"
831,"bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { applog ( LOG_INFO , ""setup_stratum_socket()<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>failed"" , get_pool_name ( pool ) ) ; sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = ( unsigned char * ) calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""%s<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , get_pool_name ( pool ) , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""%s<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , get_pool_name ( pool ) , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiating<S2SV_blank>stratum<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; if ( sockd ) { applog ( LOG_DEBUG , ""Suspending<S2SV_blank>stratum<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; suspend_stratum ( pool ) ; } } json_decref ( val ) ; return ret ; }",; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
832,"static MagickBooleanType ReadPSDChannelRLE ( Image * image , const PSDInfo * psd_info , const ssize_t type , MagickOffsetType * sizes , ExceptionInfo * exception ) { MagickBooleanType status ; size_t length , row_size ; ssize_t count , y ; unsigned char * compact_pixels , * pixels ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>RLE<S2SV_blank>compressed"" ) ; row_size = GetPSDRowSize ( image ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( row_size , sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; length = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) if ( ( MagickOffsetType ) length < sizes [ y ] ) length = ( size_t ) sizes [ y ] ; if ( length > row_size + 256 ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowBinaryException ( ResourceLimitError , ""InvalidLength"" , image -> filename ) ; } compact_pixels = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * pixels ) ) ; if ( compact_pixels == ( unsigned char * ) NULL ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } ( void ) ResetMagickMemory ( compact_pixels , 0 , length * sizeof ( * compact_pixels ) ) ; status = MagickTrue ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { status = MagickFalse ; count = ReadBlob ( image , ( size_t ) sizes [ y ] , compact_pixels ) ; if ( count != ( ssize_t ) sizes [ y ] ) break ; count = DecodePSDPixels ( ( size_t ) sizes [ y ] , compact_pixels , ( ssize_t ) ( image -> depth == 1 ? 123456 : image -> depth ) , row_size , pixels ) ; if ( count != ( ssize_t ) row_size ) break ; status = ReadPSDChannelPixels ( image , psd_info -> channels , y , type , pixels , exception ) ; if ( status == MagickFalse ) break ; } compact_pixels = ( unsigned char * ) RelinquishMagickMemory ( compact_pixels ) ; pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; return ( status ) ; }","
"
833,"int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , ""Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\n"" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }",rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;
834,"int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; <S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }",= htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
835,"static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_EndBug> bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( ( MagickSizeType ) length / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"""
836,"static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) { struct path lowerpath ; struct path upperpath ; struct path workpath ; struct inode * root_inode ; struct dentry * root_dentry ; struct ovl_entry * oe ; struct ovl_fs * ufs ; struct kstatfs statfs ; int err ; err = - ENOMEM ; ufs = kzalloc ( sizeof ( struct ovl_fs ) , GFP_KERNEL ) ; if ( ! ufs ) goto out ; err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; if ( err ) goto out_free_config ; err = - EINVAL ; if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || ! ufs -> config . workdir ) { pr_err ( ""overlayfs:<S2SV_blank>missing<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir\\n"" ) ; goto out_free_config ; } err = - ENOMEM ; oe = ovl_alloc_entry ( ) ; if ( oe == NULL ) goto out_free_config ; err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; if ( err ) goto out_free_oe ; err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; if ( err ) goto out_put_upperpath ; err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; if ( err ) goto out_put_lowerpath ; err = - EINVAL ; if ( ! S_ISDIR ( upperpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( lowerpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( workpath . dentry -> d_inode -> i_mode ) ) { pr_err ( ""overlayfs:<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory\\n"" ) ; goto out_put_workpath ; } if ( upperpath . mnt != workpath . mnt ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>reside<S2SV_blank>under<S2SV_blank>the<S2SV_blank>same<S2SV_blank>mount\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>be<S2SV_blank>separate<S2SV_blank>subtrees\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>upperdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { pr_err ( ""overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>lowerdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto out_put_workpath ; } err = vfs_statfs ( & lowerpath , & statfs ) ; if ( err ) { pr_err ( ""overlayfs:<S2SV_blank>statfs<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>lowerpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_namelen = statfs . f_namelen ; <S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> err = PTR_ERR ( ufs -> upper_mnt ) ; if ( IS_ERR ( ufs -> upper_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>upperpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; err = PTR_ERR ( ufs -> lower_mnt ) ; if ( IS_ERR ( ufs -> lower_mnt ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>lowerpath\\n"" ) ; goto out_put_upper_mnt ; } ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; err = PTR_ERR ( ufs -> workdir ) ; if ( IS_ERR ( ufs -> workdir ) ) { pr_err ( ""overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>directory<S2SV_blank>%s/%s\\n"" , ufs -> config . workdir , OVL_WORKDIR_NAME ) ; goto out_put_lower_mnt ; } ufs -> lower_mnt -> mnt_flags |= MNT_READONLY ; if ( ufs -> upper_mnt -> mnt_sb -> s_flags & MS_RDONLY ) sb -> s_flags |= MS_RDONLY ; sb -> s_d_op = & ovl_dentry_operations ; err = - ENOMEM ; root_inode = ovl_new_inode ( sb , S_IFDIR , oe ) ; if ( ! root_inode ) goto out_put_workdir ; root_dentry = d_make_root ( root_inode ) ; if ( ! root_dentry ) goto out_put_workdir ; mntput ( upperpath . mnt ) ; mntput ( lowerpath . mnt ) ; path_put ( & workpath ) ; oe -> __upperdentry = upperpath . dentry ; oe -> lowerdentry = lowerpath . dentry ; root_dentry -> d_fsdata = oe ; sb -> s_magic = OVERLAYFS_SUPER_MAGIC ; sb -> s_op = & ovl_super_operations ; sb -> s_root = root_dentry ; sb -> s_fs_info = ufs ; return 0 ; out_put_workdir : dput ( ufs -> workdir ) ; out_put_lower_mnt : mntput ( ufs -> lower_mnt ) ; out_put_upper_mnt : mntput ( ufs -> upper_mnt ) ; out_put_workpath : path_put ( & workpath ) ; out_put_lowerpath : path_put ( & lowerpath ) ; out_put_upperpath : path_put ( & upperpath ) ; out_free_oe : kfree ( oe ) ; out_free_config : kfree ( ufs -> config . lowerdir ) ; kfree ( ufs -> config . upperdir ) ; kfree ( ufs -> config . workdir ) ; kfree ( ufs ) ; out : return err ; }",". f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; }"
837,"static void down2_symodd ( const uint8_t * const input , int length , uint8_t * output ) { <S2SV_StartBug> static const int16_t * filter = vp9_down2_symodd_half_filter ; <S2SV_EndBug> const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) / 2 ; int i , j ; uint8_t * optr = output ; int l1 = filter_len_half - 1 ; int l2 = ( length - filter_len_half + 1 ) ; l1 += ( l1 & 1 ) ; l2 += ( l2 & 1 ) ; if ( l1 > l2 ) { for ( i = 0 ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ ( i + j >= length ? length - 1 : i + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } else { for ( i = 0 ; i < l1 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ i + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < l2 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ i + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ ( i + j >= length ? length - 1 : i + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } }",output ) { <S2SV_ModEnd> const int16_t *
838,"static int cmd_handle_untagged ( struct ImapData * idata ) { unsigned int count = 0 ; char * s = imap_next_word ( idata -> buf ) ; char * pn = imap_next_word ( s ) ; if ( ( idata -> state >= IMAP_SELECTED ) && isdigit ( ( unsigned char ) * s ) ) { pn = s ; s = imap_next_word ( s ) ; if ( mutt_str_strncasecmp ( ""EXISTS"" , s , 6 ) == 0 ) { mutt_debug ( 2 , ""Handling<S2SV_blank>EXISTS\\n"" ) ; if ( mutt_str_atoui ( pn , & count ) < 0 ) { mutt_debug ( 1 , ""Malformed<S2SV_blank>EXISTS:<S2SV_blank>\'%s\'\\n"" , pn ) ; } if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) && count < idata -> max_msn ) { mutt_debug ( 1 , ""Message<S2SV_blank>count<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>sync\\n"" ) ; return 0 ; } else if ( count == idata -> max_msn ) mutt_debug ( 3 , ""superfluous<S2SV_blank>EXISTS<S2SV_blank>message.\\n"" ) ; else { if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) ) { mutt_debug ( 2 , ""New<S2SV_blank>mail<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>total.\\n"" , idata -> mailbox , count ) ; idata -> reopen |= IMAP_NEWMAIL_PENDING ; } idata -> new_mail_count = count ; } } else if ( mutt_str_strncasecmp ( ""EXPUNGE"" , s , 7 ) == 0 ) cmd_parse_expunge ( idata , pn ) ; else if ( mutt_str_strncasecmp ( ""FETCH"" , s , 5 ) == 0 ) cmd_parse_fetch ( idata , pn ) ; } else if ( mutt_str_strncasecmp ( ""CAPABILITY"" , s , 10 ) == 0 ) cmd_parse_capability ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""OK<S2SV_blank>[CAPABILITY"" , s , 14 ) == 0 ) cmd_parse_capability ( idata , pn ) ; else if ( mutt_str_strncasecmp ( ""OK<S2SV_blank>[CAPABILITY"" , pn , 14 ) == 0 ) cmd_parse_capability ( idata , imap_next_word ( pn ) ) ; else if ( mutt_str_strncasecmp ( ""LIST"" , s , 4 ) == 0 ) cmd_parse_list ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""LSUB"" , s , 4 ) == 0 ) cmd_parse_lsub ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""MYRIGHTS"" , s , 8 ) == 0 ) cmd_parse_myrights ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""SEARCH"" , s , 6 ) == 0 ) cmd_parse_search ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""STATUS"" , s , 6 ) == 0 ) cmd_parse_status ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""ENABLED"" , s , 7 ) == 0 ) cmd_parse_enabled ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""BYE"" , s , 3 ) == 0 ) { mutt_debug ( 2 , ""Handling<S2SV_blank>BYE\\n"" ) ; if ( idata -> status == IMAP_BYE ) return 0 ; s += 3 ; SKIPWS ( s ) ; mutt_error ( ""%s"" , s ) ; cmd_handle_fatal ( idata ) ; return - 1 ; } else if ( ImapServernoise && ( mutt_str_strncasecmp ( ""NO"" , s , 2 ) == 0 ) ) { mutt_debug ( 2 , ""Handling<S2SV_blank>untagged<S2SV_blank>NO\\n"" ) ; <S2SV_StartBug> mutt_error ( ""%s"" , s + 3 ) ; <S2SV_EndBug> } return 0 ; }",", s + 2 <S2SV_ModEnd> ) ; }"
839,"static int init_items ( struct MACH0_ ( obj_t ) * bin ) { struct load_command lc = { 0 , 0 } ; ut8 loadc [ sizeof ( struct load_command ) ] = { 0 } ; bool is_first_thread = true ; ut64 off = 0LL ; int i , len ; bin -> uuidn = 0 ; bin -> os = 0 ; bin -> has_crypto = 0 ; if ( bin -> hdr . sizeofcmds > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>chopping<S2SV_blank>hdr.sizeofcmds\\n"" ) ; bin -> hdr . sizeofcmds = bin -> size - 128 ; } for ( i = 0 , off = sizeof ( struct MACH0_ ( mach_header ) ) ; i < bin -> hdr . ncmds ; i ++ , off += lc . cmdsize ) { if ( off > bin -> size || off + sizeof ( struct load_command ) > bin -> size ) { bprintf ( ""mach0:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>command\\n"" ) ; return false ; } len = r_buf_read_at ( bin -> b , off , loadc , sizeof ( struct load_command ) ) ; if ( len < 1 ) { bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(lc)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; return false ; } lc . cmd = r_read_ble32 ( & loadc [ 0 ] , bin -> big_endian ) ; lc . cmdsize = r_read_ble32 ( & loadc [ 4 ] , bin -> big_endian ) ; if ( lc . cmdsize < 1 || off + lc . cmdsize > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>mach0_header<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>cmdsize<1.\\n"" , i ) ; break ; } sdb_num_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.offset"" , i ) , off , 0 ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.format"" , i ) , ""xd<S2SV_blank>cmd<S2SV_blank>size"" , 0 ) ; switch ( lc . cmd ) { case LC_DATA_IN_CODE : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""data_in_code"" , 0 ) ; break ; case LC_RPATH : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""rpath"" , 0 ) ; break ; case LC_SEGMENT_64 : case LC_SEGMENT : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""segment"" , 0 ) ; bin -> nsegs ++ ; if ( ! parse_segments ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>segment\\n"" ) ; bin -> nsegs -- ; return false ; } break ; case LC_SYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""symtab"" , 0 ) ; if ( ! parse_symtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>symtab\\n"" ) ; return false ; } break ; case LC_DYSYMTAB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dysymtab"" , 0 ) ; if ( ! parse_dysymtab ( bin , off ) ) { bprintf ( ""error<S2SV_blank>parsing<S2SV_blank>dysymtab\\n"" ) ; return false ; } break ; case LC_DYLIB_CODE_SIGN_DRS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib_code_sign_drs"" , 0 ) ; break ; case LC_VERSION_MIN_MACOSX : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_macosx"" , 0 ) ; bin -> os = 1 ; break ; case LC_VERSION_MIN_IPHONEOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_iphoneos"" , 0 ) ; bin -> os = 2 ; break ; case LC_VERSION_MIN_TVOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_tvos"" , 0 ) ; bin -> os = 4 ; break ; case LC_VERSION_MIN_WATCHOS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version_min_watchos"" , 0 ) ; bin -> os = 3 ; break ; case LC_UUID : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""uuid"" , 0 ) ; { struct uuid_command uc = { 0 } ; if ( off + sizeof ( struct uuid_command ) > bin -> size ) { bprintf ( ""UUID<S2SV_blank>out<S2SV_blank>of<S2SV_blank>obunds\\n"" ) ; return false ; } if ( r_buf_fread_at ( bin -> b , off , ( ut8 * ) & uc , ""24c"" , 1 ) != - 1 ) { char key [ 128 ] ; char val [ 128 ] ; snprintf ( key , sizeof ( key ) - 1 , ""uuid.%d"" , bin -> uuidn ++ ) ; r_hex_bin2str ( ( ut8 * ) & uc . uuid , 16 , val ) ; sdb_set ( bin -> kv , key , val , 0 ) ; } } break ; case LC_ENCRYPTION_INFO_64 : case LC_ENCRYPTION_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""encryption_info"" , 0 ) ; { struct MACH0_ ( encryption_info_command ) eic = { 0 } ; ut8 seic [ sizeof ( struct MACH0_ ( encryption_info_command ) ) ] = { 0 } ; if ( off + sizeof ( struct MACH0_ ( encryption_info_command ) ) > bin -> size ) { bprintf ( ""encryption<S2SV_blank>info<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , seic , sizeof ( struct MACH0_ ( encryption_info_command ) ) ) != - 1 ) { eic . cmd = r_read_ble32 ( & seic [ 0 ] , bin -> big_endian ) ; eic . cmdsize = r_read_ble32 ( & seic [ 4 ] , bin -> big_endian ) ; eic . cryptoff = r_read_ble32 ( & seic [ 8 ] , bin -> big_endian ) ; eic . cryptsize = r_read_ble32 ( & seic [ 12 ] , bin -> big_endian ) ; eic . cryptid = r_read_ble32 ( & seic [ 16 ] , bin -> big_endian ) ; bin -> has_crypto = eic . cryptid ; sdb_set ( bin -> kv , ""crypto"" , ""true"" , 0 ) ; sdb_num_set ( bin -> kv , ""cryptid"" , eic . cryptid , 0 ) ; sdb_num_set ( bin -> kv , ""cryptoff"" , eic . cryptoff , 0 ) ; sdb_num_set ( bin -> kv , ""cryptsize"" , eic . cryptsize , 0 ) ; sdb_num_set ( bin -> kv , ""cryptheader"" , off , 0 ) ; } } break ; case LC_LOAD_DYLINKER : { sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylinker"" , 0 ) ; free ( bin -> intrp ) ; bin -> intrp = NULL ; struct dylinker_command dy = { 0 } ; ut8 sdy [ sizeof ( struct dylinker_command ) ] = { 0 } ; if ( off + sizeof ( struct dylinker_command ) > bin -> size ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>parse<S2SV_blank>dylinker<S2SV_blank>command\\n"" ) ; return false ; } if ( r_buf_read_at ( bin -> b , off , sdy , sizeof ( struct dylinker_command ) ) == - 1 ) { bprintf ( ""Warning:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { dy . cmd = r_read_ble32 ( & sdy [ 0 ] , bin -> big_endian ) ; dy . cmdsize = r_read_ble32 ( & sdy [ 4 ] , bin -> big_endian ) ; dy . name = r_read_ble32 ( & sdy [ 8 ] , bin -> big_endian ) ; int len = dy . cmdsize ; char * buf = malloc ( len + 1 ) ; if ( buf ) { r_buf_read_at ( bin -> b , off + 0xc , ( ut8 * ) buf , len ) ; buf [ len ] = 0 ; free ( bin -> intrp ) ; bin -> intrp = buf ; } } } break ; case LC_MAIN : { struct { ut64 eo ; ut64 ss ; } ep = { 0 } ; ut8 sep [ 2 * sizeof ( ut64 ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""main"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_MAIN<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } if ( off + 8 > bin -> size || off + sizeof ( ep ) > bin -> size ) { bprintf ( ""invalid<S2SV_blank>command<S2SV_blank>size<S2SV_blank>for<S2SV_blank>main\\n"" ) ; return false ; } r_buf_read_at ( bin -> b , off + 8 , sep , 2 * sizeof ( ut64 ) ) ; ep . eo = r_read_ble64 ( & sep [ 0 ] , bin -> big_endian ) ; ep . ss = r_read_ble64 ( & sep [ 8 ] , bin -> big_endian ) ; bin -> entry = ep . eo ; bin -> main_cmd = lc ; sdb_num_set ( bin -> kv , ""mach0.entry.offset"" , off + 8 , 0 ) ; sdb_num_set ( bin -> kv , ""stacksize"" , ep . ss , 0 ) ; is_first_thread = false ; } break ; case LC_UNIXTHREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""unixthread"" , 0 ) ; if ( ! is_first_thread ) { bprintf ( ""Error:<S2SV_blank>LC_UNIXTHREAD<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n"" ) ; return false ; } case LC_THREAD : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""thread"" , 0 ) ; if ( ! parse_thread ( bin , & lc , off , is_first_thread ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>thread\\n"" ) ; return false ; } is_first_thread = false ; break ; case LC_LOAD_DYLIB : case LC_LOAD_WEAK_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""load_dylib"" , 0 ) ; bin -> nlibs ++ ; if ( ! parse_dylib ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dylib\\n"" ) ; bin -> nlibs -- ; return false ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { ut8 dyldi [ sizeof ( struct dyld_info_command ) ] = { 0 } ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dyld_info"" , 0 ) ; <S2SV_StartBug> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { <S2SV_EndBug> bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n"" ) ; <S2SV_StartBug> free ( bin -> dyld_info ) ; <S2SV_EndBug> return false ; } if ( r_buf_read_at ( bin -> b , off , dyldi , sizeof ( struct dyld_info_command ) ) == - 1 ) { free ( bin -> dyld_info ) ; bin -> dyld_info = NULL ; bprintf ( ""Error:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , off ) ; } else { bin -> dyld_info -> cmd = r_read_ble32 ( & dyldi [ 0 ] , bin -> big_endian ) ; bin -> dyld_info -> cmdsize = r_read_ble32 ( & dyldi [ 4 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_off = r_read_ble32 ( & dyldi [ 8 ] , bin -> big_endian ) ; bin -> dyld_info -> rebase_size = r_read_ble32 ( & dyldi [ 12 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_off = r_read_ble32 ( & dyldi [ 16 ] , bin -> big_endian ) ; bin -> dyld_info -> bind_size = r_read_ble32 ( & dyldi [ 20 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_off = r_read_ble32 ( & dyldi [ 24 ] , bin -> big_endian ) ; bin -> dyld_info -> weak_bind_size = r_read_ble32 ( & dyldi [ 28 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_off = r_read_ble32 ( & dyldi [ 32 ] , bin -> big_endian ) ; bin -> dyld_info -> lazy_bind_size = r_read_ble32 ( & dyldi [ 36 ] , bin -> big_endian ) ; bin -> dyld_info -> export_off = r_read_ble32 ( & dyldi [ 40 ] , bin -> big_endian ) ; bin -> dyld_info -> export_size = r_read_ble32 ( & dyldi [ 44 ] , bin -> big_endian ) ; } } <S2SV_StartBug> break ; <S2SV_EndBug> case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ; sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""signature"" , 0 ) ; break ; case LC_SOURCE_VERSION : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""version"" , 0 ) ; break ; case LC_SEGMENT_SPLIT_INFO : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""split_info"" , 0 ) ; break ; case LC_FUNCTION_STARTS : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""function_starts"" , 0 ) ; if ( ! parse_function_starts ( bin , off ) ) { bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>LC_FUNCTION_STARTS\\n"" ) ; } break ; case LC_REEXPORT_DYLIB : sdb_set ( bin -> kv , sdb_fmt ( 0 , ""mach0_cmd_%d.cmd"" , i ) , ""dylib"" , 0 ) ; break ; default : break ; } } return true ; }","-> dyld_info = calloc ( 1 , <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ; if ( bin -> dyld_info ) { if ( <S2SV_ModStart> ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n"" ) ; R_FREE <S2SV_ModEnd> ( bin -> <S2SV_ModStart> ; } } }"
840,"static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) { <S2SV_StartBug> int n ; <S2SV_EndBug> int ret ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <S2SV_StartBug> long newbufsize ; <S2SV_EndBug> long newpos ; assert ( buf ) ; assert ( cnt >= 0 ) ; JAS_DBGLOG ( 100 , ( ""mem_write(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , obj , buf , cnt ) ) ; newpos = m -> pos_ + cnt ; if ( newpos > m -> bufsize_ && m -> growable_ ) { newbufsize = m -> bufsize_ ; while ( newbufsize < newpos ) { <S2SV_StartBug> newbufsize <<= 1 ; <S2SV_EndBug> assert ( newbufsize >= 0 ) ; } <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\n"" , m -> bufsize_ , <S2SV_EndBug> newbufsize ) ) ; JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%ul\\n"" , m -> bufsize_ , JAS_CAST ( unsigned long , newbufsize ) ) ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } <S2SV_StartBug> if ( m -> pos_ > m -> len_ ) { <S2SV_EndBug> n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ; if ( n > 0 ) { memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ; m -> len_ += n ; } if ( m -> pos_ != m -> len_ ) { return 0 ; } } n = m -> bufsize_ - m -> pos_ ; ret = JAS_MIN ( n , cnt ) ; if ( ret > 0 ) { memcpy ( & m -> buf_ [ m -> pos_ ] , buf , ret ) ; m -> pos_ += ret ; } if ( m -> pos_ > m -> len_ ) { m -> len_ = m -> pos_ ; } assert ( ret == cnt ) ; return ret ; }","cnt ) { size_t <S2SV_ModEnd> n ; int <S2SV_ModStart> ) obj ; size_t newbufsize ; size_t <S2SV_ModEnd> newpos ; assert <S2SV_ModStart> newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( ""new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n"" ) ) ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> ; } } JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n"" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }"
841,"void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading<S2SV_blank>\\""%s\\""<S2SV_blank>failed\\n"" , name ) ; } } return dllhandle ; }","* dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; }"
842,"static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }",( d ) <S2SV_ModEnd> ; return 0
843,"void vp8_bilinear_predict8x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 ; uint8x8_t d7u8 , d9u8 , d11u8 , d22u8 , d23u8 , d24u8 , d25u8 , d26u8 ; uint8x16_t q1u8 , q2u8 , q3u8 , q4u8 , q5u8 ; uint16x8_t q1u16 , q2u16 , q3u16 , q4u16 ; uint16x8_t q6u16 , q7u16 , q8u16 , q9u16 , q10u16 ; if ( xoffset == 0 ) { d22u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d23u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d24u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d25u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d26u8 = vld1_u8 ( src_ptr ) ; } else { q1u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q2u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q3u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q4u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q5u8 = vld1q_u8 ( src_ptr ) ; <S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ; q7u16 = vmull_u8 ( vget_low_u8 ( q2u8 ) , d0u8 ) ; q8u16 = vmull_u8 ( vget_low_u8 ( q3u8 ) , d0u8 ) ; q9u16 = vmull_u8 ( vget_low_u8 ( q4u8 ) , d0u8 ) ; q10u16 = vmull_u8 ( vget_low_u8 ( q5u8 ) , d0u8 ) ; d3u8 = vext_u8 ( vget_low_u8 ( q1u8 ) , vget_high_u8 ( q1u8 ) , 1 ) ; d5u8 = vext_u8 ( vget_low_u8 ( q2u8 ) , vget_high_u8 ( q2u8 ) , 1 ) ; d7u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 1 ) ; d9u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 1 ) ; d11u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 1 ) ; q6u16 = vmlal_u8 ( q6u16 , d3u8 , d1u8 ) ; q7u16 = vmlal_u8 ( q7u16 , d5u8 , d1u8 ) ; q8u16 = vmlal_u8 ( q8u16 , d7u8 , d1u8 ) ; q9u16 = vmlal_u8 ( q9u16 , d9u8 , d1u8 ) ; q10u16 = vmlal_u8 ( q10u16 , d11u8 , d1u8 ) ; d22u8 = vqrshrn_n_u16 ( q6u16 , 7 ) ; d23u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ; d24u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ; d25u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ; d26u8 = vqrshrn_n_u16 ( q10u16 , 7 ) ; } if ( yoffset == 0 ) { vst1_u8 ( ( uint8_t * ) dst_ptr , d22u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d23u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d24u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d25u8 ) ; } else { d0u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 0 ] ) ; d1u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 1 ] ) ; q1u16 = vmull_u8 ( d22u8 , d0u8 ) ; q2u16 = vmull_u8 ( d23u8 , d0u8 ) ; q3u16 = vmull_u8 ( d24u8 , d0u8 ) ; q4u16 = vmull_u8 ( d25u8 , d0u8 ) ; q1u16 = vmlal_u8 ( q1u16 , d23u8 , d1u8 ) ; q2u16 = vmlal_u8 ( q2u16 , d24u8 , d1u8 ) ; q3u16 = vmlal_u8 ( q3u16 , d25u8 , d1u8 ) ; q4u16 = vmlal_u8 ( q4u16 , d26u8 , d1u8 ) ; d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ; d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ; d4u8 = vqrshrn_n_u16 ( q3u16 , 7 ) ; d5u8 = vqrshrn_n_u16 ( q4u16 , 7 ) ; vst1_u8 ( ( uint8_t * ) dst_ptr , d2u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d3u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d4u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d5u8 ) ; } return ; }",= vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset <S2SV_ModStart> = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset
844,"void dump_global_data ( FILE * fp , data_t * data ) { # ifdef _WITH_VRRP_ char buf [ 64 ] ; # endif if ( ! data ) return ; conf_write ( fp , ""------<<S2SV_blank>Global<S2SV_blank>definitions<S2SV_blank>>------"" ) ; # if HAVE_DECL_CLONE_NEWNET conf_write ( fp , ""<S2SV_blank>Network<S2SV_blank>namespace<S2SV_blank>=<S2SV_blank>%s"" , data -> network_namespace ? data -> network_namespace : ""(default)"" ) ; # endif if ( data -> instance_name ) conf_write ( fp , ""<S2SV_blank>Instance<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> instance_name ) ; if ( data -> router_id ) conf_write ( fp , ""<S2SV_blank>Router<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%s"" , data -> router_id ) ; if ( data -> smtp_server . ss_family ) { conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( & data -> smtp_server ) ) ; conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%u"" , ntohs ( inet_sockaddrport ( & data -> smtp_server ) ) ) ; } if ( data -> smtp_helo_name ) conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>HELO<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_helo_name ) ; if ( data -> smtp_connection_to ) conf_write ( fp , ""<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>connection<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%lu"" , data -> smtp_connection_to / TIMER_HZ ) ; if ( data -> email_from ) { conf_write ( fp , ""<S2SV_blank>Email<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>=<S2SV_blank>%s"" , data -> email_from ) ; dump_list ( fp , data -> email ) ; } conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert == - 1 ? ""unset"" : data -> smtp_alert ? ""on"" : ""off"" ) ; # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert_vrrp<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert_vrrp == - 1 ? ""unset"" : data -> smtp_alert_vrrp ? ""on"" : ""off"" ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>smtp_alert_checker<S2SV_blank>=<S2SV_blank>%s"" , data -> smtp_alert_checker == - 1 ? ""unset"" : data -> smtp_alert_checker ? ""on"" : ""off"" ) ; # endif # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>Dynamic<S2SV_blank>interfaces<S2SV_blank>=<S2SV_blank>%s"" , data -> dynamic_interfaces ? ""true"" : ""false"" ) ; if ( data -> dynamic_interfaces ) conf_write ( fp , ""<S2SV_blank>Allow<S2SV_blank>interface<S2SV_blank>changes<S2SV_blank>=<S2SV_blank>%s"" , data -> allow_if_changes ? ""true"" : ""false"" ) ; if ( data -> no_email_faults ) conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>emails<S2SV_blank>for<S2SV_blank>fault<S2SV_blank>transitions<S2SV_blank>=<S2SV_blank>off"" ) ; # endif # ifdef _WITH_LVS_ if ( data -> lvs_tcp_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_tcp_timeout ) ; if ( data -> lvs_tcpfin_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>FIN<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_tcpfin_timeout ) ; if ( data -> lvs_udp_timeout ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_udp_timeout ) ; # ifdef _WITH_VRRP_ # ifndef _DEBUG_ if ( prog_type == PROG_TYPE_VRRP ) # endif conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s"" , data -> default_ifp ? data -> default_ifp -> ifname : DFLT_INT ) ; if ( data -> lvs_syncd . vrrp ) { conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>vrrp<S2SV_blank>instance<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_syncd . vrrp -> iname ) ; if ( data -> lvs_syncd . ifname ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_syncd . ifname ) ; conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>syncid<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . syncid ) ; # ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_ if ( data -> lvs_syncd . sync_maxlen ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>maxlen<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . sync_maxlen ) ; if ( data -> lvs_syncd . mcast_group . ss_family != AF_UNSPEC ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>%s"" , inet_sockaddrtos ( & data -> lvs_syncd . mcast_group ) ) ; if ( data -> lvs_syncd . mcast_port ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%d"" , data -> lvs_syncd . mcast_port ) ; if ( data -> lvs_syncd . mcast_ttl ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>ttl<S2SV_blank>=<S2SV_blank>%u"" , data -> lvs_syncd . mcast_ttl ) ; # endif } # endif conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>flush<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_flush ? ""true"" : ""false"" ) ; # endif if ( data -> notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> notify_fifo . name ) ; if ( data -> notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> notify_fifo . script ) , data -> notify_fifo . script -> uid , data -> notify_fifo . script -> gid ) ; } # ifdef _WITH_VRRP_ if ( data -> vrrp_notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_notify_fifo . name ) ; if ( data -> vrrp_notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> vrrp_notify_fifo . script ) , data -> vrrp_notify_fifo . script -> uid , data -> vrrp_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_LVS_ if ( data -> lvs_notify_fifo . name ) { conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s"" , data -> lvs_notify_fifo . name ) ; if ( data -> lvs_notify_fifo . script ) conf_write ( fp , ""<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , cmd_str ( data -> lvs_notify_fifo . script ) , data -> lvs_notify_fifo . script -> uid , data -> lvs_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_VRRP_ if ( data -> vrrp_mcast_group4 . sin_family ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>IPv4<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group4 ) ) ; } if ( data -> vrrp_mcast_group6 . sin6_family ) { conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>IPv6<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s"" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group6 ) ) ; } conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_garp_delay / TIMER_HZ ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_garp_rep ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>timer<S2SV_blank>=<S2SV_blank>%lu"" , data -> vrrp_garp_refresh . tv_sec ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_refresh_rep ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data -> vrrp_garp_lower_prio_delay / TIMER_HZ ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_lower_prio_rep ) ; conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_lower_prio_no_advert ? ""false"" : ""true"" ) ; conf_write ( fp , ""<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>higher<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_higher_prio_send_advert ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_garp_interval ) ; conf_write ( fp , ""<S2SV_blank>Gratuitous<S2SV_blank>NA<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_gna_interval ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>default<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_version ) ; if ( data -> vrrp_iptables_inchain [ 0 ] ) conf_write ( fp , ""<S2SV_blank>Iptables<S2SV_blank>input<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_iptables_inchain ) ; if ( data -> vrrp_iptables_outchain [ 0 ] ) conf_write ( fp , ""<S2SV_blank>Iptables<S2SV_blank>output<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_iptables_outchain ) ; # ifdef _HAVE_LIBIPSET_ conf_write ( fp , ""<S2SV_blank>Using<S2SV_blank>ipsets<S2SV_blank>=<S2SV_blank>%s"" , data -> using_ipsets ? ""true"" : ""false"" ) ; if ( data -> vrrp_ipset_address [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address ) ; if ( data -> vrrp_ipset_address6 [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address6 ) ; if ( data -> vrrp_ipset_address_iface6 [ 0 ] ) conf_write ( fp , ""<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address,iface<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_ipset_address_iface6 ) ; # endif conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>check<S2SV_blank>unicast_src<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_check_unicast_src ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>skip<S2SV_blank>check<S2SV_blank>advert<S2SV_blank>addresses<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_skip_check_adv_addr ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>strict<S2SV_blank>mode<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_strict ? ""true"" : ""false"" ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> vrrp_process_priority ) ; conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> vrrp_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> vrrp_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> vrrp_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> checker_process_priority ) ; conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> checker_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> checker_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> checker_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_BFD_ conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d"" , data -> bfd_process_priority ) ; conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s"" , data -> bfd_no_swap ? ""true"" : ""false"" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u"" , data -> bfd_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , ""<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu"" , data -> bfd_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_SNMP_VRRP_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>vrrp<S2SV_blank>%s"" , data -> enable_snmp_vrrp ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_CHECKER_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>checker<S2SV_blank>%s"" , data -> enable_snmp_checker ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_RFCV2_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>RFCv2<S2SV_blank>%s"" , data -> enable_snmp_rfcv2 ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_RFCV3_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>RFCv3<S2SV_blank>%s"" , data -> enable_snmp_rfcv3 ? ""enabled"" : ""disabled"" ) ; # endif # ifdef _WITH_SNMP_ conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>traps<S2SV_blank>%s"" , data -> enable_traps ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>SNMP<S2SV_blank>socket<S2SV_blank>=<S2SV_blank>%s"" , data -> snmp_socket ? data -> snmp_socket : ""default<S2SV_blank>(unix:/var/agentx/master)"" ) ; # endif # ifdef _WITH_DBUS_ conf_write ( fp , ""<S2SV_blank>DBus<S2SV_blank>%s"" , data -> enable_dbus ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>DBus<S2SV_blank>service<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s"" , data -> dbus_service_name ? data -> dbus_service_name : """" ) ; # endif conf_write ( fp , ""<S2SV_blank>Script<S2SV_blank>security<S2SV_blank>%s"" , script_security ? ""enabled"" : ""disabled"" ) ; conf_write ( fp , ""<S2SV_blank>Default<S2SV_blank>script<S2SV_blank>uid:gid<S2SV_blank>%d:%d"" , default_script_uid , default_script_gid ) ; # ifdef _WITH_VRRP_ conf_write ( fp , ""<S2SV_blank>vrrp_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_cmd_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_monitor_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>vrrp_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_netlink_monitor_rcv_bufs_force ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , ""<S2SV_blank>lvs_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_cmd_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_monitor_rcv_bufs ) ; conf_write ( fp , ""<S2SV_blank>lvs_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u"" , global_data -> lvs_netlink_monitor_rcv_bufs_force ) ; conf_write ( fp , ""<S2SV_blank>rs_init_notifies<S2SV_blank>=<S2SV_blank>%u"" , global_data -> rs_init_notifies ) ; conf_write ( fp , ""<S2SV_blank>no_checker_emails<S2SV_blank>=<S2SV_blank>%u"" , global_data -> no_checker_emails ) ; # endif # ifdef _WITH_VRRP_ buf [ 0 ] = '\\0' ; if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU ) strcpy ( buf , ""<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>MTU"" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT ) strcpy ( buf , ""<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>ADVERT"" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_SIZE ) sprintf ( buf , ""<S2SV_blank>rx_bufs_size<S2SV_blank>=<S2SV_blank>%lu"" , global_data -> vrrp_rx_bufs_size ) ; if ( buf [ 0 ] ) conf_write ( fp , ""%s"" , buf ) ; conf_write ( fp , ""<S2SV_blank>rx_bufs_multiples<S2SV_blank>=<S2SV_blank>%u"" , global_data -> vrrp_rx_bufs_multiples ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }","vrrp_rx_bufs_multiples ) ; conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ;"
845,"long video_ioctl2 ( struct file * file , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> void * mbuf = NULL ; void * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug> if ( err == - ENOIOCTLCMD ) err = - EINVAL ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : switch ( _IOC_DIR ( cmd ) ) { case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ; break ; } out : kfree ( mbuf ) ; return err ; }","arg ) { return video_usercopy <S2SV_ModEnd> ( file , <S2SV_ModStart> , cmd , arg , __video_do_ioctl ) <S2SV_ModEnd> ; } <S2SV_null>"
846,static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; tok -> level = 0 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif <S2SV_StartBug> return tok ; <S2SV_EndBug> },; # endif tok -> type_comments = 0 ;
847,"static int check_ptr_alignment ( struct bpf_verifier_env * env , const struct bpf_reg_state * reg , int off , int size ) { bool strict = env -> strict_alignment ; const char * pointer_desc = """" ; switch ( reg -> type ) { case PTR_TO_PACKET : case PTR_TO_PACKET_META : return check_pkt_ptr_alignment ( env , reg , off , size , strict ) ; case PTR_TO_MAP_VALUE : pointer_desc = ""value<S2SV_blank>"" ; break ; case PTR_TO_CTX : pointer_desc = ""context<S2SV_blank>"" ; break ; case PTR_TO_STACK : pointer_desc = ""stack<S2SV_blank>"" ; <S2SV_StartBug> break ; <S2SV_EndBug> default : break ; } return check_generic_ptr_alignment ( env , reg , pointer_desc , off , size , strict ) ; }","= ""stack<S2SV_blank>"" ; strict = true ;"
848,"<S2SV_StartBug> static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) { <S2SV_EndBug> int i , j ; for ( i = 0 ; i < INTER_MODE_CONTEXTS ; ++ i ) for ( j = 0 ; j < INTER_MODES - 1 ; ++ j ) vp9_diff_update_prob ( r , & fc -> inter_mode_probs [ i ] [ j ] ) ; }","* fc , vpx_reader <S2SV_ModEnd> * r )"
849,"<S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> BLOCK_SIZE * min_block_size , <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int sb_width_in_blocks = MI_BLOCK_SIZE ; int sb_height_in_blocks = MI_BLOCK_SIZE ; int i , j ; int index = 0 ; for ( i = 0 ; i < sb_height_in_blocks ; ++ i ) { for ( j = 0 ; j < sb_width_in_blocks ; ++ j ) { MODE_INFO * mi = mi_8x8 [ index + j ] ; BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ; <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug> * max_block_size = MAX ( * max_block_size , sb_type ) ; } index += xd -> mi_stride ; } }","void get_sb_partition_size_range ( MACROBLOCKD * xd <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) { <S2SV_ModEnd> int sb_width_in_blocks = <S2SV_ModStart> : 0 ; bs_hist [ sb_type ] ++ ;"
850,"static int skcipher_accept_parent ( void * private , struct sock * sk ) { struct skcipher_ctx * ctx ; struct alg_sock * ask = alg_sk ( sk ) ; <S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> GFP_KERNEL ) ; if ( ! ctx -> iv ) { sock_kfree_s ( sk , ctx , len ) ; return - ENOMEM ; } <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug> skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ; sk -> sk_destruct = skcipher_sock_destruct ; return 0 ; }","sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback"
851,"static void srpt_handle_tsk_mgmt ( struct srpt_rdma_ch * ch , struct srpt_recv_ioctx * recv_ioctx , struct srpt_send_ioctx * send_ioctx ) { struct srp_tsk_mgmt * srp_tsk ; struct se_cmd * cmd ; struct se_session * sess = ch -> sess ; uint64_t unpacked_lun ; <S2SV_StartBug> uint32_t tag = 0 ; <S2SV_EndBug> int tcm_tmr ; int rc ; BUG_ON ( ! send_ioctx ) ; srp_tsk = recv_ioctx -> ioctx . buf ; cmd = & send_ioctx -> cmd ; pr_debug ( ""recv<S2SV_blank>tsk_mgmt<S2SV_blank>fn<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>task_tag<S2SV_blank>%lld<S2SV_blank>and<S2SV_blank>cmd<S2SV_blank>tag<S2SV_blank>%lld"" ""<S2SV_blank>cm_id<S2SV_blank>%p<S2SV_blank>sess<S2SV_blank>%p\\n"" , srp_tsk -> tsk_mgmt_func , srp_tsk -> task_tag , srp_tsk -> tag , ch -> cm_id , ch -> sess ) ; srpt_set_cmd_state ( send_ioctx , SRPT_STATE_MGMT ) ; send_ioctx -> cmd . tag = srp_tsk -> tag ; tcm_tmr = srp_tmr_to_tcm ( srp_tsk -> tsk_mgmt_func ) ; <S2SV_StartBug> if ( tcm_tmr < 0 ) { <S2SV_EndBug> send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ; goto fail ; } unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) { <S2SV_StartBug> rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; <S2SV_EndBug> if ( rc < 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_DOES_NOT_EXIST ; goto fail ; } tag = srp_tsk -> task_tag ; } rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ; if ( rc != 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_FUNCTION_REJECTED ; goto fail ; } return ; fail : transport_send_check_condition_and_sense ( cmd , 0 , 0 ) ; }","uint64_t unpacked_lun ; <S2SV_ModEnd> int tcm_tmr ; <S2SV_ModStart> tsk_mgmt_func ) ; unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> , srp_tsk -> <S2SV_ModStart> srp_tsk -> task_tag <S2SV_ModEnd> , TARGET_SCF_ACK_KREF )"
852,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { struct common_audit_data sa ; struct apparmor_audit_data aad = { 0 , } ; <S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> size_t arg_size ; int error ; if ( size == 0 ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( args [ size - 1 ] != '\\0' ) { <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; else goto fail ; <S2SV_StartBug> } else <S2SV_EndBug> return - EINVAL ; if ( ! error ) error = size ; return error ; fail : sa . type = LSM_AUDIT_DATA_NONE ; sa . aad = & aad ; aad . profile = aa_current_profile ( ) ; aad . op = OP_SETPROCATTR ; aad . info = name ; <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> }","command , * largs = NULL , * <S2SV_ModStart> return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> EINVAL ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ( name , ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> , ! AA_DO_TEST <S2SV_ModStart> AA_DO_TEST ) ; <S2SV_ModEnd> else goto fail <S2SV_ModStart> ; } else <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error <S2SV_ModStart> . error = error = <S2SV_ModStart> NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>"
