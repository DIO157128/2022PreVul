,source,target
0,"CWE-276 static int rawsock_create ( struct net * net , struct socket * sock , const struct nfc_protocol * nfc_proto , int kern ) { struct sock * sk ; pr_debug ( ""sock=%p\\n"" , sock ) ; if ( ( sock -> type != SOCK_SEQPACKET ) && ( sock -> type != SOCK_RAW ) ) return - ESOCKTNOSUPPORT ;  if ( sock -> type == SOCK_RAW )  sock -> ops = & rawsock_raw_ops ;  else   sock -> ops = & rawsock_ops ;  sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ; if ( ! sk ) return - ENOMEM ; sock_init_data ( sock , sk ) ; sk -> sk_protocol = nfc_proto -> id ; sk -> sk_destruct = rawsock_destruct ; sock -> state = SS_UNCONNECTED ; if ( sock -> type == SOCK_RAW ) nfc_sock_link ( & raw_sk_list , sk ) ; else { INIT_WORK ( & nfc_rawsock ( sk ) -> tx_work , rawsock_tx_work ) ; nfc_rawsock ( sk ) -> tx_work_scheduled = false ; } return 0 ; }", == SOCK_RAW ) { if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ;  & rawsock_raw_ops ; } else {  sock -> ops  & rawsock_ops ; }
1,"CWE-732 int sandbox ( void * sandbox_arg ) { ( void ) sandbox_arg ; pid_t child_pid = getpid ( ) ; if ( arg_debug ) printf ( ""Initializingchildprocess\\n"" ) ; close ( parent_to_child_fds [ 1 ] ) ; close ( child_to_parent_fds [ 0 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; if ( arg_debug && child_pid == 1 ) printf ( ""PIDnamespaceinstalled\\n"" ) ; if ( cfg . hostname ) { if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( ""sethostname"" ) ; } if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { chk_chroot ( ) ; } preproc_mount_mnt_dir ( ) ; if ( mount ( LIBDIR ""/firejail"" , RUN_FIREJAIL_LIB_DIR , ""none"" , MS_BIND , NULL ) < 0 ) errExit ( ""mounting"" RUN_FIREJAIL_LIB_DIR ) ; if ( cfg . name ) fs_logger2 ( ""sandboxname:"" , cfg . name ) ; fs_logger2int ( ""sandboxpid:"" , ( int ) sandbox_pid ) ; if ( cfg . chrootdir ) fs_logger ( ""sandboxfilesystem:chroot"" ) ; else if ( arg_overlay ) fs_logger ( ""sandboxfilesystem:overlay"" ) ; else fs_logger ( ""sandboxfilesystem:local"" ) ; fs_logger ( ""installmountnamespace"" ) ; if ( arg_netfilter && any_bridge_configured ( ) ) { netfilter ( arg_netfilter_file ) ; } if ( arg_netfilter6 && any_bridge_configured ( ) ) { netfilter6 ( arg_netfilter6_file ) ; } int gw_cfg_failed = 0 ; if ( arg_nonetwork ) { net_if_up ( ""lo"" ) ; if ( arg_debug ) printf ( ""Networknamespaceenabled,onlyloopbackinterfaceavailable\\n"" ) ; } else if ( arg_netns ) { netns ( arg_netns ) ; if ( arg_debug ) printf ( ""Networknamespace\'%s\'activated\\n"" , arg_netns ) ; } else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { net_if_up ( ""lo"" ) ; if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ; sandbox_if_up ( & cfg . bridge0 ) ; if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ; sandbox_if_up ( & cfg . bridge1 ) ; if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ; sandbox_if_up ( & cfg . bridge2 ) ; if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ; sandbox_if_up ( & cfg . bridge3 ) ; if ( cfg . interface0 . configured && cfg . interface0 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface0 . ip ) , cfg . interface0 . dev ) ; net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ; } if ( cfg . interface1 . configured && cfg . interface1 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface1 . ip ) , cfg . interface1 . dev ) ; net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ; } if ( cfg . interface2 . configured && cfg . interface2 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface2 . ip ) , cfg . interface2 . dev ) ; net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ; } if ( cfg . interface3 . configured && cfg . interface3 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface3 . ip ) , cfg . interface3 . dev ) ; net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ; } if ( cfg . defaultgw ) { if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) { fwarning ( ""cannotconfiguredefaultroute\\n"" ) ; gw_cfg_failed = 1 ; } } if ( arg_debug ) printf ( ""Networknamespaceenabled\\n"" ) ; } if ( ! arg_quiet ) { if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) { fmessage ( ""\\n"" ) ; if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , ""printif"" , ""scan"" ) ; else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , ""printif"" ) ; } if ( cfg . defaultgw != 0 ) { if ( gw_cfg_failed ) fmessage ( ""Defaultgatewayconfigurationfailed\\n"" ) ; else fmessage ( ""Defaultgateway%d.%d.%d.%d\\n"" , PRINT_IP ( cfg . defaultgw ) ) ; } if ( cfg . dns1 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns1 ) ; if ( cfg . dns2 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns2 ) ; if ( cfg . dns3 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns3 ) ; if ( cfg . dns4 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns4 ) ; fmessage ( ""\\n"" ) ; } } if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) { } else { EUID_USER ( ) ; env_ibus_load ( ) ; EUID_ROOT ( ) ; } # ifdef HAVE_SECCOMP if ( cfg . protocol ) { if ( arg_debug ) printf ( ""Buildprotocolfilter:%s\\n"" , cfg . protocol ) ; int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , ""protocol"" , ""build"" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ; if ( rv ) exit ( rv ) ; } if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ; # endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ; if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) { enforce_filters ( ) ; need_preload = arg_trace || arg_tracelog ; } if ( need_preload ) fs_trace_preload ( ) ; if ( cfg . hosts_file ) fs_store_hosts_file ( ) ; # ifdef HAVE_CHROOT if ( cfg . chrootdir ) { fs_chroot ( cfg . chrootdir ) ; if ( need_preload ) fs_trace_preload ( ) ; } else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ; else # endif fs_basic_fs ( ) ; if ( arg_private ) { if ( cfg . home_private ) { if ( cfg . chrootdir ) fwarning ( ""private=directoryfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private=directoryfeatureisdisabledinoverlay\\n"" ) ; else fs_private_homedir ( ) ; } else if ( cfg . home_private_keep ) { if ( cfg . chrootdir ) fwarning ( ""private-home=featureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-home=featureisdisabledinoverlay\\n"" ) ; else fs_private_home_list ( ) ; } else fs_private ( ) ; } if ( arg_private_dev ) fs_private_dev ( ) ; if ( arg_private_etc ) { if ( cfg . chrootdir ) fwarning ( ""private-etcfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-etcfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_dir_list ( ""/etc"" , RUN_ETC_DIR , cfg . etc_private_keep ) ; if ( need_preload ) fs_trace_preload ( ) ; } } if ( arg_private_opt ) { if ( cfg . chrootdir ) fwarning ( ""private-optfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-optfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_dir_list ( ""/opt"" , RUN_OPT_DIR , cfg . opt_private_keep ) ; } } if ( arg_private_srv ) { if ( cfg . chrootdir ) fwarning ( ""private-srvfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-srvfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_dir_list ( ""/srv"" , RUN_SRV_DIR , cfg . srv_private_keep ) ; } } if ( arg_private_bin && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( ""private-binfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-binfeatureisdisabledinoverlay\\n"" ) ; else { if ( arg_x11_xorg ) { EUID_USER ( ) ; char * tmp ; if ( asprintf ( & tmp , ""%s,xauth"" , cfg . bin_private_keep ) == - 1 ) errExit ( ""asprintf"" ) ; cfg . bin_private_keep = tmp ; EUID_ROOT ( ) ; } fs_private_bin_list ( ) ; } } if ( arg_private_lib && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( ""private-libfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-libfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_lib ( ) ; } } if ( arg_private_cache ) { if ( cfg . chrootdir ) fwarning ( ""private-cachefeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-cachefeatureisdisabledinoverlay\\n"" ) ; else fs_private_cache ( ) ; } if ( arg_private_tmp ) { EUID_USER ( ) ; fs_private_tmp ( ) ; EUID_ROOT ( ) ; } if ( arg_nodbus ) dbus_session_disable ( ) ; if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ; if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ; if ( arg_netns ) netns_mounts ( arg_netns ) ; fs_proc_sys_dev_boot ( ) ; if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ; else if ( arg_disable_mnt ) fs_mnt ( 0 ) ; fs_whitelist ( ) ; fs_blacklist ( ) ; if ( arg_nosound ) { pulseaudio_disable ( ) ; fs_dev_disable_sound ( ) ; } else if ( ! arg_noautopulse ) pulseaudio_init ( ) ; if ( arg_no3d ) fs_dev_disable_3d ( ) ; if ( arg_notv ) fs_dev_disable_tv ( ) ; if ( arg_nodvd ) fs_dev_disable_dvd ( ) ; if ( arg_nou2f ) fs_dev_disable_u2f ( ) ; if ( arg_novideo ) fs_dev_disable_video ( ) ; if ( need_preload ) fs_trace ( ) ; fs_resolvconf ( ) ; fs_logger_print ( ) ; fs_logger_change_owner ( ) ; EUID_USER ( ) ; int cwd = 0 ; if ( cfg . cwd ) { if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ; } if ( ! cwd ) { if ( chdir ( ""/"" ) < 0 ) errExit ( ""chdir"" ) ; if ( cfg . homedir ) { struct stat s ; if ( stat ( cfg . homedir , & s ) == 0 ) { if ( chdir ( cfg . homedir ) < 0 ) errExit ( ""chdir"" ) ; } } } if ( arg_debug ) { char * cpath = get_current_dir_name ( ) ; if ( cpath ) { printf ( ""Currentdirectory:%s\\n"" , cpath ) ; free ( cpath ) ; } } EUID_ROOT ( ) ; fs_x11 ( ) ; if ( arg_x11_xorg ) x11_xorg ( ) ; save_umask ( ) ; save_nonewprivs ( ) ;  set_caps ( ) ;  save_cpu ( ) ; save_cgroup ( ) ; # ifdef HAVE_SECCOMP # ifdef SYS_socket if ( cfg . protocol ) { if ( arg_debug ) printf ( ""Installprotocolfilter:%s\\n"" , cfg . protocol ) ; seccomp_load ( RUN_SECCOMP_PROTOCOL ) ; protocol_filter_save ( ) ; } else { int rv = unlink ( RUN_SECCOMP_PROTOCOL ) ; ( void ) rv ; } # endif if ( arg_seccomp == 1 ) { if ( cfg . seccomp_list_keep ) seccomp_filter_keep ( ) ; else seccomp_filter_drop ( ) ; } else { int rv = unlink ( RUN_SECCOMP_CFG ) ; rv |= unlink ( RUN_SECCOMP_32 ) ; ( void ) rv ; } if ( arg_memory_deny_write_execute ) { if ( arg_debug ) printf ( ""Installmemorywrite&executefilter\\n"" ) ; seccomp_load ( RUN_SECCOMP_MDWX ) ; } else { int rv = unlink ( RUN_SECCOMP_MDWX ) ; ( void ) rv ; }  # endif  FILE * rj = create_ready_for_join_file ( ) ; save_nogroups ( ) ; if ( arg_noroot ) { int rv = unshare ( CLONE_NEWUSER ) ; if ( rv == - 1 ) { fwarning ( ""cannotcreateanewusernamespace,goingforwardwithoutit...\\n"" ) ; arg_noroot = 0 ; } } notify_other ( child_to_parent_fds [ 1 ] ) ; close ( child_to_parent_fds [ 1 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; close ( parent_to_child_fds [ 0 ] ) ; if ( arg_noroot ) { if ( arg_debug ) printf ( ""norootusernamespaceinstalled\\n"" ) ; set_caps ( ) ; } if ( arg_nonewprivs ) { prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) ; if ( prctl ( PR_GET_NO_NEW_PRIVS , 0 , 0 , 0 , 0 ) != 1 ) { fwarning ( ""cannotsetNO_NEW_PRIVS,itrequiresaLinuxkernelversion3.5ornewer.\\n"" ) ; if ( force_nonewprivs ) { fprintf ( stderr , ""Error:NO_NEW_PRIVSrequiredforthissandbox,exiting...\\n"" ) ; exit ( 1 ) ; } } else if ( arg_debug ) printf ( ""NO_NEW_PRIVSset\\n"" ) ; } drop_privs ( arg_nogroups ) ; prctl ( PR_SET_PDEATHSIG , SIGKILL , 0 , 0 , 0 ) ; if ( cfg . cpus ) set_cpu_affinity ( ) ; pid_t app_pid = fork ( ) ; if ( app_pid == - 1 ) errExit ( ""fork"" ) ; if ( app_pid == 0 ) { # ifdef HAVE_APPARMOR if ( checkcfg ( CFG_APPARMOR ) && arg_apparmor ) { errno = 0 ; if ( aa_change_onexec ( ""firejail-default"" ) ) { fwarning ( ""CannotconfinetheapplicationusingAppArmor.\\n"" ""Maybefirejail-defaultAppArmorprofileisnotloadedintothekernel.\\n"" ""Asroot,run\\""aa-enforcefirejail-default\\""toloadit.\\n"" ) ; } else if ( arg_debug ) printf ( ""AppArmorenabled\\n"" ) ; } # endif if ( arg_nice ) set_nice ( cfg . nice ) ; set_rlimits ( ) ; start_application ( 0 , rj ) ; } fclose ( rj ) ; int status = monitor_application ( app_pid ) ; flush_stdin ( ) ; if ( WIFEXITED ( status ) ) { return WEXITSTATUS ( status ) ; } else { return - 1 ; } }", ( ) ;  save_cpu ( )  rv ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ;  FILE * rj
2,"CWE-369 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps ) { return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; }  siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;  siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }"," 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalidXRsizvalue%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalidYRsizvalue%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }"
3,"CWE-476 static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ;  if ( ( temp_buffer & 0xffffff00 ) != 0x100 )  continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;  else if ( temp_buffer < 0x120 )  VO ++ ;  else if ( temp_buffer < 0x130 )  VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }", ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2  ) continue ;  if ( temp_buffer >= 0x100 && temp_buffer  else if ( temp_buffer >= 0x120 &&
4,"CWE-78 static char_u * do_one_cmd ( char_u * * cmdlinep , int sourcing , # ifdef FEAT_EVAL struct condstack * cstack , # endif char_u * ( * fgetline ) ( int , void * , int ) , void * cookie ) { char_u * p ; linenr_T lnum ; long n ; char * errormsg = NULL ; char_u * after_modifier = NULL ; exarg_T ea ; int save_msg_scroll = msg_scroll ; cmdmod_T save_cmdmod ; int ni ; char_u * cmd ; vim_memset ( & ea , 0 , sizeof ( ea ) ) ; ea . line1 = 1 ; ea . line2 = 1 ; # ifdef FEAT_EVAL ++ ex_nesting_level ; # endif if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ; save_cmdmod = cmdmod ; if ( ( * cmdlinep ) [ 0 ] == '#' && ( * cmdlinep ) [ 1 ] == '!' ) goto doend ; ea . cmd = * cmdlinep ; ea . cmdlinep = cmdlinep ; ea . getline = fgetline ; ea . cookie = cookie ; # ifdef FEAT_EVAL ea . cstack = cstack ; # endif if ( parse_command_modifiers ( & ea , & errormsg , FALSE ) == FAIL ) goto doend ; after_modifier = ea . cmd ; # ifdef FEAT_EVAL ea . skip = did_emsg || got_int || did_throw || ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_ACTIVE ) ) ; # else ea . skip = ( if_level > 0 ) ; # endif cmd = ea . cmd ; ea . cmd = skip_range ( ea . cmd , NULL ) ; if ( * ea . cmd == '*' && vim_strchr ( p_cpo , CPO_STAR ) == NULL ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; p = find_command ( & ea , NULL ) ; # ifdef FEAT_EVAL # ifdef FEAT_PROFILE if ( do_profiling == PROF_YES && ( ! ea . skip || cstack -> cs_idx == 0 || ( cstack -> cs_idx > 0 && ( cstack -> cs_flags [ cstack -> cs_idx - 1 ] & CSF_ACTIVE ) ) ) ) { int skip = did_emsg || got_int || did_throw ; if ( ea . cmdidx == CMD_catch ) skip = ! skip && ! ( cstack -> cs_idx >= 0 && ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_THROWN ) && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & CSF_CAUGHT ) ) ; else if ( ea . cmdidx == CMD_else || ea . cmdidx == CMD_elseif ) skip = skip || ! ( cstack -> cs_idx >= 0 && ! ( cstack -> cs_flags [ cstack -> cs_idx ] & ( CSF_ACTIVE | CSF_TRUE ) ) ) ; else if ( ea . cmdidx == CMD_finally ) skip = FALSE ; else if ( ea . cmdidx != CMD_endif && ea . cmdidx != CMD_endfor && ea . cmdidx != CMD_endtry && ea . cmdidx != CMD_endwhile ) skip = ea . skip ; if ( ! skip ) { if ( getline_equal ( fgetline , cookie , get_func_line ) ) func_line_exec ( getline_cookie ( fgetline , cookie ) ) ; else if ( getline_equal ( fgetline , cookie , getsourceline ) ) script_line_exec ( ) ; } } # endif dbg_check_breakpoint ( & ea ) ; if ( ! ea . skip && got_int ) { ea . skip = TRUE ; ( void ) do_intthrow ( cstack ) ; } # endif if ( ! IS_USER_CMDIDX ( ea . cmdidx ) ) { if ( ea . cmdidx != CMD_SIZE ) ea . addr_type = cmdnames [ ( int ) ea . cmdidx ] . cmd_addr_type ; else ea . addr_type = ADDR_LINES ; if ( ea . cmdidx == CMD_wincmd && p != NULL ) get_wincmd_addr_type ( skipwhite ( p ) , & ea ) ; } ea . cmd = cmd ; if ( parse_cmd_address ( & ea , & errormsg , FALSE ) == FAIL ) goto doend ; ea . cmd = skipwhite ( ea . cmd ) ; while ( * ea . cmd == ':' ) ea . cmd = skipwhite ( ea . cmd + 1 ) ; if ( * ea . cmd == NUL || * ea . cmd == \'""\' || ( ea . nextcmd = check_nextcmd ( ea . cmd ) ) != NULL ) { if ( ea . skip ) goto doend ; if ( * ea . cmd == '|' || ( exmode_active && ea . line1 != ea . line2 ) ) { ea . cmdidx = CMD_print ; ea . argt = RANGE + COUNT + TRLBAR ; if ( ( errormsg = invalid_range ( & ea ) ) == NULL ) { correct_range ( & ea ) ; ex_print ( & ea ) ; } } else if ( ea . addr_count != 0 ) { if ( ea . line2 > curbuf -> b_ml . ml_line_count ) { if ( vim_strchr ( p_cpo , CPO_MINUS ) != NULL ) ea . line2 = - 1 ; else ea . line2 = curbuf -> b_ml . ml_line_count ; } if ( ea . line2 < 0 ) errormsg = _ ( e_invrange ) ; else { if ( ea . line2 == 0 ) curwin -> w_cursor . lnum = 1 ; else curwin -> w_cursor . lnum = ea . line2 ; beginline ( BL_SOL | BL_FIX ) ; } } goto doend ; } if ( p != NULL && ea . cmdidx == CMD_SIZE && ! ea . skip && ASCII_ISUPPER ( * ea . cmd ) && has_cmdundefined ( ) ) { int ret ; p = ea . cmd ; while ( ASCII_ISALNUM ( * p ) ) ++ p ; p = vim_strnsave ( ea . cmd , ( int ) ( p - ea . cmd ) ) ; ret = apply_autocmds ( EVENT_CMDUNDEFINED , p , p , TRUE , NULL ) ; vim_free ( p ) ; p = ( ret # ifdef FEAT_EVAL && ! aborting ( ) # endif ) ? find_command ( & ea , NULL ) : ea . cmd ; } # ifdef FEAT_USR_CMDS if ( p == NULL ) { if ( ! ea . skip ) errormsg = _ ( ""E464:Ambiguoususeofuser-definedcommand"" ) ; goto doend ; } if ( * p == '!' && ea . cmd [ 1 ] == 0151 && ea . cmd [ 0 ] == 78 && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { errormsg = uc_fun_cmd ( ) ; goto doend ; } # endif if ( ea . cmdidx == CMD_SIZE ) { if ( ! ea . skip ) { STRCPY ( IObuff , _ ( ""E492:Notaneditorcommand"" ) ) ; if ( ! sourcing ) { if ( after_modifier != NULL ) append_command ( after_modifier ) ; else append_command ( * cmdlinep ) ; } errormsg = ( char * ) IObuff ; did_emsg_syntax = TRUE ; } goto doend ; } ni = ( ! IS_USER_CMDIDX ( ea . cmdidx ) && ( cmdnames [ ea . cmdidx ] . cmd_func == ex_ni # ifdef HAVE_EX_SCRIPT_NI || cmdnames [ ea . cmdidx ] . cmd_func == ex_script_ni # endif ) ) ; # ifndef FEAT_EVAL if ( ea . cmdidx == CMD_if ) ++ if_level ; if ( if_level ) { if ( ea . cmdidx == CMD_endif ) -- if_level ; goto doend ; } # endif if ( * p == '!' && ea . cmdidx != CMD_substitute && ea . cmdidx != CMD_smagic && ea . cmdidx != CMD_snomagic ) { ++ p ; ea . forceit = TRUE ; } else ea . forceit = FALSE ; if ( ! IS_USER_CMDIDX ( ea . cmdidx ) ) ea . argt = ( long ) cmdnames [ ( int ) ea . cmdidx ] . cmd_argt ; if ( ! ea . skip ) { # ifdef HAVE_SANDBOX if ( sandbox != 0 && ! ( ea . argt & SBOXOK ) ) { errormsg = _ ( e_sandbox ) ; goto doend ; } # endif  if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) )  { errormsg = _ ( e_modifiable ) ; goto doend ; } if ( text_locked ( ) && ! ( ea . argt & CMDWIN ) && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { errormsg = _ ( get_text_locked_msg ( ) ) ; goto doend ; } if ( ! ( ea . argt & CMDWIN ) && ea . cmdidx != CMD_checktime && ea . cmdidx != CMD_edit && ea . cmdidx != CMD_file && ! IS_USER_CMDIDX ( ea . cmdidx ) && curbuf_locked ( ) ) goto doend ; if ( ! ni && ! ( ea . argt & RANGE ) && ea . addr_count > 0 ) { errormsg = _ ( e_norange ) ; goto doend ; } } if ( ! ni && ! ( ea . argt & BANG ) && ea . forceit ) { errormsg = _ ( e_nobang ) ; goto doend ; } if ( ! ea . skip && ! ni ) { if ( ! global_busy && ea . line1 > ea . line2 ) { if ( msg_silent == 0 ) { if ( sourcing || exmode_active ) { errormsg = _ ( ""E493:Backwardsrangegiven"" ) ; goto doend ; } if ( ask_yesno ( ( char_u * ) _ ( ""Backwardsrangegiven,OKtoswap"" ) , FALSE ) != 'y' ) goto doend ; } lnum = ea . line1 ; ea . line1 = ea . line2 ; ea . line2 = lnum ; } if ( ( errormsg = invalid_range ( & ea ) ) != NULL ) goto doend ; } if ( ( ea . argt & NOTADR ) && ea . addr_count == 0 ) ea . line2 = 1 ; correct_range ( & ea ) ; # ifdef FEAT_FOLDING if ( ( ( ea . argt & WHOLEFOLD ) || ea . addr_count >= 2 ) && ! global_busy && ea . addr_type == ADDR_LINES ) { ( void ) hasFolding ( ea . line1 , & ea . line1 , NULL ) ; ( void ) hasFolding ( ea . line2 , NULL , & ea . line2 ) ; } # endif # ifdef FEAT_QUICKFIX p = replace_makeprg ( & ea , p , cmdlinep ) ; if ( p == NULL ) goto doend ; # endif if ( ea . cmdidx == CMD_bang ) ea . arg = p ; else ea . arg = skipwhite ( p ) ; if ( ea . cmdidx == CMD_file && * ea . arg != NUL && curbuf_locked ( ) ) goto doend ; if ( ea . argt & ARGOPT ) while ( ea . arg [ 0 ] == '+' && ea . arg [ 1 ] == '+' ) if ( getargopt ( & ea ) == FAIL && ! ni ) { errormsg = _ ( e_invarg ) ; goto doend ; } if ( ea . cmdidx == CMD_write || ea . cmdidx == CMD_update ) { if ( * ea . arg == '>' ) { if ( * ++ ea . arg != '>' ) { errormsg = _ ( ""E494:Useworw>>"" ) ; goto doend ; } ea . arg = skipwhite ( ea . arg + 1 ) ; ea . append = TRUE ; } else if ( * ea . arg == '!' && ea . cmdidx == CMD_write ) { ++ ea . arg ; ea . usefilter = TRUE ; } } if ( ea . cmdidx == CMD_read ) { if ( ea . forceit ) { ea . usefilter = TRUE ; ea . forceit = FALSE ; } else if ( * ea . arg == '!' ) { ++ ea . arg ; ea . usefilter = TRUE ; } } if ( ea . cmdidx == CMD_lshift || ea . cmdidx == CMD_rshift ) { ea . amount = 1 ; while ( * ea . arg == * ea . cmd ) { ++ ea . arg ; ++ ea . amount ; } ea . arg = skipwhite ( ea . arg ) ; } if ( ( ea . argt & EDITCMD ) && ! ea . usefilter ) ea . do_ecmd_cmd = getargcmd ( & ea . arg ) ; if ( ( ea . argt & TRLBAR ) && ! ea . usefilter ) separate_nextcmd ( & ea ) ; else if ( ea . cmdidx == CMD_bang || ea . cmdidx == CMD_terminal || ea . cmdidx == CMD_global || ea . cmdidx == CMD_vglobal || ea . usefilter ) { for ( p = ea . arg ; * p ; ++ p ) { if ( * p == '\\\\' && p [ 1 ] == '\\n' ) STRMOVE ( p , p + 1 ) ; else if ( * p == '\\n' ) { ea . nextcmd = p + 1 ; * p = NUL ; break ; } } } if ( ( ea . argt & DFLALL ) && ea . addr_count == 0 ) { buf_T * buf ; ea . line1 = 1 ; switch ( ea . addr_type ) { case ADDR_LINES : ea . line2 = curbuf -> b_ml . ml_line_count ; break ; case ADDR_LOADED_BUFFERS : buf = firstbuf ; while ( buf -> b_next != NULL && buf -> b_ml . ml_mfp == NULL ) buf = buf -> b_next ; ea . line1 = buf -> b_fnum ; buf = lastbuf ; while ( buf -> b_prev != NULL && buf -> b_ml . ml_mfp == NULL ) buf = buf -> b_prev ; ea . line2 = buf -> b_fnum ; break ; case ADDR_BUFFERS : ea . line1 = firstbuf -> b_fnum ; ea . line2 = lastbuf -> b_fnum ; break ; case ADDR_WINDOWS : ea . line2 = LAST_WIN_NR ; break ; case ADDR_TABS : ea . line2 = LAST_TAB_NR ; break ; case ADDR_TABS_RELATIVE : ea . line2 = 1 ; break ; case ADDR_ARGUMENTS : if ( ARGCOUNT == 0 ) ea . line1 = ea . line2 = 0 ; else ea . line2 = ARGCOUNT ; break ; # ifdef FEAT_QUICKFIX case ADDR_QUICKFIX : ea . line2 = qf_get_size ( & ea ) ; if ( ea . line2 == 0 ) ea . line2 = 1 ; break ; # endif } } if ( ( ea . argt & REGSTR ) && * ea . arg != NUL && ( ! IS_USER_CMDIDX ( ea . cmdidx ) || * ea . arg != '=' ) && ! ( ( ea . argt & COUNT ) && VIM_ISDIGIT ( * ea . arg ) ) ) { # ifndef FEAT_CLIPBOARD if ( * ea . arg == '*' || * ea . arg == '+' ) { errormsg = _ ( e_invalidreg ) ; goto doend ; } # endif if ( valid_yank_reg ( * ea . arg , ( ea . cmdidx != CMD_put && ! IS_USER_CMDIDX ( ea . cmdidx ) ) ) ) { ea . regname = * ea . arg ++ ; # ifdef FEAT_EVAL if ( ea . arg [ - 1 ] == '=' && ea . arg [ 0 ] != NUL ) { set_expr_line ( vim_strsave ( ea . arg ) ) ; ea . arg += STRLEN ( ea . arg ) ; } # endif ea . arg = skipwhite ( ea . arg ) ; } } if ( ( ea . argt & COUNT ) && VIM_ISDIGIT ( * ea . arg ) && ( ! ( ea . argt & BUFNAME ) || * ( p = skipdigits ( ea . arg ) ) == NUL || VIM_ISWHITE ( * p ) ) ) { n = getdigits ( & ea . arg ) ; ea . arg = skipwhite ( ea . arg ) ; if ( n <= 0 && ! ni && ( ea . argt & ZEROR ) == 0 ) { errormsg = _ ( e_zerocount ) ; goto doend ; } if ( ea . argt & NOTADR ) { ea . line2 = n ; if ( ea . addr_count == 0 ) ea . addr_count = 1 ; } else { ea . line1 = ea . line2 ; ea . line2 += n - 1 ; ++ ea . addr_count ; if ( ea . addr_type == ADDR_LINES && ea . line2 > curbuf -> b_ml . ml_line_count ) ea . line2 = curbuf -> b_ml . ml_line_count ; } } if ( ea . argt & EXFLAGS ) get_flags ( & ea ) ; if ( ! ni && ! ( ea . argt & EXTRA ) && * ea . arg != NUL && * ea . arg != \'""\' && ( * ea . arg != '|' || ( ea . argt & TRLBAR ) == 0 ) ) { errormsg = _ ( e_trailing ) ; goto doend ; } if ( ! ni && ( ea . argt & NEEDARG ) && * ea . arg == NUL ) { errormsg = _ ( e_argreq ) ; goto doend ; } # ifdef FEAT_EVAL if ( ea . skip ) { switch ( ea . cmdidx ) { case CMD_while : case CMD_endwhile : case CMD_for : case CMD_endfor : case CMD_if : case CMD_elseif : case CMD_else : case CMD_endif : case CMD_try : case CMD_catch : case CMD_finally : case CMD_endtry : case CMD_function : break ; case CMD_aboveleft : case CMD_and : case CMD_belowright : case CMD_botright : case CMD_browse : case CMD_call : case CMD_confirm : case CMD_delfunction : case CMD_djump : case CMD_dlist : case CMD_dsearch : case CMD_dsplit : case CMD_echo : case CMD_echoerr : case CMD_echomsg : case CMD_echon : case CMD_execute : case CMD_filter : case CMD_help : case CMD_hide : case CMD_ijump : case CMD_ilist : case CMD_isearch : case CMD_isplit : case CMD_keepalt : case CMD_keepjumps : case CMD_keepmarks : case CMD_keeppatterns : case CMD_leftabove : case CMD_let : case CMD_lockmarks : case CMD_lua : case CMD_match : case CMD_mzscheme : case CMD_noautocmd : case CMD_noswapfile : case CMD_perl : case CMD_psearch : case CMD_python : case CMD_py3 : case CMD_python3 : case CMD_return : case CMD_rightbelow : case CMD_ruby : case CMD_silent : case CMD_smagic : case CMD_snomagic : case CMD_substitute : case CMD_syntax : case CMD_tab : case CMD_tcl : case CMD_throw : case CMD_tilde : case CMD_topleft : case CMD_unlet : case CMD_verbose : case CMD_vertical : case CMD_wincmd : break ; default : goto doend ; } } # endif if ( ea . argt & XFILE ) { if ( expand_filename ( & ea , cmdlinep , & errormsg ) == FAIL ) goto doend ; } if ( ( ea . argt & BUFNAME ) && * ea . arg != NUL && ea . addr_count == 0 && ! IS_USER_CMDIDX ( ea . cmdidx ) ) { if ( ea . cmdidx == CMD_bdelete || ea . cmdidx == CMD_bwipeout || ea . cmdidx == CMD_bunload ) p = skiptowhite_esc ( ea . arg ) ; else { p = ea . arg + STRLEN ( ea . arg ) ; while ( p > ea . arg && VIM_ISWHITE ( p [ - 1 ] ) ) -- p ; } ea . line2 = buflist_findpat ( ea . arg , p , ( ea . argt & BUFUNL ) != 0 , FALSE , FALSE ) ; if ( ea . line2 < 0 ) goto doend ; ea . addr_count = 1 ; ea . arg = skipwhite ( p ) ; } if ( ea . cmdidx == CMD_try && ea . did_esilent > 0 ) { emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; ea . did_esilent = 0 ; } # ifdef FEAT_USR_CMDS if ( IS_USER_CMDIDX ( ea . cmdidx ) ) { do_ucmd ( & ea ) ; } else # endif { ea . errmsg = NULL ; ( cmdnames [ ea . cmdidx ] . cmd_func ) ( & ea ) ; if ( ea . errmsg != NULL ) errormsg = _ ( ea . errmsg ) ; } # ifdef FEAT_EVAL if ( need_rethrow ) do_throw ( cstack ) ; else if ( check_cstack ) { if ( source_finished ( fgetline , cookie ) ) do_finish ( & ea , TRUE ) ; else if ( getline_equal ( fgetline , cookie , get_func_line ) && current_func_returned ( ) ) do_return ( & ea , TRUE , FALSE , NULL ) ; } need_rethrow = check_cstack = FALSE ; # endif doend : if ( curwin -> w_cursor . lnum == 0 ) { curwin -> w_cursor . lnum = 1 ; curwin -> w_cursor . col = 0 ; } if ( errormsg != NULL && * errormsg != NUL && ! did_emsg ) { if ( sourcing ) { if ( errormsg != ( char * ) IObuff ) { STRCPY ( IObuff , errormsg ) ; errormsg = ( char * ) IObuff ; } append_command ( * cmdlinep ) ; } emsg ( errormsg ) ; } # ifdef FEAT_EVAL do_errthrow ( cstack , ( ea . cmdidx != CMD_SIZE && ! IS_USER_CMDIDX ( ea . cmdidx ) ) ? cmdnames [ ( int ) ea . cmdidx ] . cmd_name : ( char_u * ) NULL ) ; # endif if ( ea . verbose_save >= 0 ) p_verbose = ea . verbose_save ; free_cmdmod ( ) ; cmdmod = save_cmdmod ; if ( ea . save_msg_silent != - 1 ) { if ( ! did_emsg || msg_silent > ea . save_msg_silent ) msg_silent = ea . save_msg_silent ; emsg_silent -= ea . did_esilent ; if ( emsg_silent < 0 ) emsg_silent = 0 ; msg_scroll = save_msg_scroll ; if ( redirecting ( ) ) msg_col = 0 ; } # ifdef HAVE_SANDBOX if ( ea . did_sandbox ) -- sandbox ; # endif if ( ea . nextcmd && * ea . nextcmd == NUL ) ea . nextcmd = NULL ; # ifdef FEAT_EVAL -- ex_nesting_level ; # endif return ea . nextcmd ; }"," endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( ""E981:Commandnotallowedinrvim"" ) ; goto doend ; } if ("
5,"CWE-200 int tpm_open ( struct inode * inode , struct file * file ) { int minor = iminor ( inode ) ; struct tpm_chip * chip = NULL , * pos ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( pos , & tpm_chip_list , list ) { if ( pos -> vendor . miscdev . minor == minor ) { chip = pos ; get_device ( chip -> dev ) ; break ; } } rcu_read_unlock ( ) ; if ( ! chip ) return - ENODEV ; if ( test_and_set_bit ( 0 , & chip -> is_open ) ) { dev_dbg ( chip -> dev , ""AnotherprocessownsthisTPM\\n"" ) ; put_device ( chip -> dev ) ; return - EBUSY ; }  chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ;  if ( chip -> data_buffer == NULL ) { clear_bit ( 0 , & chip -> is_open ) ; put_device ( chip -> dev ) ; return - ENOMEM ; } atomic_set ( & chip -> data_pending , 0 ) ; file -> private_data = chip ; return 0 ; }"," -> data_buffer = kzalloc ( TPM_BUFSIZE  , GFP_KERNEL )"
6,"CWE-476 static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ;  unsigned int channo ;  if ( jp2_getuint16 ( in , & cdef -> numchans ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }", unsigned int channo ; cdef -> ents = 0
7,"CWE-400 static long pmcraid_ioctl_passthrough ( struct pmcraid_instance * pinstance , unsigned int ioctl_cmd , unsigned int buflen , unsigned long arg ) { struct pmcraid_passthrough_ioctl_buffer * buffer ; struct pmcraid_ioarcb * ioarcb ; struct pmcraid_cmd * cmd ; struct pmcraid_cmd * cancel_cmd ; unsigned long request_buffer ; unsigned long request_offset ; unsigned long lock_flags ; void * ioasa ; u32 ioasc ; int request_size ; int buffer_size ; u8 access , direction ; int rc = 0 ; if ( pinstance -> ioa_reset_in_progress ) { rc = wait_event_interruptible_timeout ( pinstance -> reset_wait_q , ! pinstance -> ioa_reset_in_progress , msecs_to_jiffies ( 10000 ) ) ; if ( ! rc ) return - ETIMEDOUT ; else if ( rc < 0 ) return - ERESTARTSYS ; } if ( pinstance -> ioa_state != IOA_STATE_OPERATIONAL ) { pmcraid_err ( ""IOAisnotoperational\\n"" ) ; return - ENOTTY ; } buffer_size = sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ; buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; if ( ! buffer ) { pmcraid_err ( ""nomemoryforpassthroughbuffer\\n"" ) ; return - ENOMEM ; } request_offset = offsetof ( struct pmcraid_passthrough_ioctl_buffer , request_buffer ) ; request_buffer = arg + request_offset ; rc = __copy_from_user ( buffer , ( struct pmcraid_passthrough_ioctl_buffer * ) arg , sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ) ; ioasa = ( void * ) ( arg + offsetof ( struct pmcraid_passthrough_ioctl_buffer , ioasa ) ) ; if ( rc ) { pmcraid_err ( ""ioctl:can\'tcopypassthroughbuffer\\n"" ) ; rc = - EFAULT ; goto out_free_buffer ; } request_size = buffer -> ioarcb . data_transfer_length ; if ( buffer -> ioarcb . request_flags0 & TRANSFER_DIR_WRITE ) { access = VERIFY_READ ; direction = DMA_TO_DEVICE ; } else { access = VERIFY_WRITE ; direction = DMA_FROM_DEVICE ; } if ( request_size > 0 ) { rc = access_ok ( access , arg , request_offset + request_size ) ; if ( ! rc ) { rc = - EFAULT ; goto out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; } if ( buffer -> ioarcb . add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN ) { rc = - EINVAL ; goto out_free_buffer ; } cmd = pmcraid_get_free_cmd ( pinstance ) ; if ( ! cmd ) { pmcraid_err ( ""freecommandblockisnotavailable\\n"" ) ; rc = - ENOMEM ; goto out_free_buffer ; } cmd -> scsi_cmd = NULL ; ioarcb = & ( cmd -> ioa_cb -> ioarcb ) ; ioarcb -> resource_handle = buffer -> ioarcb . resource_handle ; ioarcb -> data_transfer_length = buffer -> ioarcb . data_transfer_length ; ioarcb -> cmd_timeout = buffer -> ioarcb . cmd_timeout ; ioarcb -> request_type = buffer -> ioarcb . request_type ; ioarcb -> request_flags0 = buffer -> ioarcb . request_flags0 ; ioarcb -> request_flags1 = buffer -> ioarcb . request_flags1 ; memcpy ( ioarcb -> cdb , buffer -> ioarcb . cdb , PMCRAID_MAX_CDB_LEN ) ; if ( buffer -> ioarcb . add_cmd_param_length ) { ioarcb -> add_cmd_param_length = buffer -> ioarcb . add_cmd_param_length ; ioarcb -> add_cmd_param_offset = buffer -> ioarcb . add_cmd_param_offset ; memcpy ( ioarcb -> add_data . u . add_cmd_params , buffer -> ioarcb . add_data . u . add_cmd_params , buffer -> ioarcb . add_cmd_param_length ) ; } ioarcb -> hrrq_id = atomic_add_return ( 1 , & ( pinstance -> last_message_id ) ) % pinstance -> num_hrrq ; if ( request_size ) { rc = pmcraid_build_passthrough_ioadls ( cmd , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""couldn\'tbuildpassthroughioadls\\n"" ) ; goto out_free_buffer ;  }  } if ( direction == DMA_TO_DEVICE && request_size > 0 ) { rc = pmcraid_copy_sglist ( cmd -> sglist , request_buffer , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""failedtocopyuserbuffer\\n"" ) ; goto out_free_sglist ; } } cmd -> cmd_done = pmcraid_internal_done ; init_completion ( & cmd -> wait_for_completion ) ; cmd -> completion_req = 1 ; pmcraid_info ( ""command(%d)(CDB[0]=%x)for%x\\n"" , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle ) >> 2 , cmd -> ioa_cb -> ioarcb . cdb [ 0 ] , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . resource_handle ) ) ; spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; _pmcraid_fire_command ( cmd ) ; spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; buffer -> ioarcb . cmd_timeout = 0 ; if ( buffer -> ioarcb . cmd_timeout == 0 ) { wait_for_completion ( & cmd -> wait_for_completion ) ; } else if ( ! wait_for_completion_timeout ( & cmd -> wait_for_completion , msecs_to_jiffies ( buffer -> ioarcb . cmd_timeout * 1000 ) ) ) { pmcraid_info ( ""abortingcmd%d(CDB[0]=%x)duetotimeout\\n"" , le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle >> 2 ) , cmd -> ioa_cb -> ioarcb . cdb [ 0 ] ) ; spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; cancel_cmd = pmcraid_abort_cmd ( cmd ) ; spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; if ( cancel_cmd ) { wait_for_completion ( & cancel_cmd -> wait_for_completion ) ; ioasc = cancel_cmd -> ioa_cb -> ioasa . ioasc ; pmcraid_return_cmd ( cancel_cmd ) ; if ( ioasc == PMCRAID_IOASC_IOA_WAS_RESET || PMCRAID_IOASC_SENSE_KEY ( ioasc ) == 0x00 ) { if ( ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND ) rc = - ETIMEDOUT ; goto out_handle_response ; } } if ( ! wait_for_completion_timeout ( & cmd -> wait_for_completion , msecs_to_jiffies ( 150 * 1000 ) ) ) { pmcraid_reset_bringup ( cmd -> drv_inst ) ; rc = - ETIMEDOUT ; } } out_handle_response : if ( copy_to_user ( ioasa , & cmd -> ioa_cb -> ioasa , sizeof ( struct pmcraid_ioasa ) ) ) { pmcraid_err ( ""failedtocopyioasabuffertouser\\n"" ) ; rc = - EFAULT ; } else if ( direction == DMA_FROM_DEVICE && request_size > 0 ) { rc = pmcraid_copy_sglist ( cmd -> sglist , request_buffer , request_size , direction ) ; if ( rc ) { pmcraid_err ( ""failedtocopyuserbuffer\\n"" ) ; rc = - EFAULT ; } } out_free_sglist : pmcraid_release_passthrough_ioadls ( cmd , request_size , direction ) ; pmcraid_return_cmd ( cmd ) ; out_free_buffer : kfree ( buffer ) ; return rc ; }", out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
8,"CWE-436 static gssize find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) {  guchar * match ;  int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ;  gsize to_match = MIN ( left , buffer -> pos ) ;   if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 )  { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL )  return match - buffer -> data + strlen ( AUTH_END_STRING ) ;  for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }"," buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer  , buffer ->  , buffer -> data , buffer ->  pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer  -> data +  -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } }  }  "
9,"CWE-119 static int check_ptr_alignment ( struct bpf_verifier_env * env , const struct bpf_reg_state * reg , int off , int size ) { bool strict = env -> strict_alignment ; const char * pointer_desc = """" ; switch ( reg -> type ) { case PTR_TO_PACKET : case PTR_TO_PACKET_META : return check_pkt_ptr_alignment ( env , reg , off , size , strict ) ; case PTR_TO_MAP_VALUE : pointer_desc = ""value"" ; break ; case PTR_TO_CTX : pointer_desc = ""context"" ; break ; case PTR_TO_STACK : pointer_desc = ""stack"" ;  break ;  default : break ; } return check_generic_ptr_alignment ( env , reg , pointer_desc , off , size , strict ) ; }"," = ""stack"" ; strict = true ;"
10,"CWE-119 void vp8_copy_mem8x8_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 8 ; r ++ ) {  # if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; # endif src += src_stride ; dst += dst_stride ; } }"," ++ ) { memcpy ( dst , src , 8 ) ;  src += src_stride"
11,"CWE-415 static OM_uint32 init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , OM_uint32 acc_negState , gss_OID supportedMech , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * tokflag ) { OM_uint32 tmpmin ;  size_t i ;  generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ; gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , GSS_C_NO_BUFFER ) ; for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) break ; } if ( i == sc -> mech_set -> count ) return GSS_S_DEFECTIVE_TOKEN ; sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; if ( acc_negState != REQUEST_MIC ) return GSS_S_DEFECTIVE_TOKEN ; sc -> mech_complete = 0 ; sc -> mic_reqd = 1 ; * negState = REQUEST_MIC ; * tokflag = CONT_TOKEN_SEND ; return GSS_S_CONTINUE_NEEDED ; }", ; size_t i  ; gss_delete_sec_context (
12,"CWE-119 WORD32 ih264d_parse_bslice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD8 u1_ref_idx_re_flag_lx ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_temp , ui_temp1 ; WORD32 i_temp ; WORD32 ret ; { WORD8 * pi1_buf ; WORD16 * pi2_mv = ps_dec -> s_default_mv_pred . i2_mv ; WORD32 * pi4_mv = ( WORD32 * ) pi2_mv ; WORD16 * pi16_refFrame ; pi1_buf = ps_dec -> s_default_mv_pred . i1_ref_frame ; pi16_refFrame = ( WORD16 * ) pi1_buf ; * pi4_mv = 0 ; * ( pi4_mv + 1 ) = 0 ; * pi16_refFrame = OUT_OF_RANGE_REF ; ps_dec -> s_default_mv_pred . u1_col_ref_pic_idx = ( UWORD8 ) - 1 ; ps_dec -> s_default_mv_pred . u1_pic_type = ( UWORD8 ) - 1 ; } ps_slice -> u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:num_ref_idx_override_flag"" , ps_slice -> u1_num_ref_idx_active_override_flag ) ; u4_temp = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 0 ] ; ui_temp1 = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 1 ] ; if ( ps_slice -> u1_num_ref_idx_active_override_flag ) { u4_temp = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:num_ref_idx_l0_active_minus1"" , u4_temp - 1 ) ; ui_temp1 = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:num_ref_idx_l1_active_minus1"" , ui_temp1 - 1 ) ; } { UWORD8 u1_max_ref_idx = MAX_FRAMES ; if ( ps_slice -> u1_field_pic_flag ) { u1_max_ref_idx = MAX_FRAMES << 1 ; } if ( ( u4_temp > u1_max_ref_idx ) || ( ui_temp1 > u1_max_ref_idx ) ) { return ERROR_NUM_REF ; } ps_slice -> u1_num_ref_idx_lx_active [ 0 ] = u4_temp ; ps_slice -> u1_num_ref_idx_lx_active [ 1 ] = ui_temp1 ; } { UWORD8 init_idx_flg = ( ps_dec -> u1_pr_sl_type != ps_dec -> ps_cur_slice -> u1_slice_type ) ; if ( ps_dec -> u1_first_pb_nal_in_pic || ( init_idx_flg & ! ps_dec -> u1_sl_typ_5_9 ) || ps_dec -> u1_num_ref_idx_lx_active_prev != ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ) ih264d_init_ref_idx_lx_b ( ps_dec ) ; if ( ps_dec -> u1_first_pb_nal_in_pic & ps_dec -> u1_sl_typ_5_9 ) ps_dec -> u1_first_pb_nal_in_pic = 0 ; } ps_dec -> u1_num_ref_idx_lx_active_prev = ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; u1_ref_idx_re_flag_lx = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:ref_pic_list_reordering_flag_l0"" , u1_ref_idx_re_flag_lx ) ; if ( u1_ref_idx_re_flag_lx ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 0 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; } else ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; u1_ref_idx_re_flag_lx = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:ref_pic_list_reordering_flag_l1"" , u1_ref_idx_re_flag_lx ) ; if ( u1_ref_idx_re_flag_lx ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 1 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 1 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 1 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; } else ps_dec -> ps_ref_pic_buf_lx [ 1 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 1 ] ; { void * * ppv_map_ref_idx_to_poc_lx ; WORD8 idx ; struct pic_buffer_t * ps_pic ; ppv_map_ref_idx_to_poc_lx = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L0 ; ppv_map_ref_idx_to_poc_lx [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx [ idx ] = ( ps_pic -> pu1_buf1 ) ; } ppv_map_ref_idx_to_poc_lx = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L1 ; ppv_map_ref_idx_to_poc_lx [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 1 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 1 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx [ idx ] = ( ps_pic -> pu1_buf1 ) ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { void * * ppv_map_ref_idx_to_poc_lx_t , * * ppv_map_ref_idx_to_poc_lx_b ; ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t += 2 ; ppv_map_ref_idx_to_poc_lx_b += 2 ; } ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; for ( idx = 0 ; idx < ps_dec -> ps_cur_slice -> u1_num_ref_idx_lx_active [ 1 ] ; idx ++ ) { UWORD8 u1_tmp_idx = idx << 1 ; ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 1 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ u1_tmp_idx ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ u1_tmp_idx + 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ u1_tmp_idx ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ u1_tmp_idx + 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; } } if ( ps_dec -> u4_num_cores >= 3 ) { WORD32 num_entries ; WORD32 size ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; memcpy ( ( void * ) ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc , ps_dec -> ppv_map_ref_idx_to_poc , size ) ; } } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) ) { ih264d_convert_frm_mbaff_list ( ps_dec ) ; } if ( ps_pps -> u1_wted_bipred_idc == 1 ) { ret = ih264d_parse_pred_weight_table ( ps_slice , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_form_pred_weight_matrix ( ps_dec ) ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } else if ( ps_pps -> u1_wted_bipred_idc == 2 ) { ps_slice -> u2_log2Y_crwd = 0x0505 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; ih264d_get_implicit_weights ( ps_dec ) ; } else ps_dec -> ps_cur_slice -> u2_log2Y_crwd = 0 ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ;  else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } if ( ps_pps -> u1_entropy_coding_mode == CABAC ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_CABAC_INIT_IDC ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> u1_cabac_init_idc = u4_temp ; COPYTHECONTEXT ( ""SH:cabac_init_idc"" , ps_slice -> u1_cabac_init_idc ) ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) { return ERROR_INV_RANGE_QP_T ; } ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:slice_qp_delta"" , ( WORD8 ) ( ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } COPYTHECONTEXT ( ""SH:disable_deblocking_filter_idc"" , u4_temp ) ; ps_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:slice_alpha_c0_offset_div2"" , ps_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:slice_beta_offset_div2"" , ps_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } } else { ps_slice -> u1_disable_dblk_filter_idc = 0 ; ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac ; ps_dec -> pf_parse_inter_mb = ih264d_parse_bmb_cabac ; ih264d_init_cabac_contexts ( B_SLICE , ps_dec ) ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; } else { SWITCHONTRACE ; SWITCHOFFTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc ; ps_dec -> pf_parse_inter_mb = ih264d_parse_bmb_cavlc ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; } ret = ih264d_cal_col_pic ( ps_dec ) ; if ( ret != OK ) return ret ; ps_dec -> u1_B = 1 ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb ; ret = ps_dec -> pf_parse_inter_slice ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; return OK ; }", -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; }  -> u4_bitoffset = i_temp ; }  else ps_bitstrm ->
13,"CWE-119 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) >  ( Rec2 . RecordLength - 2 - 2 ) / 3 )  ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp <= 16 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }"," ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries"
14,"CWE-119  void usage_exit ( ) {  fprintf ( stderr , ""Usage:%s<codec><width><height><infile><outfile>"" ""<keyframe-interval>[<error-resilient>]\\nSeecommentsin"" ""simple_encoder.cformoreinformation.\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }", void usage_exit ( void
15,"CWE-269 int main ( int argc , char * * argv ) { const char * safepath = SAFE_PATH ; const char * confpath = NULL ; char * shargv [ ] = { NULL , NULL } ; char * sh ; const char * cmd ; char cmdline [ LINE_MAX ] ; char myname [ _PW_NAME_LEN + 1 ] ; struct passwd * original_pw , * target_pw ; struct rule * rule ; uid_t uid ; uid_t target = 0 ; gid_t groups [ NGROUPS_MAX + 1 ] ; int ngroups ; int i , ch ; int sflag = 0 ; int nflag = 0 ; char cwdpath [ PATH_MAX ] ; const char * cwd ; char * login_style = NULL ; char * * envp ; # ifndef linux setprogname ( ""doas"" ) ; # endif # ifndef linux closefrom ( STDERR_FILENO + 1 ) ; # endif uid = getuid ( ) ; while ( ( ch = getopt ( argc , argv , ""a:C:nsu:"" ) ) != - 1 ) { switch ( ch ) { case 'a' : login_style = optarg ; break ; case 'C' : confpath = optarg ; break ; case 'u' : if ( parseuid ( optarg , & target ) != 0 ) errx ( 1 , ""unknownuser"" ) ; break ; case 'n' : nflag = 1 ; break ; case 's' : sflag = 1 ; break ; default : usage ( ) ; break ; } } argv += optind ; argc -= optind ; if ( confpath ) { if ( sflag ) usage ( ) ; } else if ( ( ! sflag && ! argc ) || ( sflag && argc ) ) usage ( ) ; original_pw = getpwuid ( uid ) ; if ( ! original_pw ) err ( 1 , ""getpwuidfailed"" ) ; if ( strlcpy ( myname , original_pw -> pw_name , sizeof ( myname ) ) >= sizeof ( myname ) ) errx ( 1 , ""pw_nametoolong"" ) ; ngroups = getgroups ( NGROUPS_MAX , groups ) ; if ( ngroups == - 1 ) err ( 1 , ""can\'tgetgroups"" ) ; groups [ ngroups ++ ] = getgid ( ) ; if ( sflag ) { sh = getenv ( ""SHELL"" ) ; if ( sh == NULL || * sh == '\\0' ) { shargv [ 0 ] = strdup ( original_pw -> pw_shell ) ; if ( shargv [ 0 ] == NULL ) err ( 1 , NULL ) ; } else shargv [ 0 ] = sh ; argv = shargv ; argc = 1 ; } if ( confpath ) { checkconfig ( confpath , argc , argv , uid , groups , ngroups , target ) ; exit ( 1 ) ; } if ( geteuid ( ) ) errx ( 1 , ""notinstalledsetuid"" ) ; parseconfig ( DOAS_CONF , 1 ) ; ( void ) strlcpy ( cmdline , argv [ 0 ] , sizeof ( cmdline ) ) ; for ( i = 1 ; i < argc ; i ++ ) { if ( strlcat ( cmdline , """" , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; if ( strlcat ( cmdline , argv [ i ] , sizeof ( cmdline ) ) >= sizeof ( cmdline ) ) break ; } cmd = argv [ 0 ] ; if ( ! permit ( uid , groups , ngroups , & rule , target , cmd , ( const char * * ) argv + 1 ) ) { syslog ( LOG_AUTHPRIV | LOG_NOTICE , ""failedcommandfor%s:%s"" , myname , cmdline ) ; errc ( 1 , EPERM , NULL ) ; } if ( ! ( rule -> options & NOPASS ) ) { if ( nflag ) errx ( 1 , ""Authorizationrequired"" ) ; # if defined ( USE_BSD_AUTH ) authuser ( myname , login_style , rule -> options & PERSIST ) ; # elif defined ( USE_PAM )  # define PAM_END ( msg ) do { syslog ( LOG_ERR , ""%s:%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( EXIT_FAILURE ) ; } while ( 0 )  pam_handle_t * pamh = NULL ; int pam_err ; int temp_stdin ; temp_stdin = dup ( STDIN_FILENO ) ; if ( temp_stdin == - 1 ) err ( 1 , ""dup"" ) ; close ( STDIN_FILENO ) ; int temp_stdout = dup ( 1 ) ; if ( temp_stdout == - 1 ) err ( 1 , ""dup"" ) ; close ( 1 ) ; if ( dup2 ( 2 , 1 ) == - 1 ) err ( 1 , ""dup2"" ) ; pam_err = pam_start ( ""doas"" , myname , & pamc , & pamh ) ; if ( pam_err != PAM_SUCCESS ) { if ( pamh != NULL ) PAM_END ( ""pam_start"" ) ; syslog ( LOG_ERR , ""pam_startfailed:%s"" , pam_strerror ( pamh , pam_err ) ) ; errx ( EXIT_FAILURE , ""pam_startfailed"" ) ; } switch ( pam_err = pam_authenticate ( pamh , PAM_SILENT ) ) { case PAM_SUCCESS : switch ( pam_err = pam_acct_mgmt ( pamh , PAM_SILENT ) ) { case PAM_SUCCESS : break ; case PAM_NEW_AUTHTOK_REQD : pam_err = pam_chauthtok ( pamh , PAM_SILENT | PAM_CHANGE_EXPIRED_AUTHTOK ) ; if ( pam_err != PAM_SUCCESS ) PAM_END ( ""pam_chauthtok"" ) ; break ; case PAM_AUTH_ERR : case PAM_USER_UNKNOWN : case PAM_MAXTRIES : syslog ( LOG_AUTHPRIV | LOG_NOTICE , ""failedauthfor%s"" , myname ) ; errx ( EXIT_FAILURE , ""secondauthenticationfailed"" ) ; break ; default : PAM_END ( ""pam_acct_mgmt"" ) ; break ; } break ; case PAM_AUTH_ERR : case PAM_USER_UNKNOWN : case PAM_MAXTRIES : syslog ( LOG_AUTHPRIV | LOG_NOTICE , ""failedauthfor%s"" , myname ) ; errx ( EXIT_FAILURE , ""authenticationfailed"" ) ; break ; default : PAM_END ( ""pam_authenticate"" ) ; break ; } pam_end ( pamh , pam_err ) ; # ifndef linux if ( dup2 ( temp_stdin , STDIN_FILENO ) == - 1 ) err ( 1 , ""dup2"" ) ; close ( temp_stdin ) ; # else close ( 1 ) ; if ( dup2 ( temp_stdout , 1 ) == - 1 ) err ( 1 , ""dup2"" ) ; # endif # else # error No auth module ! # endif } target_pw = getpwuid ( target ) ; if ( ! target_pw ) errx ( 1 , ""nopasswdentryfortarget"" ) ; # if defined ( HAVE_LOGIN_CAP_H ) if ( setusercontext ( NULL , target_pw , target , LOGIN_SETGROUP | LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK | LOGIN_SETUSER ) != 0 ) errx ( 1 , ""failedtosetusercontextfortarget"" ) ;  # endif  if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = ""(failed)"" ; else cwd = cwdpath ;  # ifndef HAVE_LOGIN_CAP_H  if ( target != 0 ) setuid ( target ) ; if ( geteuid ( ) == ROOT_UID ) setuid ( ROOT_UID ) ; # endif syslog ( LOG_AUTHPRIV | LOG_INFO , ""%srancommand%sas%sfrom%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ; envp = prepenv ( rule , original_pw , target_pw ) ; if ( rule -> cmd ) { if ( setenv ( ""PATH"" , safepath , 1 ) == - 1 ) err ( 1 , ""failedtosetPATH\'%s\'"" , safepath ) ; } execvpe ( cmd , argv , envp ) ; if ( errno == ENOENT ) errx ( 1 , ""%s:commandnotfound"" , cmd ) ; err ( 1 , ""%s"" , cmd ) ; }"," EXIT_FAILURE ) ; \\\n}  while ( 0  ) ; # else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ; # else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ; # endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ; # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ; # else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ; # endif #  = cwdpath ;  syslog ( LOG_AUTHPRIV"
16,"CWE-400 static xfs_failaddr_t xfs_agf_verify ( struct xfs_buf * bp ) { struct xfs_mount * mp = bp -> b_mount ; struct xfs_agf * agf = XFS_BUF_TO_AGF ( bp ) ; if ( xfs_sb_version_hascrc ( & mp -> m_sb ) ) { if ( ! uuid_equal ( & agf -> agf_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; if ( ! xfs_log_check_lsn ( mp , be64_to_cpu ( XFS_BUF_TO_AGF ( bp ) -> agf_lsn ) ) ) return __this_address ; } if ( ! xfs_verify_magic ( bp , agf -> agf_magicnum ) ) return __this_address ; if ( ! ( XFS_AGF_GOOD_VERSION ( be32_to_cpu ( agf -> agf_versionnum ) ) && be32_to_cpu ( agf -> agf_freeblks ) <= be32_to_cpu ( agf -> agf_length ) && be32_to_cpu ( agf -> agf_flfirst ) < xfs_agfl_size ( mp ) && be32_to_cpu ( agf -> agf_fllast ) < xfs_agfl_size ( mp ) &&  be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) )  return __this_address ; if ( be32_to_cpu ( agf -> agf_levels [ XFS_BTNUM_BNO ] ) < 1 || be32_to_cpu ( agf -> agf_levels [ XFS_BTNUM_CNT ] ) < 1 || be32_to_cpu ( agf -> agf_levels [ XFS_BTNUM_BNO ] ) > XFS_BTREE_MAXLEVELS || be32_to_cpu ( agf -> agf_levels [ XFS_BTNUM_CNT ] ) > XFS_BTREE_MAXLEVELS ) return __this_address ; if ( xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && ( be32_to_cpu ( agf -> agf_levels [ XFS_BTNUM_RMAP ] ) < 1 || be32_to_cpu ( agf -> agf_levels [ XFS_BTNUM_RMAP ] ) > XFS_BTREE_MAXLEVELS ) ) return __this_address ;  if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno )  return __this_address ; if ( xfs_sb_version_haslazysbcount ( & mp -> m_sb ) &&  be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) )  return __this_address ; if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && ( be32_to_cpu ( agf -> agf_refcount_level ) < 1 || be32_to_cpu ( agf -> agf_refcount_level ) > XFS_BTREE_MAXLEVELS ) ) return __this_address ; return NULL ; }", ( mp ) ) ) return __this_address ; if ( be32_to_cpu ( agf -> agf_length ) > mp -> m_sb . sb_dblocks ) return __this_address ; if ( be32_to_cpu ( agf -> agf_freeblks ) < be32_to_cpu ( agf -> agf_longest ) || be32_to_cpu ( agf -> agf_freeblks ) > be32_to_cpu ( agf -> agf_length  ; if ( xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_rmap_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if (  agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_refcount_blocks ) >
17,"CWE-264 static inline int ip_ufo_append_data ( struct sock * sk , struct sk_buff_head * queue , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int maxfraglen , unsigned int flags ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ;  skb -> ip_summed = CHECKSUM_PARTIAL ;  skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ;  __skb_queue_tail ( queue , skb ) ;  } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }"," ; skb -> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb ->  ip_summed = CHECKSUM_PARTIAL  ; skb_shinfo (  = SKB_GSO_UDP ; append :  return skb_append_datato_frags ("
18,"CWE-119 int psf_binheader_readf ( SF_PRIVATE * psf , char const * format , ... ) { va_list argptr ; sf_count_t * countptr , countdata ; unsigned char * ucptr , sixteen_bytes [ 16 ] ; unsigned int * intptr , intdata ; unsigned short * shortptr ; char * charptr ; float * floatptr ; double * doubleptr ; char c ;  int byte_count = 0 , count ;  if ( ! format ) return psf_ftell ( psf ) ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) )  { switch ( c )  { case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 'm' : intptr = va_arg ( argptr , unsigned int * ) ;  ucptr = ( unsigned char * ) intptr ;  byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; * intptr = GET_MARKER ( ucptr ) ; break ; case 'h' :  intptr = va_arg ( argptr , unsigned int * ) ;  ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , sixteen_bytes , sizeof ( sixteen_bytes ) ) ; { int k ; intdata = 0 ; for ( k = 0 ; k < 16 ; k ++ ) intdata ^= sixteen_bytes [ k ] << k ; } * intptr = intdata ; break ; case '1' : charptr = va_arg ( argptr , char * ) ; * charptr = 0 ; byte_count += header_read ( psf , charptr , sizeof ( char ) ) ; break ; case '2' : shortptr = va_arg ( argptr , unsigned short * ) ; * shortptr = 0 ; ucptr = ( unsigned char * ) shortptr ; byte_count += header_read ( psf , ucptr , sizeof ( short ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * shortptr = GET_BE_SHORT ( ucptr ) ; else * shortptr = GET_LE_SHORT ( ucptr ) ; break ; case '3' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 3 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = GET_BE_3BYTE ( sixteen_bytes ) ; else * intptr = GET_LE_3BYTE ( sixteen_bytes ) ; break ; case '4' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * intptr = psf_get_be32 ( ucptr , 0 ) ; else * intptr = psf_get_le32 ( ucptr , 0 ) ; break ; case '8' : countptr = va_arg ( argptr , sf_count_t * ) ; * countptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 8 ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) countdata = psf_get_be64 ( sixteen_bytes , 0 ) ; else countdata = psf_get_le64 ( sixteen_bytes , 0 ) ; * countptr = countdata ; break ; case 'f' : floatptr = va_arg ( argptr , float * ) ; * floatptr = 0.0 ; byte_count += header_read ( psf , floatptr , sizeof ( float ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * floatptr = float32_be_read ( ( unsigned char * ) floatptr ) ; else * floatptr = float32_le_read ( ( unsigned char * ) floatptr ) ; break ; case 'd' : doubleptr = va_arg ( argptr , double * ) ; * doubleptr = 0.0 ; byte_count += header_read ( psf , doubleptr , sizeof ( double ) ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) * doubleptr = double64_be_read ( ( unsigned char * ) doubleptr ) ; else * doubleptr = double64_le_read ( ( unsigned char * ) doubleptr ) ; break ; case 's' : psf_log_printf ( psf , ""Formatconversion\'s\'notimplementedyet.\\n"" ) ; break ; case 'b' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ;  if ( count > 0 )  byte_count += header_read ( psf , charptr , count ) ; break ;  case 'G' :  charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ;  if ( count > 0 )  byte_count += header_gets ( psf , charptr , count ) ; break ; case 'z' : psf_log_printf ( psf , ""Formatconversion\'z\'notimplementedyet.\\n"" ) ; break ; case 'p' : count = va_arg ( argptr , size_t ) ;  header_seek ( psf , count , SEEK_SET ) ;  byte_count = count ; break ; case 'j' : count = va_arg ( argptr , size_t ) ; if ( count ) { header_seek ( psf , count , SEEK_CUR ) ;  byte_count += count ;  } ; break ; default : psf_log_printf ( psf , ""***Invalidformatspecifier`%c\'\\n"" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return byte_count ; }"," 0 , count = 0  ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ;  * ) ; * intptr = 0 ;  int * ) ; * intptr = 0  size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets  ( psf ,  break ; case 'z' : psf_log_printf ( psf , ""Formatconversion\'z\'notimplementedyet.\\n"" ) ; break ; case 'p' :  count = va_arg  size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j'  : count =  , count ,  SEEK_CUR ) ;  byte_count += count  ; break ;"
19,"CWE-476 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; if ( optstr ) { jas_eprintf ( ""warning:ignoringBMPdecoderoptions\\n"" ) ; } jas_eprintf ( ""THEBMPFORMATISNOTFULLYSUPPORTED!\\n"" ""THATIS,THEJASPERSOFTWARECANNOTDECODEALLTYPESOFBMPDATA.\\n"" ""IFYOUHAVEANYPROBLEMS,PLEASETRYCONVERTINGYOURIMAGEDATA\\n"" ""TOTHEPNMFORMAT,ANDUSINGTHISFORMATINSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannotgetheader\\n"" ) ; return 0 ; }  if ( ! ( info = bmp_getinfo ( in ) ) ) {  jas_eprintf ( ""cannotgetinfo\\n"" ) ; return 0 ;  }  if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:unsupportedBMPencoding\\n"" ) ; bmp_info_destroy ( info ) ; return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:possiblybadbitmapoffset?\\n"" ) ; return 0 ; } if ( n > 0 ) { jas_eprintf ( ""skippingunknowndatainBMPfile\\n"" ) ; if ( bmp_gobble ( in , n ) ) { bmp_info_destroy ( info ) ; return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { bmp_info_destroy ( info ) ; return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { bmp_info_destroy ( info ) ; jas_image_destroy ( image ) ; return 0 ; } bmp_info_destroy ( info ) ; return image ; }"," 0 ; } JAS_DBGLOG ( 1 , ( ""BMPheader:magic0x%x;siz%d;res1%d;res2%d;off%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ;  0 ; } JAS_DBGLOG ( 1 , ( ""BMPinformation:len%d;width%d;height%d;numplanes%d;"" ""depth%d;enctype%d;siz%d;hres%d;vres%d;numcolors%d;"" ""mincolors%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ;"
20,"CWE-352 static void doGet ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; if ( ACTION ( HOME ) ) { LOCK ( Run . mutex ) do_home ( res ) ; END_LOCK ;  } else if ( ACTION ( RUN ) ) {   handle_run ( req , res ) ;  } else if ( ACTION ( TEST ) ) {  is_monit_running ( res ) ;  } else if ( ACTION ( VIEWLOG ) ) { do_viewlog ( req , res ) ; } else if ( ACTION ( ABOUT ) ) { do_about ( res ) ; } else if ( ACTION ( FAVICON ) ) { printFavicon ( res ) ; } else if ( ACTION ( PING ) ) { do_ping ( res ) ; } else if ( ACTION ( GETID ) ) { do_getid ( res ) ;  } else if ( ACTION ( STATUS ) ) {  print_status ( req , res , 1 ) ; } else if ( ACTION ( STATUS2 ) ) { print_status ( req , res , 2 ) ; } else if ( ACTION ( SUMMARY ) ) { print_summary ( req , res ) ; } else if ( ACTION ( REPORT ) ) { _printReport ( req , res ) ; } else if ( ACTION ( DOACTION ) ) { handle_do_action ( req , res ) ; } else { handle_action ( req , res ) ; } }"," ( ACTION ( RUNTIME  ) ) {  ) ) { handle_runtime  ( req ,  { is_monit_running (  res ) ;  ; } else { handle_service  ( req ,"
21,"CWE-200 int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) { struct btrfs_path * path ; struct extent_buffer * leaf ; struct btrfs_file_extent_item * fi ; struct btrfs_key key ; struct btrfs_key found_key ; u64 extent_start = 0 ; u64 extent_num_bytes = 0 ; u64 extent_offset = 0 ; u64 item_end = 0 ; u64 last_size = new_size ; u32 found_type = ( u8 ) - 1 ; int found_extent ; int del_item ; int pending_del_nr = 0 ; int pending_del_slot = 0 ; int extent_type = - 1 ; int ret ; int err = 0 ; u64 ino = btrfs_ino ( inode ) ; u64 bytes_deleted = 0 ; bool be_nice = 0 ; bool should_throttle = 0 ; bool should_end = 0 ; BUG_ON ( new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY ) ; if ( ! btrfs_is_free_space_inode ( inode ) && test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) be_nice = 1 ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; path -> reada = - 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) btrfs_drop_extent_cache ( inode , ALIGN ( new_size , root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; if ( min_type == 0 && root == BTRFS_I ( inode ) -> root ) btrfs_kill_delayed_inode_items ( inode ) ; key . objectid = ino ; key . offset = ( u64 ) - 1 ; key . type = ( u8 ) - 1 ; search_again : if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { if ( btrfs_should_end_transaction ( trans , root ) ) { err = - EAGAIN ; goto error ; } } path -> leave_spinning = 1 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; goto out ; } if ( ret > 0 ) { if ( path -> slots [ 0 ] == 0 ) goto out ; path -> slots [ 0 ] -- ; } while ( 1 ) { fi = NULL ; leaf = path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; found_type = found_key . type ; if ( found_key . objectid != ino ) break ; if ( found_type < min_type ) break ; item_end = found_key . offset ; if ( found_type == BTRFS_EXTENT_DATA_KEY ) { fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_file_extent_item ) ; extent_type = btrfs_file_extent_type ( leaf , fi ) ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ; } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ; } item_end -- ; } if ( found_type > min_type ) { del_item = 1 ; } else { if ( item_end < new_size ) break ; if ( found_key . offset >= new_size ) del_item = 1 ; else del_item = 0 ; } found_extent = 0 ; if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ; if ( del_item ) last_size = found_key . offset ; else last_size = new_size ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { u64 num_dec ; extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; if ( ! del_item ) { u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ; extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ; btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ; num_dec = ( orig_num_bytes - extent_num_bytes ) ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { extent_num_bytes = btrfs_file_extent_disk_num_bytes ( leaf , fi ) ; extent_offset = found_key . offset - btrfs_file_extent_offset ( leaf , fi ) ; num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; if ( extent_start != 0 ) { found_extent = 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ; } } } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { if ( ! del_item &&  btrfs_file_extent_compression ( leaf , fi ) == 0 &&  btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { u32 size = new_size - found_key . offset ;  if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) )  inode_sub_bytes ( inode , item_end + 1 -  new_size ) ;  btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; size = btrfs_file_extent_calc_inline_size ( size ) ; btrfs_truncate_item ( root , path , size , 1 ) ; } else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) { inode_sub_bytes ( inode , item_end + 1 - found_key . offset ) ; } } delete : if ( del_item ) { if ( ! pending_del_nr ) { pending_del_slot = path -> slots [ 0 ] ; pending_del_nr = 1 ; } else if ( pending_del_nr && path -> slots [ 0 ] + 1 == pending_del_slot ) { pending_del_nr ++ ; pending_del_slot = path -> slots [ 0 ] ; } else { BUG ( ) ; } } else { break ; } should_throttle = 0 ; if ( found_extent && ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) ) { btrfs_set_path_blocking ( path ) ; bytes_deleted += extent_num_bytes ; ret = btrfs_free_extent ( trans , root , extent_start , extent_num_bytes , 0 , btrfs_header_owner ( leaf ) , ino , extent_offset , 0 ) ; BUG_ON ( ret ) ; if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) btrfs_async_run_delayed_refs ( root , trans -> delayed_ref_updates * 2 , 0 ) ; if ( be_nice ) { if ( truncate_space_check ( trans , root , extent_num_bytes ) ) { should_end = 1 ; } if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) { should_throttle = 1 ; } } } if ( found_type == BTRFS_INODE_ITEM_KEY ) break ; if ( path -> slots [ 0 ] == 0 || path -> slots [ 0 ] != pending_del_slot || should_throttle || should_end ) { if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto error ; } pending_del_nr = 0 ; } btrfs_release_path ( path ) ; if ( should_throttle ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } if ( should_end ) { err = - EAGAIN ; goto error ; } goto search_again ; } else { path -> slots [ 0 ] -- ; } } out : if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; } error : if ( root -> root_key . objectid != BTRFS_TREE_LOG_OBJECTID ) btrfs_ordered_update_i_size ( inode , last_size , NULL ) ; btrfs_free_path ( path ) ; if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } return err ; }"," ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if (  , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else  if ( test_bit  state ) ) {  1 - new_size  ) ; }"
22,CWE-119 void vp8_denoiser_free ( VP8_DENOISER * denoiser ) { int i ; assert ( denoiser ) ; for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_running_avg [ i ] ) ; } vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_mc_running_avg ) ;  } , yv12_mc_running_avg ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;
23,"CWE-59 static int get_default_root ( pool * p , int allow_symlinks , char * * root ) { config_rec * c = NULL ; char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; while ( c ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; } if ( dir ) { char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , ""/"" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ;  struct stat st ;  size_t pathlen ; path = dir ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\0' ; }  pr_fs_clear_cache ( ) ;  res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) {  xerrno = errno ;   pr_log_pri ( PR_LOG_WARNING , ""error:unabletocheck%s:%s"" , path ,  strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , ""error:DefaultRoot%sisasymlink(deniedbyAllowChrootSymlinks"" ""config)"" , path ) ; errno = EPERM ; return - 1 ; } } PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , ""notice:unabletouseDefaultRoot\'%s\'[resolvedto\'%s\']:%s"" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }"," 1 ] ;  size_t pathlen ;  '\\0' ; } res = is_symlink_path ( p , path , pathlen  ) ; if  0 ) { if ( errno == EPERM ) {  pr_log_pri ( PR_LOG_WARNING  ( PR_LOG_WARNING , ""error:DefaultRoot%sisasymlink"" ""(deniedbyAllowChrootSymlinksconfig)"" , path ) ; }  errno = EPERM"
24,"CWE-125 void isakmp_rfc3948_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 ) {  if ( length == 1 && bp [ 0 ] == 0xff ) {  ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ; return ; } if ( length < 4 ) { goto trunc ;  }  if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) { ND_PRINT ( ( ndo , ""NONESP-encap:"" ) ) ; isakmp_print ( ndo , bp + 4 , length - 4 , bp2 ) ; return ; } { int nh , enh , padlen ; int advance ; ND_PRINT ( ( ndo , ""UDP-encap:"" ) ) ; advance = esp_print ( ndo , bp , length , bp2 , & enh , & padlen ) ; if ( advance <= 0 ) return ; bp += advance ; length -= advance + padlen ; nh = enh & 0xff ; ip_print_inner ( ndo , bp , length , nh , bp2 ) ; return ; } trunc : ND_PRINT ( ( ndo , ""[|isakmp]"" ) ) ; return ; }", bp2 ) { ND_TCHECK ( bp [ 0 ] ) ;  trunc ; } ND_TCHECK ( bp [ 3 ] ) ;
25,"CWE-119 int vp8_full_search_sadx8 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; unsigned char * in_what ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ;  DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , sad_array8 , 8 ) ;  unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride ,  bestaddress , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 7 ) < col_max ) { int i ; fn_ptr -> sdx8f ( what , what_stride , check_here , in_what_stride , sad_array8 ) ; for ( i = 0 ; i < 8 ; i ++ ) { thissad = sad_array8 [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) {  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row * 8 ; this_mv . as_mv . col = best_mv -> as_mv . col * 8 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }"," + distance ; DECLARE_ALIGNED  ( 16 ,  16 , unsigned int , sad_array8 [ 8 ]  ) ; unsigned  bestaddress , in_what_stride  ) + mvsad_err_cost  check_here , in_what_stride  ) ; if"
26,CWE-000 void pin_remove ( struct fs_pin * pin ) { spin_lock ( & pin_lock ) ;  hlist_del ( & pin -> m_list ) ;   hlist_del ( & pin -> s_list ) ;  spin_unlock ( & pin_lock ) ; spin_lock_irq ( & pin -> wait . lock ) ; pin -> done = 1 ; wake_up_locked ( & pin -> wait ) ; spin_unlock_irq ( & pin -> wait . lock ) ; }, pin_lock ) ; hlist_del_init  ( & pin  m_list ) ; hlist_del_init  ( & pin
27,"CWE-264  static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf )  { int sock [ 2 ] = { - 1 , - 1 } ; pid_t qpid , cpid = - 1 ; FILE * pids_file = NULL ; bool answer = false , fail = false ; pids_file = open_pids_file ( contrl , cg ) ; if ( ! pids_file ) return false ; if ( socketpair ( AF_UNIX , SOCK_DGRAM , 0 , sock ) < 0 ) { perror ( ""socketpair"" ) ; goto out ; } cpid = fork ( ) ; if ( cpid == - 1 ) goto out ; if ( ! cpid ) { fclose ( pids_file ) ; pid_from_ns_wrapper ( sock [ 1 ] , tpid ) ; } const char * ptr = buf ; while ( sscanf ( ptr , ""%d"" , & qpid ) == 1 ) { struct ucred cred ; char v ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) { fprintf ( stderr , ""%s:errorwritingpidtochild:%s\\n"" , __func__ , strerror ( errno ) ) ; goto out ; } if ( recv_creds ( sock [ 0 ] , & cred , & v ) ) { if ( v == '0' ) {  if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 )  fail = true ; } } ptr = strchr ( ptr , '\\n' ) ; if ( ! ptr ) break ; ptr ++ ; } qpid = - 1 ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) fprintf ( stderr , ""Warning:failedtoaskchildtoexit\\n"" ) ; if ( ! fail ) answer = true ; out : if ( cpid != - 1 ) wait_for_pid ( cpid ) ; if ( sock [ 0 ] != - 1 ) { close ( sock [ 0 ] ) ; close ( sock [ 1 ] ) ; } if ( pids_file ) { if ( fclose ( pids_file ) != 0 ) answer = false ; } return answer ; }"," pid_t tpid , uid_t tuid ,  { if ( ! may_move_pid ( tpid , tuid ,  cred . pid  . pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid )"
28,"CWE-119 static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {  u_char * b , * s , * t , c ;  int i , proto ; const void * se ; if ( length <= 0 ) return ;  b = ( uint8_t * ) malloc ( length ) ;  if ( b == NULL ) return ;  for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) {  c = * s ++ ; if ( c == 0x7d ) {  if ( i > 1 ) {  i -- ;  c = * s ++ ^ 0x20 ;  } else continue ; } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; proto = * b ; switch ( proto ) { case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; default : break ; } if ( length < 2 ) goto trunc ; proto = EXTRACT_16BITS ( b ) ; switch ( proto ) { case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ; proto = EXTRACT_16BITS ( b + 2 ) ; handle_ppp ( ndo , proto , b + 4 , length - 4 ) ; break ; default : handle_ppp ( ndo , proto , b + 2 , length - 2 ) ; break ; } cleanup : ndo -> ndo_snapend = se ; free ( b ) ; return ; trunc : ndo -> ndo_snapend = se ; free ( b ) ; ND_PRINT ( ( ndo , ""[|ppp]"" ) ) ; }"," b , *  t , c  t , c ; const u_char * s  b = ( u_char  * ) malloc  ( s =  p , t  i > 0 && ND_TTEST ( * s )  if ( i <= 1 || ! ND_TTEST ( * s ) ) break ;  i -- ;  ++ ^ 0x20  ; } *"
29,CWE-617 void pci_lintr_deassert ( struct pci_vdev * dev ) {  assert ( dev -> lintr . pin > 0 ) ;  pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == ASSERTED ) { dev -> lintr . state = IDLE ; pci_irq_deassert ( dev ) ; } else if ( dev -> lintr . state == PENDING ) dev -> lintr . state = IDLE ; pthread_mutex_unlock ( & dev -> lintr . lock ) ; }," dev ) { if  ( dev ->  lintr . pin <= 0 ) { pr_warn ( ""%s:Invalidintrpinondev[%s]\\n"" , __func__ , dev -> name ) ; return ; }  pthread_mutex_lock ( &"
30,"CWE-310 static noinline int create_pending_snapshot ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info , struct btrfs_pending_snapshot * pending ) { struct btrfs_key key ; struct btrfs_root_item * new_root_item ; struct btrfs_root * tree_root = fs_info -> tree_root ; struct btrfs_root * root = pending -> root ; struct btrfs_root * parent_root ; struct btrfs_block_rsv * rsv ; struct inode * parent_inode ; struct btrfs_path * path ; struct btrfs_dir_item * dir_item ; struct dentry * parent ; struct dentry * dentry ; struct extent_buffer * tmp ; struct extent_buffer * old ; struct timespec cur_time = CURRENT_TIME ; int ret ; u64 to_reserve = 0 ; u64 index = 0 ; u64 objectid ; u64 root_flags ; uuid_le new_uuid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = pending -> error = - ENOMEM ; goto path_alloc_fail ; } new_root_item = kmalloc ( sizeof ( * new_root_item ) , GFP_NOFS ) ; if ( ! new_root_item ) { ret = pending -> error = - ENOMEM ; goto root_item_alloc_fail ; } ret = btrfs_find_free_objectid ( tree_root , & objectid ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } btrfs_reloc_pre_snapshot ( trans , pending , & to_reserve ) ; if ( to_reserve > 0 ) { ret = btrfs_block_rsv_add ( root , & pending -> block_rsv , to_reserve , BTRFS_RESERVE_NO_FLUSH ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } } ret = btrfs_qgroup_inherit ( trans , fs_info , root -> root_key . objectid , objectid , pending -> inherit ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } key . objectid = objectid ; key . offset = ( u64 ) - 1 ; key . type = BTRFS_ROOT_ITEM_KEY ; rsv = trans -> block_rsv ; trans -> block_rsv = & pending -> block_rsv ; dentry = pending -> dentry ; parent = dget_parent ( dentry ) ; parent_inode = parent -> d_inode ; parent_root = BTRFS_I ( parent_inode ) -> root ; record_root_in_trans ( trans , parent_root ) ; ret = btrfs_set_inode_index ( parent_inode , & index ) ; BUG_ON ( ret ) ; dir_item = btrfs_lookup_dir_item ( NULL , parent_root , path , btrfs_ino ( parent_inode ) , dentry -> d_name . name , dentry -> d_name . len , 0 ) ; if ( dir_item != NULL && ! IS_ERR ( dir_item ) ) { pending -> error = - EEXIST ; goto fail ; } else if ( IS_ERR ( dir_item ) ) { ret = PTR_ERR ( dir_item ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_release_path ( path ) ; ret = btrfs_run_delayed_items ( trans , root ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } record_root_in_trans ( trans , root ) ; btrfs_set_root_last_snapshot ( & root -> root_item , trans -> transid ) ; memcpy ( new_root_item , & root -> root_item , sizeof ( * new_root_item ) ) ; btrfs_check_and_init_root_item ( new_root_item ) ; root_flags = btrfs_root_flags ( new_root_item ) ; if ( pending -> readonly ) root_flags |= BTRFS_ROOT_SUBVOL_RDONLY ; else root_flags &= ~ BTRFS_ROOT_SUBVOL_RDONLY ; btrfs_set_root_flags ( new_root_item , root_flags ) ; btrfs_set_root_generation_v2 ( new_root_item , trans -> transid ) ; uuid_le_gen ( & new_uuid ) ; memcpy ( new_root_item -> uuid , new_uuid . b , BTRFS_UUID_SIZE ) ; memcpy ( new_root_item -> parent_uuid , root -> root_item . uuid , BTRFS_UUID_SIZE ) ; new_root_item -> otime . sec = cpu_to_le64 ( cur_time . tv_sec ) ; new_root_item -> otime . nsec = cpu_to_le32 ( cur_time . tv_nsec ) ; btrfs_set_root_otransid ( new_root_item , trans -> transid ) ; memset ( & new_root_item -> stime , 0 , sizeof ( new_root_item -> stime ) ) ; memset ( & new_root_item -> rtime , 0 , sizeof ( new_root_item -> rtime ) ) ; btrfs_set_root_stransid ( new_root_item , 0 ) ; btrfs_set_root_rtransid ( new_root_item , 0 ) ; old = btrfs_lock_root_node ( root ) ; ret = btrfs_cow_block ( trans , root , old , NULL , 0 , & old ) ; if ( ret ) { btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_set_lock_blocking ( old ) ; ret = btrfs_copy_root ( trans , root , old , & tmp , objectid ) ; btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } root -> force_cow = 1 ; smp_wmb ( ) ; btrfs_set_root_node ( new_root_item , tmp ) ; key . offset = trans -> transid ; ret = btrfs_insert_root ( trans , tree_root , & key , new_root_item ) ; btrfs_tree_unlock ( tmp ) ; free_extent_buffer ( tmp ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_add_root_ref ( trans , tree_root , objectid , parent_root -> root_key . objectid , btrfs_ino ( parent_inode ) , index , dentry -> d_name . name , dentry -> d_name . len ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } key . offset = ( u64 ) - 1 ; pending -> snap = btrfs_read_fs_root_no_name ( root -> fs_info , & key ) ; if ( IS_ERR ( pending -> snap ) ) { ret = PTR_ERR ( pending -> snap ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_reloc_post_snapshot ( trans , pending ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_run_delayed_refs ( trans , root , ( unsigned long ) - 1 ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_insert_dir_item ( trans , parent_root , dentry -> d_name . name , dentry -> d_name . len , parent_inode , & key , BTRFS_FT_DIR , index ) ;  BUG_ON ( ret == - EEXIST ) ;  if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + dentry -> d_name . len * 2 ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode_fallback ( trans , parent_root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; fail : dput ( parent ) ; trans -> block_rsv = rsv ; no_free_objectid : kfree ( new_root_item ) ; root_item_alloc_fail : btrfs_free_path ( path ) ; path_alloc_fail : btrfs_block_rsv_release ( root , & pending -> block_rsv , ( u64 ) - 1 ) ; return ret ; }", == - EEXIST || ret == - EOVERFLOW
31,"CWE-400 static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ;  int opts ;  Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } }  if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {  if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }"," text ; int result ; int  ; } } result =  js_regexec ( re  , opts ) ; if ( result < 0 ) js_error ( J , ""regexecfailed"" ) ; if ( result == 0"
32,"CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos )  {  if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }", pos ) { check_stack_depth ( ) ;
33,"CWE-125  int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  { if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ; Stream_Read_UINT16 ( s , fields -> Len ) ; Stream_Read_UINT16 ( s , fields -> MaxLen ) ; Stream_Read_UINT32 ( s , fields -> BufferOffset ) ; return 1 ; }",    static
34,"CWE-119 static vpx_codec_err_t decoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {  if ( ! ctx -> priv ) {   vpx_codec_alg_priv_t * alg_priv = vpx_memalign ( 32 , sizeof ( * alg_priv ) ) ;   if ( alg_priv == NULL )   return VPX_CODEC_MEM_ERROR ;  vp9_zero ( * alg_priv ) ;  ctx -> priv = ( vpx_codec_priv_t * ) alg_priv ;  ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = alg_priv ; ctx -> priv -> alg_priv -> si . sz = sizeof ( ctx -> priv -> alg_priv -> si ) ; ctx -> priv -> init_flags = ctx -> init_flags ;  if ( ctx -> config . dec ) {   ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ;   ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ;  } } return VPX_CODEC_OK ; }"," data ) { ( void ) data ;  { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1  , sizeof (  sizeof ( * priv  ) ) ;  ; if ( priv  == NULL )  ) return VPX_CODEC_MEM_ERROR  ; ctx ->  vpx_codec_priv_t * ) priv  ; ctx ->  -> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> flushed = 0 ; priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ;  dec ) { priv  -> cfg =  dec = & priv  -> cfg ;"
35,"CWE-19 int xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; ASSERT ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; ASSERT ( name_loc -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; valuelen = be16_to_cpu ( name_loc -> valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; ASSERT ( name_rmt -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ;  valuelen = be32_to_cpu ( name_rmt -> valuelen ) ;  args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount ,  valuelen ) ;  if ( args -> flags & ATTR_KERNOVAL ) {  args -> valuelen = valuelen ;  return 0 ; }  if ( args -> valuelen < valuelen ) {  args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; }  args -> valuelen = valuelen ;  } return 0 ; }"," 0 ) ; args -> rmtvaluelen  = be32_to_cpu (  -> i_mount , args -> rmtvaluelen  ) ; if  -> valuelen = args -> rmtvaluelen  ; return 0  -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen  ; return XFS_ERROR  -> valuelen = args -> rmtvaluelen  ; } return"
36,"CWE-119 static bool parse_reconnect ( struct pool * pool , json_t * val ) {  char * sockaddr_url , * stratum_port , * tmp ;  char * url , * port , address [ 256 ] ;  if ( opt_disable_client_reconnect ) {  applog ( LOG_WARNING , ""Stratumclient.reconnectforbidden,aborting."" ) ; return false ; } memset ( address , 0 , 255 ) ;  url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ;  if ( ! url ) url = pool -> sockaddr_url ; port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ;  sprintf ( address , ""%s:%s"" , url , port ) ;  if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_NOTICE , ""Reconnectrequestedfrom%sto%s"" , get_pool_name ( pool ) , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }"," val ) { if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , ""Stratumclient.reconnectreceivedbutisdisabled,notreconnecting."" ) ; return false ; }  char * url  256 ] ; char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port  = ( char  ( val ,  1 ) )  -> stratum_port ; snprintf ( address , sizeof ( address )  , ""%s:%s"" ,"
37,"CWE-119 static int cmd_mount ( void * data , const char * _input ) { ut64 off = 0 ; char * input , * oinput , * ptr , * ptr2 ; RList * list ; RListIter * iter ; RFSFile * file ; RFSRoot * root ; RFSPlugin * plug ; RFSPartition * part ; RCore * core = ( RCore * ) data ; if ( ! strncmp ( ""kdir"" , _input , 4 ) ) { return cmd_mkdir ( data , _input ) ; } if ( ! strncmp ( ""v"" , _input , 1 ) ) { return cmd_mv ( data , _input ) ; } input = oinput = strdup ( _input ) ; switch ( * input ) { case '' : input ++ ; if ( input [ 0 ] == '' )  input ++ ;  ptr = strchr ( input , '' ) ; if ( ptr ) { * ptr = 0 ; ptr ++ ; ptr2 = strchr ( ptr , '' ) ; if ( ptr2 ) { * ptr2 = 0 ; off = r_num_math ( core -> num , ptr2 + 1 ) ; }  if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannotmount%s\\n"" , input ) ;  } else {   if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknownfilesystemtype\\n"" ) ;  else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannotmount%s\\n"" , input ) ;  free ( ptr ) ; } break ; case '-' : r_fs_umount ( core -> fs , input + 1 ) ; break ; case '*' : eprintf ( ""Listcommandsinradareformat\\n"" ) ; r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""m%s%s0x%"" PFMT64x ""\\n"" , root -> path , root -> p -> name , root -> delta ) ; } break ; case '\\0' : r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""%s\\t0x%"" PFMT64x ""\\t%s\\n"" , root -> p -> name , root -> delta , root -> path ) ; } break ; case 'l' : r_list_foreach ( core -> fs -> plugins , iter , plug ) { r_cons_printf ( ""%10s%s\\n"" , plug -> name , plug -> desc ) ; } break ; case 'd' : input ++ ; if ( input [ 0 ] == '' ) input ++ ; list = r_fs_dir ( core -> fs , input ) ; if ( list ) { r_list_foreach ( list , iter , file ) { r_cons_printf ( ""%c%s\\n"" , file -> type , file -> name ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannotopen\'%s\'directory\\n"" , input ) ; break ; case 'p' : input ++ ; if ( * input == '' ) input ++ ; ptr = strchr ( input , '' ) ; if ( ptr ) { * ptr = 0 ; off = r_num_math ( core -> num , ptr + 1 ) ; } list = r_fs_partitions ( core -> fs , input , off ) ; if ( list ) { r_list_foreach ( list , iter , part ) { r_cons_printf ( ""%d%02x0x%010"" PFMT64x ""0x%010"" PFMT64x ""\\n"" , part -> number , part -> type , part -> start , part -> start + part -> length ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannotreadpartition\\n"" ) ; break ; case 'o' : input ++ ; if ( input [ 0 ] == '' ) input ++ ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; r_cons_printf ( ""ffile%d0x%08"" PFMT64x ""\\n"" , file -> size , file -> off ) ; r_fs_close ( core -> fs , file ) ; } else eprintf ( ""Cannotopenfile\\n"" ) ; break ; case 'g' : input ++ ; if ( * input == '' ) input ++ ; ptr = strchr ( input , '' ) ; if ( ptr ) * ptr ++ = 0 ; else ptr = ""./"" ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; write ( 1 , file -> data , file -> size ) ; r_fs_close ( core -> fs , file ) ; write ( 1 , ""\\n"" , 1 ) ; } else if ( ! r_fs_dir_dump ( core -> fs , input , ptr ) ) eprintf ( ""Cannotopenfile\\n"" ) ; break ; case 'f' : input ++ ; switch ( * input ) { case '?' : r_cons_printf ( ""Usage:mf[no][...]\\n"" ""mfn/foo*.c;searchfilesbynamein/foopath\\n"" ""mfo/foo0x5e91;searchfilesbyoffsetin/foopath\\n"" ) ; break ; case 'n' : input ++ ; if ( * input == '' ) input ++ ; ptr = strchr ( input , '' ) ; if ( ptr ) { * ptr ++ = 0 ; list = r_fs_find_name ( core -> fs , input , ptr ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknownstorepath\\n"" ) ; break ; case 'o' : input ++ ; if ( * input == '' ) input ++ ; ptr = strchr ( input , '' ) ; if ( ptr ) { * ptr ++ = 0 ; ut64 off = r_num_math ( core -> num , ptr ) ; list = r_fs_find_off ( core -> fs , input , off ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknownstorepath\\n"" ) ; break ; } break ; case 's' : if ( core -> http_up ) { free ( oinput ) ; return false ; } input ++ ; if ( input [ 0 ] == '' ) input ++ ; r_fs_prompt ( core -> fs , input ) ; break ; case 'y' : eprintf ( ""TODO\\n"" ) ; break ; case '?' : { const char * help_msg [ ] = { ""Usage:"" , ""m[-?*dgy][...]"" , ""Mountpointsmanagement"" , ""m"" , """" , ""Listallmountpointsinhumanreadableformat"" , ""m*"" , """" , ""Sameasabove,butinr2commands"" , ""ml"" , """" , ""Listfilesystemplugins"" , ""m"" , ""/mnt"" , ""Mountfsat/mntwithautodetectfsandcurrentoffset"" , ""m"" , ""/mntext20"" , ""Mountext2fsat/mntwithdelta0onIO"" , ""m-/"" , """" , ""Umountgivenpath(/)"" , ""my"" , """" , ""Yankcontentsoffileintoclipboard"" , ""mo"" , ""/foo"" , ""Getoffsetandsizeofgivenfile"" , ""mg"" , ""/foo"" , ""Getcontentsoffile/dirdumpedtodisk(XXX?)"" , ""mf"" , ""[?][o|n]"" , ""Searchfilesforgivenfilenameorforoffset"" , ""md"" , ""/"" , ""Listdirectorycontentsforpath"" , ""mp"" , """" , ""Listallsupportedpartitiontypes"" , ""mp"" , ""msdos0"" , ""Showpartitionsinmsdosformatatoffset0"" , ""ms"" , ""/mnt"" , ""Openfilesystempromptat/mnt"" , NULL } ; r_core_cmd_help ( core , help_msg ) ; } break ; } free ( oinput ) ; return 0 ; }"," == '' ) { input ++ ; }  ptr = strchr  off ) ) {  ) ; } }  ) ) ) {  ""Unknownfilesystemtype\\n"" ) ; }  offset ) ) {  input ) ; }"
38,"CWE-20 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ;  while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) {  const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ;  for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) {  ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( struct pgstate * ) io ; } return ( ( u_char * ) ps <= ep ? 0 : - 1 ) ; }", >= 0 &&  ND_TTEST ( *  < ie &&  ND_TTEST ( *
39,"CWE-416 static void ext4_clamp_want_extra_isize ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ;  if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&  sbi -> s_want_extra_isize == 0 ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize >  sbi -> s_inode_size ) {  sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , ""requiredextrainodespacenotavailable"" ) ; } }", -> s_es ; unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ;  sbi -> s_inode_size == EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = 0 ; return ; } if ( sbi -> s_want_extra_isize < 4 ) { sbi -> s_want_extra_isize = def_extra_isize ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) ||  ( EXT4_GOOD_OLD_INODE_SIZE +  -> s_inode_size ) ) { sbi -> s_want_extra_isize = def_extra_isize  ; ext4_msg (
40,"CWE-264 static int rio_ioctl ( struct net_device * dev , struct ifreq * rq , int cmd ) { int phy_addr ; struct netdev_private * np = netdev_priv ( dev ) ;  struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;  struct netdev_desc * desc ; int i ; phy_addr = np -> phy_addr ; switch ( cmd ) {  case SIOCDEVPRIVATE :  break ;  case SIOCDEVPRIVATE + 1 :   miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;  break ;  case SIOCDEVPRIVATE + 2 :   mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ;  break ; case SIOCDEVPRIVATE + 3 : break ; case SIOCDEVPRIVATE + 4 : break ; case SIOCDEVPRIVATE + 5 : netif_stop_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 6 : netif_wake_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 7 : printk ( ""tx_full=%xcur_tx=%lxold_tx=%lxcur_rx=%lxold_rx=%lx\\n"" , netif_queue_stopped ( dev ) , np -> cur_tx , np -> old_tx , np -> cur_rx , np -> old_rx ) ; break ; case SIOCDEVPRIVATE + 8 : printk ( ""TXring:\\n"" ) ; for ( i = 0 ; i < TX_RING_SIZE ; i ++ ) { desc = & np -> tx_ring [ i ] ; printk ( ""%02x:cur:%08xnext:%08xstatus:%08xfrag1:%08xfrag0:%08x"" , i , ( u32 ) ( np -> tx_ring_dma + i * sizeof ( * desc ) ) , ( u32 ) le64_to_cpu ( desc -> next_desc ) , ( u32 ) le64_to_cpu ( desc -> status ) , ( u32 ) ( le64_to_cpu ( desc -> fraginfo ) >> 32 ) , ( u32 ) le64_to_cpu ( desc -> fraginfo ) ) ; printk ( ""\\n"" ) ; } printk ( ""\\n"" ) ; break ; default : return - EOPNOTSUPP ; } return 0 ; }"," ) ; struct mii_ioctl_data  * miidata =  * miidata = if_mii ( rq )  ; phy_addr =  ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ;  break ; case  break ; case SIOCGMIIREG  : miidata ->  : miidata -> val_out  = mii_read (  break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;  mii_write ( dev  , miidata -> val_in  ) ; break"
41,"CWE-416  int hns_nic_net_xmit_hw ( struct net_device * ndev ,  struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; struct hnae_ring * ring = ring_data -> ring ; struct device * dev = ring_to_dev ( ring ) ; struct netdev_queue * dev_queue ; struct skb_frag_struct * frag ; int buf_num ; int seg_num ; dma_addr_t dma ; int size , next_to_use ; int i ; switch ( priv -> ops . maybe_stop_tx ( & skb , & buf_num , ring ) ) { case - EBUSY : ring -> stats . tx_busy ++ ; goto out_net_tx_busy ; case - ENOMEM : ring -> stats . sw_err_cnt ++ ; netdev_err ( ndev , ""nomemorytoxmit!\\n"" ) ; goto out_err_tx_ok ; default : break ; } seg_num = skb_shinfo ( skb ) -> nr_frags + 1 ; next_to_use = ring -> next_to_use ; size = skb_headlen ( skb ) ; dma = dma_map_single ( dev , skb -> data , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , ""TXheadDMAmapfailed\\n"" ) ; ring -> stats . sw_err_cnt ++ ; goto out_err_tx_ok ; } priv -> ops . fill_desc ( ring , skb , size , dma , seg_num == 1 ? 1 : 0 , buf_num , DESC_TYPE_SKB , ndev -> mtu ) ; for ( i = 1 ; i < seg_num ; i ++ ) { frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; size = skb_frag_size ( frag ) ; dma = skb_frag_dma_map ( dev , frag , 0 , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , ""TXfrag(%d)DMAmapfailed\\n"" , i ) ; ring -> stats . sw_err_cnt ++ ; goto out_map_frag_fail ; } priv -> ops . fill_desc ( ring , skb_frag_page ( frag ) , size , dma , seg_num - 1 == i ? 1 : 0 , buf_num , DESC_TYPE_PAGE , ndev -> mtu ) ; } dev_queue = netdev_get_tx_queue ( ndev , skb -> queue_mapping ) ; netdev_tx_sent_queue ( dev_queue , skb -> len ) ;  wmb ( ) ;  assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ; hnae_queue_xmit ( priv -> ae_handle -> qs [ skb -> queue_mapping ] , buf_num ) ; ring -> stats . tx_pkts ++ ; ring -> stats . tx_bytes += skb -> len ; return NETDEV_TX_OK ; out_map_frag_fail : while ( ring -> next_to_use != next_to_use ) { unfill_desc ( ring ) ; if ( ring -> next_to_use != next_to_use ) dma_unmap_page ( dev , ring -> desc_cb [ ring -> next_to_use ] . dma , ring -> desc_cb [ ring -> next_to_use ] . length , DMA_TO_DEVICE ) ; else dma_unmap_single ( dev , ring -> desc_cb [ next_to_use ] . dma , ring -> desc_cb [ next_to_use ] . length , DMA_TO_DEVICE ) ; } out_err_tx_ok : dev_kfree_skb_any ( skb ) ; return NETDEV_TX_OK ; out_net_tx_busy : netif_stop_subqueue ( ndev , skb -> queue_mapping ) ; smp_mb ( ) ; return NETDEV_TX_BUSY ; }",    netdev_tx_t  hns_nic_net_xmit_hw ( struct  len ) ; netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ;
42,"CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( ""ping_unhash(isk=%p,isk->num=%u)\\n"" , isk , isk -> inet_num ) ;  if ( sk_hashed ( sk ) ) {   write_lock_bh ( & ping_table . lock ) ;  hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ;  write_unlock_bh ( & ping_table . lock ) ;  }  } ", inet_num ) ; write_lock_bh ( & ping_table . lock ) ;  ) ) {  hlist_nulls_del ( &  1 ) ; }  ) ; }    
43,"CWE-000 static int list_fields ( MYSQL * mysql , const char * db , const char * table , const char * wild ) {  char query [ 1024 ] , * end ;  MYSQL_RES * result ; MYSQL_ROW row ; ulong UNINIT_VAR ( rows ) ; if ( mysql_select_db ( mysql , db ) ) { fprintf ( stderr , ""%s:Cannotconnecttodb:%s:%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; return 1 ; } if ( opt_count ) {  sprintf ( query , ""selectcount(*)from`%s`"" , table ) ;  if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:Cannotgetrecordcountfordb:%s,table:%s:%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } row = mysql_fetch_row ( result ) ; rows = ( ulong ) strtoull ( row [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( result ) ; }  end = strmov ( strmov ( strmov ( query , ""show/*!32332FULL*/columnsfrom`"" ) , table ) , ""`"" ) ;   if ( wild && wild [ 0 ] )  strxmov ( end , ""like\'"" , wild , ""\'"" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:Cannotlistcolumnsindb:%s,table:%s:%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } printf ( ""Database:%sTable:%s"" , db , table ) ; if ( opt_count ) printf ( ""Rows:%lu"" , rows ) ; if ( wild && wild [ 0 ] ) printf ( ""Wildcard:%s"" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; if ( opt_show_keys ) {  end = strmov ( strmov ( strmov ( query , ""showkeysfrom`"" ) , table ) , ""`"" ) ;  if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:Cannotlistkeysindb:%s,table:%s:%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } if ( mysql_num_rows ( result ) ) { print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; } else puts ( ""Tablehasnokeys"" ) ; } mysql_free_result ( result ) ; return 0 ; }"," char query [ NAME_LEN + 100 ] ; int len  ; MYSQL_RES *  opt_count ) { my_snprintf ( query , sizeof ( query )  , ""selectcount(*)from`%s`"" ,  ) ; } len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show/*!32332FULL*/columnsfrom`%s`"" , table  ) ; if  [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len  , ""like\'"" ,  opt_show_keys ) { my_snprintf ( query , sizeof ( query ) , ""showkeysfrom`%s`"" , table  ) ; if"
44,"CWE-119 static av_always_inline int vp78_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt , int is_vp7 ) { VP8Context * s = avctx -> priv_data ; int ret , i , referenced , num_jobs ; enum AVDiscard skip_thresh ;  VP8Frame * av_uninit ( curframe ) , * prev_frame ;  if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; else ret = vp8_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; if ( ret < 0 ) goto err ; prev_frame = s -> framep [ VP56_FRAME_CURRENT ] ; referenced = s -> update_last || s -> update_golden == VP56_FRAME_CURRENT || s -> update_altref == VP56_FRAME_CURRENT ; skip_thresh = ! referenced ? AVDISCARD_NONREF : ! s -> keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL ; if ( avctx -> skip_frame >= skip_thresh ) { s -> invisible = 1 ; memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; goto skip_decode ; } s -> deblock_filter = s -> filter . level && avctx -> skip_loop_filter < skip_thresh ; for ( i = 0 ; i < 5 ; i ++ ) if ( s -> frames [ i ] . tf . f -> data [ 0 ] && & s -> frames [ i ] != prev_frame && & s -> frames [ i ] != s -> framep [ VP56_FRAME_PREVIOUS ] && & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN ] && & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) vp8_release_frame ( s , & s -> frames [ i ] ) ; curframe = s -> framep [ VP56_FRAME_CURRENT ] = vp8_find_free_buffer ( s ) ; if ( ! s -> colorspace ) avctx -> colorspace = AVCOL_SPC_BT470BG ; if ( s -> fullrange ) avctx -> color_range = AVCOL_RANGE_JPEG ; else avctx -> color_range = AVCOL_RANGE_MPEG ; if ( ! s -> keyframe && ( ! s -> framep [ VP56_FRAME_PREVIOUS ] || ! s -> framep [ VP56_FRAME_GOLDEN ] || ! s -> framep [ VP56_FRAME_GOLDEN2 ] ) ) { av_log ( avctx , AV_LOG_WARNING , ""Discardinginterframewithoutapriorkeyframe!\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto err ; } curframe -> tf . f -> key_frame = s -> keyframe ; curframe -> tf . f -> pict_type = s -> keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ; if ( ( ret = vp8_alloc_frame ( s , curframe , referenced ) ) < 0 ) goto err ; if ( s -> update_altref != VP56_FRAME_NONE ) s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ s -> update_altref ] ; else s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ VP56_FRAME_GOLDEN2 ] ; if ( s -> update_golden != VP56_FRAME_NONE ) s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ s -> update_golden ] ; else s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ VP56_FRAME_GOLDEN ] ; if ( s -> update_last ) s -> next_framep [ VP56_FRAME_PREVIOUS ] = curframe ; else s -> next_framep [ VP56_FRAME_PREVIOUS ] = s -> framep [ VP56_FRAME_PREVIOUS ] ; s -> next_framep [ VP56_FRAME_CURRENT ] = curframe ; if ( avctx -> codec -> update_thread_context ) ff_thread_finish_setup ( avctx ) ; s -> linesize = curframe -> tf . f -> linesize [ 0 ] ; s -> uvlinesize = curframe -> tf . f -> linesize [ 1 ] ; memset ( s -> top_nnz , 0 , s -> mb_width * sizeof ( * s -> top_nnz ) ) ; if ( ! s -> mb_layout ) memset ( s -> macroblocks + s -> mb_height * 2 - 1 , 0 , ( s -> mb_width + 1 ) * sizeof ( * s -> macroblocks ) ) ; if ( ! s -> mb_layout && s -> keyframe ) memset ( s -> intra4x4_pred_mode_top , DC_PRED , s -> mb_width * 4 ) ; memset ( s -> ref_count , 0 , sizeof ( s -> ref_count ) ) ; if ( s -> mb_layout == 1 ) { if ( prev_frame && s -> segmentation . enabled && ! s -> segmentation . update_map ) ff_thread_await_progress ( & prev_frame -> tf , 1 , 0 ) ; if ( is_vp7 ) vp7_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; else vp8_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; } if ( avctx -> active_thread_type == FF_THREAD_FRAME ) num_jobs = 1 ; else num_jobs = FFMIN ( s -> num_coeff_partitions , avctx -> thread_count ) ; s -> num_jobs = num_jobs ; s -> curframe = curframe ; s -> prev_frame = prev_frame ; s -> mv_bounds . mv_min . y = - MARGIN ; s -> mv_bounds . mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; for ( i = 0 ; i < MAX_THREADS ; i ++ ) { VP8ThreadData * td = & s -> thread_data [ i ] ; atomic_init ( & td -> thread_mb_pos , 0 ) ; atomic_init ( & td -> wait_mb_pos , INT_MAX ) ; } if ( is_vp7 ) avctx -> execute2 ( avctx , vp7_decode_mb_row_sliced , s -> thread_data , NULL , num_jobs ) ; else avctx -> execute2 ( avctx , vp8_decode_mb_row_sliced , s -> thread_data , NULL , num_jobs ) ; ff_thread_report_progress ( & curframe -> tf , INT_MAX , 0 ) ; memcpy ( & s -> framep [ 0 ] , & s -> next_framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; skip_decode : if ( ! s -> update_probabilities ) s -> prob [ 0 ] = s -> prob [ 1 ] ; if ( ! s -> invisible ) { if ( ( ret = av_frame_ref ( data , curframe -> tf . f ) ) < 0 ) return ret ; * got_frame = 1 ; } return avpkt -> size ; err : memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; return ret ; }"," , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )"
45,"CWE-264 static ssize_t ib_ucm_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ib_ucm_file * file = filp -> private_data ; struct ib_ucm_cmd_hdr hdr ;  ssize_t result ;  if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucm_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; result = ucm_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! result ) result = len ; return result ; }", ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
46,CWE-119 void vpx_img_free ( vpx_image_t * img ) { if ( img ) { if ( img -> img_data && img -> img_data_owner )  img_buf_free ( img -> img_data ) ;  if ( img -> self_allocd ) free ( img ) ; } }, -> img_data_owner ) vpx_free  ( img ->
47,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {  l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;  } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }", opj_calloc ( ( size_t ) (  -> numlayers + 1U  ) * l_step_l
48,"CWE-59 static int get_default_root ( pool * p , int allow_symlinks , const char * * root ) { config_rec * c = NULL ; const char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; while ( c != NULL ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , ""DefaultRoot"" , FALSE ) ; } if ( dir != NULL ) { const char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , ""/"" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ;  struct stat st ;  size_t pathlen ; path = pstrdup ( p , dir ) ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\0' ; }  pr_fs_clear_cache2 ( path ) ;  res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) {  xerrno = errno ;   pr_log_pri ( PR_LOG_WARNING , ""error:unabletocheck%s:%s"" , path ,  strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , ""error:DefaultRoot%sisasymlink(deniedbyAllowChrootSymlinks"" ""config)"" , path ) ; errno = EPERM ; return - 1 ; } } pr_fs_clear_cache2 ( dir ) ; PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , ""notice:unabletouseDefaultRoot\'%s\'[resolvedto\'%s\']:%s"" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }"," 1 ] ;  size_t pathlen ;  '\\0' ; } res = is_symlink_path ( p , path , pathlen  ) ; if  0 ) { if ( errno == EPERM ) {  pr_log_pri ( PR_LOG_WARNING  ( PR_LOG_WARNING , ""error:DefaultRoot%sisasymlink"" ""(deniedbyAllowChrootSymlinksconfig)"" , path ) ; }  errno = EPERM"
49,"CWE-399 static int sctp_process_param ( struct sctp_association * asoc , union sctp_params param , const union sctp_addr * peer_addr , gfp_t gfp ) { struct net * net = sock_net ( asoc -> base . sk ) ; union sctp_addr addr ; int i ; __u16 sat ; int retval = 1 ; sctp_scope_t scope ; time_t stale ; struct sctp_af * af ; union sctp_addr_param * addr_param ; struct sctp_transport * t ; struct sctp_endpoint * ep = asoc -> ep ; switch ( param . p -> type ) { case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 != asoc -> base . sk -> sk_family ) break ; goto do_addr_param ; case SCTP_PARAM_IPV4_ADDRESS : if ( ipv6_only_sock ( asoc -> base . sk ) ) break ; do_addr_param : af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; af -> from_addr_param ( & addr , param . addr , htons ( asoc -> peer . port ) , 0 ) ; scope = sctp_scope ( peer_addr ) ; if ( sctp_in_scope ( net , & addr , scope ) ) if ( ! sctp_assoc_add_peer ( asoc , & addr , gfp , SCTP_UNCONFIRMED ) ) return 0 ; break ; case SCTP_PARAM_COOKIE_PRESERVATIVE : if ( ! net -> sctp . cookie_preserve_enable ) break ; stale = ntohl ( param . life -> lifespan_increment ) ; asoc -> cookie_life = ktime_add_ms ( asoc -> cookie_life , stale ) ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : pr_debug ( ""%s:unimplementedSCTP_HOST_NAME_ADDRESS\\n"" , __func__ ) ; break ; case SCTP_PARAM_SUPPORTED_ADDRESS_TYPES : asoc -> peer . ipv4_address = 0 ; asoc -> peer . ipv6_address = 0 ; if ( peer_addr -> sa . sa_family == AF_INET6 ) asoc -> peer . ipv6_address = 1 ; else if ( peer_addr -> sa . sa_family == AF_INET ) asoc -> peer . ipv4_address = 1 ; sat = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; if ( sat ) sat /= sizeof ( __u16 ) ; for ( i = 0 ; i < sat ; ++ i ) { switch ( param . sat -> types [ i ] ) { case SCTP_PARAM_IPV4_ADDRESS : asoc -> peer . ipv4_address = 1 ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 == asoc -> base . sk -> sk_family ) asoc -> peer . ipv6_address = 1 ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : asoc -> peer . hostname_address = 1 ; break ; default : break ; } } break ; case SCTP_PARAM_STATE_COOKIE : asoc -> peer . cookie_len = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; asoc -> peer . cookie = param . cookie -> body ; break ; case SCTP_PARAM_HEARTBEAT_INFO : break ; case SCTP_PARAM_UNRECOGNIZED_PARAMETERS : break ; case SCTP_PARAM_ECN_CAPABLE : asoc -> peer . ecn_capable = 1 ; break ; case SCTP_PARAM_ADAPTATION_LAYER_IND : asoc -> peer . adaptation_ind = ntohl ( param . aind -> adaptation_ind ) ; break ; case SCTP_PARAM_SET_PRIMARY : if ( ! net -> sctp . addip_enable ) goto fall_through ; addr_param = param . v + sizeof ( sctp_addip_param_t ) ; af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ;  af -> from_addr_param ( & addr , addr_param ,  htons ( asoc -> peer . port ) , 0 ) ; if ( ! af -> addr_valid ( & addr , NULL , NULL ) ) break ; t = sctp_assoc_lookup_paddr ( asoc , & addr ) ; if ( ! t ) break ; sctp_assoc_set_primary ( asoc , t ) ; break ; case SCTP_PARAM_SUPPORTED_EXT : sctp_process_ext_param ( asoc , param ) ; break ; case SCTP_PARAM_FWD_TSN_SUPPORT : if ( net -> sctp . prsctp_enable ) { asoc -> peer . prsctp_capable = 1 ; break ; } goto fall_through ; case SCTP_PARAM_RANDOM : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_random = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_random ) { retval = 0 ; break ; } break ; case SCTP_PARAM_HMAC_ALGO : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_hmacs = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_hmacs ) { retval = 0 ; break ; } sctp_auth_asoc_set_default_hmac ( asoc , param . hmac_algo ) ; break ; case SCTP_PARAM_CHUNKS : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_chunks = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_chunks ) retval = 0 ; break ; fall_through : default : pr_debug ( ""%s:ignoringparam:%dforassociation:%p.\\n"" , __func__ , ntohs ( param . p -> type ) , asoc ) ; break ; } return retval ; }", ) ) ; if ( af == NULL ) break ;
50,"CWE-119 MagickBooleanType sixel_decode ( unsigned char * p , unsigned char * * pixels , size_t * pwidth , size_t * pheight , unsigned char * * palette , size_t * ncolors ) { int n , i , r , g , b , sixel_vertical_mask , c ; int posision_x , posision_y ; int max_x , max_y ; int attributed_pan , attributed_pad ; int attributed_ph , attributed_pv ; int repeat_count , color_index , max_color_index = 2 , background_color_index ; int param [ 10 ] ; int sixel_palet [ SIXEL_PALETTE_MAX ] ; unsigned char * imbuf , * dmbuf ; int imsx , imsy ; int dmsx , dmsy ; int y ; posision_x = posision_y = 0 ; max_x = max_y = 0 ; attributed_pan = 2 ; attributed_pad = 1 ; attributed_ph = attributed_pv = 0 ; repeat_count = 1 ; color_index = 0 ; background_color_index = 0 ; imsx = 2048 ; imsy = 2048 ;  imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ;  if ( imbuf == NULL ) { return ( MagickFalse ) ; } for ( n = 0 ; n < 16 ; n ++ ) { sixel_palet [ n ] = sixel_default_color_table [ n ] ; } for ( r = 0 ; r < 6 ; r ++ ) { for ( g = 0 ; g < 6 ; g ++ ) { for ( b = 0 ; b < 6 ; b ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( r * 51 , g * 51 , b * 51 ) ; } } } for ( i = 0 ; i < 24 ; i ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( i * 11 , i * 11 , i * 11 ) ; } for ( ; n < SIXEL_PALETTE_MAX ; n ++ ) { sixel_palet [ n ] = SIXEL_RGB ( 255 , 255 , 255 ) ; }  ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ;  while ( * p != '\\0' ) { if ( ( p [ 0 ] == '\\033' && p [ 1 ] == 'P' ) || * p == 0x90 ) { if ( * p == '\\033' ) { p ++ ; } p = get_params ( ++ p , param , & n ) ; if ( * p == 'q' ) { p ++ ; if ( n > 0 ) { switch ( param [ 0 ] ) { case 0 : case 1 : attributed_pad = 2 ; break ; case 2 : attributed_pad = 5 ; break ; case 3 : attributed_pad = 4 ; break ; case 4 : attributed_pad = 4 ; break ; case 5 : attributed_pad = 3 ; break ; case 6 : attributed_pad = 3 ; break ; case 7 : attributed_pad = 2 ; break ; case 8 : attributed_pad = 2 ; break ; case 9 : attributed_pad = 1 ; break ; } } if ( n > 2 ) { if ( param [ 2 ] == 0 ) { param [ 2 ] = 10 ; } attributed_pan = attributed_pan * param [ 2 ] / 10 ; attributed_pad = attributed_pad * param [ 2 ] / 10 ; if ( attributed_pan <= 0 ) attributed_pan = 1 ; if ( attributed_pad <= 0 ) attributed_pad = 1 ; } } } else if ( ( p [ 0 ] == '\\033' && p [ 1 ] == '\\\\' ) || * p == 0x9C ) { break ; } else if ( * p == \'""\' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) attributed_pad = param [ 0 ] ; if ( n > 1 ) attributed_pan = param [ 1 ] ; if ( n > 2 && param [ 2 ] > 0 ) attributed_ph = param [ 2 ] ; if ( n > 3 && param [ 3 ] > 0 ) attributed_pv = param [ 3 ] ; if ( attributed_pan <= 0 ) attributed_pan = 1 ; if ( attributed_pad <= 0 ) attributed_pad = 1 ; if ( imsx < attributed_ph || imsy < attributed_pv ) { dmsx = imsx > attributed_ph ? imsx : attributed_ph ; dmsy = imsy > attributed_pv ? imsy : attributed_pv ;  dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ;  if ( dmbuf == ( unsigned char * ) NULL ) { imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; }  ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ;  for ( y = 0 ; y < imsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } } else if ( * p == '!' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) { repeat_count = param [ 0 ] ; } } else if ( * p == '#' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) { if ( ( color_index = param [ 0 ] ) < 0 ) { color_index = 0 ; } else if ( color_index >= SIXEL_PALETTE_MAX ) { color_index = SIXEL_PALETTE_MAX - 1 ; } } if ( n > 4 ) { if ( param [ 1 ] == 1 ) { if ( param [ 2 ] > 360 ) param [ 2 ] = 360 ; if ( param [ 3 ] > 100 ) param [ 3 ] = 100 ; if ( param [ 4 ] > 100 ) param [ 4 ] = 100 ; sixel_palet [ color_index ] = hls_to_rgb ( param [ 2 ] * 100 / 360 , param [ 3 ] , param [ 4 ] ) ; } else if ( param [ 1 ] == 2 ) { if ( param [ 2 ] > 100 ) param [ 2 ] = 100 ; if ( param [ 3 ] > 100 ) param [ 3 ] = 100 ; if ( param [ 4 ] > 100 ) param [ 4 ] = 100 ; sixel_palet [ color_index ] = SIXEL_XRGB ( param [ 2 ] , param [ 3 ] , param [ 4 ] ) ; } } } else if ( * p == '$' ) { p ++ ; posision_x = 0 ; repeat_count = 1 ; } else if ( * p == '-' ) { p ++ ; posision_x = 0 ; posision_y += 6 ; repeat_count = 1 ; } else if ( * p >= '?' && * p <= '\\177' ) { if ( imsx < ( posision_x + repeat_count ) || imsy < ( posision_y + 6 ) ) { int nx = imsx * 2 ; int ny = imsy * 2 ; while ( nx < ( posision_x + repeat_count ) || ny < ( posision_y + 6 ) ) { nx *= 2 ; ny *= 2 ; } dmsx = nx ; dmsy = ny ;  dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ;  if ( dmbuf == ( unsigned char * ) NULL ) { imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; }  ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ;  for ( y = 0 ; y < imsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } if ( color_index > max_color_index ) { max_color_index = color_index ; } if ( ( b = * ( p ++ ) - '?' ) == 0 ) { posision_x += repeat_count ; } else { sixel_vertical_mask = 0x01 ; if ( repeat_count <= 1 ) { for ( i = 0 ; i < 6 ; i ++ ) { if ( ( b & sixel_vertical_mask ) != 0 ) { imbuf [ imsx * ( posision_y + i ) + posision_x ] = color_index ; if ( max_x < posision_x ) { max_x = posision_x ; } if ( max_y < ( posision_y + i ) ) { max_y = posision_y + i ; } } sixel_vertical_mask <<= 1 ; } posision_x += 1 ; } else { for ( i = 0 ; i < 6 ; i ++ ) { if ( ( b & sixel_vertical_mask ) != 0 ) { c = sixel_vertical_mask << 1 ; for ( n = 1 ; ( i + n ) < 6 ; n ++ ) { if ( ( b & c ) == 0 ) { break ; } c <<= 1 ; } for ( y = posision_y + i ; y < posision_y + i + n ; ++ y ) {  ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ;  } if ( max_x < ( posision_x + repeat_count - 1 ) ) { max_x = posision_x + repeat_count - 1 ; } if ( max_y < ( posision_y + i + n - 1 ) ) { max_y = posision_y + i + n - 1 ; } i += ( n - 1 ) ; sixel_vertical_mask <<= ( n - 1 ) ; } sixel_vertical_mask <<= 1 ; } posision_x += repeat_count ; } } repeat_count = 1 ; } else { p ++ ; } } if ( ++ max_x < attributed_ph ) { max_x = attributed_ph ; } if ( ++ max_y < attributed_pv ) { max_y = attributed_pv ; } if ( imsx > max_x || imsy > max_y ) { dmsx = max_x ; dmsy = max_y ;  if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) {  imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } for ( y = 0 ; y < dmsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , dmsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } * pixels = imbuf ; * pwidth = imsx ; * pheight = imsy ; * ncolors = max_color_index + 1 ; * palette = ( unsigned char * ) AcquireQuantumMemory ( * ncolors , 4 ) ; for ( n = 0 ; n < ( ssize_t ) * ncolors ; ++ n ) { ( * palette ) [ n * 4 + 0 ] = sixel_palet [ n ] >> 16 & 0xff ; ( * palette ) [ n * 4 + 1 ] = sixel_palet [ n ] >> 8 & 0xff ; ( * palette ) [ n * 4 + 2 ] = sixel_palet [ n ] & 0xff ; ( * palette ) [ n * 4 + 3 ] = 0xff ; } return ( MagickTrue ) ; }"," AcquireQuantumMemory ( imsx , imsy  ) ; if  , background_color_index , ( size_t )  AcquireQuantumMemory ( dmsx , dmsy  ) ; if  , background_color_index , ( size_t )  AcquireQuantumMemory ( dmsx , dmsy  ) ; if  , background_color_index , ( size_t )  ( imbuf + ( size_t )  AcquireQuantumMemory ( dmsx , dmsy  ) ) =="
51,"CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , ""INVALID-PAYLOAD-TYPE"" , ""DOI-NOT-SUPPORTED"" , ""SITUATION-NOT-SUPPORTED"" , ""INVALID-COOKIE"" , ""INVALID-MAJOR-VERSION"" , ""INVALID-MINOR-VERSION"" , ""INVALID-EXCHANGE-TYPE"" , ""INVALID-FLAGS"" , ""INVALID-MESSAGE-ID"" , ""INVALID-PROTOCOL-ID"" , ""INVALID-SPI"" , ""INVALID-TRANSFORM-ID"" , ""ATTRIBUTES-NOT-SUPPORTED"" , ""NO-PROPOSAL-CHOSEN"" , ""BAD-PROPOSAL-SYNTAX"" , ""PAYLOAD-MALFORMED"" , ""INVALID-KEY-INFORMATION"" , ""INVALID-ID-INFORMATION"" , ""INVALID-CERT-ENCODING"" , ""INVALID-CERTIFICATE"" , ""CERT-TYPE-UNSUPPORTED"" , ""INVALID-CERT-AUTHORITY"" , ""INVALID-HASH-INFORMATION"" , ""AUTHENTICATION-FAILED"" , ""INVALID-SIGNATURE"" , ""ADDRESS-NOTIFICATION"" , ""NOTIFY-SA-LIFETIME"" , ""CERTIFICATE-UNAVAILABLE"" , ""UNSUPPORTED-EXCHANGE-TYPE"" , ""UNEQUAL-PAYLOAD-LENGTHS"" , } ; static const char * ipsec_notify_error_str [ ] = { ""RESERVED"" , } ; static const char * notify_status_str [ ] = { ""CONNECTED"" , } ; static const char * ipsec_notify_status_str [ ] = { ""RESPONDER-LIFETIME"" , ""REPLAY-STATUS"" , ""INITIAL-CONTACT"" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , ""doi=%d"" , doi ) ) ; ND_PRINT ( ( ndo , ""proto=%d"" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , ""doi=ipsec"" ) ) ; ND_PRINT ( ( ndo , ""proto=%s"" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""type=%s"" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , ""type=%s"" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , ""attrs=("" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""status=("" ) ) ;  ND_PRINT ( ( ndo , ""replaydetection%sabled"" ,  EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }", ) ) ; ND_TCHECK_32BITS ( cp ) ;
52,"CWE-119 void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) {  ALOGE ( ""b/26366256"" ) ;  return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }"," ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"""
53,"CWE-74 static int einj_error_inject ( u32 type , u32 flags , u64 param1 , u64 param2 , u64 param3 , u64 param4 ) { int rc ;  u64 base_addr , size ;  if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ; if ( ! ( param_extension || acpi5 ) ) goto inject ; if ( type & ACPI5_VENDOR_BIT ) { if ( vendor_flags != SETWA_FLAGS_MEM ) goto inject ; } else if ( ! ( type & MEM_ERROR_MASK ) && ! ( flags & SETWA_FLAGS_MEM ) ) goto inject ; base_addr = param1 & param2 ; size = ~ param2 + 1 ; if ( ( ( param2 & PAGE_MASK ) != PAGE_MASK ) || ( ( region_intersects ( base_addr , size , IORESOURCE_SYSTEM_RAM , IORES_DESC_NONE ) != REGION_INTERSECTS ) && ( region_intersects ( base_addr , size , IORESOURCE_MEM , IORES_DESC_PERSISTENT_MEMORY ) != REGION_INTERSECTS ) ) ) return - EINVAL ; inject : mutex_lock ( & einj_mutex ) ; rc = __einj_error_inject ( type , flags , param1 , param2 , param3 , param4 ) ; mutex_unlock ( & einj_mutex ) ; return rc ; }"," base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM"
54,"CWE-190 rfbBool HandleCursorShape ( rfbClient * client , int xhot , int yhot , int width , int height , uint32_t enc ) { int bytesPerPixel ; size_t bytesPerRow , bytesMaskData ; rfbXCursorColors rgb ; uint32_t colors [ 2 ] ; char * buf ; uint8_t * ptr ; int x , y , b ; bytesPerPixel = client -> format . bitsPerPixel / 8 ; bytesPerRow = ( width + 7 ) / 8 ; bytesMaskData = bytesPerRow * height ; if ( width * height == 0 ) return TRUE ;  if ( client -> rcSource )  free ( client -> rcSource ) ; client -> rcSource = malloc ( width * height * bytesPerPixel ) ; if ( client -> rcSource == NULL ) return FALSE ; buf = malloc ( bytesMaskData ) ; if ( buf == NULL ) { free ( client -> rcSource ) ; client -> rcSource = NULL ; return FALSE ; } if ( enc == rfbEncodingXCursor ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rgb , sz_rfbXCursorColors ) ) { free ( client -> rcSource ) ; client -> rcSource = NULL ; free ( buf ) ; return FALSE ; } colors [ 0 ] = RGB24_TO_PIXEL ( 32 , rgb . backRed , rgb . backGreen , rgb . backBlue ) ; colors [ 1 ] = RGB24_TO_PIXEL ( 32 , rgb . foreRed , rgb . foreGreen , rgb . foreBlue ) ; if ( ! ReadFromRFBServer ( client , buf , bytesMaskData ) ) { free ( client -> rcSource ) ; client -> rcSource = NULL ; free ( buf ) ; return FALSE ; } ptr = client -> rcSource ; for ( y = 0 ; y < height ; y ++ ) { for ( x = 0 ; x < width / 8 ; x ++ ) { for ( b = 7 ; b >= 0 ; b -- ) { * ptr = buf [ y * bytesPerRow + x ] >> b & 1 ; ptr += bytesPerPixel ; } } for ( b = 7 ; b > 7 - width % 8 ; b -- ) { * ptr = buf [ y * bytesPerRow + x ] >> b & 1 ; ptr += bytesPerPixel ; } } switch ( bytesPerPixel ) { case 1 : for ( x = 0 ; x < width * height ; x ++ ) client -> rcSource [ x ] = ( uint8_t ) colors [ client -> rcSource [ x ] ] ; break ; case 2 : for ( x = 0 ; x < width * height ; x ++ ) ( ( uint16_t * ) client -> rcSource ) [ x ] = ( uint16_t ) colors [ client -> rcSource [ x * 2 ] ] ; break ; case 4 : for ( x = 0 ; x < width * height ; x ++ ) ( ( uint32_t * ) client -> rcSource ) [ x ] = colors [ client -> rcSource [ x * 4 ] ] ; break ; } } else { if ( ! ReadFromRFBServer ( client , ( char * ) client -> rcSource , width * height * bytesPerPixel ) ) { free ( client -> rcSource ) ; client -> rcSource = NULL ; free ( buf ) ; return FALSE ; } } if ( ! ReadFromRFBServer ( client , buf , bytesMaskData ) ) { free ( client -> rcSource ) ; client -> rcSource = NULL ; free ( buf ) ; return FALSE ; } client -> rcMask = malloc ( width * height ) ; if ( client -> rcMask == NULL ) { free ( client -> rcSource ) ; client -> rcSource = NULL ; free ( buf ) ; return FALSE ; } ptr = client -> rcMask ; for ( y = 0 ; y < height ; y ++ ) { for ( x = 0 ; x < width / 8 ; x ++ ) { for ( b = 7 ; b >= 0 ; b -- ) { * ptr ++ = buf [ y * bytesPerRow + x ] >> b & 1 ; } } for ( b = 7 ; b > 7 - width % 8 ; b -- ) { * ptr ++ = buf [ y * bytesPerRow + x ] >> b & 1 ; } } if ( client -> GotCursorShape != NULL ) { client -> GotCursorShape ( client , xhot , yhot , width , height , bytesPerPixel ) ; } free ( buf ) ; return TRUE ; }", ; if ( width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE ) return FALSE ; if (
55,"CWE-476 file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) { bee_t * bee = ic -> bee ; bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ;  if ( bee -> ui -> ft_in_start ) {  return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ; } else { return NULL ; } }", ui -> ft_in_start && bu
56,"CWE-190 static s32 gf_hevc_read_sps_bs_internal ( GF_BitStream * bs , HEVCState * hevc , u8 layer_id , u32 * vui_flag_pos ) { s32 vps_id , sps_id = - 1 ; u32 i , nb_CTUs , depth ; HEVC_SPS * sps ; HEVC_VPS * vps ; HEVC_ProfileTierLevel ptl ; Bool multiLayerExtSpsFlag ; u8 sps_ext_or_max_sub_layers_minus1 , max_sub_layers_minus1 ; if ( vui_flag_pos ) * vui_flag_pos = 0 ; vps_id = gf_bs_read_int_log ( bs , 4 , ""vps_id"" ) ;  if ( vps_id >= 16 ) {  return - 1 ; } memset ( & ptl , 0 , sizeof ( ptl ) ) ; max_sub_layers_minus1 = 0 ; sps_ext_or_max_sub_layers_minus1 = 0 ; if ( layer_id == 0 ) max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""max_sub_layers_minus1"" ) ; else sps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log ( bs , 3 , ""sps_ext_or_max_sub_layers_minus1"" ) ; multiLayerExtSpsFlag = ( layer_id != 0 ) && ( sps_ext_or_max_sub_layers_minus1 == 7 ) ; if ( ! multiLayerExtSpsFlag ) { gf_bs_read_int_log ( bs , 1 , ""temporal_id_nesting_flag"" ) ; hevc_profile_tier_level ( bs , 1 , max_sub_layers_minus1 , & ptl , 0 ) ; } sps_id = gf_bs_read_ue_log ( bs , ""sps_id"" ) ; if ( ( sps_id < 0 ) || ( sps_id >= 16 ) ) { return - 1 ; } sps = & hevc -> sps [ sps_id ] ; if ( ! sps -> state ) { sps -> state = 1 ; sps -> id = sps_id ; sps -> vps_id = vps_id ; } sps -> ptl = ptl ; vps = & hevc -> vps [ vps_id ] ; sps -> max_sub_layers_minus1 = 0 ; sps -> sps_ext_or_max_sub_layers_minus1 = 0 ; sps -> colour_primaries = 2 ; sps -> transfer_characteristic = 2 ; sps -> matrix_coeffs = 2 ; if ( multiLayerExtSpsFlag ) { sps -> update_rep_format_flag = gf_bs_read_int_log ( bs , 1 , ""update_rep_format_flag"" ) ; if ( sps -> update_rep_format_flag ) { sps -> rep_format_idx = gf_bs_read_int_log ( bs , 8 , ""rep_format_idx"" ) ; } else { sps -> rep_format_idx = vps -> rep_format_idx [ layer_id ] ; } sps -> width = vps -> rep_formats [ sps -> rep_format_idx ] . pic_width_luma_samples ; sps -> height = vps -> rep_formats [ sps -> rep_format_idx ] . pic_height_luma_samples ; sps -> chroma_format_idc = vps -> rep_formats [ sps -> rep_format_idx ] . chroma_format_idc ; sps -> bit_depth_luma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_luma ; sps -> bit_depth_chroma = vps -> rep_formats [ sps -> rep_format_idx ] . bit_depth_chroma ; sps -> separate_colour_plane_flag = vps -> rep_formats [ sps -> rep_format_idx ] . separate_colour_plane_flag ; sps -> ptl = vps -> ext_ptl [ 0 ] ; } else { sps -> chroma_format_idc = gf_bs_read_ue_log ( bs , ""chroma_format_idc"" ) ; if ( sps -> chroma_format_idc == 3 ) sps -> separate_colour_plane_flag = gf_bs_read_int_log ( bs , 1 , ""separate_colour_plane_flag"" ) ; sps -> width = gf_bs_read_ue_log ( bs , ""width"" ) ; sps -> height = gf_bs_read_ue_log ( bs , ""height"" ) ; if ( ( sps -> cw_flag = gf_bs_read_int_log ( bs , 1 , ""conformance_window_flag"" ) ) ) { u32 SubWidthC , SubHeightC ; if ( sps -> chroma_format_idc == 1 ) { SubWidthC = SubHeightC = 2 ; } else if ( sps -> chroma_format_idc == 2 ) { SubWidthC = 2 ; SubHeightC = 1 ; } else { SubWidthC = SubHeightC = 1 ; } sps -> cw_left = gf_bs_read_ue_log ( bs , ""conformance_window_left"" ) ; sps -> cw_right = gf_bs_read_ue_log ( bs , ""conformance_window_right"" ) ; sps -> cw_top = gf_bs_read_ue_log ( bs , ""conformance_window_top"" ) ; sps -> cw_bottom = gf_bs_read_ue_log ( bs , ""conformance_window_bottom"" ) ; sps -> width -= SubWidthC * ( sps -> cw_left + sps -> cw_right ) ; sps -> height -= SubHeightC * ( sps -> cw_top + sps -> cw_bottom ) ; } sps -> bit_depth_luma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_luma_minus8"" ) ; sps -> bit_depth_chroma = 8 + gf_bs_read_ue_log ( bs , ""bit_depth_chroma_minus8"" ) ; } sps -> log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log ( bs , ""log2_max_pic_order_cnt_lsb_minus4"" ) ; if ( ! multiLayerExtSpsFlag ) { sps -> sub_layer_ordering_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""sub_layer_ordering_info_present_flag"" ) ; for ( i = sps -> sub_layer_ordering_info_present_flag ? 0 : sps -> max_sub_layers_minus1 ; i <= sps -> max_sub_layers_minus1 ; i ++ ) { gf_bs_read_ue_log_idx ( bs , ""max_dec_pic_buffering"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""num_reorder_pics"" , i ) ; gf_bs_read_ue_log_idx ( bs , ""max_latency_increase"" , i ) ; } } sps -> log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log ( bs , ""log2_min_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_luma_coding_block_size"" ) ; sps -> max_CU_width = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> max_CU_height = ( 1 << ( sps -> log2_min_luma_coding_block_size + sps -> log2_diff_max_min_luma_coding_block_size ) ) ; sps -> log2_min_transform_block_size = 2 + gf_bs_read_ue_log ( bs , ""log2_min_transform_block_size_minus2"" ) ; sps -> log2_max_transform_block_size = sps -> log2_min_transform_block_size + gf_bs_read_ue_log ( bs , ""log2_max_transform_block_size"" ) ; depth = 0 ; sps -> max_transform_hierarchy_depth_inter = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_inter"" ) ; sps -> max_transform_hierarchy_depth_intra = gf_bs_read_ue_log ( bs , ""max_transform_hierarchy_depth_intra"" ) ; while ( ( u32 ) ( sps -> max_CU_width >> sps -> log2_diff_max_min_luma_coding_block_size ) > ( u32 ) ( 1 << ( sps -> log2_min_transform_block_size + depth ) ) ) { depth ++ ; } sps -> max_CU_depth = sps -> log2_diff_max_min_luma_coding_block_size + depth ; nb_CTUs = ( ( sps -> width + sps -> max_CU_width - 1 ) / sps -> max_CU_width ) * ( ( sps -> height + sps -> max_CU_height - 1 ) / sps -> max_CU_height ) ; sps -> bitsSliceSegmentAddress = 0 ; while ( nb_CTUs > ( u32 ) ( 1 << sps -> bitsSliceSegmentAddress ) ) { sps -> bitsSliceSegmentAddress ++ ; } sps -> scaling_list_enable_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_enable_flag"" ) ; if ( sps -> scaling_list_enable_flag ) { sps -> infer_scaling_list_flag = 0 ; sps -> scaling_list_ref_layer_id = 0 ; if ( multiLayerExtSpsFlag ) { sps -> infer_scaling_list_flag = gf_bs_read_int_log ( bs , 1 , ""infer_scaling_list_flag"" ) ; } if ( sps -> infer_scaling_list_flag ) { sps -> scaling_list_ref_layer_id = gf_bs_read_int_log ( bs , 6 , ""scaling_list_ref_layer_id"" ) ; } else { sps -> scaling_list_data_present_flag = gf_bs_read_int_log ( bs , 1 , ""scaling_list_data_present_flag"" ) ; if ( sps -> scaling_list_data_present_flag ) { hevc_scaling_list_data ( bs ) ; } } } sps -> asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""asymmetric_motion_partitions_enabled_flag"" ) ; sps -> sample_adaptive_offset_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""sample_adaptive_offset_enabled_flag"" ) ; if ( ( sps -> pcm_enabled_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_enabled_flag"" ) ) ) { sps -> pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_luma_minus1"" ) ; sps -> pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log ( bs , 4 , ""pcm_sample_bit_depth_chroma_minus1"" ) ; sps -> log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log ( bs , ""log2_min_pcm_luma_coding_block_size_minus3"" ) ; sps -> log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log ( bs , ""log2_diff_max_min_pcm_luma_coding_block_size"" ) ; sps -> pcm_loop_filter_disable_flag = gf_bs_read_int_log ( bs , 1 , ""pcm_loop_filter_disable_flag"" ) ; } sps -> num_short_term_ref_pic_sets = gf_bs_read_ue_log ( bs , ""num_short_term_ref_pic_sets"" ) ; if ( sps -> num_short_term_ref_pic_sets > 64 ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( ""[HEVC]Invalidnumberofshorttermreferencepicturesets%d\\n"" , sps -> num_short_term_ref_pic_sets ) ) ; return - 1 ; } for ( i = 0 ; i < sps -> num_short_term_ref_pic_sets ; i ++ ) { Bool ret = hevc_parse_short_term_ref_pic_set ( bs , sps , i ) ; if ( ! ret ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CODING , ( ""[HEVC]Invalidshort_term_ref_pic_set\\n"" ) ) ; return - 1 ; } } sps -> long_term_ref_pics_present_flag = gf_bs_read_int_log ( bs , 1 , ""long_term_ref_pics_present_flag"" ) ; if ( sps -> long_term_ref_pics_present_flag ) { sps -> num_long_term_ref_pic_sps = gf_bs_read_ue_log ( bs , ""num_long_term_ref_pic_sps"" ) ; for ( i = 0 ; i < sps -> num_long_term_ref_pic_sps ; i ++ ) { gf_bs_read_int_log_idx ( bs , sps -> log2_max_pic_order_cnt_lsb , ""lt_ref_pic_poc_lsb_sps"" , i ) ; gf_bs_read_int_log_idx ( bs , 1 , ""used_by_curr_pic_lt_sps_flag"" , i ) ; } } sps -> temporal_mvp_enable_flag = gf_bs_read_int_log ( bs , 1 , ""temporal_mvp_enable_flag"" ) ; sps -> strong_intra_smoothing_enable_flag = gf_bs_read_int_log ( bs , 1 , ""strong_intra_smoothing_enable_flag"" ) ; if ( vui_flag_pos ) * vui_flag_pos = ( u32 ) gf_bs_get_bit_offset ( bs ) ; if ( ( sps -> vui_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""vui_parameters_present_flag"" ) ) ) { sps -> aspect_ratio_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""aspect_ratio_info_present_flag"" ) ; if ( sps -> aspect_ratio_info_present_flag ) { sps -> sar_idc = gf_bs_read_int_log ( bs , 8 , ""aspect_ratio_idc"" ) ; if ( sps -> sar_idc == 255 ) { sps -> sar_width = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_width"" ) ; sps -> sar_height = gf_bs_read_int_log ( bs , 16 , ""aspect_ratio_height"" ) ; } else if ( sps -> sar_idc < 17 ) { sps -> sar_width = hevc_sar [ sps -> sar_idc ] . w ; sps -> sar_height = hevc_sar [ sps -> sar_idc ] . h ; } } if ( ( sps -> overscan_info_present = gf_bs_read_int_log ( bs , 1 , ""overscan_info_present"" ) ) ) sps -> overscan_appropriate = gf_bs_read_int_log ( bs , 1 , ""overscan_appropriate"" ) ; sps -> video_signal_type_present_flag = gf_bs_read_int_log ( bs , 1 , ""video_signal_type_present_flag"" ) ; if ( sps -> video_signal_type_present_flag ) { sps -> video_format = gf_bs_read_int_log ( bs , 3 , ""video_format"" ) ; sps -> video_full_range_flag = gf_bs_read_int_log ( bs , 1 , ""video_full_range_flag"" ) ; if ( ( sps -> colour_description_present_flag = gf_bs_read_int_log ( bs , 1 , ""colour_description_present_flag"" ) ) ) { sps -> colour_primaries = gf_bs_read_int_log ( bs , 8 , ""colour_primaries"" ) ; sps -> transfer_characteristic = gf_bs_read_int_log ( bs , 8 , ""transfer_characteristic"" ) ; sps -> matrix_coeffs = gf_bs_read_int_log ( bs , 8 , ""matrix_coefficients"" ) ; } } if ( ( sps -> chroma_loc_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""chroma_loc_info_present_flag"" ) ) ) { sps -> chroma_sample_loc_type_top_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_top_field"" ) ; sps -> chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log ( bs , ""chroma_sample_loc_type_bottom_field"" ) ; } sps -> neutra_chroma_indication_flag = gf_bs_read_int_log ( bs , 1 , ""neutra_chroma_indication_flag"" ) ; sps -> field_seq_flag = gf_bs_read_int_log ( bs , 1 , ""field_seq_flag"" ) ; sps -> frame_field_info_present_flag = gf_bs_read_int_log ( bs , 1 , ""frame_field_info_present_flag"" ) ; if ( ( sps -> default_display_window_flag = gf_bs_read_int_log ( bs , 1 , ""default_display_window_flag"" ) ) ) { sps -> left_offset = gf_bs_read_ue_log ( bs , ""display_window_left_offset"" ) ; sps -> right_offset = gf_bs_read_ue_log ( bs , ""display_window_right_offset"" ) ; sps -> top_offset = gf_bs_read_ue_log ( bs , ""display_window_top_offset"" ) ; sps -> bottom_offset = gf_bs_read_ue_log ( bs , ""display_window_bottom_offset"" ) ; } sps -> has_timing_info = gf_bs_read_int_log ( bs , 1 , ""has_timing_info"" ) ; if ( sps -> has_timing_info ) { sps -> num_units_in_tick = gf_bs_read_int_log ( bs , 32 , ""num_units_in_tick"" ) ; sps -> time_scale = gf_bs_read_int_log ( bs , 32 , ""time_scale"" ) ; sps -> poc_proportional_to_timing_flag = gf_bs_read_int_log ( bs , 1 , ""poc_proportional_to_timing_flag"" ) ; if ( sps -> poc_proportional_to_timing_flag ) sps -> num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log ( bs , ""num_ticks_poc_diff_one_minus1"" ) ; if ( ( sps -> hrd_parameters_present_flag = gf_bs_read_int_log ( bs , 1 , ""hrd_parameters_present_flag"" ) ) ) { return sps_id ; } } if ( gf_bs_read_int_log ( bs , 1 , ""bitstream_restriction_flag"" ) ) { gf_bs_read_int_log ( bs , 1 , ""tiles_fixed_structure_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""motion_vectors_over_pic_boundaries_flag"" ) ; gf_bs_read_int_log ( bs , 1 , ""restricted_ref_pic_lists_flag"" ) ; gf_bs_read_ue_log ( bs , ""min_spatial_segmentation_idc"" ) ; gf_bs_read_ue_log ( bs , ""max_bytes_per_pic_denom"" ) ; gf_bs_read_ue_log ( bs , ""max_bits_per_min_cu_denom"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_horizontal"" ) ; gf_bs_read_ue_log ( bs , ""log2_max_mv_length_vertical"" ) ; } } if ( gf_bs_read_int_log ( bs , 1 , ""sps_extension_flag"" ) ) { # if 0 while ( gf_bs_available ( bs ) ) { gf_bs_read_int ( bs , 1 ) ; } # endif } return sps_id ; }", ; if ( ( vps_id < 0 ) || (  vps_id >= 16 )
57,CWE-000 static void veth_setup ( struct net_device * dev ) {  ether_setup ( dev ) ;  dev -> netdev_ops = & veth_netdev_ops ; dev -> ethtool_ops = & veth_ethtool_ops ; dev -> features |= NETIF_F_LLTX ; dev -> destructor = veth_dev_free ; dev -> hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM ; }, ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
58,"CWE-000  struct key * find_keyring_by_name ( const char * name , bool skip_perm_check )  { struct key * keyring ; int bucket ; if ( ! name ) return ERR_PTR ( - EINVAL ) ; bucket = keyring_hash ( name ) ; read_lock ( & keyring_name_lock ) ; if ( keyring_name_hash [ bucket ] . next ) { list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) { if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ; if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) continue ; if ( strcmp ( keyring -> description , name ) != 0 ) continue ;  if ( ! skip_perm_check &&  key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 )  continue ;  if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ; keyring -> last_used_at = current_kernel_time ( ) . tv_sec ; goto out ; } } keyring = ERR_PTR ( - ENOKEY ) ; out : read_unlock ( & keyring_name_lock ) ; return keyring ; }"," name , bool uid_keyring  ) { struct  ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if (  key_permission ( make_key_ref  ) continue ; }"
59,"CWE-404 static int nfs4_callback_svc ( void * vrqstp ) { int err ; struct svc_rqst * rqstp = vrqstp ; set_freezable ( ) ;  while ( ! kthread_should_stop ( ) ) {  err = svc_recv ( rqstp , MAX_SCHEDULE_TIMEOUT ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; svc_process ( rqstp ) ; }  return 0 ;  }", while ( ! kthread_freezable_should_stop ( NULL  ) ) {  ) ) { if ( signal_pending ( current ) ) flush_signals ( current ) ;  ) ; } svc_exit_thread ( rqstp ) ; module_put_and_exit ( 0 ) ;
60,"CWE-74 PS_SERIALIZER_DECODE_FUNC ( php ) { const char * p , * q ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ;  PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;  p = val ; while ( p < endptr ) { zval * * tmp ;  q = p ;  while ( * q != PS_DELIMITER ) { if ( ++ q >= endptr ) goto break_outer_loop ; } if ( p [ 0 ] == PS_UNDEF_MARKER ) { p ++ ; has_value = 0 ; } else { has_value = 1 ; } namelen = q - p ; name = estrndup ( p , namelen ) ; q ++ ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) {  goto skip ;  } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & q , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) {  php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;  } else { var_push_dtor_no_addref ( & var_hash , & current ) ; efree ( name ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; }  PS_ADD_VARL ( name , namelen ) ;  skip : efree ( name ) ; p = q ; } break_outer_loop : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }", php_unserialize_data_t var_hash ; int skip = 0 ;  q = p ; skip = 0  ) ) { skip = 1  ; } }  ) ) { if ( ! skip ) {  TSRMLS_CC ) ; }  ) ; } if ( ! skip ) {  namelen ) ; }
61,"CWE-362 static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ;  if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) {   spin_lock_irq ( & child -> sighand -> siglock ) ;  WARN_ON_ONCE ( task_is_stopped ( child ) ) ;  if ( ignore_state || ( task_is_traced ( child ) &&  ! ( child -> jobctl & JOBCTL_LISTENING ) ) )  ret = 0 ;  spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ;  if ( ! ret && ! ignore_state )   ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ;  return ret ; }"," ; if (  child -> ptrace  child -> ptrace  && child ->  current ) { WARN_ON ( child -> state == __TASK_TRACED  ) ; if  ( ignore_state || ptrace_freeze_traced ( child  ) ) ret  ret = 0  ; } read_unlock  ! ignore_state ) { if ( !  wait_task_inactive ( child  ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret =  - ESRCH ;  - ESRCH ; } }"
62,"CWE-119 static vpx_codec_err_t ctrl_get_display_size ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {  int * const display_size = va_arg ( args , int * ) ;  if ( display_size ) {   if ( ctx -> pbi ) {   const VP9_COMMON * const cm = & ctx -> pbi -> common ;  display_size [ 0 ] = cm -> display_width ; display_size [ 1 ] = cm -> display_height ;  } else {  return VPX_CODEC_ERROR ; }  return VPX_CODEC_OK ;  } else { return VPX_CODEC_INVALID_PARAM ; }  } "," * ctx ,  va_list args )  ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Notsupportedinframeparalleldecode"" ) ; return VPX_CODEC_INCAPABLE ; } if (  ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;  const VP9_COMMON *  cm = & frame_worker_data  -> pbi ->  -> display_height ; return VPX_CODEC_OK ;  VPX_CODEC_ERROR ; } }  return VPX_CODEC_INVALID_PARAM ;  VPX_CODEC_INVALID_PARAM ; }    "
63,"CWE-125 static int tok_get ( struct tok_state * tok , char * * p_start , char * * p_end ) { int c ; int blankline , nonascii ; * p_start = * p_end = NULL ; nextline : tok -> start = NULL ; blankline = 0 ; if ( tok -> atbol ) { int col = 0 ; int altcol = 0 ; tok -> atbol = 0 ; for ( ; ; ) { c = tok_nextc ( tok ) ; if ( c == '' ) { col ++ , altcol ++ ; } else if ( c == '\\t' ) { col = ( col / tok -> tabsize + 1 ) * tok -> tabsize ;  altcol = ( altcol / tok -> alttabsize + 1 )   * tok -> alttabsize ;  } else if ( c == '\\014' ) { col = altcol = 0 ; } else { break ; } } tok_backup ( tok , c ) ; if ( c == '#' || c == '\\n' ) { if ( col == 0 && c == '\\n' && tok -> prompt != NULL ) { blankline = 0 ; } else { blankline = 1 ; } } if ( ! blankline && tok -> level == 0 ) { if ( col == tok -> indstack [ tok -> indent ] ) { if ( altcol != tok -> altindstack [ tok -> indent ] ) {  if ( indenterror ( tok ) ) {  return ERRORTOKEN ; } } } else if ( col > tok -> indstack [ tok -> indent ] ) { if ( tok -> indent + 1 >= MAXINDENT ) { tok -> done = E_TOODEEP ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( altcol <= tok -> altindstack [ tok -> indent ] ) {  if ( indenterror ( tok ) ) {  return ERRORTOKEN ; } } tok -> pendin ++ ; tok -> indstack [ ++ tok -> indent ] = col ; tok -> altindstack [ tok -> indent ] = altcol ; } else { while ( tok -> indent > 0 && col < tok -> indstack [ tok -> indent ] ) { tok -> pendin -- ; tok -> indent -- ; } if ( col != tok -> indstack [ tok -> indent ] ) { tok -> done = E_DEDENT ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( altcol != tok -> altindstack [ tok -> indent ] ) {  if ( indenterror ( tok ) ) {  return ERRORTOKEN ; } } } } } tok -> start = tok -> cur ; if ( tok -> pendin != 0 ) { if ( tok -> pendin < 0 ) { tok -> pendin ++ ; return DEDENT ; } else { tok -> pendin -- ; return INDENT ; } } if ( tok -> async_def && ! blankline && tok -> level == 0 && tok -> async_def_nl && tok -> async_def_indent >= tok -> indent ) { tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; } again : tok -> start = NULL ; do { c = tok_nextc ( tok ) ; } while ( c == '' || c == '\\t' || c == '\\014' ) ; tok -> start = tok -> cur - 1 ; if ( c == '#' ) { const char * prefix , * p , * type_start ; while ( c != EOF && c != '\\n' ) c = tok_nextc ( tok ) ; p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '' ) { while ( * p == '' || * p == '\\t' ) p ++ ; } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } } } if ( c == EOF ) { return tok -> done == E_EOF ? ENDMARKER : ERRORTOKEN ; } nonascii = 0 ; if ( is_potential_identifier_start ( c ) ) { int saw_b = 0 , saw_r = 0 , saw_u = 0 , saw_f = 0 ; while ( 1 ) { if ( ! ( saw_b || saw_u || saw_f ) && ( c == 'b' || c == 'B' ) ) saw_b = 1 ; else if ( ! ( saw_b || saw_u || saw_r || saw_f ) && ( c == 'u' || c == 'U' ) ) { saw_u = 1 ; } else if ( ! ( saw_r || saw_u ) && ( c == 'r' || c == 'R' ) ) { saw_r = 1 ; } else if ( ! ( saw_f || saw_b || saw_u ) && ( c == 'f' || c == 'F' ) ) { saw_f = 1 ; } else { break ; } c = tok_nextc ( tok ) ; if ( c == \'""\' || c == '\\'' ) { goto letter_quote ; } } while ( is_potential_identifier_char ( c ) ) { if ( c >= 128 ) { nonascii = 1 ; } c = tok_nextc ( tok ) ; } tok_backup ( tok , c ) ; if ( nonascii && ! verify_identifier ( tok ) ) { return ERRORTOKEN ; } * p_start = tok -> start ; * p_end = tok -> cur ; if ( tok -> cur - tok -> start == 5 ) {  if ( tok -> async_def ) {  if ( memcmp ( tok -> start , ""async"" , 5 ) == 0 ) { return ASYNC ; } if ( memcmp ( tok -> start , ""await"" , 5 ) == 0 ) { return AWAIT ; } } else if ( memcmp ( tok -> start , ""async"" , 5 ) == 0 ) { struct tok_state ahead_tok ; char * ahead_tok_start = NULL , * ahead_tok_end = NULL ; int ahead_tok_kind ; memcpy ( & ahead_tok , tok , sizeof ( ahead_tok ) ) ; ahead_tok_kind = tok_get ( & ahead_tok , & ahead_tok_start , & ahead_tok_end ) ; if ( ahead_tok_kind == NAME && ahead_tok . cur - ahead_tok . start == 3 && memcmp ( ahead_tok . start , ""def"" , 3 ) == 0 ) { tok -> async_def_indent = tok -> indent ; tok -> async_def = 1 ; return ASYNC ; } } } return NAME ; } if ( c == '\\n' ) { tok -> atbol = 1 ; if ( blankline || tok -> level > 0 ) { goto nextline ; } * p_start = tok -> start ; * p_end = tok -> cur - 1 ; tok -> cont_line = 0 ; if ( tok -> async_def ) { tok -> async_def_nl = 1 ; } return NEWLINE ; } if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( isdigit ( c ) ) { goto fraction ; } else if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( c == '.' ) { * p_start = tok -> start ; * p_end = tok -> cur ; return ELLIPSIS ; } else { tok_backup ( tok , c ) ; } tok_backup ( tok , '.' ) ; } else { tok_backup ( tok , c ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return DOT ; } if ( isdigit ( c ) ) { if ( c == '0' ) { c = tok_nextc ( tok ) ; if ( c == 'x' || c == 'X' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( ! isxdigit ( c ) ) { tok -> done = E_TOKEN ; tok_backup ( tok , c ) ; return ERRORTOKEN ; } do { c = tok_nextc ( tok ) ; } while ( isxdigit ( c ) ) ; } while ( c == '_' ) ; } else if ( c == 'o' || c == 'O' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c < '0' || c >= '8' ) { tok -> done = E_TOKEN ; tok_backup ( tok , c ) ; return ERRORTOKEN ; } do { c = tok_nextc ( tok ) ; } while ( '0' <= c && c < '8' ) ; } while ( c == '_' ) ; } else if ( c == 'b' || c == 'B' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c != '0' && c != '1' ) { tok -> done = E_TOKEN ; tok_backup ( tok , c ) ; return ERRORTOKEN ; } do { c = tok_nextc ( tok ) ; } while ( c == '0' || c == '1' ) ; } while ( c == '_' ) ; } else { int nonzero = 0 ; while ( 1 ) { if ( c == '_' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok -> done = E_TOKEN ; tok_backup ( tok , c ) ; return ERRORTOKEN ; } } if ( c != '0' ) { break ; } c = tok_nextc ( tok ) ; } if ( isdigit ( c ) ) { nonzero = 1 ; c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } if ( c == '.' ) { c = tok_nextc ( tok ) ; goto fraction ; } else if ( c == 'e' || c == 'E' ) { goto exponent ; } else if ( c == 'j' || c == 'J' ) { goto imaginary ; } else if ( nonzero ) { tok -> done = E_TOKEN ; tok_backup ( tok , c ) ; return ERRORTOKEN ; } } } else { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } { if ( c == '.' ) { c = tok_nextc ( tok ) ; fraction : if ( isdigit ( c ) ) { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } } if ( c == 'e' || c == 'E' ) { int e ; exponent : e = c ; c = tok_nextc ( tok ) ; if ( c == '+' || c == '-' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok -> done = E_TOKEN ; tok_backup ( tok , c ) ; return ERRORTOKEN ; } } else if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; tok_backup ( tok , e ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return NUMBER ; } c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } if ( c == 'j' || c == 'J' ) { imaginary : c = tok_nextc ( tok ) ; } } } tok_backup ( tok , c ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return NUMBER ; } letter_quote : if ( c == '\\'' || c == \'""\' ) { int quote = c ; int quote_size = 1 ; int end_quote_size = 0 ; c = tok_nextc ( tok ) ; if ( c == quote ) { c = tok_nextc ( tok ) ; if ( c == quote ) { quote_size = 3 ; } else { end_quote_size = 1 ; } } if ( c != quote ) { tok_backup ( tok , c ) ; } while ( end_quote_size != quote_size ) { c = tok_nextc ( tok ) ; if ( c == EOF ) { if ( quote_size == 3 ) { tok -> done = E_EOFS ; } else { tok -> done = E_EOLS ; } tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( quote_size == 1 && c == '\\n' ) { tok -> done = E_EOLS ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( c == quote ) { end_quote_size += 1 ; } else { end_quote_size = 0 ; if ( c == '\\\\' ) { tok_nextc ( tok ) ; } } } * p_start = tok -> start ; * p_end = tok -> cur ; return STRING ; } if ( c == '\\\\' ) { c = tok_nextc ( tok ) ; if ( c != '\\n' ) { tok -> done = E_LINECONT ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } tok -> cont_line = 1 ; goto again ; } { int c2 = tok_nextc ( tok ) ; int token = Ta3Token_TwoChars ( c , c2 ) ; if ( token != OP ) { int c3 = tok_nextc ( tok ) ; int token3 = Ta3Token_ThreeChars ( c , c2 , c3 ) ; if ( token3 != OP ) { token = token3 ; } else { tok_backup ( tok , c3 ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return token ; } tok_backup ( tok , c2 ) ; } switch ( c ) { case '(' : case '[' : case '{' : tok -> level ++ ; break ; case ')' : case ']' : case '}' : tok -> level -- ; break ; } * p_start = tok -> start ; * p_end = tok -> cur ; return Ta3Token_OneChar ( c ) ; }", ( altcol / ALTTABSIZE  + 1 )  + 1 ) * ALTTABSIZE  ; } else  ] ) { return  indenterror ( tok  ( tok ) ;  } } else  ] ) { return  indenterror ( tok  ( tok ) ;  } tok ->  ] ) { return  indenterror ( tok  ( tok ) ;  } } }  { if ( tok -> async_always ||
64,"CWE-787 static int grub_ext2_iterate_dir ( grub_fshelp_node_t dir , int ( * hook ) ( const char * filename , enum grub_fshelp_filetype filetype , grub_fshelp_node_t node , void * closure ) , void * closure ) { unsigned int fpos = 0 ; struct grub_fshelp_node * diro = ( struct grub_fshelp_node * ) dir ; if ( ! diro -> inode_read ) { grub_ext2_read_inode ( diro -> data , diro -> ino , & diro -> inode ) ; if ( grub_errno ) return 0 ; } if ( hook ) while ( fpos < grub_le_to_cpu32 ( diro -> inode . size ) ) { struct ext2_dirent dirent ; grub_ext2_read_file ( diro , NULL , NULL , 0 , fpos , sizeof ( dirent ) , ( char * ) & dirent ) ; if ( grub_errno ) return 0 ; if ( dirent . direntlen == 0 ) return 0 ; if ( dirent . namelen != 0 ) {  # ifndef _MSC_VER   char filename [ dirent . namelen + 1 ] ;  # else char * filename = grub_malloc ( dirent . namelen + 1 ) ; # endif struct grub_fshelp_node * fdiro ;  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ;  grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ; if ( grub_errno )  return 0 ;  fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ; if ( ! fdiro )  return 0 ;  fdiro -> data = diro -> data ; fdiro -> ino = grub_le_to_cpu32 ( dirent . inode ) ; filename [ dirent . namelen ] = '\\0' ; if ( dirent . filetype != FILETYPE_UNKNOWN ) { fdiro -> inode_read = 0 ; if ( dirent . filetype == FILETYPE_DIRECTORY ) type = GRUB_FSHELP_DIR ; else if ( dirent . filetype == FILETYPE_SYMLINK ) type = GRUB_FSHELP_SYMLINK ; else if ( dirent . filetype == FILETYPE_REG ) type = GRUB_FSHELP_REG ; } else { grub_ext2_read_inode ( diro -> data , grub_le_to_cpu32 ( dirent . inode ) , & fdiro -> inode ) ; if ( grub_errno )  {  grub_free ( fdiro ) ; return 0 ; } fdiro -> inode_read = 1 ; if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_DIRECTORY ) type = GRUB_FSHELP_DIR ; else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_SYMLINK ) type = GRUB_FSHELP_SYMLINK ; else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_REG ) type = GRUB_FSHELP_REG ; }  if ( hook ( filename , type , fdiro , closure ) )  return 1 ; } fpos += grub_le_to_cpu16 ( dirent . direntlen ) ; } return 0 ; }", 0 ) { char * filename = grub_malloc (  dirent . namelen  namelen + 1 ) ;  struct grub_fshelp_node *  = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; }  ( grub_errno ) { free ( filename ) ; return 0 ; }  fdiro = grub_malloc  ! fdiro ) { free ( filename ) ; return 0 ; }  fdiro -> data  ( grub_errno ) { free ( filename ) ;  grub_free ( fdiro  closure ) ) { free ( filename ) ; return 1 ; } free ( filename )  ; } fpos
65,"CWE-119 void process_pfa ( FILE * ifp , const char * ifp_filename , struct font_reader * fr ) { char buffer [ LINESIZE ] ; int c = 0 ; int blocktyp = PFA_ASCII ; char saved_orphan = 0 ; ( void ) ifp_filename ; while ( c != EOF ) { char * line = buffer , * last = buffer ; int crlf = 0 ; c = getc ( ifp ) ; while ( c != EOF && c != '\\r' && c != '\\n' && last < buffer + LINESIZE - 1 ) { * last ++ = c ; c = getc ( ifp ) ; } if ( last == buffer + LINESIZE - 1 ) ungetc ( c , ifp ) ; else if ( c == '\\r' && blocktyp != PFA_BINARY ) { c = getc ( ifp ) ; if ( c != '\\n' ) ungetc ( c , ifp ) , crlf = 1 ; else crlf = 2 ; * last ++ = '\\n' ; } else if ( c != EOF ) * last ++ = c ; * last = 0 ; if ( blocktyp == PFA_ASCII ) {  if ( strncmp ( line , ""currentfileeexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {  char saved_p ;  for ( line += 18 ; isspace ( * line ) ; line ++ )  ; saved_p = * line ; * line = 0 ; fr -> output_ascii ( buffer , line - buffer ) ; * line = saved_p ; blocktyp = PFA_EEXEC_TEST ; if ( ! * line ) continue ; } else { fr -> output_ascii ( line , last - line ) ; continue ; } } if ( blocktyp == PFA_EEXEC_TEST ) {  for ( ; line < last && isspace ( * line ) ; line ++ )  ; if ( line == last ) continue ;  else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] )   && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) )  blocktyp = PFA_HEX ; else blocktyp = PFA_BINARY ; memmove ( buffer , line , last - line + 1 ) ; last = buffer + ( last - line ) ; line = buffer ; if ( blocktyp == PFA_BINARY && crlf ) { last [ - 1 ] = '\\r' ; if ( crlf == 2 ) * last ++ = '\\n' ; } } if ( all_zeroes ( line ) ) { fr -> output_ascii ( line , last - line ) ; blocktyp = PFA_ASCII ; } else if ( blocktyp == PFA_HEX ) { int len = translate_hex_string ( line , & saved_orphan ) ; if ( len ) fr -> output_binary ( ( unsigned char * ) line , len ) ; } else fr -> output_binary ( ( unsigned char * ) line , last - line ) ; } fr -> output_end ( ) ; }", && isspace ( ( unsigned char )  ; isspace ( ( unsigned char )  && isspace ( ( unsigned char )  && isxdigit ( ( unsigned char )  && isxdigit ( ( unsigned char )  && isxdigit ( ( unsigned char )  && isxdigit ( ( unsigned char )
66,"CWE-20 static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = CHECKSUM_NONE ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - EMSGSIZE ; } if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & MSG_MORE ) && rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) csummode = CHECKSUM_PARTIAL ; if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ;  if ( transhdrlen ) {  skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; }  copy = datalen - transhdrlen - fraggap ;  if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }"," frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; }  ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen  , offset ,"
67,"CWE-416 zip_int64_t _zip_dirent_read ( zip_dirent_t * zde , zip_source_t * src , zip_buffer_t * buffer , bool local , zip_error_t * error ) { zip_uint8_t buf [ CDENTRYSIZE ] ; zip_uint16_t dostime , dosdate ; zip_uint32_t size , variable_size ; zip_uint16_t filename_len , comment_len , ef_len ; bool from_buffer = ( buffer != NULL ) ; size = local ? LENTRYSIZE : CDENTRYSIZE ; if ( buffer ) { if ( _zip_buffer_left ( buffer ) < size ) { zip_error_set ( error , ZIP_ER_NOZIP , 0 ) ; return - 1 ; } } else { if ( ( buffer = _zip_buffer_new_from_source ( src , size , buf , error ) ) == NULL ) { return - 1 ; } } if ( memcmp ( _zip_buffer_get ( buffer , 4 ) , ( local ? LOCAL_MAGIC : CENTRAL_MAGIC ) , 4 ) != 0 ) { zip_error_set ( error , ZIP_ER_NOZIP , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } _zip_dirent_init ( zde ) ; if ( ! local ) zde -> version_madeby = _zip_buffer_get_16 ( buffer ) ; else zde -> version_madeby = 0 ; zde -> version_needed = _zip_buffer_get_16 ( buffer ) ; zde -> bitflags = _zip_buffer_get_16 ( buffer ) ; zde -> comp_method = _zip_buffer_get_16 ( buffer ) ; dostime = _zip_buffer_get_16 ( buffer ) ; dosdate = _zip_buffer_get_16 ( buffer ) ; zde -> last_mod = _zip_d2u_time ( dostime , dosdate ) ; zde -> crc = _zip_buffer_get_32 ( buffer ) ; zde -> comp_size = _zip_buffer_get_32 ( buffer ) ; zde -> uncomp_size = _zip_buffer_get_32 ( buffer ) ; filename_len = _zip_buffer_get_16 ( buffer ) ; ef_len = _zip_buffer_get_16 ( buffer ) ; if ( local ) { comment_len = 0 ; zde -> disk_number = 0 ; zde -> int_attrib = 0 ; zde -> ext_attrib = 0 ; zde -> offset = 0 ; } else { comment_len = _zip_buffer_get_16 ( buffer ) ; zde -> disk_number = _zip_buffer_get_16 ( buffer ) ; zde -> int_attrib = _zip_buffer_get_16 ( buffer ) ; zde -> ext_attrib = _zip_buffer_get_32 ( buffer ) ; zde -> offset = _zip_buffer_get_32 ( buffer ) ; } if ( ! _zip_buffer_ok ( buffer ) ) { zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> bitflags & ZIP_GPBF_ENCRYPTED ) { if ( zde -> bitflags & ZIP_GPBF_STRONG_ENCRYPTION ) { zde -> encryption_method = ZIP_EM_UNKNOWN ; } else { zde -> encryption_method = ZIP_EM_TRAD_PKWARE ; } } else { zde -> encryption_method = ZIP_EM_NONE ; } zde -> filename = NULL ; zde -> extra_fields = NULL ; zde -> comment = NULL ; variable_size = ( zip_uint32_t ) filename_len + ( zip_uint32_t ) ef_len + ( zip_uint32_t ) comment_len ; if ( from_buffer ) { if ( _zip_buffer_left ( buffer ) < variable_size ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; return - 1 ; } } else { _zip_buffer_free ( buffer ) ; if ( ( buffer = _zip_buffer_new_from_source ( src , variable_size , NULL , error ) ) == NULL ) { return - 1 ; } } if ( filename_len ) { zde -> filename = _zip_read_string ( buffer , src , filename_len , 1 , error ) ; if ( ! zde -> filename ) { if ( zip_error_code_zip ( error ) == ZIP_ER_EOF ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; } if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> bitflags & ZIP_GPBF_ENCODING_UTF_8 ) { if ( _zip_guess_encoding ( zde -> filename , ZIP_ENCODING_UTF8_KNOWN ) == ZIP_ENCODING_ERROR ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } } } if ( ef_len ) { zip_uint8_t * ef = _zip_read_data ( buffer , src , ef_len , 0 , error ) ; if ( ef == NULL ) { if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( ! _zip_ef_parse ( ef , ef_len , local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL , & zde -> extra_fields , error ) ) { free ( ef ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } free ( ef ) ; if ( local ) zde -> local_extra_fields_read = 1 ; } if ( comment_len ) { zde -> comment = _zip_read_string ( buffer , src , comment_len , 0 , error ) ; if ( ! zde -> comment ) { if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> bitflags & ZIP_GPBF_ENCODING_UTF_8 ) { if ( _zip_guess_encoding ( zde -> comment , ZIP_ENCODING_UTF8_KNOWN ) == ZIP_ENCODING_ERROR ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } } } zde -> filename = _zip_dirent_process_ef_utf_8 ( zde , ZIP_EF_UTF_8_NAME , zde -> filename ) ; zde -> comment = _zip_dirent_process_ef_utf_8 ( zde , ZIP_EF_UTF_8_COMMENT , zde -> comment ) ; if ( zde -> uncomp_size == ZIP_UINT32_MAX || zde -> comp_size == ZIP_UINT32_MAX || zde -> offset == ZIP_UINT32_MAX ) { zip_uint16_t got_len ; zip_buffer_t * ef_buffer ; const zip_uint8_t * ef = _zip_ef_get_by_id ( zde -> extra_fields , & got_len , ZIP_EF_ZIP64 , 0 , local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL , error ) ; if ( ef == NULL ) { if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( ( ef_buffer = _zip_buffer_new ( ( zip_uint8_t * ) ef , got_len ) ) == NULL ) { zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( zde -> uncomp_size == ZIP_UINT32_MAX ) zde -> uncomp_size = _zip_buffer_get_64 ( ef_buffer ) ; else if ( local ) { ( void ) _zip_buffer_skip ( ef_buffer , 8 ) ; } if ( zde -> comp_size == ZIP_UINT32_MAX ) zde -> comp_size = _zip_buffer_get_64 ( ef_buffer ) ; if ( ! local ) { if ( zde -> offset == ZIP_UINT32_MAX ) zde -> offset = _zip_buffer_get_64 ( ef_buffer ) ; if ( zde -> disk_number == ZIP_UINT16_MAX ) zde -> disk_number = _zip_buffer_get_32 ( buffer ) ; } if ( ! _zip_buffer_eof ( ef_buffer ) ) { zip_error_set ( error , ZIP_ER_INCONS , 0 ) ; _zip_buffer_free ( ef_buffer ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } _zip_buffer_free ( ef_buffer ) ; } if ( ! _zip_buffer_ok ( buffer ) ) { zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ; if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } return - 1 ; } if ( ! from_buffer ) { _zip_buffer_free ( buffer ) ; } if ( zde -> offset > ZIP_INT64_MAX ) { zip_error_set ( error , ZIP_ER_SEEK , EFBIG ) ; return - 1 ; } if ( ! _zip_dirent_process_winzip_aes ( zde , error ) ) {  if ( ! from_buffer ) {  _zip_buffer_free ( buffer ) ; } return - 1 ; } zde -> extra_fields = _zip_ef_remove_internal ( zde -> extra_fields ) ; return ( zip_int64_t ) ( size + variable_size ) ; }", ) ) {  return - 1
68,"CWE-189 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ;  if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K )  return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ;  if ( aux -> alu_state &&  ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) )  return - EACCES ;  aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }"," ; if ( can_skip_alu_sanitation ( env , insn )  ) return 0  ; if ( update_alu_sanitation_state ( aux , alu_state ,  alu_limit ) )  return - EACCES  ; do_sim :"
69,"CWE-200 static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ;  pr_debug ( ""%p%zu\\n"" , sk , len ) ;  lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""Recvdatagramfailedstate%d%d%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""Datagramsocket%d%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ;  sockaddr -> sa_family = AF_NFC ;  sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }"," , len ) ; msg -> msg_namelen = 0  ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;"
70,CWE-119 void unix_notinflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ;  if ( s ) {   struct unix_sock * u = unix_sk ( s ) ;  spin_lock ( & unix_gc_lock ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ;  spin_unlock ( & unix_gc_lock ) ;  }  } , fp ) ; spin_lock ( & unix_gc_lock ) ;  unix_sk ( s  ) ; BUG_ON  unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ;  ) ; }    
71,"CWE-415 static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) {  unsigned char * buf ;  assert ( m -> buf_ ) ; assert ( bufsize >= 0 ) ;  if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {  return - 1 ; } m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }", char * buf  ; assert (  ) ) ) && bufsize
72,"CWE-125 PyObject * ast2obj_arguments ( void * _o ) { arguments_ty o = ( arguments_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) {  Py_INCREF ( Py_None ) ;  return Py_None ; } result = PyType_GenericNew ( arguments_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_list ( o -> args , ast2obj_arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arg ( o -> vararg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_vararg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> kwonlyargs , ast2obj_arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_kwonlyargs , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> kw_defaults , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_kw_defaults , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arg ( o -> kwarg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_kwarg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> defaults , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_defaults , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }", o ) { Py_RETURN_NONE  ; } result
73,"CWE-119 static void set_block_size ( VP9_COMP * const cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) { if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) {  MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;   set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;  xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;  duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;  } }"," const cpi , MACROBLOCK * const x , MACROBLOCKD * const xd  , int mi_row  mi_row ) { set_mode_info_offsets  ( & cpi  cpi -> common , x  = bsize ;  } } "
74,"CWE-119 static bool parse_reconnect ( struct pool * pool , json_t * val ) { char * sockaddr_url , * stratum_port , * tmp ; char * url , * port , address [ 256 ] ; memset ( address , 0 , 255 ) ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; else { char * dot_pool , * dot_reconnect ; dot_pool = strchr ( pool -> sockaddr_url , '.' ) ; if ( ! dot_pool ) { applog ( LOG_ERR , ""Deniedstratumreconnectrequestforpoolwithoutdomain\'%s\'"" , pool -> sockaddr_url ) ; return false ; } dot_reconnect = strchr ( url , '.' ) ; if ( ! dot_reconnect ) { applog ( LOG_ERR , ""Deniedstratumreconnectrequesttourlwithoutdomain\'%s\'"" , url ) ; return false ; } if ( strcmp ( dot_pool , dot_reconnect ) ) { applog ( LOG_ERR , ""Deniedstratumreconnectrequesttonon-matchingdomainurl\'%s\'"" , pool -> sockaddr_url ) ; return false ; } } port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ;  sprintf ( address , ""%s:%s"" , url , port ) ;  if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_WARNING , ""Stratumreconnectrequestedfrompool%dto%s"" , pool -> pool_no , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }"," -> stratum_port ; snprintf ( address , 254  , ""%s:%s"" ,"
75,"CWE-119 static void parse_global_config ( struct VpxEncoderConfig * global , char * * argv ) { char * * argi , * * argj ; struct arg arg ;  memset ( global , 0 , sizeof ( * global ) ) ;   global -> codec = get_vpx_encoder_by_index ( 0 ) ;  global -> passes = 0 ; global -> use_i420 = 1 ; global -> deadline = VPX_DL_GOOD_QUALITY ; for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( arg_match ( & arg , & codecarg , argi ) ) { global -> codec = get_vpx_encoder_by_name ( arg . val ) ; if ( ! global -> codec ) die ( ""Error:Unrecognizedargument(%s)to--codec\\n"" , arg . val ) ; } else if ( arg_match ( & arg , & passes , argi ) ) { global -> passes = arg_parse_uint ( & arg ) ; if ( global -> passes < 1 || global -> passes > 2 ) die ( ""Error:Invalidnumberofpasses(%d)\\n"" , global -> passes ) ; } else if ( arg_match ( & arg , & pass_arg , argi ) ) { global -> pass = arg_parse_uint ( & arg ) ; if ( global -> pass < 1 || global -> pass > 2 ) die ( ""Error:Invalidpassselected(%d)\\n"" , global -> pass ) ; } else if ( arg_match ( & arg , & usage , argi ) ) global -> usage = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & deadline , argi ) ) global -> deadline = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & best_dl , argi ) ) global -> deadline = VPX_DL_BEST_QUALITY ; else if ( arg_match ( & arg , & good_dl , argi ) ) global -> deadline = VPX_DL_GOOD_QUALITY ; else if ( arg_match ( & arg , & rt_dl , argi ) ) global -> deadline = VPX_DL_REALTIME ; else if ( arg_match ( & arg , & use_yv12 , argi ) )  global -> use_i420 = 0 ;  else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> use_i420 = 1 ; else if ( arg_match ( & arg , & quietarg , argi ) ) global -> quiet = 1 ; else if ( arg_match ( & arg , & verbosearg , argi ) ) global -> verbose = 1 ; else if ( arg_match ( & arg , & limit , argi ) ) global -> limit = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & skip , argi ) ) global -> skip_frames = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & psnrarg , argi ) ) global -> show_psnr = 1 ; else if ( arg_match ( & arg , & recontest , argi ) ) global -> test_decode = arg_parse_enum_or_int ( & arg ) ; else if ( arg_match ( & arg , & framerate , argi ) ) { global -> framerate = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & global -> framerate ) ; global -> have_framerate = 1 ; } else if ( arg_match ( & arg , & out_part , argi ) ) global -> out_part = 1 ; else if ( arg_match ( & arg , & debugmode , argi ) ) global -> debug = 1 ; else if ( arg_match ( & arg , & q_hist_n , argi ) ) global -> show_q_hist_buckets = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & rate_hist_n , argi ) ) global -> show_rate_hist_buckets = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & disable_warnings , argi ) ) global -> disable_warnings = 1 ; else if ( arg_match ( & arg , & disable_warning_prompt , argi ) ) global -> disable_warning_prompt = 1 ;  else if ( arg_match ( & arg , & experimental_bitstream , argi ) )  global -> experimental_bitstream = 1 ; else argj ++ ; } if ( global -> pass ) { if ( global -> pass > global -> passes ) { warn ( ""Assuming--pass=%dimplies--passes=%d\\n"" , global -> pass , global -> pass ) ; global -> passes = global -> pass ; } } if ( global -> passes == 0 ) {  # if CONFIG_VP9_ENCODER  global -> passes = ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 && global -> deadline != VPX_DL_REALTIME ) ? 2 : 1 ; # else global -> passes = 1 ; # endif } if ( global -> deadline == VPX_DL_REALTIME && global -> passes > 1 ) { warn ( ""Enforcingone-passencodinginrealtimemode\\n"" ) ; global -> passes = 1 ; } }"," arg arg ; const int num_encoder = get_vpx_encoder_count ( ) ; if ( num_encoder < 1 ) die ( ""Error:novalidencoderavailable\\n"" ) ;  = get_vpx_encoder_by_index ( num_encoder - 1 ) ; global -> passes = 0 ; global -> color_type = I420  ; global ->  ) global -> color_type = YV12 ; else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ; else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ; else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ; else if ( arg_match ( & arg , & use_i440 , argi ) ) global -> color_type = I440  ; else if  1 ; else  argj ++ ;  # if CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL )"
76,"CWE-200 static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) || ( sock -> state == SS_CONNECTING ) ) ) { res = - ENOTCONN ; goto exit ;  }  target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }", exit ; } m -> msg_namelen = 0 ;
77,"CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET )  get_page ( page ) ;  if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }", & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } }  if ( flags
78,"CWE-401 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) {  sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;  ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
79,"CWE-20 static int __sock_diag_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { int err ; struct sock_diag_req * req = nlmsg_data ( nlh ) ; const struct sock_diag_handler * hndl ; if ( nlmsg_len ( nlh ) < sizeof ( * req ) ) return - EINVAL ;  hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;  if ( hndl == NULL ) err = - ENOENT ; else err = hndl -> dump ( skb , nlh ) ; sock_diag_unlock_handler ( hndl ) ; return err ; }", - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
80,"CWE-190  static inline ulong encode_twos_comp ( long n , int prec )  {  ulong result ;  assert ( prec >= 2 ) ; jas_eprintf ( ""warning:supportforsigneddataisuntested\\n"" ) ; if ( n < 0 ) { result = - n ; result = ( result ^ 0xffffffffUL ) + 1 ; result &= ( 1 << prec ) - 1 ; } else { result = n ; } return result ; }",  static inline jas_ulong  encode_twos_comp ( long  prec ) { jas_ulong  result ; assert
81,"CWE-362 static int  mptctl_eventquery ( unsigned long arg )  { struct mpt_ioctl_eventquery __user * uarg = ( void __user * ) arg ;  struct mpt_ioctl_eventquery karg ;  MPT_ADAPTER * ioc ; int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventquery ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_eventquery-"" ""Unabletoreadinmpt_ioctl_eventquerystruct@%p\\n"" , __FILE__ , __LINE__ , uarg ) ;  return - EFAULT ;  } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventquery()@%d-ioc%dnotfound!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_eventquerycalled.\\n"" , ioc -> name ) ) ; karg . eventEntries = MPTCTL_EVENT_LOG_SIZE ; karg . eventTypes = ioc -> eventTypes ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_eventquery ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventquery-"" ""Unabletowriteoutmpt_ioctl_eventquerystruct@%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }"," int mptctl_eventquery ( MPT_ADAPTER * ioc ,  struct mpt_ioctl_eventquery karg  ; if (  return - EFAULT  ; } dctlprintk"
82,"CWE-284 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ; const unsigned char * old_name ; struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ;  if ( source == target )  return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename && ! old_dir -> i_op -> rename2 ) return - EPERM ; if ( flags && ! old_dir -> i_op -> rename2 ) return - EINVAL ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error ) return error ; } } error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) return error ; old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } if ( ! old_dir -> i_op -> rename2 ) { error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry ) ; } else { WARN_ON ( old_dir -> i_op -> rename != NULL ) ; error = old_dir -> i_op -> rename2 ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; } if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } fsnotify_oldname_free ( old_name ) ; return error ; }"," ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 )  ) return 0"
83,"CWE-863 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ;  if ( ! vma -> vm_userfaultfd_ctx . ctx )  goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }", ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
84,"CWE-264  static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ;  if ( ! options ) {  rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR ""Errorattemptingtoregister"" ""globalsig;rc=[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR ""Errorattemptingtoregister"" ""globalfneksig[%s];rc=[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ;  case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:eCryptfs:unrecognizedoption[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , ""Youmustsupplyatleastonevalid"" ""authtoksignatureasamount"" ""parameter;seetheeCryptfsREADME\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR ""Errorattemptingtoinitialize"" ""cipherwithname=[%s]andkeysize=[%td];"" ""rc=[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR ""Errorattemptingtoinitialize"" ""cipherwithname=[%s]andkeysize=[%td];"" ""rc=[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING ""Oneormoreglobalauthtokscouldnot"" ""properlyregister;rc=[%d]\\n"" , rc ) ; out : return rc ; }"," char * options , uid_t * check_ruid  * fn_cipher_key_bytes_src ; * check_ruid = 0 ;  break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case"
85,"CWE-119 enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( ""Authenticating(CRAM-MD5)..."" ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , ""AUTHENTICATECRAM-MD5"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Invalidresponsefromserver:%s\\n"" , ibuf ) ; goto bail ; }  len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;  if ( len == - 1 ) { mutt_debug ( 1 , ""Errordecodingbase64response.\\n"" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , ""CRAMchallenge:%s\\n"" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , ""%s"" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , ""CRAMresponse:%s\\n"" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , ""Errorreceivingserverresponse.\\n"" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( ""CRAM-MD5authenticationfailed."" ) ) ; return IMAP_AUTH_FAILURE ; }"," buf + 2 , sizeof ( obuf )"
86,"CWE-119  int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) {  return 0 ; }"," downmix_object_t * pDownmixer __unused  , bool init __unused"
87,"CWE-000 int ext4_ext_get_blocks ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct buffer_head * bh_result , int flags ) { struct ext4_ext_path * path = NULL ; struct ext4_extent_header * eh ; struct ext4_extent newex , * ex , * last_ex ; ext4_fsblk_t newblock ; int err = 0 , depth , ret , cache_type ; unsigned int allocated = 0 ; struct ext4_allocation_request ar ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; __clear_bit ( BH_New , & bh_result -> b_state ) ; ext_debug ( ""blocks%u/%urequestedforinode%lu\\n"" , iblock , max_blocks , inode -> i_ino ) ; cache_type = ext4_ext_in_cache ( inode , iblock , & newex ) ; if ( cache_type ) { if ( cache_type == EXT4_EXT_CACHE_GAP ) { if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { goto out2 ; } } else if ( cache_type == EXT4_EXT_CACHE_EXTENT ) { newblock = iblock - le32_to_cpu ( newex . ee_block ) + ext_pblock ( & newex ) ; allocated = ext4_ext_get_actual_len ( & newex ) - ( iblock - le32_to_cpu ( newex . ee_block ) ) ; goto out ; } else { BUG ( ) ; } } path = ext4_ext_find_extent ( inode , iblock , NULL ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; path = NULL ; goto out2 ; } depth = ext_depth ( inode ) ; if ( path [ depth ] . p_ext == NULL && depth != 0 ) { ext4_error ( inode -> i_sb , ""badextentaddress"" ""inode:%lu,iblock:%d,depth:%d"" , inode -> i_ino , iblock , depth ) ; err = - EIO ; goto out2 ; } eh = path [ depth ] . p_hdr ; ex = path [ depth ] . p_ext ; if ( ex ) { ext4_lblk_t ee_block = le32_to_cpu ( ex -> ee_block ) ; ext4_fsblk_t ee_start = ext_pblock ( ex ) ; unsigned short ee_len ; ee_len = ext4_ext_get_actual_len ( ex ) ; if ( iblock >= ee_block && iblock < ee_block + ee_len ) { newblock = iblock - ee_block + ee_start ; allocated = ee_len - ( iblock - ee_block ) ; ext_debug ( ""%ufitinto%u:%d->%llu\\n"" , iblock , ee_block , ee_len , newblock ) ; if ( ! ext4_ext_is_uninitialized ( ex ) ) { ext4_ext_put_in_cache ( inode , ee_block , ee_len , ee_start , EXT4_EXT_CACHE_EXTENT ) ; goto out ; } ret = ext4_ext_handle_uninitialized_extents ( handle , inode , iblock , max_blocks , path , flags , allocated , bh_result , newblock ) ; return ret ; } } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { ext4_ext_put_gap_in_cache ( inode , path , iblock ) ; goto out2 ; } ar . lleft = iblock ; err = ext4_ext_search_left ( inode , path , & ar . lleft , & ar . pleft ) ; if ( err ) goto out2 ; ar . lright = iblock ; err = ext4_ext_search_right ( inode , path , & ar . lright , & ar . pright ) ; if ( err ) goto out2 ; if ( max_blocks > EXT_INIT_MAX_LEN && ! ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) ) max_blocks = EXT_INIT_MAX_LEN ; else if ( max_blocks > EXT_UNINIT_MAX_LEN && ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) ) max_blocks = EXT_UNINIT_MAX_LEN ; newex . ee_block = cpu_to_le32 ( iblock ) ; newex . ee_len = cpu_to_le16 ( max_blocks ) ; err = ext4_ext_check_overlap ( inode , & newex , path ) ; if ( err ) allocated = ext4_ext_get_actual_len ( & newex ) ; else allocated = max_blocks ; ar . inode = inode ; ar . goal = ext4_ext_find_goal ( inode , path , iblock ) ; ar . logical = iblock ; ar . len = allocated ; if ( S_ISREG ( inode -> i_mode ) ) ar . flags = EXT4_MB_HINT_DATA ; else ar . flags = 0 ; newblock = ext4_mb_new_blocks ( handle , & ar , & err ) ; if ( ! newblock ) goto out2 ; ext_debug ( ""allocatenewblock:goal%llu,found%llu/%u\\n"" , ar . goal , newblock , allocated ) ; ext4_ext_store_pblock ( & newex , newblock ) ; newex . ee_len = cpu_to_le16 ( ar . len ) ; if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) { ext4_ext_mark_uninitialized ( & newex ) ;  if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {  if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;  }  } if ( unlikely ( EXT4_I ( inode ) -> i_flags & EXT4_EOFBLOCKS_FL ) ) { if ( eh -> eh_entries ) { last_ex = EXT_LAST_EXTENT ( eh ) ; if ( iblock + ar . len > le32_to_cpu ( last_ex -> ee_block ) + ext4_ext_get_actual_len ( last_ex ) ) EXT4_I ( inode ) -> i_flags &= ~ EXT4_EOFBLOCKS_FL ; } else { WARN_ON ( eh -> eh_entries == 0 ) ; ext4_error ( inode -> i_sb , __func__ , ""inode#%lu,eh->eh_entries=0!"" , inode -> i_ino ) ; } } err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err ) { ext4_discard_preallocations ( inode ) ; ext4_free_blocks ( handle , inode , 0 , ext_pblock ( & newex ) , ext4_ext_get_actual_len ( & newex ) , 0 ) ; goto out2 ; } newblock = ext_pblock ( & newex ) ; allocated = ext4_ext_get_actual_len ( & newex ) ; if ( allocated > max_blocks ) allocated = max_blocks ; set_buffer_new ( bh_result ) ; if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 1 ) ; if ( ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) == 0 ) { ext4_ext_put_in_cache ( inode , iblock , allocated , newblock , EXT4_EXT_CACHE_EXTENT ) ; ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; } else ext4_update_inode_fsync_trans ( handle , inode , 0 ) ; out : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; set_buffer_mapped ( bh_result ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }", ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) )  { if (  ) ; } if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;
88,"CWE-000 int main ( argc , argv ) int argc ; char * argv [ ] ; { krb5_data pname_data , tkt_data ; int sock = 0 ; socklen_t l ; int retval ; struct sockaddr_in l_inaddr , f_inaddr ; krb5_creds creds , * new_creds ; krb5_ccache cc ; krb5_data msgtext , msg ; krb5_context context ; krb5_auth_context auth_context = NULL ; # ifndef DEBUG freopen ( ""/tmp/uu-server.log"" , ""w"" , stderr ) ; # endif retval = krb5_init_context ( & context ) ; if ( retval ) { com_err ( argv [ 0 ] , retval , ""whileinitializingkrb5"" ) ; exit ( 1 ) ; } # ifdef DEBUG { int one = 1 ; int acc ; struct servent * sp ; socklen_t namelen = sizeof ( f_inaddr ) ; if ( ( sock = socket ( PF_INET , SOCK_STREAM , 0 ) ) < 0 ) { com_err ( ""uu-server"" , errno , ""creatingsocket"" ) ; exit ( 3 ) ; } l_inaddr . sin_family = AF_INET ; l_inaddr . sin_addr . s_addr = 0 ; if ( argc == 2 ) { l_inaddr . sin_port = htons ( atoi ( argv [ 1 ] ) ) ; } else { if ( ! ( sp = getservbyname ( ""uu-sample"" , ""tcp"" ) ) ) { com_err ( ""uu-server"" , 0 , ""can\'tfinduu-sample/tcpservice"" ) ; exit ( 3 ) ; } l_inaddr . sin_port = sp -> s_port ; } ( void ) setsockopt ( sock , SOL_SOCKET , SO_REUSEADDR , ( char * ) & one , sizeof ( one ) ) ; if ( bind ( sock , ( struct sockaddr * ) & l_inaddr , sizeof ( l_inaddr ) ) ) { com_err ( ""uu-server"" , errno , ""bindingsocket"" ) ; exit ( 3 ) ; } if ( listen ( sock , 1 ) == - 1 ) { com_err ( ""uu-server"" , errno , ""listening"" ) ; exit ( 3 ) ; } printf ( ""Serverstarted\\n"" ) ; fflush ( stdout ) ; if ( ( acc = accept ( sock , ( struct sockaddr * ) & f_inaddr , & namelen ) ) == - 1 ) { com_err ( ""uu-server"" , errno , ""accepting"" ) ; exit ( 3 ) ; } dup2 ( acc , 0 ) ; close ( sock ) ; sock = 0 ; } # endif retval = krb5_read_message ( context , ( krb5_pointer ) & sock , & pname_data ) ;  if ( retval ) {  com_err ( ""uu-server"" , retval , ""readingpname"" ) ; return 2 ; } retval = krb5_read_message ( context , ( krb5_pointer ) & sock , & tkt_data ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""readingticketdata"" ) ; return 2 ; } retval = krb5_cc_default ( context , & cc ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""gettingcredentialscache"" ) ; return 4 ; } memset ( & creds , 0 , sizeof ( creds ) ) ; retval = krb5_cc_get_principal ( context , cc , & creds . client ) ; if ( retval ) { com_err ( ""uu-client"" , retval , ""gettingprincipalname"" ) ; return 6 ; } printf ( ""uu-server:clientprincipalis\\""%s\\"".\\n"" , pname_data . data ) ; retval = krb5_parse_name ( context , pname_data . data , & creds . server ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""parsingclientname"" ) ; return 3 ; } creds . second_ticket = tkt_data ; printf ( ""uu-server:clientticketis%dbytes.\\n"" , creds . second_ticket . length ) ; retval = krb5_get_credentials ( context , KRB5_GC_USER_USER , cc , & creds , & new_creds ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""gettinguser-userticket"" ) ; return 5 ; } # ifndef DEBUG l = sizeof ( f_inaddr ) ; if ( getpeername ( 0 , ( struct sockaddr * ) & f_inaddr , & l ) == - 1 ) { com_err ( ""uu-server"" , errno , ""gettingclientaddress"" ) ; return 6 ; } # endif l = sizeof ( l_inaddr ) ; if ( getsockname ( 0 , ( struct sockaddr * ) & l_inaddr , & l ) == - 1 ) { com_err ( ""uu-server"" , errno , ""gettinglocaladdress"" ) ; return 6 ; } retval = krb5_auth_con_init ( context , & auth_context ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""makingauth_context"" ) ; return 8 ; } retval = krb5_auth_con_setflags ( context , auth_context , KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""initializingtheauth_contextflags"" ) ; return 8 ; } retval = krb5_auth_con_genaddrs ( context , auth_context , sock , KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR | KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""generatingaddrsforauth_context"" ) ; return 9 ; } # if 1 retval = krb5_mk_req_extended ( context , & auth_context , AP_OPTS_USE_SESSION_KEY , NULL , new_creds , & msg ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""makingAP_REQ"" ) ; return 8 ; } retval = krb5_write_message ( context , ( krb5_pointer ) & sock , & msg ) ; # else retval = krb5_sendauth ( context , & auth_context , ( krb5_pointer ) & sock , ""???"" , 0 , 0 , AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY , NULL , & creds , cc , NULL , NULL , NULL ) ; # endif if ( retval ) goto cl_short_wrt ; free ( msg . data ) ; msgtext . length = 32 ; msgtext . data = ""Hello,otherendofconnection."" ; retval = krb5_mk_safe ( context , auth_context , & msgtext , & msg , NULL ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""encodingmessagetoclient"" ) ; return 6 ; } retval = krb5_write_message ( context , ( krb5_pointer ) & sock , & msg ) ; if ( retval ) { cl_short_wrt : com_err ( ""uu-server"" , retval , ""writingmessagetoclient"" ) ; return 7 ; } krb5_free_data_contents ( context , & msg ) ; krb5_free_data_contents ( context , & pname_data ) ; krb5_free_cred_contents ( context , & creds ) ; krb5_free_creds ( context , new_creds ) ; krb5_cc_close ( context , cc ) ; krb5_auth_con_free ( context , auth_context ) ; krb5_free_context ( context ) ; return 0 ; }", if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0'
89,"CWE-125 static int jpeg_size ( unsigned char * data , unsigned int data_size , int * width , int * height ) { int i = 0 ; if ( i + 3 < data_size && data [ i ] == 0xFF && data [ i + 1 ] == 0xD8 && data [ i + 2 ] == 0xFF && data [ i + 3 ] == 0xE0 ) { i += 4 ; if ( i + 6 < data_size && data [ i + 2 ] == 'J' && data [ i + 3 ] == 'F' && data [ i + 4 ] == 'I' && data [ i + 5 ] == 'F' && data [ i + 6 ] == 0x00 ) { unsigned short block_length = data [ i ] * 256 + data [ i + 1 ] ; while ( i < data_size ) { i += block_length ; if ( ( i + 1 ) >= data_size ) return - 1 ; if ( data [ i ] != 0xFF ) return - 1 ; if ( data [ i + 1 ] == 0xC0 ) { * height = data [ i + 5 ] * 256 + data [ i + 6 ] ; * width = data [ i + 7 ] * 256 + data [ i + 8 ] ; return 0 ; } i += 2 ;  block_length = data [ i ] * 256 + data [ i + 1 ] ;  } } } return - 1 ; }", += 2 ; if ( i + 1 < data_size )
90,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; BoxBlurContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int plane ; int cw = FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) , ch = FF_CEIL_RSHIFT ( in -> height , s -> vsub ) ; int w [ 4 ] = { inlink -> w , cw , cw , inlink -> w } ; int h [ 4 ] = { in -> height , ch , ch , in -> height } ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ;  for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ )  hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;  for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ )  vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }", = 0 ;  plane < 4  plane < 4 && in -> data [ plane ] && in -> linesize [ plane ]  = 0 ;  plane < 4  plane < 4 && in -> data [ plane ] && in -> linesize [ plane ]
91,"CWE-119 static void define_gf_group ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) {  RATE_CONTROL * const rc = & cpi -> rc ;   VP9_CONFIG * const oxcf = & cpi -> oxcf ;   struct twopass_rc * const twopass = & cpi -> twopass ;   FIRSTPASS_STATS next_frame = { 0 } ;   const FIRSTPASS_STATS * start_pos ;  int i ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ;  double gf_first_frame_err = 0.0 ;  double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double zero_motion_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double last_loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mv_ratio_accumulator_thresh ;  const int max_bits = frame_max_bits ( rc , oxcf ) ;  unsigned int allow_alt_ref = oxcf -> play_alternate && oxcf -> lag_in_frames ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; twopass -> gf_group_bits = 0 ; vp9_clear_system_state ( ) ; start_pos = twopass -> stats_in ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) gf_group_err -= gf_first_frame_err ;  mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ;  active_max_gf_interval = 12 + ( ( int ) vp9_convert_qindex_to_q ( rc -> last_q [ INTER_FRAME ] ) >> 5 ) ; if ( active_max_gf_interval > rc -> max_gf_interval )  active_max_gf_interval = rc -> max_gf_interval ;  i = 0 ; while ( i < rc -> static_scene_max_gf_interval && i < rc -> frames_to_key ) { ++ i ;  mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;  gf_group_err += mod_frame_err ;  if ( EOF == input_stats ( twopass , & next_frame ) )  break ; flash_detected = detect_flash ( twopass , 0 ) ; accumulate_frame_motion_stats ( & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; if ( ! flash_detected ) { last_loop_decay_rate = loop_decay_rate ;  loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ;  decay_accumulator = decay_accumulator * loop_decay_rate ;  if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) <  zero_motion_accumulator ) { zero_motion_accumulator = next_frame . pcnt_inter - next_frame . pcnt_motion ; }  if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate ,  last_loop_decay_rate ) ) { allow_alt_ref = 0 ; break ; } }  boost_score += ( decay_accumulator *   calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ;  if (  ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) ||  (  ( i > MIN_GF_INTERVAL ) &&  ( ( boost_score > 125.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) ||  ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) {  boost_score = old_boost_score ; break ; } * this_frame = next_frame ; old_boost_score = boost_score ; } twopass -> gf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 1000.0 ) ;  if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) {   while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) {  ++ i ; if ( EOF == input_stats ( twopass , this_frame ) ) break ;  if ( i < rc -> frames_to_key ) {  mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { cpi -> new_frame_coding_order_period = 0 ; cpi -> next_frame_in_order = 0 ; cpi -> arf_buffered = 0 ; vp9_zero ( cpi -> frame_coding_order ) ; vp9_zero ( cpi -> arf_buffer_idx ) ; vpx_memset ( cpi -> arf_weight , - 1 , sizeof ( cpi -> arf_weight ) ) ; } # endif if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active )  rc -> baseline_gf_interval = i - 1 ;  else  rc -> baseline_gf_interval = i ;  if ( allow_alt_ref &&  ( i < cpi -> oxcf . lag_in_frames ) &&  ( i >= MIN_GF_INTERVAL ) && ( rc -> next_key_frame_forced || ( i <= ( rc -> frames_to_key - MIN_GF_INTERVAL ) ) ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { schedule_frames ( cpi , 0 , - ( rc -> baseline_gf_interval - 1 ) , 2 , 1 , 0 ) ; } # endif  } else {  rc -> gfu_boost = ( int ) boost_score ; rc -> source_alt_ref_pending = 0 ; # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { schedule_frames ( cpi , 0 , rc -> baseline_gf_interval - 1 , 2 , 0 , 0 ) ; assert ( cpi -> new_frame_coding_order_period == rc -> baseline_gf_interval ) ; } # endif } # if CONFIG_MULTIPLE_ARF  if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) {  int max_level = INT_MIN ; for ( i = 0 ; i < cpi -> frame_coding_order_period ; ++ i ) { if ( cpi -> arf_weight [ i ] > max_level ) { max_level = cpi -> arf_weight [ i ] ; } } ++ max_level ; for ( i = 0 ; i < cpi -> frame_coding_order_period ; ++ i ) { if ( cpi -> arf_weight [ i ] == - 1 ) { cpi -> arf_weight [ i ] = max_level ; } } cpi -> max_arf_level = max_level ; } # if 0 if ( cpi -> multi_arf_enabled ) { printf ( ""\\nSchedule:"" ) ; for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { printf ( ""%4d"" , cpi -> frame_coding_order [ i ] ) ; } printf ( ""\\n"" ) ; printf ( ""ARFref:"" ) ; for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { printf ( ""%4d"" , cpi -> arf_buffer_idx [ i ] ) ; } printf ( ""\\n"" ) ; printf ( ""Weight:"" ) ; for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { printf ( ""%4d"" , cpi -> arf_weight [ i ] ) ; } printf ( ""\\n"" ) ; } # endif # endif if ( twopass -> kf_group_bits > 0 && twopass -> kf_group_error_left > 0 ) { twopass -> gf_group_bits = ( int64_t ) ( twopass -> kf_group_bits * ( gf_group_err / twopass -> kf_group_error_left ) ) ; } else { twopass -> gf_group_bits = 0 ; } twopass -> gf_group_bits = ( twopass -> gf_group_bits < 0 ) ? 0 : ( twopass -> gf_group_bits > twopass -> kf_group_bits ) ? twopass -> kf_group_bits : twopass -> gf_group_bits ; if ( twopass -> gf_group_bits > ( int64_t ) max_bits * rc -> baseline_gf_interval ) twopass -> gf_group_bits = ( int64_t ) max_bits * rc -> baseline_gf_interval ; reset_fpf_position ( twopass , start_pos ) ; for ( i = 0 ; i <= ( rc -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; ++ i ) { int allocation_chunks ; int q = rc -> last_q [ INTER_FRAME ] ; int gf_bits ; int boost = ( rc -> gfu_boost * gfboost_qadjust ( q ) ) / 100 ; boost = clamp ( boost , 125 , ( rc -> baseline_gf_interval + 1 ) * 200 ) ; if ( rc -> source_alt_ref_pending && i == 0 ) allocation_chunks = ( ( rc -> baseline_gf_interval + 1 ) * 100 ) + boost ; else allocation_chunks = ( rc -> baseline_gf_interval * 100 ) + ( boost - 100 ) ; if ( boost > 1023 ) { int divisor = boost >> 10 ; boost /= divisor ; allocation_chunks /= divisor ; } gf_bits = ( int ) ( ( double ) boost * ( twopass -> gf_group_bits / ( double ) allocation_chunks ) ) ; if ( rc -> baseline_gf_interval < 1 || mod_frame_err < gf_group_err / ( double ) rc -> baseline_gf_interval ) { double alt_gf_grp_bits = ( double ) twopass -> kf_group_bits * ( mod_frame_err * ( double ) rc -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( twopass -> kf_group_error_left ) ; int alt_gf_bits = ( int ) ( ( double ) boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) gf_bits = alt_gf_bits ; } else { int alt_gf_bits = ( int ) ( ( double ) twopass -> kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( twopass -> kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) gf_bits = alt_gf_bits ; } if ( gf_bits < 0 ) gf_bits = 0 ; if ( i == 0 ) { twopass -> gf_bits = gf_bits ; } if ( i == 1 || ( ! rc -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ) { vp9_rc_set_frame_target ( cpi , gf_bits ) ; } } { twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { twopass -> gf_group_error_left = ( int64_t ) ( gf_group_err - mod_frame_err ) ; } else if ( cpi -> common . frame_type != KEY_FRAME ) { twopass -> gf_group_error_left = ( int64_t ) ( gf_group_err - gf_first_frame_err ) ; } else { twopass -> gf_group_error_left = ( int64_t ) gf_group_err ; } if ( rc -> baseline_gf_interval >= 3 ) { const int boost = rc -> source_alt_ref_pending ? b_boost : rc -> gfu_boost ; if ( boost >= 150 ) { const int pct_extra = MIN ( 20 , ( boost - 100 ) / 50 ) ; const int alt_extra_bits = ( int ) ( ( MAX ( twopass -> gf_group_bits - twopass -> gf_bits , 0 ) * pct_extra ) / 100 ) ; twopass -> gf_group_bits -= alt_extra_bits ; } } } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; zero_stats ( & sectionstats ) ; reset_fpf_position ( twopass , start_pos ) ; for ( i = 0 ; i < rc -> baseline_gf_interval ; ++ i ) { input_stats ( twopass , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; twopass -> section_intra_rating = ( int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; reset_fpf_position ( twopass , start_pos ) ; } }"," this_frame ) { VP9_COMMON * const cm = & cpi -> common ;  -> rc ; VP9EncoderConfig  * const oxcf  -> oxcf ; TWO_PASS  * const twopass  ; FIRSTPASS_STATS next_frame  ; const FIRSTPASS_STATS  const FIRSTPASS_STATS * const start_pos = twopass -> stats_in  ; int i  = 0.0 ; # if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ; # endif double gf_group_skip_pct = 0.0 ; double gf_group_inactive_zone_rows = 0.0 ;  double mv_ratio_accumulator_thresh ; unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; int active_min_gf_interval ; int64_t gf_group_bits ; double gf_group_error_left ; int gf_arf_bits ; const int is_key_frame = frame_is_intra_only ( cm ) ; const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; if ( is_key_frame == 0 ) { vp9_zero ( twopass -> gf_group ) ; } vpx_clear_system_state ( ) ; vp9_zero ( next_frame ) ; mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( arf_active_or_kf ) {  gf_group_err -= gf_first_frame_err  -= gf_first_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ; # endif gf_group_skip_pct -= this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; } mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; { int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality ,  cpi -> common  -> common . bit_depth ) ) ; int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex ,  cpi -> common  -> common . bit_depth ) ) ; active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ; if ( cpi -> multi_arf_allowed ) { active_max_gf_interval = rc -> max_gf_interval ; } else { active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval  ; if (  -> max_gf_interval ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ; } }  ( cpi , twopass , oxcf ,  += mod_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ;  = get_prediction_decay_rate ( cpi  , & next_frame  * loop_decay_rate ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ;  if ( detect_transition_to_still  ( detect_transition_to_still ( cpi  , i ,  } boost_score +=  decay_accumulator * calc_frame_boost  next_frame , this_frame_mv_in_out , GF_MAX_BOOST  ) ; if  ( i >= ( active_max_gf_interval + arf_active_or_kf ) &&  zero_motion_accumulator < 0.995  < 0.995 )  || ( (  ( ( i >= active_min_gf_interval + arf_active_or_kf  ) && (  old_boost_score ) < BOOST_BREAKOUT  ) ) )  1000.0 ) ; rc -> constrained_gf_group = ( i >=  rc -> frames_to_key  rc -> frames_to_key ) ? 1 : 0 ; if ( allow_alt_ref &&  ( i <  ( i < cpi -> oxcf . lag_in_frames ) && ( i >= rc -> min_gf_interval ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; } else { rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; rc -> source_alt_ref_pending = 0 ; } rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) {  if ( EOF  ) break ; gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; }  rc -> baseline_gf_interval  -> baseline_gf_interval = new_gf_interval ; } rc -> frames_till_gf_update_due =  rc -> baseline_gf_interval  rc -> baseline_gf_interval ; reset_fpf_position ( twopass , start_pos ) ; gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; # if GROUP_ADAPTIVE_MAXQ if ( (  cpi -> oxcf  -> oxcf . rc_mode != VPX_Q ) && ( rc -> baseline_gf_interval > 1 ) ) { const int vbr_group_bits_per_frame = ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; const double group_av_skip_pct = gf_group_skip_pct / rc -> baseline_gf_interval ; const double group_av_inactive_zone = ( ( gf_group_inactive_zone_rows * 2 ) / ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; int tmp_q ; double rc_factor = 1.0 ; if ( rc -> rate_error_estimate > 0 ) { rc_factor = MAX ( RC_FACTOR_MIN , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } else { rc_factor = MIN ( RC_FACTOR_MAX , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } tmp_q = get_twopass_worst_quality ( cpi , group_av_err , ( group_av_skip_pct + group_av_inactive_zone ) , vbr_group_bits_per_frame , twopass -> kfgroup_inter_fraction * rc_factor ) ; twopass -> active_worst_quality = MAX ( tmp_q , twopass -> active_worst_quality >> 1  ) ; }  } # endif gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ; twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { gf_group_error_left = gf_group_err - mod_frame_err ; } else if ( is_key_frame == 0 ) { gf_group_error_left = gf_group_err - gf_first_frame_err ; } else { gf_group_error_left = gf_group_err ; } allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; reset_fpf_position ( twopass , start_pos ) ; if  ( cpi ->  != KEY_FRAME ) { twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ; } if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED  ; } }"
92,"CWE-401 static int nfp_flower_spawn_vnic_reprs ( struct nfp_app * app , enum nfp_flower_cmsg_port_vnic_type vnic_type , enum nfp_repr_type repr_type , unsigned int cnt ) { u8 nfp_pcie = nfp_cppcore_pcie_unit ( app -> pf -> cpp ) ; struct nfp_flower_priv * priv = app -> priv ; atomic_t * replies = & priv -> reify_replies ; struct nfp_flower_repr_priv * repr_priv ; enum nfp_port_type port_type ; struct nfp_repr * nfp_repr ; struct nfp_reprs * reprs ; int i , err , reify_cnt ; const u8 queue = 0 ; port_type = repr_type == NFP_REPR_TYPE_PF ? NFP_PORT_PF_PORT : NFP_PORT_VF_PORT ; reprs = nfp_reprs_alloc ( cnt ) ; if ( ! reprs ) return - ENOMEM ; for ( i = 0 ; i < cnt ; i ++ ) { struct net_device * repr ; struct nfp_port * port ; u32 port_id ; repr = nfp_repr_alloc ( app ) ; if ( ! repr ) { err = - ENOMEM ; goto err_reprs_clean ; } repr_priv = kzalloc ( sizeof ( * repr_priv ) , GFP_KERNEL ) ; if ( ! repr_priv ) { err = - ENOMEM ;  goto err_reprs_clean ;  } nfp_repr = netdev_priv ( repr ) ; nfp_repr -> app_priv = repr_priv ; repr_priv -> nfp_repr = nfp_repr ; WARN_ON ( repr_type == NFP_REPR_TYPE_PF && i ) ; port = nfp_port_alloc ( app , port_type , repr ) ; if ( IS_ERR ( port ) ) { err = PTR_ERR ( port ) ;  nfp_repr_free ( repr ) ;  goto err_reprs_clean ; } if ( repr_type == NFP_REPR_TYPE_PF ) { port -> pf_id = i ; port -> vnic = priv -> nn -> dp . ctrl_bar ; } else { port -> pf_id = 0 ; port -> vf_id = i ; port -> vnic = app -> pf -> vf_cfg_mem + i * NFP_NET_CFG_BAR_SZ ; } eth_hw_addr_random ( repr ) ; port_id = nfp_flower_cmsg_pcie_port ( nfp_pcie , vnic_type , i , queue ) ; err = nfp_repr_init ( app , repr , port_id , port , priv -> nn -> dp . netdev ) ;  if ( err ) {  nfp_port_free ( port ) ; nfp_repr_free ( repr ) ; goto err_reprs_clean ; } RCU_INIT_POINTER ( reprs -> reprs [ i ] , repr ) ; nfp_info ( app -> cpp , ""%s%dRepresentor(%s)created\\n"" , repr_type == NFP_REPR_TYPE_PF ? ""PF"" : ""VF"" , i , repr -> name ) ; } nfp_app_reprs_set ( app , repr_type , reprs ) ; atomic_set ( replies , 0 ) ; reify_cnt = nfp_flower_reprs_reify ( app , repr_type , true ) ; if ( reify_cnt < 0 ) { err = reify_cnt ; nfp_warn ( app -> cpp , ""Failedtonotifyfirmwareaboutreprcreation\\n"" ) ; goto err_reprs_remove ; } err = nfp_flower_wait_repr_reify ( app , replies , reify_cnt ) ; if ( err ) goto err_reprs_remove ; return 0 ; err_reprs_remove : reprs = nfp_app_reprs_set ( app , repr_type , NULL ) ; err_reprs_clean : nfp_reprs_clean_and_free ( app , reprs ) ; return err ; }", - ENOMEM ; nfp_repr_free ( repr ) ;  port ) ; kfree ( repr_priv ) ;  err ) { kfree ( repr_priv ) ;
93,"CWE-264 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Badoffset%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:element%psize%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip_checkentry ( & e -> ip ) ) return - EINVAL ;  err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;  if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflowsmustbeunconditionaland"" ""usetheSTANDARDtargetwith"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }"," , e -> elems , e ->"
94,"CWE-200 static int pptp_connect ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; struct rtable * rt ; struct flowi4 fl4 ; int error = 0 ;  if ( sp -> sa_protocol != PX_PROTO_PPTP )  return - EINVAL ; if ( lookup_chan_dst ( sp -> sa_addr . pptp . call_id , sp -> sa_addr . pptp . sin_addr . s_addr ) ) return - EALREADY ; lock_sock ( sk ) ; if ( sk -> sk_state & PPPOX_CONNECTED ) { error = - EBUSY ; goto end ; } if ( sk -> sk_state & PPPOX_DEAD ) { error = - EALREADY ; goto end ; } if ( ! opt -> src_addr . sin_addr . s_addr || ! sp -> sa_addr . pptp . sin_addr . s_addr ) { error = - EINVAL ; goto end ; } po -> chan . private = sk ; po -> chan . ops = & pptp_chan_ops ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , opt -> dst_addr . sin_addr . s_addr , opt -> src_addr . sin_addr . s_addr , 0 , 0 , IPPROTO_GRE , RT_CONN_FLAGS ( sk ) , 0 ) ; if ( IS_ERR ( rt ) ) { error = - EHOSTUNREACH ; goto end ; } sk_setup_caps ( sk , & rt -> dst ) ; po -> chan . mtu = dst_mtu ( & rt -> dst ) ; if ( ! po -> chan . mtu ) po -> chan . mtu = PPP_MRU ; ip_rt_put ( rt ) ; po -> chan . mtu -= PPTP_HEADER_OVERHEAD ; po -> chan . hdrlen = 2 + sizeof ( struct pptp_gre_header ) ; error = ppp_register_channel ( & po -> chan ) ; if ( error ) { pr_err ( ""PPTP:failedtoregisterPPPchannel(%d)\\n"" , error ) ; goto end ; } opt -> dst_addr = sp -> sa_addr . pptp ; sk -> sk_state = PPPOX_CONNECTED ; end : release_sock ( sk ) ; return error ; }", ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if (
95,"CWE-20 static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ;  RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;  if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ;  if ( unlikely ( work_to_do < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ;  if ( unlikely ( ret < 0 ) ) {  netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Badpacketsize:%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) {  netdev_dbg ( vif -> dev ,  ""txreq.offset:%x,size:%u,end:%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'tallocateaskbinstart_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ;  netbk_tx_err ( vif , & txreq , idx ) ;  continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }"," ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossiblenumberofrequests."" ""req_prod%d,req_cons%d,size%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; }  0 ) ) continue ;  } ret =  0 ) ) continue ;  idx += ret  ) ) { netdev_err  ( vif ->  size ) ; netbk_fatal_tx_err ( vif  ) ; continue  skb ) ;  continue ; }"
96,"CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; }  ret = vfs_dedupe_file_range ( file , same ) ;  if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }", out ; } same -> dest_count = count ;
97,"CWE-601 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""ControlcharacterdetectedinURL."" ) ; return HTTP_BAD_REQUEST ; }  }  return OK ; }"," HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""BackslashcharacterdetectedinURL."" ) ; return HTTP_BAD_REQUEST ; }"
98,"CWE-22 local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""nametoolong:"" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , ""toolarge--notcompiledwithlargefilesupport"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%sdoesnotexist--skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%sisaspecialfileordevice--skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%sisasymboliclink--skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%sisadirectory--skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""notenoughmemory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""notenoughmemory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""pathtoolong"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""pathtoolong:"" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%sendswith%s--skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%sdoesnothavecompressedsuffix--skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""readerroron"" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%sisnotcompressed--skipping"" : ""%shasunknowncompressionmethod--skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""notenoughmemory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""tryingtowritecompresseddatatoaterminal"" , ""(use-ftoforce)"" ) ; } else {  char * to , * repl ;  to = g . inf ;  if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {   to = g . hname ;   len = strlen ( g . hname ) ;  }  repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ;   g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ;  if ( g . outf == NULL ) bail ( ""notenoughmemory"" , """" ) ;  memcpy ( g . outf , to , len ) ;   strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ;  g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%sexists--overwrite(y/n)?"" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != '' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%sexists--skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""writeerroron"" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%sto%s"" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""writeerroron"" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }"," char * to = g . inf , * sufx = """" ; size_t pre = 0  ; if (  g . decode ) { if (  ( g .  NULL ) { pre = justname ( g . inf ) - g . inf ; to = justname (  g . hname  g . hname )  = strlen ( to ) ; } else if (  strcmp ( to  , "".tgz"" ) == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ;  g . outf  = MALLOC ( pre + len + strlen ( sufx )  + 1 )  . outf , g . inf , pre ) ; memcpy  ( g .  . outf + pre , to , len ) ; strcpy ( g . outf + pre + len ,  sufx ) ;"
99,"CWE-119 static int uio_mmap_physical ( struct vm_area_struct * vma ) { struct uio_device * idev = vma -> vm_private_data ; int mi = uio_find_mem_index ( vma ) ;  if ( mi < 0 )  return - EINVAL ; vma -> vm_ops = & uio_physical_vm_ops ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; return remap_pfn_range ( vma , vma -> vm_start ,  idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }"," vma ) ; struct uio_mem * mem ;  mi < 0 ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size  -> vm_start , mem ->  addr >> PAGE_SHIFT"
100,"CWE-787 int jbig2_image_compose ( Jbig2Ctx * ctx , Jbig2Image * dst , Jbig2Image * src , int x , int y , Jbig2ComposeOp op ) { uint32_t w , h ; uint32_t shift ; uint32_t leftbyte ; uint8_t * ss ; uint8_t * dd ; uint8_t leftmask , rightmask ; int early = x >= 0 ; int late ; uint32_t bytewidth ; uint32_t syoffset = 0 ; if ( src == NULL )  return 0 ;  w = src -> width ; h = src -> height ; shift = ( x & 7 ) ; ss = src -> data - early ; if ( x < 0 ) { if ( w < ( uint32_t ) - x ) w = 0 ; else w += x ; ss += ( - x - 1 ) >> 3 ; x = 0 ; } if ( y < 0 ) { if ( h < ( uint32_t ) - y ) h = 0 ; else h += y ; syoffset = - y * src -> stride ; y = 0 ; } if ( ( uint32_t ) x + w > dst -> width ) { if ( dst -> width < ( uint32_t ) x ) w = 0 ; else w = dst -> width - x ; } if ( ( uint32_t ) y + h > dst -> height ) { if ( dst -> height < ( uint32_t ) y ) h = 0 ; else h = dst -> height - y ; } # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""compositing%dx%dat(%d,%d)afterclipping"" , w , h , x , y ) ; # endif if ( ( w <= 0 ) || ( h <= 0 ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""zeroclippingregion"" ) ; # endif return 0 ; } leftbyte = ( uint32_t ) x >> 3 ; dd = dst -> data + y * dst -> stride + leftbyte ; bytewidth = ( ( ( uint32_t ) x + w - 1 ) >> 3 ) - leftbyte + 1 ; leftmask = 255 >> ( x & 7 ) ; rightmask = ( ( ( x + w ) & 7 ) == 0 ) ? 255 : ~ ( 255 >> ( ( x + w ) & 7 ) ) ; if ( bytewidth == 1 ) leftmask &= rightmask ; late = ( ss + bytewidth >= src -> data + ( ( src -> width + 7 ) >> 3 ) ) ; ss += syoffset ; switch ( op ) { case JBIG2_COMPOSE_OR : jbig2_image_compose_opt_OR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_AND : jbig2_image_compose_opt_AND ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XOR : jbig2_image_compose_opt_XOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_XNOR : jbig2_image_compose_opt_XNOR ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; case JBIG2_COMPOSE_REPLACE : jbig2_image_compose_opt_REPLACE ( ss , dd , early , late , leftmask , rightmask , bytewidth , h , shift , dst -> stride , src -> stride ) ; break ; } return 0 ; }"," return 0 ; if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""overflowincompose_image"" ) ; # endif return 0 ; }"
101,"CWE-362 static int  mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr )  {  MPT_ADAPTER * ioc ;  MPT_FRAME_HDR * mf = NULL ; MPIHeader_t * hdr ; char * psge ; struct buflist bufIn ; struct buflist bufOut ; dma_addr_t dma_addr_in ; dma_addr_t dma_addr_out ; int sgSize = 0 ;  int iocnum , flagsLength ;  int sz , rc = 0 ; int msgContext ; u16 req_idx ; ulong timeout ; unsigned long timeleft ; struct scsi_device * sdev ; unsigned long flags ; u8 function ; bufIn . kptr = bufOut . kptr = NULL ; bufIn . len = bufOut . len = 0 ;  if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_do_mpt_command()@%d-ioc%dnotfound!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } spin_lock_irqsave ( & ioc -> taskmgmt_lock , flags ) ; if ( ioc -> ioc_reset_in_progress ) { spin_unlock_irqrestore ( & ioc -> taskmgmt_lock , flags ) ; printk ( KERN_ERR MYNAM ""%s@%d::mptctl_do_mpt_command-"" ""Busywithdiagnosticreset\\n"" , __FILE__ , __LINE__ ) ; return - EBUSY ; } spin_unlock_irqrestore ( & ioc -> taskmgmt_lock , flags ) ; if ( karg . maxReplyBytes < 0 || karg . dataInSize < 0 || karg . dataOutSize < 0 || karg . dataSgeOffset < 0 || karg . maxSenseBytes < 0 || karg . dataSgeOffset > ioc -> req_sz / 4 ) return - EINVAL ; sz = karg . dataSgeOffset * 4 ; if ( karg . dataInSize > 0 ) sz += ioc -> SGE_size ; if ( karg . dataOutSize > 0 ) sz += ioc -> SGE_size ; if ( sz > ioc -> req_sz ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""Requestframetoolarge(%d)maximum(%d)\\n"" , ioc -> name , __FILE__ , __LINE__ , sz , ioc -> req_sz ) ; return - EFAULT ; } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == NULL ) return - EAGAIN ; hdr = ( MPIHeader_t * ) mf ; msgContext = le32_to_cpu ( hdr -> MsgContext ) ; req_idx = le16_to_cpu ( mf -> u . frame . hwhdr . msgctxu . fld . req_idx ) ; if ( copy_from_user ( mf , mfPtr , karg . dataSgeOffset * 4 ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""UnabletoreadMFfrommpt_ioctl_commandstruct@%p\\n"" , ioc -> name , __FILE__ , __LINE__ , mfPtr ) ; function = - 1 ; rc = - EFAULT ; goto done_free_mem ; } hdr -> MsgContext = cpu_to_le32 ( msgContext ) ; function = hdr -> Function ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""sendingmpifunction(0x%02X),req=%p\\n"" , ioc -> name , hdr -> Function , mf ) ) ; switch ( function ) { case MPI_FUNCTION_IOC_FACTS : case MPI_FUNCTION_PORT_FACTS : karg . dataOutSize = karg . dataInSize = 0 ; break ; case MPI_FUNCTION_CONFIG : { Config_t * config_frame ; config_frame = ( Config_t * ) mf ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""\\ttype=0x%02xext_type=0x%02x"" ""number=0x%02xaction=0x%02x\\n"" , ioc -> name , config_frame -> Header . PageType , config_frame -> ExtPageType , config_frame -> Header . PageNumber , config_frame -> Action ) ) ; break ; } case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND : case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND : case MPI_FUNCTION_FW_UPLOAD : case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR : case MPI_FUNCTION_FW_DOWNLOAD : case MPI_FUNCTION_FC_PRIMITIVE_SEND : case MPI_FUNCTION_TOOLBOX : case MPI_FUNCTION_SAS_IO_UNIT_CONTROL : break ; case MPI_FUNCTION_SCSI_IO_REQUEST : if ( ioc -> sh ) { SCSIIORequest_t * pScsiReq = ( SCSIIORequest_t * ) mf ; int qtag = MPI_SCSIIO_CONTROL_UNTAGGED ; int scsidir = 0 ; int dataSize ; u32 id ; id = ( ioc -> devices_per_bus == 0 ) ? 256 : ioc -> devices_per_bus ; if ( pScsiReq -> TargetID > id ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""TargetIDoutofbounds.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - ENODEV ; goto done_free_mem ; } if ( pScsiReq -> Bus >= ioc -> number_of_buses ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""TargetBusoutofbounds.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - ENODEV ; goto done_free_mem ; } pScsiReq -> MsgFlags &= ~ MPI_SCSIIO_MSGFLGS_SENSE_WIDTH ; pScsiReq -> MsgFlags |= mpt_msg_flags ( ioc ) ; if ( karg . maxSenseBytes > MPT_SENSE_BUFFER_SIZE ) pScsiReq -> SenseBufferLength = MPT_SENSE_BUFFER_SIZE ; else pScsiReq -> SenseBufferLength = karg . maxSenseBytes ; pScsiReq -> SenseBufferLowAddr = cpu_to_le32 ( ioc -> sense_buf_low_dma + ( req_idx * MPT_SENSE_BUFFER_ALLOC ) ) ; shost_for_each_device ( sdev , ioc -> sh ) { struct scsi_target * starget = scsi_target ( sdev ) ; VirtTarget * vtarget = starget -> hostdata ; if ( vtarget == NULL ) continue ; if ( ( pScsiReq -> TargetID == vtarget -> id ) && ( pScsiReq -> Bus == vtarget -> channel ) && ( vtarget -> tflags & MPT_TARGET_FLAGS_Q_YES ) ) qtag = MPI_SCSIIO_CONTROL_SIMPLEQ ; } if ( karg . dataOutSize > 0 ) { scsidir = MPI_SCSIIO_CONTROL_WRITE ; dataSize = karg . dataOutSize ; } else { scsidir = MPI_SCSIIO_CONTROL_READ ; dataSize = karg . dataInSize ; } pScsiReq -> Control = cpu_to_le32 ( scsidir | qtag ) ; pScsiReq -> DataLength = cpu_to_le32 ( dataSize ) ; } else { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""SCSIdriverisnotloaded.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } break ; case MPI_FUNCTION_SMP_PASSTHROUGH : break ; case MPI_FUNCTION_SATA_PASSTHROUGH : if ( ! ioc -> sh ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""SCSIdriverisnotloaded.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } break ; case MPI_FUNCTION_RAID_ACTION : break ; case MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH : if ( ioc -> sh ) { SCSIIORequest_t * pScsiReq = ( SCSIIORequest_t * ) mf ; int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ ; int scsidir = MPI_SCSIIO_CONTROL_READ ; int dataSize ; pScsiReq -> MsgFlags &= ~ MPI_SCSIIO_MSGFLGS_SENSE_WIDTH ; pScsiReq -> MsgFlags |= mpt_msg_flags ( ioc ) ; if ( karg . maxSenseBytes > MPT_SENSE_BUFFER_SIZE ) pScsiReq -> SenseBufferLength = MPT_SENSE_BUFFER_SIZE ; else pScsiReq -> SenseBufferLength = karg . maxSenseBytes ; pScsiReq -> SenseBufferLowAddr = cpu_to_le32 ( ioc -> sense_buf_low_dma + ( req_idx * MPT_SENSE_BUFFER_ALLOC ) ) ; if ( karg . dataOutSize > 0 ) { scsidir = MPI_SCSIIO_CONTROL_WRITE ; dataSize = karg . dataOutSize ; } else { scsidir = MPI_SCSIIO_CONTROL_READ ; dataSize = karg . dataInSize ; } pScsiReq -> Control = cpu_to_le32 ( scsidir | qtag ) ; pScsiReq -> DataLength = cpu_to_le32 ( dataSize ) ; } else { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""SCSIdriverisnotloaded.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } break ; case MPI_FUNCTION_SCSI_TASK_MGMT : { SCSITaskMgmt_t * pScsiTm ; pScsiTm = ( SCSITaskMgmt_t * ) mf ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""\\tTaskType=0x%xMsgFlags=0x%x"" ""TaskMsgContext=0x%xid=%dchannel=%d\\n"" , ioc -> name , pScsiTm -> TaskType , le32_to_cpu ( pScsiTm -> TaskMsgContext ) , pScsiTm -> MsgFlags , pScsiTm -> TargetID , pScsiTm -> Bus ) ) ; break ; } case MPI_FUNCTION_IOC_INIT : { IOCInit_t * pInit = ( IOCInit_t * ) mf ; u32 high_addr , sense_high ; if ( sizeof ( dma_addr_t ) == sizeof ( u64 ) ) { high_addr = cpu_to_le32 ( ( u32 ) ( ( u64 ) ioc -> req_frames_dma >> 32 ) ) ; sense_high = cpu_to_le32 ( ( u32 ) ( ( u64 ) ioc -> sense_buf_pool_dma >> 32 ) ) ; } else { high_addr = 0 ; sense_high = 0 ; } if ( ( pInit -> Flags != 0 ) || ( pInit -> MaxDevices != ioc -> facts . MaxDevices ) || ( pInit -> MaxBuses != ioc -> facts . MaxBuses ) || ( pInit -> ReplyFrameSize != cpu_to_le16 ( ioc -> reply_sz ) ) || ( pInit -> HostMfaHighAddr != high_addr ) || ( pInit -> SenseBufferHighAddr != sense_high ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""IOC_INITissuedwith1ormoreincorrectparameters.Rejected.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; rc = - EFAULT ; goto done_free_mem ; } } break ; default : printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""Illegalrequest(function0x%x)\\n"" , ioc -> name , __FILE__ , __LINE__ , hdr -> Function ) ; rc = - EFAULT ; goto done_free_mem ; } psge = ( char * ) ( ( ( int * ) mf ) + karg . dataSgeOffset ) ; flagsLength = 0 ; if ( karg . dataOutSize > 0 ) sgSize ++ ; if ( karg . dataInSize > 0 ) sgSize ++ ; if ( sgSize > 0 ) { if ( karg . dataOutSize > 0 ) { if ( karg . dataInSize > 0 ) { flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT | MPI_SGE_FLAGS_END_OF_BUFFER | MPI_SGE_FLAGS_DIRECTION ) << MPI_SGE_FLAGS_SHIFT ; } else { flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE ; } flagsLength |= karg . dataOutSize ; bufOut . len = karg . dataOutSize ; bufOut . kptr = pci_alloc_consistent ( ioc -> pcidev , bufOut . len , & dma_addr_out ) ; if ( bufOut . kptr == NULL ) { rc = - ENOMEM ; goto done_free_mem ; } else { ioc -> add_sge ( psge , flagsLength , dma_addr_out ) ; psge += ioc -> SGE_size ; if ( copy_from_user ( bufOut . kptr , karg . dataOutBufPtr , bufOut . len ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-Unable"" ""toreaduserdata"" ""struct@%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . dataOutBufPtr ) ; rc = - EFAULT ; goto done_free_mem ; } } } if ( karg . dataInSize > 0 ) { flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ ; flagsLength |= karg . dataInSize ; bufIn . len = karg . dataInSize ; bufIn . kptr = pci_alloc_consistent ( ioc -> pcidev , bufIn . len , & dma_addr_in ) ; if ( bufIn . kptr == NULL ) { rc = - ENOMEM ; goto done_free_mem ; } else { ioc -> add_sge ( psge , flagsLength , dma_addr_in ) ; } } } else { ioc -> add_sge ( psge , flagsLength , ( dma_addr_t ) - 1 ) ; } SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , hdr -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( ioc -> ioctl_cmds . status ) if ( hdr -> Function == MPI_FUNCTION_SCSI_TASK_MGMT ) { mutex_lock ( & ioc -> taskmgmt_cmds . mutex ) ; if ( mpt_set_taskmgmt_in_progress_flag ( ioc ) != 0 ) { mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } DBG_DUMP_TM_REQUEST_FRAME ( ioc , ( u32 * ) mf ) ; if ( ( ioc -> facts . IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q ) && ( ioc -> facts . MsgVersion >= MPI_VERSION_01_05 ) ) mpt_put_msg_frame_hi_pri ( mptctl_id , ioc , mf ) ; else { rc = mpt_send_handshake_request ( mptctl_id , ioc , sizeof ( SCSITaskMgmt_t ) , ( u32 * ) mf , CAN_SLEEP ) ; if ( rc != 0 ) { dfailprintk ( ioc , printk ( MYIOC_s_ERR_FMT ""send_handshakeFAILED!(ioc%p,mf%p)\\n"" , ioc -> name , ioc , mf ) ) ; mpt_clear_taskmgmt_in_progress_flag ( ioc ) ; rc = - ENODATA ; mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } } } else mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; timeout = ( karg . timeout > 0 ) ? karg . timeout : MPT_IOCTL_DEFAULT_TIMEOUT ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , HZ * timeout ) ; if ( ! ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { rc = - ETIME ; dfailprintk ( ioc , printk ( MYIOC_s_ERR_FMT ""%s:TIMEDOUT!\\n"" , ioc -> name , __func__ ) ) ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { if ( function == MPI_FUNCTION_SCSI_TASK_MGMT ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; goto done_free_mem ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""mptcmdtimeout,doorbell=0x%08x"" ""function=0x%x\\n"" , ioc -> name , mpt_GetIocState ( ioc , 0 ) , function ) ; if ( function == MPI_FUNCTION_SCSI_TASK_MGMT ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; mptctl_timeout_expired ( ioc , mf ) ; mf = NULL ; } else goto retry_wait ; goto done_free_mem ; } if ( function == MPI_FUNCTION_SCSI_TASK_MGMT ) mutex_unlock ( & ioc -> taskmgmt_cmds . mutex ) ; mf = NULL ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) { if ( karg . maxReplyBytes < ioc -> reply_sz ) { sz = min ( karg . maxReplyBytes , 4 * ioc -> ioctl_cmds . reply [ 2 ] ) ; } else { sz = min ( ioc -> reply_sz , 4 * ioc -> ioctl_cmds . reply [ 2 ] ) ; } if ( sz > 0 ) { if ( copy_to_user ( karg . replyFrameBufPtr , ioc -> ioctl_cmds . reply , sz ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""Unabletowriteoutreplyframe%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . replyFrameBufPtr ) ; rc = - ENODATA ; goto done_free_mem ; } } } if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_SENSE_VALID ) { sz = min ( karg . maxSenseBytes , MPT_SENSE_BUFFER_SIZE ) ; if ( sz > 0 ) { if ( copy_to_user ( karg . senseDataPtr , ioc -> ioctl_cmds . sense , sz ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""Unabletowritesensedatatouser%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . senseDataPtr ) ; rc = - ENODATA ; goto done_free_mem ; } } } if ( ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) && ( karg . dataInSize > 0 ) && ( bufIn . kptr ) ) { if ( copy_to_user ( karg . dataInBufPtr , bufIn . kptr , karg . dataInSize ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_mpt_command-"" ""Unabletowritedatatouser%p\\n"" , ioc -> name , __FILE__ , __LINE__ , karg . dataInBufPtr ) ; rc = - ENODATA ; } } done_free_mem : CLEAR_MGMT_STATUS ( ioc -> ioctl_cmds . status ) SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( bufOut . kptr != NULL ) { pci_free_consistent ( ioc -> pcidev , bufOut . len , ( void * ) bufOut . kptr , dma_addr_out ) ; } if ( bufIn . kptr != NULL ) { pci_free_consistent ( ioc -> pcidev , bufIn . len , ( void * ) bufIn . kptr , dma_addr_in ) ; } if ( mf ) mpt_free_msg_frame ( ioc , mf ) ; return rc ; }"," int mptctl_do_mpt_command ( MPT_ADAPTER * ioc ,  mfPtr ) {  MPT_FRAME_HDR * mf  0 ; int  flagsLength ; int  = 0 ;  spin_lock_irqsave ( &"
102,"CWE-200 static int copy_to_user_auth ( struct xfrm_algo_auth * auth , struct sk_buff * skb ) { struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data ( nla ) ;  strcpy ( algo -> alg_name , auth -> alg_name ) ;  memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ; algo -> alg_key_len = auth -> alg_key_len ; return 0 ; }"," nla ) ; strncpy  ( algo ->  auth -> alg_name , sizeof ( algo -> alg_name )"
103,"CWE-476 static GF_Err av1dmx_parse_flush_sample ( GF_Filter * filter , GF_AV1DmxCtx * ctx ) { u32 pck_size ; GF_FilterPacket * pck ;  u8 * output ;  gf_bs_get_content_no_truncate ( ctx -> state . bs , & ctx -> state . frame_obus , & pck_size , & ctx -> state . frame_obus_alloc ) ; if ( ! pck_size ) { GF_LOG ( GF_LOG_DEBUG , GF_LOG_CONTAINER , ( ""[AV1Dmx]noframeOBU,skippingOBU\\n"" ) ) ; return GF_OK ; } pck = gf_filter_pck_new_alloc ( ctx -> opid , pck_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , pck ) ; gf_filter_pck_set_cts ( pck , ctx -> cts ) ; gf_filter_pck_set_sap ( pck , ctx -> state . frame_state . key_frame ? GF_FILTER_SAP_1 : 0 ) ; memcpy ( output , ctx -> state . frame_obus , pck_size ) ; if ( ctx -> deps ) { u8 flags = 0 ; flags = ( ctx -> state . frame_state . key_frame ) ? 2 : 1 ; flags <<= 2 ; flags |= ctx -> state . frame_state . refresh_frame_flags ? 1 : 2 ; flags <<= 2 ; gf_filter_pck_set_dependency_flags ( pck , flags ) ; } gf_filter_pck_send ( pck ) ; av1dmx_update_cts ( ctx ) ; gf_av1_reset_state ( & ctx -> state , GF_FALSE ) ; return GF_OK ; }", u8 * output ; if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM
104,"CWE-000 static void hub_activate ( struct usb_hub * hub , enum hub_activation_type type ) { struct usb_device * hdev = hub -> hdev ; struct usb_hcd * hcd ; int ret ; int port1 ; int status ; bool need_debounce_delay = false ; unsigned delay ;  if ( type == HUB_INIT2 )  goto init2 ;  if ( type == HUB_INIT3 )  goto init3 ; if ( type != HUB_RESUME ) { if ( hdev -> parent && hub_is_superspeed ( hdev ) ) { ret = usb_control_msg ( hdev , usb_sndctrlpipe ( hdev , 0 ) , HUB_SET_DEPTH , USB_RT_HUB , hdev -> level - 1 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) dev_err ( hub -> intfdev , ""sethubdepthfailed\\n"" ) ; } if ( type == HUB_INIT ) { delay = hub_power_on_good_delay ( hub ) ; hub_power_on ( hub , false ) ; INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func2 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; usb_autopm_get_interface_no_resume ( to_usb_interface ( hub -> intfdev ) ) ; return ; } else if ( type == HUB_RESET_RESUME ) { hcd = bus_to_hcd ( hdev -> bus ) ; if ( hcd -> driver -> update_hub_device ) { ret = hcd -> driver -> update_hub_device ( hcd , hdev , & hub -> tt , GFP_NOIO ) ; if ( ret < 0 ) { dev_err ( hub -> intfdev , ""Hostnot"" ""acceptinghubinfo"" ""update.\\n"" ) ; dev_err ( hub -> intfdev , ""LS/FSdevices"" ""andhubsmaynotwork"" ""underthishub\\n."" ) ; } } hub_power_on ( hub , true ) ; } else { hub_power_on ( hub , true ) ; } } init2 : for ( port1 = 1 ; port1 <= hdev -> maxchild ; ++ port1 ) { struct usb_port * port_dev = hub -> ports [ port1 - 1 ] ; struct usb_device * udev = port_dev -> child ; u16 portstatus , portchange ; portstatus = portchange = 0 ; status = hub_port_status ( hub , port1 , & portstatus , & portchange ) ; if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) ) dev_dbg ( & port_dev -> dev , ""status%04xchange%04x\\n"" , portstatus , portchange ) ; if ( ( portstatus & USB_PORT_STAT_ENABLE ) && ( type != HUB_RESUME || ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ! udev || udev -> state == USB_STATE_NOTATTACHED ) ) { portstatus &= ~ USB_PORT_STAT_ENABLE ; if ( ! hub_is_superspeed ( hdev ) ) usb_clear_port_feature ( hdev , port1 , USB_PORT_FEAT_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_CONNECTION ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_CONNECTION ) ; } if ( portchange & USB_PORT_STAT_C_ENABLE ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_RESET ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_RESET ) ; } if ( ( portchange & USB_PORT_STAT_C_BH_RESET ) && hub_is_superspeed ( hub -> hdev ) ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_BH_PORT_RESET ) ; } if ( ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portchange & USB_PORT_STAT_C_CONNECTION ) ) clear_bit ( port1 , hub -> removed_bits ) ; if ( ! udev || udev -> state == USB_STATE_NOTATTACHED ) { if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portstatus & USB_PORT_STAT_OVERCURRENT ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( portstatus & USB_PORT_STAT_ENABLE ) { bool port_resumed = ( portstatus & USB_PORT_STAT_LINK_STATE ) == USB_SS_PORT_LS_U0 ; if ( portchange || ( hub_is_superspeed ( hub -> hdev ) && port_resumed ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( udev -> persist_enabled ) { # ifdef CONFIG_PM udev -> reset_resume = 1 ; # endif if ( test_bit ( port1 , hub -> power_bits ) ) set_bit ( port1 , hub -> change_bits ) ; } else { usb_set_device_state ( udev , USB_STATE_NOTATTACHED ) ; set_bit ( port1 , hub -> change_bits ) ; } } if ( need_debounce_delay ) { delay = HUB_DEBOUNCE_STABLE ; if ( type == HUB_INIT2 ) { INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func3 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ;  return ;  } else { msleep ( delay ) ; } } init3 : hub -> quiescing = 0 ; status = usb_submit_urb ( hub -> urb , GFP_NOIO ) ; if ( status < 0 ) dev_err ( hub -> intfdev , ""activate-->%d\\n"" , status ) ; if ( hub -> has_indicators && blinkenlights ) queue_delayed_work ( system_power_efficient_wq , & hub -> leds , LED_CYCLE_PERIOD ) ; kick_hub_wq ( hub ) ; if ( type <= HUB_INIT3 ) usb_autopm_put_interface_async ( to_usb_interface ( hub -> intfdev ) ) ;  } "," type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2  goto init2 ; goto init3 ; } kref_get ( & hub -> kref )  ; if (  ) ) ; device_unlock ( hub -> intfdev ) ;  ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;"
105,"CWE-20 void ftpServerProcessList ( FtpClientConnection * connection , char_t * param ) { error_t error ; uint_t perm ; if ( ! connection -> userLoggedIn ) { osStrcpy ( connection -> response , ""530Notloggedin\\r\\n"" ) ; return ; } while ( * param == '-' ) { while ( * param != '' && * param != '\\0' )  param ++ ;   while ( * param == '' )   param ++ ;  } if ( * param == '\\0' ) { osStrcpy ( connection -> path , connection -> currentDir ) ; } else { error = ftpServerGetPath ( connection , param , connection -> path , FTP_SERVER_MAX_PATH_LEN ) ; if ( error ) { osStrcpy ( connection -> response , ""501Invalidparameter\\r\\n"" ) ; return ; } } perm = ftpServerGetFilePermissions ( connection , connection -> path ) ; if ( ( perm & FTP_FILE_PERM_READ ) == 0 ) { osStrcpy ( connection -> response , ""550Accessdenied\\r\\n"" ) ; return ; } connection -> dir = fsOpenDir ( connection -> path ) ; if ( ! connection -> dir ) { osStrcpy ( connection -> response , ""550Directorynotfound\\r\\n"" ) ; return ; } if ( connection -> passiveMode ) { if ( connection -> dataChannel . state == FTP_CHANNEL_STATE_IDLE ) connection -> dataChannel . state = FTP_CHANNEL_STATE_SEND ; } else { error = ftpServerOpenDataChannel ( connection ) ; if ( error ) { fsCloseDir ( connection -> dir ) ; osStrcpy ( connection -> response , ""450Can\'topendataconnection\\r\\n"" ) ; return ; } connection -> dataChannel . state = FTP_CHANNEL_STATE_SEND ; } connection -> bufferLength = 0 ; connection -> bufferPos = 0 ; connection -> controlChannel . state = FTP_CHANNEL_STATE_LIST ; osStrcpy ( connection -> response , ""150Openingdataconnection\\r\\n"" ) ; }", != '\\0' ) {  param ++ ; }  == '' ) {  param ++ ; }
106,"CWE-787 __inline # if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__ __attribute__ ( ( __gnu_inline__ ) ) # endif # endif const struct ByUnfoldKey * unicode_unfold_key ( OnigCodePoint code ) { static const struct ByUnfoldKey wordlist [ ] = { { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x1040a , 3267 , 1 } , { 0x1e0a , 1727 , 1 } , { 0x040a , 1016 , 1 } , { 0x010a , 186 , 1 } , { 0x1f0a , 2088 , 1 } , { 0x2c0a , 2451 , 1 } , { 0x0189 , 619 , 1 } , { 0x1f89 , 134 , 2 } , { 0x1f85 , 154 , 2 } , { 0x0389 , 733 , 1 } , { 0x03ff , 724 , 1 } , { 0xab89 , 1523 , 1 } , { 0xab85 , 1511 , 1 } , { 0x10c89 , 3384 , 1 } , { 0x10c85 , 3372 , 1 } , { 0x1e84 , 1911 , 1 } , { 0x03f5 , 752 , 1 } , { 0x0184 , 360 , 1 } , { 0x1f84 , 149 , 2 } , { 0x2c84 , 2592 , 1 } , { 0x017d , 351 , 1 } , { 0x1ff3 , 96 , 2 } , { 0xab84 , 1508 , 1 } , { 0xa784 , 3105 , 1 } , { 0x10c84 , 3369 , 1 } , { 0xab7d , 1487 , 1 } , { 0xa77d , 1706 , 1 } , { 0x1e98 , 38 , 2 } , { 0x0498 , 1106 , 1 } , { 0x0198 , 375 , 1 } , { 0x1f98 , 169 , 2 } , { 0x2c98 , 2622 , 1 } , { 0x0398 , 762 , 1 } , { 0xa684 , 2940 , 1 } , { 0xab98 , 1568 , 1 } , { 0xa798 , 3123 , 1 } , { 0x10c98 , 3429 , 1 } , { 0x050a , 1277 , 1 } , { 0x1ffb , 2265 , 1 } , { 0x1e96 , 16 , 2 } , { 0x0496 , 1103 , 1 } , { 0x0196 , 652 , 1 } , { 0x1f96 , 199 , 2 } , { 0x2c96 , 2619 , 1 } , { 0x0396 , 756 , 1 } , { 0xa698 , 2970 , 1 } , { 0xab96 , 1562 , 1 } , { 0xa796 , 3120 , 1 } , { 0x10c96 , 3423 , 1 } , { 0x1feb , 2259 , 1 } , { 0x2ceb , 2736 , 1 } , { 0x1e90 , 1929 , 1 } , { 0x0490 , 1094 , 1 } , { 0x0190 , 628 , 1 } , { 0x1f90 , 169 , 2 } , { 0x2c90 , 2610 , 1 } , { 0x0390 , 25 , 3 } , { 0xa696 , 2967 , 1 } , { 0xab90 , 1544 , 1 } , { 0xa790 , 3114 , 1 } , { 0x10c90 , 3405 , 1 } , { 0x01d7 , 444 , 1 } , { 0x1fd7 , 31 , 3 } , { 0x1ea6 , 1947 , 1 } , { 0x04a6 , 1127 , 1 } , { 0x01a6 , 676 , 1 } , { 0x1fa6 , 239 , 2 } , { 0x2ca6 , 2643 , 1 } , { 0x03a6 , 810 , 1 } , { 0xa690 , 2958 , 1 } , { 0xaba6 , 1610 , 1 } , { 0xa7a6 , 3144 , 1 } , { 0x10ca6 , 3471 , 1 } , { 0x1ea4 , 1944 , 1 } , { 0x04a4 , 1124 , 1 } , { 0x01a4 , 390 , 1 } , { 0x1fa4 , 229 , 2 } , { 0x2ca4 , 2640 , 1 } , { 0x03a4 , 804 , 1 } , { 0x10a6 , 2763 , 1 } , { 0xaba4 , 1604 , 1 } , { 0xa7a4 , 3141 , 1 } , { 0x10ca4 , 3465 , 1 } , { 0x1ea0 , 1938 , 1 } , { 0x04a0 , 1118 , 1 } , { 0x01a0 , 384 , 1 } , { 0x1fa0 , 209 , 2 } , { 0x2ca0 , 2634 , 1 } , { 0x03a0 , 792 , 1 } , { 0x10a4 , 2757 , 1 } , { 0xaba0 , 1592 , 1 } , { 0xa7a0 , 3135 , 1 } , { 0x10ca0 , 3453 , 1 } , { 0x1eb2 , 1965 , 1 } , { 0x04b2 , 1145 , 1 } , { 0x01b2 , 694 , 1 } , { 0x1fb2 , 249 , 2 } , { 0x2cb2 , 2661 , 1 } , { 0x03fd , 718 , 1 } , { 0x10a0 , 2745 , 1 } , { 0xabb2 , 1646 , 1 } , { 0xa7b2 , 703 , 1 } , { 0x10cb2 , 3507 , 1 } , { 0x1eac , 1956 , 1 } , { 0x04ac , 1136 , 1 } , { 0x01ac , 396 , 1 } , { 0x1fac , 229 , 2 } , { 0x2cac , 2652 , 1 } , { 0x0537 , 1352 , 1 } , { 0x10b2 , 2799 , 1 } , { 0xabac , 1628 , 1 } , { 0xa7ac , 637 , 1 } , { 0x10cac , 3489 , 1 } , { 0x1eaa , 1953 , 1 } , { 0x04aa , 1133 , 1 } , { 0x00dd , 162 , 1 } , { 0x1faa , 219 , 2 } , { 0x2caa , 2649 , 1 } , { 0x03aa , 824 , 1 } , { 0x10ac , 2781 , 1 } , { 0xabaa , 1622 , 1 } , { 0xa7aa , 646 , 1 } , { 0x10caa , 3483 , 1 } , { 0x1ea8 , 1950 , 1 } , { 0x04a8 , 1130 , 1 } , { 0x020a , 517 , 1 } , { 0x1fa8 , 209 , 2 } , { 0x2ca8 , 2646 , 1 } , { 0x03a8 , 817 , 1 } , { 0x10aa , 2775 , 1 } , { 0xaba8 , 1616 , 1 } , { 0xa7a8 , 3147 , 1 } , { 0x10ca8 , 3477 , 1 } , { 0x1ea2 , 1941 , 1 } , { 0x04a2 , 1121 , 1 } , { 0x01a2 , 387 , 1 } , { 0x1fa2 , 219 , 2 } , { 0x2ca2 , 2637 , 1 } , { 0x118a6 , 3528 , 1 } , { 0x10a8 , 2769 , 1 } , { 0xaba2 , 1598 , 1 } , { 0xa7a2 , 3138 , 1 } , { 0x10ca2 , 3459 , 1 } , { 0x2ced , 2739 , 1 } , { 0x1fe9 , 2283 , 1 } , { 0x1fe7 , 47 , 3 } , { 0x1eb0 , 1962 , 1 } , { 0x04b0 , 1142 , 1 } , { 0x118a4 , 3522 , 1 } , { 0x10a2 , 2751 , 1 } , { 0x2cb0 , 2658 , 1 } , { 0x03b0 , 41 , 3 } , { 0x1fe3 , 41 , 3 } , { 0xabb0 , 1640 , 1 } , { 0xa7b0 , 706 , 1 } , { 0x10cb0 , 3501 , 1 } , { 0x01d9 , 447 , 1 } , { 0x1fd9 , 2277 , 1 } , { 0x118a0 , 3510 , 1 } , { 0x00df , 24 , 2 } , { 0x00d9 , 150 , 1 } , { 0xab77 , 1469 , 1 } , { 0x10b0 , 2793 , 1 } , { 0x1eae , 1959 , 1 } , { 0x04ae , 1139 , 1 } , { 0x01ae , 685 , 1 } , { 0x1fae , 239 , 2 } , { 0x2cae , 2655 , 1 } , { 0x118b2 , 3564 , 1 } , { 0xab73 , 1457 , 1 } , { 0xabae , 1634 , 1 } , { 0xab71 , 1451 , 1 } , { 0x10cae , 3495 , 1 } , { 0x1e2a , 1775 , 1 } , { 0x042a , 968 , 1 } , { 0x012a , 234 , 1 } , { 0x1f2a , 2130 , 1 } , { 0x2c2a , 2547 , 1 } , { 0x118ac , 3546 , 1 } , { 0x10ae , 2787 , 1 } , { 0x0535 , 1346 , 1 } , { 0xa72a , 2988 , 1 } , { 0x1e9a , 0 , 2 } , { 0x049a , 1109 , 1 } , { 0xff37 , 3225 , 1 } , { 0x1f9a , 179 , 2 } , { 0x2c9a , 2625 , 1 } , { 0x039a , 772 , 1 } , { 0x118aa , 3540 , 1 } , { 0xab9a , 1574 , 1 } , { 0xa79a , 3126 , 1 } , { 0x10c9a , 3435 , 1 } , { 0x1e94 , 1935 , 1 } , { 0x0494 , 1100 , 1 } , { 0x0194 , 640 , 1 } , { 0x1f94 , 189 , 2 } , { 0x2c94 , 2616 , 1 } , { 0x0394 , 749 , 1 } , { 0x118a8 , 3534 , 1 } , { 0xab94 , 1556 , 1 } , { 0xa69a , 2973 , 1 } , { 0x10c94 , 3417 , 1 } , { 0x10402 , 3243 , 1 } , { 0x1e02 , 1715 , 1 } , { 0x0402 , 992 , 1 } , { 0x0102 , 174 , 1 } , { 0x0533 , 1340 , 1 } , { 0x2c02 , 2427 , 1 } , { 0x118a2 , 3516 , 1 } , { 0x052a , 1325 , 1 } , { 0xa694 , 2964 , 1 } , { 0x1e92 , 1932 , 1 } , { 0x0492 , 1097 , 1 } , { 0x2165 , 2307 , 1 } , { 0x1f92 , 179 , 2 } , { 0x2c92 , 2613 , 1 } , { 0x0392 , 742 , 1 } , { 0x2161 , 2295 , 1 } , { 0xab92 , 1550 , 1 } , { 0xa792 , 3117 , 1 } , { 0x10c92 , 3411 , 1 } , { 0x118b0 , 3558 , 1 } , { 0x1f5f , 2199 , 1 } , { 0x1e8e , 1926 , 1 } , { 0x048e , 1091 , 1 } , { 0x018e , 453 , 1 } , { 0x1f8e , 159 , 2 } , { 0x2c8e , 2607 , 1 } , { 0x038e , 833 , 1 } , { 0xa692 , 2961 , 1 } , { 0xab8e , 1538 , 1 } , { 0x0055 , 59 , 1 } , { 0x10c8e , 3399 , 1 } , { 0x1f5d , 2196 , 1 } , { 0x212a , 27 , 1 } , { 0x04cb , 1181 , 1 } , { 0x01cb , 425 , 1 } , { 0x1fcb , 2241 , 1 } , { 0x118ae , 3552 , 1 } , { 0x0502 , 1265 , 1 } , { 0x00cb , 111 , 1 } , { 0xa68e , 2955 , 1 } , { 0x1e8a , 1920 , 1 } , { 0x048a , 1085 , 1 } , { 0x018a , 622 , 1 } , { 0x1f8a , 139 , 2 } , { 0x2c8a , 2601 , 1 } , { 0x038a , 736 , 1 } , { 0x2c67 , 2571 , 1 } , { 0xab8a , 1526 , 1 } , { 0x1e86 , 1914 , 1 } , { 0x10c8a , 3387 , 1 } , { 0x0186 , 616 , 1 } , { 0x1f86 , 159 , 2 } , { 0x2c86 , 2595 , 1 } , { 0x0386 , 727 , 1 } , { 0xff35 , 3219 , 1 } , { 0xab86 , 1514 , 1 } , { 0xa786 , 3108 , 1 } , { 0x10c86 , 3375 , 1 } , { 0xa68a , 2949 , 1 } , { 0x0555 , 1442 , 1 } , { 0x1ebc , 1980 , 1 } , { 0x04bc , 1160 , 1 } , { 0x01bc , 411 , 1 } , { 0x1fbc , 62 , 2 } , { 0x2cbc , 2676 , 1 } , { 0x1f5b , 2193 , 1 } , { 0xa686 , 2943 , 1 } , { 0xabbc , 1676 , 1 } , { 0x1eb8 , 1974 , 1 } , { 0x04b8 , 1154 , 1 } , { 0x01b8 , 408 , 1 } , { 0x1fb8 , 2268 , 1 } , { 0x2cb8 , 2670 , 1 } , { 0x01db , 450 , 1 } , { 0x1fdb , 2247 , 1 } , { 0xabb8 , 1664 , 1 } , { 0x10bc , 2829 , 1 } , { 0x00db , 156 , 1 } , { 0x1eb6 , 1971 , 1 } , { 0x04b6 , 1151 , 1 } , { 0xff33 , 3213 , 1 } , { 0x1fb6 , 58 , 2 } , { 0x2cb6 , 2667 , 1 } , { 0xff2a , 3186 , 1 } , { 0x10b8 , 2817 , 1 } , { 0xabb6 , 1658 , 1 } , { 0xa7b6 , 3153 , 1 } , { 0x10426 , 3351 , 1 } , { 0x1e26 , 1769 , 1 } , { 0x0426 , 956 , 1 } , { 0x0126 , 228 , 1 } , { 0x0053 , 52 , 1 } , { 0x2c26 , 2535 , 1 } , { 0x0057 , 65 , 1 } , { 0x10b6 , 2811 , 1 } , { 0x022a , 562 , 1 } , { 0xa726 , 2982 , 1 } , { 0x1e2e , 1781 , 1 } , { 0x042e , 980 , 1 } , { 0x012e , 240 , 1 } , { 0x1f2e , 2142 , 1 } , { 0x2c2e , 2559 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2167 , 2313 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa72e , 2994 , 1 } , { 0x1e2c , 1778 , 1 } , { 0x042c , 974 , 1 } , { 0x012c , 237 , 1 } , { 0x1f2c , 2136 , 1 } , { 0x2c2c , 2553 , 1 } , { 0x1f6f , 2223 , 1 } , { 0x2c6f , 604 , 1 } , { 0xabbf , 1685 , 1 } , { 0xa72c , 2991 , 1 } , { 0x1e28 , 1772 , 1 } , { 0x0428 , 962 , 1 } , { 0x0128 , 231 , 1 } , { 0x1f28 , 2124 , 1 } , { 0x2c28 , 2541 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0553 , 1436 , 1 } , { 0x10bf , 2838 , 1 } , { 0xa728 , 2985 , 1 } , { 0x0526 , 1319 , 1 } , { 0x0202 , 505 , 1 } , { 0x1e40 , 1808 , 1 } , { 0x10424 , 3345 , 1 } , { 0x1e24 , 1766 , 1 } , { 0x0424 , 950 , 1 } , { 0x0124 , 225 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c24 , 2529 , 1 } , { 0x052e , 1331 , 1 } , { 0xa740 , 3018 , 1 } , { 0x118bc , 3594 , 1 } , { 0xa724 , 2979 , 1 } , { 0x1ef2 , 2061 , 1 } , { 0x04f2 , 1241 , 1 } , { 0x01f2 , 483 , 1 } , { 0x1ff2 , 257 , 2 } , { 0x2cf2 , 2742 , 1 } , { 0x052c , 1328 , 1 } , { 0x118b8 , 3582 , 1 } , { 0xa640 , 2865 , 1 } , { 0x10422 , 3339 , 1 } , { 0x1e22 , 1763 , 1 } , { 0x0422 , 944 , 1 } , { 0x0122 , 222 , 1 } , { 0x2126 , 820 , 1 } , { 0x2c22 , 2523 , 1 } , { 0x0528 , 1322 , 1 } , { 0x01f1 , 483 , 1 } , { 0x118b6 , 3576 , 1 } , { 0xa722 , 2976 , 1 } , { 0x03f1 , 796 , 1 } , { 0x1ebe , 1983 , 1 } , { 0x04be , 1163 , 1 } , { 0xfb02 , 12 , 2 } , { 0x1fbe , 767 , 1 } , { 0x2cbe , 2679 , 1 } , { 0x01b5 , 405 , 1 } , { 0x0540 , 1379 , 1 } , { 0xabbe , 1682 , 1 } , { 0x0524 , 1316 , 1 } , { 0x00b5 , 779 , 1 } , { 0xabb5 , 1655 , 1 } , { 0x1eba , 1977 , 1 } , { 0x04ba , 1157 , 1 } , { 0x216f , 2337 , 1 } , { 0x1fba , 2226 , 1 } , { 0x2cba , 2673 , 1 } , { 0x10be , 2835 , 1 } , { 0x0051 , 46 , 1 } , { 0xabba , 1670 , 1 } , { 0x10b5 , 2808 , 1 } , { 0x1e6e , 1878 , 1 } , { 0x046e , 1055 , 1 } , { 0x016e , 330 , 1 } , { 0x1f6e , 2220 , 1 } , { 0x2c6e , 664 , 1 } , { 0x118bf , 3603 , 1 } , { 0x0522 , 1313 , 1 } , { 0x10ba , 2823 , 1 } , { 0xa76e , 3087 , 1 } , { 0x1eb4 , 1968 , 1 } , { 0x04b4 , 1148 , 1 } , { 0x2c75 , 2583 , 1 } , { 0x1fb4 , 50 , 2 } , { 0x2cb4 , 2664 , 1 } , { 0xab75 , 1463 , 1 } , { 0x1ec2 , 1989 , 1 } , { 0xabb4 , 1652 , 1 } , { 0xa7b4 , 3150 , 1 } , { 0x1fc2 , 253 , 2 } , { 0x2cc2 , 2685 , 1 } , { 0x03c2 , 800 , 1 } , { 0x00c2 , 83 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff26 , 3174 , 1 } , { 0x10b4 , 2805 , 1 } , { 0x1eca , 2001 , 1 } , { 0x0551 , 1430 , 1 } , { 0x01ca , 425 , 1 } , { 0x1fca , 2238 , 1 } , { 0x2cca , 2697 , 1 } , { 0x10c2 , 2847 , 1 } , { 0x00ca , 108 , 1 } , { 0xff2e , 3198 , 1 } , { 0x1e8c , 1923 , 1 } , { 0x048c , 1088 , 1 } , { 0x0226 , 556 , 1 } , { 0x1f8c , 149 , 2 } , { 0x2c8c , 2604 , 1 } , { 0x038c , 830 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8c , 1532 , 1 } , { 0xff2c , 3192 , 1 } , { 0x10c8c , 3393 , 1 } , { 0x1ec4 , 1992 , 1 } , { 0x022e , 568 , 1 } , { 0x01c4 , 417 , 1 } , { 0x1fc4 , 54 , 2 } , { 0x2cc4 , 2688 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00c4 , 89 , 1 } , { 0xff28 , 3180 , 1 } , { 0xa68c , 2952 , 1 } , { 0x01cf , 432 , 1 } , { 0x022c , 565 , 1 } , { 0x118be , 3600 , 1 } , { 0x03cf , 839 , 1 } , { 0x00cf , 123 , 1 } , { 0x118b5 , 3573 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c4 , 2853 , 1 } , { 0x216e , 2334 , 1 } , { 0x24cb , 2406 , 1 } , { 0x0228 , 559 , 1 } , { 0xff24 , 3168 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x118ba , 3588 , 1 } , { 0x1efe , 2079 , 1 } , { 0x04fe , 1259 , 1 } , { 0x01fe , 499 , 1 } , { 0x1e9e , 24 , 2 } , { 0x049e , 1115 , 1 } , { 0x03fe , 721 , 1 } , { 0x1f9e , 199 , 2 } , { 0x2c9e , 2631 , 1 } , { 0x039e , 786 , 1 } , { 0x0224 , 553 , 1 } , { 0xab9e , 1586 , 1 } , { 0xa79e , 3132 , 1 } , { 0x10c9e , 3447 , 1 } , { 0x01f7 , 414 , 1 } , { 0x1ff7 , 67 , 3 } , { 0xff22 , 3162 , 1 } , { 0x03f7 , 884 , 1 } , { 0x118b4 , 3570 , 1 } , { 0x049c , 1112 , 1 } , { 0x019c , 661 , 1 } , { 0x1f9c , 189 , 2 } , { 0x2c9c , 2628 , 1 } , { 0x039c , 779 , 1 } , { 0x24bc , 2361 , 1 } , { 0xab9c , 1580 , 1 } , { 0xa79c , 3129 , 1 } , { 0x10c9c , 3441 , 1 } , { 0x0222 , 550 , 1 } , { 0x1e7c , 1899 , 1 } , { 0x047c , 1076 , 1 } , { 0x1e82 , 1908 , 1 } , { 0x24b8 , 2349 , 1 } , { 0x0182 , 357 , 1 } , { 0x1f82 , 139 , 2 } , { 0x2c82 , 2589 , 1 } , { 0xab7c , 1484 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab82 , 1502 , 1 } , { 0xa782 , 3102 , 1 } , { 0x10c82 , 3363 , 1 } , { 0x2c63 , 1709 , 1 } , { 0x24b6 , 2343 , 1 } , { 0x1e80 , 1905 , 1 } , { 0x0480 , 1082 , 1 } , { 0x1f59 , 2190 , 1 } , { 0x1f80 , 129 , 2 } , { 0x2c80 , 2586 , 1 } , { 0x0059 , 71 , 1 } , { 0xa682 , 2937 , 1 } , { 0xab80 , 1496 , 1 } , { 0xa780 , 3099 , 1 } , { 0x10c80 , 3357 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1e4c , 1826 , 1 } , { 0x0145 , 270 , 1 } , { 0x014c , 279 , 1 } , { 0x1f4c , 2184 , 1 } , { 0x0345 , 767 , 1 } , { 0x0045 , 12 , 1 } , { 0x004c , 31 , 1 } , { 0xa680 , 2934 , 1 } , { 0xa74c , 3036 , 1 } , { 0x1e4a , 1823 , 1 } , { 0x01d5 , 441 , 1 } , { 0x014a , 276 , 1 } , { 0x1f4a , 2178 , 1 } , { 0x03d5 , 810 , 1 } , { 0x00d5 , 141 , 1 } , { 0x004a , 24 , 1 } , { 0x24bf , 2370 , 1 } , { 0xa74a , 3033 , 1 } , { 0xa64c , 2883 , 1 } , { 0x1041c , 3321 , 1 } , { 0x1e1c , 1754 , 1 } , { 0x041c , 926 , 1 } , { 0x011c , 213 , 1 } , { 0x1f1c , 2118 , 1 } , { 0x2c1c , 2505 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xa64a , 2880 , 1 } , { 0x1041a , 3315 , 1 } , { 0x1e1a , 1751 , 1 } , { 0x041a , 920 , 1 } , { 0x011a , 210 , 1 } , { 0x1f1a , 2112 , 1 } , { 0x2c1a , 2499 , 1 } , { 0xabbd , 1679 , 1 } , { 0x0545 , 1394 , 1 } , { 0x054c , 1415 , 1 } , { 0x10418 , 3309 , 1 } , { 0x1e18 , 1748 , 1 } , { 0x0418 , 914 , 1 } , { 0x0118 , 207 , 1 } , { 0x1f18 , 2106 , 1 } , { 0x2c18 , 2493 , 1 } , { 0x10bd , 2832 , 1 } , { 0x2163 , 2301 , 1 } , { 0x054a , 1409 , 1 } , { 0x1040e , 3279 , 1 } , { 0x1e0e , 1733 , 1 } , { 0x040e , 1028 , 1 } , { 0x010e , 192 , 1 } , { 0x1f0e , 2100 , 1 } , { 0x2c0e , 2463 , 1 } , { 0x1efc , 2076 , 1 } , { 0x04fc , 1256 , 1 } , { 0x01fc , 496 , 1 } , { 0x1ffc , 96 , 2 } , { 0x051c , 1304 , 1 } , { 0x1040c , 3273 , 1 } , { 0x1e0c , 1730 , 1 } , { 0x040c , 1022 , 1 } , { 0x010c , 189 , 1 } , { 0x1f0c , 2094 , 1 } , { 0x2c0c , 2457 , 1 } , { 0x1f6d , 2217 , 1 } , { 0x2c6d , 607 , 1 } , { 0x051a , 1301 , 1 } , { 0x24be , 2367 , 1 } , { 0x10408 , 3261 , 1 } , { 0x1e08 , 1724 , 1 } , { 0x0408 , 1010 , 1 } , { 0x0108 , 183 , 1 } , { 0x1f08 , 2082 , 1 } , { 0x2c08 , 2445 , 1 } , { 0x04c9 , 1178 , 1 } , { 0x0518 , 1298 , 1 } , { 0x1fc9 , 2235 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24ba , 2355 , 1 } , { 0x00c9 , 105 , 1 } , { 0x10416 , 3303 , 1 } , { 0x1e16 , 1745 , 1 } , { 0x0416 , 908 , 1 } , { 0x0116 , 204 , 1 } , { 0x050e , 1283 , 1 } , { 0x2c16 , 2487 , 1 } , { 0x10414 , 3297 , 1 } , { 0x1e14 , 1742 , 1 } , { 0x0414 , 902 , 1 } , { 0x0114 , 201 , 1 } , { 0x042b , 971 , 1 } , { 0x2c14 , 2481 , 1 } , { 0x1f2b , 2133 , 1 } , { 0x2c2b , 2550 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x050c , 1280 , 1 } , { 0x10406 , 3255 , 1 } , { 0x1e06 , 1721 , 1 } , { 0x0406 , 1004 , 1 } , { 0x0106 , 180 , 1 } , { 0x13fb , 1697 , 1 } , { 0x2c06 , 2439 , 1 } , { 0x24c2 , 2379 , 1 } , { 0x118bd , 3597 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0508 , 1274 , 1 } , { 0x10404 , 3249 , 1 } , { 0x1e04 , 1718 , 1 } , { 0x0404 , 998 , 1 } , { 0x0104 , 177 , 1 } , { 0x1f95 , 194 , 2 } , { 0x2c04 , 2433 , 1 } , { 0x0395 , 752 , 1 } , { 0x24ca , 2403 , 1 } , { 0xab95 , 1559 , 1 } , { 0x0531 , 1334 , 1 } , { 0x10c95 , 3420 , 1 } , { 0x0516 , 1295 , 1 } , { 0x1e6c , 1875 , 1 } , { 0x046c , 1052 , 1 } , { 0x016c , 327 , 1 } , { 0x1f6c , 2214 , 1 } , { 0x216d , 2331 , 1 } , { 0x0514 , 1292 , 1 } , { 0x0245 , 697 , 1 } , { 0x024c , 598 , 1 } , { 0xa76c , 3084 , 1 } , { 0x10400 , 3237 , 1 } , { 0x1e00 , 1712 , 1 } , { 0x0400 , 986 , 1 } , { 0x0100 , 171 , 1 } , { 0x24c4 , 2385 , 1 } , { 0x2c00 , 2421 , 1 } , { 0x0506 , 1271 , 1 } , { 0x024a , 595 , 1 } , { 0x1fab , 224 , 2 } , { 0xa66c , 2931 , 1 } , { 0x03ab , 827 , 1 } , { 0x24cf , 2418 , 1 } , { 0xabab , 1625 , 1 } , { 0xa7ab , 631 , 1 } , { 0x10cab , 3486 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0504 , 1268 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x021c , 544 , 1 } , { 0x01a9 , 679 , 1 } , { 0x1fa9 , 214 , 2 } , { 0x10ab , 2778 , 1 } , { 0x03a9 , 820 , 1 } , { 0x212b , 92 , 1 } , { 0xaba9 , 1619 , 1 } , { 0x1e88 , 1917 , 1 } , { 0x10ca9 , 3480 , 1 } , { 0x021a , 541 , 1 } , { 0x1f88 , 129 , 2 } , { 0x2c88 , 2598 , 1 } , { 0x0388 , 730 , 1 } , { 0x13fd , 1703 , 1 } , { 0xab88 , 1520 , 1 } , { 0x10a9 , 2772 , 1 } , { 0x10c88 , 3381 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0218 , 538 , 1 } , { 0x0500 , 1262 , 1 } , { 0x1f4d , 2187 , 1 } , { 0x01a7 , 393 , 1 } , { 0x1fa7 , 244 , 2 } , { 0x004d , 34 , 1 } , { 0x03a7 , 814 , 1 } , { 0xa688 , 2946 , 1 } , { 0xaba7 , 1613 , 1 } , { 0x020e , 523 , 1 } , { 0x10ca7 , 3474 , 1 } , { 0x1e6a , 1872 , 1 } , { 0x046a , 1049 , 1 } , { 0x016a , 324 , 1 } , { 0x1f6a , 2208 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x216c , 2328 , 1 } , { 0x10a7 , 2766 , 1 } , { 0x01d1 , 435 , 1 } , { 0xa76a , 3081 , 1 } , { 0x020c , 520 , 1 } , { 0x03d1 , 762 , 1 } , { 0x00d1 , 129 , 1 } , { 0x1e68 , 1869 , 1 } , { 0x0468 , 1046 , 1 } , { 0x0168 , 321 , 1 } , { 0x1f68 , 2202 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff31 , 3207 , 1 } , { 0xa66a , 2928 , 1 } , { 0x0208 , 514 , 1 } , { 0xa768 , 3078 , 1 } , { 0x1e64 , 1863 , 1 } , { 0x0464 , 1040 , 1 } , { 0x0164 , 315 , 1 } , { 0x054d , 1418 , 1 } , { 0x2c64 , 673 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff2b , 3189 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa764 , 3072 , 1 } , { 0xa668 , 2925 , 1 } , { 0x0216 , 535 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x118ab , 3543 , 1 } , { 0x1e62 , 1860 , 1 } , { 0x0462 , 1037 , 1 } , { 0x0162 , 312 , 1 } , { 0x0214 , 532 , 1 } , { 0x2c62 , 655 , 1 } , { 0xa664 , 2919 , 1 } , { 0x1ed2 , 2013 , 1 } , { 0x04d2 , 1193 , 1 } , { 0xa762 , 3069 , 1 } , { 0x1fd2 , 20 , 3 } , { 0x2cd2 , 2709 , 1 } , { 0x118a9 , 3537 , 1 } , { 0x00d2 , 132 , 1 } , { 0x0206 , 511 , 1 } , { 0x10420 , 3333 , 1 } , { 0x1e20 , 1760 , 1 } , { 0x0420 , 938 , 1 } , { 0x0120 , 219 , 1 } , { 0xa662 , 2916 , 1 } , { 0x2c20 , 2517 , 1 } , { 0x1e60 , 1856 , 1 } , { 0x0460 , 1034 , 1 } , { 0x0160 , 309 , 1 } , { 0x0204 , 508 , 1 } , { 0x2c60 , 2562 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24bd , 2364 , 1 } , { 0x216a , 2322 , 1 } , { 0xa760 , 3066 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xfb16 , 125 , 2 } , { 0x118a7 , 3531 , 1 } , { 0x1efa , 2073 , 1 } , { 0x04fa , 1253 , 1 } , { 0x01fa , 493 , 1 } , { 0x1ffa , 2262 , 1 } , { 0xfb14 , 109 , 2 } , { 0x03fa , 887 , 1 } , { 0xa660 , 2913 , 1 } , { 0x2168 , 2316 , 1 } , { 0x01b7 , 700 , 1 } , { 0x1fb7 , 10 , 3 } , { 0x1f6b , 2211 , 1 } , { 0x2c6b , 2577 , 1 } , { 0x0200 , 502 , 1 } , { 0xabb7 , 1661 , 1 } , { 0xfb06 , 29 , 2 } , { 0x1e56 , 1841 , 1 } , { 0x2164 , 2304 , 1 } , { 0x0156 , 294 , 1 } , { 0x1f56 , 62 , 3 } , { 0x0520 , 1310 , 1 } , { 0x004f , 40 , 1 } , { 0x0056 , 62 , 1 } , { 0x10b7 , 2814 , 1 } , { 0xa756 , 3051 , 1 } , { 0xfb04 , 5 , 3 } , { 0x1e78 , 1893 , 1 } , { 0x0478 , 1070 , 1 } , { 0x0178 , 168 , 1 } , { 0x1e54 , 1838 , 1 } , { 0x2162 , 2298 , 1 } , { 0x0154 , 291 , 1 } , { 0x1f54 , 57 , 3 } , { 0xab78 , 1472 , 1 } , { 0xa656 , 2898 , 1 } , { 0x0054 , 56 , 1 } , { 0x1e52 , 1835 , 1 } , { 0xa754 , 3048 , 1 } , { 0x0152 , 288 , 1 } , { 0x1f52 , 52 , 3 } , { 0x24c9 , 2400 , 1 } , { 0x1e32 , 1787 , 1 } , { 0x0052 , 49 , 1 } , { 0x0132 , 243 , 1 } , { 0xa752 , 3045 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xfb00 , 4 , 2 } , { 0xa654 , 2895 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa732 , 2997 , 1 } , { 0x2160 , 2292 , 1 } , { 0x054f , 1424 , 1 } , { 0x0556 , 1445 , 1 } , { 0x1e50 , 1832 , 1 } , { 0xa652 , 2892 , 1 } , { 0x0150 , 285 , 1 } , { 0x1f50 , 84 , 2 } , { 0x017b , 348 , 1 } , { 0x1e4e , 1829 , 1 } , { 0x0050 , 43 , 1 } , { 0x014e , 282 , 1 } , { 0xa750 , 3042 , 1 } , { 0xab7b , 1481 , 1 } , { 0xa77b , 3093 , 1 } , { 0x004e , 37 , 1 } , { 0x0554 , 1439 , 1 } , { 0xa74e , 3039 , 1 } , { 0x1e48 , 1820 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x216b , 2325 , 1 } , { 0x1f48 , 2172 , 1 } , { 0xa650 , 2889 , 1 } , { 0x0552 , 1433 , 1 } , { 0x0048 , 21 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa748 , 3030 , 1 } , { 0xa64e , 2886 , 1 } , { 0x0532 , 1337 , 1 } , { 0x1041e , 3327 , 1 } , { 0x1e1e , 1757 , 1 } , { 0x041e , 932 , 1 } , { 0x011e , 216 , 1 } , { 0x118b7 , 3579 , 1 } , { 0x2c1e , 2511 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa648 , 2877 , 1 } , { 0x1ff9 , 2253 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x03f9 , 878 , 1 } , { 0x0550 , 1427 , 1 } , { 0x10412 , 3291 , 1 } , { 0x1e12 , 1739 , 1 } , { 0x0412 , 896 , 1 } , { 0x0112 , 198 , 1 } , { 0x054e , 1421 , 1 } , { 0x2c12 , 2475 , 1 } , { 0x10410 , 3285 , 1 } , { 0x1e10 , 1736 , 1 } , { 0x0410 , 890 , 1 } , { 0x0110 , 195 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c10 , 2469 , 1 } , { 0x2132 , 2289 , 1 } , { 0x0548 , 1403 , 1 } , { 0x1ef8 , 2070 , 1 } , { 0x04f8 , 1250 , 1 } , { 0x01f8 , 490 , 1 } , { 0x1ff8 , 2250 , 1 } , { 0x0220 , 381 , 1 } , { 0x1ee2 , 2037 , 1 } , { 0x04e2 , 1217 , 1 } , { 0x01e2 , 462 , 1 } , { 0x1fe2 , 36 , 3 } , { 0x2ce2 , 2733 , 1 } , { 0x03e2 , 857 , 1 } , { 0x051e , 1307 , 1 } , { 0x1ede , 2031 , 1 } , { 0x04de , 1211 , 1 } , { 0x01de , 456 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cde , 2727 , 1 } , { 0x03de , 851 , 1 } , { 0x00de , 165 , 1 } , { 0x1f69 , 2205 , 1 } , { 0x2c69 , 2574 , 1 } , { 0x1eda , 2025 , 1 } , { 0x04da , 1205 , 1 } , { 0x0512 , 1289 , 1 } , { 0x1fda , 2244 , 1 } , { 0x2cda , 2721 , 1 } , { 0x03da , 845 , 1 } , { 0x00da , 153 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0510 , 1286 , 1 } , { 0x1ed8 , 2022 , 1 } , { 0x04d8 , 1202 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fd8 , 2274 , 1 } , { 0x2cd8 , 2718 , 1 } , { 0x03d8 , 842 , 1 } , { 0x00d8 , 147 , 1 } , { 0x1ed6 , 2019 , 1 } , { 0x04d6 , 1199 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fd6 , 76 , 2 } , { 0x2cd6 , 2715 , 1 } , { 0x03d6 , 792 , 1 } , { 0x00d6 , 144 , 1 } , { 0x1ec8 , 1998 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x01c8 , 421 , 1 } , { 0x1fc8 , 2232 , 1 } , { 0x2cc8 , 2694 , 1 } , { 0xff32 , 3210 , 1 } , { 0x00c8 , 102 , 1 } , { 0x04c7 , 1175 , 1 } , { 0x01c7 , 421 , 1 } , { 0x1fc7 , 15 , 3 } , { 0x1ec0 , 1986 , 1 } , { 0x04c0 , 1187 , 1 } , { 0x00c7 , 99 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cc0 , 2682 , 1 } , { 0x0179 , 345 , 1 } , { 0x00c0 , 77 , 1 } , { 0x0232 , 574 , 1 } , { 0x01b3 , 402 , 1 } , { 0x1fb3 , 62 , 2 } , { 0xab79 , 1475 , 1 } , { 0xa779 , 3090 , 1 } , { 0x10c7 , 2859 , 1 } , { 0xabb3 , 1649 , 1 } , { 0xa7b3 , 3156 , 1 } , { 0x1fa5 , 234 , 2 } , { 0x10c0 , 2841 , 1 } , { 0x03a5 , 807 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xaba5 , 1607 , 1 } , { 0x01b1 , 691 , 1 } , { 0x10ca5 , 3468 , 1 } , { 0x10b3 , 2802 , 1 } , { 0x2169 , 2319 , 1 } , { 0x024e , 601 , 1 } , { 0xabb1 , 1643 , 1 } , { 0xa7b1 , 682 , 1 } , { 0x10cb1 , 3504 , 1 } , { 0x10a5 , 2760 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x01af , 399 , 1 } , { 0x1faf , 244 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0248 , 592 , 1 } , { 0x10b1 , 2796 , 1 } , { 0xabaf , 1637 , 1 } , { 0x1fad , 234 , 2 } , { 0x10caf , 3498 , 1 } , { 0x04cd , 1184 , 1 } , { 0x01cd , 429 , 1 } , { 0xabad , 1631 , 1 } , { 0xa7ad , 658 , 1 } , { 0x10cad , 3492 , 1 } , { 0x00cd , 117 , 1 } , { 0x10af , 2790 , 1 } , { 0x021e , 547 , 1 } , { 0x1fa3 , 224 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x03a3 , 800 , 1 } , { 0x10ad , 2784 , 1 } , { 0xaba3 , 1601 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10ca3 , 3462 , 1 } , { 0x10cd , 2862 , 1 } , { 0x1fa1 , 214 , 2 } , { 0x24b7 , 2346 , 1 } , { 0x03a1 , 796 , 1 } , { 0x0212 , 529 , 1 } , { 0xaba1 , 1595 , 1 } , { 0x10a3 , 2754 , 1 } , { 0x10ca1 , 3456 , 1 } , { 0x01d3 , 438 , 1 } , { 0x1fd3 , 25 , 3 } , { 0x0210 , 526 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00d3 , 135 , 1 } , { 0x1e97 , 34 , 2 } , { 0x10a1 , 2748 , 1 } , { 0x0197 , 649 , 1 } , { 0x1f97 , 204 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0397 , 759 , 1 } , { 0x1041d , 3324 , 1 } , { 0xab97 , 1565 , 1 } , { 0x041d , 929 , 1 } , { 0x10c97 , 3426 , 1 } , { 0x1f1d , 2121 , 1 } , { 0x2c1d , 2508 , 1 } , { 0x1e72 , 1884 , 1 } , { 0x0472 , 1061 , 1 } , { 0x0172 , 336 , 1 } , { 0x118b3 , 3567 , 1 } , { 0x2c72 , 2580 , 1 } , { 0x0372 , 712 , 1 } , { 0x1041b , 3318 , 1 } , { 0xab72 , 1454 , 1 } , { 0x041b , 923 , 1 } , { 0x118a5 , 3525 , 1 } , { 0x1f1b , 2115 , 1 } , { 0x2c1b , 2502 , 1 } , { 0x1e70 , 1881 , 1 } , { 0x0470 , 1058 , 1 } , { 0x0170 , 333 , 1 } , { 0x118b1 , 3561 , 1 } , { 0x2c70 , 610 , 1 } , { 0x0370 , 709 , 1 } , { 0x1e46 , 1817 , 1 } , { 0xab70 , 1448 , 1 } , { 0x1e66 , 1866 , 1 } , { 0x0466 , 1043 , 1 } , { 0x0166 , 318 , 1 } , { 0x1e44 , 1814 , 1 } , { 0x0046 , 15 , 1 } , { 0x118af , 3555 , 1 } , { 0xa746 , 3027 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa766 , 3075 , 1 } , { 0x0044 , 9 , 1 } , { 0x118ad , 3549 , 1 } , { 0xa744 , 3024 , 1 } , { 0x1e7a , 1896 , 1 } , { 0x047a , 1073 , 1 } , { 0x1e3a , 1799 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa646 , 2874 , 1 } , { 0x1f3a , 2154 , 1 } , { 0xa666 , 2922 , 1 } , { 0xab7a , 1478 , 1 } , { 0x118a3 , 3519 , 1 } , { 0xa644 , 2871 , 1 } , { 0xa73a , 3009 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1ef4 , 2064 , 1 } , { 0x04f4 , 1244 , 1 } , { 0x01f4 , 487 , 1 } , { 0x1ff4 , 101 , 2 } , { 0x118a1 , 3513 , 1 } , { 0x03f4 , 762 , 1 } , { 0x1eec , 2052 , 1 } , { 0x04ec , 1232 , 1 } , { 0x01ec , 477 , 1 } , { 0x1fec , 2286 , 1 } , { 0x0546 , 1397 , 1 } , { 0x03ec , 872 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x013f , 261 , 1 } , { 0x1f3f , 2169 , 1 } , { 0x0544 , 1391 , 1 } , { 0x1eea , 2049 , 1 } , { 0x04ea , 1229 , 1 } , { 0x01ea , 474 , 1 } , { 0x1fea , 2256 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x03ea , 869 , 1 } , { 0x1ee8 , 2046 , 1 } , { 0x04e8 , 1226 , 1 } , { 0x01e8 , 471 , 1 } , { 0x1fe8 , 2280 , 1 } , { 0x053a , 1361 , 1 } , { 0x03e8 , 866 , 1 } , { 0x1ee6 , 2043 , 1 } , { 0x04e6 , 1223 , 1 } , { 0x01e6 , 468 , 1 } , { 0x1fe6 , 88 , 2 } , { 0x1f4b , 2181 , 1 } , { 0x03e6 , 863 , 1 } , { 0x1e5e , 1853 , 1 } , { 0x004b , 27 , 1 } , { 0x015e , 306 , 1 } , { 0x2166 , 2310 , 1 } , { 0x1ee4 , 2040 , 1 } , { 0x04e4 , 1220 , 1 } , { 0x01e4 , 465 , 1 } , { 0x1fe4 , 80 , 2 } , { 0xa75e , 3063 , 1 } , { 0x03e4 , 860 , 1 } , { 0x1ee0 , 2034 , 1 } , { 0x04e0 , 1214 , 1 } , { 0x01e0 , 459 , 1 } , { 0x053f , 1376 , 1 } , { 0x2ce0 , 2730 , 1 } , { 0x03e0 , 854 , 1 } , { 0x1edc , 2028 , 1 } , { 0x04dc , 1208 , 1 } , { 0xa65e , 2910 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cdc , 2724 , 1 } , { 0x03dc , 848 , 1 } , { 0x00dc , 159 , 1 } , { 0x1ed0 , 2010 , 1 } , { 0x04d0 , 1190 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x2cd0 , 2706 , 1 } , { 0x03d0 , 742 , 1 } , { 0x00d0 , 126 , 1 } , { 0x1ecc , 2004 , 1 } , { 0x054b , 1412 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fcc , 71 , 2 } , { 0x2ccc , 2700 , 1 } , { 0x1ec6 , 1995 , 1 } , { 0x00cc , 114 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fc6 , 67 , 2 } , { 0x2cc6 , 2691 , 1 } , { 0x24c8 , 2397 , 1 } , { 0x00c6 , 96 , 1 } , { 0x04c5 , 1172 , 1 } , { 0x01c5 , 417 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fbb , 2229 , 1 } , { 0x24c7 , 2394 , 1 } , { 0x00c5 , 92 , 1 } , { 0x1fb9 , 2271 , 1 } , { 0xabbb , 1673 , 1 } , { 0x24c0 , 2373 , 1 } , { 0x04c3 , 1169 , 1 } , { 0xabb9 , 1667 , 1 } , { 0x1fc3 , 71 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x00c3 , 86 , 1 } , { 0x10c5 , 2856 , 1 } , { 0x10bb , 2826 , 1 } , { 0x1ed4 , 2016 , 1 } , { 0x04d4 , 1196 , 1 } , { 0x10b9 , 2820 , 1 } , { 0x13fc , 1700 , 1 } , { 0x2cd4 , 2712 , 1 } , { 0x0246 , 589 , 1 } , { 0x00d4 , 138 , 1 } , { 0x10c3 , 2850 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff3a , 3234 , 1 } , { 0x0244 , 688 , 1 } , { 0x019f , 670 , 1 } , { 0x1f9f , 204 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x039f , 789 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab9f , 1589 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c9f , 3450 , 1 } , { 0x019d , 667 , 1 } , { 0x1f9d , 194 , 2 } , { 0x023a , 2565 , 1 } , { 0x039d , 783 , 1 } , { 0x1e5a , 1847 , 1 } , { 0xab9d , 1583 , 1 } , { 0x015a , 300 , 1 } , { 0x10c9d , 3444 , 1 } , { 0x1e9b , 1856 , 1 } , { 0x24cd , 2412 , 1 } , { 0x005a , 74 , 1 } , { 0x1f9b , 184 , 2 } , { 0xa75a , 3057 , 1 } , { 0x039b , 776 , 1 } , { 0x1ece , 2007 , 1 } , { 0xab9b , 1577 , 1 } , { 0x1e99 , 42 , 2 } , { 0x10c9b , 3438 , 1 } , { 0x2cce , 2703 , 1 } , { 0x1f99 , 174 , 2 } , { 0x00ce , 120 , 1 } , { 0x0399 , 767 , 1 } , { 0xa65a , 2904 , 1 } , { 0xab99 , 1571 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c99 , 3432 , 1 } , { 0x0193 , 634 , 1 } , { 0x1f93 , 184 , 2 } , { 0x1e58 , 1844 , 1 } , { 0x0393 , 746 , 1 } , { 0x0158 , 297 , 1 } , { 0xab93 , 1553 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c93 , 3414 , 1 } , { 0x0058 , 68 , 1 } , { 0x042d , 977 , 1 } , { 0xa758 , 3054 , 1 } , { 0x1f2d , 2139 , 1 } , { 0x2c2d , 2556 , 1 } , { 0x118bb , 3591 , 1 } , { 0x0191 , 369 , 1 } , { 0x1f91 , 174 , 2 } , { 0x118b9 , 3585 , 1 } , { 0x0391 , 739 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab91 , 1547 , 1 } , { 0xa658 , 2901 , 1 } , { 0x10c91 , 3408 , 1 } , { 0x018f , 625 , 1 } , { 0x1f8f , 164 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x038f , 836 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8f , 1541 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c8f , 3402 , 1 } , { 0x018b , 366 , 1 } , { 0x1f8b , 144 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0187 , 363 , 1 } , { 0x1f87 , 164 , 2 } , { 0xab8b , 1529 , 1 } , { 0xa78b , 3111 , 1 } , { 0x10c8b , 3390 , 1 } , { 0xab87 , 1517 , 1 } , { 0x04c1 , 1166 , 1 } , { 0x10c87 , 3378 , 1 } , { 0x1e7e , 1902 , 1 } , { 0x047e , 1079 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00c1 , 80 , 1 } , { 0x2c7e , 580 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xab7e , 1490 , 1 } , { 0xa77e , 3096 , 1 } , { 0x1e76 , 1890 , 1 } , { 0x0476 , 1067 , 1 } , { 0x0176 , 342 , 1 } , { 0x1e42 , 1811 , 1 } , { 0x10c1 , 2844 , 1 } , { 0x0376 , 715 , 1 } , { 0x1e36 , 1793 , 1 } , { 0xab76 , 1466 , 1 } , { 0x0136 , 249 , 1 } , { 0x0042 , 3 , 1 } , { 0x1e3e , 1805 , 1 } , { 0xa742 , 3021 , 1 } , { 0x1e38 , 1796 , 1 } , { 0x1f3e , 2166 , 1 } , { 0xa736 , 3003 , 1 } , { 0x1f38 , 2148 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0587 , 105 , 2 } , { 0xa73e , 3015 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa738 , 3006 , 1 } , { 0xa642 , 2868 , 1 } , { 0x1e5c , 1850 , 1 } , { 0x1e34 , 1790 , 1 } , { 0x015c , 303 , 1 } , { 0x0134 , 246 , 1 } , { 0x1ef6 , 2067 , 1 } , { 0x04f6 , 1247 , 1 } , { 0x01f6 , 372 , 1 } , { 0x1ff6 , 92 , 2 } , { 0xa75c , 3060 , 1 } , { 0xa734 , 3000 , 1 } , { 0x1ef0 , 2058 , 1 } , { 0x04f0 , 1238 , 1 } , { 0x01f0 , 20 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x1e30 , 1784 , 1 } , { 0x03f0 , 772 , 1 } , { 0x0130 , 261 , 2 } , { 0x0542 , 1385 , 1 } , { 0xa65c , 2907 , 1 } , { 0x1f83 , 144 , 2 } , { 0x0536 , 1349 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xab83 , 1505 , 1 } , { 0x053e , 1373 , 1 } , { 0x10c83 , 3366 , 1 } , { 0x0538 , 1355 , 1 } , { 0x1eee , 2055 , 1 } , { 0x04ee , 1235 , 1 } , { 0x01ee , 480 , 1 } , { 0x1f8d , 154 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x03ee , 875 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8d , 1535 , 1 } , { 0xa78d , 643 , 1 } , { 0x10c8d , 3396 , 1 } , { 0x0534 , 1343 , 1 } , { 0x0181 , 613 , 1 } , { 0x1f81 , 134 , 2 } , { 0x013d , 258 , 1 } , { 0x1f3d , 2163 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab81 , 1499 , 1 } , { 0x017f , 52 , 1 } , { 0x10c81 , 3360 , 1 } , { 0x2c7f , 583 , 1 } , { 0x037f , 881 , 1 } , { 0xff2d , 3195 , 1 } , { 0xab7f , 1493 , 1 } , { 0x1e74 , 1887 , 1 } , { 0x0474 , 1064 , 1 } , { 0x0174 , 339 , 1 } , { 0x1e3c , 1802 , 1 } , { 0x0149 , 46 , 2 } , { 0x1f49 , 2175 , 1 } , { 0x1f3c , 2160 , 1 } , { 0xab74 , 1460 , 1 } , { 0x0049 , 3606 , 1 } , { 0x0143 , 267 , 1 } , { 0x24cc , 2409 , 1 } , { 0xa73c , 3012 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0043 , 6 , 1 } , { 0x0141 , 264 , 1 } , { 0x24c6 , 2391 , 1 } , { 0x013b , 255 , 1 } , { 0x1f3b , 2157 , 1 } , { 0x0041 , 0 , 1 } , { 0x0139 , 252 , 1 } , { 0x1f39 , 2151 , 1 } , { 0x24c5 , 2388 , 1 } , { 0x24bb , 2358 , 1 } , { 0x13fa , 1694 , 1 } , { 0x053d , 1370 , 1 } , { 0x24b9 , 2352 , 1 } , { 0x0429 , 965 , 1 } , { 0x2183 , 2340 , 1 } , { 0x1f29 , 2127 , 1 } , { 0x2c29 , 2544 , 1 } , { 0x24c3 , 2382 , 1 } , { 0x10427 , 3354 , 1 } , { 0x10425 , 3348 , 1 } , { 0x0427 , 959 , 1 } , { 0x0425 , 953 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c27 , 2538 , 1 } , { 0x2c25 , 2532 , 1 } , { 0x0549 , 1406 , 1 } , { 0x053c , 1367 , 1 } , { 0x10423 , 3342 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0423 , 947 , 1 } , { 0x0543 , 1388 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c23 , 2526 , 1 } , { 0xff36 , 3222 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0541 , 1382 , 1 } , { 0x10421 , 3336 , 1 } , { 0x053b , 1364 , 1 } , { 0x0421 , 941 , 1 } , { 0xff38 , 3228 , 1 } , { 0x0539 , 1358 , 1 } , { 0x2c21 , 2520 , 1 } , { 0x10419 , 3312 , 1 } , { 0x10417 , 3306 , 1 } , { 0x0419 , 917 , 1 } , { 0x0417 , 911 , 1 } , { 0x1f19 , 2109 , 1 } , { 0x2c19 , 2496 , 1 } , { 0x2c17 , 2490 , 1 } , { 0x023e , 2568 , 1 } , { 0xff34 , 3216 , 1 } , { 0x10415 , 3300 , 1 } , { 0x10413 , 3294 , 1 } , { 0x0415 , 905 , 1 } , { 0x0413 , 899 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c15 , 2484 , 1 } , { 0x2c13 , 2478 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24ce , 2415 , 1 } , { 0x1040f , 3282 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x040f , 1031 , 1 } , { 0xff30 , 3204 , 1 } , { 0x1f0f , 2103 , 1 } , { 0x2c0f , 2466 , 1 } , { 0x1040d , 3276 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x040d , 1025 , 1 } , { 0x0147 , 273 , 1 } , { 0x1f0d , 2097 , 1 } , { 0x2c0d , 2460 , 1 } , { 0x1040b , 3270 , 1 } , { 0x0047 , 18 , 1 } , { 0x040b , 1019 , 1 } , { 0x0230 , 571 , 1 } , { 0x1f0b , 2091 , 1 } , { 0x2c0b , 2454 , 1 } , { 0x10409 , 3264 , 1 } , { 0x10405 , 3252 , 1 } , { 0x0409 , 1013 , 1 } , { 0x0405 , 1001 , 1 } , { 0x1f09 , 2085 , 1 } , { 0x2c09 , 2448 , 1 } , { 0x2c05 , 2436 , 1 } , { 0x10403 , 3246 , 1 } , { 0x10401 , 3240 , 1 } , { 0x0403 , 995 , 1 } , { 0x0401 , 989 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c03 , 2430 , 1 } , { 0x2c01 , 2424 , 1 } , { 0x13f9 , 1691 , 1 } , { 0x042f , 983 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1f2f , 2145 , 1 } , { 0x1041f , 3330 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x041f , 935 , 1 } , { 0x023d , 378 , 1 } , { 0x10411 , 3288 , 1 } , { 0x2c1f , 2514 , 1 } , { 0x0411 , 893 , 1 } , { 0x0547 , 1400 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c11 , 2472 , 1 } , { 0x10407 , 3258 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0407 , 1007 , 1 } , { 0x24c1 , 2376 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c07 , 2442 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x13f8 , 1688 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff39 , 3231 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0243 , 354 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x0241 , 586 , 1 } , { 0xff29 , 3183 , 1 } , { 0x023b , 577 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff27 , 3177 , 1 } , { 0xff25 , 3171 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff23 , 3165 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff21 , 3159 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb17 , 117 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff2f , 3201 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb15 , 113 , 2 } , { 0xfb13 , 121 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb05 , 29 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb03 , 0 , 3 } , { 0xfb01 , 8 , 2 } } ; if ( 0 == 0 ) { int key = hash ( & code ) ; if ( key <= MAX_HASH_VALUE && key >= 0 ) { OnigCodePoint gcode = wordlist [ key ] . code ;  if ( code == gcode )  return & wordlist [ key ] ; } } return 0 ; }", code == gcode && wordlist [ key ] . index >= 0
107,"CWE-119 char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) {  char buffer [ 4096 ] ;  char buffer2 [ 4096 ] ; int o_name_len = name_len ;  char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;  int l ;  if ( name_len > sizeof ( buffer ) - 2 ) {  buf = estrndup ( name , name_len ) ;  } else {  memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain :  if ( buf != buffer ) {  efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } }  if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {  memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie :  if ( buf != buffer ) {  efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }"," TSRMLS_DC ) {  int o_name_len =  char * buf , * buf2  , * d  int l ;  buf = estrndup  name_len ) ;  name_len = php_url_decode  { decrypt_return_plain : efree ( buf ) ;  memcpy ( *  ; } } buf2 = estrndup ( value , value_len ) ;  value_len = php_url_decode  ; skip_cookie : efree ( buf ) ; efree ( buf2 ) ;  return * where"
108,"CWE-125 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } switch ( type ) { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t )  GetPixelIndex ( image , q ) , q ) ;  q += GetPixelChannels ( image ) ; x ++ ; } x -- ; continue ; } } break ; } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }"," ( ssize_t ) ConstrainColormapIndex ( image ,  image , q ) , exception"
109,"CWE-476 static bool handle_client_startup ( PgSocket * client , PktHdr * pkt ) { const char * passwd ; const uint8_t * key ; bool ok ; SBuf * sbuf = & client -> sbuf ; if ( incomplete_pkt ( pkt ) ) { disconnect_client ( client , true , ""clientsentpartialpktinstartupphase"" ) ; return false ; } if ( client -> wait_for_welcome ) { if ( finish_client_login ( client ) ) { sbuf_prepare_skip ( sbuf , pkt -> len ) ; return true ; } else return false ; } switch ( pkt -> type ) { case PKT_SSLREQ : slog_noise ( client , ""C:reqSSL"" ) ; slog_noise ( client , ""P:nak"" ) ; if ( ! sbuf_answer ( & client -> sbuf , ""N"" , 1 ) ) { disconnect_client ( client , false , ""failedtonakSSL"" ) ; return false ; } break ; case PKT_STARTUP_V2 : disconnect_client ( client , true , ""OldV2protocolnotsupported"" ) ; return false ; case PKT_STARTUP : if ( client -> pool ) { disconnect_client ( client , true , ""clientre-sentstartuppkt"" ) ; return false ; } if ( ! decide_startup_pool ( client , pkt ) ) return false ; if ( client -> pool -> db -> admin ) { if ( ! admin_pre_login ( client ) ) return false ; } if ( cf_auth_type <= AUTH_TRUST || client -> own_user ) { if ( ! finish_client_login ( client ) ) return false ; } else { if ( ! send_client_authreq ( client ) ) { disconnect_client ( client , false , ""failedtosendauthreq"" ) ; return false ; } } break ; case 'p' :  if ( cf_auth_type <= AUTH_TRUST ) {  disconnect_client ( client , true , ""unrequestedpasswdpkt"" ) ; return false ; } ok = mbuf_get_string ( & pkt -> data , & passwd ) ; if ( ok && check_client_passwd ( client , passwd ) ) { if ( ! finish_client_login ( client ) ) return false ; } else { disconnect_client ( client , true , ""Authfailed"" ) ; return false ; } break ; case PKT_CANCEL : if ( mbuf_avail_for_read ( & pkt -> data ) == BACKENDKEY_LEN && mbuf_get_bytes ( & pkt -> data , BACKENDKEY_LEN , & key ) ) { memcpy ( client -> cancel_key , key , BACKENDKEY_LEN ) ; accept_cancel_request ( client ) ; } else disconnect_client ( client , false , ""badcancelrequest"" ) ; return false ; default : disconnect_client ( client , false , ""badpacket"" ) ; return false ; } sbuf_prepare_skip ( sbuf , pkt -> len ) ; client -> request_time = get_cached_time ( ) ; return true ; }"," : if ( ! client -> auth_user ) { disconnect_client ( client , true , ""clientpasswordpktbeforestartuppacket"" ) ; return false ; } if ("
110,"CWE-79 static int rndr_quote ( struct buf * ob , const struct buf * text , void * opaque ) { if ( ! text || ! text -> size ) return 0 ;  BUFPUTSL ( ob , ""<q>"" ) ;  bufput ( ob , text -> data , text -> size ) ; BUFPUTSL ( ob , ""</q>"" ) ; return 1 ; }"," return 0 ; struct html_renderopt * options = opaque ;  ""<q>"" ) ; if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ; else"
111,"CWE-264 static int cg_opendir ( const char * path , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; const char * cgroup ; struct file_info * dir_info ; char * controller = NULL ; if ( ! fc ) return - EIO ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { cgroup = NULL ; controller = NULL ; } else { controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { cgroup = ""/"" ; } }  if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) {  return - EACCES ; } dir_info = malloc ( sizeof ( * dir_info ) ) ; if ( ! dir_info ) return - ENOMEM ; dir_info -> controller = must_copy_string ( controller ) ; dir_info -> cgroup = must_copy_string ( cgroup ) ; dir_info -> type = LXC_TYPE_CGDIR ; dir_info -> buf = NULL ; dir_info -> file = NULL ; dir_info -> buflen = 0 ; fi -> fh = ( unsigned long ) dir_info ; return 0 ; }"," if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if (  ! fc_may_access (  O_RDONLY ) )  return - EACCES"
112,"CWE-119  void validate_positive_rational ( const char * msg ,  struct vpx_rational * rat ) { if ( rat -> den < 0 ) { rat -> num *= - 1 ; rat -> den *= - 1 ; } if ( rat -> num < 0 ) die ( ""Error:%smustbepositive\\n"" , msg ) ; if ( ! rat -> den ) die ( ""Error:%shaszerodenominator\\n"" , msg ) ; }",    static
113,"CWE-125 static char * get_icu_value_internal ( const char * loc_name , char * tag_name , int * result , int fromParseLocale ) { char * tag_value = NULL ; int32_t tag_value_len = 512 ; int singletonPos = 0 ; char * mod_loc_name = NULL ; int grOffset = 0 ; int32_t buflen = 512 ; UErrorCode status = U_ZERO_ERROR ; if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) != 0 ) { grOffset = findOffset ( LOC_GRANDFATHERED , loc_name ) ; if ( grOffset >= 0 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { return estrdup ( loc_name ) ; } else { return NULL ; } } if ( fromParseLocale == 1 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { if ( strlen ( loc_name ) > 1 && ( isIDPrefix ( loc_name ) == 1 ) ) { return estrdup ( loc_name ) ; } } singletonPos = getSingletonPos ( loc_name ) ; if ( singletonPos == 0 ) { return NULL ; } else if ( singletonPos > 0 ) { mod_loc_name = estrndup ( loc_name , singletonPos - 1 ) ; } } } if ( mod_loc_name == NULL ) { mod_loc_name = estrdup ( loc_name ) ; } do { tag_value = erealloc ( tag_value , buflen ) ; tag_value_len = buflen ; if ( strcmp ( tag_name , LOC_SCRIPT_TAG ) == 0 ) { buflen = uloc_getScript ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { buflen = uloc_getLanguage ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_REGION_TAG ) == 0 ) { buflen = uloc_getCountry ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_VARIANT_TAG ) == 0 ) { buflen = uloc_getVariant ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) == 0 ) { buflen = uloc_canonicalize ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( U_FAILURE ( status ) ) { if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ;  continue ;  } * result = 0 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } } while ( buflen > tag_value_len ) ; if ( buflen == 0 ) { * result = - 1 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } else { * result = 1 ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return tag_value ; }", = U_ZERO_ERROR ; buflen ++ ;
114,"CWE-125 static void printFlow ( u_int16_t id , struct ndpi_flow_info * flow , u_int16_t thread_id ) { FILE * out = results_file ? results_file : stdout ; u_int8_t known_tls ; char buf [ 32 ] , buf1 [ 64 ] ; u_int i ; double dos_ge_score ; double dos_slow_score ; double dos_hulk_score ; double ddos_score ; double hearthbleed_score ; double ftp_patator_score ; double ssh_patator_score ; double inf_score ; if ( csv_fp != NULL ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; double f = ( double ) flow -> first_seen , l = ( double ) flow -> last_seen ; dos_ge_score = Dos_goldeneye_score ( flow ) ; dos_slow_score = Dos_slow_score ( flow ) ; dos_hulk_score = Dos_hulk_score ( flow ) ; ddos_score = Ddos_score ( flow ) ; hearthbleed_score = Hearthbleed_score ( flow ) ; ftp_patator_score = Ftp_patator_score ( flow ) ; ssh_patator_score = Ssh_patator_score ( flow ) ; inf_score = Infiltration_score ( flow ) ; double benign_score = dos_ge_score < 1 && dos_slow_score < 1 && dos_hulk_score < 1 && ddos_score < 1 && hearthbleed_score < 1 && ftp_patator_score < 1 && ssh_patator_score < 1 && inf_score < 1 ? 1.1 : 0 ; fprintf ( csv_fp , ""%u,%u,%.3f,%.3f,%.3f,%s,%u,%s,%u,"" , flow -> flow_id , flow -> protocol , f / 1000.0 , l / 1000.0 , ( l - f ) / 1000.0 , flow -> src_name , ntohs ( flow -> src_port ) , flow -> dst_name , ntohs ( flow -> dst_port ) ) ; fprintf ( csv_fp , ""%s,"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) ) ; fprintf ( csv_fp , ""%s,%s,"" , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , flow -> host_server_name ) ; fprintf ( csv_fp , ""%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,%.4lf,"" , benign_score , dos_slow_score , dos_ge_score , dos_hulk_score , ddos_score , hearthbleed_score , ftp_patator_score , ssh_patator_score , inf_score ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes , ( long long unsigned int ) flow -> src2dst_goodput_bytes ) ; fprintf ( csv_fp , ""%u,%llu,%llu,"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes , ( long long unsigned int ) flow -> dst2src_goodput_bytes ) ; fprintf ( csv_fp , ""%.3f,%s,"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( csv_fp , ""%.1f,%.1f,"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_flow ) , ndpi_data_average ( flow -> iat_flow ) , ndpi_data_max ( flow -> iat_flow ) , ndpi_data_stddev ( flow -> iat_flow ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_average ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_stddev ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_s_to_c ) , ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( csv_fp , ""%u,%.1f,%u,%.1f,%u,%.1f,%u,%.1f,"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> src2dst_cwr_count , flow -> src2dst_ece_count , flow -> src2dst_urg_count , flow -> src2dst_ack_count , flow -> src2dst_psh_count , flow -> src2dst_rst_count , flow -> src2dst_syn_count , flow -> src2dst_fin_count ) ; fprintf ( csv_fp , ""%d,%d,%d,%d,%d,%d,%d,%d,"" , flow -> dst2src_cwr_count , flow -> ece_count , flow -> urg_count , flow -> ack_count , flow -> psh_count , flow -> rst_count , flow -> syn_count , flow -> fin_count ) ; fprintf ( csv_fp , ""%u,%u,"" , flow -> c_to_s_init_win , flow -> s_to_c_init_win ) ; fprintf ( csv_fp , ""%s,%s,"" , ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_requested_server_name : """" , ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_info : """" ) ; fprintf ( csv_fp , ""%s,%s,%s,%s,%s,"" , ( flow -> ssh_tls . ssl_version != 0 ) ? ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) : ""0"" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_client : """" , ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . client_unsafe_cipher ) : ""0"" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? flow -> ssh_tls . ja3_server : """" , ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) ? is_unsafe_cipher ( flow -> ssh_tls . server_unsafe_cipher ) : ""0"" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_alpn ? flow -> ssh_tls . tls_alpn : """" , flow -> ssh_tls . tls_supported_versions ? flow -> ssh_tls . tls_supported_versions : """" ) ; fprintf ( csv_fp , ""%s,%s,"" , flow -> ssh_tls . tls_issuerDN ? flow -> ssh_tls . tls_issuerDN : """" , flow -> ssh_tls . tls_subjectDN ? flow -> ssh_tls . tls_subjectDN : """" ) ; fprintf ( csv_fp , ""%s,%s"" , ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . client_hassh : """" , ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) ? flow -> ssh_tls . server_hassh : """" ) ; fprintf ( csv_fp , "",%s"" , flow -> info ) ; } if ( ( verbose != 1 ) && ( verbose != 2 ) ) { if ( csv_fp && enable_joy_stats ) { flowGetBDMeanandVariance ( flow ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; return ; } if ( csv_fp || ( verbose > 1 ) ) { # if 1 fprintf ( out , ""\\t%u"" , id ) ; # else fprintf ( out , ""\\t%u(%u)"" , id , flow -> flow_id ) ; # endif fprintf ( out , ""\\t%s"" , ipProto2Name ( flow -> protocol ) ) ; fprintf ( out , ""%s%s%s:%u%s%s%s%s:%u"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> src_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> src_port ) , flow -> bidirectional ? ""<->"" : ""->"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> dst_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> dst_port ) ) ; if ( flow -> vlan_id > 0 ) fprintf ( out , ""[VLAN:%u]"" , flow -> vlan_id ) ; if ( enable_payload_analyzer ) fprintf ( out , ""[flowId:%u]"" , flow -> flow_id ) ; } if ( enable_joy_stats ) { flowGetBDMeanandVariance ( flow ) ; fflush ( out ) ; fprintf ( out , ""[score:%.4f]"" , flow -> entropy . score ) ; } if ( csv_fp ) fprintf ( csv_fp , ""\\n"" ) ; fprintf ( out , ""[proto:"" ) ; if ( flow -> tunnel_type != ndpi_no_tunnel ) fprintf ( out , ""%s:"" , ndpi_tunnel2str ( flow -> tunnel_type ) ) ; fprintf ( out , ""%s/%s]"" , ndpi_protocol2id ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf , sizeof ( buf ) ) , ndpi_protocol2name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol , buf1 , sizeof ( buf1 ) ) ) ; if ( flow -> detected_protocol . category != 0 ) fprintf ( out , ""[cat:%s/%u]"" , ndpi_category_get_name ( ndpi_thread_info [ thread_id ] . workflow -> ndpi_struct , flow -> detected_protocol . category ) , ( unsigned int ) flow -> detected_protocol . category ) ; fprintf ( out , ""[%upkts/%llubytes"" , flow -> src2dst_packets , ( long long unsigned int ) flow -> src2dst_bytes ) ; fprintf ( out , ""%s%upkts/%llubytes]"" , ( flow -> dst2src_packets > 0 ) ? ""<->"" : ""->"" , flow -> dst2src_packets , ( long long unsigned int ) flow -> dst2src_bytes ) ; fprintf ( out , ""[Goodputratio:%.0f/%.0f]"" , 100.0 * ( ( float ) flow -> src2dst_goodput_bytes / ( float ) ( flow -> src2dst_bytes + 1 ) ) , 100.0 * ( ( float ) flow -> dst2src_goodput_bytes / ( float ) ( flow -> dst2src_bytes + 1 ) ) ) ; if ( flow -> last_seen > flow -> first_seen ) fprintf ( out , ""[%.2fsec]"" , ( ( float ) ( flow -> last_seen - flow -> first_seen ) ) / ( float ) 1000 ) ; else fprintf ( out , ""[<1sec]"" ) ; if ( flow -> telnet . username [ 0 ] != '\\0' ) fprintf ( out , ""[Username:%s]"" , flow -> telnet . username ) ; if ( flow -> telnet . password [ 0 ] != '\\0' ) fprintf ( out , ""[Password:%s]"" , flow -> telnet . password ) ; if ( flow -> host_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[Host:%s]"" , flow -> host_server_name ) ; if ( flow -> info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> info ) ; if ( flow -> flow_extra_info [ 0 ] != '\\0' ) fprintf ( out , ""[%s]"" , flow -> flow_extra_info ) ; if ( ( flow -> src2dst_packets + flow -> dst2src_packets ) > 5 ) { if ( flow -> iat_c_to_s && flow -> iat_s_to_c ) { float data_ratio = ndpi_data_ratio ( flow -> src2dst_bytes , flow -> dst2src_bytes ) ; fprintf ( out , ""[bytesratio:%.3f(%s)]"" , data_ratio , ndpi_data_ratio2str ( data_ratio ) ) ; fprintf ( out , ""[IATc2s/s2cmin/avg/max/stddev:%u/%u%.0f/%.0f%u/%u%.0f/%.0f]"" , ndpi_data_min ( flow -> iat_c_to_s ) , ndpi_data_min ( flow -> iat_s_to_c ) , ( float ) ndpi_data_average ( flow -> iat_c_to_s ) , ( float ) ndpi_data_average ( flow -> iat_s_to_c ) , ndpi_data_max ( flow -> iat_c_to_s ) , ndpi_data_max ( flow -> iat_s_to_c ) , ( float ) ndpi_data_stddev ( flow -> iat_c_to_s ) , ( float ) ndpi_data_stddev ( flow -> iat_s_to_c ) ) ; fprintf ( out , ""[PktLenc2s/s2cmin/avg/max/stddev:%u/%u%.0f/%.0f%u/%u%.0f/%.0f]"" , ndpi_data_min ( flow -> pktlen_c_to_s ) , ndpi_data_min ( flow -> pktlen_s_to_c ) , ndpi_data_average ( flow -> pktlen_c_to_s ) , ndpi_data_average ( flow -> pktlen_s_to_c ) , ndpi_data_max ( flow -> pktlen_c_to_s ) , ndpi_data_max ( flow -> pktlen_s_to_c ) , ndpi_data_stddev ( flow -> pktlen_c_to_s ) , ndpi_data_stddev ( flow -> pktlen_s_to_c ) ) ; } } if ( flow -> http . url [ 0 ] != '\\0' ) { ndpi_risk_enum risk = ndpi_validate_url ( flow -> http . url ) ; if ( risk != NDPI_NO_RISK ) NDPI_SET_BIT ( flow -> risk , risk ) ;  fprintf ( out , ""[URL:%s[StatusCode:%u]"" ,  flow -> http . url , flow -> http . response_status_code ) ; if ( flow -> http . content_type [ 0 ] != '\\0' )  fprintf ( out , ""[ContentType:%s]"" , flow -> http . content_type ) ;  if ( flow -> http . user_agent [ 0 ] != '\\0' )  fprintf ( out , ""[UserAgent:%s]"" , flow -> http . user_agent ) ;  } if ( flow -> risk ) { u_int i ; fprintf ( out , ""[Risk:"" ) ; for ( i = 0 ; i < NDPI_MAX_RISK ; i ++ ) if ( NDPI_ISSET_BIT ( flow -> risk , i ) ) fprintf ( out , ""**%s**"" , ndpi_risk2str ( i ) ) ; fprintf ( out , ""]"" ) ; } if ( flow -> ssh_tls . ssl_version != 0 ) fprintf ( out , ""[%s]"" , ndpi_ssl_version2str ( flow -> ssh_tls . ssl_version , & known_tls ) ) ; if ( flow -> ssh_tls . client_requested_server_name [ 0 ] != '\\0' ) fprintf ( out , ""[Client:%s]"" , flow -> ssh_tls . client_requested_server_name ) ; if ( flow -> ssh_tls . client_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[HASSH-C:%s]"" , flow -> ssh_tls . client_hassh ) ; if ( flow -> ssh_tls . ja3_client [ 0 ] != '\\0' ) fprintf ( out , ""[JA3C:%s%s]"" , flow -> ssh_tls . ja3_client , print_cipher ( flow -> ssh_tls . client_unsafe_cipher ) ) ; if ( flow -> ssh_tls . server_info [ 0 ] != '\\0' ) fprintf ( out , ""[Server:%s]"" , flow -> ssh_tls . server_info ) ; if ( flow -> ssh_tls . server_names ) fprintf ( out , ""[ServerNames:%s]"" , flow -> ssh_tls . server_names ) ; if ( flow -> ssh_tls . server_hassh [ 0 ] != '\\0' ) fprintf ( out , ""[HASSH-S:%s]"" , flow -> ssh_tls . server_hassh ) ; if ( flow -> ssh_tls . ja3_server [ 0 ] != '\\0' ) fprintf ( out , ""[JA3S:%s%s]"" , flow -> ssh_tls . ja3_server , print_cipher ( flow -> ssh_tls . server_unsafe_cipher ) ) ; if ( flow -> ssh_tls . tls_issuerDN ) fprintf ( out , ""[Issuer:%s]"" , flow -> ssh_tls . tls_issuerDN ) ; if ( flow -> ssh_tls . tls_subjectDN ) fprintf ( out , ""[Subject:%s]"" , flow -> ssh_tls . tls_subjectDN ) ; if ( ( flow -> detected_protocol . master_protocol == NDPI_PROTOCOL_TLS ) || ( flow -> detected_protocol . app_protocol == NDPI_PROTOCOL_TLS ) ) { if ( flow -> ssh_tls . sha1_cert_fingerprint_set ) { fprintf ( out , ""[CertificateSHA-1:"" ) ; for ( i = 0 ; i < 20 ; i ++ ) fprintf ( out , ""%s%02X"" , ( i > 0 ) ? "":"" : """" , flow -> ssh_tls . sha1_cert_fingerprint [ i ] & 0xFF ) ; fprintf ( out , ""]"" ) ; } } if ( flow -> ssh_tls . notBefore && flow -> ssh_tls . notAfter ) { char notBefore [ 32 ] , notAfter [ 32 ] ; struct tm a , b ; struct tm * before = gmtime_r ( & flow -> ssh_tls . notBefore , & a ) ; struct tm * after = gmtime_r ( & flow -> ssh_tls . notAfter , & b ) ; strftime ( notBefore , sizeof ( notBefore ) , ""%F%T"" , before ) ; strftime ( notAfter , sizeof ( notAfter ) , ""%F%T"" , after ) ; fprintf ( out , ""[Validity:%s-%s]"" , notBefore , notAfter ) ; } if ( flow -> ssh_tls . server_cipher != '\\0' ) fprintf ( out , ""[Cipher:%s]"" , ndpi_cipher2str ( flow -> ssh_tls . server_cipher ) ) ; if ( flow -> bittorent_hash [ 0 ] != '\\0' ) fprintf ( out , ""[BTHash:%s]"" , flow -> bittorent_hash ) ; if ( flow -> dhcp_fingerprint [ 0 ] != '\\0' ) fprintf ( out , ""[DHCPFingerprint:%s]"" , flow -> dhcp_fingerprint ) ; if ( flow -> has_human_readeable_strings ) fprintf ( out , ""[PLAINTEXT(%s)]"" , flow -> human_readeable_string_buffer ) ; fprintf ( out , ""\\n"" ) ; }"," ( out , ""[URL:%s][StatusCode:%u]""  , flow ->  ( out , ""[Content-Type:%s]""  , flow ->  ( out , ""[User-Agent:%s]""  , flow ->"
115,"CWE-119 static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) {  int ret ;  ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data ,  indx , & data , 1 , 1000 ) ;  if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%sreturned%d\\n"" , __func__ , ret ) ;  return ret ;  }"," data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM  ; ret =  , indx , buf  , 1 ,  ret ) ; kfree ( buf ) ;"
116,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; FlipContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow ; int i , j , plane , step ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ;  for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) {  const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; step = s -> max_step [ plane ] ; outrow = out -> data [ plane ] ; inrow = in -> data [ plane ] + ( width - 1 ) * step ; for ( i = 0 ; i < height ; i ++ ) { switch ( step ) { case 1 : for ( j = 0 ; j < width ; j ++ ) outrow [ j ] = inrow [ - j ] ; break ; case 2 : { uint16_t * outrow16 = ( uint16_t * ) outrow ; uint16_t * inrow16 = ( uint16_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow16 [ j ] = inrow16 [ - j ] ; } break ; case 3 : { uint8_t * in = inrow ; uint8_t * out = outrow ; for ( j = 0 ; j < width ; j ++ , out += 3 , in -= 3 ) { int32_t v = AV_RB24 ( in ) ; AV_WB24 ( out , v ) ; } } break ; case 4 : { uint32_t * outrow32 = ( uint32_t * ) outrow ; uint32_t * inrow32 = ( uint32_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow32 [ j ] = inrow32 [ - j ] ; } break ; default : for ( j = 0 ; j < width ; j ++ ) memcpy ( outrow + j * step , inrow - j * step , step ) ; } inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }", [ plane ] && in -> linesize [ plane ]
117,"CWE-200 static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ XFRMA_REPLAY_ESN_VAL ] ;  if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt )   return - EINVAL ;  if ( ! rt ) return 0 ; if ( p -> id . proto != IPPROTO_ESP ) return - EINVAL ; if ( p -> replay_window != 0 ) return - EINVAL ; return 0 ; }", XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if  ( p ->  & XFRM_STATE_ESN ) { if (  ! rt )  - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; }
118,"CWE-119  static void mark_object ( struct object * obj , struct strbuf * path ,  const char * name , void * data ) { update_progress ( data ) ; }"," * obj ,  const char *"
119,"CWE-436 static gssize find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) {  guchar * match ;  int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ;  gsize to_match = MIN ( left , buffer -> pos ) ;   if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 )  { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL )  return match - buffer -> data + strlen ( AUTH_END_STRING ) ;  for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }"," buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer  , buffer ->  , buffer -> data , buffer ->  pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer  -> data +  -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } }  }  "
120,"CWE-125 void zephyr_print ( netdissect_options * ndo , const u_char * cp , int length ) { struct z_packet z ; const char * parse = ( const char * ) cp ; int parselen = length ; const char * s ; int lose = 0 ;  z . kind = 0 ;  z . class = 0 ; z . inst = 0 ; z . opcode = 0 ; z . sender = 0 ; z . recipient = 0 ;  # define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ; if ( ! s ) lose = 1 ;  # define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ; # define PARSE_FIELD_STR ( field ) PARSE_STRING if ( ! lose ) field = s ; PARSE_FIELD_STR ( z . version ) ; if ( lose ) return ; if ( strncmp ( z . version , ""ZEPH"" , 4 ) ) return ; PARSE_FIELD_INT ( z . numfields ) ; PARSE_FIELD_INT ( z . kind ) ; PARSE_FIELD_STR ( z . uid ) ; PARSE_FIELD_INT ( z . port ) ; PARSE_FIELD_INT ( z . auth ) ; PARSE_FIELD_INT ( z . authlen ) ; PARSE_FIELD_STR ( z . authdata ) ; PARSE_FIELD_STR ( z . class ) ; PARSE_FIELD_STR ( z . inst ) ; PARSE_FIELD_STR ( z . opcode ) ; PARSE_FIELD_STR ( z . sender ) ; PARSE_FIELD_STR ( z . recipient ) ; PARSE_FIELD_STR ( z . format ) ; PARSE_FIELD_INT ( z . cksum ) ; PARSE_FIELD_INT ( z . multi ) ; PARSE_FIELD_STR ( z . multi_uid ) ;  if ( lose ) {  ND_PRINT ( ( ndo , ""[|zephyr](%d)"" , length ) ) ; return ; } ND_PRINT ( ( ndo , ""zephyr"" ) ) ; if ( strncmp ( z . version + 4 , ""0.2"" , 3 ) ) { ND_PRINT ( ( ndo , ""v%s"" , z . version + 4 ) ) ; return ; } ND_PRINT ( ( ndo , ""%s"" , tok2str ( z_types , ""type%d"" , z . kind ) ) ) ; if ( z . kind == Z_PACKET_SERVACK ) { const char * ackdata = NULL ; PARSE_FIELD_STR ( ackdata ) ; if ( ! lose && strcmp ( ackdata , ""SENT"" ) ) ND_PRINT ( ( ndo , ""/%s"" , str_to_lower ( ackdata ) ) ) ; } if ( * z . sender ) ND_PRINT ( ( ndo , ""%s"" , z . sender ) ) ; if ( ! strcmp ( z . class , ""USER_LOCATE"" ) ) { if ( ! strcmp ( z . opcode , ""USER_HIDE"" ) ) ND_PRINT ( ( ndo , ""hide"" ) ) ; else if ( ! strcmp ( z . opcode , ""USER_UNHIDE"" ) ) ND_PRINT ( ( ndo , ""unhide"" ) ) ; else ND_PRINT ( ( ndo , ""locate%s"" , z . inst ) ) ; return ; } if ( ! strcmp ( z . class , ""ZEPHYR_ADMIN"" ) ) { ND_PRINT ( ( ndo , ""zephyr-admin%s"" , str_to_lower ( z . opcode ) ) ) ; return ; } if ( ! strcmp ( z . class , ""ZEPHYR_CTL"" ) ) { if ( ! strcmp ( z . inst , ""CLIENT"" ) ) { if ( ! strcmp ( z . opcode , ""SUBSCRIBE"" ) || ! strcmp ( z . opcode , ""SUBSCRIBE_NODEFS"" ) || ! strcmp ( z . opcode , ""UNSUBSCRIBE"" ) ) { ND_PRINT ( ( ndo , ""%ssub%s"" , strcmp ( z . opcode , ""SUBSCRIBE"" ) ? ""un"" : """" , strcmp ( z . opcode , ""SUBSCRIBE_NODEFS"" ) ? """" : ""-nodefs"" ) ) ; if ( z . kind != Z_PACKET_SERVACK ) { const char * c = NULL , * i = NULL , * r = NULL ; PARSE_FIELD_STR ( c ) ; PARSE_FIELD_STR ( i ) ; PARSE_FIELD_STR ( r ) ; if ( ! lose ) ND_PRINT ( ( ndo , ""%s"" , z_triple ( c , i , r ) ) ) ; } return ; } if ( ! strcmp ( z . opcode , ""GIMME"" ) ) { ND_PRINT ( ( ndo , ""ret"" ) ) ; return ; } if ( ! strcmp ( z . opcode , ""GIMMEDEFS"" ) ) { ND_PRINT ( ( ndo , ""gimme-defs"" ) ) ; return ; } if ( ! strcmp ( z . opcode , ""CLEARSUB"" ) ) { ND_PRINT ( ( ndo , ""clear-subs"" ) ) ; return ; } ND_PRINT ( ( ndo , ""%s"" , str_to_lower ( z . opcode ) ) ) ; return ; } if ( ! strcmp ( z . inst , ""HM"" ) ) { ND_PRINT ( ( ndo , ""%s"" , str_to_lower ( z . opcode ) ) ) ; return ; } if ( ! strcmp ( z . inst , ""REALM"" ) ) { if ( ! strcmp ( z . opcode , ""ADD_SUBSCRIBE"" ) ) ND_PRINT ( ( ndo , ""realmadd-subs"" ) ) ; if ( ! strcmp ( z . opcode , ""REQ_SUBSCRIBE"" ) ) ND_PRINT ( ( ndo , ""realmreq-subs"" ) ) ; if ( ! strcmp ( z . opcode , ""RLM_SUBSCRIBE"" ) ) ND_PRINT ( ( ndo , ""realmrlm-sub"" ) ) ; if ( ! strcmp ( z . opcode , ""RLM_UNSUBSCRIBE"" ) ) ND_PRINT ( ( ndo , ""realmrlm-unsub"" ) ) ; return ; } } if ( ! strcmp ( z . class , ""HM_CTL"" ) ) { ND_PRINT ( ( ndo , ""hm_ctl%s"" , str_to_lower ( z . inst ) ) ) ; ND_PRINT ( ( ndo , ""%s"" , str_to_lower ( z . opcode ) ) ) ; return ; } if ( ! strcmp ( z . class , ""HM_STAT"" ) ) { if ( ! strcmp ( z . inst , ""HMST_CLIENT"" ) && ! strcmp ( z . opcode , ""GIMMESTATS"" ) ) { ND_PRINT ( ( ndo , ""get-client-stats"" ) ) ; return ; } } if ( ! strcmp ( z . class , ""WG_CTL"" ) ) { ND_PRINT ( ( ndo , ""wg_ctl%s"" , str_to_lower ( z . inst ) ) ) ; ND_PRINT ( ( ndo , ""%s"" , str_to_lower ( z . opcode ) ) ) ; return ; } if ( ! strcmp ( z . class , ""LOGIN"" ) ) { if ( ! strcmp ( z . opcode , ""USER_FLUSH"" ) ) { ND_PRINT ( ( ndo , ""flush_locs"" ) ) ; return ; } if ( ! strcmp ( z . opcode , ""NONE"" ) || ! strcmp ( z . opcode , ""OPSTAFF"" ) || ! strcmp ( z . opcode , ""REALM-VISIBLE"" ) || ! strcmp ( z . opcode , ""REALM-ANNOUNCED"" ) || ! strcmp ( z . opcode , ""NET-VISIBLE"" ) || ! strcmp ( z . opcode , ""NET-ANNOUNCED"" ) ) { ND_PRINT ( ( ndo , ""set-exposure%s"" , str_to_lower ( z . opcode ) ) ) ; return ; } } if ( ! * z . recipient ) z . recipient = ""*"" ; ND_PRINT ( ( ndo , ""to%s"" , z_triple ( z . class , z . inst , z . recipient ) ) ) ; if ( * z . opcode ) ND_PRINT ( ( ndo , ""op%s"" , z . opcode ) ) ;  } "," = 0 ; int truncated = 0 ;  , & parselen , & truncated ) ; if ( truncated ) goto trunc  ; if (  ( lose ) goto trunc ;  ND_PRINT ( (  ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|zephyr](%d)"" , length ) ) ; return ;"
121,"CWE-20 static void br_multicast_del_pg ( struct net_bridge * br , struct net_bridge_port_group * pg ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & pg -> addr ) ; if ( WARN_ON ( ! mp ) ) return ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p != pg ) continue ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ;  if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; return ; } WARN_ON ( 1 ) ; }", -> mglist && mp -> timer_armed &&
122,"CWE-416 static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""ShortMakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""ShortMakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {  exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""ShortMakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loadingentry0x%x(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Tagsizeoverflowdetected(%u*%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Invalidzero-lengthtagsize"" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tagdatapastendofbuffer(%u>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }"," size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ;"
123,"CWE-400 static int add_ballooned_pages ( int nr_pages ) { enum bp_state st ; if ( xen_hotplug_unpopulated ) { st = reserve_additional_memory ( ) ; if ( st != BP_ECANCELED ) { mutex_unlock ( & balloon_mutex ) ; wait_event ( balloon_wq , ! list_empty ( & ballooned_pages ) ) ; mutex_lock ( & balloon_mutex ) ; return 0 ; } }  st = decrease_reservation ( nr_pages , GFP_USER ) ;  if ( st != BP_DONE ) return - ENOMEM ; return 0 ; }", ; } } if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;
124,"CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 :  p += 2 ;  n += 2 ; len -= 2 ; break ; case 0x40 :  p += 3 ;  n += 3 ; len -= 3 ; break ; case 0x80 :  p += 4 ;  n += 4 ; len -= 4 ; break ; case 0xC0 :  l = p [ 1 ] ;  if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }", case 0x00 : if ( len < 2 ) return - 1 ;  case 0x40 : if ( len < 3 ) return - 1 ;  case 0x80 : if ( len < 4 ) return - 1 ;  case 0xC0 : if ( len < 2 ) return - 1 ;
125,"CWE-20 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { memset ( sax , 0 , sizeof ( * sax ) ) ; sax -> sax25_family = AF_NETROM ; skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;  }  msg -> msg_namelen = sizeof ( * sax ) ;  skb_free_datagram ( sk , skb ) ;  release_sock ( sk ) ; return copied ; }", AX25_ADDR_LEN ) ;  msg -> msg_namelen  sax ) ; }
126,"CWE-20 error_t httpClientSetMethod ( HttpClientContext * context , const char_t * method ) { size_t m ; size_t n ; char_t * p ; if ( context == NULL || method == NULL ) return ERROR_INVALID_PARAMETER ; n = osStrlen ( method ) ; if ( n == 0 || n > HTTP_CLIENT_MAX_METHOD_LEN ) return ERROR_INVALID_LENGTH ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ;  p = strchr ( context -> buffer , '' ) ;  if ( p == NULL ) return ERROR_INVALID_SYNTAX ; m = p - context -> buffer ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( context -> buffer + n , p , context -> bufferLen + 1 - m ) ; osStrncpy ( context -> buffer , method , n ) ; context -> bufferLen = context -> bufferLen + n - m ; osStrcpy ( context -> method , method ) ; return NO_ERROR ; }", ; p = osStrchr  ( context ->
127,"CWE-125 static char * isis_print_id ( const uint8_t * cp , int id_len ) { int i ; static char id [ sizeof ( ""xxxx.xxxx.xxxx.yy-zz"" ) ] ; char * pos = id ;  for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) {  snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ; pos += strlen ( pos ) ; if ( i == 2 || i == 4 ) * pos ++ = '.' ; } if ( id_len >= NODE_ID_LEN ) { snprintf ( pos , sizeof ( id ) - ( pos - id ) , "".%02x"" , * cp ++ ) ; pos += strlen ( pos ) ; } if ( id_len == LSP_ID_LEN ) snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""-%02x"" , * cp ) ; return ( id ) ; }", = id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ;  ; i <= sysid_len  ; i ++
128,"CWE-119 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ;  line += PKT_LEN_SIZE ;  if ( len == PKT_LEN_SIZE ) { * head = NULL ; * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }", return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
129,"CWE-119 enum_func_status php_mysqlnd_rowp_read_text_protocol_aux ( MYSQLND_MEMORY_POOL_CHUNK * row_buffer , zval * * fields , unsigned int field_count , const MYSQLND_FIELD * fields_metadata , zend_bool as_int_or_float , zend_bool copy_data , MYSQLND_STATS * stats TSRMLS_DC ) { unsigned int i ; zend_bool last_field_was_string = FALSE ; zval * * current_field , * * end_field , * * start_field ; zend_uchar * p = row_buffer -> ptr ; size_t data_size = row_buffer -> app ; zend_uchar * bit_area = ( zend_uchar * ) row_buffer -> ptr + data_size + 1 ;  DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;  if ( ! fields ) { DBG_RETURN ( FAIL ) ; } end_field = ( start_field = fields ) + field_count ; for ( i = 0 , current_field = start_field ; current_field < end_field ; current_field ++ , i ++ ) { DBG_INF ( ""Directlycreatingzval"" ) ; MAKE_STD_ZVAL ( * current_field ) ; if ( ! * current_field ) { DBG_RETURN ( FAIL ) ; } } for ( i = 0 , current_field = start_field ; current_field < end_field ; current_field ++ , i ++ ) { zend_uchar * this_field_len_pos = p ;  unsigned long len = php_mysqlnd_net_field_length ( & p ) ;  if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) { * this_field_len_pos = '\\0' ; } if ( len == MYSQLND_NULL_LENGTH ) { ZVAL_NULL ( * current_field ) ; last_field_was_string = FALSE ; } else { # if defined ( MYSQLND_STRING_TO_INT_CONVERSION ) struct st_mysqlnd_perm_bind perm_bind = mysqlnd_ps_fetch_functions [ fields_metadata [ i ] . type ] ; # endif if ( MYSQLND_G ( collect_statistics ) ) { enum_mysqlnd_collected_stats statistic ; switch ( fields_metadata [ i ] . type ) { case MYSQL_TYPE_DECIMAL : statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL ; break ; case MYSQL_TYPE_TINY : statistic = STAT_TEXT_TYPE_FETCHED_INT8 ; break ; case MYSQL_TYPE_SHORT : statistic = STAT_TEXT_TYPE_FETCHED_INT16 ; break ; case MYSQL_TYPE_LONG : statistic = STAT_TEXT_TYPE_FETCHED_INT32 ; break ; case MYSQL_TYPE_FLOAT : statistic = STAT_TEXT_TYPE_FETCHED_FLOAT ; break ; case MYSQL_TYPE_DOUBLE : statistic = STAT_TEXT_TYPE_FETCHED_DOUBLE ; break ; case MYSQL_TYPE_NULL : statistic = STAT_TEXT_TYPE_FETCHED_NULL ; break ; case MYSQL_TYPE_TIMESTAMP : statistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP ; break ; case MYSQL_TYPE_LONGLONG : statistic = STAT_TEXT_TYPE_FETCHED_INT64 ; break ; case MYSQL_TYPE_INT24 : statistic = STAT_TEXT_TYPE_FETCHED_INT24 ; break ; case MYSQL_TYPE_DATE : statistic = STAT_TEXT_TYPE_FETCHED_DATE ; break ; case MYSQL_TYPE_TIME : statistic = STAT_TEXT_TYPE_FETCHED_TIME ; break ; case MYSQL_TYPE_DATETIME : statistic = STAT_TEXT_TYPE_FETCHED_DATETIME ; break ; case MYSQL_TYPE_YEAR : statistic = STAT_TEXT_TYPE_FETCHED_YEAR ; break ; case MYSQL_TYPE_NEWDATE : statistic = STAT_TEXT_TYPE_FETCHED_DATE ; break ; case MYSQL_TYPE_VARCHAR : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; case MYSQL_TYPE_BIT : statistic = STAT_TEXT_TYPE_FETCHED_BIT ; break ; case MYSQL_TYPE_NEWDECIMAL : statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL ; break ; case MYSQL_TYPE_ENUM : statistic = STAT_TEXT_TYPE_FETCHED_ENUM ; break ; case MYSQL_TYPE_SET : statistic = STAT_TEXT_TYPE_FETCHED_SET ; break ; case MYSQL_TYPE_JSON : statistic = STAT_TEXT_TYPE_FETCHED_JSON ; break ; case MYSQL_TYPE_TINY_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_MEDIUM_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_LONG_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; case MYSQL_TYPE_VAR_STRING : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; case MYSQL_TYPE_STRING : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; case MYSQL_TYPE_GEOMETRY : statistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY ; break ; default : statistic = STAT_TEXT_TYPE_FETCHED_OTHER ; break ; } MYSQLND_INC_CONN_STATISTIC_W_VALUE2 ( stats , statistic , 1 , STAT_BYTES_RECEIVED_PURE_DATA_TEXT , len ) ; } # ifdef MYSQLND_STRING_TO_INT_CONVERSION if ( as_int_or_float && perm_bind . php_type == IS_LONG ) { zend_uchar save = * ( p + len ) ; * ( p + len ) = '\\0' ; if ( perm_bind . pack_len < SIZEOF_LONG ) { int64_t v = # ifndef PHP_WIN32 atoll ( ( char * ) p ) ; # else _atoi64 ( ( char * ) p ) ; # endif ZVAL_LONG ( * current_field , ( long ) v ) ; } else { uint64_t v = # ifndef PHP_WIN32 ( uint64_t ) atoll ( ( char * ) p ) ; # else ( uint64_t ) _atoi64 ( ( char * ) p ) ; # endif zend_bool uns = fields_metadata [ i ] . flags & UNSIGNED_FLAG ? TRUE : FALSE ; # if SIZEOF_LONG == 8 if ( uns == TRUE && v > 9223372036854775807L ) # elif SIZEOF_LONG == 4 if ( ( uns == TRUE && v > L64 ( 2147483647 ) ) || ( uns == FALSE && ( ( L64 ( 2147483647 ) < ( int64_t ) v ) || ( L64 ( - 2147483648 ) > ( int64_t ) v ) ) ) ) # else # error Need fix for this architecture # endif { ZVAL_STRINGL ( * current_field , ( char * ) p , len , 0 ) ; } else { ZVAL_LONG ( * current_field , ( long ) v ) ; } } * ( p + len ) = save ; } else if ( as_int_or_float && perm_bind . php_type == IS_DOUBLE ) { zend_uchar save = * ( p + len ) ; * ( p + len ) = '\\0' ; ZVAL_DOUBLE ( * current_field , atof ( ( char * ) p ) ) ; * ( p + len ) = save ; } else # endif if ( fields_metadata [ i ] . type == MYSQL_TYPE_BIT ) { zend_uchar * start = bit_area ; ps_fetch_from_1_to_8_bytes ( * current_field , & ( fields_metadata [ i ] ) , 0 , & p , len TSRMLS_CC ) ; p -= len ; if ( Z_TYPE_PP ( current_field ) == IS_LONG ) { bit_area += 1 + sprintf ( ( char * ) start , ""%ld"" , Z_LVAL_PP ( current_field ) ) ; ZVAL_STRINGL ( * current_field , ( char * ) start , bit_area - start - 1 , copy_data ) ; } else if ( Z_TYPE_PP ( current_field ) == IS_STRING ) { memcpy ( bit_area , Z_STRVAL_PP ( current_field ) , Z_STRLEN_PP ( current_field ) ) ; bit_area += Z_STRLEN_PP ( current_field ) ; * bit_area ++ = '\\0' ; zval_dtor ( * current_field ) ; ZVAL_STRINGL ( * current_field , ( char * ) start , bit_area - start - 1 , copy_data ) ; } } else { ZVAL_STRINGL ( * current_field , ( char * ) p , len , copy_data ) ; } p += len ; last_field_was_string = TRUE ; } } if ( copy_data == FALSE && last_field_was_string ) { row_buffer -> ptr [ data_size ] = '\\0' ; } DBG_RETURN ( PASS ) ; }"," + 1 ; const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ;  = p ; const  p ) ; if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , ""Malformedserverpacket.Fieldlengthpointing"" MYSQLND_SZ_T_SPEC ""bytesafterendofpacket"" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; }"
130,"CWE-119 static int crypto_ccm_auth ( struct aead_request * req , struct scatterlist * plain , unsigned int cryptlen ) { struct crypto_ccm_req_priv_ctx * pctx = crypto_ccm_reqctx ( req ) ; struct crypto_aead * aead = crypto_aead_reqtfm ( req ) ; struct crypto_ccm_ctx * ctx = crypto_aead_ctx ( aead ) ; AHASH_REQUEST_ON_STACK ( ahreq , ctx -> mac ) ; unsigned int assoclen = req -> assoclen ; struct scatterlist sg [ 3 ] ;  u8 odata [ 16 ] ;  u8 idata [ 16 ] ; int ilen , err ; err = format_input ( odata , req , cryptlen ) ; if ( err ) goto out ; sg_init_table ( sg , 3 ) ; sg_set_buf ( & sg [ 0 ] , odata , 16 ) ; if ( assoclen ) { ilen = format_adata ( idata , assoclen ) ; sg_set_buf ( & sg [ 1 ] , idata , ilen ) ; sg_chain ( sg , 3 , req -> src ) ; } else { ilen = 0 ; sg_chain ( sg , 2 , req -> src ) ; } ahash_request_set_tfm ( ahreq , ctx -> mac ) ; ahash_request_set_callback ( ahreq , pctx -> flags , NULL , NULL ) ; ahash_request_set_crypt ( ahreq , sg , NULL , assoclen + ilen + 16 ) ; err = crypto_ahash_init ( ahreq ) ; if ( err ) goto out ; err = crypto_ahash_update ( ahreq ) ; if ( err ) goto out ; ilen = 16 - ( assoclen + ilen ) % 16 ; if ( ilen < 16 ) { memset ( idata , 0 , ilen ) ; sg_init_table ( sg , 2 ) ; sg_set_buf ( & sg [ 0 ] , idata , ilen ) ; if ( plain ) sg_chain ( sg , 2 , plain ) ; plain = sg ; cryptlen += ilen ; } ahash_request_set_crypt ( ahreq , plain , pctx -> odata , cryptlen ) ; err = crypto_ahash_finup ( ahreq ) ; out : return err ; }", ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata  ; int ilen
131,"CWE-399 static int ceph_x_decrypt ( struct ceph_crypto_key * secret ,  void * * p , void * end , void * obuf , size_t olen )  { struct ceph_x_encrypt_header head ; size_t head_len = sizeof ( head ) ; int len , ret ; len = ceph_decode_32 ( p ) ; if ( * p + len > end ) return - EINVAL ; dout ( ""ceph_x_decryptlen%d\\n"" , len ) ;  ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen ,  * p , len ) ; if ( ret ) return ret ; if ( head . struct_v != 1 || le64_to_cpu ( head . magic ) != CEPHX_ENC_MAGIC ) return - EPERM ; * p += len ; return olen ; }"," end , void *  len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; }  & head_len , *"
132,"CWE-476 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( mspack_memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( ""incorrectGUIDs"" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , ""WARNING;CHMversion>3"" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( ""contentsectionbeginsafterfilehasended"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( ""chunksizenotlargeenough"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( ""nochunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( ""morethan100,000chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( ""chunkslargerthanentirefile"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , ""WARNING;chunksizeisnotapoweroftwo"" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , ""WARNING;firstPMGLchunkisnotzero"" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( ""firstpmglchunkisafterlastpmglchunk"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( ""index_rootoutsidevalidrange"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , ""WARNING;PMGLquickrefareaistoosmall"" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , ""WARNING;PMGLquickrefareaistoolarge"" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ;  if ( name_len == 0 ) goto chunk_end ;  name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ;  READ_ENCINT ( length ) ;  if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , ""invalidsectionnumber\'%u\'."" , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { if ( mspack_memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { if ( mspack_memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . content = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { chm -> sec1 . control = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . spaninfo = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; } } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( ""chunkendedbeforeallentriescouldberead"" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }", goto chunk_end ;  name = p  ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue
133,"CWE-862 static int shm_create ( XShmSegmentInfo * shm , XImage * * ximg_ptr , int w , int h , char * name ) { XImage * xim ; static int reported_flip = 0 ; int db = 0 ; shm -> shmid = - 1 ; shm -> shmaddr = ( char * ) - 1 ; * ximg_ptr = NULL ; if ( nofb ) { return 1 ; } X_LOCK ; if ( ! using_shm || xform24to32 || raw_fb ) { xim = XCreateImage_wr ( dpy , default_visual , depth , ZPixmap , 0 , NULL , w , h , raw_fb ? 32 : BitmapPad ( dpy ) , 0 ) ; X_UNLOCK ; if ( xim == NULL ) { rfbErr ( ""XCreateImage(%s)failed.\\n"" , name ) ; if ( quiet ) { fprintf ( stderr , ""XCreateImage(%s)failed.\\n"" , name ) ; } return 0 ; } if ( db ) fprintf ( stderr , ""shm_createsimple%d%d\\t%p%s\\n"" , w , h , ( void * ) xim , name ) ; xim -> data = ( char * ) malloc ( xim -> bytes_per_line * xim -> height ) ; if ( xim -> data == NULL ) { rfbErr ( ""XCreateImage(%s)datamallocfailed.\\n"" , name ) ; if ( quiet ) { fprintf ( stderr , ""XCreateImage(%s)datamalloc"" ""failed.\\n"" , name ) ; } return 0 ; } if ( flip_byte_order ) { char * order = flip_ximage_byte_order ( xim ) ; if ( ! reported_flip && ! quiet ) { rfbLog ( ""ChangingXImagebyteorder"" ""to%s\\n"" , order ) ; reported_flip = 1 ; } } * ximg_ptr = xim ; return 1 ; } if ( ! dpy ) { X_UNLOCK ; return 0 ; } xim = XShmCreateImage_wr ( dpy , default_visual , depth , ZPixmap , NULL , shm , w , h ) ; if ( xim == NULL ) { rfbErr ( ""XShmCreateImage(%s)failed.\\n"" , name ) ; if ( quiet ) { fprintf ( stderr , ""XShmCreateImage(%s)failed.\\n"" , name ) ; } X_UNLOCK ; return 0 ; } * ximg_ptr = xim ; # if HAVE_XSHM shm -> shmid = shmget ( IPC_PRIVATE ,  xim -> bytes_per_line * xim -> height , IPC_CREAT | 0777 ) ;  if ( shm -> shmid == - 1 ) { rfbErr ( ""shmget(%s)failed.\\n"" , name ) ; rfbLogPerror ( ""shmget"" ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; X_UNLOCK ; return 0 ; } shm -> shmaddr = xim -> data = ( char * ) shmat ( shm -> shmid , 0 , 0 ) ; if ( shm -> shmaddr == ( char * ) - 1 ) { rfbErr ( ""shmat(%s)failed.\\n"" , name ) ; rfbLogPerror ( ""shmat"" ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; shmctl ( shm -> shmid , IPC_RMID , 0 ) ; shm -> shmid = - 1 ; X_UNLOCK ; return 0 ; } shm -> readOnly = False ; if ( ! XShmAttach_wr ( dpy , shm ) ) { rfbErr ( ""XShmAttach(%s)failed.\\n"" , name ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; shmdt ( shm -> shmaddr ) ; shm -> shmaddr = ( char * ) - 1 ; shmctl ( shm -> shmid , IPC_RMID , 0 ) ; shm -> shmid = - 1 ; X_UNLOCK ; return 0 ; } # endif X_UNLOCK ; return 1 ; }"," , IPC_CREAT | 0600  ) ; if"
134,"CWE-264 int perf_event_refresh ( struct perf_event * event , int refresh ) {  if ( event -> attr . inherit || ! is_sampling_event ( event ) )  return - EINVAL ; atomic_add ( refresh , & event -> event_limit ) ; perf_event_enable ( event ) ;  return 0 ;  }"," refresh ) { struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock  ( event )  event ) ; ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret  ; } "
135,"CWE-269 static int pppol2tp_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; struct pppol2tp_session * ps ; int val ; int err ; if ( level != SOL_PPPOL2TP )  return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ;  if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_setsockopt ( sk , tunnel , optname , val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_setsockopt ( sk , session , optname , val ) ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }", SOL_PPPOL2TP ) return - EINVAL  ; if (
136,CWE-119 static void zero_stats ( FIRSTPASS_STATS * section ) {  section -> frame = 0.0 ;  section -> intra_error = 0.0 ; section -> coded_error = 0.0 ;  section -> sr_coded_error = 0.0 ;  section -> ssim_weighted_pred_err = 0.0 ; section -> pcnt_inter = 0.0 ; section -> pcnt_motion = 0.0 ; section -> pcnt_second_ref = 0.0 ;  section -> pcnt_neutral = 0.0 ;  section -> MVr = 0.0 ; section -> mvr_abs = 0.0 ; section -> MVc = 0.0 ; section -> mvc_abs = 0.0 ; section -> MVrv = 0.0 ; section -> MVcv = 0.0 ; section -> mv_in_out_count = 0.0 ; section -> new_mv_count = 0.0 ; section -> count = 0.0 ; section -> duration = 1.0 ; section -> spatial_layer_id = 0 ; }, section -> frame = 0.0 ; section -> weight  section -> sr_coded_error  = 0.0 ;  section -> pcnt_neutral = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols
137,"CWE-863 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg , struct bpf_reg_state * dst_reg , struct bpf_insn_aux_data * tmp_aux , const bool commit_window ) { struct bpf_insn_aux_data * aux = commit_window ? cur_aux ( env ) : tmp_aux ; struct bpf_verifier_state * vstate = env -> cur_state ;  bool off_is_neg = off_reg -> smin_value < 0 ;  bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; int err ; if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ; if ( vstate -> speculative ) goto do_sim ; err = retrieve_ptr_limit ( ptr_reg , off_reg , & alu_limit , opcode ) ; if ( err < 0 ) return err ; if ( commit_window ) { alu_state = tmp_aux -> alu_state ; alu_limit = abs ( tmp_aux -> alu_limit - alu_limit ) ; } else {  alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ;  alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; } err = update_alu_sanitation_state ( aux , alu_state , alu_limit ) ; if ( err < 0 ) return err ; do_sim : if ( commit_window ) return 0 ; if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg && ret ) * dst_reg = tmp ; return ! ret ? REASON_STACK : 0 ; }", cur_state ; bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool  off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE
138,"CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \'\\""\' ) { * ep = str ; return 0 ; }  while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ;  out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\b' ; break ; case 'f' : * ptr2 ++ = '\\f' ; break ; case 'n' : * ptr2 ++ = '\\n' ; break ; case 'r' : * ptr2 ++ = '\\r' ; break ; case 't' : * ptr2 ++ = '\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) { * ep = str ; return 0 ; } if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } if ( ptr [ 1 ] != '\\\\' || ptr [ 2 ] != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 ( ptr + 3 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) { * ep = str ; return 0 ; } uc = 0x10000 + ( ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ptr ++ ; } } * ptr2 = 0 ; if ( * ptr == \'\\""\' ) ptr ++ ; return ptr ; }", ++ len ) {  == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } }  out = (
139,"CWE-191 static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - ECONNRESET : case - ENOENT : case - ESHUTDOWN : dev_dbg ( & urb -> dev -> dev , ""%s-urbshuttingdownwithstatus:%d\\n"" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , ""%s-nonzeroreadbulkstatusreceived:%d\\n"" , __func__ , status ) ; } if ( status == - EPIPE ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , ""%s-stoppingread!\\n"" , __func__ ) ; return ; } port_number = edge_port -> port -> port_number ;  if ( edge_port -> lsr_event ) {  edge_port -> lsr_event = 0 ; dev_dbg ( dev , ""%s=====Port%uLSRStatus=%02x,Data=%02x======\\n"" , __func__ , port_number , edge_port -> lsr_mask , * data ) ; handle_new_lsr ( edge_port , 1 , edge_port -> lsr_mask , * data ) ; -- urb -> actual_length ; ++ data ; } if ( urb -> actual_length ) { usb_serial_debug_data ( dev , __func__ , urb -> actual_length , data ) ; if ( edge_port -> close_pending ) dev_dbg ( dev , ""%s-closepending,droppingdataonthefloor\\n"" , __func__ ) ; else edge_tty_recv ( edge_port -> port , data , urb -> actual_length ) ; edge_port -> port -> icount . rx += urb -> actual_length ; } exit : spin_lock ( & edge_port -> ep_lock ) ; if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_RUNNING ) retval = usb_submit_urb ( urb , GFP_ATOMIC ) ; else if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_STOPPING ) edge_port -> ep_read_urb_state = EDGE_READ_URB_STOPPED ; spin_unlock ( & edge_port -> ep_lock ) ; if ( retval ) dev_err ( dev , ""%s-usb_submit_urbfailedwithresult%d\\n"" , __func__ , retval ) ; }", ; if ( urb -> actual_length > 0 &&
140,"CWE-400 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ;  Rd_WP_DWORD ( image , & Rec . RecordLength ) ;  if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }"," Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"""
141,"CWE-000 static void dispatch_cmd ( conn c ) { int r , i , timeout = - 1 ; size_t z ; unsigned int count ; job j ; unsigned char type ; char * size_buf , * delay_buf , * ttr_buf , * pri_buf , * end_buf , * name ; unsigned int pri , body_size ; usec delay , ttr ; uint64_t id ; tube t = NULL ; c -> cmd [ c -> cmd_len - 2 ] = '\\0' ; if ( strlen ( c -> cmd ) != c -> cmd_len - 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } type = which_cmd ( c ) ; dprintf ( ""got%scommand:\\""%s\\""\\n"" , op_names [ ( int ) type ] , c -> cmd ) ; switch ( type ) { case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , & ttr_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_ttr ( & ttr , ttr_buf , & size_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; errno = 0 ; body_size = strtoul ( size_buf , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; if ( body_size > job_data_size_limit ) {  return reply_msg ( c , MSG_JOB_TOO_BIG ) ;  } if ( end_buf [ 0 ] != '\\0' ) return reply_msg ( c , MSG_BAD_FORMAT ) ; conn_set_producer ( c ) ; c -> in_job = make_job ( pri , delay , ttr ? : 1 , body_size + 2 , c -> use ) ; if ( ! c -> in_job ) { twarnx ( ""servererror:"" MSG_OUT_OF_MEMORY ) ; return skip ( c , body_size + 2 , MSG_OUT_OF_MEMORY ) ; } fill_extra_data ( c ) ; maybe_enqueue_incoming_job ( c ) ; break ; case OP_PEEK_READY : if ( c -> cmd_len != CMD_PEEK_READY_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( pq_peek ( & c -> use -> ready ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEK_DELAYED : if ( c -> cmd_len != CMD_PEEK_DELAYED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( pq_peek ( & c -> use -> delay ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEK_BURIED : if ( c -> cmd_len != CMD_PEEK_BURIED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( buried_job_p ( c -> use ) ? j = c -> use -> buried . next : NULL ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEKJOB : errno = 0 ; id = strtoull ( c -> cmd + CMD_PEEKJOB_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = job_copy ( peek_job ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_RESERVE_TIMEOUT : errno = 0 ; timeout = strtol ( c -> cmd + CMD_RESERVE_TIMEOUT_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; case OP_RESERVE : if ( type == OP_RESERVE && c -> cmd_len != CMD_RESERVE_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; conn_set_worker ( c ) ; if ( conn_has_close_deadline ( c ) && ! conn_ready ( c ) ) { return reply_msg ( c , MSG_DEADLINE_SOON ) ; } wait_for_job ( c , timeout ) ; process_queue ( ) ; break ; case OP_DELETE : errno = 0 ; id = strtoull ( c -> cmd + CMD_DELETE_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = job_find ( id ) ; j = remove_reserved_job ( c , j ) ? : remove_ready_job ( j ) ? : remove_buried_job ( j ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; j -> state = JOB_STATE_INVALID ; r = binlog_write_job ( j ) ; job_free ( j ) ; if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; reply ( c , MSG_DELETED , MSG_DELETED_LEN , STATE_SENDWORD ) ; break ; case OP_RELEASE : errno = 0 ; id = strtoull ( c -> cmd + CMD_RELEASE_LEN , & pri_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_pri ( & pri , pri_buf , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = remove_reserved_job ( c , job_find ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; if ( delay ) { z = binlog_reserve_space_update ( j ) ; if ( ! z ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; j -> reserved_binlog_space += z ; } j -> pri = pri ; j -> delay = delay ; j -> release_ct ++ ; r = enqueue_job ( j , delay , ! ! delay ) ; if ( r < 0 ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; if ( r == 1 ) { return reply ( c , MSG_RELEASED , MSG_RELEASED_LEN , STATE_SENDWORD ) ; } bury_job ( j , 0 ) ; reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; break ; case OP_BURY : errno = 0 ; id = strtoull ( c -> cmd + CMD_BURY_LEN , & pri_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_pri ( & pri , pri_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = remove_reserved_job ( c , job_find ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; j -> pri = pri ; r = bury_job ( j , 1 ) ; if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; break ; case OP_KICK : errno = 0 ; count = strtoul ( c -> cmd + CMD_KICK_LEN , & end_buf , 10 ) ; if ( end_buf == c -> cmd + CMD_KICK_LEN ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; i = kick_jobs ( c -> use , count ) ; return reply_line ( c , STATE_SENDWORD , ""KICKED%u\\r\\n"" , i ) ; case OP_TOUCH : errno = 0 ; id = strtoull ( c -> cmd + CMD_TOUCH_LEN , & end_buf , 10 ) ; if ( errno ) return twarn ( ""strtoull"" ) , reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = touch_job ( c , job_find ( id ) ) ; if ( j ) { reply ( c , MSG_TOUCHED , MSG_TOUCHED_LEN , STATE_SENDWORD ) ; } else { return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; } break ; case OP_STATS : if ( c -> cmd_len != CMD_STATS_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_stats ( c , fmt_stats , NULL ) ; break ; case OP_JOBSTATS : errno = 0 ; id = strtoull ( c -> cmd + CMD_JOBSTATS_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = peek_job ( id ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; if ( ! j -> tube ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; do_stats ( c , ( fmt_fn ) fmt_job_stats , j ) ; break ; case OP_STATS_TUBE : name = c -> cmd + CMD_STATS_TUBE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; t = tube_find ( name ) ; if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; do_stats ( c , ( fmt_fn ) fmt_stats_tube , t ) ; t = NULL ; break ; case OP_LIST_TUBES : if ( c -> cmd_len != CMD_LIST_TUBES_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_list_tubes ( c , & tubes ) ; break ; case OP_LIST_TUBE_USED : if ( c -> cmd_len != CMD_LIST_TUBE_USED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; reply_line ( c , STATE_SENDWORD , ""USING%s\\r\\n"" , c -> use -> name ) ; break ; case OP_LIST_TUBES_WATCHED : if ( c -> cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_list_tubes ( c , & c -> watch ) ; break ; case OP_USE : name = c -> cmd + CMD_USE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; c -> use -> using_ct -- ; TUBE_ASSIGN ( c -> use , t ) ; TUBE_ASSIGN ( t , NULL ) ; c -> use -> using_ct ++ ; reply_line ( c , STATE_SENDWORD , ""USING%s\\r\\n"" , c -> use -> name ) ; break ; case OP_WATCH : name = c -> cmd + CMD_WATCH_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; r = 1 ; if ( ! ms_contains ( & c -> watch , t ) ) r = ms_append ( & c -> watch , t ) ; TUBE_ASSIGN ( t , NULL ) ; if ( ! r ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; reply_line ( c , STATE_SENDWORD , ""WATCHING%d\\r\\n"" , c -> watch . used ) ; break ; case OP_IGNORE : name = c -> cmd + CMD_IGNORE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; t = NULL ; for ( i = 0 ; i < c -> watch . used ; i ++ ) { t = c -> watch . items [ i ] ; if ( strncmp ( t -> name , name , MAX_TUBE_NAME_LEN ) == 0 ) break ; t = NULL ; } if ( t && c -> watch . used < 2 ) return reply_msg ( c , MSG_NOT_IGNORED ) ; if ( t ) ms_remove ( & c -> watch , t ) ; t = NULL ; reply_line ( c , STATE_SENDWORD , ""WATCHING%d\\r\\n"" , c -> watch . used ) ; break ; case OP_QUIT : conn_close ( c ) ; break ; case OP_PAUSE_TUBE : op_ct [ type ] ++ ; r = read_tube_name ( & name , c -> cmd + CMD_PAUSE_TUBE_LEN , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; * delay_buf = '\\0' ; t = tube_find ( name ) ; if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; t -> deadline_at = now_usec ( ) + delay ; t -> pause = delay ; t -> stat . pause_ct ++ ; set_main_delay_timeout ( ) ; reply_line ( c , STATE_SENDWORD , ""PAUSED\\r\\n"" ) ; break ; default : return reply_msg ( c , MSG_UNKNOWN_COMMAND ) ; } }"," ) { return skip ( c , body_size + 2  , MSG_JOB_TOO_BIG )"
142,"CWE-200 char * url_decode_r ( char * to , char * url , size_t size ) { char * s = url , * d = to , * e = & to [ size - 1 ] ; while ( * s && d < e ) { if ( unlikely ( * s == '%' ) ) { if ( likely ( s [ 1 ] && s [ 2 ] ) ) {  * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ;  s += 2 ; } } else if ( unlikely ( * s == '+' ) ) * d ++ = '' ; else * d ++ = * s ; s ++ ; } * d = '\\0' ; return to ; }", ) ) { char t  = from_hex (  [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : ''
143,"CWE-399 static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , ""Setfirstptsto(in:%"" PRId64 ""out:%"" PRId64 "")\\n"" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , ""Discardinginitialframe(s)withno"" ""timestamp.\\n"" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; }  if ( buf -> pts == AV_NOPTS_VALUE ) {  return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , ""Dropping%dframe(s).\\n"" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , ""Duplicatingframe.\\n"" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }", pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
144,"CWE-787 opj_image_t * pgxtoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f = NULL ; int w , h , prec ; int i , numcomps , max ; OPJ_COLOR_SPACE color_space ; opj_image_cmptparm_t cmptparm ; opj_image_t * image = NULL ; int adjustS , ushift , dshift , force8 ; char endian1 , endian2 , sign ; char signtmp [ 32 ] ; char temp [ 32 ] ; int bigendian ; opj_image_comp_t * comp = NULL ; numcomps = 1 ; color_space = OPJ_CLRSPC_GRAY ; memset ( & cmptparm , 0 , sizeof ( opj_image_cmptparm_t ) ) ; max = 0 ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failedtoopen%sforreading!\\n"" , filename ) ; return NULL ; } fseek ( f , 0 , SEEK_SET ) ;  if ( fscanf ( f , ""PG%[\\t]%c%c%[\\t+-]%d%[\\t]%d%[\\t]%d"" , temp , & endian1 ,  & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose ( f ) ; fprintf ( stderr , ""ERROR:Failedtoreadtherightnumberofelementfromthefscanf()function!\\n"" ) ; return NULL ; } i = 0 ; sign = '+' ; while ( signtmp [ i ] != '\\0' ) { if ( signtmp [ i ] == '-' ) { sign = '-' ; } i ++ ; } fgetc ( f ) ; if ( endian1 == 'M' && endian2 == 'L' ) { bigendian = 1 ; } else if ( endian2 == 'M' && endian1 == 'L' ) { bigendian = 0 ; } else { fclose ( f ) ; fprintf ( stderr , ""Badpgxheader,pleasecheckinputfile\\n"" ) ; return NULL ; } cmptparm . x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; cmptparm . y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; cmptparm . w = ! cmptparm . x0 ? ( OPJ_UINT32 ) ( ( w - 1 ) * parameters -> subsampling_dx + 1 ) : cmptparm . x0 + ( OPJ_UINT32 ) ( w - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1 ; cmptparm . h = ! cmptparm . y0 ? ( OPJ_UINT32 ) ( ( h - 1 ) * parameters -> subsampling_dy + 1 ) : cmptparm . y0 + ( OPJ_UINT32 ) ( h - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1 ; if ( sign == '-' ) { cmptparm . sgnd = 1 ; } else { cmptparm . sgnd = 0 ; } if ( prec < 8 ) { force8 = 1 ; ushift = 8 - prec ; dshift = prec - ushift ; if ( cmptparm . sgnd ) { adjustS = ( 1 << ( prec - 1 ) ) ; } else { adjustS = 0 ; } cmptparm . sgnd = 0 ; prec = 8 ; } else { ushift = dshift = force8 = adjustS = 0 ; } cmptparm . prec = ( OPJ_UINT32 ) prec ; cmptparm . bpp = ( OPJ_UINT32 ) prec ; cmptparm . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = cmptparm . x0 ; image -> y0 = cmptparm . x0 ; image -> x1 = cmptparm . w ; image -> y1 = cmptparm . h ; comp = & image -> comps [ 0 ] ; for ( i = 0 ; i < w * h ; i ++ ) { int v ; if ( force8 ) { v = readuchar ( f ) + adjustS ; v = ( v << ushift ) + ( v >> dshift ) ; comp -> data [ i ] = ( unsigned char ) v ; if ( v > max ) { max = v ; } continue ; } if ( comp -> prec == 8 ) { if ( ! comp -> sgnd ) { v = readuchar ( f ) ; } else { v = ( char ) readuchar ( f ) ; } } else if ( comp -> prec <= 16 ) { if ( ! comp -> sgnd ) { v = readushort ( f , bigendian ) ; } else { v = ( short ) readushort ( f , bigendian ) ; } } else { if ( ! comp -> sgnd ) { v = ( int ) readuint ( f , bigendian ) ; } else { v = ( int ) readuint ( f , bigendian ) ; } } if ( v > max ) { max = v ; } comp -> data [ i ] = v ; } fclose ( f ) ; comp -> bpp = ( OPJ_UINT32 ) int_floorlog2 ( max ) + 1 ; return image ; }"," ( f , ""PG%31[\\t]%c%c%31[\\t+-]%d%31[\\t]%d%31[\\t]%d""  , temp ,"
145,CWE-476 static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) {  struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ;  struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; }, tfm ) {  return 0 ;
146,"CWE-119 static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) { AVCodecParameters * par = stream -> codecpar ; if ( ! strcmp ( attr , ""packetization-mode"" ) ) { av_log ( s , AV_LOG_DEBUG , ""RTPPacketizationMode:%d\\n"" , atoi ( value ) ) ; h264_data -> packetization_mode = atoi ( value ) ; if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , ""InterleavedRTPmodeisnotsupportedyet.\\n"" ) ; } else if ( ! strcmp ( attr , ""profile-level-id"" ) ) { if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , ""sprop-parameter-sets"" ) ) { int ret ;  if ( value [ strlen ( value ) - 1 ] == ',' ) {  av_log ( s , AV_LOG_WARNING , ""MissingPPSinsprop-parameter-sets,ignoring\\n"" ) ; return 0 ; } par -> extradata_size = 0 ; av_freep ( & par -> extradata ) ; ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ; av_log ( s , AV_LOG_DEBUG , ""Extradatasetto%p(size:%d)\\n"" , par -> extradata , par -> extradata_size ) ; return ret ; } return 0 ; }", ; if ( * value == 0 ||
147,"CWE-732 static M_fs_error_t M_fs_copy_file ( const char * path_old , const char * path_new , M_fs_file_mode_t mode , M_fs_progress_cb_t cb , M_fs_progress_flags_t progress_flags , M_fs_progress_t * progress , const M_fs_perms_t * perms ) { M_fs_file_t * fd_old ; M_fs_file_t * fd_new ; M_fs_info_t * info = NULL ; unsigned char temp [ M_FS_BUF_SIZE ] ; size_t read_len ; size_t wrote_len ; size_t wrote_total = 0 ; size_t offset ; M_fs_error_t res ;  if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) {  res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } } res = M_fs_file_open ( & fd_old , path_old , M_FS_BUF_SIZE , M_FS_FILE_MODE_READ | M_FS_FILE_MODE_NOCREATE , NULL ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } if ( perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS ) { res = M_fs_info_file ( & info , fd_old , M_FS_PATH_INFO_FLAGS_NONE ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } perms = M_fs_info_get_perms ( info ) ; } res = M_fs_file_open ( & fd_new , path_new , M_FS_BUF_SIZE , M_FS_FILE_MODE_WRITE | M_FS_FILE_MODE_OVERWRITE , perms ) ; M_fs_info_destroy ( info ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } while ( ( res = M_fs_file_read ( fd_old , temp , sizeof ( temp ) , & read_len , M_FS_FILE_RW_NORMAL ) ) == M_FS_ERROR_SUCCESS && read_len != 0 ) { offset = 0 ; while ( offset < read_len ) { res = M_fs_file_write ( fd_new , temp + offset , read_len - offset , & wrote_len , M_FS_FILE_RW_NORMAL ) ; offset += wrote_len ; wrote_total += wrote_len ; if ( cb ) { M_fs_progress_set_result ( progress , res ) ; if ( progress_flags & M_FS_PROGRESS_SIZE_TOTAL ) { M_fs_progress_set_size_total_progess ( progress , M_fs_progress_get_size_total_progess ( progress ) + wrote_len ) ; } if ( progress_flags & M_FS_PROGRESS_SIZE_CUR ) { M_fs_progress_set_size_current_progress ( progress , wrote_total ) ; } if ( progress_flags & M_FS_PROGRESS_COUNT ) { M_fs_progress_set_count ( progress , M_fs_progress_get_count ( progress ) + 1 ) ; } if ( ! cb ( progress ) ) { res = M_FS_ERROR_CANCELED ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } M_fs_file_close ( fd_old ) ; M_fs_file_close ( fd_new ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } return M_FS_ERROR_SUCCESS ; }", M_fs_error_t res ;  res = M_fs_file_open
148,"CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '' ; t1_getline ( ) ;  strcat ( t1_buf_array , t1_line_array ) ;  strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }"," ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;  t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE"
149,"CWE-264 int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {  return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;  }"," arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ;"
150,"CWE-415 static int muscle_list_files ( sc_card_t * card , u8 * buf , size_t bufLen ) { muscle_private_t * priv = MUSCLE_DATA ( card ) ; mscfs_t * fs = priv -> fs ; int x ; int count = 0 ; mscfs_check_cache ( priv -> fs ) ; for ( x = 0 ; x < fs -> cache . size ; x ++ ) { u8 * oid = fs -> cache . array [ x ] . objectId . id ;  sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL ,  ""FILE:%02X%02X%02X%02X\\n"" , oid [ 0 ] , oid [ 1 ] , oid [ 2 ] , oid [ 3 ] ) ; if ( 0 == memcmp ( fs -> currentPath , oid , 2 ) ) { buf [ 0 ] = oid [ 2 ] ; buf [ 1 ] = oid [ 3 ] ; if ( buf [ 0 ] == 0x00 && buf [ 1 ] == 0x00 ) continue ; buf += 2 ; count += 2 ;  }  } return count ; }", . id ; if ( bufLen < 2 ) break ;  += 2 ; bufLen -= 2 ;
151,"CWE-119 static int sc_pkcs15emu_sc_hsm_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; sc_hsm_private_data_t * priv = ( sc_hsm_private_data_t * ) card -> drv_data ; sc_file_t * file = NULL ; sc_path_t path ; u8 filelist [ MAX_EXT_APDU_LENGTH ] ; int filelistlength ; int r , i ; sc_cvc_t devcert ; struct sc_app_info * appinfo ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; struct sc_pin_cmd_data pindata ; u8 efbin [ 1024 ] ; u8 * ptr ; size_t len ; LOG_FUNC_CALLED ( card -> ctx ) ; appinfo = calloc ( 1 , sizeof ( struct sc_app_info ) ) ; if ( appinfo == NULL ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } appinfo -> aid = sc_hsm_aid ; appinfo -> ddo . aid = sc_hsm_aid ; p15card -> app = appinfo ; sc_path_set ( & path , SC_PATH_TYPE_DF_NAME , sc_hsm_aid . value , sc_hsm_aid . len , 0 , 0 ) ; r = sc_select_file ( card , & path , & file ) ; LOG_TEST_RET ( card -> ctx , r , ""CouldnotselectSmartCard-HSMapplication"" ) ; p15card -> card -> version . hw_major = 24 ; p15card -> card -> version . hw_minor = 13 ; if ( file && file -> prop_attr && file -> prop_attr_len >= 2 ) { p15card -> card -> version . fw_major = file -> prop_attr [ file -> prop_attr_len - 2 ] ; p15card -> card -> version . fw_minor = file -> prop_attr [ file -> prop_attr_len - 1 ] ; } sc_file_free ( file ) ; if ( priv -> EF_C_DevAut && priv -> EF_C_DevAut_len ) { ptr = priv -> EF_C_DevAut ; len = priv -> EF_C_DevAut_len ; } else { len = sizeof efbin ; r = read_file ( p15card , ( u8 * ) ""\\x2F\\x02"" , efbin , & len , 1 ) ; LOG_TEST_RET ( card -> ctx , r , ""SkippingoptionalEF.C_DevAut"" ) ;  ptr = realloc ( priv -> EF_C_DevAut , len ) ;  if ( ptr ) { memcpy ( ptr , efbin , len ) ; priv -> EF_C_DevAut = ptr ;  priv -> EF_C_DevAut_len = len ;  } ptr = efbin ; } memset ( & devcert , 0 , sizeof ( devcert ) ) ; r = sc_pkcs15emu_sc_hsm_decode_cvc ( p15card , ( const u8 * * ) & ptr , & len , & devcert ) ; LOG_TEST_RET ( card -> ctx , r , ""CouldnotdecodeEF.C_DevAut"" ) ; sc_pkcs15emu_sc_hsm_read_tokeninfo ( p15card ) ; if ( p15card -> tokeninfo -> label == NULL ) { if ( p15card -> card -> type == SC_CARD_TYPE_SC_HSM_GOID || p15card -> card -> type == SC_CARD_TYPE_SC_HSM_SOC ) { p15card -> tokeninfo -> label = strdup ( ""GoID"" ) ; } else { p15card -> tokeninfo -> label = strdup ( ""SmartCard-HSM"" ) ; } if ( p15card -> tokeninfo -> label == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } if ( ( p15card -> tokeninfo -> manufacturer_id != NULL ) && ! strcmp ( ""(unknown)"" , p15card -> tokeninfo -> manufacturer_id ) ) { free ( p15card -> tokeninfo -> manufacturer_id ) ; p15card -> tokeninfo -> manufacturer_id = NULL ; } if ( p15card -> tokeninfo -> manufacturer_id == NULL ) { if ( p15card -> card -> type == SC_CARD_TYPE_SC_HSM_GOID || p15card -> card -> type == SC_CARD_TYPE_SC_HSM_SOC ) { p15card -> tokeninfo -> manufacturer_id = strdup ( ""BundesdruckereiGmbH"" ) ; } else { p15card -> tokeninfo -> manufacturer_id = strdup ( ""www.CardContact.de"" ) ; } if ( p15card -> tokeninfo -> manufacturer_id == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } appinfo -> label = strdup ( p15card -> tokeninfo -> label ) ; if ( appinfo -> label == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; len = strnlen ( devcert . chr , sizeof devcert . chr ) ; assert ( len >= 8 ) ; len -= 5 ; p15card -> tokeninfo -> serial_number = calloc ( len + 1 , 1 ) ; if ( p15card -> tokeninfo -> serial_number == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; memcpy ( p15card -> tokeninfo -> serial_number , devcert . chr , len ) ; * ( p15card -> tokeninfo -> serial_number + len ) = 0 ; sc_hsm_set_serialnr ( card , p15card -> tokeninfo -> serial_number ) ; sc_pkcs15emu_sc_hsm_free_cvc ( & devcert ) ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = 1 ; pin_info . path . aid = sc_hsm_aid ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = 0x81 ; pin_info . attrs . pin . flags = SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = 6 ; pin_info . attrs . pin . stored_length = 0 ; pin_info . attrs . pin . max_length = 15 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = 3 ; pin_info . max_tries = 3 ; pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 2 ; strlcpy ( pin_obj . label , ""UserPIN"" , sizeof ( pin_obj . label ) ) ; pin_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE | SC_PKCS15_CO_FLAG_MODIFIABLE ; r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) LOG_FUNC_RETURN ( card -> ctx , r ) ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = 2 ; pin_info . path . aid = sc_hsm_aid ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = 0x88 ; pin_info . attrs . pin . flags = SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED | SC_PKCS15_PIN_FLAG_SO_PIN ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_BCD ; pin_info . attrs . pin . min_length = 16 ; pin_info . attrs . pin . stored_length = 0 ; pin_info . attrs . pin . max_length = 16 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = 15 ; pin_info . max_tries = 15 ; strlcpy ( pin_obj . label , ""SOPIN"" , sizeof ( pin_obj . label ) ) ; pin_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) LOG_FUNC_RETURN ( card -> ctx , r ) ; if ( card -> type == SC_CARD_TYPE_SC_HSM_SOC || card -> type == SC_CARD_TYPE_SC_HSM_GOID ) { r = SC_SUCCESS ; } else { memset ( & pindata , 0 , sizeof ( pindata ) ) ; pindata . cmd = SC_PIN_CMD_GET_INFO ; pindata . pin_type = SC_AC_CHV ; pindata . pin_reference = 0x85 ; r = sc_pin_cmd ( card , & pindata , NULL ) ; } if ( r == SC_ERROR_DATA_OBJECT_NOT_FOUND ) { memset ( & pindata , 0 , sizeof ( pindata ) ) ; pindata . cmd = SC_PIN_CMD_GET_INFO ; pindata . pin_type = SC_AC_CHV ; pindata . pin_reference = 0x86 ; r = sc_pin_cmd ( card , & pindata , NULL ) ; } if ( ( r != SC_ERROR_DATA_OBJECT_NOT_FOUND ) && ( r != SC_ERROR_INCORRECT_PARAMETERS ) ) card -> caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH ; filelistlength = sc_list_files ( card , filelist , sizeof ( filelist ) ) ; LOG_TEST_RET ( card -> ctx , filelistlength , ""Couldnotenumeratefileandkeyidentifier"" ) ; for ( i = 0 ; i < filelistlength ; i += 2 ) { switch ( filelist [ i ] ) { case KEY_PREFIX : r = sc_pkcs15emu_sc_hsm_add_prkd ( p15card , filelist [ i + 1 ] ) ; break ; case DCOD_PREFIX : r = sc_pkcs15emu_sc_hsm_add_dcod ( p15card , filelist [ i + 1 ] ) ; break ; case CD_PREFIX : r = sc_pkcs15emu_sc_hsm_add_cd ( p15card , filelist [ i + 1 ] ) ; break ; } if ( r != SC_SUCCESS ) { sc_log ( card -> ctx , ""Error%daddingelementstoframework"" , r ) ; } } LOG_FUNC_RETURN ( card -> ctx , SC_SUCCESS ) ; }"," ""SkippingoptionalEF.C_DevAut"" ) ; if ( len > 0 ) {  = len ; }"
152,"CWE-119  static void  swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ;  horAcc16 ( tif , cp0 , cc ) ;  }",   static int  swabHorAcc16 ( TIFF  wc ) ; return
153,"CWE-119 void vp9_rc_get_second_pass_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ;  struct twopass_rc * const twopass = & cpi -> twopass ;  int frames_left ; FIRSTPASS_STATS this_frame ;  FIRSTPASS_STATS this_frame_copy ;   double this_frame_intra_error ;  double this_frame_coded_error ; int target ; LAYER_CONTEXT * lc = NULL ;  int is_spatial_svc = ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) ;  if ( is_spatial_svc ) {  lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ;  frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count -  cm -> current_video_frame ) ;  } if ( ! twopass -> stats_in ) return ; if ( cpi -> refresh_alt_ref_frame ) { cm -> frame_type = INTER_FRAME ; vp9_rc_set_frame_target ( cpi , twopass -> gf_bits ) ; return ; } vp9_clear_system_state ( ) ; if ( is_spatial_svc && twopass -> kf_intra_err_min == 0 ) { twopass -> kf_intra_err_min = KF_MB_INTRA_MIN * cpi -> common . MBs ; twopass -> gf_intra_err_min = GF_MB_INTRA_MIN * cpi -> common . MBs ; } if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( is_spatial_svc && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const int tmp_q = vp9_twopass_worst_quality ( cpi , & twopass -> total_left_stats , section_target_bandwidth ) ; twopass -> active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q ) ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; this_frame_intra_error = this_frame . intra_error ; this_frame_coded_error = this_frame . coded_error ; if ( rc -> frames_to_key == 0 || ( cm -> frame_flags & FRAMEFLAGS_KEY ) ) { this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame_copy ) ; if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 && cpi -> svc . spatial_layer_id > 0 ) { cm -> frame_type = INTER_FRAME ; } } else { cm -> frame_type = INTER_FRAME ; }  if ( rc -> frames_till_gf_update_due == 0 ) {  this_frame_copy = this_frame ; # if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) { define_fixed_arf_period ( cpi ) ; } else { # endif define_gf_group ( cpi , & this_frame_copy ) ; # if CONFIG_MULTIPLE_ARF } # endif if ( twopass -> gf_zeromotion_pct > 995 ) { if ( ! cm -> show_frame ) cpi -> allow_encode_breakout = ENCODE_BREAKOUT_DISABLED ; else cpi -> allow_encode_breakout = ENCODE_BREAKOUT_LIMITED ; } rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; cpi -> refresh_golden_frame = 1 ; } else { this_frame_copy = this_frame ; assign_std_frame_bits ( cpi , & this_frame_copy ) ; } twopass -> this_iiratio = ( int ) ( this_frame_intra_error / DOUBLE_DIVIDE_CHECK ( this_frame_coded_error ) ) ; { FIRSTPASS_STATS next_frame ; if ( lookup_next_frame_stats ( twopass , & next_frame ) != EOF ) { twopass -> next_iiratio = ( int ) ( next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; } } if ( cpi -> common . frame_type == KEY_FRAME ) target = vp9_rc_clamp_iframe_target_size ( cpi , rc -> this_frame_target ) ; else target = vp9_rc_clamp_pframe_target_size ( cpi , rc -> this_frame_target ) ; vp9_rc_set_frame_target ( cpi , target ) ; subtract_stats ( & twopass -> total_left_stats , & this_frame ) ; }"," -> rc ; TWO_PASS  * const twopass  cpi -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group  FIRSTPASS_STATS this_frame ; int target_rate ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; if ( lc != NULL ) { frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count - cm -> current_video_frame ) ; } if ( ! twopass -> stats_in ) return ; if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { int target_rate ; configure_buffer_updates ( cpi ) ; target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; cm -> frame_type = INTER_FRAME ; if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } } if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } return ; } vpx_clear_system_state ( ) ; if ( cpi -> oxcf . rc_mode == VPX_Q ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const double section_length = twopass -> total_left_stats . count ; const double section_error = twopass -> total_left_stats . coded_error / section_length ; const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ; const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ; const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; twopass -> active_worst_quality = tmp_q ; twopass -> baseline_active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> last_q [ INTER_FRAME ] = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; else twopass -> fr_content_type = FC_NORMAL ; if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) {  FIRSTPASS_STATS this_frame_copy ; this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame ) ; this_frame = this_frame_copy ; } else { cm -> frame_type = INTER_FRAME ; } if ( lc != NULL ) { if (  cpi -> svc  -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; lc -> frames_from_key_frame = 0 ; cpi -> svc . encode_intra_empty_frame = 1 ; } } else { cm -> frame_type = INTER_FRAME ; lc -> is_key_frame =  cpi -> svc  . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; lc -> frames_from_key_frame = 0 ; } } } if ( rc -> frames_till_gf_update_due == 0 ) { define_gf_group ( cpi , & this_frame ) ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ; # if ARF_STATS_OUTPUT { FILE * fpfile ; fpfile = fopen ( ""arf.stt"" , ""a"" ) ; ++ arf_count ; fprintf ( fpfile , ""%10d%10ld%10d%10d%10ld\\n"" ,  cm -> current_video_frame  cm -> current_video_frame ,  rc -> frames_till_gf_update_due  rc -> frames_till_gf_update_due , rc -> kf_boost , arf_count , rc -> gfu_boost ) ; fclose ( fpfile ) ; } # endif } configure_buffer_updates ( cpi ) ; if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; if ( cpi -> common . frame_type == KEY_FRAME ) target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) ; else target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; { const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; twopass -> mb_av_energy = log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; }  subtract_stats ( &"
154,"CWE-908 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ;  buf = g_malloc ( size ) ;  if ( object ) { g_signal_connect ( object , ""postclose"" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }", ; buf = g_malloc0  ( size )
155,"CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } }  IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;  p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ;  next_pixel = MagickFalse ;  displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }", ( code ) \\\n{  if ( bits  ) ; } \\\n}  IndexPacket index ;  ++ ) { next_pixel = MagickFalse ; displacement = 1 ;  -= MaxHashTable ; if ( k < 0 ) continue  ; if (
156,"CWE-362 static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ;  if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA )  && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ;  switch ( ctxt -> mode ) {  case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ;  break ;  case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ;  cs_sel = ( u16 ) msr_data ;  cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ;  ss_sel &= ~ SELECTOR_RPL_MASK ;   if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) {  cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_EIP , & msr_data ) ;  ctxt -> _eip = msr_data ;  ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ;  * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ;  return X86EMUL_CONTINUE ; }", ctxt -> mode != X86EMUL_MODE_PROT64  ) && (  msr_data ) ;  if ( (  0 ) ;  ctxt -> eflags  u16 ) msr_data &  ~ SELECTOR_RPL_MASK ;  + 8 ; if  ( efer &  efer & EFER_LMA  ) { cs  -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 )  VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )
157,"CWE-20 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( mspack_memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( ""incorrectGUIDs"" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , ""WARNING;CHMversion>3"" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( ""contentsectionbeginsafterfilehasended"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( ""chunksizenotlargeenough"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( ""nochunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( ""morethan100,000chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( ""chunkslargerthanentirefile"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , ""WARNING;chunksizeisnotapoweroftwo"" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , ""WARNING;firstPMGLchunkisnotzero"" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( ""firstpmglchunkisafterlastpmglchunk"" ) ) return MSPACK_ERR_DATAFORMAT ; }  if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {  D ( ( ""index_rootoutsidevalidrange"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , ""WARNING;PMGLquickrefareaistoosmall"" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , ""WARNING;PMGLquickrefareaistoolarge"" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ;  name = p ; p += name_len ;  READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , ""invalidsectionnumber\'%u\'."" , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { if ( mspack_memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { if ( mspack_memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . content = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { chm -> sec1 . control = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . spaninfo = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; } } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( ""chunkendedbeforeallentriescouldberead"" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }", chm -> index_root >=  chm -> num_chunks  goto chunk_end ; if ( name_len == 0 ) goto chunk_end ;
158,"CWE-000 static int iwch_l2t_send ( struct t3cdev * tdev , struct sk_buff * skb , struct l2t_entry * l2e ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ;  return error ;  }", ; return error < 0 ? error : 0
159,"CWE-125 static void  l2tp_bearer_cap_print ( netdissect_options * ndo , const u_char * dat )  {  const uint32_t * ptr = ( const uint32_t * ) dat ;  if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_CAP_ANALOG_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_CAP_DIGITAL_MASK ) { ND_PRINT ( ( ndo , ""D"" ) ) ; } }"," u_char * dat , u_int length  ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVPtooshort"" ) ) ; return ; }"
160,"CWE-20 static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ;  int delta_munlocked ;  struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ;  }  pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; }  delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ;  __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }", ; int delta_munlocked = - nr  ) ; } else { delta_munlocked ++ ; }  NULL ; }  __mod_zone_page_state ( zone
161,"CWE-400 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { struct mount * n , * p ; bool done ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ;  return 0 ;  }"," ) ; return count_mounts ( m -> mnt_ns , child )  ; } "
162,"CWE-125 static void ImportCbYCrYQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; switch ( quantum_info -> depth ) { case 10 : { Quantum cbcr [ 4 ] ; pixel = 0 ; if ( quantum_info -> pack == MagickFalse ) { register ssize_t i ; size_t quantum ; ssize_t n ; n = 0 ; quantum = 0 ;  for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 )  { for ( i = 0 ; i < 4 ; i ++ ) { switch ( n % 3 ) { case 0 : { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 22 ) & 0x3ff ) << 6 ) ) ) ; break ; } case 1 : { quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 12 ) & 0x3ff ) << 6 ) ) ) ; break ; } case 2 : { quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 2 ) & 0x3ff ) << 6 ) ) ) ; break ; } } cbcr [ i ] = ( Quantum ) ( quantum ) ; n ++ ; } p += quantum_info -> pad ; SetPixelRed ( image , cbcr [ 1 ] , q ) ; SetPixelGreen ( image , cbcr [ 0 ] , q ) ; SetPixelBlue ( image , cbcr [ 2 ] , q ) ; q += GetPixelChannels ( image ) ; SetPixelRed ( image , cbcr [ 3 ] , q ) ; SetPixelGreen ( image , cbcr [ 0 ] , q ) ; SetPixelBlue ( image , cbcr [ 2 ] , q ) ; q += GetPixelChannels ( image ) ; } break ; } } default : { range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelRed ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGreen ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } } }", ; x += 4  ) { for
163,"CWE-399 static int db_interception ( struct vcpu_svm * svm ) { struct kvm_run * kvm_run = svm -> vcpu . run ; if ( ! ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) && ! svm -> nmi_singlestep ) { kvm_queue_exception ( & svm -> vcpu , DB_VECTOR ) ; return 1 ; } if ( svm -> nmi_singlestep ) { svm -> nmi_singlestep = false ; if ( ! ( svm -> vcpu . guest_debug & KVM_GUESTDBG_SINGLESTEP ) ) svm -> vmcb -> save . rflags &= ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ;  update_db_bp_intercept ( & svm -> vcpu ) ;  } if ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) { kvm_run -> exit_reason = KVM_EXIT_DEBUG ; kvm_run -> debug . arch . pc = svm -> vmcb -> save . cs . base + svm -> vmcb -> save . rip ; kvm_run -> debug . arch . exception = DB_VECTOR ; return 0 ; } return 1 ; }", X86_EFLAGS_RF ) ;  } if (
164,"CWE-415 static int sg_common_write ( Sg_fd * sfp , Sg_request * srp , unsigned char * cmnd , int timeout , int blocking ) { int k , at_head ; Sg_device * sdp = sfp -> parentdp ; sg_io_hdr_t * hp = & srp -> header ; srp -> data . cmd_opcode = cmnd [ 0 ] ; hp -> status = 0 ; hp -> masked_status = 0 ; hp -> msg_status = 0 ; hp -> info = 0 ; hp -> host_status = 0 ; hp -> driver_status = 0 ; hp -> resid = 0 ; SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sfp -> parentdp , ""sg_common_write:scsiopcode=0x%02x,cmd_size=%d\\n"" , ( int ) cmnd [ 0 ] , ( int ) hp -> cmd_len ) ) ; k = sg_start_req ( srp , cmnd ) ; if ( k ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sfp -> parentdp , ""sg_common_write:start_reqerr=%d\\n"" , k ) ) ; sg_finish_rem_req ( srp ) ; return k ; } if ( atomic_read ( & sdp -> detaching ) ) {  if ( srp -> bio )   blk_end_request_all ( srp -> rq , - EIO ) ;  sg_finish_rem_req ( srp ) ; return - ENODEV ; } hp -> duration = jiffies_to_msecs ( jiffies ) ; if ( hp -> interface_id != '\\0' && ( SG_FLAG_Q_AT_TAIL & hp -> flags ) ) at_head = 0 ; else at_head = 1 ; srp -> rq -> timeout = timeout ; kref_get ( & sfp -> f_ref ) ; blk_execute_rq_nowait ( sdp -> device -> request_queue , sdp -> disk , srp -> rq , at_head , sg_rq_end_io ) ; return 0 ; }", -> bio ) { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ;  EIO ) ; srp -> rq = NULL ; }
165,"CWE-269 static int store_asoundrc ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_ASOUNDRC_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0644 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) {  fprintf ( stderr , ""Error:invalid.asoundrcfile\\n"" ) ;  exit ( 1 ) ; }  pid_t child = fork ( ) ;  if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest ) ; if ( rv )  fprintf ( stderr , ""Warning:cannottransfer.asoundrcinprivatehomedirectory\\n"" ) ;  else {  fs_logger2 ( ""clone"" , dest ) ;  } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) errExit ( ""fchown"" ) ; if ( chmod ( dest , 0644 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }"," ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) {  ( stderr , ""Error:Cannotaccess%s\\n"" , src  ) ; exit  ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) {  fprintf ( stderr  ( stderr , ""Error:.asoundrcisasymboliclinkpointingtoafileoutsidehomedirectory\\n"" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ;  fs_logger2 ( ""clone""  ""clone"" , dest  ) ; return"
166,"CWE-000 static inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , long elements , int objprops ) { while ( elements -- > 0 ) { zval * key , * data , * * old_data ; ALLOC_INIT_ZVAL ( key ) ; if ( ! php_var_unserialize ( & key , p , max , NULL TSRMLS_CC ) ) { zval_dtor ( key ) ; FREE_ZVAL ( key ) ; return 0 ; } if ( Z_TYPE_P ( key ) != IS_LONG && Z_TYPE_P ( key ) != IS_STRING ) { zval_dtor ( key ) ; FREE_ZVAL ( key ) ; return 0 ; } ALLOC_INIT_ZVAL ( data ) ; if ( ! php_var_unserialize ( & data , p , max , var_hash TSRMLS_CC ) ) { zval_dtor ( key ) ; FREE_ZVAL ( key ) ; zval_dtor ( data ) ; FREE_ZVAL ( data ) ; return 0 ; } if ( ! objprops ) { switch ( Z_TYPE_P ( key ) ) { case IS_LONG : if ( zend_hash_index_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_hash_index_update ( ht , Z_LVAL_P ( key ) , & data , sizeof ( data ) , NULL ) ; break ; case IS_STRING : if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_symtable_update ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , & data , sizeof ( data ) , NULL ) ; break ; } } else { convert_to_string ( key ) ;  if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) {  var_push_dtor ( var_hash , old_data ) ; } zend_hash_update ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , & data , sizeof data , NULL ) ; } zval_dtor ( key ) ; FREE_ZVAL ( key ) ; if ( elements && * ( * p - 1 ) != ';' && * ( * p - 1 ) != '}' ) { ( * p ) -- ; return 0 ; } } return 1 ; }"," ; if ( zend_hash_find  ( ht ,"
167,"CWE-264 static void on_response ( void * data , krb5_error_code retval , otp_response response ) { struct request_state rs = * ( struct request_state * ) data ; free ( data ) ; if ( retval == 0 && response != otp_response_success ) retval = KRB5_PREAUTH_FAILED ;  rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;  }", = KRB5_PREAUTH_FAILED ; if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;
168,"CWE-476 void migrate_page_copy ( struct page * newpage , struct page * page ) { int cpupid ; if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ; else copy_highpage ( newpage , page ) ; if ( PageError ( page ) ) SetPageError ( newpage ) ; if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ; if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ; if ( TestClearPageActive ( page ) ) { VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ; SetPageActive ( newpage ) ; } else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ; if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ; if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ;  if ( PageDirty ( page ) ) {  clear_page_dirty_for_io ( page ) ; if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ;  else  __set_page_dirty_nobuffers ( newpage ) ; } if ( page_is_young ( page ) ) set_page_young ( newpage ) ; if ( page_is_idle ( page ) ) set_page_idle ( newpage ) ; cpupid = page_cpupid_xchg_last ( page , - 1 ) ; page_cpupid_xchg_last ( newpage , cpupid ) ; ksm_migrate_page ( newpage , page ) ; if ( PageSwapCache ( page ) ) ClearPageSwapCache ( page ) ; ClearPagePrivate ( page ) ; set_page_private ( page , 0 ) ; if ( PageWriteback ( newpage ) ) end_page_writeback ( newpage ) ; }", page ) )  SetPageDirty ( newpage  newpage ) ;  if ( page_is_young
169,"CWE-476 static MagickBooleanType ReadPSDChannel ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , const size_t channel , const PSDCompressionType compression , ExceptionInfo * exception ) { Image * channel_image , * mask ; MagickOffsetType offset ; MagickBooleanType status ; channel_image = image ; mask = ( Image * ) NULL ; if ( layer_info -> channel_info [ channel ] . type < - 1 ) { const char * option ; option = GetImageOption ( image_info , ""psd:preserve-opacity-mask"" ) ; if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && ( IsStringTrue ( option ) == MagickFalse ) ) ) { SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; return ( MagickTrue ) ; } mask = CloneImage ( image , layer_info -> mask . page . width , layer_info -> mask . page . height , MagickFalse , exception ) ;  mask -> matte = MagickFalse ;   channel_image = mask ;  } offset = TellBlob ( image ) ; status = MagickTrue ; switch ( compression ) { case Raw : status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , layer_info -> channel_info [ channel ] . type , exception ) ; break ; case RLE : { MagickOffsetType * sizes ; sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; if ( sizes == ( MagickOffsetType * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; status = ReadPSDChannelRLE ( channel_image , psd_info , layer_info -> channel_info [ channel ] . type , sizes , exception ) ; sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; } break ; case ZipWithPrediction : case ZipWithoutPrediction : # ifdef MAGICKCORE_ZLIB_DELEGATE status = ReadPSDChannelZip ( channel_image , layer_info -> channels , layer_info -> channel_info [ channel ] . type , compression , layer_info -> channel_info [ channel ] . size - 2 , exception ) ; # else ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , MissingDelegateWarning , ""DelegateLibrarySupportNotBuiltIn"" , ""\'%s\'(ZLIB)"" , image -> filename ) ; # endif break ; default : ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , ""CompressionNotSupported"" , ""\'%.20g\'"" , ( double ) compression ) ; break ; } SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; if ( status == MagickFalse ) { if ( mask != ( Image * ) NULL ) DestroyImage ( mask ) ; ThrowBinaryException ( CoderError , ""UnableToDecompressImage"" , image -> filename ) ; } layer_info -> mask . image = mask ; return ( status ) ; }", exception ) ; if ( mask != ( Image * ) NULL ) {  = mask ; }
170,"CWE-000 static int closeVirtualHostDirective ( MaState * state , cchar * key , cchar * value ) { HttpEndpoint * endpoint ; char * address , * ip , * addresses , * tok ; int port ; if ( state -> enabled ) { if ( state -> endpoints && * state -> endpoints ) {  addresses = state -> endpoints ;   while ( ( address = stok ( addresses , ""\\t,"" , & tok ) ) != 0 ) {  addresses = 0 ; mprParseSocketAddress ( address , & ip , & port , NULL , - 1 ) ; if ( ( endpoint = httpLookupEndpoint ( ip , port ) ) == 0 ) { mprLog ( ""errorappwebconfig"" , 0 , ""Cannotfindlistendirectiveforvirtualhost%s"" , address ) ; return MPR_ERR_BAD_SYNTAX ; } else { httpAddHostToEndpoint ( endpoint , state -> host ) ; } } } else { httpAddHostToEndpoints ( state -> host ) ; } } closeDirective ( state , key , value ) ; return 0 ; }", endpoints ) { for ( addresses = sclone (  state -> endpoints  state -> endpoints ) ;  ( address =  ) != 0 ; addresses = tok ) {  mprParseSocketAddress ( address
171,"CWE-119 static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ;  hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;  pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }", ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->
172,"CWE-401 struct resource_pool * dce112_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ;  BREAK_TO_DEBUGGER ( ) ;  return NULL ; }", -> base ; kfree ( pool ) ;
173,"CWE-20 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ;  align_get_bits ( gb ) ;  if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( ""QMP4"" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , ""frameskip%d\\n"" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""startcode:%3X"" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectStart"" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectLayerStart"" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FGSbpstart"" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqStart"" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqEnd"" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""UserData"" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""GroupofVOPstart"" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoSessionError"" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectStart"" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectPlanestart"" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""slicestart"" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""extensionstart"" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""fgsstart"" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectstart"" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectPlanestart"" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectstart"" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectPlanestart"" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , ""StillTextureObjectstart"" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSpatialLayerstart"" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSNRLayerstart"" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureTilestart"" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureShapeLayerstart"" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""stuffingstart"" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""reserved"" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Systemstart"" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , ""at%d\\n"" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , ""IgnoringmultipleVOLheaders\\n"" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { mpeg4_decode_profile_level ( s , gb ) ; if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; } } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { if ( ! s -> avctx -> bits_per_raw_sample ) { av_log ( s -> avctx , AV_LOG_ERROR , ""MissingVOLheader\\n"" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }", ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
174,"CWE-19 static int nft_flush_table ( struct nft_ctx * ctx ) { int err ; struct nft_chain * chain , * nc ; struct nft_set * set , * ns ;  list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) {  ctx -> chain = chain ; err = nft_delrule_by_chain ( ctx ) ; if ( err < 0 ) goto out ;  err = nft_delchain ( ctx ) ;  if ( err < 0 ) goto out ; }  list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) {   if ( set -> flags & NFT_SET_ANONYMOUS &&  ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set ) ; if ( err < 0 ) goto out ; } err = nft_deltable ( ctx ) ; out : return err ; }"," * ns ; list_for_each_entry ( chain  , & ctx  goto out ; } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set  ) ; if  } list_for_each_entry_safe ( chain , nc  , & ctx  -> table -> chains  , list )  list ) { ctx -> chain = chain ; err = nft_delchain ( ctx  ) ; if"
175,"CWE-20 int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) { __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; unsigned int start_segno , end_segno ; struct cp_control cpc ; int err = 0 ; if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) return - EINVAL ; cpc . trimmed = 0 ; if ( end <= MAIN_BLKADDR ( sbi ) ) goto out ; if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { f2fs_msg ( sbi -> sb , KERN_WARNING , ""FoundFScorruption,runfscktofix."" ) ; goto out ; } start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : GET_SEGNO ( sbi , end ) ; cpc . reason = CP_DISCARD ; cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { cpc . trim_start = start_segno ; if ( sbi -> discard_blks == 0 ) break ; else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) cpc . trim_end = end_segno ; else cpc . trim_end = min_t ( unsigned int , rounddown ( start_segno + BATCHED_TRIM_SEGMENTS ( sbi ) , sbi -> segs_per_sec ) - 1 , end_segno ) ; mutex_lock ( & sbi -> gc_mutex ) ; err = write_checkpoint ( sbi , & cpc ) ; mutex_unlock ( & sbi -> gc_mutex ) ; if ( err ) break ; schedule ( ) ; } mark_discard_range_all ( sbi ) ;  f2fs_wait_discard_bios ( sbi ) ;  out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ; }"," f2fs_wait_discard_bios ( sbi , false"
176,"CWE-399 static void inotify_free_group_priv ( struct fsnotify_group * group ) { idr_for_each ( & group -> inotify_data . idr , idr_callback , group ) ; idr_remove_all ( & group -> inotify_data . idr ) ; idr_destroy ( & group -> inotify_data . idr ) ;  free_uid ( group -> inotify_data . user ) ;  }", idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;
177,"CWE-399 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , profile_data , profile_size , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Magick:%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""BMPsize:%u"" , bmp_info . size ) ; profile_data = 0 ; profile_size = 0 ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Format:OS/2Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Geometry:%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Format:MSWindowsbitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Geometry:%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Bitsperpixel:%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Compression:UNKNOWN(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Numberofcolors:%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; profile_size = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnsupportedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Readingcolormapof%.20gcolors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( MagickSizeType ) ( length / 256 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Readingpixels(%.20gbytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( ( bmp_info . colorspace == 0x4D424544L ) && ( profile_data > 0 ) && ( profile_size > 0 ) ) { StringInfo * profile ; unsigned char * datum ; offset = start_position + 14 + profile_data ; if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) || ( GetBlobSize ( image ) < ( MagickSizeType ) ( offset + profile_size ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; profile = AcquireStringInfo ( ( size_t ) profile_size ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( CorruptImageError , ""MemoryAllocationFailed"" ) ; datum = GetStringInfoDatum ( profile ) ; if ( ReadBlob ( image , ( size_t ) profile_size , datum ) == ( ssize_t ) profile_size ) { MagickOffsetType profile_size_orig ; profile_size_orig = ( MagickOffsetType ) datum [ 0 ] << 24 ; profile_size_orig |= ( MagickOffsetType ) datum [ 1 ] << 16 ; profile_size_orig |= ( MagickOffsetType ) datum [ 2 ] << 8 ; profile_size_orig |= ( MagickOffsetType ) datum [ 3 ] ; if ( profile_size_orig < profile_size ) SetStringInfoLength ( profile , ( size_t ) profile_size_orig ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""Profile:ICC,%ubytes"" , ( unsigned int ) profile_size_orig ) ; ( void ) SetImageProfile ( image , ""icc"" , profile , exception ) ; } profile = DestroyStringInfo ( profile ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; * magick = '\\0' ; count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ;  return ( ( Image * ) NULL ) ;  } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }", = MagickFalse ; break  ; } image
178,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent ,  length ;  ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;  sun_pixels = sun_data ;  bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;  }  p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," , extent , height ,  ""UnableToReadImageData"" ) ;  height = sun_info  ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED )  sun_data ) ;  p = sun_pixels"
179,"CWE-119 static void scsi_dma_restart_bh ( void * opaque ) { SCSIDiskState * s = opaque ; SCSIRequest * req ; SCSIDiskReq * r ; qemu_bh_delete ( s -> bh ) ; s -> bh = NULL ; QTAILQ_FOREACH ( req , & s -> qdev . requests , next ) { r = DO_UPCAST ( SCSIDiskReq , req , req ) ; if ( r -> status & SCSI_REQ_STATUS_RETRY ) { int status = r -> status ; int ret ; r -> status &= ~ ( SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK ) ; switch ( status & SCSI_REQ_STATUS_RETRY_TYPE_MASK ) { case SCSI_REQ_STATUS_RETRY_READ : scsi_read_data ( & r -> req ) ; break ; case SCSI_REQ_STATUS_RETRY_WRITE : scsi_write_data ( & r -> req ) ; break ; case SCSI_REQ_STATUS_RETRY_FLUSH :  ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ;  if ( ret == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } } } } }", scsi_disk_emulate_command ( r  ) ; if
180,"CWE-190 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) {  u16 offset = sizeof ( struct ipv6hdr ) ;  unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ;  switch ( * * nexthdr ) {  case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ;  offset += ipv6_optlen ( exthdr ) ;  * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }", nexthdr ) { unsigned int  offset = sizeof  * exthdr ; unsigned int len ;  offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len  ; * nexthdr
181,"CWE-476 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( ""QMP4"" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , ""frameskip%d\\n"" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""startcode:%3X"" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectStart"" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectLayerStart"" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FGSbpstart"" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqStart"" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqEnd"" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""UserData"" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""GroupofVOPstart"" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoSessionError"" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectStart"" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectPlanestart"" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""slicestart"" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""extensionstart"" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""fgsstart"" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectstart"" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectPlanestart"" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectstart"" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectPlanestart"" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , ""StillTextureObjectstart"" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSpatialLayerstart"" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSNRLayerstart"" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureTilestart"" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureShapeLayerstart"" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""stuffingstart"" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""reserved"" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Systemstart"" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , ""at%d\\n"" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , ""IgnoringmultipleVOLheaders\\n"" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) {  mpeg4_decode_profile_level ( s , gb ) ;  if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&  ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {  s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ;  }  } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) {  if ( ! s -> avctx -> bits_per_raw_sample ) {  av_log ( s -> avctx , AV_LOG_ERROR , ""MissingVOLheader\\n"" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }"," VOS_STARTCODE ) { int profile , level ;  s , gb , & profile , & level ) ; if (  profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO  FF_PROFILE_MPEG4_SIMPLE_STUDIO && (  level > 0  > 0 &&  level < 9  ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixesstudioandnonstudioprofile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ;  studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;"
182,"CWE-119 int dbd_bind_ph ( SV * sth , imp_sth_t * imp_sth , SV * param , SV * value , IV sql_type , SV * attribs , int is_inout , IV maxlen ) { dTHX ; int rc ; int param_num = SvIV ( param ) ; int idx = param_num - 1 ;  char err_msg [ 64 ] ;  D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION STRLEN slen ; char * buffer = NULL ; int buffer_is_null = 0 ; int buffer_length = slen ; unsigned int buffer_type = 0 ; IV tmp ; # endif D_imp_dbh_from_sth ; ASYNC_CHECK_RETURN ( sth , FALSE ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""Called:dbd_bind_ph\\n"" ) ; attribs = attribs ; maxlen = maxlen ; if ( param_num <= 0 || param_num > DBIc_NUM_PARAMS ( imp_sth ) ) { do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , ""Illegalparameternumber"" , NULL ) ; return FALSE ; } if ( SvOK ( value ) && ( sql_type == SQL_NUMERIC || sql_type == SQL_DECIMAL || sql_type == SQL_INTEGER || sql_type == SQL_SMALLINT || sql_type == SQL_FLOAT || sql_type == SQL_REAL || sql_type == SQL_DOUBLE ) ) { if ( ! looks_like_number ( value ) ) {  sprintf ( err_msg ,  ""Bindingnon-numericfield%d,value%sasanumeric!"" ,  param_num , neatsvpv ( value , 0 ) ) ;  do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , err_msg , NULL ) ; } } if ( is_inout ) { do_error ( sth , JW_ERR_NOT_IMPLEMENTED , ""Outputparametersnotimplemented"" , NULL ) ; return FALSE ; } rc = bind_param ( & imp_sth -> params [ idx ] , value , sql_type ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { switch ( sql_type ) { case SQL_NUMERIC : case SQL_INTEGER : case SQL_SMALLINT : case SQL_BIGINT : case SQL_TINYINT : buffer_type = MYSQL_TYPE_LONG ; break ; case SQL_DOUBLE : case SQL_DECIMAL : case SQL_FLOAT : case SQL_REAL : buffer_type = MYSQL_TYPE_DOUBLE ; break ; case SQL_CHAR : case SQL_VARCHAR : case SQL_DATE : case SQL_TIME : case SQL_TIMESTAMP : case SQL_LONGVARCHAR : case SQL_BINARY : case SQL_VARBINARY : case SQL_LONGVARBINARY : buffer_type = MYSQL_TYPE_BLOB ; break ; default : buffer_type = MYSQL_TYPE_STRING ; } buffer_is_null = ! ( SvOK ( imp_sth -> params [ idx ] . value ) && imp_sth -> params [ idx ] . value ) ; if ( ! buffer_is_null ) { switch ( buffer_type ) { case MYSQL_TYPE_LONG : if ( ! SvIOK ( imp_sth -> params [ idx ] . value ) && DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tTRYTOBINDANINTNUMBER\\n"" ) ; buffer_length = sizeof imp_sth -> fbind [ idx ] . numeric_val . lval ; tmp = SvIV ( imp_sth -> params [ idx ] . value ) ; if ( tmp > INT32_MAX ) croak ( ""Couldnotbind%ld:IntegertoolargeforMYSQL_TYPE_LONG"" , tmp ) ; imp_sth -> fbind [ idx ] . numeric_val . lval = tmp ; buffer = ( void * ) & ( imp_sth -> fbind [ idx ] . numeric_val . lval ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""SCALARtype%d->%"" PRId32 ""<-ISAINTNUMBER\\n"" , ( int ) sql_type , * ( int32_t * ) buffer ) ; break ; case MYSQL_TYPE_DOUBLE : if ( ! SvNOK ( imp_sth -> params [ idx ] . value ) && DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tTRYTOBINDAFLOATNUMBER\\n"" ) ; buffer_length = sizeof imp_sth -> fbind [ idx ] . numeric_val . dval ; imp_sth -> fbind [ idx ] . numeric_val . dval = SvNV ( imp_sth -> params [ idx ] . value ) ; buffer = ( char * ) & ( imp_sth -> fbind [ idx ] . numeric_val . dval ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""SCALARtype%d->%f<-ISAFLOATNUMBER\\n"" , ( int ) sql_type , ( double ) ( * buffer ) ) ; break ; case MYSQL_TYPE_BLOB : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""SCALARtypeBLOB\\n"" ) ; break ; case MYSQL_TYPE_STRING : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""SCALARtypeSTRING%d,buffertype=%d\\n"" , ( int ) sql_type , buffer_type ) ; break ; default : croak ( ""BuginDBD::Mysqlfiledbdimp.c#dbd_bind_ph:donotknowhowtohandleunknownbuffertype."" ) ; } if ( buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB ) { buffer = SvPV ( imp_sth -> params [ idx ] . value , slen ) ; buffer_length = slen ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""SCALARtype%d->length%d<-ISASTRINGorBLOB\\n"" , ( int ) sql_type , buffer_length ) ; } } else { buffer = NULL ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""SCALARNULLVALUE:buffertypeis:%d\\n"" , buffer_type ) ; } if ( imp_sth -> bind [ idx ] . buffer_type != buffer_type ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""FORCEREBIND:buffertypechangedfrom%dto%d,sql-type=%d\\n"" , ( int ) imp_sth -> bind [ idx ] . buffer_type , buffer_type , ( int ) sql_type ) ; imp_sth -> has_been_bound = 0 ; } if ( imp_sth -> has_been_bound == 0 ) { imp_sth -> bind [ idx ] . buffer_type = buffer_type ; imp_sth -> bind [ idx ] . buffer = buffer ; imp_sth -> bind [ idx ] . buffer_length = buffer_length ; } else { imp_sth -> stmt -> params [ idx ] . buffer = buffer ; imp_sth -> stmt -> params [ idx ] . buffer_length = buffer_length ; } imp_sth -> fbind [ idx ] . length = buffer_length ; imp_sth -> fbind [ idx ] . is_null = buffer_is_null ; } # endif return rc ; }"," 1 ; char * err_msg  ; D_imp_xxh (  ) ) { err_msg = SvPVX ( sv_2mortal ( newSVpvf (  ""Bindingnon-numericfield%d,value%sasanumeric!"" , param_num  value , 0 ) )"
183,"CWE-119 static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) { const uint8_t * frame_start = frame ; const uint8_t * frame_end = frame + width * height ; int mask = 0x10000 , bitbuf = 0 ; int i , v , offset , count , segments ; segments = bytestream2_get_le16 ( gb ) ; while ( segments -- ) { if ( bytestream2_get_bytes_left ( gb ) < 2 ) return AVERROR_INVALIDDATA ; if ( mask == 0x10000 ) { bitbuf = bytestream2_get_le16u ( gb ) ; mask = 1 ; } if ( bitbuf & mask ) { v = bytestream2_get_le16 ( gb ) ; offset = ( v & 0x1FFF ) << 2 ; count = ( ( v >> 13 ) + 2 ) << 1 ; if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < count ; i ++ ) { frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; frame += 2 ; } } else if ( bitbuf & ( mask << 1 ) ) { v = bytestream2_get_le16 ( gb ) * 2 ; if ( frame - frame_end < v ) return AVERROR_INVALIDDATA ; frame += v ; } else {  if ( frame_end - frame < width + 3 )  return AVERROR_INVALIDDATA ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; frame += 2 ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; frame += 2 ; } mask <<= 2 ; } return 0 ; }", < width + 4  ) return AVERROR_INVALIDDATA
184,"CWE-119  int check_fragments_for_errors ( VP8D_COMP * pbi )  { if ( ! pbi -> ec_active && pbi -> fragments . count <= 1 && pbi -> fragments . sizes [ 0 ] == 0 ) { VP8_COMMON * cm = & pbi -> common ; if ( cm -> fb_idx_ref_cnt [ cm -> lst_fb_idx ] > 1 ) { const int prev_idx = cm -> lst_fb_idx ; cm -> fb_idx_ref_cnt [ prev_idx ] -- ; cm -> lst_fb_idx = get_free_fb ( cm ) ; vp8_yv12_copy_frame ( & cm -> yv12_fb [ prev_idx ] , & cm -> yv12_fb [ cm -> lst_fb_idx ] ) ; } cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; cm -> show_frame = 0 ; return 0 ; } return 1 ; }",    static
185,"CWE-119 static void swap_frame_buffers ( VP9Decoder * pbi ) { int ref_index = 0 , mask ; VP9_COMMON * const cm = & pbi -> common ;  for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) {   if ( mask & 1 ) {  const int old_idx = cm -> ref_frame_map [ ref_index ] ;  ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] ,   cm -> new_fb_idx ) ;   if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 )  cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ old_idx ] . raw_frame_buffer ) ; } ++ ref_index ; } cm -> frame_to_show = get_frame_new_buffer ( cm ) ; cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; for ( ref_index = 0 ; ref_index < 3 ; ref_index ++ )  cm -> frame_refs [ ref_index ] . idx = INT_MAX ;  }"," -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ;  1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if (  ( mask &  & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index )  ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [  cm -> new_fb_idx  cm -> new_fb_idx  ] . ref_count  ] . ref_count ; unlock_buffer_pool ( pool ) ; }  for ( ref_index  . idx = - 1  ; } "
186,"CWE-191 DECLAREcpFunc ( cpDecodedStrips ) { tsize_t stripsize = TIFFStripSize ( in ) ; tdata_t buf = _TIFFmalloc ( stripsize ) ; ( void ) imagewidth ; ( void ) spp ; if ( buf ) { tstrip_t s , ns = TIFFNumberOfStrips ( in ) ; uint32 row = 0 ; _TIFFmemset ( buf , 0 , stripsize ) ;  for ( s = 0 ; s < ns ; s ++ ) {  tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ; if ( TIFFReadEncodedStrip ( in , s , buf , cc ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,can\'treadstrip%lu"" , ( unsigned long ) s ) ; goto bad ; } if ( TIFFWriteEncodedStrip ( out , s , buf , cc ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,can\'twritestrip%lu"" , ( unsigned long ) s ) ; goto bad ; } row += rowsperstrip ; } _TIFFfree ( buf ) ; return 1 ; } else { TIFFError ( TIFFFileName ( in ) , ""Error,can\'tallocatememorybufferofsize%lu"" ""toreadstrips"" , ( unsigned long ) stripsize ) ; return 0 ; } bad : _TIFFfree ( buf ) ; return 0 ; }", s < ns && row < imagelength
187,CWE-119 SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) {  return in ;  } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; }, ) { return NULL  ; } while
188,"CWE-20 static int cmd_handle_untagged ( struct ImapData * idata ) { unsigned int count = 0 ; char * s = imap_next_word ( idata -> buf ) ; char * pn = imap_next_word ( s ) ; if ( ( idata -> state >= IMAP_SELECTED ) && isdigit ( ( unsigned char ) * s ) ) { pn = s ; s = imap_next_word ( s ) ; if ( mutt_str_strncasecmp ( ""EXISTS"" , s , 6 ) == 0 ) { mutt_debug ( 2 , ""HandlingEXISTS\\n"" ) ; if ( mutt_str_atoui ( pn , & count ) < 0 ) { mutt_debug ( 1 , ""MalformedEXISTS:\'%s\'\\n"" , pn ) ; } if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) && count < idata -> max_msn ) { mutt_debug ( 1 , ""Messagecountisoutofsync\\n"" ) ; return 0 ; } else if ( count == idata -> max_msn ) mutt_debug ( 3 , ""superfluousEXISTSmessage.\\n"" ) ; else { if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) ) { mutt_debug ( 2 , ""Newmailin%s-%dmessagestotal.\\n"" , idata -> mailbox , count ) ; idata -> reopen |= IMAP_NEWMAIL_PENDING ; } idata -> new_mail_count = count ; } } else if ( mutt_str_strncasecmp ( ""EXPUNGE"" , s , 7 ) == 0 ) cmd_parse_expunge ( idata , pn ) ; else if ( mutt_str_strncasecmp ( ""FETCH"" , s , 5 ) == 0 ) cmd_parse_fetch ( idata , pn ) ; } else if ( mutt_str_strncasecmp ( ""CAPABILITY"" , s , 10 ) == 0 ) cmd_parse_capability ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""OK[CAPABILITY"" , s , 14 ) == 0 ) cmd_parse_capability ( idata , pn ) ; else if ( mutt_str_strncasecmp ( ""OK[CAPABILITY"" , pn , 14 ) == 0 ) cmd_parse_capability ( idata , imap_next_word ( pn ) ) ; else if ( mutt_str_strncasecmp ( ""LIST"" , s , 4 ) == 0 ) cmd_parse_list ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""LSUB"" , s , 4 ) == 0 ) cmd_parse_lsub ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""MYRIGHTS"" , s , 8 ) == 0 ) cmd_parse_myrights ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""SEARCH"" , s , 6 ) == 0 ) cmd_parse_search ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""STATUS"" , s , 6 ) == 0 ) cmd_parse_status ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""ENABLED"" , s , 7 ) == 0 ) cmd_parse_enabled ( idata , s ) ; else if ( mutt_str_strncasecmp ( ""BYE"" , s , 3 ) == 0 ) { mutt_debug ( 2 , ""HandlingBYE\\n"" ) ; if ( idata -> status == IMAP_BYE ) return 0 ; s += 3 ; SKIPWS ( s ) ; mutt_error ( ""%s"" , s ) ; cmd_handle_fatal ( idata ) ; return - 1 ; } else if ( ImapServernoise && ( mutt_str_strncasecmp ( ""NO"" , s , 2 ) == 0 ) ) { mutt_debug ( 2 , ""HandlinguntaggedNO\\n"" ) ;  mutt_error ( ""%s"" , s + 3 ) ;  } return 0 ; }"," , s + 2  ) ; }"
189,"CWE-284 static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; ssize_t bit ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ;  switch ( quantum_info -> depth )  { case 1 : { register Quantum black , white ; black = 0 ; white = QuantumRange ; if ( quantum_info -> min_is_white != MagickFalse ) { black = QuantumRange ; white = 0 ; } for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 8 ) ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } case 4 : { register unsigned char pixel ; range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 1 ) ; x += 2 ) { pixel = ( unsigned char ) ( ( * p >> 4 ) & 0xf ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; pixel = ( unsigned char ) ( ( * p ) & 0xf ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) { pixel = ( unsigned char ) ( * p ++ >> 4 ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } case 8 : { unsigned char pixel ; if ( quantum_info -> min_is_white != MagickFalse ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushCharPixel ( p , & pixel ) ; SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushCharPixel ( p , & pixel ) ; SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 10 : { range = GetQuantumRange ( quantum_info -> depth ) ; if ( quantum_info -> pack == MagickFalse ) { if ( image -> endian == LSBEndian ) { for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x ++ < ( ssize_t ) number_pixels ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x ++ < ( ssize_t ) number_pixels ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 12 : { range = GetQuantumRange ( quantum_info -> depth ) ; if ( quantum_info -> pack == MagickFalse ) { unsigned short pixel ; for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 1 ) ; x += 2 ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; q += GetPixelChannels ( image ) ; p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 16 : { unsigned short pixel ; if ( quantum_info -> min_is_white != MagickFalse ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } if ( quantum_info -> format == FloatingPointQuantumFormat ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 32 : { unsigned int pixel ; if ( quantum_info -> format == FloatingPointQuantumFormat ) { float pixel ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushFloatPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleLongToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 64 : { if ( quantum_info -> format == FloatingPointQuantumFormat ) { double pixel ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushDoublePixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } } default : { range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } } }", MagickCoreSignature ) ; pixel = 0 ;
190,"CWE-119 static void write_modes_sb ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) {  VP9_COMMON * const cm = & cpi -> common ;   MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;   const int bsl = b_width_log2 ( bsize ) ;  const int bs = ( 1 << bsl ) / 4 ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ;  MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ;  if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; partition = partition_lookup [ bsl ] [ m -> mbmi . sb_type ] ; write_partition ( cm , xd , bs , mi_row , mi_col , partition , bsize , w ) ; subsize = get_subsize ( bsize , partition ) ; if ( subsize < BLOCK_8X8 ) { write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; } else { switch ( partition ) { case PARTITION_NONE : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; break ; case PARTITION_HORZ : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_row + bs < cm -> mi_rows ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col ) ; break ; case PARTITION_VERT : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_col + bs < cm -> mi_cols ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs ) ; break ; case PARTITION_SPLIT : write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col + bs , subsize ) ; break ; default : assert ( 0 ) ; } } if ( bsize >= BLOCK_8X8 && ( bsize == BLOCK_8X8 || partition != PARTITION_SPLIT ) ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }"," const tile , vpx_writer * w ,  TOKENEXTRA * *  * tok , const TOKENEXTRA * const  tok_end , int  bsize ) { const  & cpi -> td .  int bsl = b_width_log2_lookup [ bsize ]  ; const int  BLOCK_SIZE subsize ; const MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;  m = cm  + mi_col ]  ; partition ="
191,"CWE-77 static void print_value ( int output , int num , const char * devname , const char * value , const char * name , size_t valsz ) { if ( output & OUTPUT_VALUE_ONLY ) { fputs ( value , stdout ) ; fputc ( '\\n' , stdout ) ; } else if ( output & OUTPUT_UDEV_LIST ) { print_udev_format ( name , value ) ; } else if ( output & OUTPUT_EXPORT_LIST ) { if ( num == 1 && devname ) printf ( ""DEVNAME=%s\\n"" , devname ) ; fputs ( name , stdout ) ; fputs ( ""="" , stdout ) ;  safe_print ( value , valsz , NULL ) ;  fputs ( ""\\n"" , stdout ) ; } else { if ( num == 1 && devname ) printf ( ""%s:"" , devname ) ; fputs ( """" , stdout ) ; fputs ( name , stdout ) ; fputs ( ""=\\"""" , stdout ) ;  safe_print ( value , valsz , ""\\"""" ) ;  fputs ( ""\\"""" , stdout ) ; } }"," , valsz , ""\\\\\\""\'$`<>""  ) ; fputs  , valsz , ""\\""\\\\"" ) ; fputs ( ""\\""""  , stdout )"
192,"CWE-125 static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""illegaldct_dc_sizevlc\\n"" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , ""dct_dc_size>8"" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""illegalaccoefficientgroupvlc\\n"" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 << additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 << ( additional_code_len - 1 ) ) + code ; idx += run ;  j = scantable [ idx ++ ] ;  block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) {  j = scantable [ idx ++ ] ;  block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;  } else if ( group == 21 ) {  j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc >> ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }", += run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ;  20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;  21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
193,"CWE-119 static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ;  int i , pktsz , ret ;  if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { dev_err ( dev , ""Can\'tsetaltsetting1.\\n"" ) ; return - EIO ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - ENOMEM ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = TX_TIMEOUT ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , ""Nofreeurbsavailable.\\n"" ) ; ret = - ENOMEM ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { dev_dbg ( dev , ""Testingforf5u011\\n"" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = RX_PKT_SZ ; } else { pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , NULL , NULL , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , NULL , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) {  dev_dbg ( dev , ""Checkingmemorysize\\n"" ) ;   i = 0x12345678 ;   catc_write_mem ( catc , 0x7a80 , & i , 4 ) ;   i = 0x87654321 ;   catc_write_mem ( catc , 0xfa80 , & i , 4 ) ;   catc_read_mem ( catc , 0x7a80 , & i , 4 ) ;   switch ( i ) {  case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ; catc_set_reg ( catc , RxBufCount , 32 ) ; dev_dbg ( dev , ""64kMemory\\n"" ) ; break ; default : dev_warn ( & intf -> dev , ""Couldn\'tdetectmemorysize,assuming32k\\n"" ) ; case 0x87654321 : catc_set_reg ( catc , TxBufCount , 4 ) ; catc_set_reg ( catc , RxBufCount , 16 ) ; dev_dbg ( dev , ""32kMemory\\n"" ) ; break ;  }  dev_dbg ( dev , ""GettingMACfromSEEROM.\\n"" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""SettingMACintoregisters.\\n"" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , ""Fillingthemulticastlist.\\n"" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , ""Clearingerrorcounters.\\n"" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , EthStats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , ""Enabling.\\n"" ) ; catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; catc_set_reg ( catc , LEDCtrl , LEDLink ) ; catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; } else { dev_dbg ( dev , ""Performingreset\\n"" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""SettingRXMode\\n"" ) ; catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , ""Initdone.\\n"" ) ; printk ( KERN_INFO ""%s:%sUSBEthernetatusb-%s-%s,%pM.\\n"" , netdev -> name , ( catc -> is_f5u011 ) ? ""BelkinF5U011"" : ""CATCEL1210ANetMate"" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , NULL ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }"," ] ; int  pktsz , ret  is_f5u011 ) { u32 * buf ; int i ;  ""Checkingmemorysize\\n"" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf  = 0x12345678 ;  , 0x7a80 , buf  , 4 )  4 ) ; * buf  = 0x87654321 ;  , 0xfa80 , buf  , 4 )  , 0x7a80 , buf  , 4 )  ; switch ( * buf  ) { case  break ; } kfree ( buf ) ;"
194,"CWE-362 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ;  const unsigned char * old_name ;  struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ;  if ( source == target )  return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename ) return - EPERM ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error ) return error ; } } error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) return error ;  old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;  dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } fsnotify_oldname_free ( old_name ) ; return error ; }"," old_dentry ) ;  struct inode *  -> s_max_links ; struct name_snapshot old_name ;  return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir ,  old_dentry -> d_name  d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name  ) ; return"
195,"CWE-476 void migrate_page_copy ( struct page * newpage , struct page * page ) { int cpupid ; if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ; else copy_highpage ( newpage , page ) ; if ( PageError ( page ) ) SetPageError ( newpage ) ; if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ; if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ; if ( TestClearPageActive ( page ) ) { VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ; SetPageActive ( newpage ) ; } else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ; if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ; if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ;  if ( PageDirty ( page ) ) {  clear_page_dirty_for_io ( page ) ; if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ;  else  __set_page_dirty_nobuffers ( newpage ) ; } if ( page_is_young ( page ) ) set_page_young ( newpage ) ; if ( page_is_idle ( page ) ) set_page_idle ( newpage ) ; cpupid = page_cpupid_xchg_last ( page , - 1 ) ; page_cpupid_xchg_last ( newpage , cpupid ) ; ksm_migrate_page ( newpage , page ) ; if ( PageSwapCache ( page ) ) ClearPageSwapCache ( page ) ; ClearPagePrivate ( page ) ; set_page_private ( page , 0 ) ; if ( PageWriteback ( newpage ) ) end_page_writeback ( newpage ) ; }", page ) )  SetPageDirty ( newpage  newpage ) ;  if ( page_is_young
196,"CWE-000 static struct sock * unix_create1 ( struct net * net , struct socket * sock , int kern ) { struct sock * sk = NULL ; struct unix_sock * u ; atomic_long_inc ( & unix_nr_socks ) ; if ( atomic_long_read ( & unix_nr_socks ) > 2 * get_max_files ( ) ) goto out ; sk = sk_alloc ( net , PF_UNIX , GFP_KERNEL , & unix_proto , kern ) ; if ( ! sk ) goto out ; sock_init_data ( sock , sk ) ; lockdep_set_class ( & sk -> sk_receive_queue . lock , & af_unix_sk_receive_queue_lock_key ) ; sk -> sk_write_space = unix_write_space ; sk -> sk_max_ack_backlog = net -> unx . sysctl_max_dgram_qlen ; sk -> sk_destruct = unix_sock_destructor ; u = unix_sk ( sk ) ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; spin_lock_init ( & u -> lock ) ; atomic_long_set ( & u -> inflight , 0 ) ; INIT_LIST_HEAD ( & u -> link ) ; mutex_init ( & u -> readlock ) ; init_waitqueue_head ( & u -> peer_wait ) ;  unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;  out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ; else { local_bh_disable ( ) ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , 1 ) ; local_bh_enable ( ) ; } return sk ; }"," peer_wait ) ; init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;"
197,"CWE-362 static int snd_ctl_elem_user_put ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int change ;  struct user_element * ue = kcontrol -> private_data ;  change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ; if ( change ) memcpy ( ue -> elem_data , & ucontrol -> value , ue -> elem_data_size ) ;  return change ;  }", kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock )  elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
198,"CWE-310 static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) { EVP_CIPHER_CTX * ctx ; const EVP_CIPHER * cipher ;  char * name ;  unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = { 0 } ; name = StringValueCStr ( str ) ; GetCipherInit ( self , ctx ) ; if ( ctx ) { ossl_raise ( rb_eRuntimeError , ""Cipheralreadyinititalized!"" ) ; } AllocCipher ( self , ctx ) ; if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) { ossl_raise ( rb_eRuntimeError , ""unsupportedcipheralgorithm(%"" PRIsVALUE "")"" , str ) ; }  if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 )  ossl_raise ( eCipherError , NULL ) ; return self ; }"," char * name  ; name =  , NULL , NULL  , NULL ,"
199,"CWE-416 static void nick_hash_remove ( CHANNEL_REC * channel , NICK_REC * nick ) {  NICK_REC * list ;  list = g_hash_table_lookup ( channel -> nicks , nick -> nick ) ; if ( list == NULL ) return ;  if ( list == nick || list -> next == NULL ) {  g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( list -> next != NULL ) {  g_hash_table_insert ( channel -> nicks , nick -> next -> nick ,  nick -> next ) ; }  } else {  while ( list -> next != nick ) list = list -> next ; list -> next = nick -> next ; }  } "," NICK_REC * list , * newlist  list == nick ) { newlist =  nick -> next  nick -> next ;  } else {  } else { newlist = list ;  next ; } g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; }"
200,"CWE-190  jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend )  { jas_matrix_t * matrix ; assert ( xstart <= xend && ystart <= yend ) ; if ( ! ( matrix = jas_matrix_create ( yend - ystart , xend - xstart ) ) ) { return 0 ; } matrix -> xstart_ = xstart ; matrix -> ystart_ = ystart ; matrix -> xend_ = xend ; matrix -> yend_ = yend ; return matrix ; }"," * jas_seq2d_create ( jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t  yend ) {"
201,"CWE-77 enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) { char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ; char buf [ STRING ] ; int rc ; if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) { mutt_message ( _ ( ""LOGINdisabledonthisserver."" ) ) ; return IMAP_AUTH_UNAVAIL ; } if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; mutt_message ( _ ( ""Loggingin..."" ) ) ;  imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ;   imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ;  if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""SendingLOGINcommandfor%s...\\n"" , idata -> conn -> account . user ) ; snprintf ( buf , sizeof ( buf ) , ""LOGIN%s%s"" , q_user , q_pass ) ; rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ; if ( ! rc ) { mutt_clear_error ( ) ; return IMAP_AUTH_SUCCESS ; } mutt_error ( _ ( ""Loginfailed."" ) ) ; return IMAP_AUTH_FAILURE ; }"," account . user , false  account . pass , false"
202,"CWE-617 static void pci_emul_cmdsts_write ( struct pci_vdev * dev , int coff , uint32_t new , int bytes ) { int i , rshift ; uint32_t cmd , cmd2 , changed , old , readonly ; cmd = pci_get_cfgdata16 ( dev , PCIR_COMMAND ) ; rshift = ( coff & 0x3 ) * 8 ; readonly = 0xFFFFF880 >> rshift ; old = CFGREAD ( dev , coff , bytes ) ; new &= ~ readonly ; new |= ( old & readonly ) ; CFGWRITE ( dev , coff , new , bytes ) ; cmd2 = pci_get_cfgdata16 ( dev , PCIR_COMMAND ) ; changed = cmd ^ cmd2 ; for ( i = 0 ; i <= PCI_BARMAX ; i ++ ) { switch ( dev -> bar [ i ] . type ) { case PCIBAR_NONE : case PCIBAR_MEMHI64 : break ; case PCIBAR_IO : if ( changed & PCIM_CMD_PORTEN ) { if ( porten ( dev ) ) register_bar ( dev , i ) ; else unregister_bar ( dev , i ) ; } break ; case PCIBAR_MEM32 : case PCIBAR_MEM64 : if ( changed & PCIM_CMD_MEMEN ) { if ( memen ( dev ) ) register_bar ( dev , i ) ; else unregister_bar ( dev , i ) ; } break ; default :  assert ( 0 ) ;  } } pci_lintr_update ( dev ) ; }"," ; default : pr_err ( ""%s:invalidbartype%d\\n"" , __func__ , dev -> bar [ i ] . type ) ; return  ; } }"
203,"CWE-125 static int string_scan_range ( RList * list , RBinFile * bf , int min , const ut64 from , const ut64 to , int type ) { ut8 tmp [ R_STRING_SCAN_BUFFER_SIZE ] ; ut64 str_start , needle = from ; int count = 0 , i , rc , runes ; int str_type = R_STRING_TYPE_DETECT ; if ( type == - 1 ) { type = R_STRING_TYPE_DETECT ; } if ( from >= to ) { eprintf ( ""Invalidrangetofindstrings0x%llx..0x%llx\\n"" , from , to ) ; return - 1 ; }  ut8 * buf = calloc ( to - from , 1 ) ;  if ( ! buf || ! min ) { return - 1 ; }  r_buf_read_at ( bf -> buf , from , buf , to - from ) ;  while ( needle < to ) { rc = r_utf8_decode ( buf + needle - from , to - needle , NULL ) ; if ( ! rc ) { needle ++ ; continue ; } if ( type == R_STRING_TYPE_DETECT ) { char * w = ( char * ) buf + needle + rc - from ;  if ( ( to - needle ) > 5 ) {   bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ;  if ( is_wide32 ) { str_type = R_STRING_TYPE_WIDE32 ; } else { bool is_wide = needle + rc + 2 < to && ! w [ 0 ] && w [ 1 ] && ! w [ 2 ] ; str_type = is_wide ? R_STRING_TYPE_WIDE : R_STRING_TYPE_ASCII ; } } else { str_type = R_STRING_TYPE_ASCII ; } } else { str_type = type ; } runes = 0 ; str_start = needle ; for ( rc = i = 0 ; i < sizeof ( tmp ) - 3 && needle < to ; i += rc ) { RRune r = { 0 } ; if ( str_type == R_STRING_TYPE_WIDE32 ) { rc = r_utf32le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc ) { rc = 4 ; } } else if ( str_type == R_STRING_TYPE_WIDE ) { rc = r_utf16le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc == 1 ) { rc = 2 ; } } else { rc = r_utf8_decode ( buf + needle - from , to - needle , & r ) ; if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } } if ( ! rc ) { needle ++ ; break ; } needle += rc ; if ( r_isprint ( r ) && r != '\\\\' ) { if ( str_type == R_STRING_TYPE_WIDE32 ) { if ( r == 0xff ) { r = 0 ; } } rc = r_utf8_encode ( & tmp [ i ] , r ) ; runes ++ ; } else if ( r && r < 0x100 && strchr ( ""\\b\\v\\f\\n\\r\\t\\a\\033\\\\"" , ( char ) r ) ) { if ( ( i + 32 ) < sizeof ( tmp ) && r < 93 ) { tmp [ i + 0 ] = '\\\\' ; tmp [ i + 1 ] = ""abtnvfre"" """" """" ""\\\\"" [ r ] ; } else { break ; } rc = 2 ; runes ++ ; } else { break ; } } tmp [ i ++ ] = '\\0' ; if ( runes >= min ) { if ( str_type == R_STRING_TYPE_ASCII ) { int j ; for ( j = 0 ; j < i ; j ++ ) { char ch = tmp [ j ] ; if ( ch != '\\n' && ch != '\\r' && ch != '\\t' ) { if ( ! IS_PRINTABLE ( tmp [ j ] ) ) { continue ; } } } } RBinString * bs = R_NEW0 ( RBinString ) ; if ( ! bs ) { break ; } bs -> type = str_type ; bs -> length = runes ; bs -> size = needle - str_start ; bs -> ordinal = count ++ ; switch ( str_type ) { case R_STRING_TYPE_WIDE : if ( str_start - from > 1 ) { const ut8 * p = buf + str_start - 2 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 2 ; } } break ; case R_STRING_TYPE_WIDE32 : if ( str_start - from > 3 ) { const ut8 * p = buf + str_start - 4 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 4 ; } } break ; } bs -> paddr = bs -> vaddr = str_start ; bs -> string = r_str_ndup ( ( const char * ) tmp , i ) ; if ( list ) { r_list_append ( list , bs ) ; } else { print_string ( bs , bf ) ; r_bin_string_free ( bs ) ; } } } free ( buf ) ; return count ; }"," 1 ; } int len = to - from ;  = calloc ( len  , 1 )  , buf , len  ) ; while  ) > 5 + rc  bool is_wide32 = (  2 < to ) && (  ! w [  [ 4 ] )"
204,"CWE-119 static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {  vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_set_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }"," * ctx ,  va_list args )"
205,"CWE-200 static int cdrom_ioctl_select_disc ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""enteringCDROM_SELECT_DISC\\n"" ) ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) ) return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) {  if ( ( int ) arg >= cdi -> capacity )  return - EINVAL ; } if ( cdi -> ops -> select_disc ) return cdi -> ops -> select_disc ( cdi , arg ) ; cd_dbg ( CD_CHANGER , ""Usinggenericcdrom_select_disc()\\n"" ) ; return cdrom_select_disc ( cdi , arg ) ; }", { if (  arg >= cdi
206,"CWE-189 int CIFSFindNext ( const int xid , struct cifs_tcon * tcon , __u16 searchHandle , struct cifs_search_info * psrch_inf ) { TRANSACTION2_FNEXT_REQ * pSMB = NULL ; TRANSACTION2_FNEXT_RSP * pSMBr = NULL ; T2_FNEXT_RSP_PARMS * parms ; char * response_data ; int rc = 0 ;  int bytes_returned , name_len ;  __u16 params , byte_count ; cFYI ( 1 , ""InFindNext"" ) ; if ( psrch_inf -> endOfSearch ) return - ENOENT ; rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) return rc ; params = 14 ; byte_count = 0 ; pSMB -> TotalDataCount = 0 ; pSMB -> MaxParameterCount = cpu_to_le16 ( 8 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT ) ; pSMB -> SearchHandle = searchHandle ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ; pSMB -> ResumeKey = psrch_inf -> resume_key ; pSMB -> SearchFlags = cpu_to_le16 ( CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME ) ; name_len = psrch_inf -> resume_name_len ; params += name_len ; if ( name_len < PATH_MAX ) { memcpy ( pSMB -> ResumeFileName , psrch_inf -> presume_name , name_len ) ; byte_count += name_len ; pSMB -> ResumeFileName [ name_len ] = 0 ; pSMB -> ResumeFileName [ name_len + 1 ] = 0 ; } else { rc = - EINVAL ; goto FNext2_err_exit ; } byte_count = params + 1 ; pSMB -> TotalParameterCount = cpu_to_le16 ( params ) ; pSMB -> ParameterCount = pSMB -> TotalParameterCount ; inc_rfc1001_len ( pSMB , byte_count ) ; pSMB -> ByteCount = cpu_to_le16 ( byte_count ) ; rc = SendReceive ( xid , tcon -> ses , ( struct smb_hdr * ) pSMB , ( struct smb_hdr * ) pSMBr , & bytes_returned , 0 ) ; cifs_stats_inc ( & tcon -> num_fnext ) ; if ( rc ) { if ( rc == - EBADF ) { psrch_inf -> endOfSearch = true ; cifs_buf_release ( pSMB ) ; rc = 0 ; } else cFYI ( 1 , ""FindNextreturned=%d"" , rc ) ; } else { rc = validate_t2 ( ( struct smb_t2_rsp * ) pSMBr ) ; if ( rc == 0 ) { unsigned int lnoff ; if ( pSMBr -> hdr . Flags2 & SMBFLG2_UNICODE ) psrch_inf -> unicode = true ; else psrch_inf -> unicode = false ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . ParameterOffset ) ; parms = ( T2_FNEXT_RSP_PARMS * ) response_data ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset ) ; if ( psrch_inf -> smallBuf ) cifs_small_buf_release ( psrch_inf -> ntwrk_buf_start ) ; else cifs_buf_release ( psrch_inf -> ntwrk_buf_start ) ; psrch_inf -> srch_entries_start = response_data ; psrch_inf -> ntwrk_buf_start = ( char * ) pSMB ; psrch_inf -> smallBuf = 0 ; if ( parms -> EndofSearch ) psrch_inf -> endOfSearch = true ; else psrch_inf -> endOfSearch = false ; psrch_inf -> entries_in_buffer = le16_to_cpu ( parms -> SearchCount ) ; psrch_inf -> index_of_last_entry += psrch_inf -> entries_in_buffer ; lnoff = le16_to_cpu ( parms -> LastNameOffset ) ; if ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE < lnoff ) { cERROR ( 1 , ""ignoringcorruptresumename"" ) ; psrch_inf -> last_entry = NULL ; return rc ; } else psrch_inf -> last_entry = psrch_inf -> srch_entries_start + lnoff ; } } FNext2_err_exit : if ( rc != 0 ) cifs_buf_release ( pSMB ) ; return rc ; }", ; int bytes_returned ; unsigned int  name_len ; __u16
207,"CWE-119 TEE_Result syscall_asymm_operate ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * src_data , size_t src_len , void * dst_data , uint64_t * dst_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; uint64_t dlen64 ; size_t dlen ; struct tee_obj * o ; void * label = NULL ; size_t label_len = 0 ; size_t n ; int salt_len ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) src_data , src_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; if ( res != TEE_SUCCESS ) return res ; dlen = dlen64 ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) dst_data , dlen ) ; if ( res != TEE_SUCCESS ) return res ;  params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ;  if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_GENERIC ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_RSA_NOPAD : if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_GENERIC ; } break ; case TEE_ALG_RSAES_PKCS1_V1_5 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : for ( n = 0 ; n < num_params ; n ++ ) { if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { label = params [ n ] . content . ref . buffer ; label_len = params [ n ] . content . ref . length ; break ; } } if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsaes_decrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_BAD_PARAMETERS ; } break ; # if defined ( CFG_CRYPTO_RSASSA_NA1 ) case TEE_ALG_RSASSA_PKCS1_V1_5 : # endif case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : if ( cs -> mode != TEE_MODE_SIGN ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_DSA_SHA1 : case TEE_ALG_DSA_SHA224 : case TEE_ALG_DSA_SHA256 : res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_ECDSA_P192 : case TEE_ALG_ECDSA_P224 : case TEE_ALG_ECDSA_P256 : case TEE_ALG_ECDSA_P384 : case TEE_ALG_ECDSA_P521 : res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; break ; } out : free ( params ) ; if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { TEE_Result res2 ; dlen64 = dlen ; res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; if ( res2 != TEE_SUCCESS ) return res2 ; } return res ; }"," return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;  = malloc ( alloc_size  ) ; if"
208,"CWE-20 pcap_t * pcap_ng_check_header ( const uint8_t * magic , FILE * fp , u_int precision , char * errbuf , int * err ) { bpf_u_int32 magic_int ; size_t amt_read ; bpf_u_int32 total_length ; bpf_u_int32 byte_order_magic ; struct block_header * bhdrp ; struct section_header_block * shbp ; pcap_t * p ; int swapped = 0 ; struct pcap_ng_sf * ps ; int status ; struct block_cursor cursor ; struct interface_description_block * idbp ; * err = 0 ; memcpy ( & magic_int , magic , sizeof ( magic_int ) ) ; if ( magic_int != BT_SHB ) { return ( NULL ) ; } amt_read = fread ( & total_length , 1 , sizeof ( total_length ) , fp ) ; if ( amt_read < sizeof ( total_length ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""errorreadingdumpfile"" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ; if ( amt_read < sizeof ( byte_order_magic ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""errorreadingdumpfile"" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } if ( byte_order_magic != BYTE_ORDER_MAGIC ) { byte_order_magic = SWAPLONG ( byte_order_magic ) ; if ( byte_order_magic != BYTE_ORDER_MAGIC ) { return ( NULL ) ; } swapped = 1 ; total_length = SWAPLONG ( total_length ) ; } if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) || ( total_length > BT_SHB_INSANE_MAX ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE ,  ""SectionHeaderBlockinpcapngdumpfilehasinvalidlength%"" PRIsize ""<_%lu_<%lu(BT_SHB_INSANE_MAX)"" ,  sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ; * err = 1 ; return ( NULL ) ; } p = pcap_open_offline_common ( errbuf , sizeof ( struct pcap_ng_sf ) ) ; if ( p == NULL ) { * err = 1 ; return ( NULL ) ; } p -> swapped = swapped ; ps = p -> priv ; switch ( precision ) { case PCAP_TSTAMP_PRECISION_MICRO : ps -> user_tsresol = 1000000 ; break ; case PCAP_TSTAMP_PRECISION_NANO : ps -> user_tsresol = 1000000000 ; break ; default : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""unknowntimestampresolution%u"" , precision ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } p -> opt . tstamp_precision = precision ; p -> bufsize = 2048 ; if ( p -> bufsize < total_length ) p -> bufsize = total_length ; p -> buffer = malloc ( p -> bufsize ) ; if ( p -> buffer == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""outofmemory"" ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } ps -> max_blocksize = INITIAL_MAX_BLOCKSIZE ; bhdrp = ( struct block_header * ) p -> buffer ; shbp = ( struct section_header_block * ) ( ( u_char * ) p -> buffer + sizeof ( struct block_header ) ) ; bhdrp -> block_type = magic_int ; bhdrp -> total_length = total_length ; shbp -> byte_order_magic = byte_order_magic ; if ( read_bytes ( fp , ( u_char * ) p -> buffer + ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , total_length - ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , 1 , errbuf ) == - 1 ) goto fail ; if ( p -> swapped ) { shbp -> major_version = SWAPSHORT ( shbp -> major_version ) ; shbp -> minor_version = SWAPSHORT ( shbp -> minor_version ) ; } if ( ! ( shbp -> major_version == PCAP_NG_VERSION_MAJOR && shbp -> minor_version == PCAP_NG_VERSION_MINOR ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""unsupportedpcapngsavefileversion%u.%u"" , shbp -> major_version , shbp -> minor_version ) ; goto fail ; } p -> version_major = shbp -> major_version ; p -> version_minor = shbp -> minor_version ; p -> opt . tstamp_precision = precision ; for ( ; ; ) { status = read_block ( fp , p , & cursor , errbuf ) ; if ( status == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""thecapturefilehasnoInterfaceDescriptionBlocks"" ) ; goto fail ; } if ( status == - 1 ) goto fail ; switch ( cursor . block_type ) { case BT_IDB : idbp = get_from_block_data ( & cursor , sizeof ( * idbp ) , errbuf ) ; if ( idbp == NULL ) goto fail ; if ( p -> swapped ) { idbp -> linktype = SWAPSHORT ( idbp -> linktype ) ; idbp -> snaplen = SWAPLONG ( idbp -> snaplen ) ; } if ( ! add_interface ( p , & cursor , errbuf ) ) goto fail ; goto done ; case BT_EPB : case BT_SPB : case BT_PB : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""thecapturefilehasapacketblockbeforeanyInterfaceDescriptionBlocks"" ) ; goto fail ; default : break ; } } done : p -> tzoff = 0 ; p -> linktype = linktype_to_dlt ( idbp -> linktype ) ; p -> snapshot = pcap_adjust_snapshot ( p -> linktype , idbp -> snaplen ) ; p -> linktype_ext = 0 ; if ( MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) > ps -> max_blocksize ) ps -> max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) ; p -> next_packet_op = pcap_ng_next_packet ; p -> cleanup_op = pcap_ng_cleanup ; return ( p ) ; fail : free ( ps -> ifaces ) ; free ( p -> buffer ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; }"," , ""SectionHeaderBlockinpcapngdumpfilehasinvalidlength%"" PRIsize ""<_%u_<%u(BT_SHB_INSANE_MAX)""  , sizeof ("
209,"CWE-476 file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) { bee_t * bee = ic -> bee ; bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ;  if ( bee -> ui -> ft_in_start ) {  return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ; } else { return NULL ; } }", ui -> ft_in_start && bu
210,"CWE-119 GF_Err cat_multiple_files ( GF_ISOFile * dest , char * fileName , u32 import_flags , Double force_fps , u32 frames_per_sample , char * tmp_dir , Bool force_cat , Bool align_timelines , Bool allow_add_in_command ) { CATEnum cat_enum ; char * sep ; cat_enum . dest = dest ; cat_enum . import_flags = import_flags ; cat_enum . force_fps = force_fps ; cat_enum . frames_per_sample = frames_per_sample ; cat_enum . tmp_dir = tmp_dir ; cat_enum . force_cat = force_cat ; cat_enum . align_timelines = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ;  strcpy ( cat_enum . szPath , fileName ) ;  sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ; if ( ! sep ) sep = strrchr ( cat_enum . szPath , '/' ) ; if ( ! sep ) { strcpy ( cat_enum . szPath , ""."" ) ;  strcpy ( cat_enum . szRad1 , fileName ) ;  } else {  strcpy ( cat_enum . szRad1 , sep + 1 ) ;  sep [ 0 ] = 0 ; }  sep = strchr ( cat_enum . szRad1 , '*' ) ;   strcpy ( cat_enum . szRad2 , sep + 1 ) ;  sep [ 0 ] = 0 ;  sep = strchr ( cat_enum . szRad2 , '%' ) ;  if ( ! sep ) sep = strchr ( cat_enum . szRad2 , '#' ) ; if ( ! sep ) sep = strchr ( cat_enum . szRad2 , ':' ) ; strcpy ( cat_enum . szOpt , """" ) ;  if ( sep ) {  strcpy ( cat_enum . szOpt , sep ) ; sep [ 0 ] = 0 ; } return gf_enum_directory ( cat_enum . szPath , 0 , cat_enumerate , & cat_enum , NULL ) ; }"," = allow_add_in_command ; if ( strlen ( fileName ) >= sizeof  ( cat_enum .  cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Filename%sistoolong.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath  ""."" ) ; if ( strlen ( fileName ) >= sizeof  ( cat_enum .  cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Filename%sistoolong.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1  } else { if ( strlen (  sep + 1  + 1 ) >= sizeof  ( cat_enum .  cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Filename%sistoolong.\\n"" , (  sep + 1  + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 )  = 0 ; }  ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Filename%sistoolong.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2  , '%' )  sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalidoption:%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; }"
211,"CWE-125 static int ldp_tlv_print ( netdissect_options * ndo , register const u_char * tptr , u_short msg_tlen ) { struct ldp_tlv_header { uint8_t type [ 2 ] ; uint8_t length [ 2 ] ; } ; const struct ldp_tlv_header * ldp_tlv_header ; u_short tlv_type , tlv_len , tlv_tlen , af , ft_flags ; u_char fec_type ; u_int ui , vc_info_len , vc_info_tlv_type , vc_info_tlv_len , idx ; char buf [ 100 ] ; int i ; ldp_tlv_header = ( const struct ldp_tlv_header * ) tptr ; ND_TCHECK ( * ldp_tlv_header ) ; tlv_len = EXTRACT_16BITS ( ldp_tlv_header -> length ) ; if ( tlv_len + 4 > msg_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t\\tTLVcontentsgopastendofmessage"" ) ) ; return 0 ; } tlv_tlen = tlv_len ; tlv_type = LDP_MASK_TLV_TYPE ( EXTRACT_16BITS ( ldp_tlv_header -> type ) ) ; ND_PRINT ( ( ndo , ""\\n\\t%sTLV(0x%04x),length:%u,Flags:[%sand%sforwardifunknown]"" , tok2str ( ldp_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_tlv_header -> type ) ) ? ""continueprocessing"" : ""ignore"" , LDP_MASK_F_BIT ( EXTRACT_16BITS ( & ldp_tlv_header -> type ) ) ? ""do"" : ""don\'t"" ) ) ; tptr += sizeof ( struct ldp_tlv_header ) ; switch ( tlv_type ) { case LDP_TLV_COMMON_HELLO : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tHoldTime:%us,Flags:[%sHello%s]"" , EXTRACT_16BITS ( tptr ) , ( EXTRACT_16BITS ( tptr + 2 ) & 0x8000 ) ? ""Targeted"" : ""Link"" , ( EXTRACT_16BITS ( tptr + 2 ) & 0x4000 ) ? "",RequestfortargetedHellos"" : """" ) ) ; break ; case LDP_TLV_IPV4_TRANSPORT_ADDR : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tIPv4TransportAddress:%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case LDP_TLV_IPV6_TRANSPORT_ADDR : TLV_TCHECK ( 16 ) ; ND_PRINT ( ( ndo , ""\\n\\tIPv6TransportAddress:%s"" , ip6addr_string ( ndo , tptr ) ) ) ; break ; case LDP_TLV_CONFIG_SEQ_NUMBER : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tSequenceNumber:%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case LDP_TLV_ADDRESS_LIST : TLV_TCHECK ( LDP_TLV_ADDRESS_LIST_AFNUM_LEN ) ; af = EXTRACT_16BITS ( tptr ) ; tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; ND_PRINT ( ( ndo , ""\\n\\tAddressFamily:%s,addresses"" , tok2str ( af_values , ""Unknown(%u)"" , af ) ) ) ; switch ( af ) { case AFNUM_INET : while ( tlv_tlen >= sizeof ( struct in_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlv_tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case AFNUM_INET6 : while ( tlv_tlen >= sizeof ( struct in6_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlv_tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; default : break ; } break ; case LDP_TLV_COMMON_SESSION : TLV_TCHECK ( 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tVersion:%u,Keepalive:%us,Flags:[Downstream%s,LoopDetection%s]"" , EXTRACT_16BITS ( tptr ) , EXTRACT_16BITS ( tptr + 2 ) , ( EXTRACT_16BITS ( tptr + 6 ) & 0x8000 ) ? ""OnDemand"" : ""Unsolicited"" , ( EXTRACT_16BITS ( tptr + 6 ) & 0x4000 ) ? ""Enabled"" : ""Disabled"" ) ) ; break ; case LDP_TLV_FEC : TLV_TCHECK ( 1 ) ; fec_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t%sFEC(0x%02x)"" , tok2str ( ldp_fec_values , ""Unknown"" , fec_type ) , fec_type ) ) ; tptr += 1 ; tlv_tlen -= 1 ; switch ( fec_type ) { case LDP_FEC_WILDCARD : break ; case LDP_FEC_PREFIX : TLV_TCHECK ( 2 ) ; af = EXTRACT_16BITS ( tptr ) ; tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; if ( af == AFNUM_INET ) { i = decode_prefix4 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ; if ( i == - 2 ) goto trunc ; if ( i == - 3 ) ND_PRINT ( ( ndo , "":IPv4prefix(goespastendofTLV)"" ) ) ; else if ( i == - 1 ) ND_PRINT ( ( ndo , "":IPv4prefix(invalidlength)"" ) ) ; else ND_PRINT ( ( ndo , "":IPv4prefix%s"" , buf ) ) ; } else if ( af == AFNUM_INET6 ) { i = decode_prefix6 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ; if ( i == - 2 ) goto trunc ; if ( i == - 3 ) ND_PRINT ( ( ndo , "":IPv4prefix(goespastendofTLV)"" ) ) ; else if ( i == - 1 ) ND_PRINT ( ( ndo , "":IPv6prefix(invalidlength)"" ) ) ; else ND_PRINT ( ( ndo , "":IPv6prefix%s"" , buf ) ) ; } else ND_PRINT ( ( ndo , "":Addressfamily%uprefix"" , af ) ) ; break ; case LDP_FEC_HOSTADDRESS : break ; case LDP_FEC_MARTINI_VC : TLV_TCHECK ( 7 ) ; vc_info_len = * ( tptr + 2 ) ; if ( vc_info_len == 0 ) { ND_PRINT ( ( ndo , "":%s,%scontrolword,group-ID%u,VC-info-length:%u"" , tok2str ( mpls_pw_types_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? """" : ""no"" , EXTRACT_32BITS ( tptr + 3 ) , vc_info_len ) ) ; break ; } TLV_TCHECK ( 11 ) ; ND_PRINT ( ( ndo , "":%s,%scontrolword,group-ID%u,VC-ID%u,VC-info-length:%u"" , tok2str ( mpls_pw_types_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? """" : ""no"" , EXTRACT_32BITS ( tptr + 3 ) , EXTRACT_32BITS ( tptr + 7 ) , vc_info_len ) ) ; if ( vc_info_len < 4 ) { ND_PRINT ( ( ndo , ""(invalid,<4"" ) ) ; return ( tlv_len + 4 ) ; } vc_info_len -= 4 ; tptr += 11 ; tlv_tlen -= 11 ; TLV_TCHECK ( vc_info_len ) ; while ( vc_info_len > 2 ) { vc_info_tlv_type = * tptr ; vc_info_tlv_len = * ( tptr + 1 ) ; if ( vc_info_tlv_len < 2 ) break ; if ( vc_info_len < vc_info_tlv_len ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\tInterfaceParameter:%s(0x%02x),len%u"" , tok2str ( ldp_fec_martini_ifparm_values , ""Unknown"" , vc_info_tlv_type ) , vc_info_tlv_type , vc_info_tlv_len ) ) ; switch ( vc_info_tlv_type ) { case LDP_FEC_MARTINI_IFPARM_MTU : ND_PRINT ( ( ndo , "":%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; case LDP_FEC_MARTINI_IFPARM_DESC : ND_PRINT ( ( ndo , "":"" ) ) ; for ( idx = 2 ; idx < vc_info_tlv_len ; idx ++ ) safeputchar ( ndo , * ( tptr + idx ) ) ; break ; case LDP_FEC_MARTINI_IFPARM_VCCV : ND_PRINT ( ( ndo , ""\\n\\t\\tControlChannels(0x%02x)=[%s]"" , * ( tptr + 2 ) , bittok2str ( ldp_fec_martini_ifparm_vccv_cc_values , ""none"" , * ( tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tCVTypes(0x%02x)=[%s]"" , * ( tptr + 3 ) , bittok2str ( ldp_fec_martini_ifparm_vccv_cv_values , ""none"" , * ( tptr + 3 ) ) ) ) ; break ; default : print_unknown_data ( ndo , tptr + 2 , ""\\n\\t\\t"" , vc_info_tlv_len - 2 ) ; break ; } vc_info_len -= vc_info_tlv_len ; tptr += vc_info_tlv_len ; } break ; } break ; case LDP_TLV_GENERIC_LABEL : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tLabel:%u"" , EXTRACT_32BITS ( tptr ) & 0xfffff ) ) ; break ; case LDP_TLV_STATUS : TLV_TCHECK ( 8 ) ; ui = EXTRACT_32BITS ( tptr ) ; tptr += 4 ; ND_PRINT ( ( ndo , ""\\n\\tStatus:0x%02x,Flags:[%sand%sforward]"" , ui & 0x3fffffff , ui & 0x80000000 ? ""Fatalerror"" : ""AdvisoryNotification"" , ui & 0x40000000 ? ""do"" : ""don\'t"" ) ) ; ui = EXTRACT_32BITS ( tptr ) ; tptr += 4 ; if ( ui ) ND_PRINT ( ( ndo , "",causingMessageID:0x%08x"" , ui ) ) ; break ; case LDP_TLV_FT_SESSION :  TLV_TCHECK ( 8 ) ;  ft_flags = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\tFlags:[%sReconnect,%sSaveState,%sAll-LabelProtection,%sCheckpoint,%sRe-LearnState]"" , ft_flags & 0x8000 ? """" : ""No"" , ft_flags & 0x8 ? """" : ""Don\'t"" , ft_flags & 0x4 ? """" : ""No"" , ft_flags & 0x2 ? ""SequenceNumberedLabel"" : ""AllLabels"" , ft_flags & 0x1 ? """" : ""Don\'t"" ) ) ; tptr += 4 ; ui = EXTRACT_32BITS ( tptr ) ; if ( ui ) ND_PRINT ( ( ndo , "",ReconnectTimeout:%ums"" , ui ) ) ; tptr += 4 ; ui = EXTRACT_32BITS ( tptr ) ; if ( ui ) ND_PRINT ( ( ndo , "",RecoveryTime:%ums"" , ui ) ) ; break ; case LDP_TLV_MTU : TLV_TCHECK ( 2 ) ; ND_PRINT ( ( ndo , ""\\n\\tMTU:%u"" , EXTRACT_16BITS ( tptr ) ) ) ; break ; case LDP_TLV_HOP_COUNT : case LDP_TLV_PATH_VECTOR : case LDP_TLV_ATM_LABEL : case LDP_TLV_FR_LABEL : case LDP_TLV_EXTD_STATUS : case LDP_TLV_RETURNED_PDU : case LDP_TLV_RETURNED_MSG : case LDP_TLV_ATM_SESSION_PARM : case LDP_TLV_FR_SESSION_PARM : case LDP_TLV_LABEL_REQUEST_MSG_ID : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlv_tlen ) ; break ; } return ( tlv_len + 4 ) ; trunc :  ND_PRINT ( ( ndo , ""\\n\\t\\tpacketexceededsnapshot"" ) ) ;  return 0 ; badtlv : ND_PRINT ( ( ndo , ""\\n\\t\\tTLVcontentsgopastendofTLV"" ) ) ; return ( tlv_len + 4 ) ; }"," : TLV_TCHECK ( 12  ) ; ft_flags  ( ndo , ""%s"" , tstr  ) ) ;"
212,"CWE-20 static int snd_hrtimer_start ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ;  hrtimer_cancel ( & stime -> hrt ) ;  hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set ( & stime -> running , 1 ) ; return 0 ; }", 0 ) ; hrtimer_try_to_cancel  ( & stime
213,"CWE-362 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ;  const unsigned char * old_name ;  struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ;  if ( source == target )  return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename ) return - EPERM ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error ) return error ; } } error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) return error ;  old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;  dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } fsnotify_oldname_free ( old_name ) ; return error ; }"," old_dentry ) ;  struct inode *  -> s_max_links ; struct name_snapshot old_name ;  return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir ,  old_dentry -> d_name  d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name  ) ; return"
214,"CWE-264 static int flakey_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct flakey_c * fc = ti -> private ;  return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ;  }"," -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if  ( fc ->  ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl (  -> bdev ,  dev -> mode"
215,"CWE-362 void snd_pcm_period_elapsed ( struct snd_pcm_substream * substream ) { struct snd_pcm_runtime * runtime ; unsigned long flags ; if ( PCM_RUNTIME_CHECK ( substream ) ) return ; runtime = substream -> runtime ; snd_pcm_stream_lock_irqsave ( substream , flags ) ; if ( ! snd_pcm_running ( substream ) || snd_pcm_update_hw_ptr0 ( substream , 1 ) < 0 ) goto _end ; # ifdef CONFIG_SND_PCM_TIMER if ( substream -> timer_running ) snd_timer_interrupt ( substream -> timer , 1 ) ; # endif _end :  snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;  kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;  } "," endif _end :  kill_fasync ( &  POLL_IN ) ; snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;"
216,"CWE-000  void bpf_map_inc ( struct bpf_map * map , bool uref )  {  atomic_inc ( & map -> refcnt ) ;  if ( uref ) atomic_inc ( & map -> usercnt ) ;  } ",    struct bpf_map *  bpf_map_inc ( struct  uref ) { if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec  ( & map  refcnt ) ; return ERR_PTR ( - EBUSY ) ; }  usercnt ) ; return map ;
217,"CWE-264 static int persistent_prepare_exception ( struct dm_exception_store * store , struct dm_exception * e ) {  struct pstore * ps = get_info ( store ) ;  uint32_t stride ; chunk_t next_free ; sector_t size = get_dev_size ( dm_snap_cow ( store -> snap ) -> bdev ) ; if ( size < ( ( ps -> next_free + 1 ) * store -> chunk_size ) ) return - ENOSPC ; e -> new_chunk = ps -> next_free ;  stride = ( ps -> exceptions_per_area + 1 ) ;  next_free = ++ ps -> next_free ; if ( sector_div ( next_free , stride ) == 1 )  ps -> next_free ++ ;  atomic_inc ( & ps -> pending_count ) ; return 0 ; }", ( store )  ; sector_t size  -> next_free ;  ps -> next_free  -> next_free ++ ; skip_metadata ( ps )
218,"CWE-119 static void yv12_extend_frame_top_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 ; unsigned char * dest_ptr1 ; unsigned int Border ; int plane_stride ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; src_ptr1 = ybf -> y_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) Border ; i ++ ) {  vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;  dest_ptr1 += plane_stride ; } plane_stride = ybf -> uv_stride ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) {  vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;  dest_ptr1 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) {  vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;  dest_ptr1 += plane_stride ; } }"," ++ ) { memcpy  ( dest_ptr1 ,  ++ ) { memcpy  ( dest_ptr1 ,  ++ ) { memcpy  ( dest_ptr1 ,"
219,"CWE-119 static int get_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) {  return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_GET_REGS , RTL8150_REQT_READ ,  indx , 0 , data , size , 500 ) ;   } "," data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret =  usb_control_msg ( dev  , 0 , buf  , size ,  500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;"
220,"CWE-125 static int fstring_find_expr ( const char * * str , const char * end , int raw , int recurse_lvl , expr_ty * expression , struct compiling * c , const node * n ) { const char * expr_start ; const char * expr_end ; expr_ty simple_expression ; expr_ty format_spec = NULL ; int conversion = - 1 ; char quote_char = 0 ; int string_type = 0 ; Py_ssize_t nested_depth = 0 ; char parenstack [ MAXLEVEL ] ; if ( recurse_lvl >= 2 ) { ast_error ( c , n , ""f-string:expressionsnestedtoodeeply"" ) ; return - 1 ; } assert ( * * str == '{' ) ; * str += 1 ; expr_start = * str ; for ( ; * str < end ; ( * str ) ++ ) { char ch ; assert ( nested_depth >= 0 ) ; assert ( * str >= expr_start && * str < end ) ; if ( quote_char ) assert ( string_type == 1 || string_type == 3 ) ; else assert ( string_type == 0 ) ; ch = * * str ; if ( ch == '\\\\' ) { ast_error ( c , n , ""f-stringexpressionpart"" ""cannotincludeabackslash"" ) ; return - 1 ; } if ( quote_char ) { if ( ch == quote_char ) { if ( string_type == 3 ) { if ( * str + 2 < end && * ( * str + 1 ) == ch && * ( * str + 2 ) == ch ) { * str += 2 ; string_type = 0 ; quote_char = 0 ; continue ; } } else { quote_char = 0 ; string_type = 0 ; continue ; } } } else if ( ch == '\\'' || ch == \'""\' ) { if ( * str + 2 < end && * ( * str + 1 ) == ch && * ( * str + 2 ) == ch ) { string_type = 3 ; * str += 2 ; } else { string_type = 1 ; } quote_char = ch ; } else if ( ch == '[' || ch == '{' || ch == '(' ) { if ( nested_depth >= MAXLEVEL ) { ast_error ( c , n , ""f-string:toomanynestedparenthesis"" ) ; return - 1 ; } parenstack [ nested_depth ] = ch ; nested_depth ++ ; } else if ( ch == '#' ) { ast_error ( c , n , ""f-stringexpressionpartcannotinclude\'#\'"" ) ; return - 1 ; } else if ( nested_depth == 0 && ( ch == '!' || ch == ':' || ch == '}' ) ) { if ( ch == '!' && * str + 1 < end && * ( * str + 1 ) == '=' ) { continue ; } break ; } else if ( ch == ']' || ch == '}' || ch == ')' ) { if ( ! nested_depth ) { ast_error ( c , n , ""f-string:unmatched\'%c\'"" , ch ) ; return - 1 ; } nested_depth -- ; int opening = parenstack [ nested_depth ] ; if ( ! ( ( opening == '(' && ch == ')' ) || ( opening == '[' && ch == ']' ) || ( opening == '{' && ch == '}' ) ) ) { ast_error ( c , n , ""f-string:closingparenthesis\'%c\'"" ""doesnotmatchopeningparenthesis\'%c\'"" , ch , opening ) ; return - 1 ; } } else { } } expr_end = * str ; if ( quote_char ) { ast_error ( c , n , ""f-string:unterminatedstring"" ) ; return - 1 ; } if ( nested_depth ) { int opening = parenstack [ nested_depth - 1 ] ; ast_error ( c , n , ""f-string:unmatched\'%c\'"" , opening ) ; return - 1 ; } if ( * str >= end ) goto unexpected_end_of_string ; simple_expression = fstring_compile_expr ( expr_start , expr_end , c , n ) ; if ( ! simple_expression ) return - 1 ; if ( * * str == '!' ) { * str += 1 ; if ( * str >= end ) goto unexpected_end_of_string ; conversion = * * str ; * str += 1 ; if ( ! ( conversion == 's' || conversion == 'r' || conversion == 'a' ) ) { ast_error ( c , n , ""f-string:invalidconversioncharacter:"" ""expected\'s\',\'r\',or\'a\'"" ) ; return - 1 ; } } if ( * str >= end ) goto unexpected_end_of_string ; if ( * * str == ':' ) { * str += 1 ; if ( * str >= end ) goto unexpected_end_of_string ; format_spec = fstring_parse ( str , end , raw , recurse_lvl + 1 , c , n ) ; if ( ! format_spec ) return - 1 ; } if ( * str >= end || * * str != '}' ) goto unexpected_end_of_string ; assert ( * str < end ) ; assert ( * * str == '}' ) ; * str += 1 ; * expression = FormattedValue ( simple_expression , conversion , format_spec , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; if ( ! * expression ) return - 1 ; return 0 ; unexpected_end_of_string : ast_error ( c , n , ""f-string:expecting\'}\'"" ) ; return - 1 ; }","
"
221,"CWE-119  static int decode_term_subexp ( vp9_reader * r ) {   if ( ! vp9_read_bit ( r ) )   return vp9_read_literal ( r , 4 ) ;   if ( ! vp9_read_bit ( r ) )   return vp9_read_literal ( r , 4 ) + 16 ;   if ( ! vp9_read_bit ( r ) )   return vp9_read_literal ( r , 5 ) + 32 ;  return decode_uniform ( r ) + 64 ; }"," int decode_term_subexp ( vpx_reader  * r )  if ( ! vpx_read_bit  ( r )  ) ) return vpx_read_literal  ( r ,  if ( ! vpx_read_bit  ( r )  ) ) return vpx_read_literal  ( r ,  if ( ! vpx_read_bit  ( r )  ) ) return vpx_read_literal  ( r ,"
222,"CWE-119 void vp8cx_pick_filter_level_fast ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filt_val ;  int best_filt_val = cm -> filter_level ;  YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> sharpness_level != cm -> last_sharpness_level ) { vp8_loop_filter_update_sharpness ( & cm -> lf_info , cm -> sharpness_level ) ; cm -> last_sharpness_level = cm -> sharpness_level ; } if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; else if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; filt_val = cm -> filter_level ; best_filt_val = filt_val ;  vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;  vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; best_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; filt_val -= 1 + ( filt_val > 10 ) ; while ( filt_val >= min_filter_level ) {  vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;  vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err ; best_filt_val = filt_val ; } else break ; filt_val -= 1 + ( filt_val > 10 ) ; } filt_val = cm -> filter_level + 1 + ( filt_val > 10 ) ; if ( best_filt_val == cm -> filter_level ) { best_err -= ( best_err >> 10 ) ; while ( filt_val < max_filter_level ) {  vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;  vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err - ( filt_err >> 10 ) ; best_filt_val = filt_val ; } else break ; filt_val += 1 + ( filt_val > 10 ) ; } } cm -> filter_level = best_filt_val ; if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; cm -> frame_to_show = saved_frame ; }"," ; int best_filt_val  ; YV12_BUFFER_CONFIG *  = filt_val ; yv12_copy_partial_frame  ( saved_frame ,  min_filter_level ) { yv12_copy_partial_frame  ( saved_frame ,  max_filter_level ) { yv12_copy_partial_frame  ( saved_frame ,"
223,"CWE-416 static struct file * path_openat ( int dfd , struct filename * pathname , struct nameidata * nd , const struct open_flags * op , int flags ) { struct file * file ; struct path path ; int opened = 0 ; int error ; file = get_empty_filp ( ) ; if ( IS_ERR ( file ) ) return file ; file -> f_flags = op -> open_flag ; if ( unlikely ( file -> f_flags & __O_TMPFILE ) ) { error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ;  goto out ;  } error = path_init ( dfd , pathname , flags , nd ) ; if ( unlikely ( error ) ) goto out ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; while ( unlikely ( error > 0 ) ) { struct path link = path ; void * cookie ; if ( ! ( nd -> flags & LOOKUP_FOLLOW ) ) { path_put_conditional ( & path , nd ) ; path_put ( & nd -> path ) ; error = - ELOOP ; break ; } error = may_follow_link ( & link , nd ) ; if ( unlikely ( error ) ) break ; nd -> flags |= LOOKUP_PARENT ; nd -> flags &= ~ ( LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_EXCL ) ; error = follow_link ( & link , nd , & cookie ) ; if ( unlikely ( error ) ) break ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; put_link ( nd , & link , cookie ) ; } out : path_cleanup ( nd ) ;  if ( ! ( opened & FILE_OPENED ) ) {  BUG_ON ( ! error ) ; put_filp ( file ) ; } if ( unlikely ( error ) ) { if ( error == - EOPENSTALE ) { if ( flags & LOOKUP_RCU ) error = - ECHILD ; else error = - ESTALE ; } file = ERR_PTR ( error ) ; } return file ; }", ) ; goto out2  ; } error  nd ) ; out2 :
224,"CWE-125 static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) {  value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;   return ( ( unsigned short ) ( value & 0xffff ) ) ;  }  value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |  ( ( unsigned char * ) buffer ) [ 1 ] ) ;  return ( ( unsigned short ) ( value & 0xffff ) ) ;  }", unsigned short )  buffer [ 1  ] << 8 ; value |= ( unsigned short )  buffer [ 0  [ 0 ]  ; return (  ; return (  value & 0xffff  value & 0xffff  ) ; }  unsigned short ) buffer  [ 0 ]  ] << 8 ; value |=  ( unsigned short  unsigned short ) buffer [ 1 ] ; return  & 0xffff )  ; } 
225,"CWE-732 static M_fs_error_t M_fs_copy_file ( const char * path_old , const char * path_new , M_fs_file_mode_t mode , M_fs_progress_cb_t cb , M_fs_progress_flags_t progress_flags , M_fs_progress_t * progress , const M_fs_perms_t * perms ) { M_fs_file_t * fd_old ; M_fs_file_t * fd_new ; M_fs_info_t * info = NULL ; unsigned char temp [ M_FS_BUF_SIZE ] ; size_t read_len ; size_t wrote_len ; size_t wrote_total = 0 ; size_t offset ; M_fs_error_t res ;  if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) {  res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } } res = M_fs_file_open ( & fd_old , path_old , M_FS_BUF_SIZE , M_FS_FILE_MODE_READ | M_FS_FILE_MODE_NOCREATE , NULL ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } if ( perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS ) { res = M_fs_info_file ( & info , fd_old , M_FS_PATH_INFO_FLAGS_NONE ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } perms = M_fs_info_get_perms ( info ) ; } res = M_fs_file_open ( & fd_new , path_new , M_FS_BUF_SIZE , M_FS_FILE_MODE_WRITE | M_FS_FILE_MODE_OVERWRITE , perms ) ; M_fs_info_destroy ( info ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } while ( ( res = M_fs_file_read ( fd_old , temp , sizeof ( temp ) , & read_len , M_FS_FILE_RW_NORMAL ) ) == M_FS_ERROR_SUCCESS && read_len != 0 ) { offset = 0 ; while ( offset < read_len ) { res = M_fs_file_write ( fd_new , temp + offset , read_len - offset , & wrote_len , M_FS_FILE_RW_NORMAL ) ; offset += wrote_len ; wrote_total += wrote_len ; if ( cb ) { M_fs_progress_set_result ( progress , res ) ; if ( progress_flags & M_FS_PROGRESS_SIZE_TOTAL ) { M_fs_progress_set_size_total_progess ( progress , M_fs_progress_get_size_total_progess ( progress ) + wrote_len ) ; } if ( progress_flags & M_FS_PROGRESS_SIZE_CUR ) { M_fs_progress_set_size_current_progress ( progress , wrote_total ) ; } if ( progress_flags & M_FS_PROGRESS_COUNT ) { M_fs_progress_set_count ( progress , M_fs_progress_get_count ( progress ) + 1 ) ; } if ( ! cb ( progress ) ) { res = M_FS_ERROR_CANCELED ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } M_fs_file_close ( fd_old ) ; M_fs_file_close ( fd_new ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } return M_FS_ERROR_SUCCESS ; }", M_fs_error_t res ;  res = M_fs_file_open
226,CWE-476 static int stv06xx_isoc_init ( struct gspca_dev * gspca_dev )  {  struct usb_host_interface * alt ; struct sd * sd = ( struct sd * ) gspca_dev ;  alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ;  alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( sd -> sensor -> max_packet_size [ gspca_dev -> curr_mode ] ) ; return 0 ; }, gspca_dev ) { struct usb_interface_cache * intfc ;  ) gspca_dev ; intfc =  gspca_dev -> dev  [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc  [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV
227,"CWE-20 static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) { GFile * location ; gboolean res ;  if ( ! is_launcher )  { return TRUE ; }  if ( nautilus_file_can_execute ( file ) )  { return TRUE ; } res = FALSE ; if ( nautilus_file_is_local ( file ) ) { location = nautilus_file_get_location ( file ) ; res = nautilus_is_in_system_dir ( location ) ; g_object_unref ( location ) ; } return res ; }"," gboolean res ; g_autofree gchar * trusted = NULL ;  TRUE ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ;  ( file ) && trusted != NULL"
228,"CWE-772 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , sequence , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; data = ( unsigned char * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1"" , MaxTextExtent ) ; info . polarity = MagickFalse ; info . scale = ( Quantum * ) NULL ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . significant_bits = 0 ; info . rescale = MagickFalse ; info . rescale_intercept = 0.0 ; info . rescale_slope = 1.0 ; info . window_center = 0.0 ; info . window_width = 0.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; sequence = MagickFalse ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX%4ld%s-%s(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError ,  ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%dquantum=%d"" ""length=%dgroup=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MaxTextExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corruptedimage-tryingexplicitformat\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MaxTextExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( info . depth > 32 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , """" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MaxTextExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property ) ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; } image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( Quantum ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( Quantum ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; image -> colormap [ i ] . green = ( Quantum ) index ; image -> colormap [ i ] . blue = ( Quantum ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register PixelPacket * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 1 : { SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 2 : { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 3 : { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } default : break ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," , message ) \\\n{  if ( data  ) ) ; \\\n}  char explicit_vr [  image ) ) ThrowDCMException  ( CorruptImageError ,"
229,"CWE-401 static ssize_t qrtr_tun_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct qrtr_tun * tun = filp -> private_data ; size_t len = iov_iter_count ( from ) ; ssize_t ret ; void * kbuf ; kbuf = kzalloc ( len , GFP_KERNEL ) ; if ( ! kbuf ) return - ENOMEM ;  if ( ! copy_from_iter_full ( kbuf , len , from ) )   return - EFAULT ;  ret = qrtr_endpoint_post ( & tun -> ep , kbuf , len ) ;  return ret < 0 ? ret : len ;  }", from ) ) { kfree ( kbuf ) ;  - EFAULT ; }  len ) ; kfree ( kbuf ) ;
230,"CWE-401 struct clock_source * dcn20_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dcn20_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; }  BREAK_TO_DEBUGGER ( ) ;  return NULL ; }", base ; } kfree ( clk_src ) ;
231,"CWE-835 rfbBool ReadFromRFBServer ( rfbClient * client , char * out , unsigned int n )  {  # undef DEBUG_READ_EXACT # ifdef DEBUG_READ_EXACT char * oout = out ; unsigned int nn = n ; rfbClientLog ( ""ReadFromRFBServer%dbytes\\n"" , n ) ; # endif if ( ! out ) return FALSE ; if ( client -> serverPort == - 1 ) { rfbVNCRec * rec = client -> vncRec ; struct timeval tv ; if ( rec -> readTimestamp ) { rec -> readTimestamp = FALSE ; if ( ! fread ( & tv , sizeof ( struct timeval ) , 1 , rec -> file ) ) return FALSE ; tv . tv_sec = rfbClientSwap32IfLE ( tv . tv_sec ) ; tv . tv_usec = rfbClientSwap32IfLE ( tv . tv_usec ) ; if ( rec -> tv . tv_sec != 0 && ! rec -> doNotSleep ) { struct timeval diff ; diff . tv_sec = tv . tv_sec - rec -> tv . tv_sec ; diff . tv_usec = tv . tv_usec - rec -> tv . tv_usec ; if ( diff . tv_usec < 0 ) { diff . tv_sec -- ; diff . tv_usec += 1000000 ; } # ifndef WIN32 sleep ( diff . tv_sec ) ; usleep ( diff . tv_usec ) ; # else Sleep ( diff . tv_sec * 1000 + diff . tv_usec / 1000 ) ; # endif } rec -> tv = tv ; } return ( fread ( out , 1 , n , rec -> file ) != n ? FALSE : TRUE ) ; } if ( n <= client -> buffered ) { memcpy ( out , client -> bufoutptr , n ) ; client -> bufoutptr += n ; client -> buffered -= n ; # ifdef DEBUG_READ_EXACT goto hexdump ; # endif return TRUE ; } memcpy ( out , client -> bufoutptr , client -> buffered ) ; out += client -> buffered ; n -= client -> buffered ; client -> bufoutptr = client -> buf ; client -> buffered = 0 ; if ( n <= RFB_BUF_SIZE ) { while ( client -> buffered < n ) { int i ; if ( client -> tlsSession ) i = ReadFromTLS ( client , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ; else # ifdef LIBVNCSERVER_HAVE_SASL if ( client -> saslconn ) i = ReadFromSASL ( client , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ; else { # endif i = read ( client -> sock , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ; # ifdef WIN32 if ( i < 0 ) errno = WSAGetLastError ( ) ; # endif # ifdef LIBVNCSERVER_HAVE_SASL } # endif if ( i <= 0 ) { if ( i < 0 ) { if ( errno == EWOULDBLOCK || errno == EAGAIN ) {  WaitForMessage ( client , 100000 ) ;  i = 0 ; } else { rfbClientErr ( ""read(%d:%s)\\n"" , errno , strerror ( errno ) ) ; return FALSE ; } } else { if ( errorMessageOnReadFailure ) { rfbClientLog ( ""VNCserverclosedconnection\\n"" ) ; } return FALSE ; } } client -> buffered += i ; } memcpy ( out , client -> bufoutptr , n ) ; client -> bufoutptr += n ; client -> buffered -= n ; } else { while ( n > 0 ) { int i ; if ( client -> tlsSession ) i = ReadFromTLS ( client , out , n ) ; else # ifdef LIBVNCSERVER_HAVE_SASL if ( client -> saslconn ) i = ReadFromSASL ( client , out , n ) ; else # endif i = read ( client -> sock , out , n ) ; if ( i <= 0 ) { if ( i < 0 ) { # ifdef WIN32 errno = WSAGetLastError ( ) ; # endif if ( errno == EWOULDBLOCK || errno == EAGAIN ) {  WaitForMessage ( client , 100000 ) ;  i = 0 ; } else { rfbClientErr ( ""read(%s)\\n"" , strerror ( errno ) ) ; return FALSE ; } } else { if ( errorMessageOnReadFailure ) { rfbClientLog ( ""VNCserverclosedconnection\\n"" ) ; } return FALSE ; } } out += i ; n -= i ; } } # ifdef DEBUG_READ_EXACT hexdump : { unsigned int ii ; for ( ii = 0 ; ii < nn ; ii ++ ) fprintf ( stderr , ""%02x"" , ( unsigned char ) oout [ ii ] ) ; fprintf ( stderr , ""\\n"" ) ; } # endif return TRUE ; }"," n ) { const int USECS_WAIT_PER_RETRY = 100000 ; int retries = 0 ;  EAGAIN ) { if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( ""Connectiontimedout\\n"" ) ; return FALSE ; }  ( client , USECS_WAIT_PER_RETRY  ) ; i  EAGAIN ) { if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( ""Connectiontimedout\\n"" ) ; return FALSE ; }  ( client , USECS_WAIT_PER_RETRY  ) ; i"
232,"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:objectheadersize%unotamultipleof4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:objectheadertooshort%u<%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%sObject(%u)Flags:[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""andforward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""ifunknown],Class-Type:%s(%u),length:%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:objectgoespastendofobjectsTLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4DestAddress:%s,ProtocolID:0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%sFlags:[0x%02x],DestPort%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6DestAddress:%s,ProtocolID:0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%sFlags:[0x%02x],DestPort%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelEndPoint:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6P2MPLSPID:0x%08x,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4P2MPLSPID:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelEndPoint:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4ReceiverAddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6ReceiverAddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4NotifyNodeAddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6NotifyNodeAddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sGeneralizedLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sWavebandID:%u%sStartLabel:%u,StopLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sReservationStyle:%s,Flags:[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%smergecapability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%sMinimumVPI/VCI:%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%sMaximumVPI/VCI:%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%sMinimum/MaximumDLCI:%u/%u,%s%sbitDLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sLSPEncodingType:%s(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%sSwitchingType:%s(%u),PayloadID:%s(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%sSubobjectType:%s,length%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%sERROR:zerolengthEROsubtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""ERROR:length!=8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""ERROR:Prefixlength%u!=32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",%s,%s/%u,Flags:[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""ERROR:length!=8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",Flags:[%s](%#x),Class-Type:%s(%u),%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceInstance:0x%08x,DestinationInstance:0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sRestartTime:%ums,RecoveryTime:%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%sSessionName:"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Flags:[%s](%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) {  subobj_len = EXTRACT_16BITS ( obj_tptr ) ;  subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%sSubobjectType:%s(%u),AF:%s(%u),length:%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ;  if ( subobj_len == 0 )  goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sUNIIPv4TNAaddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sUNIIPv6TNAaddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%sU-bit:%x,Labeltype:%u,Logicalportid:%u,Label:%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%sServicelevel:%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sPrevious/NextInterface:%s,LogicalInterfaceHandle:0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sPrevious/NextInterface:%s,LogicalInterfaceHandle:0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sRefreshPeriod:%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sMsg-Version:%u,length:%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%sServiceType:%s(%u),breakbit%sset,Servicelength:%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,FlowLabel:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Hop-limit:%u,Bandwidth:%.10gMbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%sInclude-any:0x%08x,Exclude-any:0x%08x,Include-all:0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Hop-limit:%u,Bandwidth:%.10gMbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%sIncludeColors:0x%08x,ExcludeColors:0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%sPLR-ID:%s,Avoid-Node-ID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%sCT:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%sErrorNodeAddress:%s,Flags:[0x%02x]%sErrorCode:%s(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",UnknownErrorValue(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%sErrorNodeAddress:%s,Flags:[0x%02x]%sErrorCode:%s(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%sTLVcount:%u,paddingbytes:%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s%sTLV(0x%02x),length:%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sFlags[0x%02x],epoch:%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sMessage-ID0x%08x(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%sKey-ID0x%04x%08x,Sequence0x%08x%08x,Flags[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%sMD5-sum0x%08x%08x%08x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sFlags[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%sAction:%s(%u),Labeltype:%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sStartrange:%u,Endrange:%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sSubchannel#%u:%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSub-LSPdestinationaddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSub-LSPdestinationaddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }", 0 ) { if ( total_subobj_len < 4 ) goto invalid ;  if ( subobj_len < 4 || subobj_len > total_subobj_len  ) goto invalid
233,"CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; proto = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""%s,ethertype%s(0x%04x),length%u:"" , tok2str ( chdlc_cast_values , ""0x%02x"" , p [ 0 ] ) , tok2str ( ethertype_values , ""Unknown"" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 )  isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;  else  isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;  break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""unknownCHDLCprotocol(0x%04x)"" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ; }"," length - 1  ) ; else  p , length  ) ; break"
234,"CWE-000 bool_t auth_gssapi_unwrap_data ( OM_uint32 * major , OM_uint32 * minor , gss_ctx_id_t context , uint32_t seq_num , XDR * in_xdrs , bool_t ( * xdr_func ) ( ) , caddr_t xdr_ptr ) { gss_buffer_desc in_buf , out_buf ; XDR temp_xdrs ; uint32_t verf_seq_num ; int conf , qop ; unsigned int length ; PRINTF ( ( ""gssapi_unwrap_data:starting\\n"" ) ) ; * major = GSS_S_COMPLETE ; * minor = 0 ; in_buf . value = NULL ; out_buf . value = NULL ; if ( ! xdr_bytes ( in_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ) { PRINTF ( ( ""gssapi_unwrap_data:deserializingencrypteddatafailed\\n"" ) ) ; temp_xdrs . x_op = XDR_FREE ; ( void ) xdr_bytes ( & temp_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ; return FALSE ; } in_buf . length = length ; * major = gss_unseal ( minor , context , & in_buf , & out_buf , & conf , & qop ) ; free ( in_buf . value ) ; if ( * major != GSS_S_COMPLETE ) return FALSE ; PRINTF ( ( ""gssapi_unwrap_data:%llubytesdata,%llubytessealed\\n"" , ( unsigned long long ) out_buf . length , ( unsigned long long ) in_buf . length ) ) ; xdrmem_create ( & temp_xdrs , out_buf . value , out_buf . length , XDR_DECODE ) ; if ( ! xdr_u_int32 ( & temp_xdrs , & verf_seq_num ) ) { PRINTF ( ( ""gssapi_unwrap_data:deserializingverf_seq_numfailed\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } if ( verf_seq_num != seq_num ) { PRINTF ( ( ""gssapi_unwrap_data:seq%dspecified,read%d\\n"" , seq_num , verf_seq_num ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( ""gssapi_unwrap_data:unwrapseq_num%dokay\\n"" , verf_seq_num ) ) ; if ( ! ( * xdr_func ) ( & temp_xdrs , xdr_ptr ) ) { PRINTF ( ( ""gssapi_unwrap_data:deserializingargumentsfailed\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ;  xdr_free ( xdr_func , xdr_ptr ) ;  XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( ""gssapi_unwrap_data:succeeding\\n\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return TRUE ; }", out_buf ) ;  XDR_DESTROY ( &
235,"CWE-119 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) {  c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ;   aligned_height = FFALIGN ( c -> height , 16 ) ;  av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }"," c -> width + 15  , 16 )  , 16 ) * 3 ; aligned_height =  c -> height  c -> height + 15  ; av_free ("
236,"CWE-254 void impeg2d_peek_next_start_code ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) )  { impeg2d_bit_stream_get ( ps_stream , 8 ) ; } return ; }", s_bit_stream . u4_offset <  ps_dec -> s_bit_stream
237,"CWE-285 int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) return - E2BIG ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ;  error = posix_acl_equiv_mode ( acl , & mode ) ;  if ( error < 0 ) return error ; if ( error == 0 ) acl = NULL ;  if ( mode != inode -> i_mode ) {  inode -> i_mode = mode ; mark_inode_dirty ( inode ) ;  }  } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , GFP_NOFS ) ; if ( data == NULL ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = NULL ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }"," ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error  ; if (  -> i_mode )  mark_inode_dirty ( inode  inode ) ;  } if ("
238,"CWE-119 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ;  SDev = cd -> device ;  retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen ,  ( unsigned char * ) cgc -> sense , & sshdr ,  cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""discchangedetected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROMnotreadyyet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROMnotready.Makesurethere"" ""isadiscinthedrive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }"," = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ;  cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer  -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( *  cgc -> sense  cgc -> sense )  ) ; if"
239,"CWE-295 void main_cleanup ( ) { # ifdef USE_OS_THREADS CLI * c ; unsigned i , threads ; THREAD_ID * thread_list ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_THREAD_LIST ] ) ; threads = 0 ; for ( c = thread_head ; c ; c = c -> thread_next ) threads ++ ; thread_list = str_alloc ( ( threads + 1 ) * sizeof ( THREAD_ID ) ) ; i = 0 ; for ( c = thread_head ; c ; c = c -> thread_next ) { thread_list [ i ++ ] = c -> thread_id ; s_log ( LOG_DEBUG , ""Terminatingathreadfor[%s]"" , c -> opt -> servname ) ; } if ( cron_thread_id ) { thread_list [ threads ++ ] = cron_thread_id ; s_log ( LOG_DEBUG , ""Terminatingthecronthread"" ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_THREAD_LIST ] ) ; if ( threads ) { s_log ( LOG_NOTICE , ""Terminating%uservicethread(s)"" , threads ) ; writesocket ( terminate_pipe [ 1 ] , """" , 1 ) ; for ( i = 0 ; i < threads ; ++ i ) { # ifdef USE_PTHREAD if ( pthread_join ( thread_list [ i ] , NULL ) ) s_log ( LOG_ERR , ""pthread_join()failed"" ) ; # endif # ifdef USE_WIN32 if ( WaitForSingleObject ( thread_list [ i ] , INFINITE ) == WAIT_FAILED ) ioerror ( ""WaitForSingleObject"" ) ; if ( ! CloseHandle ( thread_list [ i ] ) ) ioerror ( ""CloseHandle"" ) ; # endif } s_log ( LOG_NOTICE , ""Servicethreadsterminated"" ) ; } str_free ( thread_list ) ; # endif unbind_ports ( ) ; s_poll_free ( fds ) ; fds = NULL ; # if 0 str_stats ( ) ; # endif  log_flush ( LOG_MODE_ERROR ) ;  log_close ( SINK_SYSLOG | SINK_OUTFILE ) ; }", endif log_flush ( LOG_MODE_BUFFER  ) ; log_close
240,"CWE-119 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } }  }  else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbsinslice:%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ;  ps_dec -> u2_cur_slice_num ++ ;   if ( ps_dec -> u4_first_slice_in_pic != 0 )  ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }", } } } ps_dec -> u4_first_slice_in_pic = 0 ;  u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ;  u2_cur_slice_num ++ ; }  ps_dec -> i2_prev_slice_mbx
241,"CWE-119 static struct grub_ext4_extent_header * grub_ext4_find_leaf ( struct grub_ext2_data * data , char * buf , struct grub_ext4_extent_header * ext_block , grub_uint32_t fileblock ) { struct grub_ext4_extent_idx * index ; while ( 1 ) { int i ; grub_disk_addr_t block ; index = ( struct grub_ext4_extent_idx * ) ( ext_block + 1 ) ; if ( grub_le_to_cpu16 ( ext_block -> magic ) != EXT4_EXT_MAGIC ) return 0 ; if ( ext_block -> depth == 0 ) return ext_block ; for ( i = 0 ; i < grub_le_to_cpu16 ( ext_block -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( index [ i ] . block ) ) break ; } if ( -- i < 0 ) return 0 ; block = grub_le_to_cpu16 ( index [ i ] . leaf_hi ) ; block = ( block << 32 ) + grub_le_to_cpu32 ( index [ i ] . leaf ) ; if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) )  return 0 ;  ext_block = ( struct grub_ext4_extent_header * ) buf ; } }", buf ) ) { return 0 ; }  ext_block = (
242,"CWE-000 static uint16_t http_splitline ( struct worker * w , int fd , struct http * hp , const struct http_conn * htc , int h1 , int h2 , int h3 ) { char * p , * q ; CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; Tcheck ( htc -> rxbuf ) ; for ( p = htc -> rxbuf . b ; vct_islws ( * p ) ; p ++ ) continue ; q = p ; for ( ; ! vct_issp ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } hp -> hd [ h1 ] . b = q ; hp -> hd [ h1 ] . e = p ; for ( ; vct_issp ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } q = p ; for ( ; ! vct_islws ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } hp -> hd [ h2 ] . b = q ; hp -> hd [ h2 ] . e = p ; if ( ! Tlen ( hp -> hd [ h2 ] ) ) return ( 400 ) ; for ( ; vct_issp ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } q = p ;  if ( ! vct_iscrlf ( * p ) ) {   for ( ; ! vct_iscrlf ( * p ) ; p ++ )  if ( ! vct_issep ( * p ) && vct_isctl ( * p ) ) return ( 400 ) ; } hp -> hd [ h3 ] . b = q ; hp -> hd [ h3 ] . e = p ; p += vct_skipcrlf ( p ) ; * hp -> hd [ h1 ] . e = '\\0' ; WSLH ( w , fd , hp , h1 ) ; * hp -> hd [ h2 ] . e = '\\0' ; WSLH ( w , fd , hp , h2 ) ; if ( hp -> hd [ h3 ] . e != NULL ) { * hp -> hd [ h3 ] . e = '\\0' ; WSLH ( w , fd , hp , h3 ) ; } return ( http_dissect_hdrs ( w , hp , fd , p , htc ) ) ; }", ! vct_iscrlf (  p ) )  ! vct_iscrlf (  p ) ;
243,"CWE-252 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , ""rdensty:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu"" , & density ) ; break ; } if ( LocaleNCompare ( header , ""rpelcnt:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , ""rorient:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , ""rtype:"" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , ""%lu"" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF )  ( void ) fputc ( c , file ) ;  ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""group4:%s"" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lux%lu"" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lu"" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , ""CALS"" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }"," != EOF ) if (  fputc ( c  , file ) != c ) break"
244,"CWE-787 void mp_decode_to_lua_array ( lua_State * L , mp_cur * c , size_t len ) { assert ( len <= UINT_MAX ) ; int index = 1 ;  lua_newtable ( L ) ;  while ( len -- ) { lua_pushnumber ( L , index ++ ) ; mp_decode_to_lua_type ( L , c ) ; if ( c -> err ) return ; lua_settable ( L , - 3 ) ; } }"," lua_newtable ( L ) ; luaL_checkstack ( L , 1 , ""infunctionmp_decode_to_lua_array"""
245,"CWE-787 static OPJ_BOOL opj_t2_encode_packet ( OPJ_UINT32 tileno , opj_tcd_tile_t * tile , opj_tcp_t * tcp , opj_pi_iterator_t * pi , OPJ_BYTE * dest , OPJ_UINT32 * p_data_written , OPJ_UINT32 length , opj_codestream_info_t * cstr_info , J2K_T2_MODE p_t2_mode , opj_event_mgr_t * p_manager ) { OPJ_UINT32 bandno , cblkno ; OPJ_BYTE * c = dest ; OPJ_UINT32 l_nb_bytes ; OPJ_UINT32 compno = pi -> compno ; OPJ_UINT32 resno = pi -> resno ; OPJ_UINT32 precno = pi -> precno ; OPJ_UINT32 layno = pi -> layno ; OPJ_UINT32 l_nb_blocks ; opj_tcd_band_t * band = 00 ; opj_tcd_cblk_enc_t * cblk = 00 ; opj_tcd_pass_t * pass = 00 ; opj_tcd_tilecomp_t * tilec = & tile -> comps [ compno ] ; opj_tcd_resolution_t * res = & tilec -> resolutions [ resno ] ; opj_bio_t * bio = 00 ; OPJ_BOOL packet_empty = OPJ_TRUE ;  if ( tcp -> csty & J2K_CP_CSTY_SOP ) {  c [ 0 ] = 255 ; c [ 1 ] = 145 ; c [ 2 ] = 0 ; c [ 3 ] = 4 ; # if 0 c [ 4 ] = ( tile -> packno % 65536 ) / 256 ; c [ 5 ] = ( tile -> packno % 65536 ) % 256 ; # else c [ 4 ] = ( tile -> packno >> 8 ) & 0xff ; c [ 5 ] = tile -> packno & 0xff ; # endif c += 6 ; length -= 6 ; } if ( ! layno ) { band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; opj_tgt_reset ( prc -> incltree ) ; opj_tgt_reset ( prc -> imsbtree ) ; l_nb_blocks = prc -> cw * prc -> ch ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { cblk = & prc -> cblks . enc [ cblkno ] ; cblk -> numpasses = 0 ; opj_tgt_setvalue ( prc -> imsbtree , cblkno , band -> numbps - ( OPJ_INT32 ) cblk -> numbps ) ; } } } bio = opj_bio_create ( ) ; if ( ! bio ) { return OPJ_FALSE ; } opj_bio_init_enc ( bio , c , length ) ; band = res -> bands ; for ( bandno = 0 ; bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ , ++ cblk ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { continue ; } packet_empty = OPJ_FALSE ; break ; } if ( ! packet_empty ) { break ; } } opj_bio_write ( bio , packet_empty ? 0 : 1 , 1 ) ; band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; ++ bandno , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! cblk -> numpasses && layer -> numpasses ) { opj_tgt_setvalue ( prc -> incltree , cblkno , ( OPJ_INT32 ) layno ) ; } ++ cblk ; } cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; cblkno ++ ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; OPJ_UINT32 increment = 0 ; OPJ_UINT32 nump = 0 ; OPJ_UINT32 len = 0 , passno ; OPJ_UINT32 l_nb_passes ; if ( ! cblk -> numpasses ) { opj_tgt_encode ( bio , prc -> incltree , cblkno , ( OPJ_INT32 ) ( layno + 1 ) ) ; } else { opj_bio_write ( bio , layer -> numpasses != 0 , 1 ) ; } if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( ! cblk -> numpasses ) { cblk -> numlenbits = 3 ; opj_tgt_encode ( bio , prc -> imsbtree , cblkno , 999 ) ; } opj_t2_putnumpasses ( bio , layer -> numpasses ) ; l_nb_passes = cblk -> numpasses + layer -> numpasses ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { ++ nump ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { increment = ( OPJ_UINT32 ) opj_int_max ( ( OPJ_INT32 ) increment , opj_int_floorlog2 ( ( OPJ_INT32 ) len ) + 1 - ( ( OPJ_INT32 ) cblk -> numlenbits + opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } opj_t2_putcommacode ( bio , ( OPJ_INT32 ) increment ) ; cblk -> numlenbits += increment ; pass = cblk -> passes + cblk -> numpasses ; for ( passno = cblk -> numpasses ; passno < l_nb_passes ; ++ passno ) { nump ++ ; len += pass -> len ; if ( pass -> term || passno == ( cblk -> numpasses + layer -> numpasses ) - 1 ) { opj_bio_write ( bio , ( OPJ_UINT32 ) len , cblk -> numlenbits + ( OPJ_UINT32 ) opj_int_floorlog2 ( ( OPJ_INT32 ) nump ) ) ; len = 0 ; nump = 0 ; } ++ pass ; } ++ cblk ; } } if ( ! opj_bio_flush ( bio ) ) { opj_bio_destroy ( bio ) ; return OPJ_FALSE ; } l_nb_bytes = ( OPJ_UINT32 ) opj_bio_numbytes ( bio ) ; c += l_nb_bytes ; length -= l_nb_bytes ; opj_bio_destroy ( bio ) ;  if ( tcp -> csty & J2K_CP_CSTY_EPH ) {  c [ 0 ] = 255 ; c [ 1 ] = 146 ; c += 2 ; length -= 2 ; } if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> end_ph_pos = ( OPJ_INT32 ) ( c - dest ) ; } band = res -> bands ; for ( bandno = 0 ; ! packet_empty && bandno < res -> numbands ; bandno ++ , ++ band ) { opj_tcd_precinct_t * prc ; if ( opj_tcd_is_band_empty ( band ) ) { continue ; } prc = & band -> precincts [ precno ] ; l_nb_blocks = prc -> cw * prc -> ch ; cblk = prc -> cblks . enc ; for ( cblkno = 0 ; cblkno < l_nb_blocks ; ++ cblkno ) { opj_tcd_layer_t * layer = & cblk -> layers [ layno ] ; if ( ! layer -> numpasses ) { ++ cblk ; continue ; } if ( layer -> len > length ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():only%ubytesremainingin"" ""outputbuffer.%uneeded.\\n"" , length , layer -> len ) ; } return OPJ_FALSE ; } memcpy ( c , layer -> data , layer -> len ) ; cblk -> numpasses += layer -> numpasses ; c += layer -> len ; length -= layer -> len ; if ( cstr_info && cstr_info -> index_write ) { opj_packet_info_t * info_PK = & cstr_info -> tile [ tileno ] . packet [ cstr_info -> packno ] ; info_PK -> disto += layer -> disto ; if ( cstr_info -> D_max < info_PK -> disto ) { cstr_info -> D_max = info_PK -> disto ; } } ++ cblk ; } } assert ( c >= dest ) ; * p_data_written += ( OPJ_UINT32 ) ( c - dest ) ; return OPJ_TRUE ; }"," J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():only%ubytesremainingin"" ""outputbuffer.%uneeded.\\n"" , length , 6 ) ; } return OPJ_FALSE ; }  J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():only%ubytesremainingin"" ""outputbuffer.%uneeded.\\n"" , length , 2 ) ; } return OPJ_FALSE ; }"
246,"CWE-119 static vpx_codec_err_t vp8_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { vpx_codec_err_t res = VPX_CODEC_OK ;  ( void ) data ;  vp8_rtcd ( ) ;  if ( ! ctx -> priv )  {  vpx_codec_mmap_t mmap ;  mmap . id = vp8_mem_req_segs [ 0 ] . id ; mmap . sz = sizeof ( vpx_codec_alg_priv_t ) ; mmap . align = vp8_mem_req_segs [ 0 ] . align ; mmap . flags = vp8_mem_req_segs [ 0 ] . flags ; res = vpx_mmap_alloc ( & mmap ) ; if ( res != VPX_CODEC_OK ) return res ;  vp8_init_ctx ( ctx , & mmap ) ;   ctx -> priv -> alg_priv -> fragments . count = 0 ;   ctx -> priv -> alg_priv -> fragments . enabled =   ( ctx -> priv -> alg_priv -> base . init_flags &  VPX_CODEC_USE_INPUT_FRAGMENTS ) ;  ctx -> priv -> alg_priv -> defer_alloc = 1 ;  } ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads =  ( ctx -> priv -> alg_priv -> base . init_flags &  VPX_CODEC_USE_FRAME_THREADING ) ;  ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads = 0 ;   if ( ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads &&   ( ( ctx -> priv -> alg_priv -> base . init_flags &   VPX_CODEC_USE_ERROR_CONCEALMENT )   || ( ctx -> priv -> alg_priv -> base . init_flags &  VPX_CODEC_USE_INPUT_FRAGMENTS ) ) ) { res = VPX_CODEC_INVALID_PARAM ; } return res ; }", = VPX_CODEC_OK ; vpx_codec_alg_priv_t * priv = NULL ;  ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ;  priv ) {  vp8_init_ctx ( ctx  vp8_init_ctx ( ctx ) ; priv = ( vpx_codec_alg_priv_t * )  ctx -> priv  ctx -> priv ; priv  -> fragments .  = 0 ; priv  -> fragments .  enabled = ( priv  -> base .  VPX_CODEC_USE_INPUT_FRAGMENTS ) ; } else { priv = ( vpx_codec_alg_priv_t * )  ctx -> priv ; } priv  -> yv12_frame_buffers .  -> priv ->  init_flags & VPX_CODEC_USE_FRAME_THREADING  VPX_CODEC_USE_FRAME_THREADING ) ; priv  -> yv12_frame_buffers .  ; if ( priv  -> yv12_frame_buffers .  -> priv ->  init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT  & VPX_CODEC_USE_ERROR_CONCEALMENT ) ||  ( ctx ->  -> priv ->  init_flags & VPX_CODEC_USE_INPUT_FRAGMENTS
247,"CWE-362 int prepare_binprm ( struct linux_binprm * bprm ) {  struct inode * inode = file_inode ( bprm -> file ) ;  umode_t mode = inode -> i_mode ; int retval ;  bprm -> cred -> euid = current_euid ( ) ;  bprm -> cred -> egid = current_egid ( ) ; if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && ! task_no_new_privs ( current ) && kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) ) { if ( mode & S_ISUID ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> euid = inode -> i_uid ; } if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> egid = inode -> i_gid ; } } retval = security_bprm_set_creds ( bprm ) ; if ( retval ) return retval ; bprm -> cred_prepared = 1 ; memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; }", bprm ) {  int retval ;  int retval ; bprm_fill_uid ( bprm ) ;  retval = security_bprm_set_creds
248,"CWE-310 int ssl3_get_cert_verify ( SSL * s ) { EVP_PKEY * pkey = NULL ; unsigned char * p ; int al , ok , ret = 0 ; long n ; int type = 0 , i , j ; X509 * peer ; const EVP_MD * md = NULL ; EVP_MD_CTX mctx ; EVP_MD_CTX_init ( & mctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_VRFY_A , SSL3_ST_SR_CERT_VRFY_B , - 1 , SSL3_RT_MAX_PLAIN_LENGTH , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( s -> session -> peer != NULL ) { peer = s -> session -> peer ; pkey = X509_get_pubkey ( peer ) ; type = X509_certificate_type ( peer , pkey ) ; } else { peer = NULL ; pkey = NULL ; } if ( s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s -> s3 -> tmp . reuse_message = 1 ;  if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) )  { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ; goto f_err ; } ret = 1 ; goto end ; } if ( peer == NULL ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_NO_CLIENT_CERT_RECEIVED ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } if ( ! ( type & EVP_PKT_SIGN ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE ) ; al = SSL_AD_ILLEGAL_PARAMETER ; goto f_err ; } if ( s -> s3 -> change_cipher_spec ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_CCS_RECEIVED_EARLY ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } p = ( unsigned char * ) s -> init_msg ; if ( n == 64 && ( pkey -> type == NID_id_GostR3410_94 || pkey -> type == NID_id_GostR3410_2001 ) ) { i = 64 ; } else { if ( SSL_USE_SIGALGS ( s ) ) { int rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) { al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } else if ( rv == 0 ) { al = SSL_AD_DECODE_ERROR ; goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USINGTLSv1.2HASH%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } n2s ( p , i ) ; n -= 2 ; if ( i > n ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_LENGTH_MISMATCH ) ; al = SSL_AD_DECODE_ERROR ; goto f_err ; } } j = EVP_PKEY_size ( pkey ) ; if ( ( i > j ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_WRONG_SIGNATURE_SIZE ) ; al = SSL_AD_DECODE_ERROR ; goto f_err ; } if ( SSL_USE_SIGALGS ( s ) ) { long hdatalen = 0 ; void * hdata ; hdatalen = BIO_get_mem_data ( s -> s3 -> handshake_buffer , & hdata ) ; if ( hdatalen <= 0 ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_INTERNAL_ERROR ) ; al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""UsingTLS1.2withclientverifyalg%s\\n"" , EVP_MD_name ( md ) ) ; # endif if ( ! EVP_VerifyInit_ex ( & mctx , md , NULL ) || ! EVP_VerifyUpdate ( & mctx , hdata , hdatalen ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_EVP_LIB ) ; al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } if ( EVP_VerifyFinal ( & mctx , p , i , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA ) { i = RSA_verify ( NID_md5_sha1 , s -> s3 -> tmp . cert_verify_md , MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH , p , i , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_RSA_SIGNATURE ) ; goto f_err ; } } else # endif # ifndef OPENSSL_NO_DSA if ( pkey -> type == EVP_PKEY_DSA ) { j = DSA_verify ( pkey -> save_type , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) , SHA_DIGEST_LENGTH , p , i , pkey -> pkey . dsa ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_DSA_SIGNATURE ) ; goto f_err ; } } else # endif # ifndef OPENSSL_NO_ECDSA if ( pkey -> type == EVP_PKEY_EC ) { j = ECDSA_verify ( pkey -> save_type , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) , SHA_DIGEST_LENGTH , p , i , pkey -> pkey . ec ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_ECDSA_SIGNATURE ) ; goto f_err ; } } else # endif if ( pkey -> type == NID_id_GostR3410_94 || pkey -> type == NID_id_GostR3410_2001 ) { unsigned char signature [ 64 ] ; int idx ; EVP_PKEY_CTX * pctx = EVP_PKEY_CTX_new ( pkey , NULL ) ; EVP_PKEY_verify_init ( pctx ) ; if ( i != 64 ) { fprintf ( stderr , ""GOSTsignaturelengthis%d"" , i ) ; } for ( idx = 0 ; idx < 64 ; idx ++ ) { signature [ 63 - idx ] = p [ idx ] ; } j = EVP_PKEY_verify ( pctx , signature , 64 , s -> s3 -> tmp . cert_verify_md , 32 ) ; EVP_PKEY_CTX_free ( pctx ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_ECDSA_SIGNATURE ) ; goto f_err ; } } else { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_INTERNAL_ERROR ) ; al = SSL_AD_UNSUPPORTED_CERTIFICATE ; goto f_err ; } ret = 1 ; if ( 0 ) { f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; } end : if ( s -> s3 -> handshake_buffer ) { BIO_free ( s -> s3 -> handshake_buffer ) ; s -> s3 -> handshake_buffer = NULL ; s -> s3 -> flags &= ~ TLS1_FLAGS_KEEP_HANDSHAKE ; } EVP_MD_CTX_cleanup ( & mctx ) ; EVP_PKEY_free ( pkey ) ; return ( ret ) ; }", ; if (  peer != NULL  peer != NULL  ) { al
249,"CWE-119 static vpx_codec_err_t set_encoder_config (  VP9_CONFIG * oxcf ,  const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) {  oxcf -> profile = cfg -> g_profile ;   oxcf -> width = cfg -> g_w ;  oxcf -> height = cfg -> g_h ;  oxcf -> bit_depth = extra_cfg -> bit_depth ;  oxcf -> framerate = ( double ) cfg -> g_timebase . den / cfg -> g_timebase . num ;  if ( oxcf -> framerate > 180 )   oxcf -> framerate = 30 ;  switch ( cfg -> g_pass ) { case VPX_RC_ONE_PASS :  oxcf -> mode = MODE_GOODQUALITY ;  break ; case VPX_RC_FIRST_PASS :  oxcf -> mode = MODE_FIRSTPASS ;  break ; case VPX_RC_LAST_PASS :  oxcf -> mode = MODE_SECONDPASS_BEST ;  break ; } oxcf -> lag_in_frames = cfg -> g_pass == VPX_RC_FIRST_PASS ? 0 : cfg -> g_lag_in_frames ;  oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ;   if ( cfg -> rc_end_usage == VPX_CQ )  oxcf -> end_usage = USAGE_CONSTRAINED_QUALITY ; else if ( cfg -> rc_end_usage == VPX_Q ) oxcf -> end_usage = USAGE_CONSTANT_QUALITY ; else if ( cfg -> rc_end_usage == VPX_CBR ) oxcf -> end_usage = USAGE_STREAM_FROM_SERVER ;  oxcf -> target_bandwidth = cfg -> rc_target_bitrate ;  oxcf -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ;  oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ;   oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ;   oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ;  oxcf -> fixed_q = - 1 ; oxcf -> under_shoot_pct = cfg -> rc_undershoot_pct ; oxcf -> over_shoot_pct = cfg -> rc_overshoot_pct ;  oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ;   oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ;   oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ;  oxcf -> drop_frames_water_mark = cfg -> rc_dropframe_thresh ; oxcf -> two_pass_vbrbias = cfg -> rc_2pass_vbr_bias_pct ; oxcf -> two_pass_vbrmin_section = cfg -> rc_2pass_vbr_minsection_pct ; oxcf -> two_pass_vbrmax_section = cfg -> rc_2pass_vbr_maxsection_pct ; oxcf -> auto_key = cfg -> kf_mode == VPX_KF_AUTO && cfg -> kf_min_dist != cfg -> kf_max_dist ; oxcf -> key_freq = cfg -> kf_max_dist ;  oxcf -> cpu_used = extra_cfg -> cpu_used ;  oxcf -> encode_breakout = extra_cfg -> static_thresh ;  oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ;  oxcf -> noise_sensitivity = extra_cfg -> noise_sensitivity ; oxcf -> sharpness = extra_cfg -> sharpness ; oxcf -> two_pass_stats_in = cfg -> rc_twopass_stats_in ;  oxcf -> output_pkt_list = extra_cfg -> pkt_list ;  oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ; oxcf -> arnr_strength = extra_cfg -> arnr_strength ;  oxcf -> arnr_type = extra_cfg -> arnr_type ;  oxcf -> tuning = extra_cfg -> tuning ;  oxcf -> tile_columns = extra_cfg -> tile_columns ;  oxcf -> tile_rows = extra_cfg -> tile_rows ;  oxcf -> lossless = extra_cfg -> lossless ;  oxcf -> error_resilient_mode = cfg -> g_error_resilient ; oxcf -> frame_parallel_decoding_mode = extra_cfg -> frame_parallel_decoding_mode ; oxcf -> aq_mode = extra_cfg -> aq_mode ; oxcf -> frame_periodic_boost = extra_cfg -> frame_periodic_boost ; oxcf -> ss_number_layers = cfg -> ss_number_layers ;  if ( oxcf -> ss_number_layers > 1 ) {   vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ;   } else if ( oxcf -> ss_number_layers == 1 ) {  oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; } oxcf -> ts_number_layers = cfg -> ts_number_layers ; if ( oxcf -> ts_number_layers > 1 ) { vp9_copy ( oxcf -> ts_target_bitrate , cfg -> ts_target_bitrate ) ; vp9_copy ( oxcf -> ts_rate_decimator , cfg -> ts_rate_decimator ) ; } else if ( oxcf -> ts_number_layers == 1 ) {  oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;  oxcf -> ts_rate_decimator [ 0 ] = 1 ; } return VPX_CODEC_OK ; }"," vpx_codec_err_t set_encoder_config ( VP9EncoderConfig  * oxcf ,  extra_cfg ) { const int is_vbr = cfg -> rc_end_usage == VPX_VBR ; int sl , tl ;  ; oxcf -> max_threads = ( int ) cfg -> g_threads ; oxcf ->  -> bit_depth = cfg -> g_bit_depth ; oxcf -> input_bit_depth = cfg -> g_input_bit_depth ; oxcf -> init_framerate  = ( double  ( oxcf -> init_framerate  > 180 )  ) oxcf -> init_framerate = 30 ; oxcf -> mode = GOOD  ; switch (  : oxcf -> pass = 0  ; break ;  : oxcf -> pass = 1  ; break ;  : oxcf -> pass = 2  ; break ;  ; oxcf -> rc_mode =  cfg -> rc_end_usage  cfg -> rc_end_usage  ; oxcf ->  -> target_bandwidth = 1000 *  ; oxcf -> rc_max_inter_bitrate_pct = extra_cfg -> rc_max_inter_bitrate_pct ; oxcf -> gf_cbr_boost_pct = extra_cfg -> gf_cbr_boost_pct ; oxcf -> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex (  cfg -> rc_min_quantizer  cfg -> rc_min_quantizer )  ; oxcf ->  -> worst_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex (  cfg -> rc_max_quantizer  cfg -> rc_max_quantizer )  ; oxcf ->  -> cq_level = vp9_quantizer_to_qindex (  extra_cfg -> cq_level  extra_cfg -> cq_level )  ; oxcf ->  ; oxcf -> scaled_frame_width = cfg -> rc_scaled_width ; oxcf -> scaled_frame_height = cfg -> rc_scaled_height ; if ( cfg -> rc_resize_allowed == 1 ) { oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ; } else { oxcf -> resize_mode = RESIZE_NONE ; } oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 :  cfg -> rc_buf_sz  ; oxcf -> starting_buffer_level_ms = is_vbr ? 60000 :  cfg -> rc_buf_initial_sz  ; oxcf -> optimal_buffer_level_ms = is_vbr ? 60000 :  cfg -> rc_buf_optimal_sz  ; oxcf -> speed = abs ( extra_cfg -> cpu_used )  ; oxcf ->  ; oxcf -> enable_auto_arf  = extra_cfg ->  -> rc_twopass_stats_in ; # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ; # endif oxcf -> color_space = extra_cfg -> color_space  ; oxcf ->  ; oxcf -> min_gf_interval = extra_cfg -> min_gf_interval ; oxcf -> max_gf_interval = extra_cfg -> max_gf_interval  ; oxcf ->  ; oxcf -> content = extra_cfg -> content ; oxcf ->  ; oxcf ->  error_resilient_mode = cfg  -> ss_number_layers ; oxcf -> ts_number_layers = cfg -> ts_number_layers ; oxcf -> temporal_layering_mode = ( enum vp9e_temporal_layering_mode ) cfg -> temporal_layering_mode ; for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ sl ] = cfg -> ss_enable_auto_alt_ref [ sl ] ; # endif for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { oxcf -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] = 1000 * cfg -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] ; } } if  ( oxcf ->  oxcf -> ss_number_layers == 1 && oxcf -> pass != 0 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ; # endif } if ( oxcf -> ts_number_layers  1 ) { for ( tl = 0 ; tl < VPX_TS_MAX_LAYERS ; ++ tl ) { oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ; }  } else if  ( oxcf ->  ts_number_layers == 1  { oxcf ->  ts_rate_decimator [ 0"
250,"CWE-119 static int get_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) {  int ret ;  ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 ,  indx , data , size , 1000 ) ;  if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%sreturned%d\\n"" , __func__ , ret ) ;  return ret ;  }"," data ) { u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM  ; ret =  , indx , buf  , size ,  ret ) ; else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ;"
251,"CWE-835 static int resp_get_length ( netdissect_options * ndo , register const u_char * bp , int len , const u_char * * endp ) { int result ; u_char c ; int saw_digit ; int neg ; int too_large ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; too_large = 0 ; neg = 0 ; if ( * bp == '-' ) { neg = 1 ; bp ++ ; len -- ; } result = 0 ; saw_digit = 0 ; for ( ; ; ) { if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; c = * bp ; if ( ! ( c >= '0' && c <= '9' ) ) {  if ( ! saw_digit )   goto invalid ;  break ; } c -= '0' ; if ( result > ( INT_MAX / 10 ) ) { too_large = 1 ; } else { result *= 10 ; if ( result == INT_MAX && c > ( INT_MAX % 10 ) ) { too_large = 1 ; } else result += c ; } bp ++ ; len -- ; saw_digit = 1 ; } if ( ! saw_digit ) goto invalid ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ;  if ( * bp != '\\r' )   goto invalid ;  bp ++ ; len -- ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ;  if ( * bp != '\\n' )   goto invalid ;  bp ++ ; len -- ; * endp = bp ; if ( neg ) { if ( too_large || result != 1 ) return ( - 4 ) ; result = - 1 ; } return ( too_large ? - 3 : result ) ; trunc :  return ( - 2 ) ;  invalid :  return ( - 5 ) ;  }", ! saw_digit ) { bp ++ ;  goto invalid ; }  != '\\r' ) { bp ++ ;  goto invalid ; }  != '\\n' ) { bp ++ ;  goto invalid ; }  ; trunc : * endp = bp ;  ; invalid : * endp = bp ;
252,"CWE-125 int rt6_print ( netdissect_options * ndo , register const u_char * bp , const u_char * bp2 _U_ ) { register const struct ip6_rthdr * dp ; register const struct ip6_rthdr0 * dp0 ; register const u_char * ep ; int i , len ; register const struct in6_addr * addr ; dp = ( const struct ip6_rthdr * ) bp ;  len = dp -> ip6r_len ;  ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; ND_PRINT ( ( ndo , ""srcrt(len=%d"" , dp -> ip6r_len ) ) ; ND_PRINT ( ( ndo , "",type=%d"" , dp -> ip6r_type ) ) ; ND_PRINT ( ( ndo , "",segleft=%d"" , dp -> ip6r_segleft ) ) ; switch ( dp -> ip6r_type ) { case IPV6_RTHDR_TYPE_0 : case IPV6_RTHDR_TYPE_2 : dp0 = ( const struct ip6_rthdr0 * ) dp ; ND_TCHECK ( dp0 -> ip6r0_reserved ) ; if ( dp0 -> ip6r0_reserved || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",rsv=0x%0x"" , EXTRACT_32BITS ( & dp0 -> ip6r0_reserved ) ) ) ; } if ( len % 2 == 1 ) goto trunc ; len >>= 1 ; addr = & dp0 -> ip6r0_addr [ 0 ] ; for ( i = 0 ; i < len ; i ++ ) { if ( ( const u_char * ) ( addr + 1 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , "",[%d]%s"" , i , ip6addr_string ( ndo , addr ) ) ) ; addr ++ ; } ND_PRINT ( ( ndo , "")"" ) ) ; return ( ( dp0 -> ip6r0_len + 1 ) << 3 ) ; break ; default : goto trunc ; break ; } trunc : ND_PRINT ( ( ndo , ""[|srcrt]"" ) ) ; return - 1 ; }", ) bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ;  dp -> ip6r_len  ; ND_PRINT (
253,"CWE-252 size_t _dl_dst_count ( const char * name , int is_path ) {  size_t cnt = 0 ;  do { size_t len = 1 ;  if ( ( ( ( ! __libc_enable_secure   && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 )  || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( ! __libc_enable_secure  && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 )  || ( strncmp ( & name [ 2 ] , ""PLATFORM}"" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) ++ cnt ; name = strchr ( name + len , '$' ) ; } while ( name != NULL ) ; return cnt ; }"," is_path ) { const char * const start = name ;  ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == '\\0' || ( is_path && name [ 7 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) && ( len = 7 ) != 0 ) || (  strncmp ( &  1 ] , ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 &&  ( ! __libc_enable_secure  ( ! __libc_enable_secure || ( ( name [ 9 ] == '\\0' || ( is_path && name [ 9 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) )  && ( len"
254,"CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ;  retval = generic_gss_oid_decompose ( minor_status ,  GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }", = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
255,"CWE-399 static void update_exception_bitmap ( struct kvm_vcpu * vcpu ) { u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) |  ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ;  if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ; if ( to_vmx ( vcpu ) -> rmode . vm86_active ) eb = ~ 0 ; if ( enable_ept ) eb &= ~ ( 1u << PF_VECTOR ) ; if ( vcpu -> fpu_active ) eb &= ~ ( 1u << NM_VECTOR ) ; if ( is_guest_mode ( vcpu ) ) eb |= get_vmcs12 ( vcpu ) -> exception_bitmap ; vmcs_write32 ( EXCEPTION_BITMAP , eb ) ; }", 1u << DB_VECTOR ) | ( 1u << AC_VECTOR
256,"CWE-200 static int get_bitmap_file ( struct mddev * mddev , void __user * arg ) { mdu_bitmap_file_t * file = NULL ; char * ptr ; int err ;  file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ;  if ( ! file ) return - ENOMEM ; err = 0 ; spin_lock ( & mddev -> lock ) ; if ( ! mddev -> bitmap_info . file ) file -> pathname [ 0 ] = '\\0' ; else if ( ( ptr = file_path ( mddev -> bitmap_info . file , file -> pathname , sizeof ( file -> pathname ) ) ) , IS_ERR ( ptr ) ) err = PTR_ERR ( ptr ) ; else memmove ( file -> pathname , ptr , sizeof ( file -> pathname ) - ( ptr - file -> pathname ) ) ; spin_unlock ( & mddev -> lock ) ; if ( err == 0 && copy_to_user ( arg , file , sizeof ( * file ) ) ) err = - EFAULT ; kfree ( file ) ; return err ; }", ; file = kzalloc  ( sizeof (
257,"CWE-000 PUBLIC void mprDefaultLogHandler ( cchar * tags , int level , cchar * msg ) { MprFile * file ; char tbuf [ 128 ] ; static int check = 0 ; if ( ( file = MPR -> logFile ) == 0 ) { return ; } if ( MPR -> logBackup && MPR -> logSize && ( check ++ % 1000 ) == 0 ) { backupLog ( ) ; } if ( tags && * tags ) { if ( MPR -> flags & MPR_LOG_DETAILED ) { fmt ( tbuf , sizeof ( tbuf ) , ""%s%d%s,"" , mprGetDate ( MPR_LOG_DATE ) , level , tags ) ; mprWriteFileString ( file , tbuf ) ; } else if ( MPR -> flags & MPR_LOG_TAGGED ) { if ( schr ( tags , '' ) ) {  tags = stok ( sclone ( tags ) , """" , NULL ) ;  } if ( ! isupper ( ( uchar ) * tags ) ) { tags = stitle ( tags ) ; } mprWriteFileFmt ( file , ""%12s"" , sfmt ( ""[%s]"" , tags ) ) ; } } mprWriteFileString ( file , msg ) ; mprWriteFileString ( file , ""\\n"" ) ; # if ME_MPR_OSLOG if ( level == 0 ) { mprWriteToOsLog ( sfmt ( ""%s:%d%s:%s"" , MPR -> name , level , tags , msg ) , level ) ; } # endif }", { tags = ssplit  ( sclone (
258,"CWE-200 static void send_ssi_file ( struct mg_connection * conn , const char * path , struct mg_file * filep , int include_level ) { char buf [ MG_BUF_LEN ] ; int ch , offset , len , in_tag , in_ssi_tag ; if ( include_level > 10 ) { mg_cry_internal ( conn , ""SSI#includelevelistoodeep(%s)"" , path ) ; return ; } in_tag = in_ssi_tag = len = offset = 0 ; while ( ( ch = mg_fgetc ( filep , offset ++ ) ) != EOF ) { if ( in_tag ) { if ( ch == '>' ) { buf [ len ++ ] = '>' ; if ( in_ssi_tag ) { buf [ len ] = 0 ;  if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) {  do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ; # if ! defined ( NO_POPEN )  } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) {  do_ssi_exec ( conn , buf + 9 ) ; # endif } else { mg_cry_internal ( conn , ""%s:unknownSSI"" ""command:\\""%s\\"""" , path , buf ) ; } len = 0 ; in_ssi_tag = in_tag = 0 ; } else { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; in_tag = 0 ; } } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( ( len == 5 ) && ! memcmp ( buf , ""<!--#"" , 5 ) ) { in_ssi_tag = 1 ; } if ( ( len + 2 ) > ( int ) sizeof ( buf ) ) { mg_cry_internal ( conn , ""%s:tagistoolarge"" , path ) ; return ; } } } else { if ( ch == '<' ) { in_tag = 1 ; if ( len > 0 ) { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; } len = 1 ; buf [ 0 ] = '<' ; } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( len == ( int ) sizeof ( buf ) ) { mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; } } } } if ( len > 0 ) { mg_write ( conn , buf , ( size_t ) len ) ; } }", ; if ( ( len > 12 ) &&  else if ( ( len > 9 ) &&
259,"CWE-476 static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , ""Attempttoalias%stonon-existentkey%s;Ignored\\n"" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , ""Attempttocreatealiaswiththenameofarealkey;"" ""Alias\\""%s=%s\\""ignored\\n"" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ;  }  i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } }  keymap -> num_key_aliases = num_key_aliases ;  keymap -> key_aliases = key_aliases ; return true ; }", return false ;  i = 0  ; } } }
260,"CWE-273 char * * glob_vector ( pat , dir , flags ) char * pat ; char * dir ; int flags ; { DIR * d ; register struct dirent * dp ; struct globval * lastlink , * e , * dirlist ; register struct globval * nextlink ; register char * nextname , * npat , * subdir ; unsigned int count ; int lose , skip , ndirs , isdir , sdlen , add_current , patlen ; register char * * name_vector ; register unsigned int i ; int mflags ; int pflags ;  int nalloca ;  struct globval * firstmalloc , * tmplink ; char * convfn ; lastlink = 0 ; count = lose = skip = add_current = 0 ; firstmalloc = 0 ; nalloca = 0 ; name_vector = NULL ; if ( pat == 0 || * pat == '\\0' ) { if ( glob_testdir ( dir , 0 ) < 0 ) return ( ( char * * ) & glob_error_return ) ; nextlink = ( struct globval * ) alloca ( sizeof ( struct globval ) ) ; if ( nextlink == NULL ) return ( ( char * * ) NULL ) ; nextlink -> next = ( struct globval * ) 0 ; nextname = ( char * ) malloc ( 1 ) ; if ( nextname == 0 ) lose = 1 ; else { lastlink = nextlink ; nextlink -> name = nextname ; nextname [ 0 ] = '\\0' ; count = 1 ; } skip = 1 ; } patlen = ( pat && * pat ) ? strlen ( pat ) : 0 ;  if ( skip == 0 && glob_pattern_p ( pat ) == 0 )  { int dirlen ; struct stat finfo ; if ( glob_testdir ( dir , 0 ) < 0 ) return ( ( char * * ) & glob_error_return ) ; dirlen = strlen ( dir ) ; nextname = ( char * ) malloc ( dirlen + patlen + 2 ) ; npat = ( char * ) malloc ( patlen + 1 ) ; if ( nextname == 0 || npat == 0 ) { FREE ( nextname ) ; FREE ( npat ) ; lose = 1 ; } else { strcpy ( npat , pat ) ; dequote_pathname ( npat ) ; strcpy ( nextname , dir ) ; nextname [ dirlen ++ ] = '/' ; strcpy ( nextname + dirlen , npat ) ; if ( GLOB_TESTNAME ( nextname ) >= 0 ) { free ( nextname ) ; nextlink = ( struct globval * ) alloca ( sizeof ( struct globval ) ) ; if ( nextlink ) { nextlink -> next = ( struct globval * ) 0 ; lastlink = nextlink ; nextlink -> name = npat ; count = 1 ; } else { free ( npat ) ; lose = 1 ; } } else { free ( nextname ) ; free ( npat ) ; } } skip = 1 ; } if ( skip == 0 ) { # if defined ( OPENDIR_NOT_ROBUST ) if ( glob_testdir ( dir , 0 ) < 0 ) return ( ( char * * ) & glob_error_return ) ; # endif d = opendir ( dir ) ; if ( d == NULL ) return ( ( char * * ) & glob_error_return ) ; mflags = ( noglob_dot_filenames ? FNM_PERIOD : 0 ) | FNM_PATHNAME ; # ifdef FNM_CASEFOLD if ( glob_ignore_case ) mflags |= FNM_CASEFOLD ; # endif if ( extended_glob ) mflags |= FNM_EXTMATCH ; add_current = ( ( flags & ( GX_ALLDIRS | GX_ADDCURDIR ) ) == ( GX_ALLDIRS | GX_ADDCURDIR ) ) ; while ( 1 ) { if ( interrupt_state || terminating_signal ) { lose = 1 ; break ; } else if ( signal_is_pending ( SIGINT ) ) { lose = 1 ; break ; } dp = readdir ( d ) ; if ( dp == NULL ) break ; if ( REAL_DIR_ENTRY ( dp ) == 0 ) continue ; # if 0 if ( dp -> d_name == 0 || * dp -> d_name == 0 ) continue ; # endif # if HANDLE_MULTIBYTE if ( MB_CUR_MAX > 1 && mbskipname ( pat , dp -> d_name , flags ) ) continue ; else # endif if ( skipname ( pat , dp -> d_name , flags ) ) continue ; if ( flags & ( GX_MATCHDIRS | GX_ALLDIRS ) ) { pflags = ( flags & GX_ALLDIRS ) ? MP_RMDOT : 0 ; if ( flags & GX_NULLDIR ) pflags |= MP_IGNDOT ; subdir = sh_makepath ( dir , dp -> d_name , pflags ) ; isdir = glob_testdir ( subdir , flags ) ; if ( isdir < 0 && ( flags & GX_MATCHDIRS ) ) { free ( subdir ) ; continue ; } } if ( flags & GX_ALLDIRS ) { if ( isdir == 0 ) { dirlist = finddirs ( pat , subdir , ( flags & ~ GX_ADDCURDIR ) , & e , & ndirs ) ; if ( dirlist == & finddirs_error_return ) { free ( subdir ) ; lose = 1 ; break ; } if ( ndirs ) { if ( firstmalloc == 0 ) firstmalloc = e ; e -> next = lastlink ; lastlink = dirlist ; count += ndirs ; } } nextlink = ( struct globval * ) malloc ( sizeof ( struct globval ) ) ; if ( firstmalloc == 0 ) firstmalloc = nextlink ; sdlen = strlen ( subdir ) ; nextname = ( char * ) malloc ( sdlen + 1 ) ; if ( nextlink == 0 || nextname == 0 ) { FREE ( nextlink ) ; FREE ( nextname ) ; free ( subdir ) ; lose = 1 ; break ; } nextlink -> next = lastlink ; lastlink = nextlink ; nextlink -> name = nextname ; bcopy ( subdir , nextname , sdlen + 1 ) ; free ( subdir ) ; ++ count ; continue ; } else if ( flags & GX_MATCHDIRS ) free ( subdir ) ; convfn = fnx_fromfs ( dp -> d_name , D_NAMLEN ( dp ) ) ; if ( strmatch ( pat , convfn , mflags ) != FNM_NOMATCH ) { if ( nalloca < ALLOCA_MAX ) { nextlink = ( struct globval * ) alloca ( sizeof ( struct globval ) ) ; nalloca += sizeof ( struct globval ) ; } else { nextlink = ( struct globval * ) malloc ( sizeof ( struct globval ) ) ; if ( firstmalloc == 0 ) firstmalloc = nextlink ; } nextname = ( char * ) malloc ( D_NAMLEN ( dp ) + 1 ) ; if ( nextlink == 0 || nextname == 0 ) { FREE ( nextlink ) ; FREE ( nextname ) ; lose = 1 ; break ; } nextlink -> next = lastlink ; lastlink = nextlink ; nextlink -> name = nextname ; bcopy ( dp -> d_name , nextname , D_NAMLEN ( dp ) + 1 ) ; ++ count ; } } ( void ) closedir ( d ) ; } if ( add_current ) { sdlen = strlen ( dir ) ; nextname = ( char * ) malloc ( sdlen + 1 ) ; nextlink = ( struct globval * ) malloc ( sizeof ( struct globval ) ) ; if ( nextlink == 0 || nextname == 0 ) { FREE ( nextlink ) ; FREE ( nextname ) ; lose = 1 ; } else { nextlink -> name = nextname ; nextlink -> next = lastlink ; lastlink = nextlink ; if ( flags & GX_NULLDIR ) nextname [ 0 ] = '\\0' ; else bcopy ( dir , nextname , sdlen + 1 ) ; ++ count ; } } if ( lose == 0 ) { name_vector = ( char * * ) malloc ( ( count + 1 ) * sizeof ( char * ) ) ; lose |= name_vector == NULL ; } if ( lose ) { tmplink = 0 ; while ( lastlink ) { if ( firstmalloc ) { if ( lastlink == firstmalloc ) firstmalloc = 0 ; tmplink = lastlink ; } else tmplink = 0 ; free ( lastlink -> name ) ; lastlink = lastlink -> next ; FREE ( tmplink ) ; } return ( ( char * * ) NULL ) ; } for ( tmplink = lastlink , i = 0 ; i < count ; ++ i ) { name_vector [ i ] = tmplink -> name ; tmplink = tmplink -> next ; } name_vector [ count ] = NULL ; if ( firstmalloc ) { tmplink = 0 ; while ( lastlink ) { tmplink = lastlink ; if ( lastlink == firstmalloc ) lastlink = firstmalloc = 0 ; else lastlink = lastlink -> next ; free ( tmplink ) ; } } return ( name_vector ) ; }", pflags ; int hasglob ; int  : 0 ; hasglob = 0 ;  == 0 && ( hasglob =  ( pat ) ) == 0 || hasglob == 2  ) { int
261,"CWE-125 int WavpackVerifySingleBlock ( unsigned char * buffer , int verify_checksum ) { WavpackHeader * wphdr = ( WavpackHeader * ) buffer ; uint32_t checksum_passed = 0 , bcount , meta_bc ; unsigned char * dp , meta_id , c1 , c2 ; if ( strncmp ( wphdr -> ckID , ""wvpk"" , 4 ) || wphdr -> ckSize + 8 < sizeof ( WavpackHeader ) ) return FALSE ; bcount = wphdr -> ckSize - sizeof ( WavpackHeader ) + 8 ; dp = ( unsigned char * ) ( wphdr + 1 ) ; while ( bcount >= 2 ) { meta_id = * dp ++ ; c1 = * dp ++ ; meta_bc = c1 << 1 ; bcount -= 2 ; if ( meta_id & ID_LARGE ) { if ( bcount < 2 ) return FALSE ; c1 = * dp ++ ; c2 = * dp ++ ; meta_bc += ( ( uint32_t ) c1 << 9 ) + ( ( uint32_t ) c2 << 17 ) ; bcount -= 2 ; } if ( bcount < meta_bc ) return FALSE ; if ( verify_checksum && ( meta_id & ID_UNIQUE ) == ID_BLOCK_CHECKSUM ) { # ifdef BITSTREAM_SHORTS uint16_t * csptr = ( uint16_t * ) buffer ; # else unsigned char * csptr = buffer ; # endif int wcount = ( int ) ( dp - 2 - buffer ) >> 1 ; uint32_t csum = ( uint32_t ) - 1 ; if ( ( meta_id & ID_ODD_SIZE ) || meta_bc < 2 || meta_bc > 4 ) return FALSE ; # ifdef BITSTREAM_SHORTS while ( wcount -- ) csum = ( csum * 3 ) + * csptr ++ ; # else WavpackNativeToLittleEndian ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; while ( wcount -- ) { csum = ( csum * 3 ) + csptr [ 0 ] + ( csptr [ 1 ] << 8 ) ; csptr += 2 ; } WavpackLittleEndianToNative ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; # endif if ( meta_bc == 4 ) {  if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) )  return FALSE ; } else { csum ^= csum >> 16 ;  if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) )  return FALSE ; } checksum_passed ++ ; } bcount -= meta_bc ; dp += meta_bc ; } return ( bcount == 0 ) && ( ! verify_checksum || ! ( wphdr -> flags & HAS_CHECKSUM ) || checksum_passed ) ; }", ( * dp  != ( csum  0xff ) || dp [ 1 ]  != ( (  0xff ) || dp [ 2 ]  != ( (  0xff ) || dp [ 3 ]  != ( (  ( * dp  != ( csum  0xff ) || dp [ 1 ]  != ( (
262,"CWE-310 static unsigned int do_decrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;  # elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;  # else return do_decrypt_fn ( ctx , bx , ax ) ; # endif }"," -> rounds , dec_tables . T  ) ; #  -> rounds , dec_tables . T  ) ; #"
263,"CWE-119 int32_t DownmixLib_Create ( const effect_uuid_t * uuid ,  int32_t sessionId ,   int32_t ioId ,  effect_handle_t * pHandle ) { int ret ; int i ; downmix_module_t * module ; const effect_descriptor_t * desc ; ALOGV ( ""DownmixLib_Create()"" ) ; # ifdef DOWNMIX_TEST_CHANNEL_INDEX ALOGI ( ""DOWNMIX_TEST_CHANNEL_INDEX:shouldwork:"" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; ALOGI ( ""DOWNMIX_TEST_CHANNEL_INDEX:shouldNOTwork:"" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT ) ; # endif if ( pHandle == NULL || uuid == NULL ) { return - EINVAL ; } for ( i = 0 ; i < kNbEffects ; i ++ ) { desc = gDescriptors [ i ] ; if ( memcmp ( uuid , & desc -> uuid , sizeof ( effect_uuid_t ) ) == 0 ) { break ; } } if ( i == kNbEffects ) { return - ENOENT ; } module = malloc ( sizeof ( downmix_module_t ) ) ; module -> itfe = & gDownmixInterface ; module -> context . state = DOWNMIX_STATE_UNINITIALIZED ; ret = Downmix_Init ( module ) ; if ( ret < 0 ) { ALOGW ( ""DownmixLib_Create()initfailed"" ) ; free ( module ) ; return ret ; } * pHandle = ( effect_handle_t ) module ; ALOGV ( ""DownmixLib_Create()%p,size%zu"" , module , sizeof ( downmix_module_t ) ) ; return 0 ; }"," , int32_t sessionId __unused  , int32_t ioId __unused"
264,"CWE-264 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ;  opt = xchg ( & np -> opt , NULL ) ;   if ( opt )   sock_kfree_s ( sk , opt , opt -> tot_len ) ;   } "," = xchg ( ( __force struct ipv6_txoptions * * )  ( opt ) { atomic_sub (  opt -> tot_len  opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt  ) ; } }"
265,"CWE-190 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ;  dec -> xstart = siz -> xoff ;  dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) ; cmpt -> height = JPC_CEILDIV ( dec -> yend , cmpt -> vstep ) - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) ; cmpt -> hsubstep = 0 ; cmpt -> vsubstep = 0 ; } dec -> image = 0 ; dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ;  dec -> numtiles = dec -> numhtiles * dec -> numvtiles ;  JAS_DBGLOG ( 10 , ( ""numtiles=%d;numhtiles=%d;numvtiles=%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }  for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno ,  ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> state = JPC_TILE_INIT ; tile -> xstart = JAS_MAX ( dec -> tilexoff + htileno * dec -> tilewidth , dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> tileyoff + vtileno * dec -> tileheight , dec -> ystart ) ; tile -> xend = JAS_MIN ( dec -> tilexoff + ( htileno + 1 ) * dec -> tilewidth , dec -> xend ) ; tile -> yend = JAS_MIN ( dec -> tileyoff + ( vtileno + 1 ) * dec -> tileheight , dec -> yend ) ; tile -> numparts = 0 ; tile -> partno = 0 ; tile -> pkthdrstream = 0 ; tile -> pkthdrstreampos = 0 ; tile -> pptstab = 0 ; tile -> cp = 0 ; tile -> pi = 0 ; if ( ! ( tile -> tcomps = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_tcomp_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ cmpt , ++ tcomp ) { tcomp -> rlvls = 0 ; tcomp -> numrlvls = 0 ; tcomp -> data = 0 ; tcomp -> xstart = JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) ; tcomp -> ystart = JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) ; tcomp -> xend = JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) ; tcomp -> yend = JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ; tcomp -> tsfb = 0 ; } } dec -> pkthdrstreams = 0 ; dec -> state = JPC_MH ; return 0 ; }"," * cmpt ; size_t size ;  tileheight ) ; if ( ! jas_safe_size_mul (  dec -> numhtiles  dec -> numhtiles ,  dec -> numvtiles  dec -> numvtiles , & size  ) ) {  1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles=%d;numhtiles=%d;numvtiles=%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }"
266,"CWE-252 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX%4ld%s-%s(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%dquantum=%d"" ""length=%dgroup=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corruptedimage-tryingexplicitformat\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , """" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }  ( void ) fputc ( c , file ) ;  } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }"," , message ) \\\n{  if ( info  ) ) ; \\\n}  char explicit_vr [  break ; } if (  fputc ( c  , file ) != c ) break"
267,"CWE-125  void ntlm_print_negotiate_flags ( UINT32 flags )  { int i ; const char * str ; WLog_INFO ( TAG , ""negotiateFlags\\""0x%08"" PRIX32 ""\\"""" , flags ) ; for ( i = 31 ; i >= 0 ; i -- ) { if ( ( flags >> i ) & 1 ) { str = NTLM_NEGOTIATE_STRINGS [ ( 31 - i ) ] ; WLog_INFO ( TAG , ""\\t%s(%d),"" , str , ( 31 - i ) ) ; } } }",    static
268,"CWE-254 IMPEG2D_ERROR_CODES_T impeg2d_dec_slice ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_slice_vertical_position ; UWORD32 u4_slice_vertical_position_extension ; IMPEG2D_ERROR_CODES_T e_error ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_PREFIX_LEN ) ; u4_slice_vertical_position = impeg2d_bit_stream_get ( ps_stream , 8 ) ; if ( u4_slice_vertical_position > 2800 ) { u4_slice_vertical_position_extension = impeg2d_bit_stream_get ( ps_stream , 3 ) ; u4_slice_vertical_position += ( u4_slice_vertical_position_extension << 7 ) ; } if ( ( u4_slice_vertical_position > ps_dec -> u2_num_vert_mb ) || ( u4_slice_vertical_position == 0 ) ) { return IMPEG2D_INVALID_VERT_SIZE ; } u4_slice_vertical_position -- ; if ( ps_dec -> u2_mb_y != u4_slice_vertical_position ) { ps_dec -> u2_mb_y = u4_slice_vertical_position ; ps_dec -> u2_mb_x = 0 ; } ps_dec -> u2_first_mb = 1 ; { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = impeg2d_bit_stream_get ( ps_stream , 5 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; } if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 9 ) ;  while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 )  { impeg2d_bit_stream_flush ( ps_stream , 9 ) ; } } impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; e_error = ps_dec -> pf_decode_slice ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } if ( ps_dec -> u2_mb_y < ps_dec -> u2_num_vert_mb ) impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }", ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
269,"CWE-119 int vp9_is_skippable_in_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { int result = 1 ;  struct is_skippable_args args = { x , & result } ;  vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , plane , is_skippable , & args ) ; return result ; }", = { x -> plane [ plane ] . eobs
270,"CWE-264 static int command_write ( struct pci_dev * dev , int offset , u16 value , void * data ) { struct xen_pcibk_dev_data * dev_data ; int err ;  dev_data = pci_get_drvdata ( dev ) ;  if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":%s:enable\\n"" , pci_name ( dev ) ) ; err = pci_enable_device ( dev ) ; if ( err ) return err ; if ( dev_data ) dev_data -> enable_intx = 1 ; } else if ( pci_is_enabled ( dev ) && ! is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":%s:disable\\n"" , pci_name ( dev ) ) ; pci_disable_device ( dev ) ; if ( dev_data ) dev_data -> enable_intx = 0 ; } if ( ! dev -> is_busmaster && is_master_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":%s:setbusmaster\\n"" , pci_name ( dev ) ) ; pci_set_master ( dev ) ; } if ( value & PCI_COMMAND_INVALIDATE ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME "":%s:enablememory-write-invalidate\\n"" , pci_name ( dev ) ) ; err = pci_set_mwi ( dev ) ; if ( err ) { pr_warn ( ""%s:cannotenablememory-write-invalidate(%d)\\n"" , pci_name ( dev ) , err ) ; value &= ~ PCI_COMMAND_INVALIDATE ; } }  return pci_write_config_word ( dev , offset , value ) ;  }"," int err ; u16 val ; struct pci_cmd_info * cmd = data ;  ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;"
271,"CWE-399 static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG :  yi . cfg . mask = 0xffffffff ;  yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }"," case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;"
272,"CWE-119 int main ( int argc , char * argv [ ] ) { int i , fd , swapped , pkthdrlen , ret , optct , backwards , caplentoobig ; struct pcap_file_header pcap_fh ; struct pcap_pkthdr pcap_ph ; struct pcap_sf_patched_pkthdr pcap_patched_ph ; char buf [ 10000 ] ; struct stat statinfo ; uint64_t pktcnt ; uint32_t readword ; int32_t last_sec , last_usec , caplen ; optct = optionProcess ( & tcpcapinfoOptions , argc , argv ) ; argc -= optct ; argv += optct ; # ifdef DEBUG if ( HAVE_OPT ( DBUG ) ) debug = OPT_VALUE_DBUG ; # endif for ( i = 0 ; i < argc ; i ++ ) { dbgx ( 1 , ""processing:%s\\n"" , argv [ i ] ) ; if ( ( fd = open ( argv [ i ] , O_RDONLY ) ) < 0 ) errx ( - 1 , ""Erroropeningfile%s:%s"" , argv [ i ] , strerror ( errno ) ) ; if ( fstat ( fd , & statinfo ) < 0 ) errx ( - 1 , ""Errorgettingfilestatinfo%s:%s"" , argv [ i ] , strerror ( errno ) ) ; printf ( ""filesize=%"" PRIu64 ""bytes\\n"" , ( uint64_t ) statinfo . st_size ) ; if ( ( ret = read ( fd , & buf , sizeof ( pcap_fh ) ) ) != sizeof ( pcap_fh ) ) errx ( - 1 , ""Filetoosmall.Unabletoreadpcap_file_headerfrom%s"" , argv [ i ] ) ; dbgx ( 3 , ""Read%dbytesforfileheader"" , ret ) ; swapped = 0 ; memcpy ( & pcap_fh , & buf , sizeof ( pcap_fh ) ) ; pkthdrlen = 16 ; switch ( pcap_fh . magic ) { case TCPDUMP_MAGIC : printf ( ""magic=0x%08"" PRIx32 ""(tcpdump)(%s)\\n"" , pcap_fh . magic , is_not_swapped ) ; break ; case SWAPLONG ( TCPDUMP_MAGIC ) : printf ( ""magic=0x%08"" PRIx32 ""(tcpdump/swapped)(%s)\\n"" , pcap_fh . magic , is_swapped ) ; swapped = 1 ; break ; case KUZNETZOV_TCPDUMP_MAGIC : pkthdrlen = sizeof ( pcap_patched_ph ) ; printf ( ""magic=0x%08"" PRIx32 ""(Kuznetzov)(%s)\\n"" , pcap_fh . magic , is_not_swapped ) ; break ; case SWAPLONG ( KUZNETZOV_TCPDUMP_MAGIC ) : pkthdrlen = sizeof ( pcap_patched_ph ) ; printf ( ""magic=0x%08"" PRIx32 ""(Kuznetzov/swapped)(%s)\\n"" , pcap_fh . magic , is_swapped ) ; swapped = 1 ; break ; case FMESQUITA_TCPDUMP_MAGIC : printf ( ""magic=0x%08"" PRIx32 ""(Fmesquita)(%s)\\n"" , pcap_fh . magic , is_not_swapped ) ; break ; case SWAPLONG ( FMESQUITA_TCPDUMP_MAGIC ) : printf ( ""magic=0x%08"" PRIx32 ""(Fmesquita)(%s)\\n"" , pcap_fh . magic , is_swapped ) ; swapped = 1 ; break ; case NAVTEL_TCPDUMP_MAGIC : printf ( ""magic=0x%08"" PRIx32 ""(Navtel)(%s)\\n"" , pcap_fh . magic , is_not_swapped ) ; break ; case SWAPLONG ( NAVTEL_TCPDUMP_MAGIC ) : printf ( ""magic=0x%08"" PRIx32 ""(Navtel/swapped)(%s)\\n"" , pcap_fh . magic , is_swapped ) ; swapped = 1 ; break ; case NSEC_TCPDUMP_MAGIC : printf ( ""magic=0x%08"" PRIx32 ""(Nsec)(%s)\\n"" , pcap_fh . magic , is_not_swapped ) ; break ; case SWAPLONG ( NSEC_TCPDUMP_MAGIC ) : printf ( ""magic=0x%08"" PRIx32 ""(Nsec/swapped)(%s)\\n"" , pcap_fh . magic , is_swapped ) ; swapped = 1 ; break ; default : printf ( ""magic=0x%08"" PRIx32 ""(unknown)\\n"" , pcap_fh . magic ) ; } if ( swapped == 1 ) { pcap_fh . version_major = SWAPSHORT ( pcap_fh . version_major ) ; pcap_fh . version_minor = SWAPSHORT ( pcap_fh . version_minor ) ; pcap_fh . thiszone = SWAPLONG ( pcap_fh . thiszone ) ; pcap_fh . sigfigs = SWAPLONG ( pcap_fh . sigfigs ) ; pcap_fh . snaplen = SWAPLONG ( pcap_fh . snaplen ) ; pcap_fh . linktype = SWAPLONG ( pcap_fh . linktype ) ; } printf ( ""version=%hu.%hu\\n"" , pcap_fh . version_major , pcap_fh . version_minor ) ; printf ( ""thiszone=0x%08"" PRIx32 ""\\n"" , pcap_fh . thiszone ) ; printf ( ""sigfigs=0x%08"" PRIx32 ""\\n"" , pcap_fh . sigfigs ) ; printf ( ""snaplen=%"" PRIu32 ""\\n"" , pcap_fh . snaplen ) ; printf ( ""linktype=0x%08"" PRIx32 ""\\n"" , pcap_fh . linktype ) ; if ( pcap_fh . version_major != 2 && pcap_fh . version_minor != 4 ) { printf ( ""Sorry,weonlysupportfileformatversion2.4\\n"" ) ; close ( fd ) ; continue ; } dbgx ( 5 , ""Packetheaderlen:%d"" , pkthdrlen ) ; if ( pkthdrlen == 24 ) { printf ( ""Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\t\\tIndex\\tProto\\tPktType\\tPktCsum\\tNote\\n"" ) ; } else { printf ( ""Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\tCsum\\tNote\\n"" ) ; } pktcnt = 0 ; last_sec = 0 ; last_usec = 0 ; while ( ( ret = read ( fd , & buf , pkthdrlen ) ) == pkthdrlen ) { pktcnt ++ ; backwards = 0 ; caplentoobig = 0 ; dbgx ( 3 , ""Read%dbytesforpacket%"" PRIu64 ""header"" , ret , pktcnt ) ; memset ( & pcap_ph , 0 , sizeof ( pcap_ph ) ) ; if ( pkthdrlen == sizeof ( pcap_patched_ph ) ) { memcpy ( & pcap_patched_ph , & buf , sizeof ( pcap_patched_ph ) ) ; if ( swapped == 1 ) { dbg ( 3 , ""Swappingpacketheaderbytes..."" ) ; pcap_patched_ph . caplen = SWAPLONG ( pcap_patched_ph . caplen ) ; pcap_patched_ph . len = SWAPLONG ( pcap_patched_ph . len ) ; pcap_patched_ph . ts . tv_sec = SWAPLONG ( pcap_patched_ph . ts . tv_sec ) ; pcap_patched_ph . ts . tv_usec = SWAPLONG ( pcap_patched_ph . ts . tv_usec ) ; pcap_patched_ph . index = SWAPLONG ( pcap_patched_ph . index ) ; pcap_patched_ph . protocol = SWAPSHORT ( pcap_patched_ph . protocol ) ; } printf ( ""%"" PRIu64 ""\\t%4"" PRIu32 ""\\t\\t%4"" PRIu32 ""\\t\\t%"" PRIx32 "".%"" PRIx32 ""\\t\\t%4"" PRIu32 ""\\t%4hu\\t%4hhu"" , pktcnt , pcap_patched_ph . len , pcap_patched_ph . caplen , pcap_patched_ph . ts . tv_sec , pcap_patched_ph . ts . tv_usec , pcap_patched_ph . index , pcap_patched_ph . protocol , pcap_patched_ph . pkt_type ) ; if ( pcap_fh . snaplen < pcap_patched_ph . caplen ) { caplentoobig = 1 ; } caplen = pcap_patched_ph . caplen ; } else { memcpy ( & readword , buf , 4 ) ; pcap_ph . ts . tv_sec = readword ; memcpy ( & readword , & buf [ 4 ] , 4 ) ; pcap_ph . ts . tv_usec = readword ; memcpy ( & pcap_ph . caplen , & buf [ 8 ] , 4 ) ; memcpy ( & pcap_ph . len , & buf [ 12 ] , 4 ) ; if ( swapped == 1 ) { dbg ( 3 , ""Swappingpacketheaderbytes..."" ) ; pcap_ph . caplen = SWAPLONG ( pcap_ph . caplen ) ; pcap_ph . len = SWAPLONG ( pcap_ph . len ) ; pcap_ph . ts . tv_sec = SWAPLONG ( pcap_ph . ts . tv_sec ) ; pcap_ph . ts . tv_usec = SWAPLONG ( pcap_ph . ts . tv_usec ) ; } printf ( ""%"" PRIu64 ""\\t%4"" PRIu32 ""\\t\\t%4"" PRIu32 ""\\t\\t%"" PRIx32 "".%"" PRIx32 , pktcnt , pcap_ph . len , pcap_ph . caplen , ( unsigned int ) pcap_ph . ts . tv_sec , ( unsigned int ) pcap_ph . ts . tv_usec ) ; if ( pcap_fh . snaplen < pcap_ph . caplen ) { caplentoobig = 1 ; } caplen = pcap_ph . caplen ; }  if ( last_sec > 0 && last_usec > 0 ) {  if ( ( pcap_ph . ts . tv_sec == last_sec ) ? ( pcap_ph . ts . tv_usec < last_usec ) : ( pcap_ph . ts . tv_sec < last_sec ) ) { backwards = 1 ; } } if ( pkthdrlen == sizeof ( pcap_patched_ph ) ) { last_sec = pcap_patched_ph . ts . tv_sec ; last_usec = pcap_patched_ph . ts . tv_usec ; } else { last_sec = pcap_ph . ts . tv_sec ; last_usec = pcap_ph . ts . tv_usec ; } if ( ( ret = read ( fd , & buf , caplen ) ) != caplen ) { if ( ret < 0 ) { printf ( ""Errorreadingfile:%s:%s\\n"" , argv [ i ] , strerror ( errno ) ) ; } else { printf ( ""Filetruncated!Unabletojumptonextpacket.\\n"" ) ; } close ( fd ) ;  continue ;  } printf ( ""\\t%x\\t"" , do_checksum_math ( ( u_int16_t * ) buf , caplen ) ) ; if ( ! backwards && ! caplentoobig ) { printf ( ""OK\\n"" ) ; } else if ( backwards && ! caplentoobig ) { printf ( ""BAD_TS\\n"" ) ; } else if ( caplentoobig && ! backwards ) { printf ( ""TOOBIG\\n"" ) ; } else if ( backwards && caplentoobig ) { printf ( ""BAD_TS|TOOBIG"" ) ; } } } exit ( 0 ) ; }"," } if ( caplentoobig ) { printf ( ""\\n\\nCapturefileappearstobedamagedorcorrupt.\\n"" ""Containspacketofsize%u,biggerthansnaplength%u\\n"" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if (  fd ) ; break  ; } printf"
273,"CWE-125 GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size - 8 ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) {  tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;  tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; }  ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ;  for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ;  tmp_strsize = ( u32 ) ptr -> size - 8 ;  while ( tmp_strsize ) {  tmp_str [ j ] = gf_bs_read_u8 ( bs ) ;  tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } }  ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ;  for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ;  tmp_strsize = ( u32 ) ptr -> size - 8 ;  while ( tmp_strsize ) {  tmp_str [ j ] = gf_bs_read_u8 ( bs ) ;  tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ;  tmp_strsize = ( u32 ) ptr -> size - 8 ;  while ( tmp_strsize ) {  tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;  tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ;  tmp_strsize = ( u32 ) ptr -> size - 8 ;  while ( tmp_strsize ) {  tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;  tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ;  }  ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; }  ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ;  for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }"," tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 )  ) ; } ISOM_DECREASE_SIZE ( ptr , 1 )  ptr -> size  ; while (  tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 )  ; } } ISOM_DECREASE_SIZE ( ptr , 1 )  ptr -> size  ; while (  tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 )  ptr -> size  ; while (  tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 )  ptr -> size  ; while (  tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 )  ) ; } ISOM_DECREASE_SIZE ( ptr , 1 )  ) ; } ISOM_DECREASE_SIZE ( ptr , 1 )"
274,"CWE-824 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD"" , 4 ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%sisnotavalid.DFFfile(bytotalsize)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""fileheaderindicatedlength=%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunkheaderindicatedlength=%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdifffileversion=0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""gotPROPchunkof%dbytestotal"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ;  uint32_t sampleRate ;  while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""gotsamplerateof%uHz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefinedchannelID%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%dchannels,mask=0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD"" , 4 ) ) { error_line ( ""DSDIFFfilesmustbeuncompressed,not\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""gotPROP/SNDchunktype\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisDSDIFFfilealreadyhaschannelorderinformation!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""gotunknownPROPchunktype\\""%c%c%c%c\\""of%dbytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD"" , 4 ) ) {  if ( ! config -> num_channels ) {  error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""settingconfigurationwith%lldsamples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }", ; uint32_t sampleRate = 0  config -> num_channels || ! config -> sample_rate
275,"CWE-125  void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  { if ( fields -> Len > 0 ) { Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Write ( s , fields -> Buffer , fields -> Len ) ; } }",    static
276,"CWE-476 void pdo_stmt_init ( TSRMLS_D ) { zend_class_entry ce ; INIT_CLASS_ENTRY ( ce , ""PDOStatement"" , pdo_dbstmt_functions ) ; pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ; pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ; zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ; zend_declare_property_null ( pdo_dbstmt_ce , ""queryString"" , sizeof ( ""queryString"" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ; memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ; pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ; pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ; pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ; pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ; pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ; INIT_CLASS_ENTRY ( ce , ""PDORow"" , pdo_row_functions ) ; pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ; pdo_row_ce -> create_object = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ;  } ", = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
277,"CWE-416 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotated_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; quantum_info = ( QuantumInfo * ) NULL ; ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; status = MagickTrue ; while ( EOFBlob ( image ) == MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ;  if ( ( ldblk > 9999 ) || ( ldblk < 0 ) )  break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) break ; if ( HDR . nameLen > 0xFFFF ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; if ( HDR . imagf == 1 ) ldblk *= 2 ; SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) : image ) ; goto skip_reading_current ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( DestroyImageList ( image ) ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; break ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , ( int ) image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; skip_reading_current : AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }", ; if ( EOFBlob ( image ) ) break ; if (
278,"CWE-119 static void scalar32_min_max_or ( struct bpf_reg_state * dst_reg , struct bpf_reg_state * src_reg ) { bool src_known = tnum_subreg_is_const ( src_reg -> var_off ) ; bool dst_known = tnum_subreg_is_const ( dst_reg -> var_off ) ; struct tnum var32_off = tnum_subreg ( dst_reg -> var_off ) ;  s32 smin_val = src_reg -> smin_value ;   u32 umin_val = src_reg -> umin_value ;  if ( src_known && dst_known ) return ; dst_reg -> u32_min_value = max ( dst_reg -> u32_min_value , umin_val ) ; dst_reg -> u32_max_value = var32_off . value | var32_off . mask ; if ( dst_reg -> s32_min_value < 0 || smin_val < 0 ) { dst_reg -> s32_min_value = S32_MIN ; dst_reg -> s32_max_value = S32_MAX ; } else {  dst_reg -> s32_min_value = dst_reg -> umin_value ;   dst_reg -> s32_max_value = dst_reg -> umax_value ;  } }", = src_reg -> s32_min_value  ; u32 umin_val  = src_reg -> u32_min_value  ; if (  = dst_reg -> u32_min_value  ; dst_reg ->  = dst_reg -> u32_max_value  ; } }
279,"CWE-264 static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , ""%s,%s,%s,%s,%s"" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ;  if ( setpwnam ( ctl -> pw ) < 0 ) {  warn ( ""setpwnamfailed"" ) ; # endif printf ( _ ( ""Fingerinformation*NOT*changed.Tryagainlater.\\n"" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( ""Fingerinformationchanged.\\n"" ) ) ; return 0 ; }"," ctl -> pw , "".chfn"""
280,"CWE-125 void CLASS xtrans_interpolate ( int passes ) { int c , d , f , g , h , i , v , ng , row , col , top , left , mrow , mcol ; # ifdef LIBRAW_LIBRARY_BUILD int cstat [ 4 ] = { 0 , 0 , 0 , 0 } ; # endif int val , ndir , pass , hm [ 8 ] , avg [ 4 ] , color [ 3 ] [ 8 ] ; static const short orth [ 12 ] = { 1 , 0 , 0 , 1 , - 1 , 0 , 0 , - 1 , 1 , 0 , 0 , 1 } , patt [ 2 ] [ 16 ] = { { 0 , 1 , 0 , - 1 , 2 , 0 , - 1 , 0 , 1 , 1 , 1 , - 1 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , - 2 , 1 , 0 , - 2 , 0 , 1 , 1 , - 2 , - 2 , 1 , - 1 , - 1 , 1 } } , dir [ 4 ] = { 1 , TS , TS + 1 , TS - 1 } ; short allhex [ 3 ] [ 3 ] [ 2 ] [ 8 ] , * hex ; ushort min , max , sgrow , sgcol ; ushort ( * rgb ) [ TS ] [ TS ] [ 3 ] , ( * rix ) [ 3 ] , ( * pix ) [ 4 ] ; short ( * lab ) [ TS ] [ 3 ] , ( * lix ) [ 3 ] ; float ( * drv ) [ TS ] [ TS ] , diff [ 6 ] , tr ; char ( * homo ) [ TS ] [ TS ] , * buffer ; # ifdef DCRAW_VERBOSE if ( verbose ) fprintf ( stderr , _ ( ""%d-passX-Transinterpolation...\\n"" ) , passes ) ; # endif # ifdef LIBRAW_LIBRARY_BUILD  for ( row = 0 ; row < 6 ; row ++ )  for ( col = 0 ; col < 6 ; col ++ ) cstat [ fcol ( row , col ) ] ++ ; if ( cstat [ 0 ] < 6 || cstat [ 0 ] > 10 || cstat [ 1 ] < 16 || cstat [ 1 ] > 24 || cstat [ 2 ] < 6 || cstat [ 2 ] > 10 || cstat [ 3 ] ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;  # endif  cielab ( 0 , 0 ) ; ndir = 4 << ( passes > 1 ) ; buffer = ( char * ) malloc ( TS * TS * ( ndir * 11 + 6 ) ) ; merror ( buffer , ""xtrans_interpolate()"" ) ; rgb = ( ushort ( * ) [ TS ] [ TS ] [ 3 ] ) buffer ; lab = ( short ( * ) [ TS ] [ 3 ] ) ( buffer + TS * TS * ( ndir * 6 ) ) ; drv = ( float ( * ) [ TS ] [ TS ] ) ( buffer + TS * TS * ( ndir * 6 + 6 ) ) ;  homo = ( char ( * ) [ TS ] [ TS ] ) ( buffer + TS * TS * ( ndir * 10 + 6 ) ) ;  for ( row = 0 ; row < 3 ; row ++ ) for ( col = 0 ; col < 3 ; col ++ ) for ( ng = d = 0 ; d < 10 ; d += 2 ) { g = fcol ( row , col ) == 1 ; if ( fcol ( row + orth [ d ] , col + orth [ d + 2 ] ) == 1 ) ng = 0 ; else ng ++ ; if ( ng == 4 ) { sgrow = row ; sgcol = col ; } if ( ng == g + 1 ) FORC ( 8 ) { v = orth [ d ] * patt [ g ] [ c * 2 ] + orth [ d + 1 ] * patt [ g ] [ c * 2 + 1 ] ; h = orth [ d + 2 ] * patt [ g ] [ c * 2 ] + orth [ d + 3 ] * patt [ g ] [ c * 2 + 1 ] ;  allhex [ row ] [ col ] [ 0 ] [ c ^ ( g * 2 & d ) ] = h + v * width ;  allhex [ row ] [ col ] [ 1 ] [ c ^ ( g * 2 & d ) ] = h + v * TS ; }  }  for ( row = 2 ; row < height - 2 ; row ++ ) for ( min = ~ ( max = 0 ) , col = 2 ; col < width - 2 ; col ++ ) { if ( fcol ( row , col ) == 1 && ( min = ~ ( max = 0 ) ) ) continue ; pix = image + row * width + col ; hex = allhex [ row % 3 ] [ col % 3 ] [ 0 ] ; if ( ! max ) FORC ( 6 ) { val = pix [ hex [ c ] ] [ 1 ] ; if ( min > val ) min = val ; if ( max < val ) max = val ; } pix [ 0 ] [ 1 ] = min ; pix [ 0 ] [ 3 ] = max ; switch ( ( row - sgrow ) % 3 ) { case 1 : if ( row < height - 3 ) { row ++ ; col -- ; } break ; case 2 : if ( ( min = ~ ( max = 0 ) ) && ( col += 2 ) < width - 3 && row > 2 )  row -- ;  } } for ( top = 3 ; top < height - 19 ; top += TS - 16 ) for ( left = 3 ; left < width - 19 ; left += TS - 16 ) { mrow = MIN ( top + TS , height - 3 ) ; mcol = MIN ( left + TS , width - 3 ) ; for ( row = top ; row < mrow ; row ++ ) for ( col = left ; col < mcol ; col ++ ) memcpy ( rgb [ 0 ] [ row - top ] [ col - left ] , image [ row * width + col ] , 6 ) ; FORC3 memcpy ( rgb [ c + 1 ] , rgb [ 0 ] , sizeof * rgb ) ; for ( row = top ; row < mrow ; row ++ ) for ( col = left ; col < mcol ; col ++ ) { if ( ( f = fcol ( row , col ) ) == 1 ) continue ; pix = image + row * width + col ; hex = allhex [ row % 3 ] [ col % 3 ] [ 0 ] ; color [ 1 ] [ 0 ] = 174 * ( pix [ hex [ 1 ] ] [ 1 ] + pix [ hex [ 0 ] ] [ 1 ] ) - 46 * ( pix [ 2 * hex [ 1 ] ] [ 1 ] + pix [ 2 * hex [ 0 ] ] [ 1 ] ) ; color [ 1 ] [ 1 ] = 223 * pix [ hex [ 3 ] ] [ 1 ] + pix [ hex [ 2 ] ] [ 1 ] * 33 + 92 * ( pix [ 0 ] [ f ] - pix [ - hex [ 2 ] ] [ f ] ) ; FORC ( 2 ) color [ 1 ] [ 2 + c ] = 164 * pix [ hex [ 4 + c ] ] [ 1 ] + 92 * pix [ - 2 * hex [ 4 + c ] ] [ 1 ] + 33 * ( 2 * pix [ 0 ] [ f ] - pix [ 3 * hex [ 4 + c ] ] [ f ] - pix [ - 3 * hex [ 4 + c ] ] [ f ] ) ; FORC4 rgb [ c ^ ! ( ( row - sgrow ) % 3 ) ] [ row - top ] [ col - left ] [ 1 ] = LIM ( color [ 1 ] [ c ] >> 8 , pix [ 0 ] [ 1 ] , pix [ 0 ] [ 3 ] ) ; } for ( pass = 0 ; pass < passes ; pass ++ ) { if ( pass == 1 ) memcpy ( rgb += 4 , buffer , 4 * sizeof * rgb ) ; if ( pass ) { for ( row = top + 2 ; row < mrow - 2 ; row ++ ) for ( col = left + 2 ; col < mcol - 2 ; col ++ ) { if ( ( f = fcol ( row , col ) ) == 1 ) continue ; pix = image + row * width + col ; hex = allhex [ row % 3 ] [ col % 3 ] [ 1 ] ; for ( d = 3 ; d < 6 ; d ++ ) { rix = & rgb [ ( d - 2 ) ^ ! ( ( row - sgrow ) % 3 ) ] [ row - top ] [ col - left ] ; val = rix [ - 2 * hex [ d ] ] [ 1 ] + 2 * rix [ hex [ d ] ] [ 1 ] - rix [ - 2 * hex [ d ] ] [ f ] - 2 * rix [ hex [ d ] ] [ f ] + 3 * rix [ 0 ] [ f ] ; rix [ 0 ] [ 1 ] = LIM ( val / 3 , pix [ 0 ] [ 1 ] , pix [ 0 ] [ 3 ] ) ; } } } for ( row = ( top - sgrow + 4 ) / 3 * 3 + sgrow ; row < mrow - 2 ; row += 3 ) for ( col = ( left - sgcol + 4 ) / 3 * 3 + sgcol ; col < mcol - 2 ; col += 3 ) { rix = & rgb [ 0 ] [ row - top ] [ col - left ] ; h = fcol ( row , col + 1 ) ; memset ( diff , 0 , sizeof diff ) ; for ( i = 1 , d = 0 ; d < 6 ; d ++ , i ^= TS ^ 1 , h ^= 2 ) { for ( c = 0 ; c < 2 ; c ++ , h ^= 2 ) { g = 2 * rix [ 0 ] [ 1 ] - rix [ i << c ] [ 1 ] - rix [ - i << c ] [ 1 ] ; color [ h ] [ d ] = g + rix [ i << c ] [ h ] + rix [ - i << c ] [ h ] ; if ( d > 1 ) diff [ d ] += SQR ( rix [ i << c ] [ 1 ] - rix [ - i << c ] [ 1 ] - rix [ i << c ] [ h ] + rix [ - i << c ] [ h ] ) + SQR ( g ) ; } if ( d > 1 && ( d & 1 ) ) if ( diff [ d - 1 ] < diff [ d ] ) FORC ( 2 ) color [ c * 2 ] [ d ] = color [ c * 2 ] [ d - 1 ] ; if ( d < 2 || ( d & 1 ) ) { FORC ( 2 ) rix [ 0 ] [ c * 2 ] = CLIP ( color [ c * 2 ] [ d ] / 2 ) ; rix += TS * TS ; } } } for ( row = top + 3 ; row < mrow - 3 ; row ++ ) for ( col = left + 3 ; col < mcol - 3 ; col ++ ) { if ( ( f = 2 - fcol ( row , col ) ) == 1 ) continue ; rix = & rgb [ 0 ] [ row - top ] [ col - left ] ; c = ( row - sgrow ) % 3 ? TS : 1 ; h = 3 * ( c ^ TS ^ 1 ) ; for ( d = 0 ; d < 4 ; d ++ , rix += TS * TS ) { i = d > 1 || ( ( d ^ c ) & 1 ) || ( ( ABS ( rix [ 0 ] [ 1 ] - rix [ c ] [ 1 ] ) + ABS ( rix [ 0 ] [ 1 ] - rix [ - c ] [ 1 ] ) ) < 2 * ( ABS ( rix [ 0 ] [ 1 ] - rix [ h ] [ 1 ] ) + ABS ( rix [ 0 ] [ 1 ] - rix [ - h ] [ 1 ] ) ) ) ? c : h ; rix [ 0 ] [ f ] = CLIP ( ( rix [ i ] [ f ] + rix [ - i ] [ f ] + 2 * rix [ 0 ] [ 1 ] - rix [ i ] [ 1 ] - rix [ - i ] [ 1 ] ) / 2 ) ; } } for ( row = top + 2 ; row < mrow - 2 ; row ++ ) if ( ( row - sgrow ) % 3 ) for ( col = left + 2 ; col < mcol - 2 ; col ++ ) if ( ( col - sgcol ) % 3 ) { rix = & rgb [ 0 ] [ row - top ] [ col - left ] ; hex = allhex [ row % 3 ] [ col % 3 ] [ 1 ] ; for ( d = 0 ; d < ndir ; d += 2 , rix += TS * TS ) if ( hex [ d ] + hex [ d + 1 ] ) { g = 3 * rix [ 0 ] [ 1 ] - 2 * rix [ hex [ d ] ] [ 1 ] - rix [ hex [ d + 1 ] ] [ 1 ] ; for ( c = 0 ; c < 4 ; c += 2 ) rix [ 0 ] [ c ] = CLIP ( ( g + 2 * rix [ hex [ d ] ] [ c ] + rix [ hex [ d + 1 ] ] [ c ] ) / 3 ) ; } else { g = 2 * rix [ 0 ] [ 1 ] - rix [ hex [ d ] ] [ 1 ] - rix [ hex [ d + 1 ] ] [ 1 ] ; for ( c = 0 ; c < 4 ; c += 2 ) rix [ 0 ] [ c ] = CLIP ( ( g + rix [ hex [ d ] ] [ c ] + rix [ hex [ d + 1 ] ] [ c ] ) / 2 ) ; } } } rgb = ( ushort ( * ) [ TS ] [ TS ] [ 3 ] ) buffer ; mrow -= top ; mcol -= left ; for ( d = 0 ; d < ndir ; d ++ ) { for ( row = 2 ; row < mrow - 2 ; row ++ ) for ( col = 2 ; col < mcol - 2 ; col ++ ) cielab ( rgb [ d ] [ row ] [ col ] , lab [ row ] [ col ] ) ; for ( f = dir [ d & 3 ] , row = 3 ; row < mrow - 3 ; row ++ ) for ( col = 3 ; col < mcol - 3 ; col ++ ) { lix = & lab [ row ] [ col ] ; g = 2 * lix [ 0 ] [ 0 ] - lix [ f ] [ 0 ] - lix [ - f ] [ 0 ] ; drv [ d ] [ row ] [ col ] = SQR ( g ) + SQR ( ( 2 * lix [ 0 ] [ 1 ] - lix [ f ] [ 1 ] - lix [ - f ] [ 1 ] + g * 500 / 232 ) ) + SQR ( ( 2 * lix [ 0 ] [ 2 ] - lix [ f ] [ 2 ] - lix [ - f ] [ 2 ] - g * 500 / 580 ) ) ; } } memset ( homo , 0 , ndir * TS * TS ) ; for ( row = 4 ; row < mrow - 4 ; row ++ ) for ( col = 4 ; col < mcol - 4 ; col ++ ) { for ( tr = FLT_MAX , d = 0 ; d < ndir ; d ++ ) if ( tr > drv [ d ] [ row ] [ col ] ) tr = drv [ d ] [ row ] [ col ] ; tr *= 8 ; for ( d = 0 ; d < ndir ; d ++ ) for ( v = - 1 ; v <= 1 ; v ++ ) for ( h = - 1 ; h <= 1 ; h ++ ) if ( drv [ d ] [ row + v ] [ col + h ] <= tr ) homo [ d ] [ row ] [ col ] ++ ; } if ( height - top < TS + 4 ) mrow = height - top + 2 ; if ( width - left < TS + 4 ) mcol = width - left + 2 ; for ( row = MIN ( top , 8 ) ; row < mrow - 8 ; row ++ ) for ( col = MIN ( left , 8 ) ; col < mcol - 8 ; col ++ ) { for ( d = 0 ; d < ndir ; d ++ ) for ( hm [ d ] = 0 , v = - 2 ; v <= 2 ; v ++ ) for ( h = - 2 ; h <= 2 ; h ++ ) hm [ d ] += homo [ d ] [ row + v ] [ col + h ] ; for ( d = 0 ; d < ndir - 4 ; d ++ ) if ( hm [ d ] < hm [ d + 4 ] ) hm [ d ] = 0 ; else if ( hm [ d ] > hm [ d + 4 ] ) hm [ d + 4 ] = 0 ; for ( max = hm [ 0 ] , d = 1 ; d < ndir ; d ++ ) if ( max < hm [ d ] ) max = hm [ d ] ; max -= max >> 3 ; memset ( avg , 0 , sizeof avg ) ; for ( d = 0 ; d < ndir ; d ++ ) if ( hm [ d ] >= max ) { FORC3 avg [ c ] += rgb [ d ] [ row ] [ col ] [ c ] ; avg [ 3 ] ++ ; } FORC3 image [ ( row + top ) * width + col + left ] [ c ] = avg [ c ] / avg [ 3 ] ; } } free ( buffer ) ; border_interpolate ( 8 ) ; }"," # ifdef LIBRAW_LIBRARY_BUILD if ( width < TS || height < TS ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;  throw LIBRAW_EXCEPTION_IO_CORRUPT ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) allhex [ i ] [ j ] [ k ] [ l ] = 32700 ;  6 ) ) ; int minv = 0 , maxv = 0 , minh = 0 , maxh = 0  1 ] ; minv = MIN ( v , minv ) ; maxv = MAX ( v , maxv ) ; minh = MIN ( v , minh ) ; maxh = MAX ( v , maxh ) ;  ; } } # ifdef LIBRAW_LIBRARY_BUILD for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) if ( allhex [ i ] [ j ] [ k ] [ l ] > maxh + maxv * width + 1 || allhex [ i ] [ j ] [ k ] [ l ] < minh + minv * width - 1 ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; int retrycount = 0 ; # endif  > 2 ) {  row -- ; # ifdef LIBRAW_LIBRARY_BUILD if ( retrycount ++ > width * height ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif }"
281,"CWE-787 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ;  dlen -= 2 ;  for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }", ; dlen -= 3  ; for (
282,"CWE-20 static void request_key_auth_describe ( const struct key * key , struct seq_file * m ) { struct request_key_auth * rka = key -> payload . data [ 0 ] ; seq_puts ( m , ""key:"" ) ; seq_puts ( m , key -> description ) ;  if ( key_is_instantiated ( key ) )  seq_printf ( m , ""pid:%dci:%zu"" , rka -> pid , rka -> callout_len ) ; }", ; if ( key_is_positive  ( key )
283,"CWE-617 static void pci_lintr_route ( struct pci_vdev * dev ) { struct businfo * bi ; struct intxinfo * ii ; if ( dev -> lintr . pin == 0 ) return ; bi = pci_businfo [ dev -> bus ] ;  assert ( bi != NULL ) ;  ii = & bi -> slotinfo [ dev -> slot ] . si_intpins [ dev -> lintr . pin - 1 ] ; if ( ii -> ii_ioapic_irq == 0 ) ii -> ii_ioapic_irq = ioapic_pci_alloc_irq ( dev ) ;  assert ( ii -> ii_ioapic_irq > 0 ) ;  if ( ii -> ii_pirq_pin == 0 )  ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ;  assert ( ii -> ii_pirq_pin > 0 ) ; dev -> lintr . ioapic_irq = ii -> ii_ioapic_irq ; dev -> lintr . pirq_pin = ii -> ii_pirq_pin ; pci_set_cfgdata8 ( dev , PCIR_INTLINE , pirq_irq ( ii -> ii_pirq_pin ) ) ; }"," bus ] ; if ( bi == NULL ) { pr_err ( ""%s:pci[%s]haswrongbus%dinfo!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; }  ii = &  dev ) ;  if ( ii  pirq_alloc_pin ( dev  ) ; dev"
284,"CWE-415 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( ""I1012"" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , ""Unabletoselectpublickeyfile:%s\\n"" , sc_strerror ( r ) ) ; return 2 ; }  bufsize = file -> size ;  sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , ""Unabletoreadpublickeyfile:%s\\n"" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( ""Keynumber%dnotfound.\\n"" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }"," } bufsize = MIN (  file -> size , sizeof buf )"
285,"CWE-284 static void btsnoop_write ( const void * data , size_t length ) { if ( logfile_fd != INVALID_FD )  write ( logfile_fd , data , length ) ;  btsnoop_net_write ( data , length ) ; }"," != INVALID_FD ) TEMP_FAILURE_RETRY (  data , length )"
286,"CWE-362 static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) { long ret ; struct cros_ec_command u_cmd ; struct cros_ec_command * s_cmd ; if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) return - EFAULT ; if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) return - EINVAL ; s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ; if ( ! s_cmd ) return - ENOMEM ; if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { ret = - EFAULT ; goto exit ; }  s_cmd -> command += ec -> cmd_offset ;  ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; if ( ret < 0 ) goto exit ;  if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) )  ret = - EFAULT ; exit : kfree ( s_cmd ) ; return ret ; }", exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; }  s_cmd ) + s_cmd ->  insize ) )
287,CWE-119 static vpx_codec_err_t vp8e_destroy ( vpx_codec_alg_priv_t * ctx ) { # if CONFIG_MULTI_RES_ENCODING if ( ctx -> oxcf . mr_total_resolutions > 0 && ( ctx -> oxcf . mr_encoder_id == ctx -> oxcf . mr_total_resolutions - 1 ) ) { LOWER_RES_FRAME_INFO * shared_mem_loc = ( LOWER_RES_FRAME_INFO * ) ctx -> oxcf . mr_low_res_mode_info ; free ( shared_mem_loc -> mb_info ) ; free ( ctx -> oxcf . mr_low_res_mode_info ) ; } # endif free ( ctx -> cx_data ) ; vp8_remove_compressor ( & ctx -> cpi ) ;  free ( ctx ) ;  return VPX_CODEC_OK ; }, cpi ) ; vpx_free  ( ctx )
288,"CWE-20 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , ""invalidinsnidx%dinsn_cnt%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , ""BPFprogramistoolarge.Processed%dinsn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , ""\\nfrom%dto%d:safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( env , ""%d:safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , insn_idx ) ; else verbose ( env , ""\\nfrom%dto%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( env , state ) ; do_print_state = false ; } if ( env -> log . level ) { verbose ( env , ""%d:"" , insn_idx ) ; print_bpf_insn ( verbose , env , insn , env -> allow_ptr_leaks ) ; } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; regs = cur_regs ( env ) ;  if ( class == BPF_ALU || class == BPF_ALU64 ) {  err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( env , ""sameinsncannotbeusedwithdifferentpointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn_idx , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( env , ""sameinsncannotbeusedwithdifferentpointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_STusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_CALLusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JAusesreservedfields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , ""BPF_EXITusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , ""R0leaksaddrasreturnvalue\\n"" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ;  } else {  verbose ( env , ""invalidBPF_LDmode\\n"" ) ; return - EINVAL ; } } else { verbose ( env , ""unknowninsnclass%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( env , ""processed%dinsns,stackdepth%d\\n"" , insn_processed , env -> prog -> aux -> stack_depth ) ; return 0 ; }", env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ;  insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
289,"CWE-119 WORD32 ih264d_parse_islice_data_cabac ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; if ( ps_bitstrm -> u4_ofst & 0x07 ) { ps_bitstrm -> u4_ofst += 8 ; ps_bitstrm -> u4_ofst &= 0xFFFFFFF8 ; } ret = ih264d_init_cabac_dec_envirnoment ( & ( ps_dec -> s_cab_dec_env ) , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_init_cabac_contexts ( I_SLICE , ps_dec ) ; ps_dec -> i1_prev_mb_qp_delta = 0 ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD16 u2_mbx ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } { UWORD8 u1_mb_type ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; u2_mbx = ps_dec -> u2_mbx ; ps_cur_mb_info -> u1_tran_form8x8 = 0 ; ps_cur_mb_info -> ps_curmb -> u1_tran_form8x8 = 0 ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; u1_mb_type = ih264d_parse_mb_type_intra_cabac ( 0 , ps_dec ) ; if ( u1_mb_type > 25 ) return ERROR_MB_TYPE ; ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( ""u1_mb_type"" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cabac ( ps_dec , ps_cur_mb_info , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; if ( ps_cur_mb_info -> u1_topmb && u1_mbaff ) uc_more_data_flag = 1 ; else { uc_more_data_flag = ih264d_decode_terminate ( & ps_dec -> s_cab_dec_env , ps_bitstrm ) ; uc_more_data_flag = ! uc_more_data_flag ; COPYTHECONTEXT ( ""DecodeSliceterm"" , ! uc_more_data_flag ) ; } { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; }  u1_num_mbs ++ ;  ps_dec -> u2_total_mbs_coded ++ ; } u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  if ( u1_tfr_n_mb )  u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }", ; } u1_num_mbs  ++ ; }  ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
290,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ;  return true ;  case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ;  return true ;  default : break ; } log_wsgo ( ctx , ""Unexpectedoperator%dinResolveLhs\\n"" , expr -> expr . op ) ; return false ; }", NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL )  ; case EXPR_ARRAY_REF  . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
291,"CWE-200 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ;  if ( ! replay_esn || ! rp )  return 0 ; up = nla_data ( rp ) ;  if ( xfrm_replay_state_esn_len ( replay_esn ) !=   xfrm_replay_state_esn_len ( up ) )  return - EINVAL ; return 0 ; }", * up ; int ulen ;  rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen ||  xfrm_replay_state_esn_len ( replay_esn  replay_esn ) != ulen  ) return -
292,"CWE-119 static void rd_use_partition ( VP9_COMP * cpi ,  const TileInfo * const tile ,  MODE_INFO * * mi_8x8 , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist ,  int do_recon ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; const int mis = cm -> mi_stride ;  const int bsl = b_width_log2 ( bsize ) ;  const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] / 2 ; const int bss = ( 1 << bsl ) / 4 ; int i , pl ; PARTITION_TYPE partition = PARTITION_NONE ; BLOCK_SIZE subsize ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ;  int last_part_rate = INT_MAX ;  int64_t last_part_dist = INT64_MAX ; int64_t last_part_rd = INT64_MAX ; int none_rate = INT_MAX ; int64_t none_dist = INT64_MAX ; int64_t none_rd = INT64_MAX ; int chosen_rate = INT_MAX ; int64_t chosen_dist = INT64_MAX ; int64_t chosen_rd = INT64_MAX ; BLOCK_SIZE sub_subsize = BLOCK_4X4 ; int splits_below = 0 ; BLOCK_SIZE bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type ; int do_partition_search = 1 ;  if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols )  return ; assert ( num_4x4_blocks_wide_lookup [ bsize ] == num_4x4_blocks_high_lookup [ bsize ] ) ;  partition = partition_lookup [ bsl ] [ bs_type ] ;  subsize = get_subsize ( bsize , partition ) ;  if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index != 0 ) { * rate = 0 ; * dist = 0 ; return ; } } else { * ( get_sb_partitioning ( x , bsize ) ) = subsize ; } save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;  if ( bsize == BLOCK_16X16 ) {   set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;  x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;  } else {  x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; } if ( ! x -> in_active_map ) { do_partition_search = 0 ; if ( mi_row + ( mi_step >> 1 ) < cm -> mi_rows && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { * ( get_sb_partitioning ( x , bsize ) ) = bsize ; bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; subsize = bsize ; partition = PARTITION_NONE ; } } if ( do_partition_search && cpi -> sf . partition_search_type == SEARCH_PARTITION && cpi -> sf . adjust_partitioning_from_last_frame ) { if ( partition == PARTITION_SPLIT && subsize > BLOCK_8X8 ) { sub_subsize = get_subsize ( subsize , PARTITION_SPLIT ) ; splits_below = 1 ; for ( i = 0 ; i < 4 ; i ++ ) { int jj = i >> 1 , ii = i & 0x01 ; MODE_INFO * this_mi = mi_8x8 [ jj * bss * mis + ii * bss ] ; if ( this_mi && this_mi -> mbmi . sb_type >= sub_subsize ) { splits_below = 0 ; } } } if ( partition != PARTITION_NONE && ! splits_below && mi_row + ( mi_step >> 1 ) < cm -> mi_rows && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) {  * ( get_sb_partitioning ( x , bsize ) ) = bsize ;   rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize ,  get_block_context ( x , bsize ) , INT64_MAX ) ; pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  if ( none_rate < INT_MAX ) {   none_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;   none_rd = RDCOST ( x -> rdmult , x -> rddiv , none_rate , none_dist ) ;  }  restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;  mi_8x8 [ 0 ] -> mbmi . sb_type = bs_type ;  * ( get_sb_partitioning ( x , bsize ) ) = subsize ;  } } switch ( partition ) { case PARTITION_NONE :  rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate ,  & last_part_dist , bsize , get_block_context ( x , bsize ) , INT64_MAX ) ; break ; case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;  rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , & last_part_dist , subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;  if ( last_part_rate != INT_MAX &&  bsize >= BLOCK_8X8 && mi_row + ( mi_step >> 1 ) < cm -> mi_rows ) {  int rt = 0 ;  int64_t dt = 0 ;  update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ;  rd_pick_sb_modes ( cpi , tile , mi_row + ( mi_step >> 1 ) , mi_col , & rt , & dt ,   subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;   if ( rt == INT_MAX || dt == INT64_MAX ) {   last_part_rate = INT_MAX ;  last_part_dist = INT64_MAX ; break ; }  last_part_rate += rt ;  last_part_dist += dt ; } break ; case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;  rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , & last_part_dist , subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;  if ( last_part_rate != INT_MAX &&  bsize >= BLOCK_8X8 && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) {  int rt = 0 ;  int64_t dt = 0 ;  update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ; encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; * get_sb_index ( x , subsize ) = 1 ;  rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ( mi_step >> 1 ) , & rt , & dt ,   subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;   if ( rt == INT_MAX || dt == INT64_MAX ) {   last_part_rate = INT_MAX ;  last_part_dist = INT64_MAX ; break ; }  last_part_rate += rt ;  last_part_dist += dt ; } break ; case PARTITION_SPLIT :  last_part_rate = 0 ;  last_part_dist = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; int jj = i >> 1 , ii = i & 0x01 ;  int rt ;  int64_t dt ; if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) continue ;  * get_sb_index ( x , subsize ) = i ;  rd_use_partition ( cpi , tile , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & rt , & dt ,  i != 3 ) ;   if ( rt == INT_MAX || dt == INT64_MAX ) {   last_part_rate = INT_MAX ;  last_part_dist = INT64_MAX ; break ; }  last_part_rate += rt ;  last_part_dist += dt ; } break ; default : assert ( 0 ) ;  }  pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  if ( last_part_rate < INT_MAX ) {   last_part_rate += x -> partition_cost [ pl ] [ partition ] ;   last_part_rd = RDCOST ( x -> rdmult , x -> rddiv , last_part_rate , last_part_dist ) ;  } if ( do_partition_search && cpi -> sf . adjust_partitioning_from_last_frame && cpi -> sf . partition_search_type == SEARCH_PARTITION && partition != PARTITION_SPLIT && bsize > BLOCK_8X8 && ( mi_row + mi_step < cm -> mi_rows || mi_row + ( mi_step >> 1 ) == cm -> mi_rows ) && ( mi_col + mi_step < cm -> mi_cols || mi_col + ( mi_step >> 1 ) == cm -> mi_cols ) ) { BLOCK_SIZE split_subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;  chosen_rate = 0 ;  chosen_dist = 0 ;  restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;  for ( i = 0 ; i < 4 ; i ++ ) { int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ;  int rt = 0 ;  int64_t dt = 0 ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) continue ;  * get_sb_index ( x , split_subsize ) = i ;  * get_sb_partitioning ( x , bsize ) = split_subsize ; * get_sb_partitioning ( x , split_subsize ) = split_subsize ; save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;  rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt ,  split_subsize , get_block_context ( x , split_subsize ) , INT64_MAX ) ; restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;  if ( rt == INT_MAX || dt == INT64_MAX ) {   chosen_rate = INT_MAX ;  chosen_dist = INT64_MAX ; break ; }  chosen_rate += rt ;  chosen_dist += dt ; if ( i != 3 )  encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 ,   split_subsize ) ;  pl = partition_plane_context ( xd , mi_row + y_idx , mi_col + x_idx , split_subsize ) ;  chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;  } pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;  if ( chosen_rate < INT_MAX ) {   chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;   chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ;  } } if ( last_part_rd < chosen_rd ) { mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; if ( bsize >= BLOCK_8X8 )  * ( get_sb_partitioning ( x , bsize ) ) = subsize ;  chosen_rate = last_part_rate ; chosen_dist = last_part_dist ; chosen_rd = last_part_rd ; } if ( none_rd < chosen_rd ) { if ( bsize >= BLOCK_8X8 )  * ( get_sb_partitioning ( x , bsize ) ) = bsize ;  chosen_rate = none_rate ; chosen_dist = none_dist ; }  restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;  if ( bsize == BLOCK_64X64 )  assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ;  if ( do_recon ) { int output_enabled = ( bsize == BLOCK_64X64 ) ;  if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {  vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , chosen_rate ) ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , chosen_rate , chosen_dist ) ; encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; } * rate = chosen_rate ;  * dist = chosen_dist ;  }"," * cpi , ThreadData * td , TileDataEnc * tile_data  , MODE_INFO *  , int do_recon , PC_TREE * pc_tree  -> common ; TileInfo * const tile_info = & tile_data -> tile_info ;  x = & td  -> mb ;  int bsl = b_width_log2_lookup [ bsize ]  ; const int  8 ] ; RD_COST last_part_rdc , none_rdc , chosen_rdc  ; BLOCK_SIZE sub_subsize  = 1 ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;  ] ) ; vp9_rd_cost_reset ( & last_part_rdc ) ; vp9_rd_cost_reset ( & none_rdc ) ; vp9_rd_cost_reset ( & chosen_rdc ) ;  partition ) ; pc_tree -> partitioning = partition ; save_context ( x  , mi_row ,  bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode  ( cpi , tile_info , x  , mi_row ,  bsize ) ;  } if (  mi_cols ) { pc_tree -> partitioning = PARTITION_NONE  ; rd_pick_sb_modes (  ( cpi , tile_data , x , mi_row , mi_col , & none_rdc , bsize , ctx  , INT64_MAX )  ; if ( none_rdc . rate  < INT_MAX )  INT_MAX ) { none_rdc . rate += cpi  -> partition_cost [  PARTITION_NONE ] ; none_rdc . rdcost  = RDCOST (  -> rddiv , none_rdc . rate , none_rdc . dist  ) ; }  } restore_context ( x  , mi_row ,  = bs_type ; pc_tree -> partitioning = partition  ; } }  ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , bsize , ctx  , INT64_MAX )  case PARTITION_HORZ : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> horizontal [ 0 ] ,  INT64_MAX ) ;  ; if ( last_part_rdc . rate  != INT_MAX &&  mi_rows ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc )  ; update_state (  ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx )  ; rd_pick_sb_modes (  ( cpi , tile_data , x ,  mi_row + (  mi_col , & tmp_rdc  , subsize ,  , subsize , & pc_tree -> horizontal [ 1 ]  , INT64_MAX )  ; if ( tmp_rdc . rate  == INT_MAX ||  == INT_MAX || tmp_rdc . dist  == INT64_MAX )  INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc )  ; break ;  break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost  ; } break  case PARTITION_VERT : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> vertical [ 0 ]  , INT64_MAX )  ; if ( last_part_rdc . rate  != INT_MAX &&  mi_cols ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc )  ; update_state (  ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx )  ; rd_pick_sb_modes (  ( cpi , tile_data , x ,  mi_row , mi_col  ) , & tmp_rdc  , subsize ,  , subsize , & pc_tree -> vertical [ bsize > BLOCK_8X8 ] ,  INT64_MAX ) ;  ; if ( tmp_rdc . rate  == INT_MAX ||  == INT_MAX || tmp_rdc . dist  == INT64_MAX )  INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc )  ; break ;  break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost  ; } break  case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; break ; } last_part_rdc . rate = 0 ; last_part_rdc . dist = 0 ; last_part_rdc . rdcost  = 0 ;  & 0x01 ; RD_COST tmp_rdc  ; if (  ) continue ; vp9_rd_cost_init ( & tmp_rdc ) ; rd_use_partition ( cpi , td , tile_data , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & tmp_rdc . rate , & tmp_rdc . dist  , i !=  i != 3 , pc_tree -> split [ i ] ) ; if ( tmp_rdc . rate  == INT_MAX ||  == INT_MAX || tmp_rdc . dist  == INT64_MAX )  INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc )  ; break ;  break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist  ; } break  0 ) ; break ;  ; if ( last_part_rdc . rate  < INT_MAX )  INT_MAX ) { last_part_rdc . rate += cpi  -> partition_cost [  partition ] ; last_part_rdc . rdcost  = RDCOST (  -> rddiv , last_part_rdc . rate , last_part_rdc . dist  ) ; }  PARTITION_SPLIT ) ; chosen_rdc . rate = 0 ; chosen_rdc . dist  = 0 ;  ; restore_context ( x  , mi_row ,  , bsize ) ; pc_tree -> partitioning = PARTITION_SPLIT  1 ) ; RD_COST tmp_rdc  ; ENTROPY_CONTEXT l  ) continue ; save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + y_idx , mi_col + x_idx , & tmp_rdc , split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; restore_context ( x  , mi_row ,  bsize ) ; if ( tmp_rdc . rate  == INT_MAX ||  == INT_MAX || tmp_rdc . dist  == INT64_MAX )  INT64_MAX ) { vp9_rd_cost_reset ( & chosen_rdc )  ; break ;  break ; } chosen_rdc . rate += tmp_rdc . rate ; chosen_rdc . dist += tmp_rdc . dist  ; if (  ( cpi , td , tile_info  , tp ,  0 , split_subsize , pc_tree -> split [ i ]  split_subsize ) ; chosen_rdc . rate += cpi  -> partition_cost [  ; if ( chosen_rdc . rate  < INT_MAX )  INT_MAX ) { chosen_rdc . rate += cpi  -> partition_cost [  PARTITION_SPLIT ] ; chosen_rdc . rdcost  = RDCOST (  -> rddiv , chosen_rdc . rate , chosen_rdc . dist ) ; } } if ( last_part_rdc . rdcost < chosen_rdc . rdcost  ) { mi_8x8  >= BLOCK_8X8 ) pc_tree -> partitioning = partition ; chosen_rdc = last_part_rdc ; } if ( none_rdc . rdcost < chosen_rdc . rdcost  ) { if  >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; chosen_rdc = none_rdc  ; } restore_context  } restore_context ( x  , mi_row ,  ) assert ( chosen_rdc . rate  < INT_MAX &&  < INT_MAX && chosen_rdc . dist  < INT64_MAX )  BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ; } * rate = chosen_rdc . rate  ; * dist  * dist = chosen_rdc . dist  ; } "
293,"CWE-835 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ;  ND_PRINT ( ( ndo , ""len=%dmethod=%s"" , len - 4 ,  STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;  if ( 1 < ndo -> ndo_vflag && 4 < len ) {  ND_PRINT ( ( ndo , ""authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ;  } else if ( ndo -> ndo_vflag && 4 < len ) {  if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; }  return ( const u_char * ) ext + len ;  trunc : ND_PRINT ( ( ndo , ""[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }"," ( ndo , ""len=%umethod=%s""  , len -  ; if ( len > 4 ) { if (  ndo -> ndo_vflag  ndo -> ndo_vflag > 1  ) { ND_PRINT  ndo -> ndo_vflag  ) { if  trunc ; } }"
294,"CWE-125 static void sycc420_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b , * nr , * ng , * nb ; const int * y , * cb , * cr , * ny ;  unsigned int maxw , maxh , max ;  int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ;  maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ;  max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ;  d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;   d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;  d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ;  for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U )  {  ny = y + maxw ;  nr = r + maxw ; ng = g + maxw ; nb = b + maxw ;  for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U )  { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; }  if ( j < maxw )  { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } y += maxw ; r += maxw ; g += maxw ; b += maxw ; }  if ( i < maxh )  {  for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U )  { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ;  # if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ;   img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ;  # else  img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ;   img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;  # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;  img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;  return ; fails :  if ( r ) free ( r ) ;   if ( g ) free ( g ) ;   if ( b ) free ( b ) ;  }"," * ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i  ; upb =  maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g  = ( int  int ) *  max ) ;  max ) ; d2 = b  = ( int  int ) *  max ) ;  goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } }  i < ( loopmaxh  & ~ (  & ~ ( size_t  ) 1U )  2U ) { size_t j ;  + maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; }  j < ( loopmaxw  & ~ (  & ~ ( size_t  ) 1U )  ( j < loopmaxw  ) { sycc_to_rgb  ( i < loopmaxh ) { size_t j ;  for ( j  & ~ ( size_t  ) 1U )  = d2 ;  img -> comps  . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;  img -> comps  . h =  img -> comps  2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx =  img -> comps  2 ] . dx = img -> comps [ 0 ] . dx ;  img -> comps  1 ] . dy =  img -> comps  2 ] .  dy = img  ; img -> color_space = OPJ_CLRSPC_SRGB  ; return ;  ; fails :  free ( r  r ) ;  free ( g  g ) ;  free ( b"
295,"CWE-310  static void prefetch_table ( const volatile byte * tab , size_t len )  { size_t i ;  for ( i = 0 ; i < len ; i += 8 * 32 )  { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; }  ( void ) tab [ len - 1 ] ;  }",   static inline  = 0 ; len - i >= 8 * 32  ; i +=  ] ; } for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; }
296,"CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'thandle.WAVfileslargerthan4GB(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) ||  ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) ||   bcount != chunk_header . ckSize ) {  error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) &&  ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) {  error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:riffSize=%lld,dataSize=%lld,sampleCount=%lld,table_length=%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""formattagsize=%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag=%x,NumChannels=%d,BitsPerSample=%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign=%d,SampleRate=%d,BytesPerSecond=%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize=%d,ValidBitsPerSample=%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask=%x,SubFormat=%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%sisanunsupported.WAVformat!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisWAVfilealreadyhaschannelorderinformation!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""dataformat:normalized32-bitfloatingpoint"" ) ; else if ( config -> float_norm_exp ) error_line ( ""dataformat:32-bitfloatingpoint(Audition%d:%dfloattype1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""dataformat:%d-bitintegersstoredin%dbyte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this.WAVfilehasover16MBofextraRIFFdata,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this.WAVfilehasnoaudiosamples,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%shastoomanysamplesforWavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }"," & ds64_chunk , sizeof ( DS64Chunk )  , & bcount  || bcount != sizeof ( DS64Chunk )  ) { error_line  & ds64_chunk , sizeof ( DS64Chunk )  ) ) {"
297,"CWE-190 void * xcalloc ( size_t num , size_t size ) {  void * ptr = malloc ( num * size ) ;  if ( ptr ) {  memset ( ptr , '\\0' , ( num * size ) ) ;  } return ptr ; }"," size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ;  ptr = malloc  = malloc ( res  ) ; if  '\\0' , ( res  ) ) ;"
298,"CWE-310 static void read_conf ( FILE * conffile ) { char * buffer , * line , * val ; buffer = loadfile ( conffile ) ; for ( line = strtok ( buffer , ""\\r\\n"" ) ; line ; line = strtok ( NULL , ""\\r\\n"" ) ) { if ( ! strncmp ( line , ""export"" , 7 ) ) continue ; val = strchr ( line , '=' ) ; if ( ! val ) { printf ( ""invalidconfigurationline\\n"" ) ; break ; } * val ++ = '\\0' ; if ( ! strcmp ( line , ""JSON_INDENT"" ) ) conf . indent = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_COMPACT"" ) ) conf . compact = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_ENSURE_ASCII"" ) ) conf . ensure_ascii = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_PRESERVE_ORDER"" ) ) conf . preserve_order = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_SORT_KEYS"" ) ) conf . sort_keys = atoi ( val ) ; if ( ! strcmp ( line , ""STRIP"" ) ) conf . strip = atoi ( val ) ;  }  free ( buffer ) ; }"," val ) ; if ( ! strcmp ( line , ""HASHSEED"" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; }"
299,"CWE-119 static void handle_data_packet ( struct mt_connection * curconn , struct mt_mactelnet_hdr * pkthdr , int data_len ) { struct mt_mactelnet_control_hdr cpkt ; struct mt_packet pdata ; unsigned char * data = pkthdr -> data ; unsigned int act_size = 0 ; int got_user_packet = 0 ; int got_pass_packet = 0 ; int got_width_packet = 0 ; int got_height_packet = 0 ; int success ; success = parse_control_packet ( data , data_len - MT_HEADER_LEN , & cpkt ) ; while ( success ) { if ( cpkt . cptype == MT_CPTYPE_BEGINAUTH ) { int plen , i ; if ( ! curconn -> have_pass_salt ) { for ( i = 0 ; i < 16 ; ++ i ) { curconn -> pass_salt [ i ] = rand ( ) % 256 ; } curconn -> have_pass_salt = 1 ; memset ( curconn -> trypassword , 0 , sizeof ( curconn -> trypassword ) ) ; } init_packet ( & pdata , MT_PTYPE_DATA , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; plen = add_control_packet ( & pdata , MT_CPTYPE_PASSSALT , ( curconn -> pass_salt ) , 16 ) ; curconn -> outcounter += plen ; send_udp ( curconn , & pdata ) ; } else if ( cpkt . cptype == MT_CPTYPE_USERNAME && curconn -> state != STATE_ACTIVE ) { memcpy ( curconn -> username , cpkt . data , act_size = ( cpkt . length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt . length ) ) ; curconn -> username [ act_size ] = 0 ; got_user_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_TERM_WIDTH && cpkt . length >= 2 ) { unsigned short width ; memcpy ( & width , cpkt . data , 2 ) ; curconn -> terminal_width = le16toh ( width ) ; got_width_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_TERM_HEIGHT && cpkt . length >= 2 ) { unsigned short height ; memcpy ( & height , cpkt . data , 2 ) ; curconn -> terminal_height = le16toh ( height ) ; got_height_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_TERM_TYPE ) { memcpy ( curconn -> terminal_type , cpkt . data , act_size = ( cpkt . length > 30 - 1 ? 30 - 1 : cpkt . length ) ) ; curconn -> terminal_type [ act_size ] = 0 ;  } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) {  # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( curconn -> trypassword , 17 ) ; # endif memcpy ( curconn -> trypassword , cpkt . data , 17 ) ; got_pass_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_PLAINDATA ) { if ( curconn -> state == STATE_ACTIVE && curconn -> ptsfd != - 1 ) { write ( curconn -> ptsfd , cpkt . data , cpkt . length ) ; } } else {  syslog ( LOG_WARNING , _ ( ""(%d)Unhandeledcontrolpackettype:%d"" ) , curconn -> seskey , cpkt . cptype ) ;  } success = parse_control_packet ( NULL , 0 , & cpkt ) ; } if ( got_user_packet && got_pass_packet ) { user_login ( curconn , pkthdr ) ; } if ( curconn -> state == STATE_ACTIVE && ( got_width_packet || got_height_packet ) ) { set_terminal_size ( curconn -> ptsfd , curconn -> terminal_width , curconn -> terminal_height ) ; } }"," cptype == MT_CPTYPE_PASSWORD && cpkt . length == 17  , _ ( ""(%d)Unhandeledcontrolpackettype:%d,length:%d""  ) , curconn  cpkt . cptype , cpkt . length"
300,"CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ;  if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {  coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH :  if ( umax_val > 63 ) {  mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  __reg_deduce_bounds ( dst_reg ) ;  __reg_bound_offset ( dst_reg ) ; return 0 ; }"," , umax_val ; u64 insn_bitness =  ( BPF_CLASS (  -> code ) == BPF_ALU64 ) ? 64 : 32 ;  smin_val = src_reg  if ( umax_val >= insn_bitness  ) { mark_reg_unknown  if ( umax_val >= insn_bitness  ) { mark_reg_unknown  break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }"
301,"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } }  ( void ) ReadBlobString ( image , text ) ;  if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }"
302,"CWE-772 static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MagickPathExtent ] , id [ MagickPathExtent ] , keyword [ MagickPathExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MagickPathExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MagickPathExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MagickPathExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'a' : case 'A' : { if ( LocaleCompare ( keyword , ""alpha-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> alpha_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""alpha-trait"" ) == 0 ) { ssize_t alpha_trait ; alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , MagickFalse , options ) ; if ( alpha_trait < 0 ) break ; image -> alpha_trait = ( PixelTrait ) alpha_trait ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MagickPathExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MagickPathExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) {  if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = colormap ; switch ( depth ) { default : ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;  status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;  if ( status == MagickFalse )  return ( DestroyImageList ( image ) ) ;  status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory (  image -> colors  image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL  ) ThrowReaderException (  ) break ; if ( ( AcquireMagickResource ( WidthResource  , image ->  image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource  image -> rows )  == MagickFalse )  == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit""  ) ; status"
303,"CWE-200 static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; }  ret = copy_to_user ( uattr , attr , usize ) ;  if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }"," , attr , attr -> size  ) ; if"
304,"CWE-119 void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) {  if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {  abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += numcols ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }"," ( buf = jas_alloc3 ( bufsize , numcols  , sizeof ("
305,"CWE-476 static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; int flags = 0 ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> num = inet_sk ( oldsk ) -> num ; if ( PF_INET6 == assoc -> base . sk -> sk_family ) flags = SCTP_ADDR6_ALLOWED ; if ( assoc -> peer . ipv4_address ) flags |= SCTP_ADDR4_PEERSUPP ; if ( assoc -> peer . ipv6_address ) flags |= SCTP_ADDR6_PEERSUPP ; sctp_bind_addr_copy ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , SCTP_SCOPE_GLOBAL , GFP_KERNEL , flags ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) {  sctp_sock_rfree ( skb ) ;  __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ;  sctp_skb_set_owner_r ( skb , newsk ) ;  } } skb_queue_head_init ( & newsp -> pd_lobby ) ; sctp_sk ( newsk ) -> pd_mode = assoc -> ulpq . pd_mode ; if ( sctp_sk ( oldsk ) -> pd_mode ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) {  sctp_sock_rfree ( skb ) ;  __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ;  sctp_skb_set_owner_r ( skb , newsk ) ;  } } if ( assoc -> ulpq . pd_mode )  sctp_clear_pd ( oldsk ) ;  } newsp -> type = type ; sctp_lock_sock ( newsk ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; sctp_release_sock ( newsk ) ; }"," assoc ) { sctp_sock_rfree_frag  ( skb )  skb ) ; sctp_skb_set_owner_r_frag  ( skb ,  assoc ) { sctp_sock_rfree_frag  ( skb )  skb ) ; sctp_skb_set_owner_r_frag  ( skb ,  sctp_clear_pd ( oldsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk"
306,"CWE-787  static void nsc_decode ( NSC_CONTEXT * context )  { UINT16 x ; UINT16 y ;  UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ;   BYTE shift = context -> ColorLossLevel - 1 ;   BYTE * bmpdata = context -> BitmapData ;  for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift ) ; INT16 cg_val = ( INT16 ) ( INT8 ) ( * cgplane << shift ) ; INT16 r_val = y_val + co_val - cg_val ; INT16 g_val = y_val + cg_val ; INT16 b_val = y_val - co_val - cg_val ;  * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ;  * bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ; * bmpdata ++ = MINMAX ( r_val , 0 , 0xFF ) ; * bmpdata ++ = * aplane ; yplane ++ ; coplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; cgplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; aplane ++ ; } }  } ",   static BOOL  nsc_decode ( NSC_CONTEXT  ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw  8 ) ;  shift = context  - 1 ;  bmpdata = context  context -> BitmapData ; if ( ! bmpdata ) return FALSE  - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ;  ; } } return TRUE ;
307,"CWE-119 static int decompress_i ( AVCodecContext * avctx , uint32_t * dst , int linesize ) { SCPRContext * s = avctx -> priv_data ; GetByteContext * gb = & s -> gb ; int cx = 0 , cx1 = 0 , k = 0 , clr = 0 ; int run , r , g , b , off , y = 0 , x = 0 , z , ret ; unsigned backstep = linesize - avctx -> width ; const int cxshift = s -> cxshift ; unsigned lx , ly , ptype ; reinit_tables ( s ) ; bytestream2_skip ( gb , 2 ) ; init_rangecoder ( & s -> rc , gb ) ; while ( k < avctx -> width + 1 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = b >> cxshift ; ret = decode_value ( s , s -> run_model [ 0 ] , 256 , 400 , & run ) ; if ( ret < 0 ) return ret ; clr = ( b << 16 ) + ( g << 8 ) + r ; k += run ; while ( run -- > 0 ) {  dst [ y * linesize + x ] = clr ;  lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } } off = - linesize - 1 ; ptype = 0 ; while ( x < avctx -> width && y < avctx -> height ) { ret = decode_value ( s , s -> op_model [ ptype ] , 6 , 1000 , & ptype ) ; if ( ret < 0 ) return ret ; if ( ptype == 0 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; clr = ( b << 16 ) + ( g << 8 ) + r ; } if ( ptype > 5 ) return AVERROR_INVALIDDATA ; ret = decode_value ( s , s -> run_model [ ptype ] , 256 , 400 , & run ) ; if ( ret < 0 ) return ret ; switch ( ptype ) { case 0 : while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 1 : while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; dst [ y * linesize + x ] = dst [ ly * linesize + lx ] ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } clr = dst [ ly * linesize + lx ] ; break ; case 2 : while ( run -- > 0 ) { if ( y < 1 || y >= avctx -> height ) return AVERROR_INVALIDDATA ; clr = dst [ y * linesize + x + off + 1 ] ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 4 : while ( run -- > 0 ) { uint8_t * odst = ( uint8_t * ) dst ; if ( y < 1 || y >= avctx -> height || ( y == 1 && x == 0 ) ) return AVERROR_INVALIDDATA ; if ( x == 0 ) { z = backstep ; } else { z = 0 ; } r = odst [ ( ly * linesize + lx ) * 4 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 4 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 ] ; g = odst [ ( ly * linesize + lx ) * 4 + 1 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 5 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 + 1 ] ; b = odst [ ( ly * linesize + lx ) * 4 + 2 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 6 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 + 2 ] ; clr = ( ( b & 0xFF ) << 16 ) + ( ( g & 0xFF ) << 8 ) + ( r & 0xFF ) ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 5 : while ( run -- > 0 ) { if ( y < 1 || y >= avctx -> height || ( y == 1 && x == 0 ) ) return AVERROR_INVALIDDATA ; if ( x == 0 ) { z = backstep ; } else { z = 0 ; } clr = dst [ y * linesize + x + off - z ] ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; } if ( avctx -> bits_per_coded_sample == 16 ) { cx1 = ( clr & 0x3F00 ) >> 2 ; cx = ( clr & 0xFFFFFF ) >> 16 ; } else { cx1 = ( clr & 0xFC00 ) >> 4 ; cx = ( clr & 0xFFFFFF ) >> 18 ; } } return 0 ; }", 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
308,"CWE-189 int sysMapFile ( const char * fn , MemMapping * pMap ) { memset ( pMap , 0 , sizeof ( * pMap ) ) ; if ( fn && fn [ 0 ] == '@' ) { FILE * mapf = fopen ( fn + 1 , ""r"" ) ; if ( mapf == NULL ) { LOGV ( ""Unabletoopen\'%s\':%s\\n"" , fn + 1 , strerror ( errno ) ) ; return - 1 ; } if ( sysMapBlockFile ( mapf , pMap ) != 0 ) { LOGW ( ""Mapof\'%s\'failed\\n"" , fn ) ;  return - 1 ;  } fclose ( mapf ) ; } else { int fd = open ( fn , O_RDONLY , 0 ) ; if ( fd < 0 ) { LOGE ( ""Unabletoopen\'%s\':%s\\n"" , fn , strerror ( errno ) ) ; return - 1 ; } if ( sysMapFD ( fd , pMap ) != 0 ) { LOGE ( ""Mapof\'%s\'failed\\n"" , fn ) ; close ( fd ) ; return - 1 ; } close ( fd ) ; } return 0 ; }", fn ) ; fclose ( mapf ) ;
309,"CWE-119 SNDFILE * sf_open_fd ( int fd , int mode , SF_INFO * sfinfo , int close_desc ) { SF_PRIVATE * psf ; if ( ( SF_CONTAINER ( sfinfo -> format ) ) == SF_FORMAT_SD2 ) { sf_errno = SFE_SD2_FD_DISALLOWED ; return NULL ; } ;  if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; copy_filename ( psf , """" ) ; psf -> file . mode = mode ; psf_set_file ( psf , fd ) ; psf -> is_pipe = psf_is_pipe ( psf ) ; psf -> fileoffset = psf_ftell ( psf ) ; if ( ! close_desc ) psf -> file . do_not_close_descriptor = SF_TRUE ; return psf_open_file ( psf , sfinfo ) ; }", ( psf = psf_allocate (  ) ) ==
310,"CWE-362 static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ;  if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) )   task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;  spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ;  } "," SAS_TASK_STATE_DONE ) ) {  task_state_flags |= SAS_TASK_STATE_ABORTED  ; complete (  ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; }"
311,"CWE-119 static void opl3_panning ( int dev , int voice , int value ) {  devc -> voc [ voice ] . panning = value ;  }", value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
312,"CWE-399 static int cib_tls_close ( cib_t * cib ) {  cib_remote_opaque_t * private = cib -> variant_opaque ;  shutdown ( private -> command . socket , SHUT_RDWR ) ; shutdown ( private -> callback . socket , SHUT_RDWR ) ; close ( private -> command . socket ) ; close ( private -> callback . socket ) ; # ifdef HAVE_GNUTLS_GNUTLS_H if ( private -> command . encrypted ) {  gnutls_bye ( * ( private -> command . session ) , GNUTLS_SHUT_RDWR ) ;  gnutls_deinit ( * ( private -> command . session ) ) ; gnutls_free ( private -> command . session ) ;  gnutls_bye ( * ( private -> callback . session ) , GNUTLS_SHUT_RDWR ) ;  gnutls_deinit ( * ( private -> callback . session ) ) ; gnutls_free ( private -> callback . session ) ;  gnutls_anon_free_client_credentials ( anon_cred_c ) ;   gnutls_global_deinit ( ) ;  } # endif  return 0 ;  }"," cib -> variant_opaque  ; # ifdef  encrypted ) { if ( private -> command . session ) {  session ) ; } if ( private -> callback . session ) {  session ) ; } private -> command . session = NULL ; private -> callback . session = NULL ; if ( remote_gnutls_credentials_init ) {  ( ) ; remote_gnutls_credentials_init = FALSE ; }  } # endif if ( private -> command . socket ) { shutdown ( private -> command . socket , SHUT_RDWR ) ; close ( private -> command . socket ) ; } if ( private -> callback . socket ) { shutdown ( private -> callback . socket , SHUT_RDWR ) ; close ( private -> callback . socket ) ; } private -> command . socket = 0 ; private -> callback . socket = 0 ; free ( private -> command . recv_buf ) ; free ( private -> callback . recv_buf ) ; private -> command . recv_buf = NULL ; private -> callback . recv_buf = NULL ;"
313,"CWE-388 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return false ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%sfailedvmentry%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return true ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI :  if ( ! is_exception ( intr_info ) )  return false ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return false ; else if ( is_debug ( intr_info ) && vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) return false ; else if ( is_breakpoint ( intr_info ) && vcpu -> guest_debug & KVM_GUESTDBG_USE_SW_BP ) return false ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return false ; case EXIT_REASON_TRIPLE_FAULT : return true ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return true ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return false ; return true ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return true ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : case EXIT_REASON_RDTSCP : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return true ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_GDTR_IDTR : case EXIT_REASON_LDTR_TR : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_DESC ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return true ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_TRAP_FLAG : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_TRAP_FLAG ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return false ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_APIC_WRITE : case EXIT_REASON_EOI_INDUCED : return true ; case EXIT_REASON_EPT_VIOLATION : return false ; case EXIT_REASON_EPT_MISCONFIG : return false ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return true ; case EXIT_REASON_XSAVES : case EXIT_REASON_XRSTORS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_XSAVES ) ; case EXIT_REASON_PREEMPTION_TIMER : return false ; default : return true ; } }", : if ( is_nmi  ( intr_info )
314,"CWE-119  static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p ,   vp9_prob upd_p ) {   const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ;  const int update = cost_branch256 ( ct , * cur_p ) + vp9_cost_zero ( upd_p ) > cost_branch256 ( ct , new_p ) + vp9_cost_one ( upd_p ) + 7 * 256 ;  vp9_write ( w , update , upd_p ) ;  if ( update ) { * cur_p = new_p ;  vp9_write_literal ( w , new_p >> 1 , 7 ) ;  } return update ; }"," int update_mv ( vpx_writer  * w ,  2 ] , vpx_prob  * cur_p ,  * cur_p , vpx_prob  upd_p ) {  ) { const vpx_prob  new_p = get_binary_prob  * 256 ; vpx_write  ( w ,  = new_p ; vpx_write_literal  ( w ,"
315,"CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;  defaultoptions ( & h ) ;  lua_settop ( L , 2 ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; luaL_argcheck ( L , pos + size <= ld , 2 , ""datastringtooshort"" ) ;  luaL_checkstack ( L , 1 , ""toomanyresults"" ) ;  switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ;  lua_pushnumber ( L , res ) ;  break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ;  lua_pushnumber ( L , f ) ;  break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ;  lua_pushnumber ( L , d ) ;  break ; } case 'c' : { if ( size == 0 ) {  if ( ! lua_isnumber ( L , - 1 ) )   luaL_error ( L , ""format`c0\'needsaprevioussize"" ) ;  size = lua_tonumber ( L , - 1 ) ;  lua_pop ( L , 1 ) ;   luaL_argcheck ( L , pos + size <= ld , 2 , ""datastringtooshort"" ) ;  }  lua_pushlstring ( L , data + pos , size ) ;  break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinishedstringindata"" ) ; size = ( e - ( data + pos ) ) + 1 ;  lua_pushlstring ( L , data + pos , size - 1 ) ;  break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ;  return lua_gettop ( L ) - 2 ;  }"," - 1 ; int n = 0 ;  ( & h  ) ; while  ( L , 2  , ""toomanyresults"" )  res ) ; n ++ ;  f ) ; n ++ ;  d ) ; n ++ ;  { if ( n == 0 ||  ( L , ""format\'c0\'needsaprevioussize""  ) ; size  1 ) ; n -- ;  ( L ,  size <= ld  size <= ld && pos <= ld - size ,  2 , ""datastringtooshort""  , size ) ; n ++  1 ) ; n ++ ;  ) ; return n + 1  ; } "
316,"CWE-824 static int fetch_uidl ( char * line , void * data ) { int i , index ; struct Context * ctx = ( struct Context * ) data ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; char * endp = NULL ; errno = 0 ; index = strtol ( line , & endp , 10 ) ; if ( errno ) return - 1 ; while ( * endp == '' ) endp ++ ; memmove ( line , endp , strlen ( endp ) + 1 ) ;  for ( i = 0 ; i < ctx -> msgcount ; i ++ )  if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ; if ( i == ctx -> msgcount ) { mutt_debug ( 1 , ""newheader%d%s\\n"" , index , line ) ; if ( i >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; ctx -> msgcount ++ ; ctx -> hdrs [ i ] = mutt_header_new ( ) ; ctx -> hdrs [ i ] -> data = mutt_str_strdup ( line ) ; } else if ( ctx -> hdrs [ i ] -> index != index - 1 ) pop_data -> clear_cache = true ; ctx -> hdrs [ i ] -> refno = index ; ctx -> hdrs [ i ] -> index = index - 1 ; return 0 ; }", 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ;
317,"CWE-191 static inline LineContribType * _gdContributionsAlloc ( unsigned int line_length , unsigned int windows_size ) { unsigned int u = 0 ; LineContribType * res ;  int overflow_error = 0 ;   res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;  if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; }  for ( u = 0 ; u < line_length ; u ++ ) {  if ( overflow2 ( windows_size , sizeof ( double ) ) ) { overflow_error = 1 ; } else {  res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;  } if ( overflow_error == 1 || res -> ContribRow [ u ] . Weights == NULL ) { unsigned int i ;  u -- ;   for ( i = 0 ; i <= u ; i ++ ) {  gdFree ( res -> ContribRow [ i ] . Weights ) ; } gdFree ( res -> ContribRow ) ; gdFree ( res ) ; return NULL ; } } return res ; }"," * res ; size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u  = 0 ;  = 0 ;  u < line_length  u ++ )  { res ->  ) gdMalloc ( weights_size ) ; if (  res -> ContribRow  int i ;  for ( i  0 ; i <  u ; i"
318,"CWE-190 static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ;  timer -> it_overrun += 1 << i ;  delta -= incr ; } }", -> it_overrun += 1LL  << i ;
319,"CWE-119 static int __videobuf_mmap_mapper ( struct videobuf_queue * q , struct vm_area_struct * vma ) { struct videbuf_vmalloc_memory * mem ; struct videobuf_mapping * map ; unsigned int first ; int retval ; unsigned long offset = vma -> vm_pgoff << PAGE_SHIFT ; if ( ! ( vma -> vm_flags & VM_WRITE ) || ! ( vma -> vm_flags & VM_SHARED ) ) return - EINVAL ; for ( first = 0 ; first < VIDEO_MAX_FRAME ; first ++ ) { if ( NULL == q -> bufs [ first ] ) continue ; if ( V4L2_MEMORY_MMAP != q -> bufs [ first ] -> memory ) continue ; if ( q -> bufs [ first ] -> boff == offset ) break ; } if ( VIDEO_MAX_FRAME == first ) { dprintk ( 1 , ""mmapappbug:offsetinvalid[offset=0x%lx]\\n"" , ( vma -> vm_pgoff << PAGE_SHIFT ) ) ; return - EINVAL ; }  map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;  if ( NULL == map ) return - ENOMEM ; map -> start = vma -> vm_start ; map -> end = vma -> vm_end ; map -> q = q ; q -> bufs [ first ] -> baddr = vma -> vm_start ; vma -> vm_ops = & videobuf_vm_ops ; vma -> vm_flags |= VM_DONTEXPAND | VM_RESERVED ; vma -> vm_private_data = map ; mem = q -> bufs [ first ] -> priv ; BUG_ON ( ! mem ) ; MAGIC_CHECK ( mem -> magic , MAGIC_VMAL_MEM ) ; retval = remap_vmalloc_range ( vma , mem -> vmalloc , 0 ) ; if ( retval < 0 ) { dprintk ( 1 , ""mmap:postponingremap_vmalloc_range\\n"" ) ; mem -> vma = kmalloc ( sizeof ( * vma ) , GFP_KERNEL ) ; if ( ! mem -> vma ) { kfree ( map ) ; q -> bufs [ first ] -> map = NULL ; return - ENOMEM ; } memcpy ( mem -> vma , vma , sizeof ( * vma ) ) ; } dprintk ( 1 , ""mmap%p:q=%p%08lx-%08lx(%lx)pgoff%08lxbuf%d\\n"" , map , q , vma -> vm_start , vma -> vm_end , ( long int ) q -> bufs [ first ] -> bsize , vma -> vm_pgoff , first ) ; videobuf_vm_open ( vma ) ; return ( 0 ) ; }", -> map = kzalloc  ( sizeof (
320,"CWE-20 static void server_real_connect ( SERVER_REC * server , IPADDR * ip , const char * unix_socket ) { GIOChannel * handle ; IPADDR * own_ip = NULL ; const char * errmsg ; char * errmsg2 ; char ipaddr [ MAX_IP_LEN ] ; int port ; g_return_if_fail ( ip != NULL || unix_socket != NULL ) ; signal_emit ( ""serverconnecting"" , 2 , server , ip ) ; if ( server -> connrec -> no_connect ) return ; if ( ip != NULL ) { own_ip = ip == NULL ? NULL : ( IPADDR_IS_V6 ( ip ) ? server -> connrec -> own_ip6 : server -> connrec -> own_ip4 ) ; port = server -> connrec -> proxy != NULL ? server -> connrec -> proxy_port : server -> connrec -> port ; handle = server -> connrec -> use_ssl ?  net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey ,  server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ; } else { handle = net_connect_unix ( unix_socket ) ; } if ( handle == NULL ) { errmsg = g_strerror ( errno ) ; errmsg2 = NULL ; if ( errno == EADDRNOTAVAIL ) { if ( own_ip != NULL ) { net_ip2host ( own_ip , ipaddr ) ; errmsg2 = g_strconcat ( errmsg , "":"" , ipaddr , NULL ) ; } server -> no_reconnect = TRUE ; } if ( server -> connrec -> use_ssl && errno == ENOSYS ) server -> no_reconnect = TRUE ; server -> connection_lost = TRUE ; server_connect_failed ( server , errmsg2 ? errmsg2 : errmsg ) ; g_free ( errmsg2 ) ; } else { server -> handle = net_sendbuffer_create ( handle , 0 ) ; # ifdef HAVE_OPENSSL if ( server -> connrec -> use_ssl ) server_connect_callback_init_ssl ( server , handle ) ; else # endif server -> connect_tag = g_input_add ( handle , G_INPUT_WRITE | G_INPUT_READ , ( GInputFunction ) server_connect_callback_init , server ) ; } }"," , port , server -> connrec -> address ,"
321,"CWE-119  static void write_segment_id ( vp9_writer * w , const struct segmentation * seg ,  int segment_id ) { if ( seg -> enabled && seg -> update_map ) vp9_write_tree ( w , vp9_segment_tree , seg -> tree_probs , segment_id , 3 , 0 ) ; }"," void write_segment_id ( vpx_writer  * w ,"
322,"CWE-787 GF_Err flac_dmx_process ( GF_Filter * filter ) { GF_FLACDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u8 * output ; u8 * start ; Bool final_flush = GF_FALSE ; u32 pck_size , remain , prev_pck_size ; u64 cts = GF_FILTER_NO_TS ;  FLACHeader hdr ;  if ( ! ctx -> duration . num ) flac_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> flac_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } final_flush = GF_TRUE ; } else { return GF_OK ; } } prev_pck_size = ctx -> flac_buffer_size ; if ( pck && ! ctx -> resume_from ) { u8 * data = ( u8 * ) gf_filter_pck_get_data ( pck , & pck_size ) ; if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { u64 byte_offset = gf_filter_pck_get_byte_offset ( pck ) ; if ( ! ctx -> flac_buffer_size ) { ctx -> byte_offset = byte_offset ; } else if ( ctx -> byte_offset + ctx -> flac_buffer_size != byte_offset ) { ctx -> byte_offset = GF_FILTER_NO_BO ; if ( ( byte_offset != GF_FILTER_NO_BO ) && ( byte_offset > ctx -> flac_buffer_size ) ) { ctx -> byte_offset = byte_offset - ctx -> flac_buffer_size ; } } } if ( ctx -> flac_buffer_size + pck_size > ctx -> flac_buffer_alloc ) { ctx -> flac_buffer_alloc = ctx -> flac_buffer_size + pck_size ; ctx -> flac_buffer = gf_realloc ( ctx -> flac_buffer , ctx -> flac_buffer_alloc ) ; } memcpy ( ctx -> flac_buffer + ctx -> flac_buffer_size , data , pck_size ) ; ctx -> flac_buffer_size += pck_size ; } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } if ( cts == GF_FILTER_NO_TS ) { prev_pck_size = 0 ; } remain = ctx -> flac_buffer_size ; start = ctx -> flac_buffer ; if ( ctx -> resume_from ) { start += ctx -> resume_from - 1 ; remain -= ctx -> resume_from - 1 ; ctx -> resume_from = 0 ; } while ( remain > 2 ) { u32 next_frame = 0 , nb_samp ; u32 cur_size = remain - 2 ; u8 * cur_buf = start + 2 ; u8 * hdr_start = NULL ; if ( final_flush ) { next_frame = remain ; } else { while ( cur_size ) { hdr_start = memchr ( cur_buf , 0xFF , cur_size ) ; if ( ! hdr_start ) break ; next_frame = ( u32 ) ( hdr_start - start ) ; if ( next_frame == remain ) break ; if ( ( hdr_start [ 1 ] & 0xFC ) == 0xF8 ) { if ( flac_parse_header ( ctx , hdr_start , ( u32 ) remain - next_frame , & hdr ) ) break ; } cur_buf = hdr_start + 1 ; cur_size = ( u32 ) ( cur_buf - start ) ; assert ( cur_size <= remain ) ; cur_size = remain - cur_size ; hdr_start = NULL ; } if ( ! hdr_start ) break ; if ( next_frame == remain ) break ; } if ( ! ctx -> initialized ) { u32 size = next_frame ; u32 dsi_end = 0 ; gf_bs_reassign_buffer ( ctx -> bs , ctx -> flac_buffer , size ) ; u32 magic = gf_bs_read_u32 ( ctx -> bs ) ; if ( magic != GF_4CC ( 'f' , 'L' , 'a' , 'C' ) ) {  }  while ( gf_bs_available ( ctx -> bs ) ) { Bool last = gf_bs_read_int ( ctx -> bs , 1 ) ; u32 type = gf_bs_read_int ( ctx -> bs , 7 ) ; u32 len = gf_bs_read_int ( ctx -> bs , 24 ) ; if ( type == 0 ) { u16 min_block_size = gf_bs_read_u16 ( ctx -> bs ) ; u16 max_block_size = gf_bs_read_u16 ( ctx -> bs ) ; gf_bs_read_u24 ( ctx -> bs ) ; gf_bs_read_u24 ( ctx -> bs ) ; ctx -> sample_rate = gf_bs_read_int ( ctx -> bs , 20 ) ; ctx -> nb_channels = 1 + gf_bs_read_int ( ctx -> bs , 3 ) ; ctx -> bits_per_sample = 1 + gf_bs_read_int ( ctx -> bs , 5 ) ; if ( min_block_size == max_block_size ) ctx -> block_size = min_block_size ; else ctx -> block_size = 0 ; ctx -> duration . num = gf_bs_read_long_int ( ctx -> bs , 36 ) ; ctx -> duration . den = ctx -> sample_rate ; gf_bs_skip_bytes ( ctx -> bs , 16 ) ; dsi_end = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; } else { gf_bs_skip_bytes ( ctx -> bs , len ) ; }  if ( last ) break ;  } flac_dmx_check_pid ( filter , ctx , ctx -> flac_buffer + 4 , dsi_end - 4 ) ; remain -= size ; start += size ; ctx -> initialized = GF_TRUE ; if ( ! ctx -> is_playing ) break ; continue ; } if ( ( start [ 0 ] != 0xFF ) && ( ( start [ 1 ] & 0xFC ) != 0xF8 ) ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[FLACDmx]invalidframe,droping%dbytesandresyncing\\n"" , next_frame ) ) ; start += next_frame ; remain -= next_frame ; continue ; } flac_parse_header ( ctx , start , next_frame , & hdr ) ; if ( hdr . sample_rate != ctx -> sample_rate ) { ctx -> sample_rate = hdr . sample_rate ; gf_filter_pid_set_property ( ctx -> opid , GF_PROP_PID_SAMPLE_RATE , & PROP_UINT ( ctx -> sample_rate ) ) ; } nb_samp = hdr . block_size ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * ctx -> sample_rate ) ; if ( ctx -> cts + nb_samp >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } if ( ctx -> timescale && ! prev_pck_size && ( cts != GF_FILTER_NO_TS ) ) { ctx -> cts = cts ; cts = GF_FILTER_NO_TS ; } if ( ! ctx -> in_seek ) { dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , next_frame , & output ) ; memcpy ( output , start , next_frame ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; if ( ! ctx -> timescale || ( ctx -> timescale == ctx -> sample_rate ) ) gf_filter_pck_set_duration ( dst_pck , nb_samp ) ; else { gf_filter_pck_set_duration ( dst_pck , ( nb_samp * ctx -> timescale ) / ctx -> sample_rate ) ; } gf_filter_pck_set_sap ( dst_pck , GF_FILTER_SAP_1 ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> byte_offset != GF_FILTER_NO_BO ) { gf_filter_pck_set_byte_offset ( dst_pck , ctx -> byte_offset ) ; } gf_filter_pck_send ( dst_pck ) ; } flac_dmx_update_cts ( ctx , nb_samp ) ; assert ( start [ 0 ] == 0xFF ) ; assert ( ( start [ 1 ] & 0xFC ) == 0xF8 ) ; start += next_frame ; assert ( remain >= next_frame ) ; remain -= next_frame ; } if ( ! pck ) { ctx -> flac_buffer_size = 0 ; return flac_dmx_process ( filter ) ; } else { if ( remain < ctx -> flac_buffer_size ) { memmove ( ctx -> flac_buffer , start , remain ) ; } ctx -> flac_buffer_size = remain ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; } return GF_OK ; }"," ; FLACHeader hdr ; if ( ctx -> in_error ) return GF_NON_COMPLIANT_BITSTREAM  ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]invalidFLACmagic\\n"" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM ;  last ) break ; } if ( ! dsi_end ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]invalidFLACheader\\n"" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM"
323,"CWE-264 static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ;  if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) )  return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_NEWPID ) ) && ( task_active_pid_ns ( current ) != current -> nsproxy -> pid_ns ) ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; get_seccomp_filter ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , RLIMIT_NPROC ) ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } current -> flags &= ~ PF_NPROC_EXCEEDED ; retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module ) ) goto bad_fork_cleanup_count ; p -> did_exec = 0 ; delayacct_tsk_init ( p ) ; copy_flags ( clone_flags , p ) ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = p -> stime = p -> gtime = 0 ; p -> utimescaled = p -> stimescaled = 0 ; # ifndef CONFIG_VIRT_CPU_ACCOUNTING p -> prev_cputime . utime = p -> prev_cputime . stime = 0 ; # endif # ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN seqlock_init ( & p -> vtime_seqlock ) ; p -> vtime_snap = 0 ; p -> vtime_snap_whence = VTIME_SLEEPING ; # endif # if defined ( SPLIT_RSS_COUNTING ) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat ) ) ; # endif p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cpu_timers_init ( p ) ; do_posix_clock_monotonic_gettime ( & p -> start_time ) ; p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ) ; p -> io_context = NULL ; p -> audit_context = NULL ; if ( clone_flags & CLONE_THREAD ) threadgroup_change_begin ( current ) ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ) ; # endif # ifdef CONFIG_CPUSETS p -> cpuset_mem_spread_rotor = NUMA_NO_NODE ; p -> cpuset_slab_spread_rotor = NUMA_NO_NODE ; seqcount_init ( & p -> mems_allowed_seq ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS p -> irq_events = 0 ; p -> hardirqs_enabled = 0 ; p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _THIS_IP_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _THIS_IP_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; # endif # ifdef CONFIG_LOCKDEP p -> lockdep_depth = 0 ; p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif # ifdef CONFIG_MEMCG p -> memcg_batch . do_batch = 0 ; p -> memcg_batch . memcg = NULL ; # endif sched_fork ( p ) ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = audit_alloc ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = copy_semundo ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_audit ; retval = copy_files ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_semundo ; retval = copy_fs ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_files ; retval = copy_sighand ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_fs ; retval = copy_signal ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_sighand ; retval = copy_mm ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_signal ; retval = copy_namespaces ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_mm ; retval = copy_io ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p ) ; if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - ENOMEM ; pid = alloc_pid ( p -> nsproxy -> pid_ns ) ; if ( ! pid ) goto bad_fork_cleanup_io ; } p -> pid = pid_nr ( pid ) ; p -> tgid = p -> pid ; if ( clone_flags & CLONE_THREAD ) p -> tgid = current -> tgid ; p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? child_tidptr : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? child_tidptr : NULL ; # ifdef CONFIG_BLOCK p -> plug = NULL ; # endif # ifdef CONFIG_FUTEX p -> robust_list = NULL ; # ifdef CONFIG_COMPAT p -> compat_robust_list = NULL ; # endif INIT_LIST_HEAD ( & p -> pi_state_list ) ; p -> pi_state_cache = NULL ; # endif uprobe_copy_process ( p ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; user_disable_single_step ( p ) ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_all_latency_tracing ( p ) ; if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else if ( clone_flags & CLONE_PARENT ) p -> exit_signal = current -> group_leader -> exit_signal ; else p -> exit_signal = ( clone_flags & CSIGNAL ) ; p -> pdeath_signal = 0 ; p -> exit_state = 0 ; p -> nr_dirtied = 0 ; p -> nr_dirtied_pause = 128 >> ( PAGE_SHIFT - 10 ) ; p -> dirty_paused_when = 0 ; p -> group_leader = p ; INIT_LIST_HEAD ( & p -> thread_group ) ; p -> task_works = NULL ; write_lock_irq ( & tasklist_lock ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ) ; recalc_sigpending ( ) ; if ( signal_pending ( current ) ) { spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; retval = - ERESTARTNOINTR ; goto bad_fork_free_pid ; } if ( clone_flags & CLONE_THREAD ) { current -> signal -> nr_threads ++ ; atomic_inc ( & current -> signal -> live ) ; atomic_inc ( & current -> signal -> sigcnt ) ; p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; } if ( likely ( p -> pid ) ) { ptrace_init_task ( p , ( clone_flags & CLONE_PTRACE ) || trace ) ; if ( thread_group_leader ( p ) ) { if ( is_child_reaper ( pid ) ) { ns_of_pid ( pid ) -> child_reaper = p ; p -> signal -> flags |= SIGNAL_UNKILLABLE ; } p -> signal -> leader_pid = pid ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; attach_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; attach_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; __this_cpu_inc ( process_counts ) ; } attach_pid ( p , PIDTYPE_PID , pid ) ; nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; cgroup_post_fork ( p ) ; if ( clone_flags & CLONE_THREAD ) threadgroup_change_end ( current ) ; perf_event_fork ( p ) ; trace_task_newtask ( p , clone_flags ) ; return p ; bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ; bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ) ; bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) free_signal_struct ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_policy : perf_event_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_cgroup : # endif if ( clone_flags & CLONE_THREAD ) threadgroup_change_end ( current ) ; cgroup_exit ( p , 0 ) ; delayacct_tsk_free ( p ) ; module_put ( task_thread_info ( p ) -> exec_domain -> module ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : free_task ( p ) ; fork_out : return ERR_PTR ( retval ) ; }", ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
324,"CWE-476 static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) {  struct dentry * dir ;  struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; }  ci = d_inode ( dir ) -> i_crypt_info ;  if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ;  dir_has_key = ( ci != NULL ) ;  dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }", dentry * dir  ; int dir_has_key  0 ; }  spin_lock ( &  dir_has_key = ( d_inode ( dir ) -> i_crypt_info  != NULL )
325,"CWE-000 static int create_fixed_stream_quirk ( struct snd_usb_audio * chip , struct usb_interface * iface , struct usb_driver * driver , const struct snd_usb_audio_quirk * quirk ) { struct audioformat * fp ; struct usb_host_interface * alts ; struct usb_interface_descriptor * altsd ; int stream , err ; unsigned * rate_table = NULL ; fp = kmemdup ( quirk -> data , sizeof ( * fp ) , GFP_KERNEL ) ; if ( ! fp ) { usb_audio_err ( chip , ""cannotmemdup\\n"" ) ; return - ENOMEM ; } if ( fp -> nr_rates > MAX_NR_RATES ) { kfree ( fp ) ; return - EINVAL ; } if ( fp -> nr_rates > 0 ) { rate_table = kmemdup ( fp -> rate_table , sizeof ( int ) * fp -> nr_rates , GFP_KERNEL ) ; if ( ! rate_table ) { kfree ( fp ) ; return - ENOMEM ; } fp -> rate_table = rate_table ; } stream = ( fp -> endpoint & USB_DIR_IN ) ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; err = snd_usb_add_audio_stream ( chip , stream , fp ) ; if ( err < 0 ) { kfree ( fp ) ; kfree ( rate_table ) ; return err ; } if ( fp -> iface != get_iface_desc ( & iface -> altsetting [ 0 ] ) -> bInterfaceNumber || fp -> altset_idx >= iface -> num_altsetting ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } alts = & iface -> altsetting [ fp -> altset_idx ] ; altsd = get_iface_desc ( alts ) ;  fp -> protocol = altsd -> bInterfaceProtocol ;  if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ; if ( fp -> maxpacksize == 0 ) fp -> maxpacksize = le16_to_cpu ( get_endpoint ( alts , 0 ) -> wMaxPacketSize ) ; usb_set_interface ( chip -> dev , fp -> iface , 0 ) ; snd_usb_init_pitch ( chip , fp -> iface , alts , fp ) ; snd_usb_init_sample_rate ( chip , fp -> iface , alts , fp , fp -> rate_max ) ; return 0 ; }", alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
326,"CWE-000 WORD32 ih264d_parse_inter_slice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD32 uc_more_data_flag ; WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 , u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_read_mb_type ; UWORD32 u1_mbaff ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end = 0 ; UWORD32 u1_tfr_n_mb = 0 ; UWORD32 u1_decode_nmb = 0 ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD32 u1_mb_threshold ; WORD32 ret = OK ; if ( ps_slice -> u1_slice_type == P_SLICE ) { u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; u1_mb_threshold = 5 ; } else { u1_inter_mb_type = B_MB ; u1_deblk_mb_type = D_B_SLICE ; u1_mb_threshold = 23 ; } ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; u1_num_mbsNby2 = 0 ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; i2_mb_skip_run = 0 ; uc_more_data_flag = 1 ; u1_read_mb_type = 0 ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( ( ! i2_mb_skip_run ) && ( ! u1_read_mb_type ) ) { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) { GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; } * pu4_bitstrm_ofst = u4_bitstream_offset ; i2_mb_skip_run = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; COPYTHECONTEXT ( ""mb_skip_run"" , i2_mb_skip_run ) ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; u1_read_mb_type = uc_more_data_flag ; } ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; if ( i2_mb_skip_run ) { ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; { parse_part_params_t * ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; } ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; } else { u1_read_mb_type = 0 ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > ( UWORD32 ) ( 25 + u1_mb_threshold ) ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; COPYTHECONTEXT ( ""u1_mb_type"" , u1_mb_type ) ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; if ( u1_mb_type < u1_mb_threshold ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ret = ps_dec -> pf_parse_inter_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_num_mbsNby2 ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; } else { ps_parse_mb_data -> u1_num_part = 0 ; ps_parse_mb_data -> u1_isI_mb = 1 ; if ( ( 25 + u1_mb_threshold ) == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_dec -> u1_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , ( UWORD8 ) ( u1_mb_type - u1_mb_threshold ) ) ; if ( ret != OK ) return ret ; } ps_cur_deblk_mb -> u1_mb_type |= D_INTRA_MB ; } uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; } ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ;  }  i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ( ! ( uc_more_data_flag || i2_mb_skip_run ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; { ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } } if ( u1_decode_nmb ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }", ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
327,"CWE-134 void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; char double_str [ 20 ] , double_str2 [ 20 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-autoscale-max"" , no_argument , 0 , 'M' } , { ""zoom"" , required_argument , 0 , 'm' } , { ""no-gridfit"" , no_argument , 0 , 'N' } , { ""font"" , required_argument , 0 , 'n' } , { ""logarithmic"" , no_argument , 0 , 'o' } , { ""pango-markup"" , no_argument , 0 , 'P' } , { ""font-render-mode"" , required_argument , 0 , 'R' } , { ""rigid"" , no_argument , 0 , 'r' } , { ""step"" , required_argument , 0 , 'S' } , { ""start"" , required_argument , 0 , 's' } , { ""tabwidth"" , required_argument , 0 , 'T' } , { ""title"" , required_argument , 0 , 't' } , { ""upper-limit"" , required_argument , 0 , 'u' } , { ""vertical-label"" , required_argument , 0 , 'v' } , { ""watermark"" , required_argument , 0 , 'W' } , { ""width"" , required_argument , 0 , 'w' } , { ""units-exponent"" , required_argument , 0 , 'X' } , { ""x-grid"" , required_argument , 0 , 'x' } , { ""alt-y-grid"" , no_argument , 0 , 'Y' } , { ""y-grid"" , required_argument , 0 , 'y' } , { ""lazy"" , no_argument , 0 , 'z' } , { ""use-nan-for-all-missing-data"" , no_argument , 0 , 'Z' } , { ""units"" , required_argument , 0 , LONGOPT_UNITS_SI } , { ""alt-y-mrtg"" , no_argument , 0 , 1000 } , { ""disable-rrdtool-tag"" , no_argument , 0 , 1001 } , { ""right-axis"" , required_argument , 0 , 1002 } , { ""right-axis-label"" , required_argument , 0 , 1003 } , { ""right-axis-format"" , required_argument , 0 , 1004 } , { ""legend-position"" , required_argument , 0 , 1005 } , { ""legend-direction"" , required_argument , 0 , 1006 } , { ""border"" , required_argument , 0 , 1007 } , { ""grid-dash"" , required_argument , 0 , 1008 } , { ""dynamic-labels"" , no_argument , 0 , 1009 } , { ""week-fmt"" , required_argument , 0 , 1010 } , { ""graph-type"" , required_argument , 0 , 1011 } , { ""left-axis-format"" , required_argument , 0 , 1012 } , { 0 , 0 , 0 , 0 } } ; optind = 0 ; opterr = 0 ; rrd_parsetime ( ""end-24h"" , & start_tv ) ; rrd_parsetime ( ""now"" , & end_tv ) ; while ( 1 ) { int option_index = 0 ; int opt ; int col_start , col_end ; opt = getopt_long ( argc , argv , ""Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:Zz"" , long_options , & option_index ) ; if ( opt == EOF ) break ; switch ( opt ) { case 'I' : im -> extra_flags |= NOMINOR ; break ; case 'Y' : im -> extra_flags |= ALTYGRID ; break ; case 'A' : im -> extra_flags |= ALTAUTOSCALE ; break ; case 'J' : im -> extra_flags |= ALTAUTOSCALE_MIN ; break ; case 'M' : im -> extra_flags |= ALTAUTOSCALE_MAX ; break ; case 'j' : im -> extra_flags |= ONLY_GRAPH ; break ; case 'g' : im -> extra_flags |= NOLEGEND ; break ; case 'Z' : im -> extra_flags |= ALLOW_MISSING_DS ; break ; case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) { im -> legendposition = NORTH ; } else if ( strcmp ( optarg , ""west"" ) == 0 ) { im -> legendposition = WEST ; } else if ( strcmp ( optarg , ""south"" ) == 0 ) { im -> legendposition = SOUTH ; } else if ( strcmp ( optarg , ""east"" ) == 0 ) { im -> legendposition = EAST ; } else { rrd_set_error ( ""unknownlegend-position\'%s\'"" , optarg ) ; return ; } break ; case 1006 : if ( strcmp ( optarg , ""topdown"" ) == 0 ) { im -> legenddirection = TOP_DOWN ; } else if ( strcmp ( optarg , ""bottomup"" ) == 0 ) { im -> legenddirection = BOTTOM_UP ; } else if ( strcmp ( optarg , ""bottomup2"" ) == 0 ) { im -> legenddirection = BOTTOM_UP2 ; } else { rrd_set_error ( ""unknownlegend-position\'%s\'"" , optarg ) ; return ; } break ; case 'F' : im -> extra_flags |= FORCE_RULES_LEGEND ; break ; case 1001 : im -> extra_flags |= NO_RRDTOOL_TAG ; break ; case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) { rrd_set_error ( ""--unitscanonlybeusedonce!"" ) ; return ; } if ( strcmp ( optarg , ""si"" ) == 0 ) im -> extra_flags |= FORCE_UNITS_SI ; else { rrd_set_error ( ""invalidargumentfor--units:%s"" , optarg ) ; return ; } break ; case 'X' : im -> unitsexponent = atoi ( optarg ) ; break ; case 'L' : im -> unitslength = atoi ( optarg ) ; im -> forceleftspace = 1 ; break ; case 'T' : if ( rrd_strtodbl ( optarg , 0 , & ( im -> tabwidth ) , ""option-T"" ) != 2 ) return ; break ; case 'S' : im -> step = atoi ( optarg ) ; break ; case 'N' : im -> gridfit = 0 ; break ; case 'P' : im -> with_markup = 1 ; break ; case 's' : if ( ( parsetime_error = rrd_parsetime ( optarg , & start_tv ) ) ) { rrd_set_error ( ""starttime:%s"" , parsetime_error ) ; return ; } break ; case 'e' : if ( ( parsetime_error = rrd_parsetime ( optarg , & end_tv ) ) ) { rrd_set_error ( ""endtime:%s"" , parsetime_error ) ; return ; } break ; case 'x' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_x_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n"" , scan_gtm , & im -> xlab_user . gridst , scan_mtm , & im -> xlab_user . mgridst , scan_ltm , & im -> xlab_user . labst , & im -> xlab_user . precis , & stroff ) == 7 && stroff != 0 ) { im -> xlab_form = strdup ( optarg + stroff ) ; if ( ! im -> xlab_form ) { rrd_set_error ( ""cannotallocatememoryforxlab_form"" ) ; return ; } if ( ( int ) ( im -> xlab_user . gridtm = tmt_conv ( scan_gtm ) ) == - 1 ) { rrd_set_error ( ""unknownkeyword%s"" , scan_gtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . mgridtm = tmt_conv ( scan_mtm ) ) == - 1 ) { rrd_set_error ( ""unknownkeyword%s"" , scan_mtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . labtm = tmt_conv ( scan_ltm ) ) == - 1 ) { rrd_set_error ( ""unknownkeyword%s"" , scan_ltm ) ; return ; } im -> xlab_user . minsec = 1 ; im -> xlab_user . stst = im -> xlab_form ? im -> xlab_form : """" ; } else { rrd_set_error ( ""invalidx-gridformat"" ) ; return ; } break ; case 'y' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_y_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%[-0-9.e+]:%d"" , double_str , & im -> ylabfact ) == 2 ) { if ( rrd_strtodbl ( double_str , 0 , & ( im -> ygridstep ) , ""option-y"" ) != 2 ) { return ; } if ( im -> ygridstep <= 0 ) { rrd_set_error ( ""gridstepmustbe>0"" ) ; return ; } else if ( im -> ylabfact < 1 ) { rrd_set_error ( ""labelfactormustbe>0"" ) ; return ; } } else { rrd_set_error ( ""invalidy-gridformat"" ) ; return ; } break ; case 1007 : im -> draw_3d_border = atoi ( optarg ) ; break ; case 1008 : if ( sscanf ( optarg , ""%[-0-9.e+]:%[-0-9.e+]"" , double_str , double_str2 ) != 2 ) { if ( rrd_strtodbl ( double_str , 0 , & ( im -> grid_dash_on ) , NULL ) != 2 || rrd_strtodbl ( double_str2 , 0 , & ( im -> grid_dash_off ) , NULL ) != 2 ) { rrd_set_error ( ""expectedgrid-dashformatfloat:float"" ) ; return ; } } break ; case 1009 : im -> dynamic_labels = 1 ; break ; case 1010 : strncpy ( week_fmt , optarg , sizeof week_fmt ) ; week_fmt [ ( sizeof week_fmt ) - 1 ] = '\\0' ; break ; case 1002 : if ( sscanf ( optarg , ""%[-0-9.e+]:%[-0-9.e+]"" , double_str , double_str2 ) == 2 && rrd_strtodbl ( double_str , 0 , & ( im -> second_axis_scale ) , NULL ) == 2 && rrd_strtodbl ( double_str2 , 0 , & ( im -> second_axis_shift ) , NULL ) == 2 ) { if ( im -> second_axis_scale == 0 ) { rrd_set_error ( ""thesecond_axis_scalemustnotbe0"" ) ; return ; } } else { rrd_set_error ( ""invalidright-axisformatexpectedscale:shift"" ) ; return ; } break ; case 1003 : im -> second_axis_legend = strdup ( optarg ) ; if ( ! im -> second_axis_legend ) { rrd_set_error ( ""cannotallocatememoryforsecond_axis_legend"" ) ; return ; } break ; case 1004 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""useeither%leor%lfformats"" ) ; return ; } im -> second_axis_format = strdup ( optarg ) ; if ( ! im -> second_axis_format ) { rrd_set_error ( ""cannotallocatememoryforsecond_axis_format"" ) ; return ; } break ; case 1012 :  if ( bad_format ( optarg ) ) {  rrd_set_error ( ""useeither%leor%lfformats"" ) ; return ; } im -> primary_axis_format = strdup ( optarg ) ; if ( ! im -> primary_axis_format ) { rrd_set_error ( ""cannotallocatememoryforprimary_axis_format"" ) ; return ; } break ; case 'v' : im -> ylegend = strdup ( optarg ) ; if ( ! im -> ylegend ) { rrd_set_error ( ""cannotallocatememoryforylegend"" ) ; return ; } break ; case 'u' : if ( rrd_strtodbl ( optarg , 0 , & ( im -> maxval ) , ""option-u"" ) != 2 ) { return ; } break ; case 'l' : if ( rrd_strtodbl ( optarg , 0 , & ( im -> minval ) , ""option-l"" ) != 2 ) { return ; } break ; case 'b' : im -> base = atol ( optarg ) ; if ( im -> base != 1024 && im -> base != 1000 ) { rrd_set_error ( ""theonlysensiblevalueforbaseapartfrom1000is1024"" ) ; return ; } break ; case 'w' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""widthbelow10pixels"" ) ; return ; } im -> xsize = long_tmp ; break ; case 'h' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""heightbelow10pixels"" ) ; return ; } im -> ysize = long_tmp ; break ; case 'D' : im -> extra_flags |= FULL_SIZE_MODE ; break ; case 'i' : break ; case 'r' : im -> rigid = 1 ; break ; case 'f' : im -> imginfo = optarg ; break ; case 'a' : if ( ( int ) ( im -> imgformat = if_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupportedgraphicsformat\'%s\'"" , optarg ) ; return ; } break ; case 1011 : if ( ( int ) ( im -> graph_type = type_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupportedgraphicstype\'%s\'"" , optarg ) ; return ; } break ; case 'z' : im -> lazy = 1 ; break ; case 'E' : im -> slopemode = 1 ; break ; case 'o' : im -> logarithmic = 1 ; break ; case 'c' : if ( sscanf ( optarg , ""%10[A-Z]#%n%8lx%n"" , col_nam , & col_start , & color , & col_end ) == 2 ) { int ci ; int col_len = col_end - col_start ; switch ( col_len ) { case 3 : color = ( ( ( color & 0xF00 ) * 0x110000 ) | ( ( color & 0x0F0 ) * 0x011000 ) | ( ( color & 0x00F ) * 0x001100 ) | 0x000000FF ) ; break ; case 4 : color = ( ( ( color & 0xF000 ) * 0x11000 ) | ( ( color & 0x0F00 ) * 0x01100 ) | ( ( color & 0x00F0 ) * 0x00110 ) | ( ( color & 0x000F ) * 0x00011 ) ) ; break ; case 6 : color = ( color << 8 ) + 0xff ; break ; case 8 : break ; default : rrd_set_error ( ""thecolorformatis#RRGGBB[AA]"" ) ; return ; } if ( ( ci = grc_conv ( col_nam ) ) != - 1 ) { im -> graph_col [ ci ] = gfx_hex_to_col ( color ) ; } else { rrd_set_error ( ""invalidcolorname\'%s\'"" , col_nam ) ; return ; } } else { rrd_set_error ( ""invalidcolordefformat"" ) ; return ; } break ; case 'n' : { char prop [ 15 ] ; double size = 1 ; int end ; if ( sscanf ( optarg , ""%10[A-Z]:%[-0-9.e+]%n"" , prop , double_str , & end ) >= 2 && rrd_strtodbl ( double_str , 0 , & size , NULL ) == 2 ) { int sindex , propidx ; if ( ( sindex = text_prop_conv ( prop ) ) != - 1 ) { for ( propidx = sindex ; propidx < TEXT_PROP_LAST ; propidx ++ ) { if ( size > 0 ) { rrd_set_font_desc ( im , propidx , NULL , size ) ; } if ( ( int ) strlen ( optarg ) > end + 2 ) { if ( optarg [ end ] == ':' ) { rrd_set_font_desc ( im , propidx , optarg + end + 1 , 0 ) ; } else { rrd_set_error ( ""expected:afterfontsizein\'%s\'"" , optarg ) ; return ; } } if ( propidx == sindex && sindex != 0 ) break ; } } else { rrd_set_error ( ""invalidfonttag\'%s\'"" , prop ) ; return ; } } else { rrd_set_error ( ""invalidtextpropertyformat"" ) ; return ; } break ; } case 'm' : if ( rrd_strtodbl ( optarg , 0 , & ( im -> zoom ) , ""option-m"" ) != 2 ) { return ; } if ( im -> zoom <= 0.0 ) { rrd_set_error ( ""zoomfactormustbe>0"" ) ; return ; } break ; case 't' : im -> title = strdup ( optarg ) ; if ( ! im -> title ) { rrd_set_error ( ""cannotallocatememoryfortitle"" ) ; return ; } break ; case 'R' : if ( strcmp ( optarg , ""normal"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else if ( strcmp ( optarg , ""light"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_SLIGHT ) ; } else if ( strcmp ( optarg , ""mono"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_NONE ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else { rrd_set_error ( ""unknownfont-render-mode\'%s\'"" , optarg ) ; return ; } break ; case 'G' : if ( strcmp ( optarg , ""normal"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_GRAY ; else if ( strcmp ( optarg , ""mono"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_NONE ; else { rrd_set_error ( ""unknowngraph-render-mode\'%s\'"" , optarg ) ; return ; } break ; case 'B' : break ; case 'W' : im -> watermark = strdup ( optarg ) ; if ( ! im -> watermark ) { rrd_set_error ( ""cannotallocatememoryforwatermark"" ) ; return ; } break ; case 'd' : { if ( im -> daemon_addr != NULL ) { rrd_set_error ( ""Youcannotspecify--daemon"" ""morethanonce."" ) ; return ; } im -> daemon_addr = strdup ( optarg ) ; if ( im -> daemon_addr == NULL ) { rrd_set_error ( ""strdupfailed"" ) ; return ; } break ; } case '?' : if ( optopt != 0 ) rrd_set_error ( ""unknownoption\'%c\'"" , optopt ) ; else rrd_set_error ( ""unknownoption\'%s\'"" , argv [ optind - 1 ] ) ; return ; } } pango_cairo_context_set_font_options ( pango_layout_get_context ( im -> layout ) , im -> font_options ) ; pango_layout_context_changed ( im -> layout ) ; if ( im -> logarithmic && im -> minval <= 0 ) { rrd_set_error ( ""foralogarithmicyaxisyoumustspecifyalower-limit>0"" ) ; return ; } if ( rrd_proc_start_end ( & start_tv , & end_tv , & start_tmp , & end_tmp ) == - 1 ) { return ; } if ( start_tmp < 3600 * 24 * 365 * 10 ) { rrd_set_error ( ""thefirstentrytofetchshouldbeafter1980(%ld)"" , start_tmp ) ; return ; } if ( end_tmp < start_tmp ) { rrd_set_error ( ""start(%ld)shouldbelessthanend(%ld)"" , start_tmp , end_tmp ) ; return ; } im -> start = start_tmp ; im -> end = end_tmp ; im -> step = max ( ( long ) im -> step , ( im -> end - im -> start ) / im -> xsize ) ; }", : if ( bad_format_axis ( optarg ) ) {  return ; }  : if ( bad_format_axis ( optarg ) ) {  return ; }
328,"CWE-399 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplementedHWCRwrmsr:0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplementedMMIO_CONF_BASEwrmsr:"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:MSR_IA32_DEBUGCTLMSR0x%llx,nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : {  kvmclock_reset ( vcpu ) ;  vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ;  vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;   if ( vcpu -> arch . time_offset &  ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;  vcpu -> arch . time_page =   gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;  if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplementedperfctrwrmsr:"" ""0x%xdata0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplementedperfctrwrmsr:"" ""0x%xdata0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabledperfctrwrmsr:"" ""0x%xdata0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignoredwrmsr:0x%xdata%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandledwrmsr:0x%xdata%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignoredwrmsr:0x%xdata%llx\\n"" , msr , data ) ; break ; } } return 0 ; }"," MSR_KVM_SYSTEM_TIME : { u64 gpa_offset ;  ) break ; gpa_offset  = data &  ; if ( gpa_offset  & ( sizeof  ) break ; if ( kvm_gfn_to_hva_cache_init  ( vcpu ->  -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true  ; break ;"
329,"CWE-119 static int read_header ( FFV1Context * f ) { uint8_t state [ CONTEXT_SIZE ] ; int i , j , context_count = - 1 ; RangeCoder * const c = & f -> slice_context [ 0 ] -> c ; memset ( state , 128 , sizeof ( state ) ) ; if ( f -> version < 2 ) {  unsigned v = get_symbol ( c , state , 0 ) ;  if ( v >= 2 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""invalidversion%dinver01header\\n"" , v ) ; return AVERROR_INVALIDDATA ; } f -> version = v ; f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ; if ( f -> ac > 1 ) { for ( i = 1 ; i < 256 ; i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ; } f -> colorspace = get_symbol ( c , state , 0 ) ; if ( f -> version > 0 ) f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;  f -> chroma_planes = get_rac ( c , state ) ;   f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;   f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;   f -> transparency = get_rac ( c , state ) ;  f -> plane_count = 2 + f -> transparency ; } if ( f -> colorspace == 0 ) { if ( ! f -> transparency && ! f -> chroma_planes ) { if ( f -> avctx -> bits_per_raw_sample <= 8 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } else if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; break ; case 0x01 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; break ; case 0x20 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P ; break ; case 0x22 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""formatnotsupported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency ) { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""formatnotsupported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 9 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""formatnotsupported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else if ( f -> avctx -> bits_per_raw_sample == 10 ) { f -> packed_at_lsb = 1 ; switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""formatnotsupported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } else { switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16 ; break ; case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16 ; break ; case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16 ; break ; default : av_log ( f -> avctx , AV_LOG_ERROR , ""formatnotsupported\\n"" ) ; return AVERROR ( ENOSYS ) ; } } } else if ( f -> colorspace == 1 ) { if ( f -> chroma_h_shift || f -> chroma_v_shift ) { av_log ( f -> avctx , AV_LOG_ERROR , ""chromasubsamplingnotsupportedinthiscolorspace\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( f -> avctx -> bits_per_raw_sample == 9 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9 ; else if ( f -> avctx -> bits_per_raw_sample == 10 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10 ; else if ( f -> avctx -> bits_per_raw_sample == 12 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12 ; else if ( f -> avctx -> bits_per_raw_sample == 14 ) f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14 ; else if ( f -> transparency ) f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; else f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32 ; } else { av_log ( f -> avctx , AV_LOG_ERROR , ""colorspacenotsupported\\n"" ) ; return AVERROR ( ENOSYS ) ; } av_dlog ( f -> avctx , ""%d%d%d\\n"" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ) ; if ( f -> version < 2 ) { context_count = read_quant_tables ( c , f -> quant_table ) ; if ( context_count < 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""read_quant_tableerror\\n"" ) ; return AVERROR_INVALIDDATA ; } } else if ( f -> version < 3 ) { f -> slice_count = get_symbol ( c , state , 0 ) ; } else { const uint8_t * p = c -> bytestream_end ; for ( f -> slice_count = 0 ; f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start ; f -> slice_count ++ ) { int trailer = 3 + 5 * ! ! f -> ec ; int size = AV_RB24 ( p - trailer ) ; if ( size + trailer > p - c -> bytestream_start ) break ; p -= size + trailer ; } } if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 ) { av_log ( f -> avctx , AV_LOG_ERROR , ""slicecount%disinvalid\\n"" , f -> slice_count ) ; return AVERROR_INVALIDDATA ; } for ( j = 0 ; j < f -> slice_count ; j ++ ) { FFV1Context * fs = f -> slice_context [ j ] ; fs -> ac = f -> ac ; fs -> packed_at_lsb = f -> packed_at_lsb ; fs -> slice_damaged = 0 ; if ( f -> version == 2 ) { fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width ; fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height ; fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x ; fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y ; fs -> slice_x /= f -> num_h_slices ; fs -> slice_y /= f -> num_v_slices ; fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x ; fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y ; if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height ) return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < f -> plane_count ; i ++ ) { PlaneContext * const p = & fs -> plane [ i ] ; if ( f -> version == 2 ) { int idx = get_symbol ( c , state , 0 ) ; if ( idx > ( unsigned ) f -> quant_table_count ) { av_log ( f -> avctx , AV_LOG_ERROR , ""quant_table_indexoutofrange\\n"" ) ; return AVERROR_INVALIDDATA ; } p -> quant_table_index = idx ; memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ) ; context_count = f -> context_count [ idx ] ; } else { memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ) ; } if ( f -> version <= 2 ) { av_assert0 ( context_count >= 0 ) ; if ( p -> context_count < context_count ) { av_freep ( & p -> state ) ; av_freep ( & p -> vlc_state ) ; } p -> context_count = context_count ; } } } return 0 ; }"," 2 ) { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;  0 ) ;  chroma_planes = get_rac  state ) ;  chroma_h_shift = get_symbol  0 ) ;  chroma_v_shift = get_symbol  0 ) ;  transparency = get_rac  , state ) ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalidchangeofglobalparameters\\n"" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency"
330,"CWE-476 static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct device * idev = & interface -> dev ; struct usb_device * udev = interface_to_usbdev ( interface ) ; struct lego_usb_tower * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; struct tower_get_version_reply get_version_reply ; int i ; int retval = - ENOMEM ; int result ; dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; if ( ! dev ) goto exit ; mutex_init ( & dev -> lock ) ; dev -> udev = udev ; dev -> open_count = 0 ; dev -> read_buffer = NULL ; dev -> read_buffer_length = 0 ; dev -> read_packet_length = 0 ; spin_lock_init ( & dev -> read_buffer_lock ) ; dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; dev -> read_last_arrival = jiffies ; init_waitqueue_head ( & dev -> read_wait ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> interrupt_in_buffer = NULL ; dev -> interrupt_in_endpoint = NULL ; dev -> interrupt_in_urb = NULL ; dev -> interrupt_in_running = 0 ; dev -> interrupt_in_done = 0 ; dev -> interrupt_out_buffer = NULL ; dev -> interrupt_out_endpoint = NULL ; dev -> interrupt_out_urb = NULL ; dev -> interrupt_out_busy = 0 ; iface_desc = interface -> cur_altsetting ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_xfer_int ( endpoint ) ) { if ( usb_endpoint_dir_in ( endpoint ) ) dev -> interrupt_in_endpoint = endpoint ; else dev -> interrupt_out_endpoint = endpoint ; } } if ( dev -> interrupt_in_endpoint == NULL ) { dev_err ( idev , ""interruptinendpointnotfound\\n"" ) ; goto error ; } if ( dev -> interrupt_out_endpoint == NULL ) { dev_err ( idev , ""interruptoutendpointnotfound\\n"" ) ; goto error ; } dev -> read_buffer = kmalloc ( read_buffer_size , GFP_KERNEL ) ; if ( ! dev -> read_buffer ) goto error ; dev -> interrupt_in_buffer = kmalloc ( usb_endpoint_maxp ( dev -> interrupt_in_endpoint ) , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_buffer ) goto error ; dev -> interrupt_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_urb ) goto error ; dev -> interrupt_out_buffer = kmalloc ( write_buffer_size , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_buffer ) goto error ; dev -> interrupt_out_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_urb ) goto error ; dev -> interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev -> interrupt_in_endpoint -> bInterval ; dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;  usb_set_intfdata ( interface , dev ) ;  retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Notabletogetaminorforthisdevice.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGOUSBTower#%dnowattachedtomajor"" ""%dminor%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , LEGO_USB_TOWER_REQUEST_GET_VERSION , USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE , 0 , 0 , & get_version_reply , sizeof ( get_version_reply ) , 1000 ) ; if ( result < 0 ) { dev_err ( idev , ""LEGOUSBTowergetversioncontrolrequestfailed\\n"" ) ; retval = result ; goto error ; } dev_info ( & interface -> dev , ""LEGOUSBTowerfirmwareversionis%d.%d"" ""build%d\\n"" , get_version_reply . major , get_version_reply . minor , le16_to_cpu ( get_version_reply . build_no ) ) ;  exit :  return retval ; error : tower_delete ( dev ) ; return retval ; }"," -> bInterval ;  result = usb_control_msg  ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Notabletogetaminorforthisdevice.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGOUSBTower#%dnowattachedtomajor"" ""%dminor%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;"
331,"CWE-120 void irc_server_set_prefix_modes_chars ( struct t_irc_server * server , const char * prefix ) { char * pos ;  int i , length_modes , length_chars ;  if ( ! server || ! prefix )  return ;  if ( server -> prefix_modes ) { free ( server -> prefix_modes ) ; server -> prefix_modes = NULL ; } if ( server -> prefix_chars ) { free ( server -> prefix_chars ) ; server -> prefix_chars = NULL ; } pos = strchr ( prefix , ')' ) ; if ( pos ) { server -> prefix_modes = weechat_strndup ( prefix + 1 , pos - prefix - 1 ) ; if ( server -> prefix_modes ) { pos ++ ; length_modes = strlen ( server -> prefix_modes ) ; length_chars = strlen ( pos ) ; server -> prefix_chars = malloc ( length_modes + 1 ) ; if ( server -> prefix_chars ) { for ( i = 0 ; i < length_modes ; i ++ ) { server -> prefix_chars [ i ] = ( i < length_chars ) ? pos [ i ] : '' ; } server -> prefix_chars [ length_modes ] = '\\0' ; } else { free ( server -> prefix_modes ) ; server -> prefix_modes = NULL ; } } }  } "," int i , old_length_chars ,  prefix ) return ; old_length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0  } } } length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 ; if ( server -> prefix_chars && ( length_chars != old_length_chars ) ) irc_nick_realloc_prefixes ( server , old_length_chars , length_chars ) ;"
332,CWE-362 static void queue_delete ( struct snd_seq_queue * q ) {  snd_seq_timer_stop ( q -> timer ) ;   snd_seq_timer_close ( q ) ;  snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; }, q ) { mutex_lock ( & q -> timer_mutex ) ;  snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
333,"CWE-476 SYSCALL_DEFINE5 ( add_key , const char __user * , _type , const char __user * , _description , const void __user * , _payload , size_t , plen , key_serial_t , ringid ) { key_ref_t keyring_ref , key_ref ; char type [ 32 ] , * description ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > 1024 * 1024 - 1 ) goto error ; ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ; if ( ret < 0 ) goto error ; description = NULL ; if ( _description ) { description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ; if ( IS_ERR ( description ) ) { ret = PTR_ERR ( description ) ; goto error ; } if ( ! * description ) { kfree ( description ) ; description = NULL ; } else if ( ( description [ 0 ] == '.' ) && ( strncmp ( type , ""keyring"" , 7 ) == 0 ) ) { ret = - EPERM ; goto error2 ; } } payload = NULL ;  if ( _payload ) {  ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error2 ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error3 ; } keyring_ref = lookup_user_key ( ringid , KEY_LOOKUP_CREATE , KEY_NEED_WRITE ) ; if ( IS_ERR ( keyring_ref ) ) { ret = PTR_ERR ( keyring_ref ) ; goto error3 ; } key_ref = key_create_or_update ( keyring_ref , type , description , payload , plen , KEY_PERM_UNDEF , KEY_ALLOC_IN_QUOTA ) ; if ( ! IS_ERR ( key_ref ) ) { ret = key_ref_to_ptr ( key_ref ) -> serial ; key_ref_put ( key_ref ) ; } else { ret = PTR_ERR ( key_ref ) ; } key_ref_put ( keyring_ref ) ; error3 : kvfree ( payload ) ; error2 : kfree ( description ) ; error : return ret ; }", ; if ( plen  ) { ret
334,"CWE-399 static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ;  struct address_space * mapping ;  mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ;  if ( mapping )  hugetlb_put_quota ( mapping , 1 ) ; }"," ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool  * ) page_private  hugetlb_lock ) ; hugepage_subpool_put_pages ( spool  , 1 )"
335,"CWE-000 static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ;  struct sk_buff * skb ;  skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ;  if ( dump_one_state ( x , 0 , & info ) ) {  kfree_skb ( skb ) ;  return NULL ;  } return skb ; }", sk_buff * skb ; int err  = 0 ; err =  dump_one_state ( x  & info ) ; if ( err  ) ; return ERR_PTR ( err )  ; } return
336,"CWE-119 static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) return error ( f , VORBIS_invalid_first_page ) ; if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; for ( j = 0 ; j < g -> values ; ++ j ) g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { m -> coupling_steps = get_bits ( f , 8 ) + 1 ; for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ;  int n_read = r -> end - r -> begin ;  int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }", + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ;  int n_read = limit_r_end - limit_r_begin  ; int part_read
337,"CWE-119 static BOOL rdp_read_font_capability_set ( wStream * s , UINT16 length , rdpSettings * settings ) { WINPR_UNUSED ( settings ) ;  if ( length > 4 )  Stream_Seek_UINT16 ( s ) ;  if ( length > 6 )  Stream_Seek_UINT16 ( s ) ; return TRUE ; }", ( length > 5  ) Stream_Seek_UINT16 (  ( length > 7  ) Stream_Seek_UINT16 (
338,"CWE-665 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ;  uint32_t bcount ;  infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""formattagsize=%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag=%x,NumChannels=%d,BitsPerSample=%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign=%d,SampleRate=%d,BytesPerSecond=%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize=%d,ValidBitsPerSample=%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask=%x,SubFormat=%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%sisanunsupported.W64format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisW64filealreadyhaschannelorderinformation!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""dataformat:normalized32-bitfloatingpoint"" ) ; else error_line ( ""dataformat:%d-bitintegersstoredin%dbyte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this.W64filehasover16MBofextraRIFFdata,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this.W64filehasnoaudiosamples,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%shastoomanysamplesforWavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }", ; uint32_t bcount ; CLEAR ( WaveHeader )
339,CWE-399  void unix_notinflight ( struct file * fp )  { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; }  fp -> f_cred -> user -> unix_inflight -- ;  spin_unlock ( & unix_gc_lock ) ; }," void unix_notinflight ( struct user_struct * user ,  -- ; }  user -> unix_inflight"
340,"CWE-119 static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ;  if ( argReg >= regsz ) {  } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = ""this"" ; debug_locals [ argReg ] . descriptor = r_str_newf ( ""%s;"" , class_name ) ; debug_locals [ argReg ] . startAddress = 0 ; debug_locals [ argReg ] . signature = NULL ; debug_locals [ argReg ] . live = true ; argReg ++ ; } if ( ! ( params = dex_method_signature2 ( bin , MI ) ) ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; return ; } RListIter * iter = r_list_iterator ( params ) ; char * name ; char * type ; int reg ; r_list_foreach ( params , iter , type ) { if ( ( argReg >= regsz ) || ! type || parameters_size <= 0 ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; r_list_free ( emitted_debug_locals ) ; return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & param_type_idx ) ; param_type_idx -= 1 ; name = getstr ( bin , param_type_idx ) ; reg = argReg ; switch ( type [ 0 ] ) { case 'D' : case 'J' : argReg += 2 ; break ; default : argReg += 1 ; break ; } if ( name ) { debug_locals [ reg ] . name = name ; debug_locals [ reg ] . descriptor = type ; debug_locals [ reg ] . signature = NULL ; debug_locals [ reg ] . startAddress = address ; debug_locals [ reg ] . live = true ; } -- parameters_size ; } ut8 opcode = * ( p4 ++ ) & 0xff ; while ( keep ) { switch ( opcode ) { case 0x0 : keep = false ; break ; case 0x1 : { ut64 addr_diff ; p4 = r_uleb128 ( p4 , p4_end - p4 , & addr_diff ) ; address += addr_diff ; } break ; case 0x2 : { st64 line_diff = r_sleb128 ( & p4 , p4_end ) ; line += line_diff ; } break ; case 0x3 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = NULL ; debug_locals [ register_num ] . live = true ; } break ; case 0x4 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; ut64 sig_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & sig_idx ) ; sig_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = getstr ( bin , sig_idx ) ; debug_locals [ register_num ] . live = true ; } break ; case 0x5 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . live = false ; } break ; case 0x6 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( ! debug_locals [ register_num ] . live ) { debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . live = true ; } } break ; case 0x7 : break ; case 0x8 : break ; case 0x9 : { p4 = r_uleb128 ( p4 , p4_end - p4 , & source_file_idx ) ; source_file_idx -- ; } break ; default : { int adjusted_opcode = opcode - 0x0a ; address += ( adjusted_opcode / 15 ) ; line += - 4 + ( adjusted_opcode % 15 ) ; struct dex_debug_position_t * position = malloc ( sizeof ( struct dex_debug_position_t ) ) ; if ( ! position ) { keep = false ; break ; } position -> source_file_idx = source_file_idx ; position -> address = address ; position -> line = line ; r_list_append ( debug_positions , position ) ; } break ; } opcode = * ( p4 ++ ) & 0xff ; } if ( ! binfile -> sdb_addrinfo ) { binfile -> sdb_addrinfo = sdb_new0 ( ) ; } char * fileline ; char offset [ 64 ] ; char * offset_ptr ; RListIter * iter1 ; struct dex_debug_position_t * pos ; r_list_foreach ( debug_positions , iter1 , pos ) { fileline = r_str_newf ( ""%s|%"" PFMT64d , getstr ( bin , pos -> source_file_idx ) , pos -> line ) ; offset_ptr = sdb_itoa ( pos -> address + paddr , offset , 16 ) ; sdb_set ( binfile -> sdb_addrinfo , offset_ptr , fileline , 0 ) ; sdb_set ( binfile -> sdb_addrinfo , fileline , offset_ptr , 0 ) ; } if ( ! dexdump ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; return ; } RListIter * iter2 ; struct dex_debug_position_t * position ; rbin -> cb_printf ( ""positions:\\n"" ) ; r_list_foreach ( debug_positions , iter2 , position ) { rbin -> cb_printf ( ""0x%04llxline=%llu\\n"" , position -> address , position -> line ) ; } rbin -> cb_printf ( ""locals:\\n"" ) ; RListIter * iter3 ; struct dex_debug_local_t * local ; r_list_foreach ( emitted_debug_locals , iter3 , local ) { if ( local -> signature ) { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor , local -> signature ) ; } else { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor ) ; } } for ( reg = 0 ; reg < regsz ; reg ++ ) { if ( debug_locals [ reg ] . live ) { if ( debug_locals [ reg ] . signature ) { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s"" ""%s\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor , debug_locals [ reg ] . signature ) ; } else { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s"" ""\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor ) ; } } } r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; }", if ( argReg >  regsz ) {  regsz ) { return ;
341,"CWE-119 static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t columns ,  number_threads ;   number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;   pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ;  ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;  columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;  for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ )  { pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images , & pixels [ i ] [ j ] ) ; } return ( pixels ) ; }"," size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) ,  ( size_t )  ( ThreadResource ) )  ) AcquireQuantumMemory ( rows ,  sizeof ( *  NULL ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0  ; i <  ( ssize_t ) rows  ; i ++"
342,"CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; }  EVP_MD_CTX_init ( & ctx ) ;  if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }"," 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }"
343,"CWE-78 static void  build_config ( char * prefix , struct server * server )  { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ; FILE * f = fopen ( path , ""w+"" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( ""unabletoopenconfigfile"" ) ; } ss_free ( path ) ; return ; } fprintf ( f , ""{\\n"" ) ; fprintf ( f , ""\\""server_port\\"":%d,\\n"" , atoi ( server -> port ) ) ;  fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ;  if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\n\\""fast_open\\"":%s"" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , "",\\n\\""mode\\"":\\""%s\\"""" , server -> mode ) ;  if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ;  if ( server -> plugin ) fprintf ( f , "",\\n\\""plugin\\"":\\""%s\\"""" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , "",\\n\\""plugin_opts\\"":\\""%s\\"""" , server -> plugin_opts ) ; fprintf ( f , ""\\n}\\n"" ) ; fclose ( f ) ; ss_free ( path ) ; }"," prefix , struct manager_ctx * manager , struct  server -> password ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method  ( server ->  plugin ) fprintf"
344,"CWE-476 static int SMB2_sess_establish_session ( struct SMB2_sess_data * sess_data ) { int rc = 0 ; struct cifs_ses * ses = sess_data -> ses ; mutex_lock ( & ses -> server -> srv_mutex ) ;  if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) {   rc = ses -> server -> ops -> generate_signingkey ( ses ) ;  kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; if ( rc ) { cifs_dbg ( FYI , ""SMB3sessionkeygenerationfailed\\n"" ) ; mutex_unlock ( & ses -> server -> srv_mutex ) ;  goto keygen_exit ;  } } if ( ! ses -> server -> session_estab ) { ses -> server -> sequence_number = 0x2 ; ses -> server -> session_estab = true ; } mutex_unlock ( & ses -> server -> srv_mutex ) ; cifs_dbg ( FYI , ""SMB2/3sessionestablishedsuccessfully\\n"" ) ; spin_lock ( & GlobalMid_Lock ) ; ses -> status = CifsGood ; ses -> need_reconnect = false ; spin_unlock ( & GlobalMid_Lock ) ;  keygen_exit :  if ( ! ses -> server -> sign ) { kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; } return rc ; }", -> server ->  ops -> generate_signingkey  ( ses )  ; if (  srv_mutex ) ; return rc  ; } }  GlobalMid_Lock ) ;  return rc ;
345,"CWE-000 static void hub_activate ( struct usb_hub * hub , enum hub_activation_type type ) { struct usb_device * hdev = hub -> hdev ; struct usb_hcd * hcd ; int ret ; int port1 ; int status ; bool need_debounce_delay = false ; unsigned delay ;  if ( type == HUB_INIT2 )  goto init2 ;  if ( type == HUB_INIT3 )  goto init3 ; if ( type != HUB_RESUME ) { if ( hdev -> parent && hub_is_superspeed ( hdev ) ) { ret = usb_control_msg ( hdev , usb_sndctrlpipe ( hdev , 0 ) , HUB_SET_DEPTH , USB_RT_HUB , hdev -> level - 1 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) dev_err ( hub -> intfdev , ""sethubdepthfailed\\n"" ) ; } if ( type == HUB_INIT ) { delay = hub_power_on_good_delay ( hub ) ; hub_power_on ( hub , false ) ; INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func2 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ; usb_autopm_get_interface_no_resume ( to_usb_interface ( hub -> intfdev ) ) ; return ; } else if ( type == HUB_RESET_RESUME ) { hcd = bus_to_hcd ( hdev -> bus ) ; if ( hcd -> driver -> update_hub_device ) { ret = hcd -> driver -> update_hub_device ( hcd , hdev , & hub -> tt , GFP_NOIO ) ; if ( ret < 0 ) { dev_err ( hub -> intfdev , ""Hostnot"" ""acceptinghubinfo"" ""update.\\n"" ) ; dev_err ( hub -> intfdev , ""LS/FSdevices"" ""andhubsmaynotwork"" ""underthishub\\n."" ) ; } } hub_power_on ( hub , true ) ; } else { hub_power_on ( hub , true ) ; } } init2 : for ( port1 = 1 ; port1 <= hdev -> maxchild ; ++ port1 ) { struct usb_port * port_dev = hub -> ports [ port1 - 1 ] ; struct usb_device * udev = port_dev -> child ; u16 portstatus , portchange ; portstatus = portchange = 0 ; status = hub_port_status ( hub , port1 , & portstatus , & portchange ) ; if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) ) dev_dbg ( & port_dev -> dev , ""status%04xchange%04x\\n"" , portstatus , portchange ) ; if ( ( portstatus & USB_PORT_STAT_ENABLE ) && ( type != HUB_RESUME || ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ! udev || udev -> state == USB_STATE_NOTATTACHED ) ) { portstatus &= ~ USB_PORT_STAT_ENABLE ; if ( ! hub_is_superspeed ( hdev ) ) usb_clear_port_feature ( hdev , port1 , USB_PORT_FEAT_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_CONNECTION ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_CONNECTION ) ; } if ( portchange & USB_PORT_STAT_C_ENABLE ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_ENABLE ) ; } if ( portchange & USB_PORT_STAT_C_RESET ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_RESET ) ; } if ( ( portchange & USB_PORT_STAT_C_BH_RESET ) && hub_is_superspeed ( hub -> hdev ) ) { need_debounce_delay = true ; usb_clear_port_feature ( hub -> hdev , port1 , USB_PORT_FEAT_C_BH_PORT_RESET ) ; } if ( ! ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portchange & USB_PORT_STAT_C_CONNECTION ) ) clear_bit ( port1 , hub -> removed_bits ) ; if ( ! udev || udev -> state == USB_STATE_NOTATTACHED ) { if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) || ( portstatus & USB_PORT_STAT_OVERCURRENT ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( portstatus & USB_PORT_STAT_ENABLE ) { bool port_resumed = ( portstatus & USB_PORT_STAT_LINK_STATE ) == USB_SS_PORT_LS_U0 ; if ( portchange || ( hub_is_superspeed ( hub -> hdev ) && port_resumed ) ) set_bit ( port1 , hub -> change_bits ) ; } else if ( udev -> persist_enabled ) { # ifdef CONFIG_PM udev -> reset_resume = 1 ; # endif if ( test_bit ( port1 , hub -> power_bits ) ) set_bit ( port1 , hub -> change_bits ) ; } else { usb_set_device_state ( udev , USB_STATE_NOTATTACHED ) ; set_bit ( port1 , hub -> change_bits ) ; } } if ( need_debounce_delay ) { delay = HUB_DEBOUNCE_STABLE ; if ( type == HUB_INIT2 ) { INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func3 ) ; queue_delayed_work ( system_power_efficient_wq , & hub -> init_work , msecs_to_jiffies ( delay ) ) ;  return ;  } else { msleep ( delay ) ; } } init3 : hub -> quiescing = 0 ; status = usb_submit_urb ( hub -> urb , GFP_NOIO ) ; if ( status < 0 ) dev_err ( hub -> intfdev , ""activate-->%d\\n"" , status ) ; if ( hub -> has_indicators && blinkenlights ) queue_delayed_work ( system_power_efficient_wq , & hub -> leds , LED_CYCLE_PERIOD ) ; kick_hub_wq ( hub ) ; if ( type <= HUB_INIT3 ) usb_autopm_put_interface_async ( to_usb_interface ( hub -> intfdev ) ) ;  } "," type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2  goto init2 ; goto init3 ; } kref_get ( & hub -> kref )  ; if (  ) ) ; device_unlock ( hub -> intfdev ) ;  ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;"
346,"CWE-264 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; # ifndef CONFIG_S390 if ( npages && ! new . rmap ) { new . rmap = vzalloc ( npages * sizeof ( * new . rmap ) ) ; if ( ! new . rmap ) goto out_free ; new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; } if ( ! npages ) goto skip_lpage ; for ( i = 0 ; i < KVM_NR_PAGE_SIZES - 1 ; ++ i ) { unsigned long ugfn ; unsigned long j ; int lpages ; int level = i + 2 ; ( void ) level ; if ( new . lpage_info [ i ] ) continue ; lpages = 1 + ( ( base_gfn + npages - 1 ) >> KVM_HPAGE_GFN_SHIFT ( level ) ) ; lpages -= base_gfn >> KVM_HPAGE_GFN_SHIFT ( level ) ; new . lpage_info [ i ] = vzalloc ( lpages * sizeof ( * new . lpage_info [ i ] ) ) ; if ( ! new . lpage_info [ i ] ) goto out_free ; if ( base_gfn & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) ) new . lpage_info [ i ] [ 0 ] . write_count = 1 ; if ( ( base_gfn + npages ) & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) ) new . lpage_info [ i ] [ lpages - 1 ] . write_count = 1 ; ugfn = new . userspace_addr >> PAGE_SHIFT ; if ( ( base_gfn ^ ugfn ) & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) || ! largepages_enabled ) for ( j = 0 ; j < lpages ; ++ j ) new . lpage_info [ i ] [ j ] . write_count = 1 ; } skip_lpage : if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } # else new . user_alloc = user_alloc ; if ( user_alloc ) new . userspace_addr = mem -> userspace_addr ; # endif if ( ! npages ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow ( kvm ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ;  }  r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . rmap = NULL ; new . dirty_bitmap = NULL ; for ( i = 0 ; i < KVM_NR_PAGE_SIZES - 1 ; ++ i ) new . lpage_info [ i ] = NULL ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }"," out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ;"
347,"CWE-119 static int atusb_get_and_show_revision ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ;  unsigned char buffer [ 3 ] ;  int ret ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_ID , ATUSB_REQ_FROM_DEV , 0 , 0 , buffer , 3 , 1000 ) ; if ( ret >= 0 ) { atusb -> fw_ver_maj = buffer [ 0 ] ; atusb -> fw_ver_min = buffer [ 1 ] ; atusb -> fw_hw_type = buffer [ 2 ] ; dev_info ( & usb_dev -> dev , ""Firmware:major:%u,minor:%u,hardwaretype:%u\\n"" , atusb -> fw_ver_maj , atusb -> fw_ver_min , atusb -> fw_hw_type ) ; } if ( atusb -> fw_ver_maj == 0 && atusb -> fw_ver_min < 2 ) { dev_info ( & usb_dev -> dev , ""Firmwareversion(%u.%u)predatesourfirstpublicrelease."" , atusb -> fw_ver_maj , atusb -> fw_ver_min ) ; dev_info ( & usb_dev -> dev , ""Pleaseupdatetoversion0.2ornewer"" ) ; }  return ret ;  }"," ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM  ; ret =  ) ; } kfree ( buffer ) ;"
348,"CWE-20 EXPORTED const char * dlist_reserve_path ( const char * part , int isarchive , const struct message_guid * guid ) { static char buf [ MAX_MAILBOX_PATH ] ;  const char * base ;  if ( strchr ( part , '/' ) ) { base = part ; } else { base = isarchive ? config_archivepartitiondir ( part ) : config_partitiondir ( part ) ;  }  assert ( base != NULL ) ; snprintf ( buf , MAX_MAILBOX_PATH , ""%s/sync./%lu/%s"" , base , ( unsigned long ) getpid ( ) , message_guid_encode ( guid ) ) ; if ( cyrus_mkdir ( buf , 0755 ) ) { syslog ( LOG_ERR , ""IOERROR:failedtocreate%s/sync./%lu/forreserve:%m"" , base , ( unsigned long ) getpid ( ) ) ; } return buf ; }", char * base  = isarchive ?  part ) ;  assert ( base
349,"CWE-77 static int save_dev ( blkid_dev dev , FILE * file ) { struct list_head * p ; if ( ! dev || dev -> bid_name [ 0 ] != '/' ) return 0 ; DBG ( SAVE , ul_debug ( ""device%s,type%s"" , dev -> bid_name , dev -> bid_type ? dev -> bid_type : ""(null)"" ) ) ; fprintf ( file , ""<deviceDEVNO=\\""0x%04lx\\""TIME=\\""%ld.%ld\\"""" , ( unsigned long ) dev -> bid_devno , ( long ) dev -> bid_time , ( long ) dev -> bid_utime ) ; if ( dev -> bid_pri ) fprintf ( file , ""PRI=\\""%d\\"""" , dev -> bid_pri ) ; list_for_each ( p , & dev -> bid_tags ) { blkid_tag tag = list_entry ( p , struct blkid_struct_tag , bit_tags ) ;  fprintf ( file , ""%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ;  } fprintf ( file , "">%s</device>\\n"" , dev -> bid_name ) ; return 0 ; }"," bit_tags ) ; fputc ( '' , file ) ; fputs (  tag -> bit_name  -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted (  tag -> bit_val , file"
350,"CWE-674 static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) {  if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }"," { if ( js_doregexec ( J ,  re -> prog"
351,"CWE-264 static int load_state_from_tss16 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_16 * tss ) { int ret ; u8 cpl ; ctxt -> _eip = tss -> ip ; ctxt -> eflags = tss -> flag | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> ax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> cx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> dx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> bx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> sp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> bp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> si ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> di ; set_segment_selector ( ctxt , tss -> ldt , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; cpl = tss -> cs & 3 ;  ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }"," , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if"
352,"CWE-119 int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type ,  int qindex , double rate_target_ratio ) {  int target_index = rc -> worst_quality ; int i ;  const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ;  const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) {  target_index = i ;   if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb )  break ; } return target_index - qindex ; }"," , double rate_target_ratio , vpx_bit_depth_t bit_depth  qindex , 1.0 , bit_depth  i ) {  if ( vp9_rc_bits_per_mb  i , 1.0 , bit_depth  <= target_bits_per_mb ) { target_index = i ; break ; }  } return target_index"
353,"CWE-000 static int crypto_report_acomp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_acomp racomp ;  strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;  if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }", crypto_report_acomp racomp ; strncpy  ( racomp .
354,"CWE-20 error_t webSocketParseRequestLine ( WebSocket * webSocket , char_t * line ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; TRACE_DEBUG ( ""%s"" , line ) ; token = osStrtok_r ( line , ""\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; if ( osStrcasecmp ( token , ""GET"" ) ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ;  s = strchr ( token , '?' ) ;  if ( s != NULL ) { * s = '\\0' ; error = webSocketDecodePercentEncodedString ( token , webSocket -> uri , WEB_SOCKET_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > WEB_SOCKET_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( webSocket -> queryString , s + 1 ) ; } else { error = webSocketDecodePercentEncodedString ( token , webSocket -> uri , WEB_SOCKET_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; webSocket -> queryString [ 0 ] = '\\0' ; } token = osStrtok_r ( NULL , ""\\r\\n"" , & p ) ; if ( token == NULL ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_0_9 ; webSocket -> handshakeContext . connectionClose = TRUE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_1_0 ; webSocket -> handshakeContext . connectionClose = TRUE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { webSocket -> handshakeContext . version = WS_HTTP_VERSION_1_1 ; webSocket -> handshakeContext . connectionClose = FALSE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }"," ; s = osStrchr  ( token ,"
355,"CWE-125 static void exif_mnote_data_pentax_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataPentax * n = ( ExifMnoteDataPentax * ) en ; size_t i , tcount , o , datao , base = 0 ; ExifShort c ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ; return ; } datao = 6 + n -> offset ;  if ( ( datao + 8 < datao ) || ( datao + 8 < 8 ) || ( datao + 8 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ; return ; } if ( ! memcmp ( buf + datao , ""AOC"" , 4 ) ) { if ( ( buf [ datao + 4 ] == 'I' ) && ( buf [ datao + 5 ] == 'I' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_INTEL ; } else if ( ( buf [ datao + 4 ] == 'M' ) && ( buf [ datao + 5 ] == 'M' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> version = pentaxV2 ; } exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""ParsingPentaxmakernotev%d..."" , ( int ) n -> version ) ; datao += 4 + 2 ; base = MNOTE_PENTAX2_TAG_BASE ; } else if ( ! memcmp ( buf + datao , ""QVC"" , 4 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""ParsingCasiomakernotev2..."" ) ; n -> version = casioV2 ; base = MNOTE_CASIO2_TAG_BASE ; datao += 4 + 2 ; } else { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""ParsingPentaxmakernotev1..."" ) ; n -> version = pentaxV1 ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_pentax_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnotePentaxEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , sizeof ( MnotePentaxEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ;  break ; }  n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ;  n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnotePentax"" , ""Loadingentry0x%x(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_pentax_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ;  if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""Tagdatapastend"" ""ofbuffer(%u>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }"," ; if ( CHECKOVERFLOW ( datao , buf_size , 8  ) ) {  ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnotePentax"" , ""Loadingentry0x%x(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_pentax_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components  ) { exif_log  , ""ExifMnoteDataPentax"" , ""Tagsizeoverflowdetected(%u*%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components  ) ; break  break ; }  s = exif_format_get_size  ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""Tagdatapastend"" ""ofbuffer(%u>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s  ) ; }"
356,"CWE-362 static int snd_ctl_elem_user_get ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { struct user_element * ue = kcontrol -> private_data ;  memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ;   return 0 ;  }", -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ;  elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
357,"CWE-399 static int dcbnl_cee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * cee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx , i , err = - EMSGSIZE ; u8 value ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) goto nla_put_failure ; cee = nla_nest_start ( skb , DCB_ATTR_CEE ) ; if ( ! cee ) goto nla_put_failure ; if ( ops -> getpgtccfgtx && ops -> getpgbwgcfgtx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 1 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpgtccfgrx && ops -> getpgbwgcfgrx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 0 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpfccfg ) { struct nlattr * pfc_nest = nla_nest_start ( skb , DCB_ATTR_CEE_PFC ) ; if ( ! pfc_nest ) goto nla_put_failure ; for ( i = DCB_PFC_UP_ATTR_0 ; i <= DCB_PFC_UP_ATTR_7 ; i ++ ) { ops -> getpfccfg ( netdev , i - DCB_PFC_UP_ATTR_0 , & value ) ; if ( nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; } nla_nest_end ( skb , pfc_nest ) ; } spin_lock ( & dcb_lock ) ; app = nla_nest_start ( skb , DCB_ATTR_CEE_APP_TABLE ) ; if ( ! app ) goto dcb_unlock ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { struct nlattr * app_nest = nla_nest_start ( skb , DCB_ATTR_APP ) ; if ( ! app_nest ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_IDTYPE , itr -> app . selector ) ; if ( err ) goto dcb_unlock ; err = nla_put_u16 ( skb , DCB_APP_ATTR_ID , itr -> app . protocol ) ; if ( err ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_PRIORITY , itr -> app . priority ) ; if ( err ) goto dcb_unlock ; nla_nest_end ( skb , app_nest ) ; } } nla_nest_end ( skb , app ) ; if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; if ( ops -> getfeatcfg ) { struct nlattr * feat = nla_nest_start ( skb , DCB_ATTR_CEE_FEAT ) ; if ( ! feat ) goto nla_put_failure ; for ( i = DCB_FEATCFG_ATTR_ALL + 1 ; i <= DCB_FEATCFG_ATTR_MAX ; i ++ ) if ( ! ops -> getfeatcfg ( netdev , i , & value ) && nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; nla_nest_end ( skb , feat ) ; } if ( ops -> cee_peer_getpg ) { struct cee_pg pg ;  err = ops -> cee_peer_getpg ( netdev , & pg ) ;  if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ; } if ( ops -> cee_peer_getpfc ) {  struct cee_pfc pfc ;  err = ops -> cee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) goto nla_put_failure ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_CEE_PEER_APP_TABLE , DCB_ATTR_CEE_PEER_APP_INFO , DCB_ATTR_CEE_PEER_APP ) ; if ( err ) goto nla_put_failure ; } nla_nest_end ( skb , cee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) goto nla_put_failure ; } return 0 ; dcb_unlock : spin_unlock ( & dcb_lock ) ; nla_put_failure : return err ; }"," cee_pg pg ; memset ( & pg , 0 , sizeof ( pg ) ) ;  struct cee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )"
358,"CWE-200 static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ;  unsigned facility ;  struct option long_options [ ] = { { ""use-file"" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { ""vrrp"" , no_argument , NULL , 'P' } , { ""check"" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { ""no_bfd"" , no_argument , NULL , 'B' } , # endif { ""all"" , no_argument , NULL , 3 } , { ""log-console"" , no_argument , NULL , 'l' } , { ""log-detail"" , no_argument , NULL , 'D' } , { ""log-facility"" , required_argument , NULL , 'S' } , { ""log-file"" , optional_argument , NULL , 'g' } , { ""flush-log-file"" , no_argument , NULL , 2 } , { ""no-syslog"" , no_argument , NULL , 'G' } ,  # ifdef _WITH_VRRP_  { ""release-vips"" , no_argument , NULL , 'X' } , { ""dont-release-vrrp"" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { ""dont-release-ipvs"" , no_argument , NULL , 'I' } , # endif { ""dont-respawn"" , no_argument , NULL , 'R' } , { ""dont-fork"" , no_argument , NULL , 'n' } , { ""dump-conf"" , no_argument , NULL , 'd' } , { ""pid"" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { ""vrrp_pid"" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { ""checkers_pid"" , required_argument , NULL , 'c' } , { ""address-monitoring"" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { ""bfd_pid"" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { ""snmp"" , no_argument , NULL , 'x' } , { ""snmp-agent-socket"" , required_argument , NULL , 'A' } , # endif { ""core-dump"" , no_argument , NULL , 'm' } , { ""core-dump-pattern"" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { ""mem-check-log"" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { ""namespace"" , required_argument , NULL , 's' } , # endif { ""config-id"" , required_argument , NULL , 'i' } , { ""signum"" , required_argument , NULL , 4 } , { ""config-test"" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { ""perf"" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { ""debug"" , optional_argument , NULL , 6 } , # endif { ""version"" , no_argument , NULL , 'v' } , { ""help"" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ;  while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::""  # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , ""%s"" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , "",gitcommit%s"" , GIT_COMMIT ) ; # endif fprintf ( stderr , ""\\n\\n%s\\n\\n"" , COPYRIGHT_STRING ) ; fprintf ( stderr , ""BuiltwithkernelheadersforLinux%d.%d.%d\\n"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , ""Runningon%s%s%s\\n\\n"" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , ""configureoptions:%s\\n\\n"" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , ""Configoptions:%s\\n\\n"" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , ""Systemoptions:%s\\n"" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , ""Invalidlogfacility\'%s\'\\n"" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = ""/tmp/keepalived.log"" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ;  case 't' :  __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; if ( fd == - 1 ) { fprintf ( stderr , ""Unabletoopenconfig-testlogfile%s\\n"" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , ""Unknownsigfunc%s\\n"" , optarg ) ; exit ( 1 ) ; } printf ( ""%d\\n"" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , ""run"" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , ""all"" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , ""end"" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , ""Unknownperfstartpoint%s"" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Unknownoption-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Unknownoption%s\\n"" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Missingparameterforoption-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Missingparameterforoption--%s\\n"" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( ""Unexpectedargument(s):"" ) ; while ( optind < argc ) printf ( ""%s"" , argv [ optind ++ ] ) ; printf ( ""\\n"" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }"," ; unsigned facility ; mode_t new_umask_val  'G' } , { ""umask"" , required_argument , NULL , 'u' } ,  , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::""  # if defined  break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case"
359,CWE-476 static int asymmetric_key_match_preparse ( struct key_match_data * match_data ) { match_data -> lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE ;  return 0 ;  }, = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
360,"CWE-362 static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ;  struct address_space * mapping = inode -> i_mapping ;  unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; }  if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) {  ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex ; } if ( max_blocks > 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;  truncate_pagecache_range ( inode , start , end - 1 ) ;  inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;  ext4_inode_block_unlocked_dio ( inode ) ;  inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size ,  flags , mode ) ;  if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }"," ext4_lblk_t lblk ;  unsigned int blkbits  ret ; }  start = round_up  EXT4_EX_NOCACHE ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  inode ) ;  ret = ext4_alloc_file_blocks  flags , mode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem"
361,"CWE-20 apr_status_t h2_stream_add_header ( h2_stream * stream , const char * name , size_t nlen , const char * value , size_t vlen ) {  ap_assert ( stream ) ;   if ( ! stream -> has_response ) {  if ( name [ 0 ] == ':' ) { if ( ( vlen ) > stream -> session -> s -> limit_req_line ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):pseudoheader%stoolong"" , stream -> session -> id , stream -> id , name ) ;  return h2_stream_set_error ( stream ,  HTTP_REQUEST_URI_TOO_LARGE ) ; } } else if ( ( nlen + 2 + vlen ) > stream -> session -> s -> limit_req_fieldsize ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):header%stoolong"" , stream -> session -> id , stream -> id , name ) ;  return h2_stream_set_error ( stream ,   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ) ;  } if ( name [ 0 ] != ':' ) { ++ stream -> request_headers_added ; if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):toomanyheaderlines"" , stream -> session -> id , stream -> id ) ; return h2_stream_set_error ( stream , HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ) ; } } } if ( h2_stream_is_scheduled ( stream ) ) { return add_trailer ( stream , name , nlen , value , vlen ) ; } else { if ( ! stream -> rtmp ) { stream -> rtmp = h2_req_create ( stream -> id , stream -> pool , NULL , NULL , NULL , NULL , NULL , 0 ) ; } if ( stream -> state != H2_STREAM_ST_OPEN ) { return APR_ECONNRESET ; } return h2_request_add_header ( stream -> rtmp , stream -> pool , name , nlen , value , vlen ) ; } }"," vlen ) { int error = 0 ;  ; if (  stream -> has_response  has_response ) { return APR_EINVAL ; } ++ stream -> request_headers_added ;  name ) ; error = HTTP_REQUEST_URI_TOO_LARGE  ; } }  name ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 ) { if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 + 100 ) { return APR_ECONNRESET ; } ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):toomanyheaderlines"" , stream -> session -> id , stream -> id ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( h2_stream_is_scheduled ( stream ) ) { return add_trailer ( stream , name , nlen , value , vlen ) ; } else if ( error ) {  ( stream , error  ) ; }"
362,"CWE-264 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , ""Memorysqueezeonfr_add_pvc()\\n"" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ;  if ( type == ARPHRD_ETHER )  dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;  else  dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memorysqueezeonfr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }", == ARPHRD_ETHER ) {  ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
363,"CWE-20 static int do_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags , pte_t orig_pte ) { pgoff_t pgoff = ( ( ( address & PAGE_MASK ) - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;  pte_unmap ( page_table ) ;  if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; if ( ! ( vma -> vm_flags & VM_SHARED ) ) return do_cow_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; return do_shared_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; }", ( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
364,"CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ;  if ( * p == FAC_CCITT_DEST_NSAP ) {  memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }", ; if ( l < 10 || l > 20 ) return - 1 ; if (
365,"CWE-189 void set_fat ( DOS_FS * fs , uint32_t cluster , int32_t new ) { unsigned char * data = NULL ; int size ; loff_t offs ; if ( new == - 1 ) new = FAT_EOF ( fs ) ; else if ( ( long ) new == - 2 ) new = FAT_BAD ( fs ) ; switch ( fs -> fat_bits ) { case 12 : data = fs -> fat + cluster * 3 / 2 ; offs = fs -> fat_start + cluster * 3 / 2 ; if ( cluster & 1 ) { FAT_ENTRY prevEntry ; get_fat ( & prevEntry , fs -> fat , cluster - 1 , fs ) ; data [ 0 ] = ( ( new & 0xf ) << 4 ) | ( prevEntry . value >> 8 ) ; data [ 1 ] = new >> 4 ; } else { FAT_ENTRY subseqEntry ;  if ( cluster != fs -> clusters - 1 )  get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ; else subseqEntry . value = 0 ; data [ 0 ] = new & 0xff ; data [ 1 ] = ( new >> 8 ) | ( ( 0xff & subseqEntry . value ) << 4 ) ; } size = 2 ; break ; case 16 : data = fs -> fat + cluster * 2 ; offs = fs -> fat_start + cluster * 2 ; * ( unsigned short * ) data = htole16 ( new ) ; size = 2 ; break ; case 32 : { FAT_ENTRY curEntry ; get_fat ( & curEntry , fs -> fat , cluster , fs ) ; data = fs -> fat + cluster * 4 ; offs = fs -> fat_start + cluster * 4 ; * ( uint32_t * ) data = htole32 ( ( new & 0xfffffff ) | ( curEntry . reserved << 28 ) ) ; size = 4 ; } break ; default : die ( ""BadFATentrysize:%dbits."" , fs -> fat_bits ) ; } fs_write ( offs , size , data ) ; if ( fs -> nfats > 1 ) { fs_write ( offs + fs -> fat_size , size , data ) ; } }", fs -> clusters +  1 ) get_fat
366,"CWE-200 static void ParseCommon ( map_string_t * settings , const char * conf_filename ) { const char * value ; value = get_map_string_item_or_NULL ( settings , ""WatchCrashdumpArchiveDir"" ) ; if ( value ) { g_settings_sWatchCrashdumpArchiveDir = xstrdup ( value ) ; remove_map_string_item ( settings , ""WatchCrashdumpArchiveDir"" ) ; } value = get_map_string_item_or_NULL ( settings , ""MaxCrashReportsSize"" ) ; if ( value ) { char * end ; errno = 0 ; unsigned long ul = strtoul ( value , & end , 10 ) ; if ( errno || end == value || * end != '\\0' || ul > INT_MAX ) error_msg ( ""Errorparsing%ssetting:\'%s\'"" , ""MaxCrashReportsSize"" , value ) ; else g_settings_nMaxCrashReportsSize = ul ; remove_map_string_item ( settings , ""MaxCrashReportsSize"" ) ; } value = get_map_string_item_or_NULL ( settings , ""DumpLocation"" ) ; if ( value ) { g_settings_dump_location = xstrdup ( value ) ; remove_map_string_item ( settings , ""DumpLocation"" ) ; } else g_settings_dump_location = xstrdup ( DEFAULT_DUMP_LOCATION ) ; value = get_map_string_item_or_NULL ( settings , ""DeleteUploaded"" ) ; if ( value ) { g_settings_delete_uploaded = string_to_bool ( value ) ; remove_map_string_item ( settings , ""DeleteUploaded"" ) ; } value = get_map_string_item_or_NULL ( settings , ""AutoreportingEnabled"" ) ; if ( value ) { g_settings_autoreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , ""AutoreportingEnabled"" ) ; } value = get_map_string_item_or_NULL ( settings , ""AutoreportingEvent"" ) ; if ( value ) { g_settings_autoreporting_event = xstrdup ( value ) ; remove_map_string_item ( settings , ""AutoreportingEvent"" ) ; } else g_settings_autoreporting_event = xstrdup ( ""report_uReport"" ) ; value = get_map_string_item_or_NULL ( settings , ""ShortenedReporting"" ) ; if ( value ) { g_settings_shortenedreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , ""ShortenedReporting"" ) ; } else g_settings_shortenedreporting = 0 ;  GHashTableIter iter ;  const char * name ; init_map_string_iter ( & iter , settings ) ; while ( next_map_string_iter ( & iter , & name , & value ) ) { error_msg ( ""Unrecognizedvariable\'%s\'in\'%s\'"" , name , conf_filename ) ; } }"," = 0 ; value = get_map_string_item_or_NULL ( settings , ""PrivateReports"" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , ""PrivateReports"" ) ; }"
367,"CWE-119 void TEMPLATE ( process_block_dec ) ( decoder_info_t * decoder_info , int size , int yposY , int xposY , int sub ) { int width = decoder_info -> width ; int height = decoder_info -> height ; stream_t * stream = decoder_info -> stream ; frame_type_t frame_type = decoder_info -> frame_info . frame_type ; int split_flag = 0 ; if ( yposY >= height || xposY >= width ) return ; int decode_this_size = ( yposY + size <= height ) && ( xposY + size <= width ) ; int decode_rectangular_size = ! decode_this_size && frame_type != I_FRAME ; int bit_start = stream -> bitcnt ; int mode = MODE_SKIP ; block_context_t block_context ; TEMPLATE ( find_block_contexts ) ( yposY , xposY , height , width , size , decoder_info -> deblock_data , & block_context , decoder_info -> use_block_contexts ) ; decoder_info -> block_context = & block_context ; split_flag = decode_super_mode ( decoder_info , size , decode_this_size ) ; mode = decoder_info -> mode ; if ( size == ( 1 << decoder_info -> log2_sb_size ) && ( split_flag || mode != MODE_SKIP ) && decoder_info -> max_delta_qp > 0 ) { int delta_qp = read_delta_qp ( stream ) ; int prev_qp ; if ( yposY == 0 && xposY == 0 ) prev_qp = decoder_info -> frame_info . qp ; else prev_qp = decoder_info -> frame_info . qpb ; decoder_info -> frame_info . qpb = prev_qp + delta_qp ; } decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] += ( stream -> bitcnt - bit_start ) ;  if ( split_flag ) {  int new_size = size / 2 ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 1 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 1 * new_size , sub ) ; } else if ( decode_this_size || decode_rectangular_size ) { decode_block ( decoder_info , size , yposY , xposY , sub ) ; } }", if ( split_flag && size >= MIN_BLOCK_SIZE
368,"CWE-189 Datum path_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; PATH * path ; int isopen ; char * s ; int npts ;  int size ;  int depth = 0 ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalidinputsyntaxfortypepath:\\""%s\\"""" , str ) ) ) ; s = str ; while ( isspace ( ( unsigned char ) * s ) ) s ++ ; if ( ( * s == LDELIM ) && ( strrchr ( s , LDELIM ) == s ) ) { s ++ ; depth ++ ; }  size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;  path = ( PATH * ) palloc ( size ) ; SET_VARSIZE ( path , size ) ; path -> npts = npts ; if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == '\\0' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalidinputsyntaxfortypepath:\\""%s\\"""" , str ) ) ) ; path -> closed = ( ! isopen ) ; path -> dummy = 0 ; PG_RETURN_PATH_P ( path ) ; }"," ; int size ; int base_size  ++ ; } base_size = sizeof ( path ->  p [ 0  0 ] ) * npts ; size = offsetof ( PATH ,  p [ 0  0 ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""toomanypointsrequested"" ) ) )  ; path ="
369,"CWE-254 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) &&  ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error )  { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case QUANT_MATRIX_EXT_ID : impeg2d_dec_quant_matrix_ext ( ps_dec ) ; break ; case COPYRIGHT_EXT_ID : impeg2d_dec_copyright_ext ( ps_dec ) ; break ; case PIC_DISPLAY_EXT_ID : impeg2d_dec_pic_disp_ext ( ps_dec ) ; break ; case CAMERA_PARAM_EXT_ID : impeg2d_dec_cam_param_ext ( ps_dec ) ; break ; case ITU_T_EXT_ID : impeg2d_dec_itu_t_ext ( ps_dec ) ; break ; case PIC_SPATIAL_SCALABLE_EXT_ID : case PIC_TEMPORAL_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABLITY_NOT_SUP ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }", IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
370,"CWE-476 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ;  if ( optstr ) {  jas_eprintf ( ""warning:ignoringBMPdecoderoptions\\n"" ) ; } jas_eprintf ( ""THEBMPFORMATISNOTFULLYSUPPORTED!\\n"" ""THATIS,THEJASPERSOFTWARECANNOTDECODEALLTYPESOFBMPDATA.\\n"" ""IFYOUHAVEANYPROBLEMS,PLEASETRYCONVERTINGYOURIMAGEDATA\\n"" ""TOTHEPNMFORMAT,ANDUSINGTHISFORMATINSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannotgetheader\\n"" ) ;  return 0 ;  } JAS_DBGLOG ( 1 , ( ""BMPheader:magic0x%x;siz%d;res1%d;res2%d;off%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; if ( ! ( info = bmp_getinfo ( in ) ) ) { jas_eprintf ( ""cannotgetinfo\\n"" ) ;  return 0 ;  } JAS_DBGLOG ( 1 ,  ( ""BMPinformation:len%d;width%d;height%d;numplanes%d;""  ""depth%d;enctype%d;siz%d;hres%d;vres%d;numcolors%d;""  ""mincolors%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes ,   info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres ,   info -> numcolors , info -> mincolors ) ) ;  if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:unsupportedBMPencoding\\n"" ) ;  bmp_info_destroy ( info ) ;  return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:possiblybadbitmapoffset?\\n"" ) ;  return 0 ;  } if ( n > 0 ) { jas_eprintf ( ""skippingunknowndatainBMPfile\\n"" ) ; if ( bmp_gobble ( in , n ) ) {  bmp_info_destroy ( info ) ;  return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) {  bmp_info_destroy ( info ) ;  return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) {  bmp_info_destroy ( info ) ;   jas_image_destroy ( image ) ;   return 0 ;  }  bmp_info_destroy ( info ) ;  return image ; }"," long n ; image = 0 ; info = 0 ;  ""cannotgetheader\\n"" ) ; goto error  ; } JAS_DBGLOG  ""cannotgetinfo\\n"" ) ; goto error  ; } JAS_DBGLOG  1 , ( ""BMPinformation:len%ld;width%ld;height%ld;numplanes%d;"" ""depth%d;enctype%ld;siz%ld;hres%ld;vres%ld;numcolors%ld;"" ""mincolors%ld\\n"" , JAS_CAST ( long  , info ->  info -> len ) , JAS_CAST ( long  info -> width ) , JAS_CAST ( long  info -> height ) , JAS_CAST ( long  info -> numplanes ) , JAS_CAST ( long ,  info -> depth  info -> depth ) , JAS_CAST ( long  info -> enctype ) , JAS_CAST ( long  info -> siz ) , JAS_CAST ( long  info -> hres ) , JAS_CAST ( long  info -> vres ) , JAS_CAST ( long ,  info -> numcolors  info -> numcolors ) , JAS_CAST ( long  mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corruptbitstream\\n"" ) ; goto error ; }  if ( !  ""error:unsupportedBMPencoding\\n"" ) ; goto error  ; } if  ""error:possiblybadbitmapoffset?\\n"" ) ; goto error  ; } if  ) ) { goto error  ; } }  ) ) { goto error  ; } if  ) ) { goto error ; }  info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) {  image ) ; }  0 ; }    "
371,"CWE-000 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) {  void * dllhandle ;  if ( useSystemLib ) Com_Printf ( ""Tryingtoload\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading\\""%s\\""failed\\n"" , name ) ; } } return dllhandle ; }"," * dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""RejectingDLLnamed\\""%s\\"""" , name ) ; return NULL ; }"
372,"CWE-264 static ssize_t ucma_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ucma_file * file = filp -> private_data ; struct rdma_ucm_cmd_hdr hdr ;  ssize_t ret ;  if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucma_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; if ( ! ucma_cmd_table [ hdr . cmd ] ) return - ENOSYS ; ret = ucma_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! ret ) ret = len ; return ret ; }", ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
373,"CWE-000 static int asn1_find_indefinite_length ( const unsigned char * data , size_t datalen , size_t * _dp , size_t * _len , const char * * _errmsg ) { unsigned char tag , tmp ; size_t dp = * _dp , len , n ; int indef_level = 1 ; next_tag : if ( unlikely ( datalen - dp < 2 ) ) { if ( datalen == dp ) goto missing_eoc ; goto data_overrun_error ; } tag = data [ dp ++ ] ;  if ( tag == 0 ) {  if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; if ( -- indef_level <= 0 ) { * _len = dp - * _dp ; * _dp = dp ; return 0 ; } goto next_tag ; } if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) { do { if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; tmp = data [ dp ++ ] ; } while ( tmp & 0x80 ) ; } len = data [ dp ++ ] ;  if ( len <= 0x7f ) {  dp += len ; goto next_tag ; } if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ( tag & ASN1_CONS_BIT ) == ASN1_PRIM << 5 ) ) goto indefinite_len_primitive ; indef_level ++ ; goto next_tag ; } n = len - 0x80 ;  if ( unlikely ( n > sizeof ( size_t ) - 1 ) )  goto length_too_long ; if ( unlikely ( n > datalen - dp ) ) goto data_overrun_error ;  for ( len = 0 ; n > 0 ; n -- ) {  len <<= 8 ; len |= data [ dp ++ ] ; }  dp += len ;  goto next_tag ; length_too_long : * _errmsg = ""Unsupportedlength"" ; goto error ; indefinite_len_primitive : * _errmsg = ""Indefinitelenprimitivenotpermitted"" ; goto error ; invalid_eoc : * _errmsg = ""InvalidlengthEOC"" ; goto error ; data_overrun_error : * _errmsg = ""Dataoverrunerror"" ; goto error ; missing_eoc : * _errmsg = ""MissingEOCinindefinitelencons"" ; error : * _dp = dp ; return - 1 ; }", ( tag == ASN1_EOC  ) { if  <= 0x7f ) goto check_length ;  if ( unlikely  > sizeof ( len  ) - 1  goto data_overrun_error ; len = 0 ; for (  ; n >  ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;
374,"CWE-200 static long sg_ioctl ( struct file * filp , unsigned int cmd_in , unsigned long arg ) { void __user * p = ( void __user * ) arg ; int __user * ip = p ; int result , val , read_only ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; unsigned long iflags ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_ioctl:cmd=0x%x\\n"" , ( int ) cmd_in ) ) ; read_only = ( O_RDWR != ( filp -> f_flags & O_ACCMODE ) ) ; switch ( cmd_in ) { case SG_IO : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! scsi_block_when_processing_errors ( sdp -> device ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_IO_HDR ) ) return - EFAULT ; result = sg_new_write ( sfp , filp , p , SZ_SG_IO_HDR , 1 , read_only , 1 , & srp ) ; if ( result < 0 ) return result ; result = wait_event_interruptible ( sfp -> read_wait , ( srp_done ( sfp , srp ) || atomic_read ( & sdp -> detaching ) ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; write_lock_irq ( & sfp -> rq_list_lock ) ; if ( srp -> done ) { srp -> done = 2 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; result = sg_new_read ( sfp , p , SZ_SG_IO_HDR , srp ) ; return ( result < 0 ) ? result : 0 ; } srp -> orphan = 1 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; return result ; case SG_SET_TIMEOUT : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EIO ; if ( val >= mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) ) val = min_t ( s64 , mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) , INT_MAX ) ; sfp -> timeout_user = val ; sfp -> timeout = mult_frac ( val , HZ , USER_HZ ) ; return 0 ; case SG_GET_TIMEOUT : return sfp -> timeout_user ; case SG_SET_FORCE_LOW_DMA : return 0 ; case SG_GET_LOW_DMA : return put_user ( ( int ) sdp -> device -> host -> unchecked_isa_dma , ip ) ; case SG_GET_SCSI_ID : if ( ! access_ok ( VERIFY_WRITE , p , sizeof ( sg_scsi_id_t ) ) ) return - EFAULT ; else { sg_scsi_id_t __user * sg_idp = p ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; __put_user ( ( int ) sdp -> device -> host -> host_no , & sg_idp -> host_no ) ; __put_user ( ( int ) sdp -> device -> channel , & sg_idp -> channel ) ; __put_user ( ( int ) sdp -> device -> id , & sg_idp -> scsi_id ) ; __put_user ( ( int ) sdp -> device -> lun , & sg_idp -> lun ) ; __put_user ( ( int ) sdp -> device -> type , & sg_idp -> scsi_type ) ; __put_user ( ( short ) sdp -> device -> host -> cmd_per_lun , & sg_idp -> h_cmd_per_lun ) ; __put_user ( ( short ) sdp -> device -> queue_depth , & sg_idp -> d_queue_depth ) ; __put_user ( 0 , & sg_idp -> unused [ 0 ] ) ; __put_user ( 0 , & sg_idp -> unused [ 1 ] ) ; return 0 ; } case SG_SET_FORCE_PACK_ID : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> force_packid = val ? 1 : 0 ; return 0 ; case SG_GET_PACK_ID : if ( ! access_ok ( VERIFY_WRITE , ip , sizeof ( int ) ) ) return - EFAULT ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) { read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( srp -> header . pack_id , ip ) ; return 0 ; } } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( - 1 , ip ) ; return 0 ; case SG_GET_NUM_WAITING : read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) ++ val ; } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; return put_user ( val , ip ) ; case SG_GET_SG_TABLESIZE : return put_user ( sdp -> sg_tablesize , ip ) ; case SG_SET_RESERVED_SIZE : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EINVAL ; val = min_t ( int , val , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; mutex_lock ( & sfp -> f_mutex ) ; if ( val != sfp -> reserve . bufflen ) { if ( sfp -> mmap_called || sfp -> res_in_use ) { mutex_unlock ( & sfp -> f_mutex ) ; return - EBUSY ; } sg_remove_scat ( sfp , & sfp -> reserve ) ; sg_build_reserve ( sfp , val ) ; } mutex_unlock ( & sfp -> f_mutex ) ; return 0 ; case SG_GET_RESERVED_SIZE : val = min_t ( int , sfp -> reserve . bufflen , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; return put_user ( val , ip ) ; case SG_SET_COMMAND_Q : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> cmd_q = val ? 1 : 0 ; return 0 ; case SG_GET_COMMAND_Q : return put_user ( ( int ) sfp -> cmd_q , ip ) ; case SG_SET_KEEP_ORPHAN : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> keep_orphan = val ; return 0 ; case SG_GET_KEEP_ORPHAN : return put_user ( ( int ) sfp -> keep_orphan , ip ) ; case SG_NEXT_CMD_LEN : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val > SG_MAX_CDB_SIZE ) return - ENOMEM ; sfp -> next_cmd_len = ( val > 0 ) ? val : 0 ; return 0 ; case SG_GET_VERSION_NUM : return put_user ( sg_version_num , ip ) ; case SG_GET_ACCESS_COUNT : val = ( sdp -> device ? 1 : 0 ) ; return put_user ( val , ip ) ; case SG_GET_REQUEST_TABLE : if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ) return - EFAULT ; else { sg_req_info_t * rinfo ;  rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE ,  GFP_KERNEL ) ; if ( ! rinfo ) return - ENOMEM ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; sg_fill_request_table ( sfp , rinfo ) ; read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; result = __copy_to_user ( p , rinfo , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ; result = result ? - EFAULT : 0 ; kfree ( rinfo ) ; return result ; } case SG_EMULATED_HOST : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; return put_user ( sdp -> device -> host -> hostt -> emulated , ip ) ; case SCSI_IOCTL_SEND_COMMAND : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( read_only ) { unsigned char opcode = WRITE_6 ; Scsi_Ioctl_Command __user * siocp = p ; if ( copy_from_user ( & opcode , siocp -> data , 1 ) ) return - EFAULT ; if ( sg_allow_access ( filp , & opcode ) ) return - EPERM ; } return sg_scsi_ioctl ( sdp -> device -> request_queue , NULL , filp -> f_mode , p ) ; case SG_SET_DEBUG : result = get_user ( val , ip ) ; if ( result ) return result ; sdp -> sgdebug = ( char ) val ; return 0 ; case BLKSECTGET : return put_user ( max_sectors_bytes ( sdp -> device -> request_queue ) , ip ) ; case BLKTRACESETUP : return blk_trace_setup ( sdp -> device -> request_queue , sdp -> disk -> disk_name , MKDEV ( SCSI_GENERIC_MAJOR , sdp -> index ) , NULL , p ) ; case BLKTRACESTART : return blk_trace_startstop ( sdp -> device -> request_queue , 1 ) ; case BLKTRACESTOP : return blk_trace_startstop ( sdp -> device -> request_queue , 0 ) ; case BLKTRACETEARDOWN : return blk_trace_remove ( sdp -> device -> request_queue ) ; case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : case SCSI_IOCTL_PROBE_HOST : case SG_GET_TRANSFORM : case SG_SCSI_RESET : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; break ; default : if ( read_only ) return - EPERM ; break ; } result = scsi_ioctl_block_when_processing_errors ( sdp -> device , cmd_in , filp -> f_flags & O_NDELAY ) ; if ( result ) return result ; return scsi_ioctl ( sdp -> device , cmd_in , p ) ; }", ; rinfo = kzalloc  ( SZ_SG_REQ_INFO *
375,"CWE-20 static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) { GFile * location ; gboolean res ;  if ( ! is_launcher )  { return TRUE ; }  if ( nautilus_file_can_execute ( file ) )  { return TRUE ; } res = FALSE ; if ( nautilus_file_is_local ( file ) ) { location = nautilus_file_get_location ( file ) ; res = nautilus_is_in_system_dir ( location ) ; g_object_unref ( location ) ; } return res ; }"," gboolean res ; g_autofree gchar * trusted = NULL ;  TRUE ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ;  ( file ) && trusted != NULL"
376,"CWE-189 Datum bqarr_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; WORKSTATE state ; int32 i ; QUERYTYPE * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG StringInfoData pbuf ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( ""emptyquery"" ) ) ) ;  commonlen = COMPUTESIZE ( state . num ) ;  query = ( QUERYTYPE * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = state . num - 1 ; i >= 0 ; i -- ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } pos = query -> size - 1 ; findoprnd ( ptr , & pos ) ; # ifdef BS_DEBUG initStringInfo ( & pbuf ) ; for ( i = 0 ; i < query -> size ; i ++ ) { if ( ptr [ i ] . type == OPR ) appendStringInfo ( & pbuf , ""%c(%d)"" , ptr [ i ] . val , ptr [ i ] . left ) ; else appendStringInfo ( & pbuf , ""%d"" , ptr [ i ] . val ) ; } elog ( DEBUG3 , ""POR:%s"" , pbuf . data ) ; pfree ( pbuf . data ) ; # endif PG_RETURN_POINTER ( query ) ; }"," ) ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""numberofqueryitems(%d)exceedsthemaximumallowed(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;"
377,"CWE-264 int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , ""Internalerror:directorycacheinfousedincg_write\\n"" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 )  r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ;  else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ; if ( ! r ) size = - EINVAL ; out : free_key ( k ) ; return size ; }"," -> pid , fc -> uid ,"
378,"CWE-119  void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride ,  int eob ) { if ( eob == 1 )  vp9_idct16x16_1_add ( input , dest , stride ) ;  else if ( eob <= 10 )  vp9_idct16x16_10_add ( input , dest , stride ) ;  else  vp9_idct16x16_256_add ( input , dest , stride ) ;  }"," vp9_idct16x16_add ( const tran_low_t  * input ,  == 1 ) vpx_idct16x16_1_add  ( input ,  <= 10 ) vpx_idct16x16_10_add  ( input ,  ) ; else vpx_idct16x16_256_add  ( input ,"
379,"CWE-125 struct _mdi * _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; uint32_t mus_song_ofs = 0 ; uint32_t mus_song_len = 0 ; uint16_t mus_ch_cnt1 = 0 ; uint16_t mus_ch_cnt2 = 0 ; uint16_t mus_no_instr = 0 ; uint32_t mus_data_ofs = 0 ; uint16_t * mus_mid_instr = NULL ; uint16_t mus_instr_cnt = 0 ; struct _mdi * mus_mdi ; uint32_t mus_divisions = 60 ; float tempo_f = 0.0 ; uint16_t mus_freq = 0 ; float samples_per_tick_f = 0.0 ;  uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ;  uint8_t mus_event_size = 0 ; uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; uint32_t setup_ret = 0 ; uint32_t mus_ticks = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint16_t pitchbend_tmp = 0 ; if ( mus_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""Filetooshort"" , 0 ) ; return NULL ; } if ( memcmp ( mus_data , mus_hdr , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; return NULL ; } mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; mus_song_ofs = ( mus_data [ 7 ] << 8 ) | mus_data [ 6 ] ; mus_ch_cnt1 = ( mus_data [ 9 ] << 8 ) | mus_data [ 8 ] ; mus_ch_cnt2 = ( mus_data [ 11 ] << 8 ) | mus_data [ 10 ] ; UNUSED ( mus_ch_cnt1 ) ; UNUSED ( mus_ch_cnt2 ) ; mus_no_instr = ( mus_data [ 13 ] << 8 ) | mus_data [ 12 ] ; mus_data_ofs = 16 ; if ( mus_size < ( mus_data_ofs + ( mus_no_instr << 1 ) + mus_song_len ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""Filetooshort"" , 0 ) ; return NULL ; } mus_mid_instr = malloc ( mus_no_instr * sizeof ( uint16_t ) ) ; for ( mus_instr_cnt = 0 ; mus_instr_cnt < mus_no_instr ; mus_instr_cnt ++ ) { mus_mid_instr [ mus_instr_cnt ] = ( mus_data [ mus_data_ofs + 1 ] << 8 ) | mus_data [ mus_data_ofs ] ; mus_data_ofs += 2 ; } mus_data_ofs = mus_song_ofs ; mus_freq = _cvt_get_option ( WM_CO_FREQUENCY ) ; if ( mus_freq == 0 ) mus_freq = 140 ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / mus_freq ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / mus_freq ) ; } samples_per_tick_f = _WM_GetSamplesPerTick ( mus_divisions , ( uint32_t ) tempo_f ) ; mus_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mus_mdi , mus_divisions ) ; _WM_midi_setup_tempo ( mus_mdi , ( uint32_t ) tempo_f ) ; do { _mus_build_event : # if 1 MUS_EVENT_DEBUG ( ""Before"" , mus_data [ mus_data_ofs ] , 0 ) ; if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x0f ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x09 ; } else if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x09 ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x0f ; } MUS_EVENT_DEBUG ( ""After"" , mus_data [ mus_data_ofs ] , 0 ) ; # endif switch ( ( mus_data [ mus_data_ofs ] >> 4 ) & 0x07 ) { case 0 : mus_event_size = 2 ; mus_event [ 0 ] = 0x80 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : if ( mus_data [ mus_data_ofs + 1 ] & 0x80 ) { mus_event_size = 3 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] & 0x7f ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] = mus_event [ 2 ] ; } else { mus_event_size = 2 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] ; mus_event [ 3 ] = 0 ; } break ; case 2 : mus_event_size = 2 ; mus_event [ 0 ] = 0xe0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; pitchbend_tmp = mus_data [ mus_data_ofs + 1 ] << 6 ; mus_event [ 1 ] = pitchbend_tmp & 0x7f ; mus_event [ 2 ] = ( pitchbend_tmp >> 7 ) & 0x7f ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event_size = 2 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 10 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 120 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 11 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 123 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 12 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 126 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 13 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 127 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 14 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 121 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 4 : mus_event_size = 3 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 0 : mus_event [ 0 ] = 0xc0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 0 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 2 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 1 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 7 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 4 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 10 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 5 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 11 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 6 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 91 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 7 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 93 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 8 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 64 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 9 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 67 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 5 : mus_event_size = 1 ; goto _mus_next_data ; break ; case 6 : goto _mus_end_of_song ; break ; case 7 : mus_event_size = 1 ; goto _mus_next_data ; break ; }  setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ;  if ( setup_ret == 0 ) { goto _mus_end ; } _mus_next_data : if ( ! ( mus_data [ mus_data_ofs ] & 0x80 ) ) { mus_data_ofs += mus_event_size ; goto _mus_build_event ; } mus_data_ofs += mus_event_size ; mus_ticks = 0 ; do { mus_ticks = ( mus_ticks << 7 ) | ( mus_data [ mus_data_ofs ++ ] & 0x7f ) ; } while ( mus_data [ mus_data_ofs - 1 ] & 0x80 ) ; sample_count_f = ( ( float ) mus_ticks * samples_per_tick_f ) + sample_remainder ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mus_mdi -> events [ mus_mdi -> event_count - 1 ] . samples_to_next = sample_count ; mus_mdi -> extra_info . approx_total_samples += sample_count ; } while ( mus_data_ofs < mus_size ) ; _mus_end_of_song : if ( ( mus_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""toinitreverb"" , 0 ) ; goto _mus_end ; } _WM_midi_setup_endoftrack ( mus_mdi ) ; mus_mdi -> extra_info . current_sample = 0 ; mus_mdi -> current_event = & mus_mdi -> events [ 0 ] ; mus_mdi -> samples_to_mix = 0 ; mus_mdi -> note = NULL ; _WM_ResetToStart ( mus_mdi ) ; _mus_end : free ( mus_mid_instr ) ; if ( mus_mdi -> reverb ) return ( mus_mdi ) ; _WM_freeMDI ( mus_mdi ) ; return NULL ; }"," = 0.0 ; # define MUS_SZ 4  uint8_t mus_event [ MUS_SZ  * ) mus_event , MUS_SZ"
380,"CWE-125 int main ( ) {  gdImagePtr im ;  char * buffer ; size_t size ; size = read_test_file ( & buffer , ""heap_overflow.tga"" ) ; im = gdImageCreateFromTgaPtr ( size , ( void * ) buffer ) ; gdTestAssert ( im == NULL ) ; free ( buffer ) ; return gdNumFailures ( ) ; }"," ( ) { check_file ( ""heap_overflow_1.tga"" ) ; check_file ( ""heap_overflow_2.tga""  ) ; return"
381,"CWE-532 static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , ""sendingSIOPollrequest\\n"" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ;  if ( rc < 0 )   dev_err ( & port -> dev , ""Readinglinestatusfailed(error=%d)\\n"" ,  rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , ""readstatus%x%x\\n"" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }"," if ( rc != KLSI_STATUSBUF_LEN ) {  dev_err ( &  -> dev , ""readinglinestatusfailed:%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; }  else { status"
382,"CWE-125 static int  l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 )   {  if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }"," int l_strnstart ( netdissect_options * ndo ,  l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }"
383,"CWE-415 static bool disconnect_cb ( struct io * io , void * user_data ) { struct bt_att_chan * chan = user_data ; struct bt_att * att = chan -> att ; int err ; socklen_t len ; len = sizeof ( err ) ; if ( getsockopt ( chan -> fd , SOL_SOCKET , SO_ERROR , & err , & len ) < 0 ) { util_debug ( chan -> att -> debug_callback , chan -> att -> debug_data , ""(chan%p)Failedtoobtaindisconnect"" ""error:%s"" , chan , strerror ( errno ) ) ; err = 0 ; } util_debug ( chan -> att -> debug_callback , chan -> att -> debug_data , ""Channel%pdisconnected:%s"" , chan , strerror ( err ) ) ; queue_remove ( att -> chans , chan ) ;  queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ;  queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ; if ( chan -> pending_req ) { disc_att_send_op ( chan -> pending_req ) ; chan -> pending_req = NULL ; } if ( chan -> pending_ind ) { disc_att_send_op ( chan -> pending_ind ) ; chan -> pending_ind = NULL ; } bt_att_chan_free ( chan ) ; if ( ! queue_isempty ( att -> chans ) ) return false ; bt_att_ref ( att ) ;  queue_foreach ( att -> disconn_list , disconn_handler , INT_TO_PTR ( err ) ) ;  bt_att_unregister_all ( att ) ; bt_att_unref ( att ) ; return false ; }"," chan ) ;  if ( chan  att ) ; att -> in_disc = true ; queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ; att -> in_disc = false ;"
384,"CWE-119 static int read_skip ( VP9_COMMON * cm , const MACROBLOCKD * xd ,  int segment_id , vp9_reader * r ) {   if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) {  return 1 ; } else { const int ctx = vp9_get_skip_context ( xd ) ;  const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ;   if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . skip [ ctx ] [ skip ] ; return skip ; } }"," int segment_id , vpx_reader  * r )  { if ( segfeature_active  ( & cm  int skip = vpx_read  ( r ,  cm -> fc ->  skip_probs [ ctx  ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts ->  skip [ ctx"
385,"CWE-399 static int xfrm6_tunnel_rcv ( struct sk_buff * skb ) { struct ipv6hdr * iph = ipv6_hdr ( skb ) ; __be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ;  return xfrm6_rcv_spi ( skb , spi ) ;  }"," , spi ) > 0 ? : 0"
386,"CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ;  OPJ_UNUSED ( p_manager ) ;  if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""NotenoughbytesinoutputbuffertowriteSOTmarker\\n"" ) ; return OPJ_FALSE ; } opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && ""TODO"" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }", p_stream ) ;  if ( p_total_data_size
387,"CWE-190 static PyMemoEntry * _PyMemoTable_Lookup ( PyMemoTable * self , PyObject * key ) { size_t i ; size_t perturb ;  size_t mask = ( size_t ) self -> mt_mask ;  PyMemoEntry * table = self -> mt_table ; PyMemoEntry * entry ; Py_hash_t hash = ( Py_hash_t ) key >> 3 ; i = hash & mask ; entry = & table [ i ] ; if ( entry -> me_key == NULL || entry -> me_key == key ) return entry ; for ( perturb = hash ; ; perturb >>= PERTURB_SHIFT ) { i = ( i << 2 ) + i + perturb + 1 ; entry = & table [ i & mask ] ; if ( entry -> me_key == NULL || entry -> me_key == key ) return entry ; } Py_UNREACHABLE ( ) ; }", size_t mask =  self -> mt_mask
388,"CWE-125 static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) { char ident_buffer [ 20 ] ; uint8_t prefix [ sizeof ( struct in6_addr ) ] ; u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ; if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ; metric = EXTRACT_32BITS ( tptr ) ; processed = 4 ; tptr += 4 ; if ( afi == AF_INET ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = status_byte & 0x3f ; if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""%sIPv4prefix:badbitlength%u"" , ident , bit_length ) ) ; return ( 0 ) ; } processed ++ ; } else if ( afi == AF_INET6 ) {  if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = * ( tptr ++ ) ; if ( bit_length > 128 ) { ND_PRINT ( ( ndo , ""%sIPv6prefix:badbitlength%u"" , ident , bit_length ) ) ; return ( 0 ) ; } processed += 2 ; } else return ( 0 ) ; byte_length = ( bit_length + 7 ) / 8 ; if ( ! ND_TTEST2 ( * tptr , byte_length ) ) return ( 0 ) ; memset ( prefix , 0 , sizeof prefix ) ; memcpy ( prefix , tptr , byte_length ) ; tptr += byte_length ; processed += byte_length ; if ( afi == AF_INET ) ND_PRINT ( ( ndo , ""%sIPv4prefix:%15s/%u"" , ident , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , ""%sIPv6prefix:%s/%u"" , ident , ip6addr_string ( ndo , prefix ) , bit_length ) ) ; ND_PRINT ( ( ndo , "",Distribution:%s,Metric:%u"" , ISIS_MASK_TLV_EXTD_IP_UPDOWN ( status_byte ) ? ""down"" : ""up"" , metric ) ) ; if ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) ND_PRINT ( ( ndo , "",sub-TLVspresent"" ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , "",%s%s"" , ISIS_MASK_TLV_EXTD_IP6_IE ( status_byte ) ? ""External"" : ""Internal"" , ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ? "",sub-TLVspresent"" : """" ) ) ; if ( ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) || ( afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ) ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; sublen = * ( tptr ++ ) ; processed += sublen + 1 ; ND_PRINT ( ( ndo , ""(%u)"" , sublen ) ) ; while ( sublen > 0 ) { if ( ! ND_TTEST2 ( * tptr , 2 ) ) return ( 0 ) ; subtlvtype = * ( tptr ++ ) ; subtlvlen = * ( tptr ++ ) ; snprintf ( ident_buffer , sizeof ( ident_buffer ) , ""%s"" , ident ) ; if ( ! isis_print_ip_reach_subtlv ( ndo , tptr , subtlvtype , subtlvlen , ident_buffer ) ) return ( 0 ) ; tptr += subtlvlen ; sublen -= ( subtlvlen + 2 ) ; } } return ( processed ) ; }"," * tptr , 2  ) ) return"
389,"CWE-416 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) {  ops -> destroy ( dev ) ;  mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; return ret ; } kvm_get_kvm ( kvm ) ; cd -> fd = ret ; return 0 ; }", 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ;  destroy ( dev  ) ; return
390,"CWE-787 void rdp_in_unistr ( STREAM s , int in_len , char * * string , uint32 * str_size ) { static iconv_t icv_utf16_to_local ; size_t ibl , obl ;  char * pin , * pout ;  if ( ! icv_utf16_to_local ) { icv_utf16_to_local = iconv_open ( g_codepage , WINDOWS_CODEPAGE ) ; if ( icv_utf16_to_local == ( iconv_t ) - 1 ) { logger ( Protocol , Error , ""rdp_in_unistr(),iconv_open[%s->%s]fail%p"" , WINDOWS_CODEPAGE , g_codepage , icv_utf16_to_local ) ; abort ( ) ; } } if ( * string == NULL ) { * string = xmalloc ( in_len * 2 ) ; * str_size = in_len * 2 ; } ibl = in_len ; obl = * str_size - 1 ; pin = ( char * ) s -> p ; pout = * string ; if ( iconv ( icv_utf16_to_local , ( char * * ) & pin , & ibl , & pout , & obl ) == ( size_t ) - 1 ) { if ( errno == E2BIG ) { logger ( Protocol , Warning , ""rdp_in_unistr(),serversentanunexpectedlylongstring,truncating"" ) ; } else { logger ( Protocol , Warning , ""rdp_in_unistr(),iconvfail,errno%d"" , errno ) ; free ( * string ) ; * string = NULL ; * str_size = 0 ; } abort ( ) ; } s -> p += in_len ; * pout = 0 ; if ( * string ) * str_size = pout - * string ; }"," * pout ; struct stream packet = * s ; if ( ( in_len < 0 ) || ( ( uint32 ) in_len >= ( RD_UINT32_MAX / 2 ) ) ) { logger ( Protocol , Error , ""rdp_in_unistr(),lengthofunicodedataisoutofbounds."" ) ; abort ( ) ; } if ( ! s_check_rem ( s , in_len ) ) { rdp_protocol_error ( ""rdp_in_unistr(),consumeofunicodedatafromstreamwouldoverrun"" , & packet ) ; }"
391,"CWE-119 static int aiff_read_chanmap ( SF_PRIVATE * psf , unsigned dword ) { const AIFF_CAF_CHANNEL_MAP * map_info ; unsigned channel_bitmap , channel_decriptions , bytesread ; int layout_tag ; bytesread = psf_binheader_readf ( psf , ""444"" , & layout_tag , & channel_bitmap , & channel_decriptions ) ; if ( ( map_info = aiff_caf_of_channel_layout_tag ( layout_tag ) ) == NULL ) return 0 ; psf_log_printf ( psf , ""Tag:%x\\n"" , layout_tag ) ; if ( map_info ) psf_log_printf ( psf , ""Layout:%s\\n"" , map_info -> name ) ; if ( bytesread < dword ) psf_binheader_readf ( psf , ""j"" , dword - bytesread ) ; if ( map_info -> channel_map != NULL )  { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ;  free ( psf -> channel_map ) ; if ( ( psf -> channel_map = malloc ( chanmap_size ) ) == NULL ) return SFE_MALLOC_FAILED ; memcpy ( psf -> channel_map , map_info -> channel_map , chanmap_size ) ; } ; return 0 ; }"," size_t chanmap_size = SF_MIN (  sf . channels , layout_tag & 0xffff )"
392,"CWE-200 int data_on_connection ( int fd , callback_remove_handler remove ) { int nread ; char * network_packet ; char network_line [ 8192 ] ; char * p ; unsigned long id ; char string [ 1024 ] ; unsigned long msg_id = UINT32_MAX ; enum network_protocol version = network_client_get_version ( fd ) ; ioctl ( fd , FIONREAD , & nread ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""newconnectiondata=%d\\n"" , nread ) ; if ( nread == 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , ""%dfailed,got0closeconnectiontolistener"" , fd ) ; close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; network_client_dump ( ) ; return 0 ; } if ( nread >= 8192 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ERROR , ""%dfailed,morethan8192closeconnectiontolistener"" , fd ) ; close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; return 0 ; } network_packet = malloc ( ( nread + 1 ) * sizeof ( char ) ) ; read ( fd , network_packet , nread ) ; network_packet [ nread ] = '\\0' ; memset ( network_line , 0 , 8192 ) ; p = network_packet ; p_sem ( sem_id ) ; while ( get_network_line ( p , network_line ) ) { if ( strlen ( network_line ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""line=[%s]"" , network_line ) ; } if ( ! strncmp ( network_line , ""MSGID:"" , strlen ( ""MSGID:"" ) ) ) { msg_id = strtoul ( & ( network_line [ strlen ( ""MSGID:"" ) ] ) , NULL , 10 ) ; p += strlen ( network_line ) ; } else if ( ! strncmp ( network_line , ""Version:"" , strlen ( ""Version:"" ) ) ) { char * head = network_line , * end ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:VERSION"" ) ; version = strtoul ( head + 9 , & end , 10 ) ; if ( ! head [ 9 ] || * end ) goto failed ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""VERSION=%d"" , version ) ; if ( version < network_procotol_version ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , ""ForbiddenVERSION=%d<%d,closeconnectiontolistener"" , version , network_procotol_version ) ; goto close ; } else if ( version >= PROTOCOL_LAST ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , ""FutureVERSION=%d"" , version ) ; version = PROTOCOL_LAST - 1 ; } network_client_set_version ( fd , version ) ; msg_id = UINT32_MAX ; p += strlen ( network_line ) ; } else if ( ! strncmp ( network_line , ""Capabilities:"" , strlen ( ""Capabilities:"" ) ) ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:Capabilities"" ) ; if ( version > PROTOCOL_UNKNOWN ) { memset ( string , 0 , sizeof ( string ) ) ; snprintf ( string , sizeof ( string ) , ""Version:%d\\nCapabilities:\\n\\n"" , version ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""SEND:%s"" , string ) ; write ( fd , string , strlen ( string ) ) ; } else { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""Capabilitiesrecv,butnoversionline"" ) ; } p += strlen ( network_line ) ;  } else if ( ! strncmp ( network_line , ""GET_DN"" , strlen ( ""GET_DN"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) {  univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:GET_DN"" ) ; id = strtoul ( & ( network_line [ strlen ( ""GET_DN"" ) ] ) , NULL , 10 ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""id:%ld"" , id ) ; if ( id <= notify_last_id . id ) { char * dn_string = NULL ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""trytoread%ldfromcache"" , id ) ; if ( ( dn_string = notifier_cache_get ( id ) ) == NULL ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""%ldnotfoundincache"" , id ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""%ldgetonedn"" , id ) ; if ( ( dn_string = notify_transcation_get_one_dn ( id ) ) == NULL ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""%ldfailed"" , id ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ERROR , ""%dfailed,closeconnectiontolistener"" , fd ) ; close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; return 0 ; } } if ( dn_string != NULL ) { snprintf ( string , sizeof ( string ) , ""MSGID:%ld\\n%s\\n\\n"" , msg_id , dn_string ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""-->%d:[%s]"" , fd , string ) ; write ( fd , string , strlen ( string ) ) ; free ( dn_string ) ; } } else { network_client_set_next_id ( fd , id ) ; network_client_set_msg_id ( fd , msg_id ) ; } p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( p , ""WAIT_ID"" , 8 ) && msg_id != UINT32_MAX && version >= PROTOCOL_3 ) { char * head = network_line , * end ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:WAIT_ID"" ) ; id = strtoul ( head + 8 , & end , 10 ) ; if ( ! head [ 8 ] || * end ) goto failed ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""id:%ld"" , id ) ; if ( id <= notify_last_id . id ) { snprintf ( string , sizeof ( string ) , ""MSGID:%ld\\n%ld\\n\\n"" , msg_id , notify_last_id . id ) ; write ( fd , string , strlen ( string ) ) ; } else { network_client_set_next_id ( fd , id ) ; network_client_set_msg_id ( fd , msg_id ) ; } p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( network_line , ""GET_ID"" , strlen ( ""GET_ID"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:GET_ID"" ) ; memset ( string , 0 , sizeof ( string ) ) ; snprintf ( string , sizeof ( string ) , ""MSGID:%ld\\n%ld\\n\\n"" , msg_id , notify_last_id . id ) ; write ( fd , string , strlen ( string ) ) ; p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( network_line , ""GET_SCHEMA_ID"" , strlen ( ""GET_SCHEMA_ID"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:GET_SCHEMA_ID"" ) ; memset ( string , 0 , sizeof ( string ) ) ; snprintf ( string , sizeof ( string ) , ""MSGID:%ld\\n%ld\\n\\n"" , msg_id , SCHEMA_ID ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""-->%d:[%s]"" , fd , string ) ; write ( fd , string , strlen ( string ) ) ; p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else if ( ! strncmp ( network_line , ""ALIVE"" , strlen ( ""ALIVE"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:ALIVE"" ) ; snprintf ( string , sizeof ( string ) , ""MSGID:%ld\\nOKAY\\n\\n"" , msg_id ) ; write ( fd , string , strlen ( string ) ) ; p += strlen ( network_line ) + 1 ; msg_id = UINT32_MAX ; } else { p += strlen ( network_line ) ; if ( strlen ( network_line ) == 0 ) { p += 1 ; } else { univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ERROR , ""Droppackage[%s]"" , network_line ) ; } } } v_sem ( sem_id ) ; univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""ENDPackage"" ) ; network_client_dump ( ) ; return 0 ; failed : univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_PROCESS , ""Failedparsing[%s]"" , p ) ; close : close ( fd ) ; FD_CLR ( fd , & readfds ) ; remove ( fd ) ; return 0 ; }", != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3  ) { univention_debug
393,"CWE-119 static vpx_image_t * encoder_get_preview ( vpx_codec_alg_priv_t * ctx ) { YV12_BUFFER_CONFIG sd ;  vp9_ppflags_t flags = { 0 } ;  if ( ctx -> preview_ppcfg . post_proc_flag ) { flags . post_proc_flag = ctx -> preview_ppcfg . post_proc_flag ; flags . deblocking_level = ctx -> preview_ppcfg . deblocking_level ; flags . noise_level = ctx -> preview_ppcfg . noise_level ; } if ( vp9_get_preview_raw_frame ( ctx -> cpi , & sd , & flags ) == 0 ) { yuvconfig2image ( & ctx -> preview_img , & sd , NULL ) ; return & ctx -> preview_img ; } else { return NULL ; } }", ; vp9_ppflags_t flags ; vp9_zero ( flags )  ; if (
394,"CWE-200 static int sco_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) { struct sockaddr_sco * sa = ( struct sockaddr_sco * ) addr ; struct sock * sk = sock -> sk ; int err = 0 ; BT_DBG ( ""sk%p%pMR"" , sk , & sa -> sco_bdaddr ) ;  if ( ! addr || addr -> sa_family != AF_BLUETOOTH )  return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_SEQPACKET ) { err = - EINVAL ; goto done ; } bacpy ( & sco_pi ( sk ) -> src , & sa -> sco_bdaddr ) ; sk -> sk_state = BT_BOUND ; done : release_sock ( sk ) ; return err ; }", sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
395,"CWE-264 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,killinginterrupthandler!"" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attemptedtokilltheidletask!"" ) ; tracehook_report_exit ( & code ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT ""Fixingrecursivefaultbutrebootisneeded!\\n"" ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) exit_io_context ( ) ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:%s[%d]exitedwithpreempt_count%d\\n"" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; if ( tsk -> mm ) { update_hiwater_rss ( tsk -> mm ) ; update_hiwater_vm ( tsk -> mm ) ; } group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; } acct_collect ( code , group_dead ) ;  # ifdef CONFIG_FUTEX   if ( unlikely ( tsk -> robust_list ) )  exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( ! list_empty ( & tsk -> pi_state_list ) ) ) exit_pi_state_list ( tsk ) ; if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) exit_io_context ( ) ; if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; preempt_disable ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }"," group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif  ( unlikely (  ! list_empty ("
396,"CWE-787 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ;  in_uint16_le ( s , type ) ;  in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , ""cliprdr_process(),type=%d,status=%d,length=%d"" , type , status , length ) ;  if ( status == CLIPRDR_ERROR )  { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),unhandlederror(type=%d)"" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),unhandledpackettype%d"" , type ) ; } }"," * data ; struct stream packet = * s ;  ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),consumeofpacketfromstreamwouldoverrun"" , & packet ) ; } if ("
397,"CWE-20 static void br_multicast_del_pg ( struct net_bridge * br , struct net_bridge_port_group * pg ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & pg -> addr ) ; if ( WARN_ON ( ! mp ) ) return ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p != pg ) continue ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ;  if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; return ; } WARN_ON ( 1 ) ; }", -> mglist && mp -> timer_armed &&
398,"CWE-617 krb5_error_code process_tgs_req ( struct server_handle * handle , krb5_data * pkt , const krb5_fulladdr * from , krb5_data * * response ) { krb5_keyblock * subkey = 0 ; krb5_keyblock * header_key = NULL ; krb5_kdc_req * request = 0 ; krb5_db_entry * server = NULL ; krb5_db_entry * stkt_server = NULL ; krb5_kdc_rep reply ; krb5_enc_kdc_rep_part reply_encpart ; krb5_ticket ticket_reply , * header_ticket = 0 ; int st_idx = 0 ; krb5_enc_tkt_part enc_tkt_reply ; int newtransited = 0 ; krb5_error_code retval = 0 ; krb5_keyblock encrypting_key ; krb5_timestamp kdc_time , authtime = 0 ; krb5_keyblock session_key ; krb5_keyblock * reply_key = NULL ; krb5_key_data * server_key ; krb5_principal cprinc = NULL , sprinc = NULL , altcprinc = NULL ; krb5_last_req_entry * nolrarray [ 2 ] , nolrentry ; int errcode ; const char * status = 0 ; krb5_enc_tkt_part * header_enc_tkt = NULL ; krb5_enc_tkt_part * subject_tkt = NULL ; krb5_db_entry * client = NULL , * header_server = NULL ; krb5_db_entry * local_tgt , * local_tgt_storage = NULL ; krb5_pa_s4u_x509_user * s4u_x509_user = NULL ; krb5_authdata * * kdc_issued_auth_data = NULL ; unsigned int c_flags = 0 , s_flags = 0 ; krb5_boolean is_referral ; const char * emsg = NULL ; krb5_kvno ticket_kvno = 0 ; struct kdc_request_state * state = NULL ; krb5_pa_data * pa_tgs_req ; krb5_data scratch ; krb5_pa_data * * e_data = NULL ; kdc_realm_t * kdc_active_realm = NULL ; krb5_audit_state * au_state = NULL ; krb5_data * * auth_indicators = NULL ; memset ( & reply , 0 , sizeof ( reply ) ) ; memset ( & reply_encpart , 0 , sizeof ( reply_encpart ) ) ; memset ( & ticket_reply , 0 , sizeof ( ticket_reply ) ) ; memset ( & enc_tkt_reply , 0 , sizeof ( enc_tkt_reply ) ) ; session_key . contents = NULL ; retval = decode_krb5_tgs_req ( pkt , & request ) ; if ( retval ) return retval ; sprinc = request -> server ; if ( request -> msg_type != KRB5_TGS_REQ ) { krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; return KRB5_BADMSGTYPE ; } kdc_active_realm = setup_server_realm ( handle , request -> server ) ; if ( kdc_active_realm == NULL ) { krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; return KRB5KDC_ERR_WRONG_REALM ; } errcode = kdc_make_rstate ( kdc_active_realm , & state ) ; if ( errcode != 0 ) { krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; return errcode ; } errcode = kau_init_kdc_req ( kdc_context , request , from , & au_state ) ; if ( errcode ) { krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; return errcode ; } kau_tgs_req ( kdc_context , TRUE , au_state ) ; errcode = kdc_process_tgs_req ( kdc_active_realm , request , from , pkt , & header_ticket , & header_server , & header_key , & subkey , & pa_tgs_req ) ; if ( header_ticket && header_ticket -> enc_part2 ) cprinc = header_ticket -> enc_part2 -> client ; if ( errcode ) { status = ""PROCESS_TGS"" ; goto cleanup ; } if ( ! header_ticket ) { errcode = KRB5_NO_TKT_SUPPLIED ; status = ""UNEXPECTEDNULLinheader_ticket"" ; goto cleanup ; } errcode = kau_make_tkt_id ( kdc_context , header_ticket , & au_state -> tkt_in_id ) ; if ( errcode ) { status = ""GENERATE_TICKET_ID"" ; goto cleanup ; } scratch . length = pa_tgs_req -> length ; scratch . data = ( char * ) pa_tgs_req -> contents ; errcode = kdc_find_fast ( & request , & scratch , subkey , header_ticket -> enc_part2 -> session , state , NULL ) ; sprinc = request -> server ; if ( errcode != 0 ) { status = ""FIND_FAST"" ; goto cleanup ; } errcode = get_local_tgt ( kdc_context , & sprinc -> realm , header_server , & local_tgt , & local_tgt_storage ) ; if ( errcode ) { status = ""GET_LOCAL_TGT"" ; goto cleanup ; } au_state -> request = request ; header_enc_tkt = header_ticket -> enc_part2 ; au_state -> stage = SRVC_PRINC ; setflag ( s_flags , KRB5_KDB_FLAG_ALIAS_OK ) ; if ( isflagset ( request -> kdc_options , KDC_OPT_CANONICALIZE ) ) { setflag ( c_flags , KRB5_KDB_FLAG_CANONICALIZE ) ; setflag ( s_flags , KRB5_KDB_FLAG_CANONICALIZE ) ; } errcode = search_sprinc ( kdc_active_realm , request , s_flags , & server , & status ) ; if ( errcode != 0 ) goto cleanup ; sprinc = server -> princ ; is_referral = is_cross_tgs_principal ( server -> princ ) && ! krb5_principal_compare ( kdc_context , request -> server , server -> princ ) ; au_state -> stage = VALIDATE_POL ; if ( ( errcode = krb5_timeofday ( kdc_context , & kdc_time ) ) ) { status = ""TIME_OF_DAY"" ; goto cleanup ; } if ( ( retval = validate_tgs_request ( kdc_active_realm , request , * server , header_ticket , kdc_time , & status , & e_data ) ) ) { if ( ! status ) status = ""UNKNOWN_REASON"" ; if ( retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION ) au_state -> violation = PROT_CONSTRAINT ; errcode = retval + ERROR_TABLE_BASE_krb5 ; goto cleanup ; } if ( ! is_local_principal ( kdc_active_realm , header_enc_tkt -> client ) ) setflag ( c_flags , KRB5_KDB_FLAG_CROSS_REALM ) ; errcode = kdc_process_s4u2self_req ( kdc_active_realm , request , header_enc_tkt -> client , server , subkey , header_enc_tkt -> session , kdc_time , & s4u_x509_user , & client , & status ) ; if ( s4u_x509_user != NULL || errcode != 0 ) { if ( s4u_x509_user != NULL ) au_state -> s4u2self_user = s4u_x509_user -> user_id . user ; if ( errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION ) au_state -> violation = PROT_CONSTRAINT ; au_state -> status = status ; kau_s4u2self ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; au_state -> s4u2self_user = NULL ; } if ( errcode ) goto cleanup ; if ( s4u_x509_user != NULL ) { setflag ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) ; if ( is_referral ) { errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; status = ""LOOKING_UP_SERVER"" ; goto cleanup ; } } errcode = decrypt_2ndtkt ( kdc_active_realm , request , c_flags , & stkt_server , & status ) ; if ( errcode ) goto cleanup ; if ( isflagset ( request -> kdc_options , KDC_OPT_CNAME_IN_ADDL_TKT ) ) { errcode = kdc_process_s4u2proxy_req ( kdc_active_realm , request , request -> second_ticket [ st_idx ] -> enc_part2 , stkt_server , header_ticket -> enc_part2 -> client , request -> server , & status ) ; if ( errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION ) au_state -> violation = PROT_CONSTRAINT ; else if ( errcode ) au_state -> violation = LOCAL_POLICY ; au_state -> status = status ; retval = kau_make_tkt_id ( kdc_context , request -> second_ticket [ st_idx ] , & au_state -> evid_tkt_id ) ; if ( retval ) { status = ""GENERATE_TICKET_ID"" ; errcode = retval ; goto cleanup ; } kau_s4u2proxy ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; if ( errcode ) goto cleanup ; setflag ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ; assert ( krb5_is_tgs_principal ( header_ticket -> server ) ) ; assert ( client == NULL ) ; client = stkt_server ; stkt_server = NULL ; } else if ( request -> kdc_options & KDC_OPT_ENC_TKT_IN_SKEY ) { krb5_db_free_principal ( kdc_context , stkt_server ) ; stkt_server = NULL ; } else assert ( stkt_server == NULL ) ; au_state -> stage = ISSUE_TKT ; errcode = gen_session_key ( kdc_active_realm , request , server , & session_key , & status ) ; if ( errcode ) goto cleanup ; if ( isflagset ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ) subject_tkt = request -> second_ticket [ st_idx ] -> enc_part2 ; else subject_tkt = header_enc_tkt ; authtime = subject_tkt -> times . authtime ; if ( s4u_x509_user == NULL ) { errcode = get_auth_indicators ( kdc_context , subject_tkt , local_tgt , & auth_indicators ) ; if ( errcode ) { status = ""GET_AUTH_INDICATORS"" ; goto cleanup ; } } errcode = check_indicators ( kdc_context , server , auth_indicators ) ; if ( errcode ) { status = ""HIGHER_AUTHENTICATION_REQUIRED"" ; goto cleanup ; } if ( is_referral ) ticket_reply . server = server -> princ ; else ticket_reply . server = request -> server ; enc_tkt_reply . flags = OPTS2FLAGS ( request -> kdc_options ) ; enc_tkt_reply . flags |= COPY_TKT_FLAGS ( header_enc_tkt -> flags ) ; enc_tkt_reply . times . starttime = 0 ; if ( isflagset ( server -> attributes , KRB5_KDB_OK_AS_DELEGATE ) ) setflag ( enc_tkt_reply . flags , TKT_FLG_OK_AS_DELEGATE ) ; setflag ( enc_tkt_reply . flags , TKT_FLG_ENC_PA_REP ) ; enc_tkt_reply . caddrs = header_enc_tkt -> caddrs ; reply_encpart . caddrs = 0 ; reply_encpart . enc_padata = NULL ; if ( isflagset ( request -> kdc_options , KDC_OPT_FORWARDABLE ) ) { if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) ) { if ( client != NULL && isflagset ( client -> attributes , KRB5_KDB_DISALLOW_FORWARDABLE ) ) clear ( enc_tkt_reply . flags , TKT_FLG_FORWARDABLE ) ; else if ( ! isflagset ( header_enc_tkt -> flags , TKT_FLG_FORWARDABLE ) ) clear ( enc_tkt_reply . flags , TKT_FLG_FORWARDABLE ) ; else if ( ! is_referral && ! isflagset ( server -> attributes , KRB5_KDB_OK_TO_AUTH_AS_DELEGATE ) ) clear ( enc_tkt_reply . flags , TKT_FLG_FORWARDABLE ) ; } } if ( isflagset ( request -> kdc_options , KDC_OPT_FORWARDED ) || isflagset ( request -> kdc_options , KDC_OPT_PROXY ) ) { enc_tkt_reply . caddrs = request -> addresses ; reply_encpart . caddrs = request -> addresses ; } if ( isflagset ( request -> kdc_options , KDC_OPT_REQUEST_ANONYMOUS ) && ! isflagset ( header_enc_tkt -> flags , TKT_FLG_ANONYMOUS ) ) clear ( enc_tkt_reply . flags , TKT_FLG_ANONYMOUS ) ; if ( isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) { setflag ( enc_tkt_reply . flags , TKT_FLG_INVALID ) ; enc_tkt_reply . times . starttime = request -> from ; } else enc_tkt_reply . times . starttime = kdc_time ; if ( isflagset ( request -> kdc_options , KDC_OPT_VALIDATE ) ) { assert ( isflagset ( c_flags , KRB5_KDB_FLAGS_S4U ) == 0 ) ; ticket_reply = * ( header_ticket ) ; enc_tkt_reply = * ( header_ticket -> enc_part2 ) ; enc_tkt_reply . authorization_data = NULL ; clear ( enc_tkt_reply . flags , TKT_FLG_INVALID ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_RENEW ) ) { krb5_timestamp old_starttime ; krb5_deltat old_life ; assert ( isflagset ( c_flags , KRB5_KDB_FLAGS_S4U ) == 0 ) ; ticket_reply = * ( header_ticket ) ; enc_tkt_reply = * ( header_ticket -> enc_part2 ) ; enc_tkt_reply . authorization_data = NULL ; old_starttime = enc_tkt_reply . times . starttime ? enc_tkt_reply . times . starttime : enc_tkt_reply . times . authtime ; old_life = ts_delta ( enc_tkt_reply . times . endtime , old_starttime ) ; enc_tkt_reply . times . starttime = kdc_time ; enc_tkt_reply . times . endtime = ts_min ( header_ticket -> enc_part2 -> times . renew_till , ts_incr ( kdc_time , old_life ) ) ; } else { enc_tkt_reply . times . starttime = kdc_time ; kdc_get_ticket_endtime ( kdc_active_realm , enc_tkt_reply . times . starttime , header_enc_tkt -> times . endtime , request -> till , client , server , & enc_tkt_reply . times . endtime ) ; } kdc_get_ticket_renewtime ( kdc_active_realm , request , header_enc_tkt , client , server , & enc_tkt_reply ) ; enc_tkt_reply . times . authtime = authtime ; if ( enc_tkt_reply . times . starttime == enc_tkt_reply . times . authtime ) enc_tkt_reply . times . starttime = 0 ; if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) ) { altcprinc = s4u_x509_user -> user_id . user ; } else if ( isflagset ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ) { altcprinc = subject_tkt -> client ; } else { altcprinc = NULL ; } if ( isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) ) { krb5_enc_tkt_part * t2enc = request -> second_ticket [ st_idx ] -> enc_part2 ; encrypting_key = * ( t2enc -> session ) ; } else { if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , server , - 1 , - 1 , 0 , & server_key ) ) ) { status = ""FINDING_SERVER_KEY"" ; goto cleanup ; } if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , server_key , & encrypting_key , NULL ) ) ) { status = ""DECRYPT_SERVER_KEY"" ; goto cleanup ; } } if ( isflagset ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ) { clear ( server -> attributes , KRB5_KDB_NO_AUTH_DATA_REQUIRED ) ; } if ( isflagset ( server -> attributes , KRB5_KDB_NO_AUTH_DATA_REQUIRED ) == 0 ) { if ( ! isflagset ( c_flags , KRB5_KDB_FLAGS_S4U ) ) { setflag ( c_flags , KRB5_KDB_FLAG_INCLUDE_PAC ) ; setflag ( c_flags , KRB5_KDB_FLAG_MAP_PRINCIPALS ) ; assert ( client == NULL ) ; errcode = krb5_db_get_principal ( kdc_context , subject_tkt -> client , c_flags , & client ) ; } } if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) && ! isflagset ( c_flags , KRB5_KDB_FLAG_CROSS_REALM ) ) enc_tkt_reply . client = s4u_x509_user -> user_id . user ; else enc_tkt_reply . client = subject_tkt -> client ; enc_tkt_reply . session = & session_key ; enc_tkt_reply . transited . tr_type = KRB5_DOMAIN_X500_COMPRESS ; enc_tkt_reply . transited . tr_contents = empty_string ; if ( krb5_realm_compare ( kdc_context , header_ticket -> server , tgs_server ) || krb5_realm_compare ( kdc_context , header_ticket -> server , enc_tkt_reply . client ) ) { enc_tkt_reply . transited = header_enc_tkt -> transited ; } else { if ( header_enc_tkt -> transited . tr_type != KRB5_DOMAIN_X500_COMPRESS ) { status = ""VALIDATE_TRANSIT_TYPE"" ; errcode = KRB5KDC_ERR_TRTYPE_NOSUPP ; goto cleanup ; } memset ( & enc_tkt_reply . transited , 0 , sizeof ( enc_tkt_reply . transited ) ) ; enc_tkt_reply . transited . tr_type = KRB5_DOMAIN_X500_COMPRESS ; if ( ( errcode = add_to_transited ( & header_enc_tkt -> transited . tr_contents , & enc_tkt_reply . transited . tr_contents , header_ticket -> server , enc_tkt_reply . client , request -> server ) ) ) { status = ""ADD_TO_TRANSITED_LIST"" ; goto cleanup ; } newtransited = 1 ; } if ( isflagset ( c_flags , KRB5_KDB_FLAG_CROSS_REALM ) ) { errcode = validate_transit_path ( kdc_context , header_enc_tkt -> client , server , header_server ) ; if ( errcode ) { status = ""NON_TRANSITIVE"" ; goto cleanup ; } } if ( ! isflagset ( request -> kdc_options , KDC_OPT_DISABLE_TRANSITED_CHECK ) ) { errcode = kdc_check_transited_list ( kdc_active_realm , & enc_tkt_reply . transited . tr_contents , krb5_princ_realm ( kdc_context , header_enc_tkt -> client ) , krb5_princ_realm ( kdc_context , request -> server ) ) ; if ( errcode == 0 ) { setflag ( enc_tkt_reply . flags , TKT_FLG_TRANSIT_POLICY_CHECKED ) ; } else { log_tgs_badtrans ( kdc_context , cprinc , sprinc , & enc_tkt_reply . transited . tr_contents , errcode ) ; } } else krb5_klog_syslog ( LOG_INFO , _ ( ""notcheckingtransitpath"" ) ) ; if ( kdc_active_realm -> realm_reject_bad_transit && ! isflagset ( enc_tkt_reply . flags , TKT_FLG_TRANSIT_POLICY_CHECKED ) ) { errcode = KRB5KDC_ERR_POLICY ; status = ""BAD_TRANSIT"" ; au_state -> violation = LOCAL_POLICY ; goto cleanup ; } errcode = handle_authdata ( kdc_context , c_flags , client , server , header_server , local_tgt , subkey != NULL ? subkey : header_ticket -> enc_part2 -> session , & encrypting_key , header_key , pkt , request , s4u_x509_user ? s4u_x509_user -> user_id . user : NULL , subject_tkt , auth_indicators , & enc_tkt_reply ) ; if ( errcode ) { krb5_klog_syslog ( LOG_INFO , _ ( ""TGS_REQ:handle_authdata(%d)"" ) , errcode ) ; status = ""HANDLE_AUTHDATA"" ; goto cleanup ; } ticket_reply . enc_part2 = & enc_tkt_reply ; if ( isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) ) { krb5_enc_tkt_part * t2enc = request -> second_ticket [ st_idx ] -> enc_part2 ; krb5_principal client2 = t2enc -> client ; if ( ! krb5_principal_compare ( kdc_context , request -> server , client2 ) ) { altcprinc = client2 ; errcode = KRB5KDC_ERR_SERVER_NOMATCH ; status = ""2ND_TKT_MISMATCH"" ; au_state -> status = status ; kau_u2u ( kdc_context , FALSE , au_state ) ; goto cleanup ; } ticket_kvno = 0 ; ticket_reply . enc_part . enctype = t2enc -> session -> enctype ; kau_u2u ( kdc_context , TRUE , au_state ) ; st_idx ++ ; } else { ticket_kvno = server_key -> key_data_kvno ; } errcode = krb5_encrypt_tkt_part ( kdc_context , & encrypting_key , & ticket_reply ) ; if ( ! isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) ) krb5_free_keyblock_contents ( kdc_context , & encrypting_key ) ; if ( errcode ) { status = ""ENCRYPT_TICKET"" ; goto cleanup ; } ticket_reply . enc_part . kvno = ticket_kvno ; au_state -> stage = ENCR_REP ; reply . msg_type = KRB5_TGS_REP ; if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) && krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) != NULL ) { errcode = kdc_make_s4u2self_rep ( kdc_context , subkey , header_ticket -> enc_part2 -> session , s4u_x509_user , & reply , & reply_encpart ) ; if ( errcode ) { status = ""MAKE_S4U2SELF_PADATA"" ; au_state -> status = status ; } kau_s4u2self ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; if ( errcode ) goto cleanup ; } reply . client = enc_tkt_reply . client ; reply . enc_part . kvno = 0 ; reply . ticket = & ticket_reply ; reply_encpart . session = & session_key ; reply_encpart . nonce = request -> nonce ; reply_encpart . times = enc_tkt_reply . times ; nolrentry . lr_type = KRB5_LRQ_NONE ; nolrentry . value = 0 ; nolrentry . magic = 0 ; nolrarray [ 0 ] = & nolrentry ; nolrarray [ 1 ] = 0 ; reply_encpart . last_req = nolrarray ; reply_encpart . key_exp = 0 ; reply_encpart . flags = enc_tkt_reply . flags ; reply_encpart . server = ticket_reply . server ; reply . enc_part . enctype = subkey ? subkey -> enctype : header_ticket -> enc_part2 -> session -> enctype ; errcode = kdc_fast_response_handle_padata ( state , request , & reply , subkey ? subkey -> enctype : header_ticket -> enc_part2 -> session -> enctype ) ; if ( errcode != 0 ) { status = ""MAKE_FAST_RESPONSE"" ; goto cleanup ; } errcode = kdc_fast_handle_reply_key ( state , subkey ? subkey : header_ticket -> enc_part2 -> session , & reply_key ) ; if ( errcode ) { status = ""MAKE_FAST_REPLY_KEY"" ; goto cleanup ; } errcode = return_enc_padata ( kdc_context , pkt , request , reply_key , server , & reply_encpart , is_referral && isflagset ( s_flags , KRB5_KDB_FLAG_CANONICALIZE ) ) ; if ( errcode ) { status = ""KDC_RETURN_ENC_PADATA"" ; goto cleanup ; } errcode = kau_make_tkt_id ( kdc_context , & ticket_reply , & au_state -> tkt_out_id ) ; if ( errcode ) { status = ""GENERATE_TICKET_ID"" ; goto cleanup ; } if ( kdc_fast_hide_client ( state ) ) reply . client = ( krb5_principal ) krb5_anonymous_principal ( ) ; errcode = krb5_encode_kdc_rep ( kdc_context , KRB5_TGS_REP , & reply_encpart , subkey ? 1 : 0 , reply_key , & reply , response ) ; if ( errcode ) { status = ""ENCODE_KDC_REP"" ; } else { status = ""ISSUE"" ; } memset ( ticket_reply . enc_part . ciphertext . data , 0 , ticket_reply . enc_part . ciphertext . length ) ; free ( ticket_reply . enc_part . ciphertext . data ) ; memset ( reply . enc_part . ciphertext . data , 0 , reply . enc_part . ciphertext . length ) ; free ( reply . enc_part . ciphertext . data ) ; cleanup :  assert ( status != NULL ) ;  if ( reply_key ) krb5_free_keyblock ( kdc_context , reply_key ) ; if ( errcode ) emsg = krb5_get_error_message ( kdc_context , errcode ) ; au_state -> status = status ; if ( ! errcode ) au_state -> reply = & reply ; kau_tgs_req ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; kau_free_kdc_req ( au_state ) ; log_tgs_req ( kdc_context , from , request , & reply , cprinc , sprinc , altcprinc , authtime , c_flags , status , errcode , emsg ) ; if ( errcode ) { krb5_free_error_message ( kdc_context , emsg ) ; emsg = NULL ; } if ( errcode ) { int got_err = 0 ; if ( status == 0 ) { status = krb5_get_error_message ( kdc_context , errcode ) ; got_err = 1 ; } errcode -= ERROR_TABLE_BASE_krb5 ; if ( errcode < 0 || errcode > KRB_ERR_MAX ) errcode = KRB_ERR_GENERIC ; retval = prepare_error_tgs ( state , request , header_ticket , errcode , ( server != NULL ) ? server -> princ : NULL , response , status , e_data ) ; if ( got_err ) { krb5_free_error_message ( kdc_context , status ) ; status = 0 ; } } if ( header_ticket != NULL ) krb5_free_ticket ( kdc_context , header_ticket ) ; if ( request != NULL ) krb5_free_kdc_req ( kdc_context , request ) ; if ( state ) kdc_free_rstate ( state ) ; krb5_db_free_principal ( kdc_context , server ) ; krb5_db_free_principal ( kdc_context , stkt_server ) ; krb5_db_free_principal ( kdc_context , header_server ) ; krb5_db_free_principal ( kdc_context , client ) ; krb5_db_free_principal ( kdc_context , local_tgt_storage ) ; if ( session_key . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & session_key ) ; if ( newtransited ) free ( enc_tkt_reply . transited . tr_contents . data ) ; if ( s4u_x509_user != NULL ) krb5_free_pa_s4u_x509_user ( kdc_context , s4u_x509_user ) ; if ( kdc_issued_auth_data != NULL ) krb5_free_authdata ( kdc_context , kdc_issued_auth_data ) ; if ( subkey != NULL ) krb5_free_keyblock ( kdc_context , subkey ) ; if ( header_key != NULL ) krb5_free_keyblock ( kdc_context , header_key ) ; if ( reply . padata ) krb5_free_pa_data ( kdc_context , reply . padata ) ; if ( reply_encpart . enc_padata ) krb5_free_pa_data ( kdc_context , reply_encpart . enc_padata ) ; if ( enc_tkt_reply . authorization_data != NULL ) krb5_free_authdata ( kdc_context , enc_tkt_reply . authorization_data ) ; krb5_free_pa_data ( kdc_context , e_data ) ; k5_free_data_ptr_list ( auth_indicators ) ; return retval ; }"," ; cleanup : if ( status == NULL ) status = ""UNKNOWN_REASON""  ; if ("
399,"CWE-20 static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) {  netdev_dbg ( vif -> dev , ""GSOsizemustnotbezero.\\n"" ) ;  return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) {  netdev_dbg ( vif -> dev , ""BadGSOtype%d.\\n"" , gso -> u . gso . type ) ;  return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }"," size ) { netdev_err  ( vif ->  dev , ""GSOsizemustnotbezero.\\n"" ) ; netbk_fatal_tx_err ( vif  XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err  ( vif ->  gso . type ) ; netbk_fatal_tx_err ( vif"
400,"CWE-19 static void ext4_xattr_release_block ( handle_t * handle , struct inode * inode , struct buffer_head * bh ) {  struct mb_cache_entry * ce = NULL ;   int error = 0 ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ce = mb_cache_entry_get ( ext4_mb_cache , bh -> b_bdev , bh -> b_blocknr ) ; BUFFER_TRACE ( bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bh ) ; if ( error ) goto out ; lock_buffer ( bh ) ; if ( BHDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) {  ea_bdebug ( bh , ""refcountnow=0;freeing"" ) ;   if ( ce )  mb_cache_entry_free ( ce ) ; get_bh ( bh ) ; unlock_buffer ( bh ) ; ext4_free_blocks ( handle , inode , bh , 0 , 1 , EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET ) ; } else { le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ;  if ( ce )  mb_cache_entry_release ( ce ) ; if ( ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; unlock_buffer ( bh ) ; if ( ! ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( inode -> i_sb ) , 1 ) ) ; ea_bdebug ( bh , ""refcountnow=%d;releasing"" , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; } out : ext4_std_error ( inode -> i_sb , error ) ; return ; }"," bh ) {  int error =  error = 0  ; BUFFER_TRACE (  ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ;  ""refcountnow=0;freeing"" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr  ) ; get_bh  ; if (  ext4_handle_valid ( handle"
401,"CWE-20 sctp_disposition_t sctp_sf_do_asconf_ack ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * asconf_ack = arg ; struct sctp_chunk * last_asconf = asoc -> addip_last_asconf ; struct sctp_chunk * abort ; struct sctp_paramhdr * err_param = NULL ; sctp_addiphdr_t * addip_hdr ; __u32 sent_serial , rcvd_serial ; if ( ! sctp_vtag_verify ( asconf_ack , asoc ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , SCTP_NULL ( ) ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( ! net -> sctp . addip_noauth && ! asconf_ack -> auth ) return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_chunk_length_valid ( asconf_ack , sizeof ( sctp_addip_chunk_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; addip_hdr = ( sctp_addiphdr_t * ) asconf_ack -> skb -> data ; rcvd_serial = ntohl ( addip_hdr -> serial ) ; if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) addip_hdr -> params ,  ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ; if ( last_asconf ) { addip_hdr = ( sctp_addiphdr_t * ) last_asconf -> subh . addip_hdr ; sent_serial = ntohl ( addip_hdr -> serial ) ; } else { sent_serial = asoc -> addip_serial - 1 ; } if ( ADDIP_SERIAL_gte ( rcvd_serial , sent_serial + 1 ) && ! ( asoc -> addip_last_asconf ) ) { abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_ASCONF_ACK , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } if ( ( rcvd_serial == sent_serial ) && asoc -> addip_last_asconf ) { sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; if ( ! sctp_process_asconf_ack ( ( struct sctp_association * ) asoc , asconf_ack ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_NEXT_ASCONF , SCTP_NULL ( ) ) ; return SCTP_DISPOSITION_CONSUME ; } abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_RSRC_LOW , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } return SCTP_DISPOSITION_DISCARD ; }"," ( asoc , asconf_ack , false ,  & err_param )"
402,"CWE-667 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ;  for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next )  if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }", mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
403,"CWE-125 static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = """" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , ""%s"" , sep ) ) ; sep = "","" ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( ip_option_values , ""unknown%u"" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , ""[badlength%u]"" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , ""[badlength%u]"" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : ip_printts ( ndo , cp , option_len ) ; break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR :  ip_printroute ( ndo , cp , option_len ) ;  break ; case IPOPT_RA : if ( option_len < 4 ) { ND_PRINT ( ( ndo , ""[badlength%u]"" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , ""value%u"" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }"," case IPOPT_LSRR : if (  , option_len ) == - 1 ) goto trunc"
404,"CWE-120 enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) { gss_buffer_desc request_buf , send_token ; gss_buffer_t sec_token ; gss_name_t target_name ; gss_ctx_id_t context ; gss_OID mech_name ; char server_conf_flags ; gss_qop_t quality ; int cflags ; OM_uint32 maj_stat , min_stat ; char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ; unsigned long buf_size ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ; if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; snprintf ( buf1 , sizeof ( buf1 ) , ""imap@%s"" , idata -> conn -> account . host ) ; request_buf . value = buf1 ; request_buf . length = strlen ( buf1 ) ; maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , ""Couldn\'tgetservicenamefor[%s]\\n"" , buf1 ) ; return IMAP_AUTH_UNAVAIL ; } else if ( DebugLevel >= 2 ) { gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ; mutt_debug ( 2 , ""Usingservicename[%s]\\n"" , ( char * ) request_buf . value ) ; gss_release_buffer ( & min_stat , & request_buf ) ; } sec_token = GSS_C_NO_BUFFER ; context = GSS_C_NO_CONTEXT ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , ""Erroracquiringcredentials-noTGT?\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; return IMAP_AUTH_UNAVAIL ; } mutt_message ( _ ( ""Authenticating(GSSAPI)..."" ) ) ; imap_cmd_start ( idata , ""AUTHENTICATEGSSAPI"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 2 , ""Invalidresponsefromserver:%s\\n"" , buf1 ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; } mutt_debug ( 2 , ""Sendingcredentials\\n"" ) ; mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; while ( maj_stat == GSS_S_CONTINUE_NEEDED ) { do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""#1Errorreceivingserverresponse.\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; }  request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;  request_buf . value = buf2 ; sec_token = & request_buf ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , ""Errorexchangingcredentials\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; } gss_release_name ( & min_stat , & target_name ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""#2Errorreceivingserverresponse.\\n"" ) ; goto bail ; }  request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;  request_buf . value = buf2 ; maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ; if ( maj_stat != GSS_S_COMPLETE ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 2 , ""Couldn\'tunwrapsecurityleveldata\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } mutt_debug ( 2 , ""Credentialexchangecomplete\\n"" ) ; server_conf_flags = ( ( char * ) send_token . value ) [ 0 ] ; if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) { mutt_debug ( 2 , ""Serverrequiresintegrityorprivacy\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } ( ( char * ) send_token . value ) [ 0 ] = '\\0' ; buf_size = ntohl ( * ( ( long * ) send_token . value ) ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_debug ( 2 , ""Unwrappedsecuritylevelflags:%c%c%c\\n"" , ( server_conf_flags & GSS_AUTH_P_NONE ) ? 'N' : '-' , ( server_conf_flags & GSS_AUTH_P_INTEGRITY ) ? 'I' : '-' , ( server_conf_flags & GSS_AUTH_P_PRIVACY ) ? 'P' : '-' ) ; mutt_debug ( 2 , ""MaximumGSStokensizeis%ld\\n"" , buf_size ) ; buf_size = htonl ( buf_size ) ; memcpy ( buf1 , & buf_size , 4 ) ; buf1 [ 0 ] = GSS_AUTH_P_NONE ; strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ; request_buf . value = buf1 ; request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ; maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , ""Errorcreatingloginrequest\\n"" ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; mutt_debug ( 2 , ""Requestingauthorisationas%s\\n"" , idata -> conn -> account . user ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc == IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Unexpectedservercontinuationrequest.\\n"" ) ; goto err_abort_cmd ; } if ( imap_code ( idata -> buf ) ) { mutt_debug ( 2 , ""ReleasingGSScredentials\\n"" ) ; maj_stat = gss_delete_sec_context ( & min_stat , & context , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) mutt_debug ( 1 , ""Errorreleasingcredentials\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; return IMAP_AUTH_SUCCESS ; } else goto bail ; err_abort_cmd : mutt_socket_send ( idata -> conn , ""*\\r\\n"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; bail : mutt_error ( _ ( ""GSSAPIauthenticationfailed."" ) ) ; return IMAP_AUTH_FAILURE ; }"," buf + 2 , sizeof ( buf2 )  buf + 2 , sizeof ( buf2 )"
405,"CWE-190 static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ;  unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;  } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }", 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
406,"CWE-119 int iscsi_decode_text_input ( u8 phase , u8 sender , char * textbuf , u32 length , struct iscsi_conn * conn ) { struct iscsi_param_list * param_list = conn -> param_list ; char * tmpbuf , * start = NULL , * end = NULL ; tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ) ; if ( ! tmpbuf ) { pr_err ( ""Unabletoallocatememoryfortmpbuf.\\n"" ) ; return - 1 ; } memcpy ( tmpbuf , textbuf , length ) ; tmpbuf [ length ] = '\\0' ; start = tmpbuf ; end = ( start + length ) ; while ( start < end ) { char * key , * value ; struct iscsi_param * param ; if ( iscsi_extract_key_value ( start , & key , & value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } pr_debug ( ""Gotkey:%s=%s\\n"" , key , value ) ; if ( phase & PHASE_SECURITY ) { if ( iscsi_check_for_auth_key ( key ) > 0 ) {  char * tmpptr = key + strlen ( key ) ;  * tmpptr = '=' ; kfree ( tmpbuf ) ; return 1 ; } } param = iscsi_check_key ( key , phase , sender , param_list ) ; if ( ! param ) { if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; continue ; } if ( iscsi_check_value ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; if ( IS_PSTATE_PROPOSER ( param ) ) { if ( iscsi_check_proposer_state ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_RESPONSE_GOT ( param ) ; } else { if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_ACCEPTOR ( param ) ; } } kfree ( tmpbuf ) ; return 0 ; }", 0 ) {  kfree ( tmpbuf
407,"CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ MNT_WRITE_HOLD ;  atomic_inc ( & sb -> s_active ) ;  mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; br_write_unlock ( & vfsmount_lock ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }", ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;
408,"CWE-125 int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ;  sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;  kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }", ; sigev_none =  timr -> it_sigev_notify  timr -> it_sigev_notify  == SIGEV_NONE ;
409,"CWE-119 static size_t write_compressed_header ( VP9_COMP * cpi , uint8_t * data ) { VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;   FRAME_CONTEXT * const fc = & cm -> fc ;  vp9_writer header_bc ; vp9_start_encode ( & header_bc , data ) ; if ( xd -> lossless ) cm -> tx_mode = ONLY_4X4 ; else  encode_txfm_probs ( cm , & header_bc ) ;  update_coef_probs ( cpi , & header_bc ) ;  update_skip_probs ( cm , & header_bc ) ;  if ( ! frame_is_intra_only ( cm ) ) { int i ; for ( i = 0 ; i < INTER_MODE_CONTEXTS ; ++ i )  prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] ,   cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ;  vp9_zero ( cm -> counts . inter_mode ) ; if ( cm -> interp_filter == SWITCHABLE )  update_switchable_interp_probs ( cm , & header_bc ) ;  for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> intra_inter_prob [ i ] ,  cm -> counts . intra_inter [ i ] ) ;   if ( cm -> allow_comp_inter_inter ) {  const int use_compound_pred = cm -> reference_mode != SINGLE_REFERENCE ; const int use_hybrid_pred = cm -> reference_mode == REFERENCE_MODE_SELECT ;  vp9_write_bit ( & header_bc , use_compound_pred ) ;  if ( use_compound_pred ) {  vp9_write_bit ( & header_bc , use_hybrid_pred ) ;  if ( use_hybrid_pred ) for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_inter_prob [ i ] ,  cm -> counts . comp_inter [ i ] ) ;  } } if ( cm -> reference_mode != COMPOUND_REFERENCE ) { for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) { vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 0 ] ,  cm -> counts . single_ref [ i ] [ 0 ] ) ;  vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 1 ] ,  cm -> counts . single_ref [ i ] [ 1 ] ) ;  } } if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_ref_prob [ i ] ,  cm -> counts . comp_ref [ i ] ) ;  for ( i = 0 ; i < BLOCK_SIZE_GROUPS ; ++ i )  prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] ,   cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ;  for ( i = 0 ; i < PARTITION_CONTEXTS ; ++ i ) prob_diff_update ( vp9_partition_tree , fc -> partition_prob [ i ] ,  cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ;   vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ;  }  vp9_stop_encode ( & header_bc ) ;  assert ( header_bc . pos <= 0xffff ) ; return header_bc . pos ; }"," & cpi -> td .  const fc = cm -> fc ; FRAME_COUNTS * counts = cpi -> td . counts ; vpx_writer header_bc ; vpx_start_encode  ( & header_bc  , & header_bc , counts  , & header_bc , counts  cm -> fc ->  inter_mode_probs [ i  i ] , counts ->  inter_mode [ i  , & header_bc  ) ; if  , & header_bc , counts  i ] , counts ->  intra_inter [ i  ; if ( cpi  -> allow_comp_inter_inter )  == REFERENCE_MODE_SELECT ; vpx_write_bit  ( & header_bc  use_compound_pred ) { vpx_write_bit  ( & header_bc  i ] , counts ->  comp_inter [ i  0 ] , counts ->  single_ref [ i  1 ] , counts ->  single_ref [ i  i ] , counts ->  comp_ref [ i  cm -> fc ->  y_mode_prob [ i  i ] , counts ->  y_mode [ i  i ] , counts ->  partition [ i  , & header_bc , & counts -> mv  ) ; } vpx_stop_encode  ( & header_bc"
410,"CWE-125 void ndpi_search_openvpn ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; const u_int8_t * ovpn_payload = packet -> payload ; const u_int8_t * session_remote ; u_int8_t opcode ; u_int8_t alen ; int8_t hmac_size ; int8_t failed = 0 ;  if ( packet -> payload_packet_len >= 40 ) {  if ( packet -> tcp != NULL )  ovpn_payload += 2 ;  opcode = ovpn_payload [ 0 ] & P_OPCODE_MASK ; if ( packet -> udp ) { # ifdef DEBUG printf ( ""[packet_id:%u][opcode:%u][PacketID:%d][%u<->%u][len:%u]\\n"" , flow -> num_processed_pkts , opcode , check_pkid_and_detect_hmac_size ( ovpn_payload ) ,  htons ( packet -> udp -> source ) , htons ( packet -> udp -> dest ) , packet -> payload_packet_len ) ;  # endif if ( ( flow -> num_processed_pkts == 1 ) && (  ( ( packet -> payload_packet_len == 112 )  && ( ( opcode == 168 ) || ( opcode == 192 ) ) )  || ( ( packet -> payload_packet_len == 80 )  && ( ( opcode == 184 ) || ( opcode == 88 ) || ( opcode == 160 ) || ( opcode == 168 ) || ( opcode == 200 ) ) ) ) ) { NDPI_LOG_INFO ( ndpi_struct , ""foundopenvpn\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_OPENVPN , NDPI_PROTOCOL_UNKNOWN ) ; return ; } } if ( flow -> ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && ( opcode == P_CONTROL_HARD_RESET_CLIENT_V1 || opcode == P_CONTROL_HARD_RESET_CLIENT_V2 ) ) { if ( check_pkid_and_detect_hmac_size ( ovpn_payload ) > 0 ) { memcpy ( flow -> ovpn_session_id , ovpn_payload + 1 , 8 ) ; NDPI_LOG_DBG2 ( ndpi_struct , ""sessionkey:%02x%02x%02x%02x%02x%02x%02x%02x\\n"" , flow -> ovpn_session_id [ 0 ] , flow -> ovpn_session_id [ 1 ] , flow -> ovpn_session_id [ 2 ] , flow -> ovpn_session_id [ 3 ] , flow -> ovpn_session_id [ 4 ] , flow -> ovpn_session_id [ 5 ] , flow -> ovpn_session_id [ 6 ] , flow -> ovpn_session_id [ 7 ] ) ; } } else if ( flow -> ovpn_counter >= 1 && flow -> ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT && ( opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2 ) ) { hmac_size = check_pkid_and_detect_hmac_size ( ovpn_payload ) ; if ( hmac_size > 0 ) {  alen = ovpn_payload [ P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ] ;  if ( alen > 0 ) {  session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) + 1 + alen * 4 ;   if ( memcmp ( flow -> ovpn_session_id , session_remote , 8 ) == 0 ) {  NDPI_LOG_INFO ( ndpi_struct , ""foundopenvpn\\n"" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_OPENVPN , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else { NDPI_LOG_DBG2 ( ndpi_struct , ""keymismatch:%02x%02x%02x%02x%02x%02x%02x%02x\\n"" , session_remote [ 0 ] , session_remote [ 1 ] , session_remote [ 2 ] , session_remote [ 3 ] , session_remote [ 4 ] , session_remote [ 5 ] , session_remote [ 6 ] , session_remote [ 7 ] ) ; failed = 1 ;  }  } else failed = 1 ; } else failed = 1 ; } else failed = 1 ; flow -> ovpn_counter ++ ; if ( failed ) { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; } } }"," = 0 ; int16_t ovpn_payload_len =  packet -> payload_packet_len  packet -> payload_packet_len ; if ( ovpn_payload_len  ovpn_payload += 2 , ovpn_payload_len -= 2 ;  dest ) , ovpn_payload_len  ) ; #  ( ( ( ovpn_payload_len  == 112 )  || ( ( ovpn_payload_len  == 80 )  0 ) { u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ;  = ovpn_payload [ offset  ] ; if  0 ) { offset +=  1 + alen  ; if ( ( offset + 8 ) <= ovpn_payload_len ) { session_remote = & ovpn_payload [ offset ] ; if (  1 ; } } else failed = 1 ;"
411,CWE-284 static bool msr_mtrr_valid ( unsigned msr ) { switch ( msr ) { case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1 : case MSR_MTRRfix64K_00000 : case MSR_MTRRfix16K_80000 : case MSR_MTRRfix16K_A0000 : case MSR_MTRRfix4K_C0000 : case MSR_MTRRfix4K_C8000 : case MSR_MTRRfix4K_D0000 : case MSR_MTRRfix4K_D8000 : case MSR_MTRRfix4K_E0000 : case MSR_MTRRfix4K_E8000 : case MSR_MTRRfix4K_F0000 : case MSR_MTRRfix4K_F8000 : case MSR_MTRRdefType : case MSR_IA32_CR_PAT : return true ;  case 0x2f8 :  return true ; } return false ; }, return true ;  } return false
412,CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ;  return TRUE ;  } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }, current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
413,"CWE-269 static int __poke_user ( struct task_struct * child , addr_t addr , addr_t data ) { struct user * dummy = NULL ; addr_t offset ; if ( addr < ( addr_t ) & dummy -> regs . acrs ) { if ( addr == ( addr_t ) & dummy -> regs . psw . mask ) { unsigned long mask = PSW_MASK_USER ; mask |= is_ri_task ( child ) ? PSW_MASK_RI : 0 ;  if ( ( data & ~ mask ) != PSW_USER_BITS )  return - EINVAL ; if ( ( data & PSW_MASK_EA ) && ! ( data & PSW_MASK_BA ) ) return - EINVAL ; } * ( addr_t * ) ( ( addr_t ) & task_pt_regs ( child ) -> psw + addr ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . orig_gpr2 ) ) { offset = addr - ( addr_t ) & dummy -> regs . acrs ; # ifdef CONFIG_64BIT if ( addr == ( addr_t ) & dummy -> regs . acrs [ 15 ] ) child -> thread . acrs [ 15 ] = ( unsigned int ) ( data >> 32 ) ; else # endif * ( addr_t * ) ( ( addr_t ) & child -> thread . acrs + offset ) = data ; } else if ( addr == ( addr_t ) & dummy -> regs . orig_gpr2 ) { task_pt_regs ( child ) -> orig_gpr2 = data ; } else if ( addr < ( addr_t ) & dummy -> regs . fp_regs ) { return 0 ; } else if ( addr < ( addr_t ) ( & dummy -> regs . fp_regs + 1 ) ) { if ( addr == ( addr_t ) & dummy -> regs . fp_regs . fpc ) if ( ( unsigned int ) data != 0 || test_fp_ctl ( data >> ( BITS_PER_LONG - 32 ) ) ) return - EINVAL ; offset = addr - ( addr_t ) & dummy -> regs . fp_regs ; * ( addr_t * ) ( ( addr_t ) & child -> thread . fp_regs + offset ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . per_info + 1 ) ) { addr -= ( addr_t ) & dummy -> regs . per_info ; __poke_user_per ( child , addr , data ) ; } return 0 ; }", ( ( data ^ PSW_USER_BITS )  ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME  ) return -
414,"CWE-119 static void find_next_key_frame ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { int i , j ; FIRSTPASS_STATS last_frame ; FIRSTPASS_STATS first_frame ; FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_position ; double decay_accumulator = 1.0 ; double boost_score = 0 ; double old_boost_score = 0.0 ; double loop_decay_rate ; double kf_mod_err = 0.0 ; double kf_group_err = 0.0 ; double kf_group_intra_err = 0.0 ; double kf_group_coded_err = 0.0 ; double recent_loop_decay [ 8 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 } ;  vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;  vp8_clear_system_state ( ) ; start_position = cpi -> twopass . stats_in ; cpi -> common . frame_type = KEY_FRAME ; cpi -> this_key_frame_forced = cpi -> next_key_frame_forced ; cpi -> source_alt_ref_active = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> twopass . frames_to_key = 1 ;  vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ;  cpi -> twopass . kf_group_bits = 0 ; cpi -> twopass . kf_group_error_left = 0 ; kf_mod_err = calculate_modified_err ( cpi , this_frame ) ; i = 0 ; while ( cpi -> twopass . stats_in < cpi -> twopass . stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , this_frame ) ; kf_group_intra_err += this_frame -> intra_error ; kf_group_coded_err += this_frame -> coded_error ;  vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ;  input_stats ( cpi , this_frame ) ; if ( cpi -> oxcf . auto_key && lookup_next_frame_stats ( cpi , & next_frame ) != EOF ) { if ( ( i >= MIN_GF_INTERVAL ) && test_candidate_kf ( cpi , & last_frame , this_frame , & next_frame ) ) { break ; } loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; recent_loop_decay [ i % 8 ] = loop_decay_rate ; decay_accumulator = 1.0 ; for ( j = 0 ; j < 8 ; j ++ ) { decay_accumulator = decay_accumulator * recent_loop_decay [ j ] ; } if ( detect_transition_to_still ( cpi , i , ( cpi -> key_frame_frequency - i ) , loop_decay_rate , decay_accumulator ) ) { break ; } cpi -> twopass . frames_to_key ++ ; if ( cpi -> twopass . frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency ) break ; } else cpi -> twopass . frames_to_key ++ ; i ++ ; } if ( cpi -> oxcf . auto_key && cpi -> twopass . frames_to_key > ( int ) cpi -> key_frame_frequency ) { FIRSTPASS_STATS * current_pos = cpi -> twopass . stats_in ; FIRSTPASS_STATS tmp_frame ; cpi -> twopass . frames_to_key /= 2 ;  vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ;  reset_fpf_position ( cpi , start_position ) ; kf_group_err = 0 ; kf_group_intra_err = 0 ; kf_group_coded_err = 0 ; for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) { kf_group_err += calculate_modified_err ( cpi , & tmp_frame ) ; kf_group_intra_err += tmp_frame . intra_error ; kf_group_coded_err += tmp_frame . coded_error ; input_stats ( cpi , & tmp_frame ) ; } reset_fpf_position ( cpi , current_pos ) ; cpi -> next_key_frame_forced = 1 ; } else cpi -> next_key_frame_forced = 0 ; if ( cpi -> twopass . stats_in >= cpi -> twopass . stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , this_frame ) ; kf_group_intra_err += this_frame -> intra_error ; kf_group_coded_err += this_frame -> coded_error ; } if ( ( cpi -> twopass . bits_left > 0 ) && ( cpi -> twopass . modified_error_left > 0.0 ) ) { int max_bits = frame_max_bits ( cpi ) ; int64_t max_grp_bits ; cpi -> twopass . kf_group_bits = ( int64_t ) ( cpi -> twopass . bits_left * ( kf_group_err / cpi -> twopass . modified_error_left ) ) ; max_grp_bits = ( int64_t ) max_bits * ( int64_t ) cpi -> twopass . frames_to_key ; if ( cpi -> twopass . kf_group_bits > max_grp_bits ) cpi -> twopass . kf_group_bits = max_grp_bits ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { int64_t opt_buffer_lvl = cpi -> oxcf . optimal_buffer_level ; int64_t buffer_lvl = cpi -> buffer_level ; if ( buffer_lvl >= opt_buffer_lvl ) { int64_t high_water_mark = ( opt_buffer_lvl + cpi -> oxcf . maximum_buffer_size ) >> 1 ; int64_t av_group_bits ; av_group_bits = ( int64_t ) cpi -> av_per_frame_bandwidth * ( int64_t ) cpi -> twopass . frames_to_key ; if ( cpi -> buffer_level >= high_water_mark ) { int64_t min_group_bits ; min_group_bits = av_group_bits + ( int64_t ) ( buffer_lvl - high_water_mark ) ; if ( cpi -> twopass . kf_group_bits < min_group_bits ) cpi -> twopass . kf_group_bits = min_group_bits ; } else if ( cpi -> twopass . kf_group_bits < av_group_bits ) { int64_t bits_below_av = av_group_bits - cpi -> twopass . kf_group_bits ; cpi -> twopass . kf_group_bits += ( int64_t ) ( ( double ) bits_below_av * ( double ) ( buffer_lvl - opt_buffer_lvl ) / ( double ) ( high_water_mark - opt_buffer_lvl ) ) ; } } } } else cpi -> twopass . kf_group_bits = 0 ; reset_fpf_position ( cpi , start_position ) ; decay_accumulator = 1.0 ;  boost_score = 0.0 ;  loop_decay_rate = 1.00 ; for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) { double r ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; if ( next_frame . intra_error > cpi -> twopass . kf_intra_err_min ) r = ( IIKFACTOR2 * next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; else r = ( IIKFACTOR2 * cpi -> twopass . kf_intra_err_min / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; if ( r > RMAX ) r = RMAX ; loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; boost_score += ( decay_accumulator * r ) ; if ( ( i > MIN_GF_INTERVAL ) && ( ( boost_score - old_boost_score ) < 1.0 ) ) { break ; } old_boost_score = boost_score ; } if ( 1 ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_position ) ; for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int df_buffer_level = ( int ) ( cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } reset_fpf_position ( cpi , start_position ) ; if ( 1 ) { int kf_boost = ( int ) boost_score ; int allocation_chunks ; int Counter = cpi -> twopass . frames_to_key ; int alt_kf_bits ; YV12_BUFFER_CONFIG * lst_yv12 = & cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] ; # if 0 while ( ( kf_boost < 48 ) && ( Counter > 0 ) ) { Counter -= 2 ; kf_boost ++ ; } # endif if ( kf_boost < 48 ) { kf_boost += ( ( Counter + 1 ) >> 1 ) ; if ( kf_boost > 48 ) kf_boost = 48 ; } if ( ( lst_yv12 -> y_width * lst_yv12 -> y_height ) > ( 320 * 240 ) ) kf_boost += 2 * ( lst_yv12 -> y_width * lst_yv12 -> y_height ) / ( 320 * 240 ) ; else if ( ( lst_yv12 -> y_width * lst_yv12 -> y_height ) < ( 320 * 240 ) ) kf_boost -= 4 * ( 320 * 240 ) / ( lst_yv12 -> y_width * lst_yv12 -> y_height ) ; kf_boost = ( int ) ( ( double ) kf_boost * 100.0 ) >> 4 ; if ( kf_boost < 250 ) kf_boost = 250 ; if ( decay_accumulator >= 0.99 ) { allocation_chunks = ( ( cpi -> twopass . frames_to_key - 1 ) * 10 ) + kf_boost ; } else { allocation_chunks = ( ( cpi -> twopass . frames_to_key - 1 ) * 100 ) + kf_boost ; } while ( kf_boost > 1000 ) { kf_boost /= 2 ; allocation_chunks /= 2 ; } cpi -> twopass . kf_group_bits = ( cpi -> twopass . kf_group_bits < 0 ) ? 0 : cpi -> twopass . kf_group_bits ; cpi -> twopass . kf_bits = ( int ) ( ( double ) kf_boost * ( ( double ) cpi -> twopass . kf_group_bits / ( double ) allocation_chunks ) ) ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . kf_bits > ( int ) ( ( 3 * cpi -> buffer_level ) >> 2 ) ) cpi -> twopass . kf_bits = ( int ) ( ( 3 * cpi -> buffer_level ) >> 2 ) ; } if ( kf_mod_err < kf_group_err / cpi -> twopass . frames_to_key ) { double alt_kf_grp_bits = ( ( double ) cpi -> twopass . bits_left * ( kf_mod_err * ( double ) cpi -> twopass . frames_to_key ) / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . modified_error_left ) ) ; alt_kf_bits = ( int ) ( ( double ) kf_boost * ( alt_kf_grp_bits / ( double ) allocation_chunks ) ) ; if ( cpi -> twopass . kf_bits > alt_kf_bits ) { cpi -> twopass . kf_bits = alt_kf_bits ; } } else { alt_kf_bits = ( int ) ( ( double ) cpi -> twopass . bits_left * ( kf_mod_err / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . modified_error_left ) ) ) ; if ( alt_kf_bits > cpi -> twopass . kf_bits ) { cpi -> twopass . kf_bits = alt_kf_bits ; } } cpi -> twopass . kf_group_bits -= cpi -> twopass . kf_bits ; cpi -> twopass . kf_bits += cpi -> min_frame_bandwidth ; cpi -> per_frame_bandwidth = cpi -> twopass . kf_bits ; cpi -> target_bandwidth = ( int ) ( cpi -> twopass . kf_bits * cpi -> output_framerate ) ; } cpi -> twopass . kf_group_error_left = ( int ) ( kf_group_err - kf_mod_err ) ; cpi -> twopass . modified_error_left -= kf_group_err ; if ( cpi -> oxcf . allow_spatial_resampling ) { int resample_trigger = 0 ; int last_kf_resampled = 0 ; int kf_q ; int scale_val = 0 ; int hr , hs , vr , vs ; int new_width = cpi -> oxcf . Width ; int new_height = cpi -> oxcf . Height ;  int projected_buffer_level = ( int ) cpi -> buffer_level ;  int tmp_q ; double projected_bits_perframe ; double group_iiratio = ( kf_group_intra_err - first_frame . intra_error ) / ( kf_group_coded_err - first_frame . coded_error ) ; double err_per_frame = kf_group_err / cpi -> twopass . frames_to_key ; double bits_per_frame ; double av_bits_per_frame ; double effective_size_ratio ; if ( ( cpi -> common . Width != cpi -> oxcf . Width ) || ( cpi -> common . Height != cpi -> oxcf . Height ) ) last_kf_resampled = 1 ; cpi -> common . horiz_scale = NORMAL ; cpi -> common . vert_scale = NORMAL ; av_bits_per_frame = cpi -> oxcf . target_bandwidth / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> framerate ) ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { bits_per_frame = av_bits_per_frame ; } else { bits_per_frame = ( double ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) ; if ( bits_per_frame < av_bits_per_frame ) bits_per_frame = av_bits_per_frame ; } if ( bits_per_frame < ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ) bits_per_frame = ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ; kf_q = estimate_kf_group_q ( cpi , err_per_frame , ( int ) bits_per_frame , group_iiratio ) ; projected_bits_perframe = bits_per_frame ; tmp_q = kf_q ; while ( tmp_q > cpi -> worst_quality ) { projected_bits_perframe *= 1.04 ; tmp_q -- ; } projected_buffer_level = ( int ) ( cpi -> buffer_level - ( int ) ( ( projected_bits_perframe - av_bits_per_frame ) * cpi -> twopass . frames_to_key ) ) ; if ( 0 ) { FILE * f = fopen ( ""Subsamle.stt"" , ""a"" ) ; fprintf ( f , ""%8d%8d%8d%8d%12.0f%8d%8d%8d\\n"" , cpi -> common . current_video_frame , kf_q , cpi -> common . horiz_scale , cpi -> common . vert_scale , kf_group_err / cpi -> twopass . frames_to_key , ( int ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) , new_height , new_width ) ; fclose ( f ) ; } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( ( projected_buffer_level < ( cpi -> oxcf . resample_down_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) || ( last_kf_resampled && ( projected_buffer_level < ( cpi -> oxcf . resample_up_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) ) ) resample_trigger = 1 ; else resample_trigger = 0 ; } else { int64_t clip_bits = ( int64_t ) ( cpi -> twopass . total_stats . count * cpi -> oxcf . target_bandwidth / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> framerate ) ) ; int64_t over_spend = cpi -> oxcf . starting_buffer_level - cpi -> buffer_level ; if ( ( last_kf_resampled && ( kf_q > cpi -> worst_quality ) ) || ( ( kf_q > cpi -> worst_quality ) && ( over_spend > clip_bits / 20 ) ) ) resample_trigger = 1 ; else resample_trigger = 0 ; } if ( resample_trigger ) { while ( ( kf_q >= cpi -> worst_quality ) && ( scale_val < 6 ) ) { scale_val ++ ; cpi -> common . vert_scale = vscale_lookup [ scale_val ] ; cpi -> common . horiz_scale = hscale_lookup [ scale_val ] ; Scale2Ratio ( cpi -> common . horiz_scale , & hr , & hs ) ; Scale2Ratio ( cpi -> common . vert_scale , & vr , & vs ) ; new_width = ( ( hs - 1 ) + ( cpi -> oxcf . Width * hr ) ) / hs ; new_height = ( ( vs - 1 ) + ( cpi -> oxcf . Height * vr ) ) / vs ; effective_size_ratio = ( double ) ( new_width * new_height ) / ( double ) ( cpi -> oxcf . Width * cpi -> oxcf . Height ) ; effective_size_ratio = ( 1.0 + ( 3.0 * effective_size_ratio ) ) / 4.0 ; kf_q = estimate_kf_group_q ( cpi , err_per_frame * effective_size_ratio , ( int ) bits_per_frame , group_iiratio ) ; if ( 0 ) { FILE * f = fopen ( ""Subsamle.stt"" , ""a"" ) ; fprintf ( f , ""********%8d%8d%8d%12.0f%8d%8d%8d\\n"" , kf_q , cpi -> common . horiz_scale , cpi -> common . vert_scale , kf_group_err / cpi -> twopass . frames_to_key , ( int ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) , new_height , new_width ) ; fclose ( f ) ; } } } if ( ( cpi -> common . Width != new_width ) || ( cpi -> common . Height != new_height ) ) { cpi -> common . Width = new_width ; cpi -> common . Height = new_height ; vp8_alloc_compressor_data ( cpi ) ; } } }", 1.0 } ; memset  ( & next_frame  = 1 ; memcpy  ( & first_frame  -> coded_error ; memcpy  ( & last_frame  /= 2 ; memcpy  ( & tmp_frame  boost_score = 0.0  ; for (  ; int projected_buffer_level  ; int tmp_q
415,"CWE-119 static int xpm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { XPMDecContext * x = avctx -> priv_data ; AVFrame * p = data ;  const uint8_t * end , * ptr = avpkt -> data ;  int ncolors , cpp , ret , i , j ; int64_t size ; uint32_t * dst ; avctx -> pix_fmt = AV_PIX_FMT_BGRA ;  end = avpkt -> data + avpkt -> size ;   while ( memcmp ( ptr , ""/*XPM*/"" , 9 ) && ptr < end - 9 )  ptr ++ ; if ( ptr >= end ) { av_log ( avctx , AV_LOG_ERROR , ""missingsignature\\n"" ) ; return AVERROR_INVALIDDATA ; } ptr += mod_strcspn ( ptr , ""\\"""" ) ; if ( sscanf ( ptr , ""\\""%u%u%u%u\\"","" , & avctx -> width , & avctx -> height , & ncolors , & cpp ) != 4 ) { av_log ( avctx , AV_LOG_ERROR , ""missingimageparameters\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ) ) < 0 ) return ret ; if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; if ( cpp <= 0 || cpp >= 5 ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported/invalidnumberofcharsperpixel:%d\\n"" , cpp ) ; return AVERROR_INVALIDDATA ; } size = 1 ; for ( i = 0 ; i < cpp ; i ++ )  size *= 94 ;  if ( ncolors <= 0 || ncolors > size ) { av_log ( avctx , AV_LOG_ERROR , ""invalidnumberofcolors:%d\\n"" , ncolors ) ; return AVERROR_INVALIDDATA ; } size *= 4 ; av_fast_padded_malloc ( & x -> pixels , & x -> pixels_size , size ) ; if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ; ptr += mod_strcspn ( ptr , "","" ) + 1 ;  for ( i = 0 ; i < ncolors ; i ++ ) {  const uint8_t * index ; int len ; ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ;  if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ; index = ptr ; ptr += cpp ; ptr = strstr ( ptr , ""c"" ) ; if ( ptr ) { ptr += 2 ; } else { return AVERROR_INVALIDDATA ; } len = strcspn ( ptr , ""\\"""" ) ; if ( ( ret = ascii2index ( index , cpp ) ) < 0 ) return ret ; x -> pixels [ ret ] = color_string_to_rgba ( ptr , len ) ; ptr += mod_strcspn ( ptr , "","" ) + 1 ;  }  for ( i = 0 ; i < avctx -> height ; i ++ ) { dst = ( uint32_t * ) ( p -> data [ 0 ] + i * p -> linesize [ 0 ] ) ;  ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ;   for ( j = 0 ; j < avctx -> width ; j ++ ) {   if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ; if ( ( ret = ascii2index ( ptr , cpp ) ) < 0 ) return ret ; * dst ++ = x -> pixels [ ret ] ; ptr += cpp ; } ptr += mod_strcspn ( ptr , "","" ) + 1 ; } p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }"," , * ptr  ; int ncolors  = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf  + avpkt ->  ; while ( end - ptr > 9 &&  , 9 ) ) ptr ++ ; if ( end - ptr <= 9  ) { av_log  ) size *= 95  ; if (  + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;  ; if ( end - ptr < cpp  ) return AVERROR_INVALIDDATA  + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;  ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;  + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;  { if ( end - ptr < cpp  ) return AVERROR_INVALIDDATA"
416,"CWE-284 static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags ,  struct in6_addr * addr , uint32_t * ifindex )  { struct sockaddr_in6 sin6 ;  unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;  struct iovec iovec ; struct msghdr msghdr ; struct cmsghdr * cmsghdr ; ssize_t len ; iovec . iov_len = * buflen ; iovec . iov_base = buf ; memset ( & msghdr , 0 , sizeof ( msghdr ) ) ; msghdr . msg_name = & sin6 ; msghdr . msg_namelen = sizeof ( sin6 ) ; msghdr . msg_iov = & iovec ; msghdr . msg_iovlen = 1 ; msghdr . msg_control = cbuf ; msghdr . msg_controllen = sizeof ( cbuf ) ; len = recvmsg ( sockfd , & msghdr , flags ) ; if ( len == - 1 ) return - errno ; * buflen = len ; * ifindex = sin6 . sin6_scope_id ; for ( cmsghdr = CMSG_FIRSTHDR ( & msghdr ) ; cmsghdr ; cmsghdr = CMSG_NXTHDR ( & msghdr , cmsghdr ) ) {  if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 &&   cmsghdr -> cmsg_type == IPV6_PKTINFO &&  cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) { struct in6_pktinfo * pktinfo ; pktinfo = ( struct in6_pktinfo * ) CMSG_DATA ( cmsghdr ) ; * ifindex = pktinfo -> ipi6_ifindex ; }  }  * addr = sin6 . sin6_addr ; return 0 ; }"," uint32_t * ifindex , int * hoplimit  char cbuf [ 2 *  cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ; switch (  cmsghdr -> cmsg_type  cmsghdr -> cmsg_type ) { case IPV6_PKTINFO : if (  cmsghdr -> cmsg_len  ipi6_ifindex ; } break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; }"
417,"CWE-000 SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ;  if ( ep_loop_check ( ep , tfile ) != 0 )   goto error_tgt_fput ;  } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }", != 0 ) { clear_tfile_check_list ( ) ;  goto error_tgt_fput ; }
418,"CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ;  dprintk ( 2 , ""vm_open%p[count=%d,vma=%08lx-%08lx]\\n"" , map ,  map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }"," ( 2 , ""vm_open%p[count=%u,vma=%08lx-%08lx]\\n""  , map ,"
419,"CWE-119 int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , ""RegisteringMAC:0x%llx\\n"" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } }  mlx4_dbg ( dev , ""FreeMACindexis%d\\n"" , free ) ;  if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , ""FailedaddingMAC:0x%llx\\n"" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }", ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
420,"CWE-200 static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ;  unsigned facility ;  struct option long_options [ ] = { { ""use-file"" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { ""vrrp"" , no_argument , NULL , 'P' } , { ""check"" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { ""no_bfd"" , no_argument , NULL , 'B' } , # endif { ""all"" , no_argument , NULL , 3 } , { ""log-console"" , no_argument , NULL , 'l' } , { ""log-detail"" , no_argument , NULL , 'D' } , { ""log-facility"" , required_argument , NULL , 'S' } , { ""log-file"" , optional_argument , NULL , 'g' } , { ""flush-log-file"" , no_argument , NULL , 2 } , { ""no-syslog"" , no_argument , NULL , 'G' } ,  # ifdef _WITH_VRRP_  { ""release-vips"" , no_argument , NULL , 'X' } , { ""dont-release-vrrp"" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { ""dont-release-ipvs"" , no_argument , NULL , 'I' } , # endif { ""dont-respawn"" , no_argument , NULL , 'R' } , { ""dont-fork"" , no_argument , NULL , 'n' } , { ""dump-conf"" , no_argument , NULL , 'd' } , { ""pid"" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { ""vrrp_pid"" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { ""checkers_pid"" , required_argument , NULL , 'c' } , { ""address-monitoring"" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { ""bfd_pid"" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { ""snmp"" , no_argument , NULL , 'x' } , { ""snmp-agent-socket"" , required_argument , NULL , 'A' } , # endif { ""core-dump"" , no_argument , NULL , 'm' } , { ""core-dump-pattern"" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { ""mem-check-log"" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { ""namespace"" , required_argument , NULL , 's' } , # endif { ""config-id"" , required_argument , NULL , 'i' } , { ""signum"" , required_argument , NULL , 4 } , { ""config-test"" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { ""perf"" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { ""debug"" , optional_argument , NULL , 6 } , # endif { ""version"" , no_argument , NULL , 'v' } , { ""help"" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ;  while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::""  # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , ""%s"" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , "",gitcommit%s"" , GIT_COMMIT ) ; # endif fprintf ( stderr , ""\\n\\n%s\\n\\n"" , COPYRIGHT_STRING ) ; fprintf ( stderr , ""BuiltwithkernelheadersforLinux%d.%d.%d\\n"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , ""Runningon%s%s%s\\n\\n"" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , ""configureoptions:%s\\n\\n"" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , ""Configoptions:%s\\n\\n"" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , ""Systemoptions:%s\\n"" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , ""Invalidlogfacility\'%s\'\\n"" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = ""/tmp/keepalived.log"" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ;  case 't' :  __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; if ( fd == - 1 ) { fprintf ( stderr , ""Unabletoopenconfig-testlogfile%s\\n"" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , ""Unknownsigfunc%s\\n"" , optarg ) ; exit ( 1 ) ; } printf ( ""%d\\n"" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , ""run"" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , ""all"" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , ""end"" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , ""Unknownperfstartpoint%s"" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Unknownoption-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Unknownoption%s\\n"" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Missingparameterforoption-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Missingparameterforoption--%s\\n"" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( ""Unexpectedargument(s):"" ) ; while ( optind < argc ) printf ( ""%s"" , argv [ optind ++ ] ) ; printf ( ""\\n"" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }"," ; unsigned facility ; mode_t new_umask_val  'G' } , { ""umask"" , required_argument , NULL , 'u' } ,  , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::""  # if defined  break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case"
421,"CWE-000 static int crypto_report_akcipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ;  strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;  if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }", crypto_report_akcipher rakcipher ; strncpy  ( rakcipher .
422,"CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) {  int x , y , pos ;  Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( ""CouldnotcreateWBMP"" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) {  if ( gdImageGetPixel ( image , x , y ) == fg ) {  wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( ""CouldnotsaveWBMP"" ) ; } freewbmp ( wbmp ) ; }"," out ) { _gdImageWBMPCtx  ( image ,  ( image , fg , out  ) ; }"
423,"CWE-119 static void update_mbgraph_frame_stats ( VP9_COMP * cpi , MBGRAPH_FRAME_STATS * stats , YV12_BUFFER_CONFIG * buf , YV12_BUFFER_CONFIG * golden_ref , YV12_BUFFER_CONFIG * alt_ref ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; VP9_COMMON * const cm = & cpi -> common ; int mb_col , mb_row , offset = 0 ; int mb_y_offset = 0 , arf_y_offset = 0 , gld_y_offset = 0 ;  int_mv arf_top_mv , gld_top_mv ;   MODE_INFO mi_local = { { 0 } } ;  arf_top_mv . as_int = 0 ; gld_top_mv . as_int = 0 ; x -> mv_row_min = - BORDER_MV_PIXELS_B16 ; x -> mv_row_max = ( cm -> mb_rows - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> up_available = 0 ; xd -> plane [ 0 ] . dst . stride = buf -> y_stride ; xd -> plane [ 0 ] . pre [ 0 ] . stride = buf -> y_stride ; xd -> plane [ 1 ] . dst . stride = buf -> uv_stride ; xd -> mi [ 0 ] = & mi_local ; mi_local . mbmi . sb_type = BLOCK_16X16 ; mi_local . mbmi . ref_frame [ 0 ] = LAST_FRAME ; mi_local . mbmi . ref_frame [ 1 ] = NONE ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) {  int_mv arf_left_mv , gld_left_mv ;  int mb_y_in_offset = mb_y_offset ; int arf_y_in_offset = arf_y_offset ;  int gld_y_in_offset = gld_y_offset ;  arf_left_mv . as_int = arf_top_mv . as_int ; gld_left_mv . as_int = gld_top_mv . as_int ; x -> mv_col_min = - BORDER_MV_PIXELS_B16 ; x -> mv_col_max = ( cm -> mb_cols - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> left_available = 0 ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { MBGRAPH_MB_STATS * mb_stats = & stats -> mb_stats [ offset + mb_col ] ; update_mbgraph_mb_stats ( cpi , mb_stats , buf , mb_y_in_offset , golden_ref , & gld_left_mv , alt_ref , mb_row , mb_col ) ;  arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ;  gld_left_mv . as_int = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int ; if ( mb_col == 0 ) { arf_top_mv . as_int = arf_left_mv . as_int ; gld_top_mv . as_int = gld_left_mv . as_int ; } xd -> left_available = 1 ; mb_y_in_offset += 16 ; gld_y_in_offset += 16 ; arf_y_in_offset += 16 ; x -> mv_col_min -= 16 ; x -> mv_col_max -= 16 ; } xd -> up_available = 1 ; mb_y_offset += buf -> y_stride * 16 ; gld_y_offset += golden_ref -> y_stride * 16 ; if ( alt_ref ) arf_y_offset += alt_ref -> y_stride * 16 ; x -> mv_row_min -= 16 ; x -> mv_row_max -= 16 ; offset += cm -> mb_cols ; } }"," & cpi -> td .  = 0 ; MV gld_top_mv = { 0 , 0 }  ; MODE_INFO mi_local  ; MODE_INFO mi_local ; vp9_zero ( mi_local )  ; x ->  ++ ) { MV gld_left_mv = gld_top_mv  ; int mb_y_in_offset  gld_y_in_offset = gld_y_offset  ; x ->  mb_col ) ; gld_left_mv  = mb_stats ->  -> ref [ GOLDEN_FRAME  ] . m  . mv . as_mv ; if ( mb_col == 0 ) { gld_top_mv = gld_left_mv  ; } xd"
424,"CWE-125 int PyParser_AddToken ( parser_state * ps , int type , char * str , int lineno , int col_offset , int end_lineno , int end_col_offset , int * expected_ret ) { int ilabel ; int err ; D ( printf ( ""Token%s/\'%s\'..."" , _PyParser_TokenNames [ type ] , str ) ) ; ilabel = classify ( ps , type , str ) ; if ( ilabel < 0 ) return E_SYNTAX ; for ( ; ; ) { dfa * d = ps -> p_stack . s_top -> s_dfa ; state * s = & d -> d_state [ ps -> p_stack . s_top -> s_state ] ; D ( printf ( ""DFA\'%s\',state%d:"" , d -> d_name , ps -> p_stack . s_top -> s_state ) ) ; if ( s -> s_lower <= ilabel && ilabel < s -> s_upper ) { int x = s -> s_accel [ ilabel - s -> s_lower ] ; if ( x != - 1 ) { if ( x & ( 1 << 7 ) ) { int nt = ( x >> 8 ) + NT_OFFSET ; int arrow = x & ( ( 1 << 7 ) - 1 ) ;  dfa * d1 = PyGrammar_FindDFA (  ps -> p_grammar , nt ) ; if ( ( err = push ( & ps -> p_stack , nt , d1 , arrow , lineno , col_offset , end_lineno , end_col_offset ) ) > 0 ) { D ( printf ( ""MemError:push\\n"" ) ) ; return err ; }  D ( printf ( ""Push...\\n"" ) ) ;  continue ; } if ( ( err = shift ( & ps -> p_stack , type , str , x , lineno , col_offset , end_lineno , end_col_offset ) ) > 0 ) { D ( printf ( ""MemError:shift.\\n"" ) ) ; return err ; } D ( printf ( ""Shift.\\n"" ) ) ; while ( s = & d -> d_state [ ps -> p_stack . s_top -> s_state ] , s -> s_accept && s -> s_narcs == 1 ) { D ( printf ( ""DFA\'%s\',state%d:"" ""Directpop.\\n"" , d -> d_name , ps -> p_stack . s_top -> s_state ) ) ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD # if 0 if ( d -> d_name [ 0 ] == 'i' && strcmp ( d -> d_name , ""import_stmt"" ) == 0 ) future_hack ( ps ) ; # endif # endif s_pop ( & ps -> p_stack ) ; if ( s_empty ( & ps -> p_stack ) ) { D ( printf ( ""ACCEPT.\\n"" ) ) ; return E_DONE ; } d = ps -> p_stack . s_top -> s_dfa ; } return E_OK ; } } if ( s -> s_accept ) { # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD # if 0 if ( d -> d_name [ 0 ] == 'i' && strcmp ( d -> d_name , ""import_stmt"" ) == 0 ) future_hack ( ps ) ; # endif # endif s_pop ( & ps -> p_stack ) ; D ( printf ( ""Pop...\\n"" ) ) ; if ( s_empty ( & ps -> p_stack ) ) { D ( printf ( ""Error:bottomofstack.\\n"" ) ) ; return E_SYNTAX ; } continue ; } D ( printf ( ""Error.\\n"" ) ) ; if ( expected_ret ) { if ( s -> s_lower == s -> s_upper - 1 ) { * expected_ret = ps -> p_grammar -> g_ll . ll_label [ s -> s_lower ] . lb_type ; } else * expected_ret = - 1 ; } return E_SYNTAX ; } }"," dfa * d1 ; if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) { D ( printf ( ""[switchfunc_body_suitetosuite]"" ) ) ; nt = suite ; } d1  ( printf ( ""Push\'%s\'\\n"" , d1 -> d_name  ) ) ;"
425,"CWE-787 static void processCertificateElements ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow , u_int16_t p_offset , u_int16_t certificate_len ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int num_found = 0 , i ;  char buffer [ 64 ] = { '\\0' } , rdnSeqBuf [ 1024 ] = { '\\0' } ;  u_int rdn_len = 0 ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[offset:%u][certificate_len:%u]\\n"" , __FUNCTION__ , p_offset , certificate_len ) ; # endif for ( i = p_offset ; i < certificate_len ; i ++ ) { if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x03 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , ""CN"" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[%s][%s:%s]\\n"" , __FUNCTION__ , ( num_found == 0 ) ? ""Subject"" : ""Issuer"" , ""CommonName"" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x06 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , ""C"" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[%s][%s:%s]\\n"" , __FUNCTION__ , ( num_found == 0 ) ? ""Subject"" : ""Issuer"" , ""Country"" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x07 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , ""L"" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[%s][%s:%s]\\n"" , __FUNCTION__ , ( num_found == 0 ) ? ""Subject"" : ""Issuer"" , ""Locality"" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x08 ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , ""ST"" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[%s][%s:%s]\\n"" , __FUNCTION__ , ( num_found == 0 ) ? ""Subject"" : ""Issuer"" , ""StateorProvince"" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0a ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , ""O"" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[%s][%s:%s]\\n"" , __FUNCTION__ , ( num_found == 0 ) ? ""Subject"" : ""Issuer"" , ""OrganizationName"" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x04 ) && ( packet -> payload [ i + 2 ] == 0x0b ) ) { int rc = extractRDNSequence ( packet , i , buffer , sizeof ( buffer ) , rdnSeqBuf , & rdn_len , sizeof ( rdnSeqBuf ) , ""OU"" ) ; if ( rc == - 1 ) break ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()[%s][%s:%s]\\n"" , __FUNCTION__ , ( num_found == 0 ) ? ""Subject"" : ""Issuer"" , ""OrganizationUnit"" , buffer ) ; # endif } else if ( ( packet -> payload [ i ] == 0x30 ) && ( packet -> payload [ i + 1 ] == 0x1e ) && ( packet -> payload [ i + 2 ] == 0x17 ) ) { u_int8_t len = packet -> payload [ i + 3 ] ; u_int offset = i + 4 ; if ( num_found == 0 ) { num_found ++ ; # ifdef DEBUG_TLS printf ( ""[TLS]%s()IssuerDN[%s]\\n"" , __FUNCTION__ , rdnSeqBuf ) ; # endif if ( rdn_len ) flow -> protos . stun_ssl . ssl . issuerDN = ndpi_strdup ( rdnSeqBuf ) ; rdn_len = 0 ; } if ( ( offset + len ) < packet -> payload_packet_len ) { char utcDate [ 32 ] ; # ifdef DEBUG_TLS u_int j ; printf ( ""[CERTIFICATE]notBefore[len:%u]["" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( ""%c"" , packet -> payload [ i + 4 + j ] ) ; printf ( ""]\\n"" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ i + 4 ] , len ) ; utcDate [ len ] = '\\0' ; if ( strptime ( utcDate , ""%y%m%d%H%M%SZ"" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notBefore = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( ""[CERTIFICATE]notBefore%u[%s]\\n"" , flow -> protos . stun_ssl . ssl . notBefore , utcDate ) ; # endif } } offset += len ; if ( ( offset + 1 ) < packet -> payload_packet_len ) { len = packet -> payload [ offset + 1 ] ; offset += 2 ; if ( ( offset + len ) < packet -> payload_packet_len ) { u_int32_t time_sec = flow -> packet . current_time_ms / 1000 ; # ifdef DEBUG_TLS u_int j ; printf ( ""[CERTIFICATE]notAfter[len:%u]["" , len ) ; for ( j = 0 ; j < len ; j ++ ) printf ( ""%c"" , packet -> payload [ offset + j ] ) ; printf ( ""]\\n"" ) ; # endif if ( len < ( sizeof ( utcDate ) - 1 ) ) { struct tm utc ; utc . tm_isdst = - 1 ; strncpy ( utcDate , ( const char * ) & packet -> payload [ offset ] , len ) ; utcDate [ len ] = '\\0' ; if ( strptime ( utcDate , ""%y%m%d%H%M%SZ"" , & utc ) != NULL ) { flow -> protos . stun_ssl . ssl . notAfter = timegm ( & utc ) ; # ifdef DEBUG_TLS printf ( ""[CERTIFICATE]notAfter%u[%s]\\n"" , flow -> protos . stun_ssl . ssl . notAfter , utcDate ) ; # endif } } if ( ( time_sec < flow -> protos . stun_ssl . ssl . notBefore ) || ( time_sec > flow -> protos . stun_ssl . ssl . notAfter ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_EXPIRED ) ; } } } } else if ( ( packet -> payload [ i ] == 0x55 ) && ( packet -> payload [ i + 1 ] == 0x1d ) && ( packet -> payload [ i + 2 ] == 0x11 ) ) { u_int8_t matched_name = 0 ; # ifdef DEBUG_TLS printf ( ""*******[TLS]FoundsubjectAltName\\n"" ) ; # endif i += 3 ; i ++ ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; if ( i < packet -> payload_packet_len ) { i += 2 ; if ( i < packet -> payload_packet_len ) { i += ( packet -> payload [ i ] & 0x80 ) ? ( packet -> payload [ i ] & 0x7F ) : 0 ; i ++ ; while ( i < packet -> payload_packet_len ) { if ( packet -> payload [ i ] == 0x82 ) { if ( ( i < ( packet -> payload_packet_len - 1 ) ) && ( ( i + packet -> payload [ i + 1 ] + 2 ) < packet -> payload_packet_len ) ) { u_int8_t len = packet -> payload [ i + 1 ] ; char dNSName [ 256 ] ; i += 2 ; if ( len == 0 ) break ; strncpy ( dNSName , ( const char * ) & packet -> payload [ i ] , len ) ; dNSName [ len ] = '\\0' ; cleanupServerName ( dNSName , len ) ; # if DEBUG_TLS printf ( ""[TLS]dNSName%s[%s]\\n"" , dNSName , flow -> protos . stun_ssl . ssl . client_requested_server_name ) ; # endif if ( matched_name == 0 ) { if ( ( dNSName [ 0 ] == '*' ) && strstr ( flow -> protos . stun_ssl . ssl . client_requested_server_name , & dNSName [ 1 ] ) ) matched_name = 1 ; else if ( strcmp ( flow -> protos . stun_ssl . ssl . client_requested_server_name , dNSName ) == 0 ) matched_name = 1 ; } if ( flow -> protos . stun_ssl . ssl . server_names == NULL ) flow -> protos . stun_ssl . ssl . server_names = ndpi_strdup ( dNSName ) , flow -> protos . stun_ssl . ssl . server_names_len = strlen ( dNSName ) ; else { u_int16_t dNSName_len = strlen ( dNSName ) ; u_int16_t newstr_len = flow -> protos . stun_ssl . ssl . server_names_len + dNSName_len + 1 ; char * newstr = ( char * ) ndpi_realloc ( flow -> protos . stun_ssl . ssl . server_names , flow -> protos . stun_ssl . ssl . server_names_len + 1 , newstr_len + 1 ) ; if ( newstr ) { flow -> protos . stun_ssl . ssl . server_names = newstr ; flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len ] = ',' ; strncpy ( & flow -> protos . stun_ssl . ssl . server_names [ flow -> protos . stun_ssl . ssl . server_names_len + 1 ] , dNSName , dNSName_len + 1 ) ; flow -> protos . stun_ssl . ssl . server_names [ newstr_len ] = '\\0' ; flow -> protos . stun_ssl . ssl . server_names_len = newstr_len ; } } if ( ! flow -> l4 . tcp . tls . subprotocol_detected ) if ( ndpi_match_hostname_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_TLS , dNSName , len ) ) flow -> l4 . tcp . tls . subprotocol_detected = 1 ; i += len ; } else { # if DEBUG_TLS printf ( ""[TLS]Leftover%ubytes"" , packet -> payload_packet_len - i ) ; # endif break ; } } else { break ; } } if ( ! matched_name ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_CERTIFICATE_MISMATCH ) ; } } } } } if ( rdn_len ) flow -> protos . stun_ssl . ssl . subjectDN = ndpi_strdup ( rdnSeqBuf ) ; if ( flow -> protos . stun_ssl . ssl . subjectDN && flow -> protos . stun_ssl . ssl . issuerDN && ( ! strcmp ( flow -> protos . stun_ssl . ssl . subjectDN , flow -> protos . stun_ssl . ssl . issuerDN ) ) ) NDPI_SET_BIT ( flow -> risk , NDPI_TLS_SELFSIGNED_CERTIFICATE ) ; # if DEBUG_TLS printf ( ""[TLS]%s()SubjectDN[%s]\\n"" , __FUNCTION__ , rdnSeqBuf ) ; # endif }"," , rdnSeqBuf [ 2048  ] = {"
426,"CWE-20 SPL_METHOD ( Array , unserialize ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * buf ; int buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval * pmembers , * pflags = NULL ; HashTable * aht ; long flags ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } aht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; if ( aht -> nApplyCount > 0 ) { zend_error ( E_WARNING , ""ModificationofArrayObjectduringsortingisprohibited"" ) ; return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pflags ) ; if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) { goto outexcept ; } var_push_dtor ( & var_hash , & pflags ) ; -- p ; flags = Z_LVAL_P ( pflags ) ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' ) { if ( * p != 'a' && * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } intern -> ar_flags &= ~ SPL_ARRAY_CLONE_MASK ; intern -> ar_flags |= flags & SPL_ARRAY_CLONE_MASK ; zval_ptr_dtor ( & intern -> array ) ; ALLOC_INIT_ZVAL ( intern -> array ) ;  if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) {  goto outexcept ; } var_push_dtor ( & var_hash , & intern -> array ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pmembers ) ; if ( ! php_var_unserialize ( & pmembers , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { zval_ptr_dtor ( & pmembers ) ; goto outexcept ; } var_push_dtor ( & var_hash , & pmembers ) ; if ( ! intern -> std . properties ) { rebuild_object_properties ( & intern -> std ) ; } zend_hash_copy ( intern -> std . properties , Z_ARRVAL_P ( pmembers ) , ( copy_ctor_func_t ) zval_add_ref , ( void * ) NULL , sizeof ( zval * ) ) ; zval_ptr_dtor ( & pmembers ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , ""Erroratoffset%ldof%dbytes"" , ( long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }", var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ;  goto outexcept ;
427,"CWE-476 static int jp2_pclr_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_pclr_t * pclr = & box -> data . pclr ; int lutsize ; unsigned int i ; unsigned int j ; int_fast32_t x ; pclr -> lutdata = 0 ;  if ( jp2_getuint16 ( in , & pclr -> numlutents ) ||  jp2_getuint8 ( in , & pclr -> numchans ) ) { return - 1 ; } lutsize = pclr -> numlutents * pclr -> numchans ; if ( ! ( pclr -> lutdata = jas_alloc2 ( lutsize , sizeof ( int_fast32_t ) ) ) ) { return - 1 ; } if ( ! ( pclr -> bpc = jas_alloc2 ( pclr -> numchans , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < pclr -> numchans ; ++ i ) { if ( jp2_getuint8 ( in , & pclr -> bpc [ i ] ) ) { return - 1 ; } } for ( i = 0 ; i < pclr -> numlutents ; ++ i ) { for ( j = 0 ; j < pclr -> numchans ; ++ j ) { if ( jp2_getint ( in , ( pclr -> bpc [ j ] & 0x80 ) != 0 , ( pclr -> bpc [ j ] & 0x7f ) + 1 , & x ) ) { return - 1 ; } pclr -> lutdata [ i * pclr -> numchans + j ] = x ; } } return 0 ; }", = 0 ; pclr -> bpc = 0 ;
428,"CWE-119 static void accumulate_frame_motion_stats (  FIRSTPASS_STATS * this_frame ,   double * this_frame_mv_in_out ,  double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) {  double motion_pct ;  motion_pct = this_frame -> pcnt_motion ;  * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ;   * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ;   * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ;   if ( motion_pct > 0.05 ) {   const double this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) /   DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ;   const double this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) /   DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ;   * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs )   ? ( this_frame_mvr_ratio * motion_pct )  : this_frame -> mvr_abs * motion_pct ;  * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs )   ? ( this_frame_mvc_ratio * motion_pct )  : this_frame -> mvc_abs * motion_pct ; } }"," void accumulate_frame_motion_stats ( const FIRSTPASS_STATS * stats  , double *  , double * mv_in_out  , double *  mv_ratio_accumulator ) { const double pct = stats  -> pcnt_motion ;  pcnt_motion ; * mv_in_out = stats  -> mv_in_out_count *  -> mv_in_out_count * pct  ; * mv_in_out_accumulator  * mv_in_out_accumulator += * mv_in_out  ; * abs_mv_in_out_accumulator  += fabs ( * mv_in_out  ) ; if  ; if ( pct  > 0.05 )  { const double mvr_ratio  = fabs (  = fabs ( stats  -> mvr_abs )  ( fabs ( stats  -> MVr )  ; const double mvc_ratio  = fabs (  = fabs ( stats  -> mvc_abs )  ( fabs ( stats  -> MVc )  * mv_ratio_accumulator += pct * ( mvr_ratio < stats -> mvr_abs ? mvr_ratio : stats  -> mvr_abs )  -> mvr_abs )  ; * mv_ratio_accumulator  * mv_ratio_accumulator += pct * ( mvc_ratio < stats -> mvc_abs ? mvc_ratio : stats  -> mvc_abs )  -> mvc_abs )  ; } }"
429,"CWE-732 static void process_open ( u_int32_t id ) { u_int32_t pflags ; Attrib a ; char * name ; int r , handle , fd , flags , mode , status = SSH2_FX_FAILURE ; if ( ( r = sshbuf_get_cstring ( iqueue , & name , NULL ) ) != 0 || ( r = sshbuf_get_u32 ( iqueue , & pflags ) ) != 0 || ( r = decode_attrib ( iqueue , & a ) ) != 0 ) fatal ( ""%s:buffererror:%s"" , __func__ , ssh_err ( r ) ) ; debug3 ( ""request%u:openflags%d"" , id , pflags ) ; flags = flags_from_portable ( pflags ) ; mode = ( a . flags & SSH2_FILEXFER_ATTR_PERMISSIONS ) ? a . perm : 0666 ; logit ( ""open\\""%s\\""flags%smode0%o"" , name , string_from_portable ( pflags ) , mode ) ; if ( readonly &&  ( ( flags & O_ACCMODE ) == O_WRONLY ||   ( flags & O_ACCMODE ) == O_RDWR ) ) {  verbose ( ""Refusingopenrequestinread-onlymode"" ) ; status = SSH2_FX_PERMISSION_DENIED ; } else { fd = open ( name , flags , mode ) ; if ( fd < 0 ) { status = errno_to_portable ( errno ) ; } else { handle = handle_new ( HANDLE_FILE , name , fd , flags , NULL ) ; if ( handle < 0 ) { close ( fd ) ; } else { send_handle ( id , handle ) ; status = SSH2_FX_OK ; } } } if ( status != SSH2_FX_OK ) send_status ( id , status ) ; free ( name ) ; }", & O_ACCMODE ) != O_RDONLY  || ( flags  ( flags & ( O_CREAT | O_TRUNC ) ) != 0  ) ) {
430,"CWE-416 static void test_modules ( ) { assert_true_rule (  ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.one+1==tests.constants.two\\\n}"" ,  NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.foo==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.empty==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.empty()==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[1].i==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[0].i==1ortrue\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[0]==0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[1]==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[0]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[2]==\\""baz\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""foo\\""]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""bar\\""]==\\""bar\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2)==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2,3)==6\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0)==3.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0,3.0)==6.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.length(\\""dummy\\"")==5\\\n}"" , NULL ) ; assert_false_rule (  ""import\\""tests\\""\\\nruletest{condition:tests.struct_array[0].i==1\\\n}"" ,  NULL ) ; assert_false_rule (  ""import\\""tests\\""\\\nruletest{condition:tests.isum(1,1)==3\\\n}"" ,  NULL ) ; assert_false_rule (  ""import\\""tests\\""\\\nruletest{condition:tests.fsum(1.0,1.0)==3.0\\\n}"" ,  NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""foo\\"")==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""bar\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")==7\\\n}"" , NULL ) ; assert_error ( ""import\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }"," { assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.one+1==tests.constants.two\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.foo==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.empty==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.empty()==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[1].i==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[0].i==1ortrue\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[0]==0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[1]==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[0]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[2]==\\""baz\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""foo\\""]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""bar\\""]==\\""bar\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2)==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2,3)==6\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0)==3.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0,3.0)==6.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.foobar(1)==tests.foobar(1)\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.foobar(1)!=tests.foobar(2)\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.length(\\""dummy\\"")==5\\\n}""  , NULL )  ; assert_false_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.struct_array[0].i==1\\\n}""  , NULL )  ; assert_false_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.isum(1,1)==3\\\n}""  , NULL )  ; assert_false_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.fsum(1.0,1.0)==3.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""foo\\"")==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""bar\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")==7\\\n}""  , NULL )"
431,"CWE-295 static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ;  char common_name [ FIELD_SIZE + 1 ] ;   SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ;  X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unabletogetgatewaycertificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) == 1 ) cert_valid = 1 ; # else if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( ""Gatewaycertificatevalidationsucceeded.\\n"" ) ; ret = 0 ; goto free_cert ; } log_debug ( ""Gatewaycertificatevalidationfailed.\\n"" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( ""Couldnotcomputecertificatesha256digest.\\n"" ) ; goto free_cert ; } for ( i = 0 ; i < SHA256LEN ; i ++ ) sprintf ( & digest_str [ 2 * i ] , ""%02x"" , digest [ i ] ) ; digest_str [ SHA256STRLEN - 1 ] = '\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != NULL ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , SHA256STRLEN - 1 ) == 0 ) break ; if ( elem != NULL ) { log_debug ( ""Gatewaycertificatedigestfoundinwhitelist.\\n"" ) ; ret = 0 ; goto free_cert ; } subject = X509_NAME_oneline ( subj , NULL , 0 ) ; issuer = X509_NAME_oneline ( X509_get_issuer_name ( cert ) , NULL , 0 ) ; log_error ( ""Gatewaycertificatevalidationfailed,andthecertificatedigestinnotinthelocalwhitelist.Ifyoutrustit,rerunwith:\\n"" ) ; log_error ( ""--trusted-cert%s\\n"" , digest_str ) ; log_error ( ""oraddthislinetoyourconfigfile:\\n"" ) ; log_error ( ""trusted-cert=%s\\n"" , digest_str ) ; log_error ( ""Gatewaycertificate:\\n"" ) ; log_error ( ""subject:\\n"" ) ; for ( line = strtok ( subject , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""%s\\n"" , line ) ; log_error ( ""issuer:\\n"" ) ; for ( line = strtok ( issuer , ""/"" ) ; line != NULL ; line = strtok ( NULL , ""/"" ) ) log_error ( ""%s\\n"" , line ) ; log_error ( ""sha256digest:\\n"" ) ; log_error ( ""%s\\n"" , digest_str ) ; free_cert : X509_free ( cert ) ; return ret ; }"," * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unabletogetgatewaycertificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else  1 ] ;  if ( subj"
432,"CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; }  pipe -> curbuf = 0 ;  kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }"," ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;"
433,"CWE-119 static char * bittok2str_internal ( register const struct tok * lp , register const char * fmt , register u_int v , const char * sep ) {  static char buf [ 256 ] ;  int buflen = 0 ; register u_int rotbit ; register u_int tokval ; const char * sepstr = """" ; while ( lp != NULL && lp -> s != NULL ) { tokval = lp -> v ; rotbit = 1 ; while ( rotbit != 0 ) { if ( tokval == ( v & rotbit ) ) {  buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" ,   sepstr , lp -> s ) ;  sepstr = sep ; break ; } rotbit = rotbit << 1 ; } lp ++ ; }  if ( buflen == 0 )  ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? ""#%08x"" : fmt , v ) ; return ( buf ) ; }"," char buf [ 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size  ; register u_int  ) ) { if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp  , lp ->  lp -> s , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size  ; sepstr =  } if ( bufp == buf  ) ( void"
434,"CWE-119 static void init_config ( VP8_COMP * cpi , VP8_CONFIG * oxcf ) { VP8_COMMON * cm = & cpi -> common ; cpi -> oxcf = * oxcf ; cpi -> auto_gold = 1 ; cpi -> auto_adjust_gold_quantizer = 1 ; cm -> version = oxcf -> Version ; vp8_setup_version ( cm ) ;  cpi -> framerate = ( double ) ( oxcf -> timebase . den ) /   ( double ) ( oxcf -> timebase . num ) ;  if ( cpi -> framerate > 180 ) cpi -> framerate = 30 ; cpi -> ref_framerate = cpi -> framerate ;  vp8_change_config ( cpi , oxcf ) ;  cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ; cpi -> active_best_quality = cpi -> oxcf . best_allowed_q ; cpi -> avg_frame_qindex = cpi -> oxcf . worst_allowed_q ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> rolling_target_bits = cpi -> av_per_frame_bandwidth ; cpi -> rolling_actual_bits = cpi -> av_per_frame_bandwidth ; cpi -> long_rolling_target_bits = cpi -> av_per_frame_bandwidth ; cpi -> long_rolling_actual_bits = cpi -> av_per_frame_bandwidth ; cpi -> total_actual_bits = 0 ; cpi -> total_target_vs_actual = 0 ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { init_temporal_layer_context ( cpi , oxcf , i , prev_layer_framerate ) ; prev_layer_framerate = cpi -> output_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } # if VP8_TEMPORAL_ALT_REF { int i ; cpi -> fixed_divide [ 0 ] = 0 ; for ( i = 1 ; i < 512 ; i ++ ) cpi -> fixed_divide [ i ] = 0x80000 / i ; } # endif }", cm ) ; if ( oxcf -> timebase . num > 0 ) {  num ) ; } else { cpi -> framerate = 30 ; }  -> framerate ; cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ;
435,"CWE-264 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Badoffset%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:element%psize%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! arp_checkentry ( & e -> arp ) ) return - EINVAL ;  err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;  if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflowsmustbeunconditionaland"" ""usetheSTANDARDtargetwith"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }"," , e -> elems , e ->"
436,"CWE-119 static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ;  uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; }  if ( ! tmp )  return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }", uint8 * tmp  ; if (  0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
437,"CWE-119  static void rd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col ,  int * totalrate , int64_t * totaldist ,  BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; const AQ_MODE aq_mode = cpi -> oxcf . aq_mode ; int i , orig_rdmult ;  double rdmult_ratio ;  vp9_clear_system_state ( ) ; rdmult_ratio = 1.0 ; x -> use_lp32x32fdct = 1 ;  if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index != 0 ) { * totalrate = 0 ; * totaldist = 0 ; return ; } }  set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;  mbmi = & xd -> mi [ 0 ] -> mbmi ; mbmi -> sb_type = bsize ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 0 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 0 ] ; } ctx -> is_coded = 0 ;  x -> skip_recode = 0 ;  mbmi -> skip = 0 ;  x -> source_variance = get_sby_perpixel_variance ( cpi , x , bsize ) ;  if ( aq_mode == VARIANCE_AQ ) { const int energy = bsize <= BLOCK_16X16 ? x -> mb_energy : vp9_block_energy ( cpi , x , bsize ) ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { mbmi -> segment_id = vp9_vaq_segment_id ( energy ) ; } else { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;  mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;  }  rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ;  vp9_init_plane_quantizers ( cpi , x ) ; }  orig_rdmult = x -> rdmult ;  if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) activity_masking ( cpi , x ) ; if ( aq_mode == VARIANCE_AQ ) { vp9_clear_system_state ( ) ; x -> rdmult = ( int ) round ( x -> rdmult * rdmult_ratio ) ; } else if ( aq_mode == COMPLEXITY_AQ ) {  const int mi_offset = mi_row * cm -> mi_cols + mi_col ;  unsigned char complexity = cpi -> complexity_map [ mi_offset ] ; const int is_edge = ( mi_row <= 1 ) || ( mi_row >= ( cm -> mi_rows - 2 ) ) || ( mi_col <= 1 ) || ( mi_col >= ( cm -> mi_cols - 2 ) ) ; if ( ! is_edge && ( complexity > 128 ) )  x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ;  } else if ( aq_mode == CYCLIC_REFRESH_AQ ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;  if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) )  x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; } if ( frame_is_intra_only ( cm ) ) {  vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx ,  best_rd ) ; } else {  if ( bsize >= BLOCK_8X8 )   vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col ,   totalrate , totaldist , bsize , ctx , best_rd ) ;   else   vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate ,  totaldist , bsize , ctx , best_rd ) ; }  if ( aq_mode == VARIANCE_AQ ) {  x -> rdmult = orig_rdmult ;  if ( * totalrate != INT_MAX ) {  vp9_clear_system_state ( ) ; * totalrate = ( int ) round ( * totalrate * rdmult_ratio ) ; }  } else if ( aq_mode == COMPLEXITY_AQ || aq_mode == CYCLIC_REFRESH_AQ ) {  x -> rdmult = orig_rdmult ; } }"," * cpi , TileDataEnc * tile_data , MACROBLOCK * const x  , int mi_row  int mi_col , RD_COST * rd_cost  , BLOCK_SIZE bsize  -> common ; TileInfo * const tile_info = & tile_data -> tile_info  ; MACROBLOCKD *  , orig_rdmult ; vpx_clear_system_state ( )  ; x ->  = 1 ;  set_offsets ( cpi  ( cpi , tile_info , x  , mi_row ,  = 0 ; ctx -> skippable = 0 ; ctx -> pred_pixel_ready = 0 ;  = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {  -> source_variance = vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ; } else { x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; } # else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; # endif orig_rdmult = x -> rdmult  ; if (  -> segment_id = get_segment_id  ( cm ,  ) ; }  x -> rdmult  x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id  ) ; }  COMPLEXITY_AQ ) {  x -> rdmult  x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id  ) ; }  ; if ( cyclic_refresh_segment_id_boosted ( get_segment_id  ( cm ,  mi_col ) ) )  , x , rd_cost , bsize , ctx ,  best_rd ) ;  >= BLOCK_8X8 ) { if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) vp9_rd_pick_inter_mode_sb_seg_skip ( cpi , tile_data , x , rd_cost , bsize , ctx , best_rd ) ; else  ( cpi , tile_data , x  , mi_row ,  , mi_col , rd_cost  , bsize ,  best_rd ) ; } else {  vp9_rd_pick_inter_mode_sub8x8 ( cpi  ( cpi , tile_data , x  , mi_row ,  , mi_col , rd_cost  , bsize ,  ) ; } } if ( ( rd_cost -> rate  != INT_MAX )  != INT_MAX ) &&  ( aq_mode ==  aq_mode == COMPLEXITY_AQ ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) { vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ; } x -> rdmult = orig_rdmult ; if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist ;  }  "
438,CWE-369 tdata_t _TIFFmalloc ( tsize_t s )  {  return ( malloc ( ( size_t ) s ) ) ; }, s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
439,"CWE-119 static enum led_brightness k90_backlight_get ( struct led_classdev * led_cdev ) { int ret ; struct k90_led * led = container_of ( led_cdev , struct k90_led , cdev ) ; struct device * dev = led -> cdev . dev -> parent ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int brightness ;  char data [ 8 ] ;  ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""FailedtogetK90initialstate(error%d).\\n"" , ret ) ;  return - EIO ;  } brightness = data [ 4 ] ; if ( brightness < 0 || brightness > 3 ) { dev_warn ( dev , ""Readinvalidbacklightbrightness:%02hhx.\\n"" , data [ 4 ] ) ;  return - EIO ;   }  return brightness ; }"," brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM  ; ret =  ret ) ; ret = - EIO ; goto out  ; } brightness  ] ) ; ret =  - EIO ;  - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret  ; } "
440,"CWE-369 static void gaussian_blur_surface ( cairo_surface_t * in , cairo_surface_t * out , gdouble sx , gdouble sy ) {  gboolean use_box_blur ;  gint width , height ; cairo_format_t in_format , out_format ; gint in_stride ; gint out_stride ; guchar * in_data , * out_data ; gint bpp ; gboolean out_has_data ; cairo_surface_flush ( in ) ; width = cairo_image_surface_get_width ( in ) ; height = cairo_image_surface_get_height ( in ) ; g_assert ( width == cairo_image_surface_get_width ( out ) && height == cairo_image_surface_get_height ( out ) ) ; in_format = cairo_image_surface_get_format ( in ) ; out_format = cairo_image_surface_get_format ( out ) ; g_assert ( in_format == out_format ) ; g_assert ( in_format == CAIRO_FORMAT_ARGB32 || in_format == CAIRO_FORMAT_A8 ) ; if ( in_format == CAIRO_FORMAT_ARGB32 ) bpp = 4 ; else if ( in_format == CAIRO_FORMAT_A8 ) bpp = 1 ; else { g_assert_not_reached ( ) ; return ; } in_stride = cairo_image_surface_get_stride ( in ) ; out_stride = cairo_image_surface_get_stride ( out ) ; in_data = cairo_image_surface_get_data ( in ) ; out_data = cairo_image_surface_get_data ( out ) ; if ( sx < 0.0 ) sx = 0.0 ; if ( sy < 0.0 )  sy = 0.0 ;  if ( sx < 10.0 && sy < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ; if ( ( sx == 0.0 && sy == 0.0 ) || sx > 1000 || sy > 1000 ) { cairo_t * cr ; cr = cairo_create ( out ) ; cairo_set_source_surface ( cr , in , 0 , 0 ) ; cairo_paint ( cr ) ; cairo_destroy ( cr ) ; return ; } if ( sx != 0.0 ) { gint box_width ; gdouble * gaussian_matrix ; gint gaussian_matrix_len ; int y ; guchar * row_buffer = NULL ; guchar * row1 , * row2 ;  if ( use_box_blur ) {  box_width = compute_box_blur_width ( sx ) ; row_buffer = g_new0 ( guchar , width * bpp * 2 ) ; row1 = row_buffer ; row2 = row_buffer + width * bpp ; } else make_gaussian_convolution_matrix ( sx , & gaussian_matrix , & gaussian_matrix_len ) ; for ( y = 0 ; y < height ; y ++ ) { guchar * in_row , * out_row ; in_row = in_data + in_stride * y ; out_row = out_data + out_stride * y ; if ( use_box_blur ) { if ( box_width % 2 != 0 ) { box_blur_line ( box_width , 0 , in_row , row1 , width , bpp ) ; box_blur_line ( box_width , 0 , row1 , row2 , width , bpp ) ; box_blur_line ( box_width , 0 , row2 , out_row , width , bpp ) ; } else { box_blur_line ( box_width , - 1 , in_row , row1 , width , bpp ) ; box_blur_line ( box_width , 1 , row1 , row2 , width , bpp ) ; box_blur_line ( box_width + 1 , 0 , row2 , out_row , width , bpp ) ; } } else gaussian_blur_line ( gaussian_matrix , gaussian_matrix_len , in_row , out_row , width , bpp ) ; } if ( ! use_box_blur ) g_free ( gaussian_matrix ) ; g_free ( row_buffer ) ; out_has_data = TRUE ; } else out_has_data = FALSE ; if ( sy != 0.0 ) { gint box_height ; gdouble * gaussian_matrix = NULL ; gint gaussian_matrix_len ; guchar * col_buffer ; guchar * col1 , * col2 ; int x ;  col_buffer = g_new0 ( guchar , height * bpp * 2 ) ;  col1 = col_buffer ; col2 = col_buffer + height * bpp ; if ( use_box_blur ) { box_height = compute_box_blur_width ( sy ) ; } else make_gaussian_convolution_matrix ( sy , & gaussian_matrix , & gaussian_matrix_len ) ; for ( x = 0 ; x < width ; x ++ ) { if ( out_has_data ) get_column ( col1 , out_data , out_stride , bpp , height , x ) ; else get_column ( col1 , in_data , in_stride , bpp , height , x ) ; if ( use_box_blur ) { if ( box_height % 2 != 0 ) { box_blur_line ( box_height , 0 , col1 , col2 , height , bpp ) ; box_blur_line ( box_height , 0 , col2 , col1 , height , bpp ) ; box_blur_line ( box_height , 0 , col1 , col2 , height , bpp ) ; } else { box_blur_line ( box_height , - 1 , col1 , col2 , height , bpp ) ; box_blur_line ( box_height , 1 , col2 , col1 , height , bpp ) ; box_blur_line ( box_height + 1 , 0 , col1 , col2 , height , bpp ) ; } } else gaussian_blur_line ( gaussian_matrix , gaussian_matrix_len , col1 , col2 , height , bpp ) ; put_column ( col2 , out_data , out_stride , bpp , height , x ) ; } g_free ( gaussian_matrix ) ; g_free ( col_buffer ) ; } cairo_surface_mark_dirty ( out ) ; }"," sy ) {  gint width ,  sy = 0.0  ; if (  * row2 ; gboolean use_box_blur ; if ( sx < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ;  int x ; gboolean use_box_blur ; if ( sy < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ;"
441,"CWE-119 void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ;  data -> l_head = NULL ;  data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }"," xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) )  ; parser ."
442,"CWE-476 static int tls_construct_cke_ecdhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_EC unsigned char * encodedPoint = NULL ; int encoded_pt_len = 0 ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ;  if ( ssl_derive ( s , ckey , skey ) == 0 ) {  SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ; goto err ; } encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint ( ckey , & encodedPoint ) ; if ( encoded_pt_len == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EC_LIB ) ; goto err ; } EVP_PKEY_free ( ckey ) ; ckey = NULL ; * len = encoded_pt_len ; * * p = * len ; * p += 1 ; memcpy ( * p , encodedPoint , * len ) ; * len += 1 ; OPENSSL_free ( encodedPoint ) ; return 1 ; err : EVP_PKEY_free ( ckey ) ; return 0 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }"," ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ("
443,"CWE-000 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ;  ipv6_select_ident ( & fhdr ) ;  skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }"," unsigned int flags , struct rt6_info * rt  ( & fhdr , rt"
444,"CWE-416  static int ion_handle_put ( struct ion_handle * handle )  { struct ion_client * client = handle -> client ; int ret ; mutex_lock ( & client -> lock ) ;  ret = kref_put ( & handle -> ref , ion_handle_destroy ) ;  mutex_unlock ( & client -> lock ) ; return ret ; }",     int ion_handle_put (  ; ret = ion_handle_put_nolock ( handle  ) ; mutex_unlock
445,"CWE-200 IHEVCD_ERROR_T ihevcd_parse_slice_data ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 end_of_slice_flag = 0 ; sps_t * ps_sps ; pps_t * ps_pps ; slice_header_t * ps_slice_hdr ; WORD32 end_of_pic ; tile_t * ps_tile , * ps_tile_prev ; WORD32 i ; WORD32 ctb_addr ; WORD32 tile_idx ; WORD32 cabac_init_idc ; WORD32 ctb_size ; WORD32 num_ctb_in_row ; WORD32 num_min4x4_in_ctb ; WORD32 slice_qp ; WORD32 slice_start_ctb_idx ; WORD32 tile_start_ctb_idx ; ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base ; ps_pps = ps_codec -> s_parse . ps_pps_base ; ps_sps = ps_codec -> s_parse . ps_sps_base ; ps_slice_hdr += ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_pps += ps_slice_hdr -> i1_pps_id ; ps_sps += ps_pps -> i1_sps_id ; if ( 0 != ps_codec -> s_parse . i4_cur_slice_idx ) { if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_codec -> s_parse . i4_cur_independent_slice_idx ++ ; if ( MAX_SLICE_HDR_CNT == ps_codec -> s_parse . i4_cur_independent_slice_idx ) ps_codec -> s_parse . i4_cur_independent_slice_idx = 0 ; } } ctb_size = 1 << ps_sps -> i1_log2_ctb_size ; num_min4x4_in_ctb = ( ctb_size / 4 ) * ( ctb_size / 4 ) ; num_ctb_in_row = ps_sps -> i2_pic_wd_in_ctb ; if ( 0 == ps_codec -> i4_slice_error ) { ps_codec -> s_parse . i4_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_codec -> s_parse . i4_ctb_y = ps_slice_hdr -> i2_ctb_y ; } ps_codec -> s_parse . ps_pps = ps_pps ; ps_codec -> s_parse . ps_sps = ps_sps ; ps_codec -> s_parse . ps_slice_hdr = ps_slice_hdr ; ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , ps_codec -> s_parse . i4_ctb_y , & ps_codec -> s_parse . i4_ctb_tile_x , & ps_codec -> s_parse . i4_ctb_tile_y , & tile_idx ) ; ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; ps_tile = ps_codec -> s_parse . ps_tile ; if ( tile_idx ) ps_tile_prev = ps_tile - 1 ; else ps_tile_prev = ps_tile ; if ( 0 == ps_codec -> i4_slice_error ) { if ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) { if ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { ps_codec -> s_parse . i4_ctb_slice_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_y = 0 ; } } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_codec -> s_parse . i4_ctb_slice_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_y = 0 ; } } if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_x ) ) { ret = ihevcd_parse_pic_init ( ps_codec ) ; RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; ps_codec -> s_parse . pu4_pic_tu_idx [ 0 ] = 0 ; ps_codec -> s_parse . pu4_pic_pu_idx [ 0 ] = 0 ; ps_codec -> s_parse . i4_cur_independent_slice_idx = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_tile_y = 0 ; } { mv_buf_t * ps_mv_buf = ps_codec -> s_parse . ps_cur_mv_buf ; if ( ps_slice_hdr -> i1_num_ref_idx_l1_active != 0 ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) { ps_mv_buf -> l1_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> i4_abs_poc ; ps_mv_buf -> u1_l1_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; } } if ( ps_slice_hdr -> i1_num_ref_idx_l0_active != 0 ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) { ps_mv_buf -> l0_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> i4_abs_poc ; ps_mv_buf -> u1_l0_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; } } } if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) { WORD32 cur_poc , ref_list_poc , flag = 1 ; cur_poc = ps_slice_hdr -> i4_abs_pic_order_cnt ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) { ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_mv_buf ) -> i4_abs_poc ; if ( ref_list_poc > cur_poc ) { flag = 0 ; break ; } } if ( flag && ( ps_slice_hdr -> i1_slice_type == BSLICE ) ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) { ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_mv_buf ) -> i4_abs_poc ; if ( ref_list_poc > cur_poc ) { flag = 0 ; break ; } } } ps_slice_hdr -> i1_low_delay_flag = flag ; } if ( ps_slice_hdr -> i1_slice_type == ISLICE ) { cabac_init_idc = 0 ; } else if ( ps_slice_hdr -> i1_slice_type == PSLICE ) { cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 2 : 1 ; } else { cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 1 : 2 ; } slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; if ( ( 0 == ps_slice_hdr -> i1_dependent_slice_flag ) || ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) ) ) { ps_codec -> s_parse . u4_qp = slice_qp ; } if ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ! ( ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) && ( ps_codec -> s_parse . i4_ctb_tile_y == 0 ) ) ) ) { if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) { ihevcd_cabac_reset ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; } } else if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } do { { WORD32 cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( 1 == ps_codec -> i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB ) { ps_codec -> s_parse . ps_tu = ps_codec -> s_parse . ps_pic_tu ; ps_codec -> s_parse . i4_pic_tu_idx = 0 ; } } end_of_pic = 0 ; ps_codec -> s_parse . i4_ctb_num_pcm_blks = 0 ; if ( ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) && ( ! ( ( ps_tile -> u1_pos_x == 0 ) && ( ps_tile -> u1_pos_y == 0 ) ) ) && ( ! ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) ) ) { slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; ps_codec -> s_parse . u4_qp = slice_qp ; ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , ps_codec -> s_parse . i4_ctb_y , & ps_codec -> s_parse . i4_ctb_tile_x , & ps_codec -> s_parse . i4_ctb_tile_y , & tile_idx ) ; ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; ps_tile_prev = ps_tile - 1 ; tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( slice_start_ctb_idx < tile_start_ctb_idx ) { ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y - ps_slice_hdr -> i2_ctb_y ; if ( ! ( ( ( ps_slice_hdr -> i2_ctb_x + ps_tile_prev -> u2_wd ) % ps_sps -> i2_pic_wd_in_ctb ) == ps_tile -> u1_pos_x ) ) { if ( ps_slice_hdr -> i2_ctb_y <= ps_tile -> u1_pos_y ) { if ( ps_slice_hdr -> i2_ctb_x > ps_tile -> u1_pos_x ) { ps_codec -> s_parse . i4_ctb_slice_y -= 1 ; } } } } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } } if ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) { if ( 1 < ps_codec -> i4_num_cores ) { proc_job_t s_job ; IHEVCD_ERROR_T ret ; s_job . i4_cmd = CMD_PROCESS ; s_job . i2_ctb_cnt = ( WORD16 ) ps_tile -> u2_wd ; s_job . i2_ctb_x = ( WORD16 ) ps_codec -> s_parse . i4_ctb_x ; s_job . i2_ctb_y = ( WORD16 ) ps_codec -> s_parse . i4_ctb_y ; s_job . i2_slice_idx = ( WORD16 ) ps_codec -> s_parse . i4_cur_slice_idx ; s_job . i4_tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; ret = ihevcd_jobq_queue ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) return ret ; } else { process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; WORD32 tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; ps_proc -> i4_ctb_cnt = ps_tile -> u2_wd ; ps_proc -> i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; ps_proc -> i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; ps_proc -> i4_cur_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; ihevcd_init_proc_ctxt ( ps_proc , tu_coeff_data_ofst ) ; } } if ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) { if ( 0 == ps_codec -> s_parse . i4_ctb_x ) { WORD32 default_ctxt = 0 ; if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( ! ps_slice_hdr -> i1_dependent_slice_flag ) ) default_ctxt = 1 ; if ( 1 == ps_sps -> i2_pic_wd_in_ctb ) default_ctxt = 1 ; ps_codec -> s_parse . u4_qp = slice_qp ; if ( default_ctxt ) { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } else { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } } } if ( 0 == ps_codec -> i4_slice_error ) { if ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag ) ihevcd_parse_sao ( ps_codec ) ; } else { sao_t * ps_sao = ps_codec -> s_parse . ps_pic_sao + ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; ps_sao -> b3_y_type_idx = 0 ; ps_sao -> b3_cb_type_idx = 0 ; ps_sao -> b3_cr_type_idx = 0 ; } { WORD32 ctb_indx ; ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_sps -> i2_pic_wd_in_ctb * ps_codec -> s_parse . i4_ctb_y ; ps_codec -> s_parse . s_bs_ctxt . pu1_pic_qp_const_in_ctb [ ctb_indx >> 3 ] |= ( 1 << ( ctb_indx & 7 ) ) ; { UWORD16 * pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; pu1_slice_idx [ ctb_indx ] = ps_codec -> s_parse . i4_cur_independent_slice_idx ; } } if ( 0 == ps_codec -> i4_slice_error ) { tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; WORD32 i4_tu_cnt = ps_codec -> s_parse . s_cu . i4_tu_cnt ; WORD32 i4_pic_tu_idx = ps_codec -> s_parse . i4_pic_tu_idx ; pu_t * ps_pu = ps_codec -> s_parse . ps_pu ; WORD32 i4_pic_pu_idx = ps_codec -> s_parse . i4_pic_pu_idx ; UWORD8 * pu1_tu_coeff_data = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data ; ret = ihevcd_parse_coding_quadtree ( ps_codec , ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) , ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) , ps_sps -> i1_log2_ctb_size , 0 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) {  WORD32 pu_skip_wd , pu_skip_ht ;  WORD32 rows_remaining , cols_remaining ; WORD32 tu_coeff_data_reset_size ; rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; pu_skip_ht = MIN ( ctb_size , rows_remaining ) ; cols_remaining = ps_sps -> i2_pic_width_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) ; pu_skip_wd = MIN ( ctb_size , cols_remaining ) ; ps_codec -> s_parse . ps_tu = ps_tu ; ps_codec -> s_parse . s_cu . i4_tu_cnt = i4_tu_cnt ; ps_codec -> s_parse . i4_pic_tu_idx = i4_pic_tu_idx ; ps_codec -> s_parse . ps_pu = ps_pu ;  ps_codec -> s_parse . i4_pic_pu_idx = i4_pic_pu_idx ;  ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = 0 ; ps_tu -> b4_pos_y = 0 ; ps_tu -> b1_transquant_bypass = 0 ; ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ; ps_tu -> b1_first_tu_in_cu = 1 ; tu_coeff_data_reset_size = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - pu1_tu_coeff_data ; memset ( pu1_tu_coeff_data , 0 , tu_coeff_data_reset_size ) ; ps_codec -> s_parse . pv_tu_coeff_data = ( void * ) pu1_tu_coeff_data ;  ps_codec -> s_parse . ps_tu ++ ;  ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ; ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ; ps_pu -> b2_part_idx = 0 ; ps_pu -> b4_pos_x = 0 ; ps_pu -> b4_pos_y = 0 ; ps_pu -> b4_wd = ( pu_skip_wd >> 2 ) - 1 ; ps_pu -> b4_ht = ( pu_skip_ht >> 2 ) - 1 ; ps_pu -> b1_intra_flag = 0 ; ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ; ps_pu -> b1_merge_flag = 1 ; ps_pu -> b3_merge_idx = 0 ; ps_codec -> s_parse . ps_pu ++ ; ps_codec -> s_parse . i4_pic_pu_idx ++ ; ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } else {  tu_t * ps_tu = ps_codec -> s_parse . ps_tu ;  pu_t * ps_pu = ps_codec -> s_parse . ps_pu ; WORD32 pu_skip_wd , pu_skip_ht ; WORD32 rows_remaining , cols_remaining ; rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; pu_skip_ht = MIN ( ctb_size , rows_remaining ) ; cols_remaining = ps_sps -> i2_pic_width_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) ; pu_skip_wd = MIN ( ctb_size , cols_remaining ) ; ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = 0 ; ps_tu -> b4_pos_y = 0 ; ps_tu -> b1_transquant_bypass = 0 ; ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ; ps_tu -> b1_first_tu_in_cu = 1 ; ps_codec -> s_parse . ps_tu ++ ; ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ; ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ; ps_pu -> b2_part_idx = 0 ; ps_pu -> b4_pos_x = 0 ; ps_pu -> b4_pos_y = 0 ; ps_pu -> b4_wd = ( pu_skip_wd >> 2 ) - 1 ; ps_pu -> b4_ht = ( pu_skip_ht >> 2 ) - 1 ; ps_pu -> b1_intra_flag = 0 ; ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ; ps_pu -> b1_merge_flag = 1 ; ps_pu -> b3_merge_idx = 0 ; ps_codec -> s_parse . ps_pu ++ ; ps_codec -> s_parse . i4_pic_pu_idx ++ ; } if ( 0 == ps_codec -> i4_slice_error ) end_of_slice_flag = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; AEV_TRACE ( ""end_of_slice_flag"" , end_of_slice_flag , ps_codec -> s_parse . s_cabac . u4_range ) ; if ( ps_pps -> i1_tiles_enabled_flag || ps_pps -> i1_entropy_coding_sync_enabled_flag ) { WORD32 end_of_tile = 0 ; WORD32 end_of_tile_row = 0 ; if ( ps_pps -> i1_entropy_coding_sync_enabled_flag || ps_pps -> i1_tiles_enabled_flag ) { if ( 1 == ps_codec -> s_parse . i4_ctb_x ) { WORD32 size = sizeof ( ps_codec -> s_parse . s_cabac . au1_ctxt_models ) ; memcpy ( & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync , & ps_codec -> s_parse . s_cabac . au1_ctxt_models , size ) ; } } if ( ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) == ( ps_tile -> u2_wd ) ) { end_of_tile_row = 1 ; if ( ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) == ps_tile -> u2_ht ) end_of_tile = 1 ; } if ( ( 0 == end_of_slice_flag ) && ( ( ps_pps -> i1_tiles_enabled_flag && end_of_tile ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && end_of_tile_row ) ) ) { WORD32 end_of_sub_stream_one_bit ; end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; AEV_TRACE ( ""end_of_sub_stream_one_bit"" , end_of_sub_stream_one_bit , ps_codec -> s_parse . s_cabac . u4_range ) ; if ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst % 8 ) ihevcd_bits_flush_to_byte_boundary ( & ps_codec -> s_parse . s_bitstrm ) ; UNUSED ( end_of_sub_stream_one_bit ) ; } } { WORD32 ctb_indx ; ctb_addr = ps_codec -> s_parse . i4_ctb_y * num_ctb_in_row + ps_codec -> s_parse . i4_ctb_x ; ctb_indx = ++ ctb_addr ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ctb_addr ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . pu4_pic_pu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_pu_idx ; ps_codec -> s_parse . i4_next_pu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu1_pu_map += num_min4x4_in_ctb ; if ( 1 == ps_codec -> i4_num_cores ) { ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; } else { ctb_indx = ctb_addr ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ctb_addr ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; } ps_codec -> s_parse . pu1_tu_map += num_min4x4_in_ctb ; } if ( ps_codec -> i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD ) { WORD8 u1_top_ctb_avail = 1 ; WORD8 u1_left_ctb_avail = 1 ; WORD8 u1_top_lt_ctb_avail = 1 ; WORD8 u1_top_rt_ctb_avail = 1 ; WORD16 i2_wd_in_ctb ; tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) { i2_wd_in_ctb = ps_sps -> i2_pic_wd_in_ctb ; } else { i2_wd_in_ctb = ps_tile -> u2_wd ; } if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; u1_top_rt_ctb_avail = 0 ; } if ( ( 0 == ps_codec -> s_parse . i4_ctb_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) ) { u1_left_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) { u1_top_rt_ctb_avail = 0 ; } } } else if ( ps_codec -> s_parse . i4_ctb_x > 0 ) { if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; if ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) { u1_left_ctb_avail = 0 ; } if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) { u1_top_rt_ctb_avail = 0 ; } } else if ( ( 1 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) ) { u1_top_lt_ctb_avail = 0 ; } } if ( ( ( ps_sps -> i2_pic_wd_in_ctb - 1 ) == ps_codec -> s_parse . i4_ctb_x ) || ( ( ps_tile -> u2_wd - 1 ) == ps_codec -> s_parse . i4_ctb_tile_x ) ) { u1_top_rt_ctb_avail = 0 ; } if ( PSLICE == ps_slice_hdr -> i1_slice_type || BSLICE == ps_slice_hdr -> i1_slice_type ) { mv_ctxt_t s_mv_ctxt ; process_ctxt_t * ps_proc ; UWORD32 * pu4_ctb_top_pu_idx ; UWORD32 * pu4_ctb_left_pu_idx ; UWORD32 * pu4_ctb_top_left_pu_idx ; WORD32 i4_ctb_pu_cnt ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 cur_pu_idx ; ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; i4_ctb_pu_cnt = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; pu4_ctb_top_pu_idx = ps_proc -> pu4_pic_pu_idx_top + ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) ; pu4_ctb_left_pu_idx = ps_proc -> pu4_pic_pu_idx_left ; pu4_ctb_top_left_pu_idx = & ps_proc -> u4_ctb_top_left_pu_idx ; { s_mv_ctxt . ps_pps = ps_pps ; s_mv_ctxt . ps_sps = ps_sps ; s_mv_ctxt . ps_slice_hdr = ps_slice_hdr ; s_mv_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; s_mv_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; s_mv_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; s_mv_ctxt . ps_pic_pu = ps_codec -> s_parse . ps_pic_pu ; s_mv_ctxt . ps_tile = ps_tile ; s_mv_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; s_mv_ctxt . pu4_pic_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx ; s_mv_ctxt . pu1_pic_pu_map = ps_codec -> s_parse . pu1_pic_pu_map ; s_mv_ctxt . i4_ctb_pu_cnt = i4_ctb_pu_cnt ; s_mv_ctxt . i4_ctb_start_pu_idx = cur_pu_idx ; s_mv_ctxt . u1_top_ctb_avail = u1_top_ctb_avail ; s_mv_ctxt . u1_top_rt_ctb_avail = u1_top_rt_ctb_avail ; s_mv_ctxt . u1_top_lt_ctb_avail = u1_top_lt_ctb_avail ; s_mv_ctxt . u1_left_ctb_avail = u1_left_ctb_avail ; } ihevcd_get_mv_ctb ( & s_mv_ctxt , pu4_ctb_top_pu_idx , pu4_ctb_left_pu_idx , pu4_ctb_top_left_pu_idx ) ; } else { WORD32 num_minpu_in_ctb = ( ctb_size / MIN_PU_SIZE ) * ( ctb_size / MIN_PU_SIZE ) ; UWORD8 * pu1_pic_pu_map_ctb = ps_codec -> s_parse . pu1_pic_pu_map + ( ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ) * num_minpu_in_ctb ; process_ctxt_t * ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; WORD32 row , col ; WORD32 pu_cnt ; WORD32 num_pu_per_ctb ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 ctb_start_pu_idx ; UWORD32 * pu4_nbr_pu_idx = ps_proc -> pu4_pic_pu_idx_map ; WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2 ; pu_t * ps_pu ; for ( row = 0 ; row < ctb_size / MIN_PU_SIZE ; row ++ ) { for ( col = 0 ; col < ctb_size / MIN_PU_SIZE ; col ++ ) { pu1_pic_pu_map_ctb [ row * ctb_size / MIN_PU_SIZE + col ] = 0 ; } } cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; num_pu_per_ctb = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; ctb_start_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; ps_pu = & ps_codec -> s_parse . ps_pic_pu [ ctb_start_pu_idx ] ; for ( pu_cnt = 0 ; pu_cnt < num_pu_per_ctb ; pu_cnt ++ , ps_pu ++ ) { UWORD32 cur_pu_idx ; WORD32 pu_ht = ( ps_pu -> b4_ht + 1 ) << 2 ; WORD32 pu_wd = ( ps_pu -> b4_wd + 1 ) << 2 ; cur_pu_idx = ctb_start_pu_idx + pu_cnt ; for ( row = 0 ; row < pu_ht / MIN_PU_SIZE ; row ++ ) for ( col = 0 ; col < pu_wd / MIN_PU_SIZE ; col ++ ) pu4_nbr_pu_idx [ ( 1 + ps_pu -> b4_pos_x + col ) + ( 1 + ps_pu -> b4_pos_y + row ) * nbr_pu_idx_strd ] = cur_pu_idx ; } { WORD32 rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; WORD32 ctb_size_left = MIN ( ctb_size , rows_remaining ) ; ps_proc -> u4_ctb_top_left_pu_idx = ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + ctb_size / MIN_PU_SIZE - 1 ] ; for ( i = 0 ; i < ctb_size / MIN_PU_SIZE ; i ++ ) { ps_proc -> pu4_pic_pu_idx_left [ i ] = pu4_nbr_pu_idx [ ( ctb_size / MIN_PU_SIZE ) + ( i + 1 ) * nbr_pu_idx_strd ] ; ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + i ] = pu4_nbr_pu_idx [ ( ctb_size_left / MIN_PU_SIZE ) * nbr_pu_idx_strd + i + 1 ] ; } } } if ( 0 == ps_codec -> i4_disable_deblk_pic ) { if ( ( 0 == ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) && ( 0 == ps_codec -> i4_slice_error ) ) { WORD32 i4_ctb_tu_cnt ; WORD32 cur_ctb_idx , next_ctb_idx ; WORD32 cur_pu_idx ; WORD32 cur_tu_idx ; process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; next_ctb_idx = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; if ( 1 == ps_codec -> i4_num_cores ) { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; } else { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; } ps_codec -> s_parse . s_bs_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_bs_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_bs_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tu_cnt = i4_ctb_tu_cnt ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_x = ps_codec -> s_parse . i4_ctb_tile_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_y = ps_codec -> s_parse . i4_ctb_tile_y ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_x = ps_codec -> s_parse . i4_ctb_slice_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_y = ps_codec -> s_parse . i4_ctb_slice_y ; ps_codec -> s_parse . s_bs_ctxt . ps_tu = & ps_codec -> s_parse . ps_pic_tu [ cur_tu_idx ] ; ps_codec -> s_parse . s_bs_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; ps_codec -> s_parse . s_bs_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; ps_codec -> s_parse . s_bs_ctxt . i4_next_pu_ctb_cnt = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; ps_codec -> s_parse . s_bs_ctxt . i4_next_tu_ctb_cnt = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; ps_codec -> s_parse . s_bs_ctxt . pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; ps_codec -> s_parse . s_bs_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ps_codec -> s_parse . s_bs_ctxt . ps_tile = ps_codec -> s_parse . ps_tile ; if ( ISLICE == ps_slice_hdr -> i1_slice_type ) { ihevcd_ctb_boundary_strength_islice ( & ps_codec -> s_parse . s_bs_ctxt ) ; } else { ihevcd_ctb_boundary_strength_pbslice ( & ps_codec -> s_parse . s_bs_ctxt ) ; } } else { WORD32 bs_strd = ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) ; UWORD32 * pu4_vert_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_vert_bs + ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; UWORD32 * pu4_horz_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_horz_bs + ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; memset ( pu4_vert_bs , 0 , ( ctb_size / 8 + 1 ) * ( ctb_size / 4 ) / 8 * 2 ) ; memset ( pu4_horz_bs , 0 , ( ctb_size / 8 ) * ( ctb_size / 4 ) / 8 * 2 ) ; } } } { sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; UWORD8 * pu1_buf ; WORD32 idx ; idx = ( ps_codec -> s_parse . i4_ctb_x ) ; idx += ( ( ps_codec -> s_parse . i4_ctb_y ) * ps_sps -> i2_pic_wd_in_ctb ) ; pu1_buf = ( ps_codec -> pu1_parse_map + idx ) ; * pu1_buf = 1 ; } ps_codec -> s_parse . i4_ctb_tile_x ++ ; ps_codec -> s_parse . i4_ctb_x ++ ; ps_codec -> s_parse . i4_ctb_slice_x ++ ; if ( ps_pps -> i1_tiles_enabled_flag ) { tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) { if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u1_pos_x + ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; } } else if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = 0 ; } } else { if ( ps_codec -> s_parse . i4_ctb_slice_x == ps_tile -> u2_wd ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = 0 ; } } if ( ps_codec -> s_parse . i4_ctb_tile_x == ( ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_tile_y ++ ; ps_codec -> s_parse . i4_ctb_y ++ ; if ( ps_codec -> s_parse . i4_ctb_tile_y == ( ps_tile -> u2_ht ) ) { ps_codec -> s_parse . i4_ctb_tile_y = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . ps_tile ++ ; if ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) && ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) ) { end_of_pic = 1 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = ps_sps -> i2_pic_ht_in_ctb ; } else { ps_tile = ps_codec -> s_parse . ps_tile ; ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_y = ps_tile -> u1_pos_y ; ps_codec -> s_parse . i4_ctb_tile_y = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y ; } } } ps_codec -> s_parse . i4_next_ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> i4_slice_error ) { slice_header_t * ps_slice_hdr_next = ps_slice_hdr + 1 ; WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) end_of_slice_flag = 1 ; } if ( ( 1 == ps_codec -> i4_num_cores ) && ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; ps_proc -> i4_ctb_cnt = ps_proc -> ps_tile -> u2_wd ; ihevcd_process ( ps_proc ) ; } if ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu1_buf_max + BITSTRM_OFF_THRS < ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu4_buf + ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst / 8 ) ) ) { if ( 0 == ps_codec -> i4_slice_error ) end_of_slice_flag = 1 ; } if ( end_of_pic ) break ; } while ( ! end_of_slice_flag ) ; ps_codec -> i4_slice_error = 0 ; if ( 0 == end_of_pic ) { while ( 1 ) { WORD32 parse_slice_idx ; parse_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; parse_slice_idx ++ ; { if ( ( 1 == ps_codec -> i4_num_cores ) || ( 0 != ( parse_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ) { ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; break ; } else { WORD32 ctb_indx = 0 ; while ( ctb_indx != ps_sps -> i4_pic_size_in_ctb ) { WORD32 parse_status = * ( ps_codec -> pu1_parse_map + ctb_indx ) ; volatile WORD32 proc_status = * ( ps_codec -> pu1_proc_map + ctb_indx ) & 1 ; if ( parse_status == proc_status ) ctb_indx ++ ; } ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; break ; } } } } else { # if FRAME_ILF_PAD if ( FRAME_ILF_PAD && 1 == ps_codec -> i4_num_cores ) { if ( ps_slice_hdr -> i4_abs_pic_order_cnt == 0 ) { DUMP_PRE_ILF ( ps_codec -> as_process [ 0 ] . pu1_cur_pic_luma , ps_codec -> as_process [ 0 ] . pu1_cur_pic_chroma , ps_sps -> i2_pic_width_in_luma_samples , ps_sps -> i2_pic_height_in_luma_samples , ps_codec -> i4_strd ) ; DUMP_BS ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_vert_bs , ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_horz_bs , ps_sps -> i2_pic_wd_in_ctb * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb , ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb ) ; DUMP_QP ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp , ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CU_SIZE * MIN_CU_SIZE ) ) ; DUMP_QP_CONST_IN_CTB ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp_const_in_ctb , ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CTB_SIZE * MIN_CTB_SIZE ) / 8 ) ; DUMP_NO_LOOP_FILTER ( ps_codec -> as_process [ 0 ] . pu1_pic_no_loop_filter_flag , ( ps_sps -> i2_pic_width_in_luma_samples / MIN_CU_SIZE ) * ( ps_sps -> i2_pic_height_in_luma_samples / MIN_CU_SIZE ) / 8 ) ; DUMP_OFFSETS ( ps_slice_hdr -> i1_beta_offset_div2 , ps_slice_hdr -> i1_tc_offset_div2 , ps_pps -> i1_pic_cb_qp_offset , ps_pps -> i1_pic_cr_qp_offset ) ; } ps_codec -> s_parse . s_deblk_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_deblk_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_deblk_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_deblk_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ps_codec -> s_parse . s_deblk_ctxt . is_chroma_yuv420sp_vu = ( ps_codec -> e_ref_chroma_fmt == IV_YUV_420SP_VU ) ; ps_codec -> s_parse . s_sao_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_sao_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_sao_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_sao_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ihevcd_ilf_pad_frame ( & ps_codec -> s_parse . s_deblk_ctxt , & ps_codec -> s_parse . s_sao_ctxt ) ; } # endif ps_codec -> s_parse . i4_end_of_frame = 1 ; } return ret ; }", ) { WORD32 tu_coeff_data_reset_size ;  ps_codec -> s_parse  i4_pic_pu_idx = i4_pic_pu_idx  ; tu_coeff_data_reset_size =  ) pu1_tu_coeff_data ; ihevcd_set_ctb_skip ( ps_codec )  ; ps_codec ->  } else { ihevcd_set_ctb_skip ( ps_codec )  ; } if
446,"CWE-284 static void a2dp_open_ctrl_path ( struct a2dp_stream_common * common ) { int i ; for ( i = 0 ; i < CTRL_CHAN_RETRY_COUNT ; i ++ ) { if ( ( common -> ctrl_fd = skt_connect ( A2DP_CTRL_PATH , common -> buffer_sz ) ) > 0 ) { if ( check_a2dp_ready ( common ) == 0 ) break ; ERROR ( ""error:a2dpnotready,wait250msandretry"" ) ;  usleep ( 250000 ) ;  skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; }  usleep ( 250000 ) ;  } }"," ""error:a2dpnotready,wait250msandretry"" ) ; TEMP_FAILURE_RETRY (  usleep ( 250000 )  AUDIO_SKT_DISCONNECTED ; } TEMP_FAILURE_RETRY (  usleep ( 250000 )"
447,"CWE-400 static void perf_swevent_event ( struct perf_event * event , u64 nr ,  int nmi , struct perf_sample_data * data ,  struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ; local64_add ( nr , & event -> count ) ; if ( ! regs ) return ; if ( ! is_sampling_event ( event ) ) return ; if ( nr == 1 && hwc -> sample_period == 1 && ! event -> attr . freq )  return perf_swevent_overflow ( event , 1 , nmi , data , regs ) ;  if ( local64_add_negative ( nr , & hwc -> period_left ) ) return ;  perf_swevent_overflow ( event , 0 , nmi , data , regs ) ;  }"," u64 nr ,  struct perf_sample_data *  , 1 ,  data , regs  , 0 ,  data , regs"
448,"CWE-000 static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ;  return PTR_ERR ( tty ) ;  } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , ""tty_open"" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""opening%s..."" , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""error%dinopening%s..."" , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }", tty_mutex ) ; tty_driver_kref_put ( driver ) ;
449,"CWE-189 PHP_FUNCTION ( imageaffinematrixconcat ) { double m1 [ 6 ] ; double m2 [ 6 ] ; double mr [ 6 ] ; zval * * tmp ; zval * z_m1 ; zval * z_m2 ; int i , nelems ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""aa"" , & z_m1 , & z_m2 ) == FAILURE ) { return ; } if ( ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m1 ) ) ) != 6 ) || ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m2 ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affinearraysmusthavesixelements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < 6 ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m1 ) , i , ( void * * ) & tmp ) == SUCCESS ) { switch ( Z_TYPE_PP ( tmp ) ) { case IS_LONG : m1 [ i ] = Z_LVAL_PP ( tmp ) ; break ; case IS_DOUBLE : m1 [ i ] = Z_DVAL_PP ( tmp ) ; break ; case IS_STRING :  convert_to_double_ex ( tmp ) ;   m1 [ i ] = Z_DVAL_PP ( tmp ) ;  break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalidtypeforelement%i"" , i ) ; RETURN_FALSE ; } } if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m2 ) , i , ( void * * ) & tmp ) == SUCCESS ) { switch ( Z_TYPE_PP ( tmp ) ) { case IS_LONG : m2 [ i ] = Z_LVAL_PP ( tmp ) ; break ; case IS_DOUBLE : m2 [ i ] = Z_DVAL_PP ( tmp ) ; break ; case IS_STRING :  convert_to_double_ex ( tmp ) ;   m2 [ i ] = Z_DVAL_PP ( tmp ) ;  break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalidtypeforelement%i"" , i ) ; RETURN_FALSE ; } } } if ( gdAffineConcat ( mr , m1 , m2 ) != GD_TRUE ) { RETURN_FALSE ; } array_init ( return_value ) ; for ( i = 0 ; i < 6 ; i ++ ) { add_index_double ( return_value , i , mr [ i ] ) ; } }", case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval  ) ; m1  i ] = Z_DVAL ( dval ) ; }  break ; default  case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval  ) ; m2  i ] = Z_DVAL ( dval ) ; }  break ; default
450,"CWE-119 int evutil_parse_sockaddr_port ( const char * ip_as_string , struct sockaddr * out , int * outlen ) { int port ; char buf [ 128 ] ; const char * cp , * addr_part , * port_part ; int is_ipv6 ; cp = strchr ( ip_as_string , ':' ) ; if ( * ip_as_string == '[' ) {  int len ;  if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) { return - 1 ; }  len = ( int ) ( cp - ( ip_as_string + 1 ) ) ;   if ( len > ( int ) sizeof ( buf ) - 1 ) {  return - 1 ; } memcpy ( buf , ip_as_string + 1 , len ) ; buf [ len ] = '\\0' ; addr_part = buf ; if ( cp [ 1 ] == ':' ) port_part = cp + 2 ; else port_part = NULL ; is_ipv6 = 1 ; } else if ( cp && strchr ( cp + 1 , ':' ) ) { is_ipv6 = 1 ; addr_part = ip_as_string ; port_part = NULL ; } else if ( cp ) { is_ipv6 = 0 ; if ( cp - ip_as_string > ( int ) sizeof ( buf ) - 1 ) { return - 1 ; } memcpy ( buf , ip_as_string , cp - ip_as_string ) ; buf [ cp - ip_as_string ] = '\\0' ; addr_part = buf ; port_part = cp + 1 ; } else { addr_part = ip_as_string ; port_part = NULL ; is_ipv6 = 0 ; } if ( port_part == NULL ) { port = 0 ; } else { port = atoi ( port_part ) ; if ( port <= 0 || port > 65535 ) { return - 1 ; } } if ( ! addr_part ) return - 1 ; # ifdef AF_INET6 if ( is_ipv6 ) { struct sockaddr_in6 sin6 ; memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN sin6 . sin6_len = sizeof ( sin6 ) ; # endif sin6 . sin6_family = AF_INET6 ; sin6 . sin6_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET6 , addr_part , & sin6 . sin6_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin6 ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin6 , sizeof ( sin6 ) ) ; * outlen = sizeof ( sin6 ) ; return 0 ; } else # endif { struct sockaddr_in sin ; memset ( & sin , 0 , sizeof ( sin ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_family = AF_INET ; sin . sin_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET , addr_part , & sin . sin_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin , sizeof ( sin ) ) ; * outlen = sizeof ( sin ) ; return 0 ; } }", '[' ) { size_t  len ; if  } len =  ( cp -  ( len >  sizeof ( buf
451,"CWE-119 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return ""N/A"" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return ""N/A"" ; case SC_AC_NEVER : return ""NEVR"" ; case SC_AC_NONE : return ""NONE"" ; case SC_AC_CHV : strcpy ( buf , ""CHV"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , ""TERM"" ) ; break ; case SC_AC_PRO : strcpy ( buf , ""PROT"" ) ; break ; case SC_AC_AUT : strcpy ( buf , ""AUTH"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , ""Sec.Env."" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , ""Sec.ControlByte"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""Ox%X"" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , ""PKCS#15AuthID"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; default : strcpy ( buf , ""????"" ) ; break ; }  strcat ( line , buf ) ;   strcat ( line , """" ) ;  e = e -> next ; }  line [ strlen ( line ) - 1 ] = 0 ;  return line ; }"," break ; } strncat ( line , buf , sizeof line ) ; strncat  ( line ,  line , """" , sizeof line  } line [ ( sizeof  line ) -  1 ] = '\\0' ; line [ strlen ( line ) - 1 ] ="
452,"CWE-119 static inline void queue_unlock ( struct futex_q * q , struct futex_hash_bucket * hb ) { spin_unlock ( & hb -> lock ) ;  drop_futex_key_refs ( & q -> key ) ;  }", lock ) ;  }  
453,"CWE-200 static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - EBADFD ; t = tu -> timeri -> timer ; if ( ! t ) return - EBADFD ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - EFAULT ; if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { err = - EINVAL ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - EINVAL ; goto _end ; } if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) | ( 1 << SNDRV_TIMER_EVENT_START ) | ( 1 << SNDRV_TIMER_EVENT_STOP ) | ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_RESUME ) | ( 1 << SNDRV_TIMER_EVENT_MSTART ) | ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { err = - EINVAL ; goto _end ; } snd_timer_stop ( tu -> timeri ) ; spin_lock_irq ( & t -> lock ) ; tu -> timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_AUTO | SNDRV_TIMER_IFLG_EXCLUSIVE | SNDRV_TIMER_IFLG_EARLY_EVENT ) ; if ( params . flags & SNDRV_TIMER_PSFLG_AUTO ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_AUTO ; if ( params . flags & SNDRV_TIMER_PSFLG_EXCLUSIVE ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EXCLUSIVE ; if ( params . flags & SNDRV_TIMER_PSFLG_EARLY_EVENT ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EARLY_EVENT ; spin_unlock_irq ( & t -> lock ) ; if ( params . queue_size > 0 && ( unsigned int ) tu -> queue_size != params . queue_size ) { if ( tu -> tread ) { ttr = kmalloc ( params . queue_size * sizeof ( * ttr ) , GFP_KERNEL ) ; if ( ttr ) { kfree ( tu -> tqueue ) ; tu -> queue_size = params . queue_size ; tu -> tqueue = ttr ; } } else { tr = kmalloc ( params . queue_size * sizeof ( * tr ) , GFP_KERNEL ) ; if ( tr ) { kfree ( tu -> queue ) ; tu -> queue_size = params . queue_size ; tu -> queue = tr ; } } } tu -> qhead = tu -> qtail = tu -> qused = 0 ; if ( tu -> timeri -> flags & SNDRV_TIMER_IFLG_EARLY_EVENT ) { if ( tu -> tread ) { struct snd_timer_tread tread ;  tread . event = SNDRV_TIMER_EVENT_EARLY ;  tread . tstamp . tv_sec = 0 ; tread . tstamp . tv_nsec = 0 ; tread . val = 0 ; snd_timer_user_append_to_tqueue ( tu , & tread ) ; } else { struct snd_timer_read * r = & tu -> queue [ 0 ] ; r -> resolution = 0 ; r -> ticks = 0 ; tu -> qused ++ ; tu -> qtail ++ ; } } tu -> filter = params . filter ; tu -> ticks = params . ticks ; err = 0 ; _end : if ( copy_to_user ( _params , & params , sizeof ( params ) ) ) return - EFAULT ; return err ; }"," snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;"
454,"CWE-119 cJSON * iperf_json_printf ( const char * format , ... ) { cJSON * o ; va_list argp ; const char * cp ; char name [ 100 ] ; char * np ; cJSON * j ; o = cJSON_CreateObject ( ) ; if ( o == NULL ) return NULL ; va_start ( argp , format ) ; np = name ; for ( cp = format ; * cp != '\\0' ; ++ cp ) { switch ( * cp ) { case '' : break ; case ':' : * np = '\\0' ; break ; case '%' : ++ cp ; switch ( * cp ) { case 'b' : j = cJSON_CreateBool ( va_arg ( argp , int ) ) ; break ; case 'd' :  j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ;  break ; case 'f' :  j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ;  break ; case 's' : j = cJSON_CreateString ( va_arg ( argp , char * ) ) ; break ; default : return NULL ; } if ( j == NULL ) return NULL ; cJSON_AddItemToObject ( o , name , j ) ; np = name ; break ; default : * np ++ = * cp ; break ; } } va_end ( argp ) ; return o ; }", : j = cJSON_CreateNumber  ( va_arg (  : j = cJSON_CreateNumber  ( va_arg (
455,"CWE-295  void options_free ( ) {   parse_global_option ( CMD_FREE , NULL , NULL ) ;   } "," void options_free ( int current ) { GLOBAL_OPTIONS * global = current ? & global_options : & new_global_options ; SERVICE_OPTIONS * service = current ? & service_options : & new_service_options ;  parse_global_option ( CMD_FREE  parse_global_option ( CMD_FREE , global  NULL ) ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; while ( service ) { SERVICE_OPTIONS * tmp = service ; service = service -> next ; tmp -> next = NULL ; service_free ( tmp ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;"
456,"CWE-125 static expr_ty  ast_for_call ( struct compiling * c , const node * n , expr_ty func )  {  int i , nargs , nkeywords , ngens ;  int ndoublestars ; asdl_seq * args ; asdl_seq * keywords ; REQ ( n , arglist ) ; nargs = 0 ; nkeywords = 0 ;  ngens = 0 ;  for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { if ( NCH ( ch ) == 1 ) nargs ++ ; else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for )  ngens ++ ;  else if ( TYPE ( CHILD ( ch , 0 ) ) == STAR ) nargs ++ ; else nkeywords ++ ; } }  if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) {  ast_error ( c , n , ""Generatorexpressionmustbeparenthesized"" ""ifnotsoleargument"" ) ; return NULL ; } if ( nargs + nkeywords + ngens > 255 ) { ast_error ( c , n , ""morethan255arguments"" ) ; return NULL ; } args = _Ta3_asdl_seq_new ( nargs + ngens , c -> c_arena ) ; if ( ! args ) return NULL ; keywords = _Ta3_asdl_seq_new ( nkeywords , c -> c_arena ) ; if ( ! keywords ) return NULL ; nargs = 0 ; nkeywords = 0 ; ndoublestars = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { expr_ty e ; node * chch = CHILD ( ch , 0 ) ; if ( NCH ( ch ) == 1 ) { if ( nkeywords ) { if ( ndoublestars ) { ast_error ( c , chch , ""positionalargumentfollows"" ""keywordargumentunpacking"" ) ; } else { ast_error ( c , chch , ""positionalargumentfollows"" ""keywordargument"" ) ; } return NULL ; } e = ast_for_expr ( c , chch ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else if ( TYPE ( chch ) == STAR ) { expr_ty starred ; if ( ndoublestars ) { ast_error ( c , chch , ""iterableargumentunpackingfollows"" ""keywordargumentunpacking"" ) ; return NULL ; } e = ast_for_expr ( c , CHILD ( ch , 1 ) ) ; if ( ! e ) return NULL ; starred = Starred ( e , Load , LINENO ( chch ) , chch -> n_col_offset , c -> c_arena ) ; if ( ! starred ) return NULL ; asdl_seq_SET ( args , nargs ++ , starred ) ; } else if ( TYPE ( chch ) == DOUBLESTAR ) { keyword_ty kw ; i ++ ; e = ast_for_expr ( c , CHILD ( ch , 1 ) ) ; if ( ! e ) return NULL ; kw = keyword ( NULL , e , c -> c_arena ) ; asdl_seq_SET ( keywords , nkeywords ++ , kw ) ; ndoublestars ++ ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { e = ast_for_genexp ( c , ch ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else { keyword_ty kw ; identifier key , tmp ; int k ; e = ast_for_expr ( c , chch ) ; if ( ! e ) return NULL ; if ( e -> kind == Lambda_kind ) { ast_error ( c , chch , ""lambdacannotcontainassignment"" ) ; return NULL ; } else if ( e -> kind != Name_kind ) { ast_error ( c , chch , ""keywordcan\'tbeanexpression"" ) ; return NULL ; } else if ( forbidden_name ( c , e -> v . Name . id , ch , 1 ) ) { return NULL ; } key = e -> v . Name . id ; for ( k = 0 ; k < nkeywords ; k ++ ) { tmp = ( ( keyword_ty ) asdl_seq_GET ( keywords , k ) ) -> arg ; if ( tmp && ! PyUnicode_Compare ( tmp , key ) ) { ast_error ( c , chch , ""keywordargumentrepeated"" ) ; return NULL ; } } e = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! e ) return NULL ; kw = keyword ( key , e , c -> c_arena ) ; if ( ! kw ) return NULL ; asdl_seq_SET ( keywords , nkeywords ++ , kw ) ; } } } return Call ( func , args , keywords , func -> lineno , func -> col_offset , c -> c_arena ) ; }"," , expr_ty func , bool allowgen  nargs , nkeywords  ; int ndoublestars  = 0 ;  for ( i  == comp_for ) { nargs ++ ; if ( ! allowgen ) { ast_error ( c , ch , ""invalidsyntax"" ) ; return NULL ; } if ( NCH ( n ) > 1 ) { ast_error ( c , ch , ""Generatorexpressionmustbeparenthesized"" ) ; return NULL ; } }  else if (  ; } } args = _Ta3_asdl_seq_new ( nargs  , c ->"
457,"CWE-125 static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ;  for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ )  if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }", + 2 ; ( (  + 1 ] ) && ( kk < input -> length ) )
458,"CWE-119 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ;  char combname [ L_BUF_SIZE ] ;  l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( ""selaGetCombName"" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( ""selanotdefined"" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( ""invaliddirection"" , procName , NULL ) ; if ( direction == L_HORIZ )  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ;  else  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ;  found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( ""selnotfound"" , procName , NULL ) ; }"," char combname [ L_BUFSIZE  ] ; l_int32  ( combname , L_BUFSIZE  , ""sel_comb_%dh"" ,  ( combname , L_BUFSIZE  , ""sel_comb_%dv"" ,"
459,"CWE-200 int imap_open_connection ( IMAP_DATA * idata ) { if ( mutt_socket_open ( idata -> conn ) < 0 ) return - 1 ; idata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( idata ) != IMAP_CMD_OK ) { imap_close_connection ( idata ) ; return - 1 ; } if ( ascii_strncasecmp ( ""*OK"" , idata -> buf , 4 ) == 0 ) { if ( ascii_strncasecmp ( ""*OK[CAPABILITY"" , idata -> buf , 16 ) && imap_check_capabilities ( idata ) ) goto bail ; # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf && ( option ( OPTSSLFORCETLS ) || mutt_bit_isset ( idata -> capabilities , STARTTLS ) ) ) { int rc ; if ( option ( OPTSSLFORCETLS ) ) rc = MUTT_YES ; else if ( ( rc = query_quadoption ( OPT_SSLSTARTTLS , _ ( ""SecureconnectionwithTLS?"" ) ) ) == - 1 ) goto err_close_conn ; if ( rc == MUTT_YES ) { if ( ( rc = imap_exec ( idata , ""STARTTLS"" , IMAP_CMD_FAIL_OK ) ) == - 1 ) goto bail ; if ( rc != - 2 ) { if ( mutt_ssl_starttls ( idata -> conn ) ) { mutt_error ( _ ( ""CouldnotnegotiateTLSconnection"" ) ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } else { if ( imap_exec ( idata , ""CAPABILITY"" , 0 ) ) goto bail ; } } } } if ( option ( OPTSSLFORCETLS ) && ! idata -> conn -> ssf ) { mutt_error _ ( ""Encryptedconnectionunavailable"" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } # endif } else if ( ascii_strncasecmp ( ""*PREAUTH"" , idata -> buf , 9 ) == 0 ) {  idata -> state = IMAP_AUTHENTICATED ;  if ( imap_check_capabilities ( idata ) != 0 ) goto bail ; FREE ( & idata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , idata -> buf ) ; goto bail ; } return 0 ; # if defined ( USE_SSL ) err_close_conn : imap_close_connection ( idata ) ; # endif bail : FREE ( & idata -> capstr ) ; return - 1 ; }"," 0 ) { # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf ) { if ( option ( OPTSSLFORCETLS ) || ( query_quadoption ( OPT_SSLSTARTTLS , _ ( ""AbortunencryptedPREAUTHconnection?"" ) ) != MUTT_NO ) ) { mutt_error _ ( ""Encryptedconnectionunavailable"" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } } # endif"
460,"CWE-362 static ssize_t driver_override_show ( struct device * dev , struct device_attribute * attr , char * buf ) { struct platform_device * pdev = to_platform_device ( dev ) ;  return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ;   } ", dev ) ; ssize_t len ; device_lock ( dev ) ; len =  sprintf ( buf  driver_override ) ; device_unlock ( dev ) ; return len ;
461,"CWE-119 static cJSON * create_reference ( cJSON * item ) {  cJSON * ref ;   if ( ! ( ref = cJSON_New_Item ( ) ) )  return 0 ; memcpy ( ref , item , sizeof ( cJSON ) ) ; ref -> string = 0 ; ref -> type |= cJSON_IsReference ; ref -> next = ref -> prev = 0 ; return ref ; }", { cJSON *  ref = cJSON_New_Item  cJSON_New_Item ( ) ; if ( ! ref )  return 0 ;
462,"CWE-20 static ext3_fsblk_t get_sb_block ( void * * data , struct super_block * sb ) { ext3_fsblk_t sb_block ; char * options = ( char * ) * data ; if ( ! options || strncmp ( options , ""sb="" , 3 ) != 0 ) return 1 ; options += 3 ; sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ',' ) {  ext3_msg ( sb , ""error:invalidsbspecification:%s"" ,  ( char * ) * data ) ; return 1 ; } if ( * options == ',' ) options ++ ; * data = ( void * ) options ; return sb_block ; }"," ( sb , KERN_ERR ,"
463,"CWE-20 static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , anum_t last , int restore ) { struct NntpData * nntp_data = ctx -> data ; struct FetchCtx fc ; struct Header * hdr = NULL ; char buf [ HUGE_STRING ] ; int rc = 0 ; int oldmsgcount = ctx -> msgcount ; anum_t current ; anum_t first_over = first ; # ifdef USE_HCACHE void * hdata = NULL ; # endif if ( ! last || first > last ) return 0 ; fc . ctx = ctx ; fc . first = first ; fc . last = last ; fc . restore = restore ;  fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;  # ifdef USE_HCACHE fc . hc = hc ; # endif if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) { if ( ! ctx -> quiet ) mutt_message ( _ ( ""Fetchinglistofarticles..."" ) ) ; if ( nntp_data -> nserv -> hasLISTGROUPrange ) snprintf ( buf , sizeof ( buf ) , ""LISTGROUP%s%u-%u\\r\\n"" , nntp_data -> group , first , last ) ; else snprintf ( buf , sizeof ( buf ) , ""LISTGROUP%s\\r\\n"" , nntp_data -> group ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ; if ( rc > 0 ) { mutt_error ( ""LISTGROUP:%s"" , buf ) ; } if ( rc == 0 ) { for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( fc . messages [ current - first ] ) continue ; snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#1mutt_bcache_del%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } # ifdef USE_HCACHE if ( fc . hc ) { mutt_debug ( 2 , ""mutt_hcache_delete%s\\n"" , buf ) ; mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ; } # endif } } } else { for ( current = first ; current <= last ; current ++ ) fc . messages [ current - first ] = 1 ; } if ( ! ctx -> quiet ) { mutt_progress_init ( & fc . progress , _ ( ""Fetchingmessageheaders..."" ) , MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ; } for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ; # ifdef USE_HCACHE snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; # endif if ( ! fc . messages [ current - first ] ) continue ; if ( ctx -> msgcount >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; # ifdef USE_HCACHE hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ; if ( hdata ) { mutt_debug ( 2 , ""mutt_hcache_fetch%s\\n"" , buf ) ; ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ; mutt_hcache_free ( fc . hc , & hdata ) ; hdr -> data = 0 ; if ( hdr -> deleted && ! restore ) { mutt_header_free ( & hdr ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#2mutt_bcache_del%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } continue ; } hdr -> read = false ; hdr -> old = false ; } else # endif if ( nntp_data -> deleted ) continue ; else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) { if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) break ; else continue ; } else { FILE * fp = mutt_file_mkstemp ( ) ; if ( ! fp ) { mutt_perror ( ""mutt_file_mkstemp()failed!"" ) ; rc = - 1 ; break ; } snprintf ( buf , sizeof ( buf ) , ""HEAD%u\\r\\n"" , current ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ; if ( rc ) { mutt_file_fclose ( & fp ) ; if ( rc < 0 ) break ; if ( mutt_str_strncmp ( ""423"" , buf , 3 ) != 0 ) { mutt_error ( ""HEAD:%s"" , buf ) ; break ; } if ( nntp_data -> bcache ) { snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; mutt_debug ( 2 , ""#3mutt_bcache_del%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } rc = 0 ; continue ; } hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ; hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ; hdr -> received = hdr -> date_sent ; mutt_file_fclose ( & fp ) ; } hdr -> index = ctx -> msgcount ++ ; hdr -> read = false ; hdr -> old = false ; hdr -> deleted = false ; hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ; NHDR ( hdr ) -> article_num = current ; if ( restore ) hdr -> changed = true ; else { nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ; if ( ! hdr -> read ) nntp_parse_xref ( ctx , hdr ) ; } if ( current > nntp_data -> last_loaded ) nntp_data -> last_loaded = current ; first_over = current + 1 ; } if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) current = first_over ; if ( current <= last && rc == 0 && ! nntp_data -> deleted ) { char * cmd = nntp_data -> nserv -> hasOVER ? ""OVER"" : ""XOVER"" ; snprintf ( buf , sizeof ( buf ) , ""%s%u-%u\\r\\n"" , cmd , current , last ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ; if ( rc > 0 ) { mutt_error ( ""%s:%s"" , cmd , buf ) ; } } if ( ctx -> msgcount > oldmsgcount ) mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ; FREE ( & fc . messages ) ; if ( rc != 0 ) return - 1 ; mutt_clear_error ( ) ; return 0 ; }", char ) ) ; if ( fc . messages == NULL ) return - 1
464,"CWE-476 static int f2fs_read_single_page ( struct inode * inode , struct page * page , unsigned nr_pages , struct f2fs_map_blocks * map , struct bio * * bio_ret , sector_t * last_block_in_bio , bool is_readahead ) { struct bio * bio = * bio_ret ; const unsigned blkbits = inode -> i_blkbits ; const unsigned blocksize = 1 << blkbits ; sector_t block_in_file ; sector_t last_block ; sector_t last_block_in_file ; sector_t block_nr ; int ret = 0 ;  block_in_file = ( sector_t ) page -> index ;  last_block = block_in_file + nr_pages ; last_block_in_file = ( i_size_read ( inode ) + blocksize - 1 ) >> blkbits ; if ( last_block > last_block_in_file ) last_block = last_block_in_file ; if ( block_in_file >= last_block ) goto zero_out ; if ( ( map -> m_flags & F2FS_MAP_MAPPED ) && block_in_file > map -> m_lblk && block_in_file < ( map -> m_lblk + map -> m_len ) ) goto got_it ; map -> m_lblk = block_in_file ; map -> m_len = last_block - block_in_file ; ret = f2fs_map_blocks ( inode , map , 0 , F2FS_GET_BLOCK_DEFAULT ) ; if ( ret ) goto out ; got_it : if ( ( map -> m_flags & F2FS_MAP_MAPPED ) ) { block_nr = map -> m_pblk + block_in_file - map -> m_lblk ; SetPageMappedToDisk ( page ) ;  if ( ! PageUptodate ( page ) && ! cleancache_get_page ( page ) ) {  SetPageUptodate ( page ) ; goto confused ; } if ( ! f2fs_is_valid_blkaddr ( F2FS_I_SB ( inode ) , block_nr , DATA_GENERIC_ENHANCE_READ ) ) { ret = - EFSCORRUPTED ; goto out ; } } else { zero_out : zero_user_segment ( page , 0 , PAGE_SIZE ) ; if ( ! PageUptodate ( page ) ) SetPageUptodate ( page ) ; unlock_page ( page ) ; goto out ; } if ( bio && ( * last_block_in_bio != block_nr - 1 || ! __same_bdev ( F2FS_I_SB ( inode ) , block_nr , bio ) ) ) { submit_and_realloc : __submit_bio ( F2FS_I_SB ( inode ) , bio , DATA ) ; bio = NULL ; } if ( bio == NULL ) { bio = f2fs_grab_read_bio ( inode , block_nr , nr_pages , is_readahead ? REQ_RAHEAD : 0 ) ; if ( IS_ERR ( bio ) ) { ret = PTR_ERR ( bio ) ; bio = NULL ; goto out ; } } f2fs_wait_on_block_writeback ( inode , block_nr ) ; if ( bio_add_page ( bio , page , blocksize , 0 ) < blocksize ) goto submit_and_realloc ; inc_page_count ( F2FS_I_SB ( inode ) , F2FS_RD_DATA ) ; ClearPageError ( page ) ; * last_block_in_bio = block_nr ; goto out ; confused : if ( bio ) { __submit_bio ( F2FS_I_SB ( inode ) , bio , DATA ) ; bio = NULL ; } unlock_page ( page ) ; out : * bio_ret = bio ; return ret ; }", ( sector_t ) page_index ( page )  ; last_block =  page ) && ( ! PageSwapCache ( page ) &&  cleancache_get_page ( page )
465,"CWE-119 static void set_segment_data ( VP8_COMP * cpi , signed char * feature_data , unsigned char abs_delta ) { cpi -> mb . e_mbd . mb_segement_abs_delta = abs_delta ;  vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ;  }", = abs_delta ; memcpy  ( cpi ->
466,"CWE-20 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ;  msg -> msg_namelen = 0 ;  skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , ""%s(),Receivedtruncatedframe(%zd<%zd)!\\n"" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , ""%s(),StartingIrTTP\\n"" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }", __func__ ) ;  skb = skb_recv_datagram
467,"CWE-125 static int mp_dss_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_dss * mdss = ( const struct mp_dss * ) opt ;  if ( ( opt_len != mp_dss_len ( mdss , 1 ) &&  opt_len != mp_dss_len ( mdss , 0 ) ) || flags & TH_SYN ) return 0 ; if ( mdss -> flags & MP_DSS_F ) ND_PRINT ( ( ndo , ""fin"" ) ) ; opt += 4 ;  if ( mdss -> flags & MP_DSS_A ) {  ND_PRINT ( ( ndo , ""ack"" ) ) ;  if ( mdss -> flags & MP_DSS_a ) {  ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ; opt += 8 ;  } else {   ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;  opt += 4 ;  }  } if ( mdss -> flags & MP_DSS_M ) { ND_PRINT ( ( ndo , ""seq"" ) ) ;  if ( mdss -> flags & MP_DSS_m ) {  ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ; opt += 8 ;  } else {   ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;  opt += 4 ;  }  ND_PRINT ( ( ndo , ""subseq%u"" , EXTRACT_32BITS ( opt ) ) ) ; opt += 4 ;  ND_PRINT ( ( ndo , ""len%u"" , EXTRACT_16BITS ( opt ) ) ) ;  opt += 2 ;  if ( opt_len == mp_dss_len ( mdss , 1 ) )  ND_PRINT ( ( ndo , ""csum0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; } return 1 ; }"," ; if ( opt_len < 4 ) return 0 ; if (  flags & TH_SYN  += 4 ; opt_len -= 4 ;  MP_DSS_a ) { if ( opt_len < 8 ) return 0 ;  += 8 ; opt_len -= 8 ;  } else { if ( opt_len < 4 ) return 0 ;  += 4 ; opt_len -= 4 ;  MP_DSS_m ) { if ( opt_len < 8 ) return 0 ;  += 8 ; opt_len -= 8 ;  } else { if ( opt_len < 4 ) return 0 ;  += 4 ; opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ;  ND_PRINT ( (  += 4 ; opt_len -= 4 ; if ( opt_len < 2 ) return 0 ;  += 2 ; opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , ""csum0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1  ; } "
468,"CWE-20 static void mpeg4_encode_gop_header ( MpegEncContext * s ) {  int hours , minutes , seconds ;  int64_t time ; put_bits ( & s -> pb , 16 , 0 ) ; put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; time = s -> current_picture_ptr -> f -> pts ; if ( s -> reordered_input_picture [ 1 ] ) time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> f -> pts ) ; time = time * s -> avctx -> time_base . num ; s -> last_time_base = FFUDIV ( time , s -> avctx -> time_base . den ) ; seconds = FFUDIV ( time , s -> avctx -> time_base . den ) ; minutes = FFUDIV ( seconds , 60 ) ; seconds = FFUMOD ( seconds , 60 ) ; hours = FFUDIV ( minutes , 60 ) ; minutes = FFUMOD ( minutes , 60 ) ; hours = FFUMOD ( hours , 24 ) ; put_bits ( & s -> pb , 5 , hours ) ; put_bits ( & s -> pb , 6 , minutes ) ; put_bits ( & s -> pb , 1 , 1 ) ; put_bits ( & s -> pb , 6 , seconds ) ; put_bits ( & s -> pb , 1 , ! ! ( s -> avctx -> flags & AV_CODEC_FLAG_CLOSED_GOP ) ) ; put_bits ( & s -> pb , 1 , 0 ) ; ff_mpeg4_stuffing ( & s -> pb ) ; }"," s ) { int64_t  hours , minutes"
469,"CWE-189 static int cdf_check_stream_offset ( const cdf_stream_t * sst , const cdf_header_t * h , const void * p , size_t tail , int line ) { const char * b = ( const char * ) sst -> sst_tab ; const char * e = ( ( const char * ) p ) + tail ;  ( void ) & line ;   if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len )  return 0 ; DPRINTF ( ( ""%d:offsetbegin%p<end%p||%"" SIZE_T_FORMAT ""u"" "">%"" SIZE_T_FORMAT ""u[%"" SIZE_T_FORMAT ""u%"" SIZE_T_FORMAT ""u]\\n"" , line , b , e , ( size_t ) ( e - b ) ,  CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ;  errno = EFTYPE ; return - 1 ; }"," + tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ;  b ) <= ss  * sst ->  b ) , ss  * sst ->  -> sst_len , ss  , sst ->"
470,"CWE-119  void fdct4_sse2 ( __m128i * in ) {   const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;  const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u [ 4 ] , v [ 4 ] ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 1 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 2 ] ) ; v [ 0 ] = _mm_add_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_sub_epi16 ( u [ 0 ] , u [ 1 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p08_p24 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p24_m08 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; transpose_4x4 ( in ) ; }",    static  = _mm_set1_epi16 ( ( int16_t )
471,"CWE-399 static int hugetlbfs_fill_super ( struct super_block * sb , void * data , int silent ) { struct inode * inode ; struct dentry * root ; int ret ; struct hugetlbfs_config config ; struct hugetlbfs_sb_info * sbinfo ; save_mount_options ( sb , data ) ; config . nr_blocks = - 1 ; config . nr_inodes = - 1 ; config . uid = current_fsuid ( ) ; config . gid = current_fsgid ( ) ; config . mode = 0755 ; config . hstate = & default_hstate ; ret = hugetlbfs_parse_options ( data , & config ) ; if ( ret ) return ret ; sbinfo = kmalloc ( sizeof ( struct hugetlbfs_sb_info ) , GFP_KERNEL ) ; if ( ! sbinfo ) return - ENOMEM ; sb -> s_fs_info = sbinfo ; sbinfo -> hstate = config . hstate ; spin_lock_init ( & sbinfo -> stat_lock ) ;  sbinfo -> max_blocks = config . nr_blocks ;   sbinfo -> free_blocks = config . nr_blocks ;  sbinfo -> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ;  if ( ! inode )  goto out_free ;  root = d_alloc_root ( inode ) ;  if ( ! root ) { iput ( inode ) ; goto out_free ; } sb -> s_root = root ; return 0 ; out_free :  kfree ( sbinfo ) ;  return - ENOMEM ; }"," ; sbinfo -> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if (  config . nr_blocks  config . nr_blocks != - 1 ) { sbinfo -> spool = hugepage_new_subpool (  config . nr_blocks  config . nr_blocks  ) ; if  if ( ! sbinfo -> spool  ) goto out_free  goto out_free ; } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ;  ; out_free : if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ;"
472,"CWE-125 int jpc_dec_decodepkts ( jpc_dec_t * dec , jas_stream_t * pkthdrstream , jas_stream_t * in ) { jpc_dec_tile_t * tile ; jpc_pi_t * pi ; int ret ; tile = dec -> curtile ; pi = tile -> pi ; for ( ; ; ) { if ( ! tile -> pkthdrstream || jas_stream_peekc ( tile -> pkthdrstream ) == EOF ) { switch ( jpc_dec_lookahead ( in ) ) { case JPC_MS_EOC : case JPC_MS_SOT : return 0 ; break ; case JPC_MS_SOP : case JPC_MS_EPH : case 0 : break ; default : return - 1 ; break ; } } if ( ( ret = jpc_pi_next ( pi ) ) ) { return ret ; } if ( dec -> maxpkts >= 0 && dec -> numpkts >= dec -> maxpkts ) { jas_eprintf ( ""warning:stoppingdecodeprematurelyasrequested\\n"" ) ; return 0 ; } if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""packetoffset=%08ldprg=%dcmptno=%02d"" ""rlvlno=%02dprcno=%03dlyrno=%02d\\n"" , ( long ) jas_stream_getrwcount ( in ) , jpc_pi_prg ( pi ) , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ; } if ( jpc_dec_decodepkt ( dec , pkthdrstream , in , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ) { return - 1 ; } ++ dec -> numpkts ; } return 0 ; }","
"
473,"CWE-20 void enc624j600EventHandler ( NetInterface * interface ) { error_t error ; uint16_t status ; uint16_t value ;  status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ;  if ( ( status & EIR_LINKIF ) != 0 ) {  enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_LINKIF ) ;   value = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) ;  if ( ( value & ESTAT_PHYLNK ) != 0 ) {  value = enc624j600ReadPhyReg ( interface , ENC624J600_PHY_REG_PHSTAT3 ) ;  if ( ( value & PHSTAT3_SPDDPX1 ) != 0 ) { interface -> linkSpeed = NIC_LINK_SPEED_100MBPS ; } else { interface -> linkSpeed = NIC_LINK_SPEED_10MBPS ; }  if ( ( value & PHSTAT3_SPDDPX2 ) != 0 )  { interface -> duplexMode = NIC_FULL_DUPLEX_MODE ; } else { interface -> duplexMode = NIC_HALF_DUPLEX_MODE ; } interface -> linkState = TRUE ; enc624j600UpdateMacConfig ( interface ) ; } else { interface -> linkState = FALSE ; } nicNotifyLinkChange ( interface ) ; }  if ( ( status & EIR_PKTIF ) != 0 )  {  enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_PKTIF ) ;  do { error = enc624j600ReceivePacket ( interface ) ; } while ( error != ERROR_BUFFER_EMPTY ) ; }  enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ;  }"," ( interface , ENC624J600_EIR ) ; if ( ( status & ENC624J600_EIR_LINKIF  ) != 0  ( interface , ENC624J600_EIR , ENC624J600_EIR_LINKIF  ) ; value  ( interface , ENC624J600_ESTAT ) ; if ( ( value & ENC624J600_ESTAT_PHYLNK  ) != 0  ( interface , ENC624J600_PHSTAT3 ) ; if ( ( value & ENC624J600_PHSTAT3_SPDDPX1  ) != 0  ( value & ENC624J600_PHSTAT3_SPDDPX2  ) != 0  ( status & ENC624J600_EIR_PKTIF  ) != 0  ( interface , ENC624J600_EIR , ENC624J600_EIR_PKTIF  ) ; do  ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE  ) ; }"
474,"CWE-908 static void cmd_anal_esil ( RCore * core , const char * input ) { RAnalEsil * esil = core -> anal -> esil ; ut64 addr = core -> offset ; ut64 adr ; char * n , * n1 ; int off ; int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; int iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; int romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; int stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; int noNULL = r_config_get_i ( core -> config , ""esil.noNULL"" ) ; ut64 until_addr = UT64_MAX ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; const char * until_expr = NULL ; RAnalOp * op ; switch ( input [ 0 ] ) { case 'p' : switch ( input [ 1 ] ) { case 'c' : if ( input [ 2 ] == '' ) { r_core_cmdf ( core , ""arPC=%s"" , input + 3 ) ; r_core_cmd0 ( core , "".ar*"" ) ; } else { eprintf ( ""Missingargument\\n"" ) ; } break ; case 0 : r_anal_pin_list ( core -> anal ) ; break ; case '-' : if ( input [ 2 ] ) addr = r_num_math ( core -> num , input + 2 ) ; r_anal_pin_unset ( core -> anal , addr ) ; break ; case '' : r_anal_pin ( core -> anal , addr , input + 2 ) ; break ; default : r_core_cmd_help ( core , help_msg_aep ) ; break ; } break ; case 'r' : cmd_anal_reg ( core , input + 1 ) ; break ; case '*' : if ( core -> anal -> esil ) { r_cons_printf ( ""trap:%d\\n"" , core -> anal -> esil -> trap ) ; r_cons_printf ( ""trap-code:%d\\n"" , core -> anal -> esil -> trap_code ) ; } else { eprintf ( ""esilvmnotinitialized.run`aei`\\n"" ) ; } break ; case '' : if ( ! esil ) { if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 1 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; break ; case 's' : switch ( input [ 1 ] ) { case '?' : eprintf ( ""See:ae?~aes\\n"" ) ; break ; case 'l' : { ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ; RAnalOp * op = r_core_anal_op ( core , pc ) ; if ( ! op ) { break ; } r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ; r_anal_esil_set_pc ( esil , pc + op -> size ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'b' : if ( ! r_core_esil_step_back ( core ) ) { eprintf ( ""cannnotstepback\\n"" ) ; } r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'u' : if ( input [ 2 ] == 'e' ) { until_expr = input + 3 ; } else { until_addr = r_num_math ( core -> num , input + 2 ) ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'o' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ; if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) { until_addr = op -> addr + op -> size ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_anal_op_free ( op ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'p' : n = strchr ( input , '' ) ; n1 = n ? strchr ( n + 1 , '' ) : NULL ; if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) { eprintf ( ""aesp[offset][num]\\n"" ) ; break ; } adr = r_num_math ( core -> num , n + 1 ) ; off = r_num_math ( core -> num , n1 + 1 ) ; cmd_aespc ( core , adr , off ) ; break ; case '' : n = strchr ( input , '' ) ; if ( ! ( n + 1 ) ) { r_core_esil_step ( core , until_addr , until_expr , NULL ) ; break ; } off = r_num_math ( core -> num , n + 1 ) ; cmd_aespc ( core , - 1 , off ) ; break ; default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; } break ; case 'c' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aec ) ; } else if ( input [ 1 ] == 's' ) { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; ut64 newaddr ; int ret ; for ( ; ; ) { op = r_core_anal_op ( core , addr ) ; if ( ! op ) { break ; } if ( op -> type == R_ANAL_OP_TYPE_SWI ) { eprintf ( ""syscallat0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } if ( op -> type == R_ANAL_OP_TYPE_TRAP ) { eprintf ( ""trapat0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_anal_op_free ( op ) ; op = NULL ; if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) { break ; } if ( ! ret ) break ; r_core_cmd0 ( core , "".ar*"" ) ; newaddr = r_num_get ( core -> num , pc ) ; if ( addr == newaddr ) { addr ++ ; break ; } else { addr = newaddr ; } } if ( op ) { r_anal_op_free ( op ) ; } } else { if ( input [ 1 ] == 'u' && input [ 2 ] == 'e' ) until_expr = input + 3 ; else if ( input [ 1 ] == 'u' ) until_addr = r_num_math ( core -> num , input + 2 ) ; else until_expr = ""0"" ; r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'i' : switch ( input [ 1 ] ) { case 's' : case 'm' : cmd_esil_mem ( core , input + 2 ) ; break ; case 'p' : r_core_cmd0 ( core , ""arPC=$$"" ) ; break ; case '?' : cmd_esil_mem ( core , ""?"" ) ; break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } r_anal_esil_free ( esil ) ; core -> anal -> esil = NULL ; break ; case 0 : r_anal_esil_free ( esil ) ; { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) { r_core_cmd0 ( core , ""arPC=$$"" ) ; } } if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) { return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ; { const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ; if ( s ) { char * my = strdup ( s ) ; if ( my ) { r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ; free ( my ) ; } } } break ; } break ; case 'k' : switch ( input [ 1 ] ) { case '\\0' : input = ""123*"" ; case '' : if ( esil && esil -> stats ) { char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ; if ( out ) { r_cons_println ( out ) ; free ( out ) ; } } else { eprintf ( ""esil.statsisempty.Run\'aei\'\\n"" ) ; } break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } break ; } break ; case 'f' : { RListIter * iter ; RAnalBlock * bb ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; if ( fcn ) { r_list_foreach ( fcn -> bbs , iter , bb ) { ut64 pc = bb -> addr ; ut64 end = bb -> addr + bb -> size ; RAnalOp op ; ut8 * buf ; int ret , bbs = end - pc ; if ( bbs < 1 || bbs > 0xfffff ) { eprintf ( ""Invalidblocksize\\n"" ) ; } buf = calloc ( 1 , bbs + 1 ) ; r_io_read_at ( core -> io , pc , buf , bbs ) ; int left ; while ( pc < end ) { left = R_MIN ( end - pc , 32 ) ; r_asm_set_pc ( core -> assembler , pc ) ; ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ; if ( ret ) { r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ; r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; pc += op . size ; } else { pc += 4 ; } } } } else { eprintf ( ""Cannotfindfunctionat0x%08"" PFMT64x ""\\n"" , core -> offset ) ; } } break ; case 't' : switch ( input [ 1 ] ) { case 'r' : { RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ;  if ( ! esil )  return ; r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 2 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_free ( esil ) ; break ; } case 's' : switch ( input [ 2 ] ) { case 0 : r_anal_esil_session_list ( esil ) ; break ; case '+' : r_anal_esil_session_add ( esil ) ; break ; default : r_core_cmd_help ( core , help_msg_aets ) ; break ; } break ; default : eprintf ( ""Unknowncommand.Use`aetr`.\\n"" ) ; break ; } break ; case 'A' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 + ( 1 << 1 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 + ( 1 << 2 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 + ( 1 << 3 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 + ( 1 << 4 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 + ( 1 << 5 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; } } else { cmd_aea ( core , 1 , core -> offset , ( int ) r_num_math ( core -> num , input + 2 ) ) ; } break ; case 'a' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 << 1 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 << 2 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 << 3 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 << 4 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 << 5 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { switch ( input [ 2 ] ) { case 'j' : cmd_aea ( core , 1 << 4 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; default : cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; } break ; } } else { const char * arg = input [ 1 ] ? input + 2 : """" ; ut64 len = r_num_math ( core -> num , arg ) ; cmd_aea ( core , 0 , core -> offset , len ) ; } break ; case 'x' : { char * hex ; int ret , bufsz ; input = r_str_trim_ro ( input + 1 ) ; hex = strdup ( input ) ; if ( ! hex ) { break ; } RAnalOp aop = R_EMPTY ; bufsz = r_hex_str2bin ( hex , ( ut8 * ) hex ) ; ret = r_anal_op ( core -> anal , & aop , core -> offset , ( const ut8 * ) hex , bufsz , R_ANAL_OP_MASK_ALL ) ; if ( ret > 0 ) { const char * str = R_STRBUF_SAFEGET ( & aop . esil ) ; char * str2 = r_str_newf ( ""%s"" , str ) ; cmd_anal_esil ( core , str2 ) ; free ( str2 ) ; } r_anal_op_fini ( & aop ) ; break ; } case '?' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_detail_ae ) ; break ; } default : r_core_cmd_help ( core , help_msg_ae ) ; break ; } }", ! esil ) { return ; }  r_anal_esil_to_reil_setup ( esil
475,"CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : {  int a = getnum ( L , fmt , MAXALIGN ) ;  if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment%disnotapowerof2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalidformatoption\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }"," = getnum (  fmt , MAXALIGN"
476,"CWE-119 int evutil_parse_sockaddr_port ( const char * ip_as_string , struct sockaddr * out , int * outlen ) { int port ; char buf [ 128 ] ; const char * cp , * addr_part , * port_part ; int is_ipv6 ; cp = strchr ( ip_as_string , ':' ) ; if ( * ip_as_string == '[' ) {  int len ;  if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) { return - 1 ; }  len = ( int ) ( cp - ( ip_as_string + 1 ) ) ;   if ( len > ( int ) sizeof ( buf ) - 1 ) {  return - 1 ; } memcpy ( buf , ip_as_string + 1 , len ) ; buf [ len ] = '\\0' ; addr_part = buf ; if ( cp [ 1 ] == ':' ) port_part = cp + 2 ; else port_part = NULL ; is_ipv6 = 1 ; } else if ( cp && strchr ( cp + 1 , ':' ) ) { is_ipv6 = 1 ; addr_part = ip_as_string ; port_part = NULL ; } else if ( cp ) { is_ipv6 = 0 ; if ( cp - ip_as_string > ( int ) sizeof ( buf ) - 1 ) { return - 1 ; } memcpy ( buf , ip_as_string , cp - ip_as_string ) ; buf [ cp - ip_as_string ] = '\\0' ; addr_part = buf ; port_part = cp + 1 ; } else { addr_part = ip_as_string ; port_part = NULL ; is_ipv6 = 0 ; } if ( port_part == NULL ) { port = 0 ; } else { port = atoi ( port_part ) ; if ( port <= 0 || port > 65535 ) { return - 1 ; } } if ( ! addr_part ) return - 1 ; # ifdef AF_INET6 if ( is_ipv6 ) { struct sockaddr_in6 sin6 ; memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN sin6 . sin6_len = sizeof ( sin6 ) ; # endif sin6 . sin6_family = AF_INET6 ; sin6 . sin6_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET6 , addr_part , & sin6 . sin6_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin6 ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin6 , sizeof ( sin6 ) ) ; * outlen = sizeof ( sin6 ) ; return 0 ; } else # endif { struct sockaddr_in sin ; memset ( & sin , 0 , sizeof ( sin ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_family = AF_INET ; sin . sin_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET , addr_part , & sin . sin_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin , sizeof ( sin ) ) ; * outlen = sizeof ( sin ) ; return 0 ; } }", '[' ) { size_t  len ; if  } len =  ( cp -  ( len >  sizeof ( buf
477,"CWE-200 static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = AF_TIPC ;  addr -> addrtype = TIPC_ADDR_ID ;  addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }"," addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )"
478,"CWE-119 static inline void handle_socket_receive_known ( fastd_socket_t * sock , const fastd_peer_address_t * local_addr , const fastd_peer_address_t * remote_addr , fastd_peer_t * peer , fastd_buffer_t * buffer ) { if ( ! fastd_peer_may_connect ( peer ) ) { fastd_buffer_free ( buffer ) ; return ; } const uint8_t * packet_type = buffer -> data ; switch ( * packet_type ) { case PACKET_DATA : if ( ! fastd_peer_is_established ( peer ) || ! fastd_peer_address_equal ( & peer -> local_address , local_addr ) ) { fastd_buffer_free ( buffer ) ; if ( ! backoff_unknown ( remote_addr ) ) { pr_debug ( ""unexpectedlyreceivedpayloaddatafrom%P[%I]"" , peer , remote_addr ) ; conf . protocol -> handshake_init ( sock , local_addr , remote_addr , NULL ) ; } return ; } conf . protocol -> handle_recv ( peer , buffer ) ; break ; case PACKET_HANDSHAKE : fastd_handshake_handle ( sock , local_addr , remote_addr , peer , buffer ) ;  }  }"," buffer ) ; break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( ""receivedpacketwithinvalidtypefrom%P[%I]"" , peer , remote_addr ) ;"
479,"CWE-264 static void setup_test_dir ( char * tmp_dir , const char * files , ... ) { va_list ap ; assert_se ( mkdtemp ( tmp_dir ) != NULL ) ; va_start ( ap , files ) ; while ( files != NULL ) { _cleanup_free_ char * path = strappend ( tmp_dir , files ) ;  assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ;  files = va_arg ( ap , const char * ) ; } va_end ( ap ) ; }"," , GID_INVALID , MODE_INVALID  ) == 0"
480,"CWE-125  INST_HANDLER ( lds ) {  int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , ""ram"" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( ""r%d,=,"" , d ) ; }", lds ) { if ( len < 4 ) { return ; }
481,"CWE-362 static int l2tp_ip_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) { struct sk_buff * skb ; int rc ; struct l2tp_ip_sock * lsa = l2tp_ip_sk ( sk ) ;  struct inet_sock * inet = inet_sk ( sk ) ;  struct ip_options * opt = inet -> opt ; struct rtable * rt = NULL ; int connected = 0 ; __be32 daddr ; if ( sock_flag ( sk , SOCK_DEAD ) ) return - ENOTCONN ; if ( msg -> msg_name ) { struct sockaddr_l2tpip * lip = ( struct sockaddr_l2tpip * ) msg -> msg_name ; if ( msg -> msg_namelen < sizeof ( * lip ) ) return - EINVAL ; if ( lip -> l2tp_family != AF_INET ) { if ( lip -> l2tp_family != AF_UNSPEC ) return - EAFNOSUPPORT ; } daddr = lip -> l2tp_addr . s_addr ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = inet -> inet_daddr ; connected = 1 ; } rc = - ENOMEM ; skb = sock_wmalloc ( sk , 2 + NET_SKB_PAD + sizeof ( struct iphdr ) + 4 + len , 0 , GFP_KERNEL ) ; if ( ! skb ) goto error ; skb_reserve ( skb , 2 + NET_SKB_PAD ) ; skb_reset_network_header ( skb ) ; skb_reserve ( skb , sizeof ( struct iphdr ) ) ; skb_reset_transport_header ( skb ) ; * ( ( __be32 * ) skb_put ( skb , 4 ) ) = 0 ; rc = memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ; if ( rc < 0 ) { kfree_skb ( skb ) ; goto error ; } if ( connected ) rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; if ( rt == NULL ) {  if ( opt && opt -> srr )  daddr = opt -> faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( IS_ERR ( rt ) ) goto no_route ; sk_setup_caps ( sk , & rt -> dst ) ; } skb_dst_set ( skb , dst_clone ( & rt -> dst ) ) ; rc = ip_queue_xmit ( skb ) ; error : if ( rc >= 0 ) { lsa -> tx_packets ++ ; lsa -> tx_bytes += len ; rc = len ; } else { lsa -> tx_errors ++ ; } return rc ; no_route : IP_INC_STATS ( sock_net ( sk ) , IPSTATS_MIB_OUTNOROUTES ) ; kfree_skb ( skb ) ; return - EHOSTUNREACH ; }"," ( sk )  ; struct rtable  NULL ) { struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt .  faddr ; rt"
482,"CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ;  cifs_small_buf_release ( req ) ;  rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , ""Senderrorinread=%d\\n"" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ;  * nbytes = le32_to_cpu ( rsp -> DataLength ) ;  if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , ""badlength%dforcount%d\\n"" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }", rsp_iov ) ;  rsp = (  length ) ; cifs_small_buf_release ( req ) ;
483,"CWE-119 static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( ""Warning:malformeddwarfattributecapacitydoesn\'tmatchlength\\n"" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , & da -> decls [ abbr_code - 1 ] . specs [ i ] , & cu -> dies [ cu -> length ] . attr_values [ i ] , & cu -> hdr , debug_str , debug_str_len ) ; if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ;  sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ;   }  cu -> dies [ cu -> length ] . length ++ ; } cu -> length ++ ; } return buf ; }"," . string ; if ( name > 1024 ) {  ) ; } else { eprintf ( ""Invalidstringpointerat%p\\n"" , name ) ; } }"
484,"CWE-119 int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ;  char lbase [ 256 ] ;   char strbase [ 256 ] ;   char ltest [ 256 ] ;   char strtest [ 256 ] ;  if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( ""******Parameters*********\\n"" ) ; printf ( ""base_filename=%s\\n"" ""test_filename=%s\\n"" , inParam . base_filename , inParam . test_filename ) ; printf ( ""*************************\\n"" ) ; printf ( ""Trytoopen:%sforreading..."" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; printf ( ""Trytoopen:%sforreading..."" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {  int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ;   int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ;   assert ( nbase != 255 && ntest != 255 ) ;  if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , ""couldnotparselinefromfiles\\n"" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , ""<%s>vs.<%s>\\n"" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( ""\\n*****TESTSUCCEED:Filesarethesame.*****\\n"" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }"," char lbase [ 512  ] ; char  char strbase [ 512  ] ; char  char ltest [ 512  ] ; char  char strtest [ 512  ] ; if  ( lbase , ""%511[^\\r\\n]""  , strbase )  ( ltest , ""%511[^\\r\\n]""  , strtest )  ( nbase != 511  && ntest !=  && ntest != 511  ) ; if"
485,"CWE-200 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ;  skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT ,  flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , ""%s(),Receivedtruncatedframe(%zd<%zd)!\\n"" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , ""%s(),StartingIrTTP\\n"" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }", __func__ ) ; msg -> msg_namelen = 0 ;
486,"CWE-264 static int __poke_user ( struct task_struct * child , addr_t addr , addr_t data ) { struct user * dummy = NULL ; addr_t offset ; if ( addr < ( addr_t ) & dummy -> regs . acrs ) { if ( addr == ( addr_t ) & dummy -> regs . psw . mask ) { unsigned long mask = PSW_MASK_USER ; mask |= is_ri_task ( child ) ? PSW_MASK_RI : 0 ;  if ( ( data & ~ mask ) != PSW_USER_BITS )  return - EINVAL ; if ( ( data & PSW_MASK_EA ) && ! ( data & PSW_MASK_BA ) ) return - EINVAL ; } * ( addr_t * ) ( ( addr_t ) & task_pt_regs ( child ) -> psw + addr ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . orig_gpr2 ) ) { offset = addr - ( addr_t ) & dummy -> regs . acrs ; # ifdef CONFIG_64BIT if ( addr == ( addr_t ) & dummy -> regs . acrs [ 15 ] ) child -> thread . acrs [ 15 ] = ( unsigned int ) ( data >> 32 ) ; else # endif * ( addr_t * ) ( ( addr_t ) & child -> thread . acrs + offset ) = data ; } else if ( addr == ( addr_t ) & dummy -> regs . orig_gpr2 ) { task_pt_regs ( child ) -> orig_gpr2 = data ; } else if ( addr < ( addr_t ) & dummy -> regs . fp_regs ) { return 0 ; } else if ( addr < ( addr_t ) ( & dummy -> regs . fp_regs + 1 ) ) { if ( addr == ( addr_t ) & dummy -> regs . fp_regs . fpc ) if ( ( unsigned int ) data != 0 || test_fp_ctl ( data >> ( BITS_PER_LONG - 32 ) ) ) return - EINVAL ; offset = addr - ( addr_t ) & dummy -> regs . fp_regs ; * ( addr_t * ) ( ( addr_t ) & child -> thread . fp_regs + offset ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . per_info + 1 ) ) { addr -= ( addr_t ) & dummy -> regs . per_info ; __poke_user_per ( child , addr , data ) ; } return 0 ; }", ( ( data ^ PSW_USER_BITS )  ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME  ) return -
487,"CWE-20 void xenvif_disconnect ( struct xenvif * vif ) {  struct net_device * dev = vif -> dev ;   if ( netif_carrier_ok ( dev ) ) {  rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) )  xenvif_down ( vif ) ;   rtnl_unlock ( ) ;  xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }", vif ) {  if ( netif_carrier_ok  ( netif_carrier_ok ( vif ->  dev ) )  dev ) ) xenvif_carrier_off  ( vif )  vif ) ;  atomic_dec ( &
488,CWE-400 static int xen_evtchn_cpu_prepare ( unsigned int cpu ) {  int ret = 0 ;  if ( evtchn_ops -> percpu_init ) ret = evtchn_ops -> percpu_init ( cpu ) ; return ret ; }, ret = 0 ; xen_cpu_init_eoi ( cpu )
489,"CWE-125 static const char * expr_context_name ( expr_context_ty ctx ) { switch ( ctx ) { case Load : return ""Load"" ; case Store : return ""Store"" ; case Del : return ""Del"" ; case AugLoad : return ""AugLoad"" ; case AugStore : return ""AugStore"" ; case Param : return ""Param"" ; default :  assert ( 0 ) ;  return ""(unknown)"" ; } }", ; default : abort ( )  ; } }
490,"CWE-119 void IGDstartelt ( void * d , const char * name , int l ) {  struct IGDdatas * datas = ( struct IGDdatas * ) d ;  memcpy ( datas -> cureltname , name , l ) ; datas -> cureltname [ l ] = '\\0' ; datas -> level ++ ; if ( ( l == 7 ) && ! memcmp ( name , ""service"" , l ) ) { datas -> tmp . controlurl [ 0 ] = '\\0' ; datas -> tmp . eventsuburl [ 0 ] = '\\0' ; datas -> tmp . scpdurl [ 0 ] = '\\0' ; datas -> tmp . servicetype [ 0 ] = '\\0' ; } }", * ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1
491,"CWE-119  static void  horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ;  assert ( ( cc % ( 2 * stride ) ) == 0 ) ;  if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; }  } ","   static int  horAcc16 ( TIFF  / 2 ; if  ( ( cc  stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ; return 0 ; }  if ( wc  ) ; } return 1 ;"
492,"CWE-189 void bpf_jit_compile ( struct sk_filter * fp ) { u8 temp [ 64 ] ; u8 * prog ; unsigned int proglen , oldproglen = 0 ; int ilen , i ; int t_offset , f_offset ; u8 t_op , f_op , seen = 0 , pass ; u8 * image = NULL ; u8 * func ; int pc_ret0 = - 1 ; unsigned int cleanup_addr ; unsigned int * addrs ; const struct sock_filter * filter = fp -> insns ; int flen = fp -> len ; if ( ! bpf_jit_enable ) return ; addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( addrs == NULL ) return ; for ( proglen = 0 , i = 0 ; i < flen ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } cleanup_addr = proglen ; for ( pass = 0 ; pass < 10 ; pass ++ ) { proglen = 0 ; prog = temp ; if ( seen ) { EMIT4 ( 0x55 , 0x48 , 0x89 , 0xe5 ) ; EMIT4 ( 0x48 , 0x83 , 0xec , 96 ) ; if ( seen & ( SEEN_XREG | SEEN_DATAREF ) ) EMIT4 ( 0x48 , 0x89 , 0x5d , 0xf8 ) ; if ( seen & SEEN_XREG ) CLEAR_X ( ) ; if ( seen & SEEN_DATAREF ) { if ( offsetof ( struct sk_buff , len ) <= 127 ) EMIT4 ( 0x44 , 0x8b , 0x4f , offsetof ( struct sk_buff , len ) ) ; else { EMIT3 ( 0x44 , 0x8b , 0x8f ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } if ( is_imm8 ( offsetof ( struct sk_buff , data_len ) ) ) EMIT4 ( 0x44 , 0x2b , 0x4f , offsetof ( struct sk_buff , data_len ) ) ; else { EMIT3 ( 0x44 , 0x2b , 0x8f ) ; EMIT ( offsetof ( struct sk_buff , data_len ) , 4 ) ; } if ( is_imm8 ( offsetof ( struct sk_buff , data ) ) ) EMIT4 ( 0x4c , 0x8b , 0x47 , offsetof ( struct sk_buff , data ) ) ; else { EMIT3 ( 0x4c , 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , data ) , 4 ) ; } } } switch ( filter [ 0 ] . code ) { case BPF_S_RET_K : case BPF_S_LD_W_LEN : case BPF_S_ANC_PROTOCOL : case BPF_S_ANC_IFINDEX : case BPF_S_ANC_MARK : case BPF_S_ANC_RXHASH : case BPF_S_ANC_CPU : case BPF_S_ANC_QUEUE : case BPF_S_LD_W_ABS : case BPF_S_LD_H_ABS : case BPF_S_LD_B_ABS : break ; default : CLEAR_A ( ) ; } for ( i = 0 ; i < flen ; i ++ ) { unsigned int K = filter [ i ] . k ; switch ( filter [ i ] . code ) { case BPF_S_ALU_ADD_X : seen |= SEEN_XREG ; EMIT2 ( 0x01 , 0xd8 ) ; break ; case BPF_S_ALU_ADD_K : if ( ! K ) break ; if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xc0 , K ) ; else EMIT1_off32 ( 0x05 , K ) ; break ; case BPF_S_ALU_SUB_X : seen |= SEEN_XREG ; EMIT2 ( 0x29 , 0xd8 ) ; break ; case BPF_S_ALU_SUB_K : if ( ! K ) break ; if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xe8 , K ) ; else EMIT1_off32 ( 0x2d , K ) ; break ; case BPF_S_ALU_MUL_X : seen |= SEEN_XREG ; EMIT3 ( 0x0f , 0xaf , 0xc3 ) ; break ; case BPF_S_ALU_MUL_K : if ( is_imm8 ( K ) ) EMIT3 ( 0x6b , 0xc0 , K ) ; else { EMIT2 ( 0x69 , 0xc0 ) ; EMIT ( K , 4 ) ; } break ; case BPF_S_ALU_DIV_X : seen |= SEEN_XREG ; EMIT2 ( 0x85 , 0xdb ) ; if ( pc_ret0 != - 1 ) EMIT_COND_JMP ( X86_JE , addrs [ pc_ret0 ] - ( addrs [ i ] - 4 ) ) ; else { EMIT_COND_JMP ( X86_JNE , 2 + 5 ) ; CLEAR_A ( ) ; EMIT1_off32 ( 0xe9 , cleanup_addr - ( addrs [ i ] - 4 ) ) ; } EMIT4 ( 0x31 , 0xd2 , 0xf7 , 0xf3 ) ; break ; case BPF_S_ALU_DIV_K : EMIT3 ( 0x48 , 0x69 , 0xc0 ) ; EMIT ( K , 4 ) ; EMIT4 ( 0x48 , 0xc1 , 0xe8 , 0x20 ) ; break ; case BPF_S_ALU_AND_X : seen |= SEEN_XREG ; EMIT2 ( 0x21 , 0xd8 ) ; break ; case BPF_S_ALU_AND_K : if ( K >= 0xFFFFFF00 ) { EMIT2 ( 0x24 , K & 0xFF ) ; } else if ( K >= 0xFFFF0000 ) { EMIT2 ( 0x66 , 0x25 ) ; EMIT2 ( K , 2 ) ; } else { EMIT1_off32 ( 0x25 , K ) ; } break ; case BPF_S_ALU_OR_X : seen |= SEEN_XREG ; EMIT2 ( 0x09 , 0xd8 ) ; break ; case BPF_S_ALU_OR_K : if ( is_imm8 ( K ) ) EMIT3 ( 0x83 , 0xc8 , K ) ; else EMIT1_off32 ( 0x0d , K ) ; break ; case BPF_S_ALU_LSH_X : seen |= SEEN_XREG ; EMIT4 ( 0x89 , 0xd9 , 0xd3 , 0xe0 ) ; break ; case BPF_S_ALU_LSH_K : if ( K == 0 ) break ; else if ( K == 1 ) EMIT2 ( 0xd1 , 0xe0 ) ; else EMIT3 ( 0xc1 , 0xe0 , K ) ; break ; case BPF_S_ALU_RSH_X : seen |= SEEN_XREG ; EMIT4 ( 0x89 , 0xd9 , 0xd3 , 0xe8 ) ; break ; case BPF_S_ALU_RSH_K : if ( K == 0 ) break ; else if ( K == 1 ) EMIT2 ( 0xd1 , 0xe8 ) ; else EMIT3 ( 0xc1 , 0xe8 , K ) ; break ; case BPF_S_ALU_NEG : EMIT2 ( 0xf7 , 0xd8 ) ; break ; case BPF_S_RET_K : if ( ! K ) { if ( pc_ret0 == - 1 ) pc_ret0 = i ; CLEAR_A ( ) ; } else { EMIT1_off32 ( 0xb8 , K ) ; } case BPF_S_RET_A : if ( seen ) { if ( i != flen - 1 ) { EMIT_JMP ( cleanup_addr - addrs [ i ] ) ; break ; } if ( seen & SEEN_XREG ) EMIT4 ( 0x48 , 0x8b , 0x5d , 0xf8 ) ; EMIT1 ( 0xc9 ) ; } EMIT1 ( 0xc3 ) ; break ; case BPF_S_MISC_TAX : seen |= SEEN_XREG ; EMIT2 ( 0x89 , 0xc3 ) ; break ; case BPF_S_MISC_TXA : seen |= SEEN_XREG ; EMIT2 ( 0x89 , 0xd8 ) ; break ; case BPF_S_LD_IMM : if ( ! K ) CLEAR_A ( ) ; else EMIT1_off32 ( 0xb8 , K ) ; break ; case BPF_S_LDX_IMM : seen |= SEEN_XREG ; if ( ! K ) CLEAR_X ( ) ; else EMIT1_off32 ( 0xbb , K ) ; break ; case BPF_S_LD_MEM : seen |= SEEN_MEM ; EMIT3 ( 0x8b , 0x45 , 0xf0 - K * 4 ) ; break ; case BPF_S_LDX_MEM : seen |= SEEN_XREG | SEEN_MEM ; EMIT3 ( 0x8b , 0x5d , 0xf0 - K * 4 ) ; break ; case BPF_S_ST : seen |= SEEN_MEM ; EMIT3 ( 0x89 , 0x45 , 0xf0 - K * 4 ) ; break ; case BPF_S_STX : seen |= SEEN_XREG | SEEN_MEM ; EMIT3 ( 0x89 , 0x5d , 0xf0 - K * 4 ) ; break ; case BPF_S_LD_W_LEN : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , len ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , len ) ) ) EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , len ) ) ; else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } break ; case BPF_S_LDX_W_LEN : seen |= SEEN_XREG ; if ( is_imm8 ( offsetof ( struct sk_buff , len ) ) ) EMIT3 ( 0x8b , 0x5f , offsetof ( struct sk_buff , len ) ) ; else { EMIT2 ( 0x8b , 0x9f ) ; EMIT ( offsetof ( struct sk_buff , len ) , 4 ) ; } break ; case BPF_S_ANC_PROTOCOL : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , protocol ) != 2 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , protocol ) ) ) { EMIT4 ( 0x0f , 0xb7 , 0x47 , offsetof ( struct sk_buff , protocol ) ) ; } else { EMIT3 ( 0x0f , 0xb7 , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , protocol ) , 4 ) ; } EMIT2 ( 0x86 , 0xc4 ) ; break ; case BPF_S_ANC_IFINDEX : if ( is_imm8 ( offsetof ( struct sk_buff , dev ) ) ) { EMIT4 ( 0x48 , 0x8b , 0x47 , offsetof ( struct sk_buff , dev ) ) ; } else { EMIT3 ( 0x48 , 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , dev ) , 4 ) ; } EMIT3 ( 0x48 , 0x85 , 0xc0 ) ; EMIT_COND_JMP ( X86_JE , cleanup_addr - ( addrs [ i ] - 6 ) ) ; BUILD_BUG_ON ( FIELD_SIZEOF ( struct net_device , ifindex ) != 4 ) ; EMIT2 ( 0x8b , 0x80 ) ; EMIT ( offsetof ( struct net_device , ifindex ) , 4 ) ; break ; case BPF_S_ANC_MARK : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , mark ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , mark ) ) ) { EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , mark ) ) ; } else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , mark ) , 4 ) ; } break ; case BPF_S_ANC_RXHASH : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , rxhash ) != 4 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , rxhash ) ) ) { EMIT3 ( 0x8b , 0x47 , offsetof ( struct sk_buff , rxhash ) ) ; } else { EMIT2 ( 0x8b , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , rxhash ) , 4 ) ; } break ; case BPF_S_ANC_QUEUE : BUILD_BUG_ON ( FIELD_SIZEOF ( struct sk_buff , queue_mapping ) != 2 ) ; if ( is_imm8 ( offsetof ( struct sk_buff , queue_mapping ) ) ) { EMIT4 ( 0x0f , 0xb7 , 0x47 , offsetof ( struct sk_buff , queue_mapping ) ) ; } else { EMIT3 ( 0x0f , 0xb7 , 0x87 ) ; EMIT ( offsetof ( struct sk_buff , queue_mapping ) , 4 ) ; } break ; case BPF_S_ANC_CPU : # ifdef CONFIG_SMP EMIT4 ( 0x65 , 0x8b , 0x04 , 0x25 ) ; EMIT ( ( u32 ) ( unsigned long ) & cpu_number , 4 ) ; # else CLEAR_A ( ) ; # endif break ; case BPF_S_LD_W_ABS : func = sk_load_word ; common_load : seen |= SEEN_DATAREF ; if ( ( int ) K < 0 ) goto out ; t_offset = func - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_H_ABS : func = sk_load_half ; goto common_load ; case BPF_S_LD_B_ABS : func = sk_load_byte ; goto common_load ; case BPF_S_LDX_B_MSH : if ( ( int ) K < 0 ) { if ( pc_ret0 != - 1 ) { EMIT_JMP ( addrs [ pc_ret0 ] - addrs [ i ] ) ; break ; } CLEAR_A ( ) ; EMIT_JMP ( cleanup_addr - addrs [ i ] ) ; break ; } seen |= SEEN_DATAREF | SEEN_XREG ; t_offset = sk_load_byte_msh - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_W_IND : func = sk_load_word_ind ; common_load_ind : seen |= SEEN_DATAREF | SEEN_XREG ; t_offset = func - ( image + addrs [ i ] ) ; EMIT1_off32 ( 0xbe , K ) ; EMIT1_off32 ( 0xe8 , t_offset ) ; break ; case BPF_S_LD_H_IND : func = sk_load_half_ind ; goto common_load_ind ; case BPF_S_LD_B_IND : func = sk_load_byte_ind ; goto common_load_ind ; case BPF_S_JMP_JA : t_offset = addrs [ i + K ] - addrs [ i ] ; EMIT_JMP ( t_offset ) ; break ; COND_SEL ( BPF_S_JMP_JGT_K , X86_JA , X86_JBE ) ; COND_SEL ( BPF_S_JMP_JGE_K , X86_JAE , X86_JB ) ; COND_SEL ( BPF_S_JMP_JEQ_K , X86_JE , X86_JNE ) ; COND_SEL ( BPF_S_JMP_JSET_K , X86_JNE , X86_JE ) ; COND_SEL ( BPF_S_JMP_JGT_X , X86_JA , X86_JBE ) ; COND_SEL ( BPF_S_JMP_JGE_X , X86_JAE , X86_JB ) ; COND_SEL ( BPF_S_JMP_JEQ_X , X86_JE , X86_JNE ) ; COND_SEL ( BPF_S_JMP_JSET_X , X86_JNE , X86_JE ) ; cond_branch : f_offset = addrs [ i + filter [ i ] . jf ] - addrs [ i ] ; t_offset = addrs [ i + filter [ i ] . jt ] - addrs [ i ] ; if ( filter [ i ] . jt == filter [ i ] . jf ) { EMIT_JMP ( t_offset ) ; break ; } switch ( filter [ i ] . code ) { case BPF_S_JMP_JGT_X : case BPF_S_JMP_JGE_X : case BPF_S_JMP_JEQ_X : seen |= SEEN_XREG ; EMIT2 ( 0x39 , 0xd8 ) ; break ; case BPF_S_JMP_JSET_X : seen |= SEEN_XREG ; EMIT2 ( 0x85 , 0xd8 ) ; break ; case BPF_S_JMP_JEQ_K : if ( K == 0 ) { EMIT2 ( 0x85 , 0xc0 ) ; break ; } case BPF_S_JMP_JGT_K : case BPF_S_JMP_JGE_K : if ( K <= 127 ) EMIT3 ( 0x83 , 0xf8 , K ) ; else EMIT1_off32 ( 0x3d , K ) ; break ; case BPF_S_JMP_JSET_K : if ( K <= 0xFF ) EMIT2 ( 0xa8 , K ) ; else if ( ! ( K & 0xFFFF00FF ) ) EMIT3 ( 0xf6 , 0xc4 , K >> 8 ) ; else if ( K <= 0xFFFF ) { EMIT2 ( 0x66 , 0xa9 ) ; EMIT ( K , 2 ) ; } else { EMIT1_off32 ( 0xa9 , K ) ; } break ; } if ( filter [ i ] . jt != 0 ) {  if ( filter [ i ] . jf )   t_offset += is_near ( f_offset ) ? 2 : 6 ;  EMIT_COND_JMP ( t_op , t_offset ) ; if ( filter [ i ] . jf ) EMIT_JMP ( f_offset ) ; break ; } EMIT_COND_JMP ( f_op , f_offset ) ; break ; default : goto out ; } ilen = prog - temp ; if ( image ) { if ( unlikely ( proglen + ilen > oldproglen ) ) { pr_err ( ""bpb_jit_compilefatalerror\\n"" ) ; kfree ( addrs ) ; module_free ( NULL , image ) ; return ; } memcpy ( image + proglen , temp , ilen ) ; } proglen += ilen ; addrs [ i ] = proglen ; prog = temp ; } cleanup_addr = proglen - 1 ; if ( seen ) cleanup_addr -= 1 ; if ( seen & SEEN_XREG ) cleanup_addr -= 4 ; if ( image ) { WARN_ON ( proglen != oldproglen ) ; break ; } if ( proglen == oldproglen ) { image = module_alloc ( max_t ( unsigned int , proglen , sizeof ( struct work_struct ) ) ) ; if ( ! image ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) pr_err ( ""flen=%dproglen=%upass=%dimage=%p\\n"" , flen , proglen , pass , image ) ; if ( image ) { if ( bpf_jit_enable > 1 ) print_hex_dump ( KERN_ERR , ""JITcode:"" , DUMP_PREFIX_ADDRESS , 16 , 1 , image , proglen , false ) ; bpf_flush_icache ( image , image + proglen ) ; fp -> bpf_func = ( void * ) image ; } out : kfree ( addrs ) ; return ; }", ] . jf && f_offset  ? 2 : 5  ; EMIT_COND_JMP (
493,"CWE-119 static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ;  int err = - EIO ;  unsigned char * p = kmap ( page ) ; struct udf_inode_info * iinfo ;  uint32_t pos ;  iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ;  if ( ! bh )  goto out ; symlink = bh -> b_data ; } udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; brelse ( bh ) ; up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ;  out :  up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ;  kunmap ( page ) ;  unlock_page ( page ) ; return err ; }", ; int err  ; unsigned char  uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; }  ! bh ) { err = - EIO ; goto out_unlock_inode ; }  symlink = bh  return 0 ; out_unlock_inode  : up_read (  page ) ; out_unmap :
494,"CWE-416 int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ;  io -> io_cleanup = port_cleanup ;  switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , ""Invalidregistersize:%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } }  return 0 ;  }", - ENODEV ;  switch ( io  ; } } io -> io_cleanup = port_cleanup ;
495,"CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) {  assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ;  ( void ) memcpy ( ( ( char * ) buf ) + offs ,  ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ;  return len ; }"," id ) { size_t ss =  CDF_SHORT_SEC_SIZE ( h  ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss  len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""badsectorid%d>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; }  sst_tab ) + pos  , len )"
496,"CWE-000 static void ext4_end_io_dio ( struct kiocb * iocb , loff_t offset , ssize_t size , void * private ) { ext4_io_end_t * io_end = iocb -> private ; struct workqueue_struct * wq ;  if ( ! io_end || ! size )  return ; ext_debug ( ""ext4_end_io_dio():io_end0x%p"" ""forinode%lu,iocb0x%p,offset%llu,size%llu\\n"" , iocb -> private , io_end -> inode -> i_ino , iocb , offset , size ) ; if ( io_end -> flag != EXT4_IO_UNWRITTEN ) { ext4_free_io_end ( io_end ) ; iocb -> private = NULL ; return ; } io_end -> offset = offset ; io_end -> size = size ;  wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ;  queue_work ( wq , & io_end -> work ) ;  list_add_tail ( & io_end -> list ,   & EXT4_I ( io_end -> inode ) -> i_completed_io_list ) ;  iocb -> private = NULL ; }"," * wq ; unsigned long flags ; struct ext4_inode_info * ei ;  = size ; io_end -> flag = EXT4_IO_UNWRITTEN ;  work ) ; ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ;  -> list , & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags  ) ; iocb"
497,"CWE-763 static int pcrypt_create_aead ( struct crypto_template * tmpl , struct rtattr * * tb , u32 type , u32 mask ) { struct pcrypt_instance_ctx * ctx ; struct crypto_attr_type * algt ; struct aead_instance * inst ; struct aead_alg * alg ; const char * name ; int err ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) ) return PTR_ERR ( algt ) ; name = crypto_attr_alg_name ( tb [ 1 ] ) ; if ( IS_ERR ( name ) ) return PTR_ERR ( name ) ; inst = kzalloc ( sizeof ( * inst ) + sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! inst ) return - ENOMEM ; ctx = aead_instance_ctx ( inst ) ; crypto_set_aead_spawn ( & ctx -> spawn , aead_crypto_instance ( inst ) ) ; err = crypto_grab_aead ( & ctx -> spawn , name , 0 , 0 ) ; if ( err ) goto out_free_inst ; alg = crypto_spawn_aead_alg ( & ctx -> spawn ) ; err = pcrypt_init_instance ( aead_crypto_instance ( inst ) , & alg -> base ) ; if ( err ) goto out_drop_aead ; inst -> alg . base . cra_flags = CRYPTO_ALG_ASYNC ; inst -> alg . ivsize = crypto_aead_alg_ivsize ( alg ) ; inst -> alg . maxauthsize = crypto_aead_alg_maxauthsize ( alg ) ; inst -> alg . base . cra_ctxsize = sizeof ( struct pcrypt_aead_ctx ) ; inst -> alg . init = pcrypt_aead_init_tfm ; inst -> alg . exit = pcrypt_aead_exit_tfm ; inst -> alg . setkey = pcrypt_aead_setkey ; inst -> alg . setauthsize = pcrypt_aead_setauthsize ; inst -> alg . encrypt = pcrypt_aead_encrypt ; inst -> alg . decrypt = pcrypt_aead_decrypt ;  err = aead_register_instance ( tmpl , inst ) ;  if ( err ) goto out_drop_aead ; out : return err ; out_drop_aead : crypto_drop_aead ( & ctx -> spawn ) ; out_free_inst : kfree ( inst ) ; goto out ; }", = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
498,"CWE-415 static int sg_common_write ( Sg_fd * sfp , Sg_request * srp , unsigned char * cmnd , int timeout , int blocking ) { int k , at_head ; Sg_device * sdp = sfp -> parentdp ; sg_io_hdr_t * hp = & srp -> header ; srp -> data . cmd_opcode = cmnd [ 0 ] ; hp -> status = 0 ; hp -> masked_status = 0 ; hp -> msg_status = 0 ; hp -> info = 0 ; hp -> host_status = 0 ; hp -> driver_status = 0 ; hp -> resid = 0 ; SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sfp -> parentdp , ""sg_common_write:scsiopcode=0x%02x,cmd_size=%d\\n"" , ( int ) cmnd [ 0 ] , ( int ) hp -> cmd_len ) ) ; k = sg_start_req ( srp , cmnd ) ; if ( k ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sfp -> parentdp , ""sg_common_write:start_reqerr=%d\\n"" , k ) ) ; sg_finish_rem_req ( srp ) ; return k ; } if ( atomic_read ( & sdp -> detaching ) ) {  if ( srp -> bio )   blk_end_request_all ( srp -> rq , - EIO ) ;  sg_finish_rem_req ( srp ) ; return - ENODEV ; } hp -> duration = jiffies_to_msecs ( jiffies ) ; if ( hp -> interface_id != '\\0' && ( SG_FLAG_Q_AT_TAIL & hp -> flags ) ) at_head = 0 ; else at_head = 1 ; srp -> rq -> timeout = timeout ; kref_get ( & sfp -> f_ref ) ; blk_execute_rq_nowait ( sdp -> device -> request_queue , sdp -> disk , srp -> rq , at_head , sg_rq_end_io ) ; return 0 ; }", -> bio ) { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ;  EIO ) ; srp -> rq = NULL ; }
499,"CWE-20 int cifs_mount ( struct super_block * sb , struct cifs_sb_info * cifs_sb , char * mount_data_global , const char * devname ) { int rc ; int xid ; struct smb_vol * volume_info ; struct cifsSesInfo * pSesInfo ; struct cifsTconInfo * tcon ; struct TCP_Server_Info * srvTcp ; char * full_path ; char * mount_data = mount_data_global ; struct tcon_link * tlink ; # ifdef CONFIG_CIFS_DFS_UPCALL struct dfs_info3_param * referrals = NULL ; unsigned int num_referrals = 0 ; int referral_walks_count = 0 ; try_mount_again : # endif rc = 0 ; tcon = NULL ; pSesInfo = NULL ; srvTcp = NULL ; full_path = NULL ; tlink = NULL ; xid = GetXid ( ) ; volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ) ; if ( ! volume_info ) { rc = - ENOMEM ; goto out ; } if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) ) { rc = - EINVAL ; goto out ; } if ( volume_info -> nullauth ) { cFYI ( 1 , ""nulluser"" ) ; volume_info -> username = """" ; } else if ( volume_info -> username ) { cFYI ( 1 , ""Username:%s"" , volume_info -> username ) ; } else { cifserror ( ""Nousernamespecified"" ) ; rc = - EINVAL ; goto out ; } if ( volume_info -> iocharset == NULL ) { volume_info -> local_nls = load_nls_default ( ) ; } else { volume_info -> local_nls = load_nls ( volume_info -> iocharset ) ; if ( volume_info -> local_nls == NULL ) { cERROR ( 1 , ""CIFSmounterror:iocharset%snotfound"" , volume_info -> iocharset ) ; rc = - ELIBACC ; goto out ; } } cifs_sb -> local_nls = volume_info -> local_nls ; srvTcp = cifs_get_tcp_session ( volume_info ) ; if ( IS_ERR ( srvTcp ) ) { rc = PTR_ERR ( srvTcp ) ; goto out ; } pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ) ; if ( IS_ERR ( pSesInfo ) ) { rc = PTR_ERR ( pSesInfo ) ; pSesInfo = NULL ; goto mount_fail_check ; } setup_cifs_sb ( volume_info , cifs_sb ) ; if ( pSesInfo -> capabilities & CAP_LARGE_FILES ) sb -> s_maxbytes = MAX_LFS_FILESIZE ; else sb -> s_maxbytes = MAX_NON_LFS ; sb -> s_time_gran = 100 ; tcon = cifs_get_tcon ( pSesInfo , volume_info ) ; if ( IS_ERR ( tcon ) ) { rc = PTR_ERR ( tcon ) ; tcon = NULL ; goto remote_path_check ; } if ( ! tcon -> ipc ) { CIFSSMBQFSDeviceInfo ( xid , tcon ) ; CIFSSMBQFSAttributeInfo ( xid , tcon ) ; } if ( tcon -> ses -> capabilities & CAP_UNIX ) reset_cifs_unix_caps ( xid , tcon , sb , volume_info ) ; else tcon -> unix_ext = 0 ; if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) ) { cifs_sb -> rsize = 1024 * 127 ; cFYI ( DBG2 , ""noverylargereadsupport,rsizenow127K"" ) ; } if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) ) cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) ) cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; remote_path_check :  if ( ! rc && cifs_sb -> prepathlen && tcon ) {  full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto mount_fail_check ; } rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ) ; if ( rc != 0 && rc != - EREMOTE ) { kfree ( full_path ) ; goto mount_fail_check ; } kfree ( full_path ) ; } if ( rc == - EREMOTE ) { # ifdef CONFIG_CIFS_DFS_UPCALL if ( referral_walks_count > MAX_NESTED_LINKS ) { rc = - ELOOP ; goto mount_fail_check ; } if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; full_path = build_unc_path_to_root ( volume_info , cifs_sb ) ; if ( IS_ERR ( full_path ) ) { rc = PTR_ERR ( full_path ) ; goto mount_fail_check ; } cFYI ( 1 , ""Gettingreferralfor:%s"" , full_path ) ; rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ) ; if ( ! rc && num_referrals > 0 ) { char * fake_devname = NULL ; if ( mount_data != mount_data_global ) kfree ( mount_data ) ; mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ) ; free_dfs_info_array ( referrals , num_referrals ) ; kfree ( fake_devname ) ; kfree ( full_path ) ; if ( IS_ERR ( mount_data ) ) { rc = PTR_ERR ( mount_data ) ; mount_data = NULL ; goto mount_fail_check ; } if ( tcon ) cifs_put_tcon ( tcon ) ; else if ( pSesInfo ) cifs_put_smb_ses ( pSesInfo ) ; cleanup_volume_info ( & volume_info ) ; referral_walks_count ++ ; FreeXid ( xid ) ; goto try_mount_again ; } # else rc = - EOPNOTSUPP ; # endif } if ( rc ) goto mount_fail_check ; tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ) ; if ( tlink == NULL ) { rc = - ENOMEM ; goto mount_fail_check ; } tlink -> tl_uid = pSesInfo -> linux_uid ; tlink -> tl_tcon = tcon ; tlink -> tl_time = jiffies ; set_bit ( TCON_LINK_MASTER , & tlink -> tl_flags ) ; set_bit ( TCON_LINK_IN_TREE , & tlink -> tl_flags ) ; cifs_sb -> master_tlink = tlink ; spin_lock ( & cifs_sb -> tlink_tree_lock ) ; tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ) ; spin_unlock ( & cifs_sb -> tlink_tree_lock ) ; queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ) ; mount_fail_check : if ( rc ) { if ( mount_data != mount_data_global ) kfree ( mount_data ) ; if ( tcon ) cifs_put_tcon ( tcon ) ; else if ( pSesInfo ) cifs_put_smb_ses ( pSesInfo ) ; else cifs_put_tcp_session ( srvTcp ) ; goto out ; } out : cleanup_volume_info ( & volume_info ) ; FreeXid ( xid ) ; return rc ; }", ( ! rc  && tcon )
500,"CWE-252 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] ; FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } pwp_image = image ; memset ( magick , 0 , sizeof ( magick ) ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""sfw:%s"" , filename ) ; for ( ; ; ) { ( void ) memset ( magick , 0 , sizeof ( magick ) ) ; for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; if ( c == EOF ) break ;  ( void ) fputc ( c , file ) ;  } ( void ) fclose ( file ) ; if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image != ( Image * ) NULL ) { if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; } return ( GetFirstImageInList ( image ) ) ; }"," ) break ; if (  fputc ( c  , file ) != c ) break"
501,"CWE-200 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unabletogethostname"" ) ; goto done ; } DBG ( ""Originnotspecified,using\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unabletoallocatememory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appidnotspecified,usingthesamevalueoforigin(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unabletoallocatememory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximumdevicesnumbernotset.Usingdefault(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unabletoallocatememory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unabletoaccessuser%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requestingauthenticationforuser%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unabletoretrievecredentialsforuser%s,(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Founduser%s"" , user ) ; DBG ( ""Homedirectoryfor%sis%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable%sisnotset.Usingdefaultvalue($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unabletoallocatememory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable%ssetto%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unabletoallocatememory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Usingdefaultauthenticationfile%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Usingauthenticationfile%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unabletoswitchusertouid%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switchedtouid%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unabletoswitchbacktouid0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switchedbacktouid0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Foundnodevicesbutnouserokspecified.Skippingauthentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unabletogetdevicesfromfile%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Foundnodevices.Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unabletoallocatememoryfortheauthpending_file,touchrequestnotificationswillnotbeemitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_fileissettoanemptyvalue,touchrequestnotificationswillbedisabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Usingfile\'%s\'foremittingtouchrequestnotifications"" , cfg -> authpending_file ) ;  authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ;  if ( authpending_file_descriptor < 0 ) { DBG ( ""Unabletoemit\'authenticationstarted\'notificationbyopeningthefile\'%s\',(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unabletoemit\'authenticationstopped\'notificationbyclosingthefile\'%s\',(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authenticationreturned%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysokneeded(otherwisereturnwith%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.[%s]"" , pam_strerror ( pamh , retval ) ) ;  return retval ;  }", O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY  ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
502,"CWE-787  static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) {  * out ++ = value ;  left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; }  FillMemory ( out , len , value ) ;  out += len ; left -= len ; } else {  * out ++ = value ;  left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }","   static BOOL  nsc_rle_decode ( BYTE  BYTE * out , UINT32 outSize  5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ;  4 ; } if ( outSize < len ) return FALSE ; outSize -= len ;  } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE  ; } "
503,"CWE-787  static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {  size_t bit ; ssize_t x ;   register Quantum * q ;  Quantum index ; index = 0 ;  switch ( depth )  { case 1 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;  if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) {  index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) {  for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ )  {  index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  } p ++ ; }  ( void ) SyncAuthenticPixels ( image , exception ) ;  break ; } case 2 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;   if ( q == ( Quantum * ) NULL )  break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) {  index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;   index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;  index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) {  index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;  SetPixelIndex ( image , index , q ) ;  q += GetPixelChannels ( image ) ;   p ++ ;  } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : {  q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;   if ( q == ( Quantum * ) NULL )  break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) {  index = ConstrainColormapIndex ( image , * p , exception ) ;  SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }","   static MagickBooleanType  InsertRow ( Image  image , ssize_t bpp  , unsigned char  exception ) { int bit ; Quantum index  ; register Quantum  ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse )  ; switch (  ; switch ( bpp  ) { case  1 : {  for ( x  index = (  ( * p  0x80 >> bit  ) ? 0x01  q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;  bit < ( ssize_t ) (  index = (  ( * p  0x80 >> bit  ) ? 0x01  q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;  ++ ; }  break ; }  2 : { for ( x = 0 ; x < ( ( ssize_t )  image -> columns  image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3  , exception )  exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : {  for ( x  * p >> 4 ) & 0x0f  , exception )  q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;  ( * p ) & 0x0f  , exception )  q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ;  ( image )  ; } if  4 ) & 0x0f  , exception )  q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ;  image ) ; }  break ; }  8 : { for ( x = 0 ; x < ( ssize_t )  image -> columns  image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p  , exception )  exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 :  for ( x  ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image  , exception )  , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ;  }  "
504,"CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ; rc = - EADDRNOTAVAIL ; if ( ! ipxif ) break ; sipx -> sipx_family = AF_IPX ; sipx -> sipx_network = ipxif -> if_netnum ; memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ;  rc = - EFAULT ;   if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) )  break ;  ipxitf_put ( ipxif ) ;  rc = 0 ; break ; } case SIOCAIPXITFCRT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_auto_create_interfaces = val ; break ; case SIOCAIPXPRISLT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_set_auto_select ( val ) ; break ; } return rc ; }"," ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc =  - EFAULT ;  ipxitf_put ( ipxif  ( ipxif )  ; break ;"
505,"CWE-125 static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ;  for ( i = 0 ; i <= SERDES_MAX ; i ++ ) {  struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }", 0 ; i <  SERDES_MAX ; i
506,"CWE-20 static int ovl_remove_upper ( struct dentry * dentry , bool is_dir ) { struct dentry * upperdir = ovl_dentry_upper ( dentry -> d_parent ) ; struct inode * dir = upperdir -> d_inode ;  struct dentry * upper = ovl_dentry_upper ( dentry ) ;  int err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ;  err = - ESTALE ;   if ( upper -> d_parent == upperdir ) {  dget ( upper ) ; if ( is_dir ) err = vfs_rmdir ( dir , upper ) ; else err = vfs_unlink ( dir , upper , NULL ) ;  dput ( upper ) ;  ovl_dentry_version_inc ( dentry -> d_parent ) ;  }  if ( ! err ) d_drop ( dentry ) ;  inode_unlock ( dir ) ;  return err ; }"," dentry * upper  ; int err  I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ;  if ( upper == ovl_dentry_upper ( dentry ) ) {  if ( is_dir  NULL ) ;  ovl_dentry_version_inc ( dentry  ) ; } dput ( upper ) ;  dentry ) ; out_unlock :"
507,"CWE-399 long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = NULL ; struct eventfd_ctx * ctx = NULL ; u64 p ; long r ; int i , fd ; if ( ioctl == VHOST_SET_OWNER ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case VHOST_SET_MEM_TABLE : r = vhost_set_memory ( d , argp ) ; break ; case VHOST_SET_LOG_BASE : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - EFAULT ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - EFAULT ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - EFAULT ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case VHOST_SET_LOG_FD : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; if ( IS_ERR ( eventfp ) ) { r = PTR_ERR ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ;  ctx = d -> log_ctx ;  d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ; } else filep = eventfp ; for ( i = 0 ; i < d -> nvqs ; ++ i ) { mutex_lock ( & d -> vqs [ i ] -> mutex ) ; d -> vqs [ i ] -> log_ctx = d -> log_ctx ; mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; } if ( ctx ) eventfd_ctx_put ( ctx ) ; if ( filep ) fput ( filep ) ; break ; default : r = - ENOIOCTLCMD ; break ; } done : return r ; }", -> log_file ; d -> log_file = eventfp ;
508,"CWE-17  int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname ,   int flen )  { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ;  if ( udf_build_ustr_exact ( unifilename , sname , flen ) )  goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( ""Failedinudf_get_filename:sname=%s\\n"" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( ""Failedinudf_get_filename:sname=%s\\n"" , sname ) ; goto out2 ; } } else goto out2 ;  len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len ,  unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }"," * sname , int slen ,  * dname , int dlen  ) { struct  , sname , slen  ) ) goto  ( dname , dlen ,"
509,"CWE-20 static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = CHECKSUM_NONE ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - EMSGSIZE ; } if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & MSG_MORE ) && rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) csummode = CHECKSUM_PARTIAL ; if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ;  if ( transhdrlen ) {  skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; }  copy = datalen - transhdrlen - fraggap ;  if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }"," frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; }  ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen  , offset ,"
510,"CWE-416 struct sk_buff * skb_segment ( struct sk_buff * head_skb , netdev_features_t features ) { struct sk_buff * segs = NULL ; struct sk_buff * tail = NULL ; struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ; skb_frag_t * frag = skb_shinfo ( head_skb ) -> frags ; unsigned int mss = skb_shinfo ( head_skb ) -> gso_size ;  unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ;  unsigned int offset = doffset ; unsigned int tnl_hlen = skb_tnl_header_len ( head_skb ) ; unsigned int headroom ; unsigned int len ; __be16 proto ; bool csum ; int sg = ! ! ( features & NETIF_F_SG ) ; int nfrags = skb_shinfo ( head_skb ) -> nr_frags ; int err = - ENOMEM ; int i = 0 ; int pos ; proto = skb_network_protocol ( head_skb ) ; if ( unlikely ( ! proto ) ) return ERR_PTR ( - EINVAL ) ; csum = ! ! can_checksum_protocol ( features , proto ) ; __skb_push ( head_skb , doffset ) ; headroom = skb_headroom ( head_skb ) ; pos = skb_headlen ( head_skb ) ; do { struct sk_buff * nskb ; skb_frag_t * nskb_frag ; int hsize ; int size ; len = head_skb -> len - offset ; if ( len > mss ) len = mss ; hsize = skb_headlen ( head_skb ) - offset ; if ( hsize < 0 ) hsize = 0 ; if ( hsize > len || ! sg ) hsize = len ; if ( ! hsize && i >= nfrags && skb_headlen ( list_skb ) && ( skb_headlen ( list_skb ) == len || sg ) ) { BUG_ON ( skb_headlen ( list_skb ) > len ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ;  pos += skb_headlen ( list_skb ) ;  while ( pos < offset + len ) { BUG_ON ( i >= nfrags ) ; size = skb_frag_size ( frag ) ; if ( pos + size > offset + len ) break ; i ++ ; pos += size ; frag ++ ; } nskb = skb_clone ( list_skb , GFP_ATOMIC ) ; list_skb = list_skb -> next ; if ( unlikely ( ! nskb ) ) goto err ; if ( unlikely ( pskb_trim ( nskb , len ) ) ) { kfree_skb ( nskb ) ; goto err ; } hsize = skb_end_offset ( nskb ) ; if ( skb_cow_head ( nskb , doffset + headroom ) ) { kfree_skb ( nskb ) ; goto err ; } nskb -> truesize += skb_end_offset ( nskb ) - hsize ; skb_release_head_state ( nskb ) ; __skb_push ( nskb , doffset ) ; } else { nskb = __alloc_skb ( hsize + doffset + headroom , GFP_ATOMIC , skb_alloc_rx_flag ( head_skb ) , NUMA_NO_NODE ) ; if ( unlikely ( ! nskb ) ) goto err ; skb_reserve ( nskb , headroom ) ; __skb_put ( nskb , doffset ) ; } if ( segs ) tail -> next = nskb ; else segs = nskb ; tail = nskb ; __copy_skb_header ( nskb , head_skb ) ; nskb -> mac_len = head_skb -> mac_len ; skb_headers_offset_update ( nskb , skb_headroom ( nskb ) - headroom ) ; skb_copy_from_linear_data_offset ( head_skb , - tnl_hlen , nskb -> data - tnl_hlen , doffset + tnl_hlen ) ; if ( nskb -> len == len + doffset ) goto perform_csum_check ; if ( ! sg ) { nskb -> ip_summed = CHECKSUM_NONE ; nskb -> csum = skb_copy_and_csum_bits ( head_skb , offset , skb_put ( nskb , len ) , len , 0 ) ; continue ; } nskb_frag = skb_shinfo ( nskb ) -> frags ; skb_copy_from_linear_data_offset ( head_skb , offset , skb_put ( nskb , hsize ) , hsize ) ; skb_shinfo ( nskb ) -> tx_flags = skb_shinfo ( head_skb ) -> tx_flags & SKBTX_SHARED_FRAG ; while ( pos < offset + len ) { if ( i >= nfrags ) { BUG_ON ( skb_headlen ( list_skb ) ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ;  BUG_ON ( ! nfrags ) ;  list_skb = list_skb -> next ; } if ( unlikely ( skb_shinfo ( nskb ) -> nr_frags >= MAX_SKB_FRAGS ) ) { net_warn_ratelimited ( ""skb_segment:toomanyfrags:%u%u\\n"" , pos , mss ) ; goto err ; }  * nskb_frag = * frag ;  __skb_frag_ref ( nskb_frag ) ; size = skb_frag_size ( nskb_frag ) ; if ( pos < offset ) { nskb_frag -> page_offset += offset - pos ; skb_frag_size_sub ( nskb_frag , offset - pos ) ; } skb_shinfo ( nskb ) -> nr_frags ++ ; if ( pos + size <= offset + len ) { i ++ ; frag ++ ; pos += size ; } else { skb_frag_size_sub ( nskb_frag , pos + size - ( offset + len ) ) ; goto skip_fraglist ; } nskb_frag ++ ; } skip_fraglist : nskb -> data_len = len - hsize ; nskb -> len += nskb -> data_len ; nskb -> truesize += nskb -> data_len ; perform_csum_check : if ( ! csum ) { nskb -> csum = skb_checksum ( nskb , doffset , nskb -> len - doffset , 0 ) ; nskb -> ip_summed = CHECKSUM_NONE ; } } while ( ( offset += len ) < head_skb -> len ) ; return segs ; err : kfree_skb_list ( segs ) ; return ERR_PTR ( err ) ; }"," ( head_skb ) ; struct sk_buff * frag_skb = head_skb  -> frags ; frag_skb = list_skb ;  -> frags ; frag_skb = list_skb ;  err ; } if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;"
511,CWE-119 SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) {  return in ;  } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }, ) { return NULL  ; } while
512,"CWE-400 struct mnt_namespace * copy_mnt_ns ( unsigned long flags , struct mnt_namespace * ns , struct user_namespace * user_ns , struct fs_struct * new_fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old ; struct mount * new ; int copy_flags ; BUG_ON ( ! ns ) ; if ( likely ( ! ( flags & CLONE_NEWNS ) ) ) { get_mnt_ns ( ns ) ; return ns ; } old = ns -> root ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; namespace_lock ( ) ; copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE ; if ( user_ns != ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ; new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { namespace_unlock ( ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ;  if ( new_fs ) {  if ( & p -> mnt == new_fs -> root . mnt ) { new_fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == new_fs -> pwd . mnt ) { new_fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; if ( ! q ) break ; while ( p -> mnt . mnt_root != q -> mnt . mnt_root ) p = next_mnt ( p , old ) ; } namespace_unlock ( ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }", = new_ns ; new_ns -> mounts ++ ;
513,"CWE-399 static gdImagePtr gdImageScaleTwoPass ( const gdImagePtr src , const unsigned int new_width , const unsigned int new_height ) { const unsigned int src_width = src -> sx ; const unsigned int src_height = src -> sy ; gdImagePtr tmp_im = NULL ; gdImagePtr dst = NULL ; if ( src_width == new_width && src_height == new_height ) { return gdImageClone ( src ) ; } if ( ! src -> trueColor ) { gdImagePaletteToTrueColor ( src ) ; } if ( src_width == new_width ) { tmp_im = src ; } else { tmp_im = gdImageCreateTrueColor ( new_width , src_height ) ; if ( tmp_im == NULL ) { return NULL ; } gdImageSetInterpolationMethod ( tmp_im , src -> interpolation_id ) ; _gdScalePass ( src , src_width , tmp_im , new_width , src_height , HORIZONTAL ) ; } if ( src_height == new_height ) { assert ( tmp_im != src ) ; return tmp_im ; } dst = gdImageCreateTrueColor ( new_width , new_height ) ; if ( dst != NULL ) { gdImageSetInterpolationMethod ( dst , src -> interpolation_id ) ; _gdScalePass ( tmp_im , src_height , dst , new_height , new_width , VERTICAL ) ; } if ( src != tmp_im ) {  gdFree ( tmp_im ) ;  } return dst ; }", tmp_im ) { gdImageDestroy  ( tmp_im )
514,"CWE-772 chrand_ret * chrand_principal_2_svc ( chrand_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_randkey_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , & k , & nkeys ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_randkey_principal ( ( void * ) handle , arg -> princ , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code == KADM5_OK ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }"," ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER  ; OM_uint32 minor_stat  prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ;  free_server_handle ( handle"
515,"CWE-125 static int mp_join_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_join * mpj = ( const struct mp_join * ) opt ;  if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) &&  ! ( opt_len == 24 && flags & TH_ACK ) )  return 0 ; if ( opt_len != 24 ) { if ( mpj -> sub_b & MP_JOIN_B ) ND_PRINT ( ( ndo , ""backup"" ) ) ; ND_PRINT ( ( ndo , ""id%u"" , mpj -> addr_id ) ) ; } switch ( opt_len ) { case 12 : ND_PRINT ( ( ndo , ""token0x%x"" ""nonce0x%x"" , EXTRACT_32BITS ( mpj -> u . syn . token ) , EXTRACT_32BITS ( mpj -> u . syn . nonce ) ) ) ; break ; case 16 : ND_PRINT ( ( ndo , ""hmac0x%"" PRIx64 ""nonce0x%x"" , EXTRACT_64BITS ( mpj -> u . synack . mac ) , EXTRACT_32BITS ( mpj -> u . synack . nonce ) ) ) ; break ; case 24 : { size_t i ; ND_PRINT ( ( ndo , ""hmac0x"" ) ) ; for ( i = 0 ; i < sizeof ( mpj -> u . ack . mac ) ; ++ i ) ND_PRINT ( ( ndo , ""%02x"" , mpj -> u . ack . mac [ i ] ) ) ; } default : break ; } return 1 ; }", == 12 && (  & TH_SYN ) )  == 24 && (  flags & TH_ACK )
516,"CWE-444 static ngx_int_t ngx_http_lua_adjust_subrequest ( ngx_http_request_t * sr , ngx_uint_t method , int always_forward_body , ngx_http_request_body_t * body , unsigned vars_action , ngx_array_t * extra_vars ) { ngx_http_request_t * r ;  ngx_int_t rc ;  ngx_http_core_main_conf_t * cmcf ;  size_t size ;  r = sr -> parent ; sr -> header_in = r -> header_in ; if ( body ) { sr -> request_body = body ;  rc = ngx_http_lua_set_content_length_header ( sr ,  body -> buf ? ngx_buf_size ( body -> buf ) : 0 ) ; if ( rc != NGX_OK ) { return NGX_ERROR ; } } else if ( ! always_forward_body && method != NGX_HTTP_PUT && method != NGX_HTTP_POST && r -> headers_in . content_length_n > 0 ) {  rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ;  if ( rc != NGX_OK ) { return NGX_ERROR ; }  # if 1  sr -> request_body = NULL ; # endif } else {  if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) {  return NGX_ERROR ;  }  if ( sr -> request_body ) { if ( sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) != NGX_OK ) { return NGX_ERROR ; } } } } sr -> method = method ; switch ( method ) { case NGX_HTTP_GET : sr -> method_name = ngx_http_lua_get_method ; break ; case NGX_HTTP_POST : sr -> method_name = ngx_http_lua_post_method ; break ; case NGX_HTTP_PUT : sr -> method_name = ngx_http_lua_put_method ; break ; case NGX_HTTP_HEAD : sr -> method_name = ngx_http_lua_head_method ; break ; case NGX_HTTP_DELETE : sr -> method_name = ngx_http_lua_delete_method ; break ; case NGX_HTTP_OPTIONS : sr -> method_name = ngx_http_lua_options_method ; break ; case NGX_HTTP_MKCOL : sr -> method_name = ngx_http_lua_mkcol_method ; break ; case NGX_HTTP_COPY : sr -> method_name = ngx_http_lua_copy_method ; break ; case NGX_HTTP_MOVE : sr -> method_name = ngx_http_lua_move_method ; break ; case NGX_HTTP_PROPFIND : sr -> method_name = ngx_http_lua_propfind_method ; break ; case NGX_HTTP_PROPPATCH : sr -> method_name = ngx_http_lua_proppatch_method ; break ; case NGX_HTTP_LOCK : sr -> method_name = ngx_http_lua_lock_method ; break ; case NGX_HTTP_UNLOCK : sr -> method_name = ngx_http_lua_unlock_method ; break ; case NGX_HTTP_PATCH : sr -> method_name = ngx_http_lua_patch_method ; break ; case NGX_HTTP_TRACE : sr -> method_name = ngx_http_lua_trace_method ; break ; default : ngx_log_error ( NGX_LOG_ERR , r -> connection -> log , 0 , ""unsupportedHTTPmethod:%u"" , ( unsigned ) method ) ; return NGX_ERROR ; } if ( ! ( vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS ) ) { cmcf = ngx_http_get_module_main_conf ( sr , ngx_http_core_module ) ; size = cmcf -> variables . nelts * sizeof ( ngx_http_variable_value_t ) ; if ( vars_action & NGX_HTTP_LUA_COPY_ALL_VARS ) { sr -> variables = ngx_palloc ( sr -> pool , size ) ; if ( sr -> variables == NULL ) { return NGX_ERROR ; } ngx_memcpy ( sr -> variables , r -> variables , size ) ; } else { sr -> variables = ngx_pcalloc ( sr -> pool , size ) ; if ( sr -> variables == NULL ) { return NGX_ERROR ; } } } return ngx_http_lua_subrequest_add_extra_vars ( sr , extra_vars ) ; }"," * r ;  ngx_http_core_main_conf_t * cmcf  * cmcf ; int pr_not_chunked = 0 ;  = body ;  } else if  0 ) { sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr )  != NGX_OK )  NGX_ERROR ; } } }  if ( ngx_http_lua_copy_request_headers  sr , r , pr_not_chunked  return NGX_ERROR ;  } sr ->"
517,"CWE-119 static Image * ReadFITSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct _FITSInfo { MagickBooleanType extend , simple ; int bits_per_pixel , columns , rows , number_axes , number_planes ; double min_data , max_data , zero , scale ; EndianType endian ; } FITSInfo ; char * comment , keyword [ 9 ] , property [ MaxTextExtent ] , value [ 73 ] ; double pixel , scale ; FITSInfo fits_info ; Image * image ; int c ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , scene , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & fits_info , 0 , sizeof ( fits_info ) ) ; fits_info . extend = MagickFalse ; fits_info . simple = MagickFalse ; fits_info . bits_per_pixel = 8 ; fits_info . columns = 1 ; fits_info . rows = 1 ; fits_info . rows = 1 ; fits_info . number_planes = 1 ; fits_info . min_data = 0.0 ; fits_info . max_data = 0.0 ; fits_info . zero = 0.0 ; fits_info . scale = 1.0 ; fits_info . endian = MSBEndian ; for ( comment = ( char * ) NULL ; EOFBlob ( image ) == MagickFalse ; ) { for ( ; EOFBlob ( image ) == MagickFalse ; ) { register char * p ; count = ReadBlob ( image , 8 , ( unsigned char * ) keyword ) ; if ( count != 8 ) break ; for ( i = 0 ; i < 8 ; i ++ ) { if ( isspace ( ( int ) ( ( unsigned char ) keyword [ i ] ) ) != 0 ) break ; keyword [ i ] = tolower ( ( int ) ( ( unsigned char ) keyword [ i ] ) ) ; } keyword [ i ] = '\\0' ; count = ReadBlob ( image , 72 , ( unsigned char * ) value ) ; value [ 72 ] = '\\0' ; if ( count != 72 ) break ; p = value ; if ( * p == '=' ) { p += 2 ; while ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) p ++ ; } if ( LocaleCompare ( keyword , ""end"" ) == 0 ) break ; if ( LocaleCompare ( keyword , ""extend"" ) == 0 ) fits_info . extend = ( * p == 'T' ) || ( * p == 't' ) ? MagickTrue : MagickFalse ; if ( LocaleCompare ( keyword , ""simple"" ) == 0 ) fits_info . simple = ( * p == 'T' ) || ( * p == 't' ) ? MagickTrue : MagickFalse ; if ( LocaleCompare ( keyword , ""bitpix"" ) == 0 ) fits_info . bits_per_pixel = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis"" ) == 0 ) fits_info . number_axes = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis1"" ) == 0 ) fits_info . columns = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis2"" ) == 0 ) fits_info . rows = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""naxis3"" ) == 0 ) fits_info . number_planes = StringToLong ( p ) ; if ( LocaleCompare ( keyword , ""datamax"" ) == 0 ) fits_info . max_data = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""datamin"" ) == 0 ) fits_info . min_data = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""bzero"" ) == 0 ) fits_info . zero = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""bscale"" ) == 0 ) fits_info . scale = StringToDouble ( p , ( char * * ) NULL ) ; if ( LocaleCompare ( keyword , ""comment"" ) == 0 ) { if ( comment == ( char * ) NULL ) comment = ConstantString ( p ) ; else ( void ) ConcatenateString ( & comment , p ) ; } if ( LocaleCompare ( keyword , ""xendian"" ) == 0 ) { if ( LocaleNCompare ( p , ""big"" , 3 ) == 0 ) fits_info . endian = MSBEndian ; else fits_info . endian = LSBEndian ; } ( void ) FormatLocaleString ( property , MaxTextExtent , ""fits:%s"" , keyword ) ; ( void ) SetImageProperty ( image , property , p ) ; } c = 0 ; while ( ( ( TellBlob ( image ) % FITSBlocksize ) != 0 ) && ( c != EOF ) ) c = ReadBlobByte ( image ) ; if ( fits_info . extend == MagickFalse ) break ; number_pixels = ( MagickSizeType ) fits_info . columns * fits_info . rows ; if ( ( fits_info . simple != MagickFalse ) && ( fits_info . number_axes >= 1 ) && ( fits_info . number_axes <= 4 ) && ( number_pixels != 0 ) ) break ; } if ( comment != ( char * ) NULL ) { ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; number_pixels = ( MagickSizeType ) fits_info . columns * fits_info . rows ; if ( ( fits_info . simple == MagickFalse ) || ( fits_info . number_axes < 1 ) || ( fits_info . number_axes > 4 ) || ( number_pixels == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; for ( scene = 0 ; scene < ( ssize_t ) fits_info . number_planes ; scene ++ ) { image -> columns = ( size_t ) fits_info . columns ; image -> rows = ( size_t ) fits_info . rows ; image -> depth = ( size_t ) ( fits_info . bits_per_pixel < 0 ? - 1 : 1 ) * fits_info . bits_per_pixel ; image -> endian = fits_info . endian ; image -> scene = ( size_t ) scene ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;  ( void ) SetImageColorspace ( image , GRAYColorspace ) ;  if ( ( fits_info . min_data == 0.0 ) && ( fits_info . max_data == 0.0 ) ) { if ( fits_info . zero == 0.0 ) ( void ) GetFITSPixelExtrema ( image , fits_info . bits_per_pixel , & fits_info . min_data , & fits_info . max_data ) ; else fits_info . max_data = GetFITSPixelRange ( ( size_t ) fits_info . bits_per_pixel ) ; } else fits_info . max_data = GetFITSPixelRange ( ( size_t ) fits_info . bits_per_pixel ) ; scale = QuantumRange / ( fits_info . max_data - fits_info . min_data ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = GetFITSPixel ( image , fits_info . bits_per_pixel ) ; if ( ( image -> depth == 16 ) || ( image -> depth == 32 ) || ( image -> depth == 64 ) ) SetFITSUnsignedPixels ( 1 , image -> depth , image -> endian , ( unsigned char * ) & pixel ) ; SetPixelRed ( q , ClampToQuantum ( scale * ( fits_info . scale * ( pixel - fits_info . min_data ) + fits_info . zero ) ) ) ; SetPixelGreen ( q , GetPixelRed ( q ) ) ; SetPixelBlue ( q , GetPixelRed ( q ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( fits_info . number_planes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
518,"CWE-369 int tcp_disconnect ( struct sock * sk , int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; int err = 0 ; int old_state = sk -> sk_state ; if ( old_state != TCP_CLOSE ) tcp_set_state ( sk , TCP_CLOSE ) ; if ( old_state == TCP_LISTEN ) { inet_csk_listen_stop ( sk ) ; } else if ( unlikely ( tp -> repair ) ) { sk -> sk_err = ECONNABORTED ; } else if ( tcp_need_reset ( old_state ) || ( tp -> snd_nxt != tp -> write_seq && ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { tcp_send_active_reset ( sk , gfp_any ( ) ) ; sk -> sk_err = ECONNRESET ; } else if ( old_state == TCP_SYN_SENT ) sk -> sk_err = ECONNRESET ; tcp_clear_xmit_timers ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; tcp_write_queue_purge ( sk ) ; tcp_fastopen_active_disable_ofo_check ( sk ) ; skb_rbtree_purge ( & tp -> out_of_order_queue ) ; inet -> inet_dport = 0 ; if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) inet_reset_saddr ( sk ) ; sk -> sk_shutdown = 0 ; sock_reset_flag ( sk , SOCK_DONE ) ; tp -> srtt_us = 0 ; tp -> write_seq += tp -> max_window + 2 ; if ( tp -> write_seq == 0 ) tp -> write_seq = 1 ; icsk -> icsk_backoff = 0 ; tp -> snd_cwnd = 2 ; icsk -> icsk_probes_out = 0 ; tp -> packets_out = 0 ; tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; tp -> snd_cwnd_cnt = 0 ; tp -> window_clamp = 0 ; tcp_set_ca_state ( sk , TCP_CA_Open ) ; tcp_clear_retrans ( tp ) ; inet_csk_delack_init ( sk ) ;  tcp_init_send_head ( sk ) ;  memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; __sk_dst_reset ( sk ) ; tcp_saved_syn_free ( tp ) ; tcp_free_fastopen_req ( tp ) ; inet -> defer_connect = 0 ; WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; sk -> sk_error_report ( sk ) ; return err ; }", sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
519,"CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s(resulti32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s(resulti64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s(resultf32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s(resultf64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s(result?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%d"" , opdef -> txt , count ) ;  for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) {   int optxtlen = strlen ( op -> txt ) ;  snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d"" , table [ i ] ) ;  }   snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ;  free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%d%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%d%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }"," count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ;  < count && txtLen  + 10 <  ++ ) { snprintf ( txt , txtLeft  , ""%d"" ,  ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ;  } snprintf ( txt , txtLeft - 1  , ""%d"" ,"
520,"CWE-125 u_int atm_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int length = h -> len ; uint32_t llchdr ; u_int hdrlen = 0 ; if ( caplen < 1 || length < 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } if ( * p == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""CNLPID"" ) ) ;  isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;  return hdrlen ; } if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } llchdr = EXTRACT_24BITS ( p ) ; if ( llchdr != LLC_UI_HDR ( LLCSAP_SNAP ) && llchdr != LLC_UI_HDR ( LLCSAP_ISONS ) && llchdr != LLC_UI_HDR ( LLCSAP_IP ) ) { if ( caplen < 20 || length < 20 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( caplen ) ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%08x%08x%08x%08x"" , EXTRACT_32BITS ( p ) , EXTRACT_32BITS ( p + 4 ) , EXTRACT_32BITS ( p + 8 ) , EXTRACT_32BITS ( p + 12 ) ) ) ; p += 20 ; length -= 20 ; caplen -= 20 ; hdrlen += 20 ; } hdrlen += atm_llc_print ( ndo , p , length , caplen ) ; return ( hdrlen ) ; }", length - 1  ) ; return
521,"CWE-119 void cJSON_AddItemToArray ( cJSON * array , cJSON * item ) { cJSON * c = array -> child ; if ( ! item ) return ; if ( ! c ) { array -> child = item ; } else { while ( c && c -> next ) c = c -> next ; suffix_object ( c , item ) ; } }","
"
522,"CWE-119 static const char * parse_number ( cJSON * item , const char * num ) {  int64_t i = 0 ;  double f = 0 ;  int isint = 1 ;  int sign = 1 , scale = 0 , subscale = 0 , signsubscale = 1 ; if ( * num == '-' ) { sign = - 1 ; ++ num ; } if ( * num == '0' ) ++ num ; if ( * num >= '1' && * num <= '9' ) { do { i = ( i * 10 ) + ( * num - '0' ) ;  f = ( f * 10.0 ) + ( * num - '0' ) ;  ++ num ; } while ( * num >= '0' && * num <= '9' ) ; } if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) { isint = 0 ; ++ num ; do { f = ( f * 10.0 ) + ( * num ++ - '0' ) ; scale -- ;  } while ( * num >= '0' && * num <= '9' ) ;  } if ( * num == 'e' || * num == 'E' ) {  isint = 0 ;  ++ num ; if ( * num == '+' )  ++ num ;   else if ( * num == '-' ) {   signsubscale = - 1 ;  ++ num ; } while ( * num >= '0' && * num <= '9' ) subscale = ( subscale * 10 ) + ( * num ++ - '0' ) ; } if ( isint ) {  i = sign * i ;   item -> valueint = i ;  item -> valuefloat = i ; } else { f = sign * f * ipow ( 10.0 , scale + subscale * signsubscale ) ; item -> valueint = f ; item -> valuefloat = f ; } item -> type = cJSON_Number ; return num ; }"," num ) { double n = 0 , sign = 1 , scale  = 0 ;  0 ; int subscale = 0 , signsubscale = 1 ; if ( * num == '-' ) sign = - 1 , num ++ ; if ( * num == '0' ) num ++ ; if ( * num >= '1' && * num <= '9' ) do n = ( n * 10.0 ) + ( * num ++ - '0' ) ; while ( * num >= '0' && * num <= '9' ) ; if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) { num ++ ; do n = ( n  * 10.0 )  ( * num ++ - '0' ) ,  scale -- ;  scale -- ;  while ( *  'E' ) { num ++ ;  if ( *  == '+' ) num ++ ;  else if (  == '-' )  signsubscale = -  = - 1 , num ++ ; while ( * num >= '0' && * num <= '9' ) subscale = ( subscale * 10 ) + ( * num ++ - '0' ) ; } n  = sign *  = sign * n * pow ( 10.0 , ( scale + subscale * signsubscale ) ) ; item -> valuedouble = n  ; item ->  -> valueint = ( int64_t ) n ;  item -> type"
523,"CWE-362 static int snd_timer_user_open ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; int err ; err = nonseekable_open ( inode , file ) ; if ( err < 0 ) return err ; tu = kzalloc ( sizeof ( * tu ) , GFP_KERNEL ) ; if ( tu == NULL ) return - ENOMEM ; spin_lock_init ( & tu -> qlock ) ; init_waitqueue_head ( & tu -> qchange_sleep ) ;  mutex_init ( & tu -> tread_sem ) ;  tu -> ticks = 1 ; tu -> queue_size = 128 ; tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) { kfree ( tu ) ; return - ENOMEM ; } file -> private_data = tu ; return 0 ; }", & tu -> ioctl_lock  ) ; tu
524,"CWE-119 void vp8_pack_bitstream ( VP8_COMP * cpi , unsigned char * dest , unsigned char * dest_end , unsigned long * size ) { int i , j ; VP8_HEADER oh ; VP8_COMMON * const pc = & cpi -> common ; vp8_writer * const bc = cpi -> bc ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int extra_bytes_packed = 0 ; unsigned char * cx_data = dest ; unsigned char * cx_data_end = dest_end ; const int * mb_feature_data_bits ; oh . show_frame = ( int ) pc -> show_frame ; oh . type = ( int ) pc -> frame_type ; oh . version = pc -> version ; oh . first_partition_length_in_bytes = 0 ; mb_feature_data_bits = vp8_mb_feature_data_bits ; bc [ 0 ] . error = & pc -> error ; validate_buffer ( cx_data , 3 , cx_data_end , & cpi -> common . error ) ; cx_data += 3 ; # if defined ( SECTIONBITS_OUTPUT ) Sectionbits [ active_section = 1 ] += sizeof ( VP8_HEADER ) * 8 * 256 ; # endif if ( oh . type == KEY_FRAME ) { int v ; validate_buffer ( cx_data , 7 , cx_data_end , & cpi -> common . error ) ; cx_data [ 0 ] = 0x9D ; cx_data [ 1 ] = 0x01 ; cx_data [ 2 ] = 0x2a ; v = ( pc -> horiz_scale << 14 ) | pc -> Width ; cx_data [ 3 ] = v ; cx_data [ 4 ] = v >> 8 ; v = ( pc -> vert_scale << 14 ) | pc -> Height ; cx_data [ 5 ] = v ; cx_data [ 6 ] = v >> 8 ; extra_bytes_packed = 7 ; cx_data += extra_bytes_packed ; vp8_start_encode ( bc , cx_data , cx_data_end ) ; vp8_write_bit ( bc , 0 ) ; vp8_write_bit ( bc , pc -> clamp_type ) ; } else vp8_start_encode ( bc , cx_data , cx_data_end ) ; vp8_write_bit ( bc , xd -> segmentation_enabled ) ; if ( xd -> segmentation_enabled ) { vp8_write_bit ( bc , xd -> update_mb_segmentation_map ) ; vp8_write_bit ( bc , xd -> update_mb_segmentation_data ) ; if ( xd -> update_mb_segmentation_data ) { signed char Data ; vp8_write_bit ( bc , xd -> mb_segement_abs_delta ) ; for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) { for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) { Data = xd -> segment_feature_data [ i ] [ j ] ; if ( Data ) { vp8_write_bit ( bc , 1 ) ; if ( Data < 0 ) { Data = - Data ; vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ; vp8_write_bit ( bc , 1 ) ; } else { vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ; vp8_write_bit ( bc , 0 ) ; } } else vp8_write_bit ( bc , 0 ) ; } } } if ( xd -> update_mb_segmentation_map ) { for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) { int Data = xd -> mb_segment_tree_probs [ i ] ; if ( Data != 255 ) { vp8_write_bit ( bc , 1 ) ; vp8_write_literal ( bc , Data , 8 ) ; } else vp8_write_bit ( bc , 0 ) ; } } } vp8_write_bit ( bc , pc -> filter_type ) ; vp8_write_literal ( bc , pc -> filter_level , 6 ) ; vp8_write_literal ( bc , pc -> sharpness_level , 3 ) ; vp8_write_bit ( bc , xd -> mode_ref_lf_delta_enabled ) ; if ( xd -> mode_ref_lf_delta_enabled ) { int send_update = xd -> mode_ref_lf_delta_update || cpi -> oxcf . error_resilient_mode ; vp8_write_bit ( bc , send_update ) ; if ( send_update ) { int Data ; for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { Data = xd -> ref_lf_deltas [ i ] ; if ( xd -> ref_lf_deltas [ i ] != xd -> last_ref_lf_deltas [ i ] || cpi -> oxcf . error_resilient_mode ) { xd -> last_ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] ; vp8_write_bit ( bc , 1 ) ; if ( Data > 0 ) { vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 0 ) ; } else { Data = - Data ; vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 1 ) ; } } else vp8_write_bit ( bc , 0 ) ; } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { Data = xd -> mode_lf_deltas [ i ] ; if ( xd -> mode_lf_deltas [ i ] != xd -> last_mode_lf_deltas [ i ] || cpi -> oxcf . error_resilient_mode ) { xd -> last_mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] ; vp8_write_bit ( bc , 1 ) ; if ( Data > 0 ) { vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 0 ) ; } else { Data = - Data ; vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; vp8_write_bit ( bc , 1 ) ; } } else vp8_write_bit ( bc , 0 ) ; } } } vp8_write_literal ( bc , pc -> multi_token_partition , 2 ) ; vp8_write_literal ( bc , pc -> base_qindex , 7 ) ; put_delta_q ( bc , pc -> y1dc_delta_q ) ; put_delta_q ( bc , pc -> y2dc_delta_q ) ; put_delta_q ( bc , pc -> y2ac_delta_q ) ; put_delta_q ( bc , pc -> uvdc_delta_q ) ; put_delta_q ( bc , pc -> uvac_delta_q ) ; if ( pc -> frame_type != KEY_FRAME ) { vp8_write_bit ( bc , pc -> refresh_golden_frame ) ; vp8_write_bit ( bc , pc -> refresh_alt_ref_frame ) ; if ( ! pc -> refresh_golden_frame ) vp8_write_literal ( bc , pc -> copy_buffer_to_gf , 2 ) ; if ( ! pc -> refresh_alt_ref_frame ) vp8_write_literal ( bc , pc -> copy_buffer_to_arf , 2 ) ; vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) ; vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ ALTREF_FRAME ] ) ; } # if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) { if ( pc -> frame_type == KEY_FRAME ) pc -> refresh_entropy_probs = 1 ; else pc -> refresh_entropy_probs = 0 ; } # endif vp8_write_bit ( bc , pc -> refresh_entropy_probs ) ; if ( pc -> frame_type != KEY_FRAME ) vp8_write_bit ( bc , pc -> refresh_last_frame ) ; # ifdef VP8_ENTROPY_STATS if ( pc -> frame_type == INTER_FRAME ) active_section = 0 ; else active_section = 7 ; # endif vp8_clear_system_state ( ) ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pack_coef_probs ( cpi ) ; # else if ( pc -> refresh_entropy_probs == 0 ) {  vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;  } vp8_update_coef_probs ( cpi ) ; # endif # ifdef VP8_ENTROPY_STATS active_section = 2 ; # endif vp8_write_bit ( bc , pc -> mb_no_coeff_skip ) ; if ( pc -> frame_type == KEY_FRAME ) { write_kfmodes ( cpi ) ; # ifdef VP8_ENTROPY_STATS active_section = 8 ; # endif } else { pack_inter_mode_mvs ( cpi ) ; # ifdef VP8_ENTROPY_STATS active_section = 1 ; # endif } vp8_stop_encode ( bc ) ; cx_data += bc -> pos ; oh . first_partition_length_in_bytes = cpi -> bc -> pos ; { int v = ( oh . first_partition_length_in_bytes << 5 ) | ( oh . show_frame << 4 ) | ( oh . version << 1 ) | oh . type ; dest [ 0 ] = v ; dest [ 1 ] = v >> 8 ; dest [ 2 ] = v >> 16 ; } * size = VP8_HEADER_SIZE + extra_bytes_packed + cpi -> bc -> pos ; cpi -> partition_sz [ 0 ] = * size ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { const int num_part = ( 1 << pc -> multi_token_partition ) ; unsigned char * dp = cpi -> partition_d [ 0 ] + cpi -> partition_sz [ 0 ] ; if ( num_part > 1 ) { validate_buffer ( dp , 3 * ( num_part - 1 ) , cpi -> partition_d_end [ 0 ] , & pc -> error ) ; cpi -> partition_sz [ 0 ] += 3 * ( num_part - 1 ) ; for ( i = 1 ; i < num_part ; i ++ ) { write_partition_size ( dp , cpi -> partition_sz [ i ] ) ; dp += 3 ; } } if ( ! cpi -> output_partition ) { for ( i = 0 ; i < num_part ; i ++ ) {  vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ;  cpi -> partition_d [ i + 1 ] = dp ; dp += cpi -> partition_sz [ i + 1 ] ; } } * size = 0 ; for ( i = 0 ; i < num_part + 1 ; i ++ ) { * size += cpi -> partition_sz [ i ] ; } } # else if ( pc -> multi_token_partition != ONE_PARTITION ) { int num_part = 1 << pc -> multi_token_partition ; cpi -> partition_sz [ 0 ] += 3 * ( num_part - 1 ) ; * size += 3 * ( num_part - 1 ) ; validate_buffer ( cx_data , 3 * ( num_part - 1 ) , cx_data_end , & pc -> error ) ; for ( i = 1 ; i < num_part + 1 ; i ++ ) { cpi -> bc [ i ] . error = & pc -> error ; } pack_tokens_into_partitions ( cpi , cx_data + 3 * ( num_part - 1 ) , cx_data_end , num_part ) ; for ( i = 1 ; i < num_part ; i ++ ) { cpi -> partition_sz [ i ] = cpi -> bc [ i ] . pos ; write_partition_size ( cx_data , cpi -> partition_sz [ i ] ) ; cx_data += 3 ; * size += cpi -> partition_sz [ i ] ; } cpi -> partition_sz [ i ] = cpi -> bc [ i ] . pos ; * size += cpi -> partition_sz [ i ] ; } else { bc [ 1 ] . error = & pc -> error ; vp8_start_encode ( & cpi -> bc [ 1 ] , cx_data , cx_data_end ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) pack_mb_row_tokens ( cpi , & cpi -> bc [ 1 ] ) ; else # endif  pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ;  vp8_stop_encode ( & cpi -> bc [ 1 ] ) ; * size += cpi -> bc [ 1 ] . pos ; cpi -> partition_sz [ 1 ] = cpi -> bc [ 1 ] . pos ; } # endif }"," 0 ) { memcpy  ( & cpi  ++ ) { memmove  ( dp ,  else # endif vp8_pack_tokens  ( & cpi"
525,"CWE-200 char * url_decode_r ( char * to , char * url , size_t size ) { char * s = url , * d = to , * e = & to [ size - 1 ] ; while ( * s && d < e ) { if ( unlikely ( * s == '%' ) ) { if ( likely ( s [ 1 ] && s [ 2 ] ) ) {  * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ;  s += 2 ; } } else if ( unlikely ( * s == '+' ) ) * d ++ = '' ; else * d ++ = * s ; s ++ ; } * d = '\\0' ; return to ; }", ) ) { char t  = from_hex (  [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : ''
526,"CWE-125 static inline unsigned int ReadPropertyUnsignedLong ( const EndianType endian , const unsigned char * buffer ) { unsigned int value ; if ( endian == LSBEndian ) {  value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;   return ( ( unsigned int ) ( value & 0xffffffff ) ) ;  }  value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;   return ( ( unsigned int ) ( value & 0xffffffff ) ) ;  }", unsigned int )  buffer [ 3  ] << 24 ; value |= ( unsigned int )  buffer [ 2  ] << 16 ; value |= ( unsigned int )  buffer [ 1  ] << 8 ; value |= ( unsigned int )  buffer [ 0  [ 0 ]  ; return (  ; return (  value & 0xffffffff  value & 0xffffffff  ) ; }  unsigned int )  buffer [ 0  ] << 24 ; value |= ( unsigned int )  buffer [ 1  ] << 16 ; value |= ( unsigned int )  buffer [ 2  ] << 8 ; value |= ( unsigned int )  buffer [ 3  [ 3 ] ; return  ( value &  & 0xffffffff )  ; } 
527,"CWE-119 static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; }  i ++ ;  if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:zerolength-clearingWDM_READ\\n"" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }"," err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }"
528,"CWE-119 int l2tp_recv ( int fd , struct l2tp_packet_t * * p , struct in_pktinfo * pkt_info , const char * secret , size_t secret_len ) {  int n , length ;  uint8_t * buf ; struct l2tp_hdr_t * hdr ; struct l2tp_avp_t * avp ;  struct l2tp_dict_attr_t * da ;   struct l2tp_attr_t * attr , * RV = NULL ;  uint8_t * ptr ; struct l2tp_packet_t * pack ; struct sockaddr_in addr ;  socklen_t len = sizeof ( addr ) ;   struct msghdr msg ;  char msg_control [ 128 ] ;  struct cmsghdr * cmsg ;  uint16_t orig_avp_len ; void * orig_avp_val ; * p = NULL ; if ( pkt_info ) { memset ( & msg , 0 , sizeof ( msg ) ) ; msg . msg_control = msg_control ;  msg . msg_controllen = 128 ;  n = recvmsg ( fd , & msg , MSG_PEEK ) ; if ( n < 0 ) { if ( errno == EAGAIN ) return - 1 ; log_error ( ""l2tp:recvmsg:%s\\n"" , strerror ( errno ) ) ; return 0 ; } for ( cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg != NULL ; cmsg = CMSG_NXTHDR ( & msg , cmsg ) ) { if ( cmsg -> cmsg_level == IPPROTO_IP && cmsg -> cmsg_type == IP_PKTINFO ) { memcpy ( pkt_info , CMSG_DATA ( cmsg ) , sizeof ( * pkt_info ) ) ; break ; } } } buf = mempool_alloc ( buf_pool ) ; if ( ! buf ) { log_emerg ( ""l2tp:outofmemory\\n"" ) ; return 0 ; } hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ;  n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ;  if ( n < 0 ) { mempool_free ( buf ) ; if ( errno == EAGAIN ) { return - 1 ; } else if ( errno == ECONNREFUSED ) { return - 2 ; } log_error ( ""l2tp:recv:%s\\n"" , strerror ( errno ) ) ; return 0 ; }  if ( n < 6 ) {  if ( conf_verbose ) log_warn ( ""l2tp:shortpacketreceived(%i/%zu)\\n"" , n , sizeof ( * hdr ) ) ; goto out_err_hdr ; }  if ( hdr -> T == 0 )  goto out_err_hdr ;  if ( n < ntohs ( hdr -> length ) ) {  if ( conf_verbose )  log_warn ( ""l2tp:shortpacketreceived(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ;  goto out_err_hdr ; }  if ( hdr -> ver == 2 ) {  if ( hdr -> L == 0 ) { if ( conf_verbose )  log_warn ( ""l2tp:incorrectmessagereceived(L=0)\\n"" ) ;  if ( ! conf_avp_permissive ) goto out_err_hdr ; } if ( hdr -> S == 0 ) { if ( conf_verbose ) log_warn ( ""l2tp:incorrectmessagereceived(S=0)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } if ( hdr -> O == 1 ) { if ( conf_verbose ) log_warn ( ""l2tp:incorrectmessagereceived(O=1)\\n"" ) ; if ( ! conf_avp_permissive ) goto out_err_hdr ; } } else if ( hdr -> ver != 3 ) { if ( conf_verbose ) log_warn ( ""l2tp:protocolversion%iisnotsupported\\n"" , hdr -> ver ) ; goto out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:outofmemory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length = ntohs ( hdr -> length ) - sizeof ( * hdr ) ; while ( length ) { * ( uint16_t * ) ptr = ntohs ( * ( uint16_t * ) ptr ) ; avp = ( struct l2tp_avp_t * ) ptr ;  if ( avp -> length > length ) {  if ( conf_verbose ) log_warn ( ""l2tp:incorrectavpreceived(exceedsmessagelength)\\n"" ) ; goto out_err ; } if ( avp -> vendor ) goto skip ; da = l2tp_dict_find_attr_by_id ( ntohs ( avp -> type ) ) ; if ( ! da ) {  if ( conf_verbose )   log_warn ( ""l2tp:unknownavpreceived(type=%i,M=%u)\\n"" , ntohs ( avp -> type ) , avp -> M ) ;  if ( avp -> M && ! conf_avp_permissive ) goto out_err ; } else {  if ( da -> M != - 1 && da -> M != avp -> M ) {  if ( conf_verbose ) log_warn ( ""l2tp:incorrectavpreceived(type=%i,M=%i,mustbe%i)\\n"" , ntohs ( avp -> type ) , avp -> M , da -> M ) ; if ( ! conf_avp_permissive ) goto out_err ; }  if ( da -> H != - 1 && da -> H != avp -> H ) {  if ( conf_verbose ) log_warn ( ""l2tp:incorrectavpreceived(type=%i,H=%i,mustbe%i)\\n"" , ntohs ( avp -> type ) , avp -> H , da -> H ) ; if ( ! conf_avp_permissive ) goto out_err ; }  if ( avp -> H ) {  if ( ! RV ) { if ( conf_verbose ) log_warn ( ""l2tp:incorrectavpreceived(type=%i,H=1,butRandom-Vectorisnotreceived)\\n"" , ntohs ( avp -> type ) ) ; goto out_err ; } if ( secret == NULL || secret_len == 0 ) { log_error ( ""l2tp:impossibletodecode"" ""hiddenavp(type%hu):no"" ""secretset)\\n"" , ntohs ( avp -> type ) ) ; goto out_err ; } if ( decode_avp ( avp , RV , secret , secret_len ) < 0 ) goto out_err ;  }  attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; list_add_tail ( & attr -> entry , & pack -> attrs ) ; if ( avp -> H ) { orig_avp_len = ntohs ( * ( uint16_t * ) avp -> val ) + sizeof ( * avp ) ; orig_avp_val = avp -> val + sizeof ( uint16_t ) ; } else {  orig_avp_len = avp -> length ;  orig_avp_val = avp -> val ; }  attr -> attr = da ;   attr -> M = avp -> M ;  attr -> H = 0 ;  attr -> length = orig_avp_len - sizeof ( * avp ) ;  if ( attr -> attr -> id == Random_Vector ) RV = attr ; switch ( da -> type ) { case ATTR_TYPE_INT16 : if ( orig_avp_len != sizeof ( * avp ) + 2 ) goto out_err_len ; attr -> val . uint16 = ntohs ( * ( uint16_t * ) orig_avp_val ) ; break ; case ATTR_TYPE_INT32 : if ( orig_avp_len != sizeof ( * avp ) + 4 ) goto out_err_len ; attr -> val . uint32 = ntohl ( * ( uint32_t * ) orig_avp_val ) ; break ; case ATTR_TYPE_INT64 : if ( orig_avp_len != sizeof ( * avp ) + 8 ) goto out_err_len ; attr -> val . uint64 = be64toh ( * ( uint64_t * ) orig_avp_val ) ; break ; case ATTR_TYPE_OCTETS : attr -> val . octets = _malloc ( attr -> length ) ; if ( ! attr -> val . octets ) goto out_err_mem ; memcpy ( attr -> val . octets , orig_avp_val , attr -> length ) ; break ; case ATTR_TYPE_STRING : attr -> val . string = _malloc ( attr -> length + 1 ) ; if ( ! attr -> val . string ) goto out_err_mem ; memcpy ( attr -> val . string , orig_avp_val , attr -> length ) ; attr -> val . string [ attr -> length ] = 0 ; break ; } } skip :  ptr += avp -> length ;   length -= avp -> length ;  } * p = pack ; mempool_free ( buf ) ; return 0 ; out_err : l2tp_packet_free ( pack ) ; out_err_hdr : mempool_free ( buf ) ; return 0 ; out_err_len : if ( conf_verbose ) log_warn ( ""l2tp:incorrectavpreceived(type=%i,incorrectlength%i)\\n"" , ntohs ( avp -> type ) , orig_avp_len ) ; goto out_err ; out_err_mem : log_emerg ( ""l2tp:outofmemory\\n"" ) ; goto out_err ; }"," secret_len ) { struct l2tp_packet_t * pack  ; struct l2tp_hdr_t  avp ; struct l2tp_attr_t *  RV = NULL  RV = NULL  ; struct sockaddr_in  addr ; socklen_t addr_len ; uint16_t orig_avp_len ; void * orig_avp_val ; uint8_t * buf , * ptr ; int n , length ; * p = NULL ; if ( pkt_info ) {  struct msghdr msg  struct msghdr msg ; struct cmsghdr * cmsg  128 ] ;  memset ( &  . msg_controllen = sizeof ( msg_control )  ; n =  1 ) ; addr_len = sizeof ( addr ) ;  addr , & addr_len  ) ; if  ( n < sizeof ( * hdr )  ) { if  out_err_hdr ; } hdr -> flags = ntohs ( hdr -> flags ) ; if ( ! ( hdr -> flags & L2TP_FLAG_T )  ) goto out_err_hdr  goto out_err_hdr ; if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) { if ( conf_verbose ) log_warn ( ""l2tp:incorrectcontrolmessagereceived(L=0)\\n"" ) ; goto out_err_hdr ; } if ( ! ( hdr -> flags & L2TP_FLAG_S ) ) { if ( conf_verbose ) log_warn ( ""l2tp:incorrectcontrolmessagereceived(S=0)\\n"" ) ; goto out_err_hdr ; } switch ( hdr -> flags & L2TP_VER_MASK ) { case 2 : if ( hdr -> flags & L2TP_FLAG_O ) { if ( conf_verbose ) log_warn ( ""l2tp:incorrectcontrolmessagereceived(O=1)\\n"" ) ; goto out_err_hdr ; } break ; case 3 : break ; default : if ( conf_verbose ) log_warn ( ""l2tp:protocolversion%iisnotsupported\\n"" , hdr -> flags & L2TP_VER_MASK ) ; goto out_err_hdr ; } length = ntohs ( hdr -> length ) ; if ( length < sizeof ( * hdr ) ) { if ( conf_verbose ) log_warn ( ""l2tp:shortpacketreceived(%i/%zu)\\n"" , length , sizeof ( * hdr ) ) ; goto out_err_hdr ; } else  ( n < length )  { if (  , n , length )  ; goto out_err_hdr  out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:outofmemory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length -= sizeof ( * hdr ) ; while ( length > 0 ) { struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr ; uint16_t avp_len ; if ( length < sizeof ( * avp )  ) { if  ) log_warn ( ""l2tp:shortavpreceived\\n"" ) ; goto out_err ; }  avp = (  ) ptr ; avp -> flags = ntohs ( avp -> flags ) ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len < sizeof ( * avp ) ) { if ( conf_verbose ) log_warn ( ""l2tp:shortavpreceived\\n"" ) ; goto out_err ; } else if ( length < avp_len  ) { if  ( conf_verbose ) {  type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) ; } if ( ( avp -> flags & L2TP_AVP_FLAG_M )  && ! conf_avp_permissive  - 1 && !  -> M != ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:incorrectavpreceived(type=%i,M=%i,mustbe%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) , da  -> M )  -> M ) ; }  if ( !  - 1 && !  -> H != ! ( avp -> flags & L2TP_AVP_FLAG_H ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:incorrectavpreceived(type=%i,H=%i,mustbe%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_H ) , da  -> H )  -> H ) ; }  if ( !  ( avp -> flags & L2TP_AVP_FLAG_H  ) { if  goto out_err ;  orig_avp_len = ntohs  { orig_avp_len = avp_len  ; orig_avp_val =  ; } attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; attr  -> M = ! ! ( avp -> flags & L2TP_AVP_FLAG_M )  ; attr ->  ( * avp ) ; list_add_tail ( & attr -> entry , & pack -> attrs  : ptr += avp_len  ; length -=  ; length -= avp_len  ; } *"
529,CWE-476 static void i8042_stop ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ;  port -> exists = false ;  synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ;  port -> serio = NULL ;  }, -> port_data ; spin_lock_irq ( & i8042_lock ) ;  exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock )  I8042_KBD_IRQ ) ;  }  
530,"CWE-000 static ssize_t aio_setup_iocb ( struct kiocb * kiocb , bool compat ) { struct file * file = kiocb -> ki_filp ; ssize_t ret = 0 ; switch ( kiocb -> ki_opcode ) { case IOCB_CMD_PREAD : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;  ret = security_file_permission ( file , MAY_READ ) ;  if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITE : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;  ret = security_file_permission ( file , MAY_WRITE ) ;  if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PREADV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ;  ret = security_file_permission ( file , MAY_READ ) ;  if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( READ , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITEV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ;  ret = security_file_permission ( file , MAY_WRITE ) ;  if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( WRITE , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_FDSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fdsync ; break ; case IOCB_CMD_FSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fsync ; break ; default : dprintk ( ""EINVAL:io_submit:nooperationprovided\\n"" ) ; ret = - EINVAL ; } if ( ! kiocb -> ki_retry ) return ret ; return 0 ; }"," ; ret = aio_setup_single_vector ( READ , file ,  kiocb ) ;  ; ret = aio_setup_single_vector ( WRITE , file ,  kiocb ) ;  ; ret =  aio_setup_vectored_rw ( READ  ; ret =  aio_setup_vectored_rw ( WRITE"
531,"CWE-125 void pim_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , const u_char * bp2 ) {  register const u_char * ep ;   register const struct pim * pim = ( const struct pim * ) bp ;  ep = ( const u_char * ) ndo -> ndo_snapend ; if ( bp >= ep ) return ; # ifdef notyet ND_TCHECK ( pim -> pim_rsv ) ; # endif  switch ( PIM_VER ( pim -> pim_typever ) ) {  case 2 : if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""PIMv%u,%s,length%u"" , PIM_VER ( pim -> pim_typever ) , tok2str ( pimv2_type_values , ""UnknownType"" , PIM_TYPE ( pim -> pim_typever ) ) , len ) ) ; return ; } else { ND_PRINT ( ( ndo , ""PIMv%u,length%u\\n\\t%s"" , PIM_VER ( pim -> pim_typever ) , len , tok2str ( pimv2_type_values , ""UnknownType"" , PIM_TYPE ( pim -> pim_typever ) ) ) ) ; pimv2_print ( ndo , bp , len , bp2 ) ; } break ; default : ND_PRINT ( ( ndo , ""PIMv%u,length%u"" , PIM_VER ( pim -> pim_typever ) , len ) ) ; break ; } return ;  } "," { register const  struct pim *  * ) bp  ; # ifdef  ; # endif ND_TCHECK ( pim -> pim_typever ) ;  } return ; trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; return ;"
532,"CWE-787  static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key ,  unsigned int keylen ) { return - ENOSYS ; }",     int shash_no_setkey (
533,"CWE-918 static inline char * parse_ip_address_ex ( const char * str , size_t str_len , int * portno , int get_err , zend_string * * err ) { char * colon ; char * host = NULL ; # ifdef HAVE_IPV6  char * p ;  if ( * ( str ) == '[' && str_len > 1 ) {  p = memchr ( str + 1 , ']' , str_len - 2 ) ;  if ( ! p || * ( p + 1 ) != ':' ) { if ( get_err ) { * err = strpprintf ( 0 , ""FailedtoparseIPv6address\\""%s\\"""" , str ) ; } return NULL ; }  * portno = atoi ( p + 2 ) ;  return estrndup ( str + 1 , p - str - 1 ) ; } # endif if ( str_len ) { colon = memchr ( str , ':' , str_len - 1 ) ; } else { colon = NULL ; } if ( colon ) {  * portno = atoi ( colon + 1 ) ;  host = estrndup ( str , colon - str ) ;  } else {  if ( get_err ) { * err = strpprintf ( 0 , ""Failedtoparseaddress\\""%s\\"""" , str ) ; } return NULL ; }  return host ;  }"," # ifdef HAVE_IPV6  if ( *  1 ) { char *  - 2 ) , * e = NULL  * portno = strtol  ( p +  p + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failedtoparseaddress\\""%s\\"""" , str ) ; } return NULL ; }  return estrndup (  colon ) { char * e = NULL ;  * portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return  estrndup ( str  ) ; } }  if ( get_err  NULL ; }    "
534,"CWE-20 static int read_bytes ( FILE * fp , void * buf , size_t bytes_to_read , int fail_on_eof , char * errbuf ) { size_t amt_read ; amt_read = fread ( buf , 1 , bytes_to_read , fp ) ; if ( amt_read != bytes_to_read ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""errorreadingdumpfile"" ) ; } else { if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE ,  ""truncateddumpfile;triedtoread%"" PRIsize ""bytes,onlygot%"" PRIsize ,  bytes_to_read , amt_read ) ; } return ( - 1 ) ; } return ( 1 ) ; }"," , PCAP_ERRBUF_SIZE , ""truncatedpcapngdumpfile;triedtoread%""  PRIsize ""bytes,onlygot%"" PRIsize"
535,"CWE-264 static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ;  if ( count < sizeof hdr )  return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }", ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
536,"CWE-59 void vrrp_print_json ( void ) { FILE * file ; element e ; struct json_object * array ; if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ;  file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ;  if ( ! file ) { log_message ( LOG_INFO , ""Can\'topen/tmp/keepalived.json(%d:%s)"" , errno , strerror ( errno ) ) ; return ; } array = json_object_new_array ( ) ; for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { struct json_object * instance_json , * json_stats , * json_data , * vips , * evips , * track_ifp , * track_script ; # ifdef _HAVE_FIB_ROUTING_ struct json_object * vroutes , * vrules ; # endif element f ; vrrp_t * vrrp = ELEMENT_DATA ( e ) ; instance_json = json_object_new_object ( ) ; json_stats = json_object_new_object ( ) ; json_data = json_object_new_object ( ) ; vips = json_object_new_array ( ) ; evips = json_object_new_array ( ) ; track_ifp = json_object_new_array ( ) ; track_script = json_object_new_array ( ) ; # ifdef _HAVE_FIB_ROUTING_ vroutes = json_object_new_array ( ) ; vrules = json_object_new_array ( ) ; # endif json_object_object_add ( json_data , ""iname"" , json_object_new_string ( vrrp -> iname ) ) ; json_object_object_add ( json_data , ""dont_track_primary"" , json_object_new_int ( vrrp -> dont_track_primary ) ) ; json_object_object_add ( json_data , ""skip_check_adv_addr"" , json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; json_object_object_add ( json_data , ""strict_mode"" , json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; # ifdef _HAVE_VRRP_VMAC_ json_object_object_add ( json_data , ""vmac_ifname"" , json_object_new_string ( vrrp -> vmac_ifname ) ) ; # endif if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { interface_t * ifp = ELEMENT_DATA ( f ) ; json_object_array_add ( track_ifp , json_object_new_string ( ifp -> ifname ) ) ; } } json_object_object_add ( json_data , ""track_ifp"" , track_ifp ) ; if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; vrrp_script_t * vscript = tsc -> scr ; json_object_array_add ( track_script , json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; } } json_object_object_add ( json_data , ""track_script"" , track_script ) ; json_object_object_add ( json_data , ""ifp_ifname"" , json_object_new_string ( vrrp -> ifp -> ifname ) ) ; json_object_object_add ( json_data , ""master_priority"" , json_object_new_int ( vrrp -> master_priority ) ) ; json_object_object_add ( json_data , ""last_transition"" , json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; json_object_object_add ( json_data , ""garp_delay"" , json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""garp_refresh"" , json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; json_object_object_add ( json_data , ""garp_rep"" , json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; json_object_object_add ( json_data , ""garp_refresh_rep"" , json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; json_object_object_add ( json_data , ""garp_lower_prio_delay"" , json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , ""garp_lower_prio_rep"" , json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; json_object_object_add ( json_data , ""lower_prio_no_advert"" , json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; json_object_object_add ( json_data , ""higher_prio_send_advert"" , json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; json_object_object_add ( json_data , ""vrid"" , json_object_new_int ( vrrp -> vrid ) ) ; json_object_object_add ( json_data , ""base_priority"" , json_object_new_int ( vrrp -> base_priority ) ) ; json_object_object_add ( json_data , ""effective_priority"" , json_object_new_int ( vrrp -> effective_priority ) ) ; json_object_object_add ( json_data , ""vipset"" , json_object_new_boolean ( vrrp -> vipset ) ) ; if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * vip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( vips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , ""vips"" , vips ) ; if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * evip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( evips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , ""evips"" , evips ) ; json_object_object_add ( json_data , ""promote_secondaries"" , json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; # ifdef _HAVE_FIB_ROUTING_ if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { ip_route_t * route = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; json_object_array_add ( vroutes , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , ""vroutes"" , vroutes ) ; if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { ip_rule_t * rule = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( RULE_BUF_SIZE ) ; format_iprule ( rule , buf , RULE_BUF_SIZE ) ; json_object_array_add ( vrules , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , ""vrules"" , vrules ) ; # endif json_object_object_add ( json_data , ""adver_int"" , json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""master_adver_int"" , json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""accept"" , json_object_new_int ( ( int ) vrrp -> accept ) ) ; json_object_object_add ( json_data , ""nopreempt"" , json_object_new_boolean ( vrrp -> nopreempt ) ) ; json_object_object_add ( json_data , ""preempt_delay"" , json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , ""state"" , json_object_new_int ( vrrp -> state ) ) ; json_object_object_add ( json_data , ""wantstate"" , json_object_new_int ( vrrp -> wantstate ) ) ; json_object_object_add ( json_data , ""version"" , json_object_new_int ( vrrp -> version ) ) ; if ( vrrp -> script_backup ) json_object_object_add ( json_data , ""script_backup"" , json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; if ( vrrp -> script_master ) json_object_object_add ( json_data , ""script_master"" , json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; if ( vrrp -> script_fault ) json_object_object_add ( json_data , ""script_fault"" , json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; if ( vrrp -> script_stop ) json_object_object_add ( json_data , ""script_stop"" , json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; if ( vrrp -> script ) json_object_object_add ( json_data , ""script"" , json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; if ( vrrp -> script_master_rx_lower_pri ) json_object_object_add ( json_data , ""script_master_rx_lower_pri"" , json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; json_object_object_add ( json_data , ""smtp_alert"" , json_object_new_boolean ( vrrp -> smtp_alert ) ) ; # ifdef _WITH_VRRP_AUTH_ if ( vrrp -> auth_type ) { json_object_object_add ( json_data , ""auth_type"" , json_object_new_int ( vrrp -> auth_type ) ) ; if ( vrrp -> auth_type != VRRP_AUTH_AH ) { char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\0' ; json_object_object_add ( json_data , ""auth_data"" , json_object_new_string ( auth_data ) ) ; } } else json_object_object_add ( json_data , ""auth_type"" , json_object_new_int ( 0 ) ) ; # endif json_object_object_add ( json_stats , ""advert_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; json_object_object_add ( json_stats , ""advert_sent"" , json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; json_object_object_add ( json_stats , ""become_master"" , json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; json_object_object_add ( json_stats , ""release_master"" , json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; json_object_object_add ( json_stats , ""packet_len_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; json_object_object_add ( json_stats , ""advert_interval_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; json_object_object_add ( json_stats , ""ip_ttl_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; json_object_object_add ( json_stats , ""invalid_type_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; json_object_object_add ( json_stats , ""addr_list_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; json_object_object_add ( json_stats , ""invalid_authtype"" , json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; # ifdef _WITH_VRRP_AUTH_ json_object_object_add ( json_stats , ""authtype_mismatch"" , json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; json_object_object_add ( json_stats , ""auth_failure"" , json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; # endif json_object_object_add ( json_stats , ""pri_zero_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; json_object_object_add ( json_stats , ""pri_zero_sent"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; json_object_object_add ( instance_json , ""data"" , json_data ) ; json_object_object_add ( instance_json , ""stats"" , json_stats ) ; json_object_array_add ( array , instance_json ) ; } fprintf ( file , ""%s"" , json_object_to_json_string ( array ) ) ; fclose ( file ) ; }"," ; file = fopen_safe  ( ""/tmp/keepalived.json"" ,"
537,"CWE-400 static void perf_event_read_event ( struct perf_event * event , struct task_struct * task ) { struct perf_output_handle handle ; struct perf_sample_data sample ; struct perf_read_event read_event = { . header = { . type = PERF_RECORD_READ , . misc = 0 , . size = sizeof ( read_event ) + event -> read_size , } , . pid = perf_event_pid ( event , task ) , . tid = perf_event_tid ( event , task ) , } ; int ret ; perf_event_header__init_id ( & read_event . header , & sample , event ) ;  ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ;  if ( ret ) return ; perf_output_put ( & handle , read_event ) ; perf_output_read ( & handle , event ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; }"," size , 0  ) ; if"
538,"CWE-400 static void emulate_load_store_insn ( struct pt_regs * regs , void __user * addr , unsigned int __user * pc ) { union mips_instruction insn ; unsigned long value ; unsigned int res ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;  __get_user ( insn . word , pc ) ; switch ( insn . i_format . opcode ) { case ll_op : case lld_op : case sc_op : case scd_op : case ldl_op : case ldr_op : case lwl_op : case lwr_op : case sdl_op : case sdr_op : case swl_op : case swr_op : case lb_op : case lbu_op : case sb_op : goto sigbus ; case lh_op : if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __BIG_ENDIAN ""1:\\tlb\\t%0,0(%2)\\n"" ""2:\\tlbu\\t$1,1(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlb\\t%0,1(%2)\\n"" ""2:\\tlbu\\t$1,0(%2)\\n\\t"" # endif ""sll\\t%0,0x8\\n\\t"" ""or\\t%0,$1\\n\\t"" ""li\\t%1,0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lw_op : if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tlwl\\t%0,(%2)\\n"" ""2:\\tlwr\\t%0,3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlwl\\t%0,3(%2)\\n"" ""2:\\tlwr\\t%0,(%2)\\n\\t"" # endif ""li\\t%1,0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lhu_op : if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __BIG_ENDIAN ""1:\\tlbu\\t%0,0(%2)\\n"" ""2:\\tlbu\\t$1,1(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlbu\\t%0,1(%2)\\n"" ""2:\\tlbu\\t$1,0(%2)\\n\\t"" # endif ""sll\\t%0,0x8\\n\\t"" ""or\\t%0,$1\\n\\t"" ""li\\t%1,0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lwu_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tlwl\\t%0,(%2)\\n"" ""2:\\tlwr\\t%0,3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tlwl\\t%0,3(%2)\\n"" ""2:\\tlwr\\t%0,(%2)\\n\\t"" # endif ""dsll\\t%0,%0,32\\n\\t"" ""dsrl\\t%0,%0,32\\n\\t"" ""li\\t%1,0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case ld_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_READ , addr , 8 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tldl\\t%0,(%2)\\n"" ""2:\\tldr\\t%0,7(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tldl\\t%0,7(%2)\\n"" ""2:\\tldr\\t%0,(%2)\\n\\t"" # endif ""li\\t%1,0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case sh_op : if ( ! access_ok ( VERIFY_WRITE , addr , 2 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN "".set\\tnoat\\n"" ""1:\\tsb\\t%1,1(%2)\\n\\t"" ""srl\\t$1,%1,0x8\\n"" ""2:\\tsb\\t$1,0(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif # ifdef __LITTLE_ENDIAN "".set\\tnoat\\n"" ""1:\\tsb\\t%1,0(%2)\\n\\t"" ""srl\\t$1,%1,0x8\\n"" ""2:\\tsb\\t$1,1(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif ""li\\t%0,0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sw_op : if ( ! access_ok ( VERIFY_WRITE , addr , 4 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tswl\\t%1,(%2)\\n"" ""2:\\tswr\\t%1,3(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tswl\\t%1,3(%2)\\n"" ""2:\\tswr\\t%1,(%2)\\n\\t"" # endif ""li\\t%0,0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sd_op : # ifdef CONFIG_64BIT if ( ! access_ok ( VERIFY_WRITE , addr , 8 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __BIG_ENDIAN ""1:\\tsdl\\t%1,(%2)\\n"" ""2:\\tsdr\\t%1,7(%2)\\n\\t"" # endif # ifdef __LITTLE_ENDIAN ""1:\\tsdl\\t%1,7(%2)\\n"" ""2:\\tsdr\\t%1,(%2)\\n\\t"" # endif ""li\\t%0,0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" STR ( PTR ) ""\\t1b,4b\\n\\t"" STR ( PTR ) ""\\t2b,4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - EFAULT ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; # endif goto sigill ; case lwc1_op : case ldc1_op : case swc1_op : case sdc1_op : goto sigbus ; case lwc2_op : cu2_notifier_call_chain ( CU2_LWC2_OP , regs ) ; break ; case ldc2_op : cu2_notifier_call_chain ( CU2_LDC2_OP , regs ) ; break ; case swc2_op : cu2_notifier_call_chain ( CU2_SWC2_OP , regs ) ; break ; case sdc2_op : cu2_notifier_call_chain ( CU2_SDC2_OP , regs ) ; break ; default : goto sigill ; } # ifdef CONFIG_DEBUG_FS unaligned_instructions ++ ; # endif return ; fault : if ( fixup_exception ( regs ) ) return ; die_if_kernel ( ""Unhandledkernelunalignedaccess"" , regs ) ; force_sig ( SIGSEGV , current ) ; return ; sigbus : die_if_kernel ( ""Unhandledkernelunalignedaccess"" , regs ) ; force_sig ( SIGBUS , current ) ; return ; sigill : die_if_kernel ( ""Unhandledkernelunalignedaccessorinvalidinstruction"" , regs ) ; force_sig ( SIGILL , current ) ; }"," PERF_COUNT_SW_EMULATION_FAULTS , 1  , regs ,"
539,"CWE-000 static ssize_t ext4_ext_direct_IO ( int rw , struct kiocb * iocb , const struct iovec * iov , loff_t offset , unsigned long nr_segs ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; ssize_t ret ; size_t count = iov_length ( iov , nr_segs ) ; loff_t final_size = offset + count ; if ( rw == WRITE && final_size <= inode -> i_size ) { iocb -> private = NULL ; EXT4_I ( inode ) -> cur_aio_dio = NULL ; if ( ! is_sync_kiocb ( iocb ) ) {  iocb -> private = ext4_init_io_end ( inode ) ;  if ( ! iocb -> private ) return - ENOMEM ; EXT4_I ( inode ) -> cur_aio_dio = iocb -> private ; } ret = blockdev_direct_IO ( rw , iocb , inode , inode -> i_sb -> s_bdev , iov , offset , nr_segs , ext4_get_block_write , ext4_end_io_dio ) ; if ( iocb -> private ) EXT4_I ( inode ) -> cur_aio_dio = NULL ; if ( ret != - EIOCBQUEUED && ret <= 0 && iocb -> private ) { ext4_free_io_end ( iocb -> private ) ; iocb -> private = NULL ; } else if ( ret > 0 && ext4_test_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ) { int err ; err = ext4_convert_unwritten_extents ( inode , offset , ret ) ; if ( err < 0 ) ret = err ; ext4_clear_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; } return ret ; } return ext4_ind_direct_IO ( rw , iocb , iov , offset , nr_segs ) ; }"," ext4_init_io_end ( inode , GFP_NOFS"
540,"CWE-415 void gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) {  gdImagePtr pim = 0 , tim = im ;  int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) {  pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ;  if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , tim -> interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; }  } "," out ) { _gdImageGifCtx  ( im ,  ( im , out  ) ; }  ) ; }    "
541,"CWE-416 int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ;  if ( map_data )  copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ;  rq -> bio = NULL ;  return - EINVAL ; }", ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if (  bio ) ; fail :
542,"CWE-476 int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef CONFIG_BOOKE case KVM_CAP_PPC_BOOKE_SREGS : case KVM_CAP_PPC_BOOKE_WATCHDOG : case KVM_CAP_PPC_EPR : # else case KVM_CAP_PPC_SEGSTATE : case KVM_CAP_PPC_HIOR : case KVM_CAP_PPC_PAPR : # endif case KVM_CAP_PPC_UNSET_IRQ : case KVM_CAP_PPC_IRQ_LEVEL : case KVM_CAP_ENABLE_CAP : case KVM_CAP_ENABLE_CAP_VM : case KVM_CAP_ONE_REG : case KVM_CAP_IOEVENTFD : case KVM_CAP_DEVICE_CTRL : case KVM_CAP_IMMEDIATE_EXIT : r = 1 ; break ; case KVM_CAP_PPC_PAIRED_SINGLES : case KVM_CAP_PPC_OSI : case KVM_CAP_PPC_GET_PVINFO : # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) case KVM_CAP_SW_TLB : # endif r = ! hv_enabled ; break ; # ifdef CONFIG_KVM_MPIC case KVM_CAP_IRQ_MPIC : r = 1 ; break ; # endif # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_SPAPR_TCE : case KVM_CAP_SPAPR_TCE_64 : case KVM_CAP_SPAPR_TCE_VFIO : case KVM_CAP_PPC_RTAS : case KVM_CAP_PPC_FIXUP_HCALL : case KVM_CAP_PPC_ENABLE_HCALL : # ifdef CONFIG_KVM_XICS case KVM_CAP_IRQ_XICS : # endif r = 1 ; break ; case KVM_CAP_PPC_ALLOC_HTAB : r = hv_enabled ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_SMT : r = 0 ; if ( kvm ) { if ( kvm -> arch . emul_smt_mode > 1 ) r = kvm -> arch . emul_smt_mode ; else r = kvm -> arch . smt_mode ; } else if ( hv_enabled ) { if ( cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = 1 ; else r = threads_per_subcore ; } break ; case KVM_CAP_PPC_SMT_POSSIBLE : r = 1 ; if ( hv_enabled ) { if ( ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = ( ( threads_per_subcore << 1 ) - 1 ) ; else r = 8 | 4 | 2 | 1 ; } break ; case KVM_CAP_PPC_RMA : r = 0 ; break ; case KVM_CAP_PPC_HWRNG : r = kvmppc_hwrng_present ( ) ; break ; case KVM_CAP_PPC_MMU_RADIX : r = ! ! ( hv_enabled && radix_enabled ( ) ) ; break ; case KVM_CAP_PPC_MMU_HASH_V3 : r = ! ! ( hv_enabled && ! radix_enabled ( ) && cpu_has_feature ( CPU_FTR_ARCH_300 ) ) ; break ; # endif case KVM_CAP_SYNC_MMU : # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE r = hv_enabled ; # elif defined ( KVM_ARCH_WANT_MMU_NOTIFIER ) r = 1 ; # else r = 0 ; # endif break ; # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_HTAB_FD : r = hv_enabled ; break ; # endif case KVM_CAP_NR_VCPUS : if ( hv_enabled ) r = num_present_cpus ( ) ; else r = num_online_cpus ( ) ; break ; case KVM_CAP_NR_MEMSLOTS : r = KVM_USER_MEM_SLOTS ; break ; case KVM_CAP_MAX_VCPUS : r = KVM_MAX_VCPUS ; break ; # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_PPC_GET_SMMU_INFO : r = 1 ; break ; case KVM_CAP_SPAPR_MULTITCE : r = 1 ; break ; case KVM_CAP_SPAPR_RESIZE_HPT : r = ! ! hv_enabled && ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_FWNMI : r = hv_enabled ; break ; # endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) &&  is_kvmppc_hv_enabled ( kvm ) ;  break ; default : r = 0 ; break ; } return r ; }", CPU_FTR_TM_COMP ) && hv_enabled  ; break ;
543,"CWE-787 int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ;  char group [ LONG_STRING ] ;  char desc [ HUGE_STRING ] = """" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ;  if ( sscanf ( line , ""%s"" ANUM """" ANUM ""%c%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 )   return 0 ;  nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }"," [ LONG_STRING ] = """"  ( line , ""%1023s""  ANUM """" ANUM  ANUM """" ANUM ""%c%8191[^\\n]""  , group ,  < 4 ) { mutt_debug ( 4 , ""Cannotparseserverline:%s\\n"" , line ) ;  return 0 ; }"
544,"CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) {  AcquireNextImage ( image_info , image ) ;  if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;"
545,"CWE-119 bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , struct drm_display_mode * mode ) { struct radeon_mode_info * mode_info = & rdev -> mode_info ; ATOM_ANALOG_TV_INFO * tv_info ; ATOM_ANALOG_TV_INFO_V1_2 * tv_info_v1_2 ; ATOM_DTD_FORMAT * dtd_timings ; int data_index = GetIndexIntoMasterTable ( DATA , AnalogTV_Info ) ; u8 frev , crev ; u16 data_offset , misc ; if ( ! atom_parse_data_header ( mode_info -> atom_context , data_index , NULL , & frev , & crev , & data_offset ) ) return false ; switch ( crev ) { case 1 : tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ;  if ( index > MAX_SUPPORTED_TV_TIMING )  return false ; mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ; mode -> crtc_hdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Disp ) ; mode -> crtc_hsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) ; mode -> crtc_hsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Total ) ; mode -> crtc_vdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Disp ) ; mode -> crtc_vsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) ; mode -> crtc_vsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( tv_info -> aModeTimings [ index ] . susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usPixelClock ) * 10 ; if ( index == 1 ) { mode -> crtc_htotal -= 1 ; mode -> crtc_vtotal -= 1 ; } break ; case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ;  if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 )  return false ; dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ; mode -> crtc_htotal = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHBlanking_Time ) ; mode -> crtc_hdisplay = le16_to_cpu ( dtd_timings -> usHActive ) ; mode -> crtc_hsync_start = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHSyncOffset ) ; mode -> crtc_hsync_end = mode -> crtc_hsync_start + le16_to_cpu ( dtd_timings -> usHSyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVBlanking_Time ) ; mode -> crtc_vdisplay = le16_to_cpu ( dtd_timings -> usVActive ) ; mode -> crtc_vsync_start = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVSyncOffset ) ; mode -> crtc_vsync_end = mode -> crtc_vsync_start + le16_to_cpu ( dtd_timings -> usVSyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( dtd_timings -> susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( dtd_timings -> usPixClk ) * 10 ; break ; } return true ; }", if ( index >=  MAX_SUPPORTED_TV_TIMING ) return  if ( index >=  MAX_SUPPORTED_TV_TIMING_V1_2 ) return
546,"CWE-119 static void multiframe_quality_enhance_block ( int blksize , int qcurr , int qprev , unsigned char * y , unsigned char * u , unsigned char * v , int y_stride , int uv_stride , unsigned char * yd , unsigned char * ud , unsigned char * vd , int yd_stride , int uvd_stride ) { static const unsigned char VP8_ZEROS [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; int uvblksize = blksize >> 1 ; int qdiff = qcurr - qprev ; int i ; unsigned char * up ; unsigned char * udp ; unsigned char * vp ; unsigned char * vdp ; unsigned int act , actd , sad , usad , vsad , sse , thr , thrsq , actrisk ; if ( blksize == 16 ) {  actd = ( vp8_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ;   act = ( vp8_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ;  # ifdef USE_SSD  sad = ( vp8_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ) ;  sad = ( sse + 128 ) >> 8 ; usad = ( vp8_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; usad = ( sse + 32 ) >> 6 ;  vsad = ( vp8_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ) ;  vsad = ( sse + 32 ) >> 6 ; # else sad = ( vp8_sad16x16 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 128 ) >> 8 ; usad = ( vp8_sad8x8 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 32 ) >> 6 ; vsad = ( vp8_sad8x8 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 32 ) >> 6 ; # endif } else { actd = ( vp8_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ;  act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ;  # ifdef USE_SSD  sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ;  sad = ( sse + 32 ) >> 6 ;  usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ;  usad = ( sse + 8 ) >> 4 ;  vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ;  vsad = ( sse + 8 ) >> 4 ; # else sad = ( vp8_sad8x8 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 32 ) >> 6 ; usad = ( vp8_sad4x4 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 8 ) >> 4 ; vsad = ( vp8_sad4x4 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 8 ) >> 4 ; # endif } actrisk = ( actd > act * 5 ) ; thr = ( qdiff >> 4 ) ; while ( actd >>= 1 ) thr ++ ; while ( qprev >>= 2 ) thr ++ ; # ifdef USE_SSD thrsq = thr * thr ; if ( sad < thrsq && 4 * usad < thrsq && 4 * vsad < thrsq && ! actrisk ) # else if ( sad < thr && 2 * usad < thr && 2 * vsad < thr && ! actrisk ) # endif { int ifactor ; # ifdef USE_SSD sad = int_sqrt ( sad ) ; # endif ifactor = ( sad << MFQE_PRECISION ) / thr ; ifactor >>= ( qdiff >> 5 ) ; if ( ifactor ) { apply_ifactor ( y , y_stride , yd , yd_stride , u , v , uv_stride , ud , vd , uvd_stride , blksize , ifactor ) ; } } else { if ( blksize == 16 ) { vp8_copy_mem16x16 ( y , y_stride , yd , yd_stride ) ; vp8_copy_mem8x8 ( u , uv_stride , ud , uvd_stride ) ; vp8_copy_mem8x8 ( v , uv_stride , vd , uvd_stride ) ; } else { vp8_copy_mem8x8 ( y , y_stride , yd , yd_stride ) ; for ( up = u , udp = ud , i = 0 ; i < uvblksize ; ++ i , up += uv_stride , udp += uvd_stride )  vpx_memcpy ( udp , up , uvblksize ) ;  for ( vp = v , vdp = vd , i = 0 ; i < uvblksize ; ++ i , vp += uv_stride , vdp += uvd_stride )  vpx_memcpy ( vdp , vp , uvblksize ) ;  } } }"," actd = ( vpx_variance16x16  ( yd ,  act = ( vpx_variance16x16  ( y ,  # ifdef USE_SSD vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ;  sad = ( sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16  ( y ,  yd , yd_stride ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride ) + 32 ) >> 6 ; # endif } else { actd = ( vpx_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0  & sse )  + 32 )  >> 6 ;  act = (  act = ( vpx_variance8x8  ( y ,  # ifdef USE_SSD vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ;  sad = ( sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8  ( y ,  yd , yd_stride )  + 32 )  usad = ( vpx_sad4x4  ( u ,  ud , uvd_stride )  + 8 )  vsad = ( vpx_sad4x4  ( v ,  vd , uvd_stride  ) + 8  += uvd_stride ) memcpy  ( udp ,  += uvd_stride ) memcpy  ( vdp ,"
547,"CWE-125 static int update_write_order_info ( rdpContext * context , wStream * s , ORDER_INFO * orderInfo , size_t offset ) { size_t position ; WINPR_UNUSED ( context ) ; position = Stream_GetPosition ( s ) ; Stream_SetPosition ( s , offset ) ; Stream_Write_UINT8 ( s , orderInfo -> controlFlags ) ; if ( orderInfo -> controlFlags & ORDER_TYPE_CHANGE ) Stream_Write_UINT8 ( s , orderInfo -> orderType ) ; update_write_field_flags ( s , orderInfo -> fieldFlags , orderInfo -> controlFlags ,  PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ;  update_write_bounds ( s , orderInfo ) ; Stream_SetPosition ( s , position ) ; return 0 ; }"," -> controlFlags , get_primary_drawing_order_field_bytes (  orderInfo -> orderType  orderInfo -> orderType , NULL )  ) ; update_write_bounds"
548,"CWE-401 int crypto_reportstat ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_reportstat_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err )  return err ;  return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }", ( err ) { kfree_skb ( skb ) ; return err ; }  return nlmsg_unicast (
549,"CWE-20 static int unix_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( iocb ) ; struct scm_cookie tmp_scm ; struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; int copied = 0 ; int check_creds = 0 ; int target ; int err = 0 ; long timeo ; int skip ; err = - EINVAL ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;  msg -> msg_namelen = 0 ;  if ( ! siocb -> scm ) { siocb -> scm = & tmp_scm ; memset ( & tmp_scm , 0 , sizeof ( tmp_scm ) ) ; } err = mutex_lock_interruptible ( & u -> readlock ) ; if ( err ) { err = sock_intr_errno ( timeo ) ; goto out ; } do { int chunk ; struct sk_buff * skb , * last ; unix_state_lock ( sk ) ; last = skb = skb_peek ( & sk -> sk_receive_queue ) ; again : if ( skb == NULL ) { unix_sk ( sk ) -> recursion_level = 0 ; if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; unix_state_unlock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; mutex_unlock ( & u -> readlock ) ; timeo = unix_stream_data_wait ( sk , timeo , last ) ; if ( signal_pending ( current ) || mutex_lock_interruptible ( & u -> readlock ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; unlock : unix_state_unlock ( sk ) ; break ; } skip = sk_peek_offset ( sk , flags ) ; while ( skip >= unix_skb_len ( skb ) ) { skip -= unix_skb_len ( skb ) ; last = skb ; skb = skb_peek_next ( skb , & sk -> sk_receive_queue ) ; if ( ! skb ) goto again ; } unix_state_unlock ( sk ) ; if ( check_creds ) { if ( ( UNIXCB ( skb ) . pid != siocb -> scm -> pid ) || ! uid_eq ( UNIXCB ( skb ) . uid , siocb -> scm -> creds . uid ) || ! gid_eq ( UNIXCB ( skb ) . gid , siocb -> scm -> creds . gid ) ) break ; } else if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) ) { scm_set_cred ( siocb -> scm , UNIXCB ( skb ) . pid , UNIXCB ( skb ) . uid , UNIXCB ( skb ) . gid ) ; check_creds = 1 ; } if ( sunaddr ) { unix_copy_addr ( msg , skb -> sk ) ; sunaddr = NULL ; } chunk = min_t ( unsigned int , unix_skb_len ( skb ) - skip , size ) ; if ( skb_copy_datagram_iovec ( skb , UNIXCB ( skb ) . consumed + skip , msg -> msg_iov , chunk ) ) { if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { UNIXCB ( skb ) . consumed += chunk ; sk_peek_offset_bwd ( sk , chunk ) ; if ( UNIXCB ( skb ) . fp ) unix_detach_fds ( siocb -> scm , skb ) ; if ( unix_skb_len ( skb ) ) break ; skb_unlink ( skb , & sk -> sk_receive_queue ) ; consume_skb ( skb ) ; if ( siocb -> scm -> fp ) break ; } else { if ( UNIXCB ( skb ) . fp ) siocb -> scm -> fp = scm_fp_dup ( UNIXCB ( skb ) . fp ) ; sk_peek_offset_fwd ( sk , chunk ) ; break ; } } while ( size ) ; mutex_unlock ( & u -> readlock ) ; scm_recv ( sock , msg , siocb -> scm , flags ) ; out : return copied ? : err ; }", MSG_DONTWAIT ) ;  if ( !
550,"CWE-119 static char * get_pid_environ_val ( pid_t pid , char * val ) {  char temp [ 500 ] ;  int i = 0 ; int foundit = 0 ; FILE * fp ; sprintf ( temp , ""/proc/%d/environ"" , pid ) ; fp = fopen ( temp , ""r"" ) ; if ( fp == NULL ) return NULL ; for ( ; ; ) {  temp [ i ] = fgetc ( fp ) ;  if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) { char * ret ; temp [ i ] = 0 ; ret = malloc ( strlen ( temp ) + 10 ) ; sprintf ( ret , ""%s"" , temp ) ; fclose ( fp ) ; return ret ; } switch ( temp [ i ] ) { case EOF : fclose ( fp ) ; return NULL ; case '=' : temp [ i ] = 0 ; if ( ! strcmp ( temp , val ) ) { foundit = 1 ; } i = 0 ; break ; case '\\0' : i = 0 ; break ; default : i ++ ; } } }"," val ) { int temp_size = 500 ; char * temp = malloc ( temp_size )  ; int i  ; ) { if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; }"
551,"CWE-000 static int encode_open_downgrade ( struct xdr_stream * xdr , const struct nfs_closeargs * arg ) { __be32 * p ; RESERVE_SPACE ( 4 + NFS4_STATEID_SIZE + 4 ) ; WRITE32 ( OP_OPEN_DOWNGRADE ) ; WRITEMEM ( arg -> stateid -> data , NFS4_STATEID_SIZE ) ; WRITE32 ( arg -> seqid -> sequence -> counter ) ;  encode_share_access ( xdr , arg -> open_flags ) ;  return 0 ; }"," , arg -> fmode  ) ; return"
552,"CWE-000 void ff_h264_free_tables ( H264Context * h , int free_rbsp ) { int i ; H264Context * hx ; av_freep ( & h -> intra4x4_pred_mode ) ; av_freep ( & h -> chroma_pred_mode_table ) ; av_freep ( & h -> cbp_table ) ; av_freep ( & h -> mvd_table [ 0 ] ) ; av_freep ( & h -> mvd_table [ 1 ] ) ; av_freep ( & h -> direct_table ) ; av_freep ( & h -> non_zero_count ) ; av_freep ( & h -> slice_table_base ) ; h -> slice_table = NULL ; av_freep ( & h -> list_counts ) ; av_freep ( & h -> mb2b_xy ) ; av_freep ( & h -> mb2br_xy ) ; av_buffer_pool_uninit ( & h -> qscale_table_pool ) ; av_buffer_pool_uninit ( & h -> mb_type_pool ) ; av_buffer_pool_uninit ( & h -> motion_val_pool ) ; av_buffer_pool_uninit ( & h -> ref_index_pool ) ; if ( free_rbsp && h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ;  av_freep ( & h -> DPB ) ;  } else if ( h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) h -> DPB [ i ] . needs_realloc = 1 ; } h -> cur_pic_ptr = NULL ; for ( i = 0 ; i < H264_MAX_THREADS ; i ++ ) { hx = h -> thread_context [ i ] ; if ( ! hx ) continue ; av_freep ( & hx -> top_borders [ 1 ] ) ; av_freep ( & hx -> top_borders [ 0 ] ) ; av_freep ( & hx -> bipred_scratchpad ) ; av_freep ( & hx -> edge_emu_buffer ) ; av_freep ( & hx -> dc_val_base ) ; av_freep ( & hx -> er . mb_index2xy ) ; av_freep ( & hx -> er . error_status_table ) ; av_freep ( & hx -> er . er_temp_buffer ) ; av_freep ( & hx -> er . mbintra_table ) ; av_freep ( & hx -> er . mbskip_table ) ; if ( free_rbsp ) { av_freep ( & hx -> rbsp_buffer [ 1 ] ) ; av_freep ( & hx -> rbsp_buffer [ 0 ] ) ; hx -> rbsp_buffer_size [ 0 ] = 0 ; hx -> rbsp_buffer_size [ 1 ] = 0 ; } if ( i ) av_freep ( & h -> thread_context [ i ] ) ; } }"," ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;"
553,"CWE-190 static enum hrtimer_restart posix_timer_fn ( struct hrtimer * timer ) { struct k_itimer * timr ; unsigned long flags ; int si_private = 0 ; enum hrtimer_restart ret = HRTIMER_NORESTART ; timr = container_of ( timer , struct k_itimer , it . real . timer ) ; spin_lock_irqsave ( & timr -> it_lock , flags ) ; timr -> it_active = 0 ; if ( timr -> it_interval != 0 ) si_private = ++ timr -> it_requeue_pending ; if ( posix_timer_event ( timr , si_private ) ) { if ( timr -> it_interval != 0 ) { ktime_t now = hrtimer_cb_get_time ( timer ) ; # ifdef CONFIG_HIGH_RES_TIMERS { ktime_t kj = NSEC_PER_SEC / HZ ; if ( timr -> it_interval < kj ) now = ktime_add ( now , kj ) ; } # endif  timr -> it_overrun += ( unsigned int )  hrtimer_forward ( timer , now , timr -> it_interval ) ; ret = HRTIMER_RESTART ; ++ timr -> it_requeue_pending ; timr -> it_active = 1 ; } } unlock_timer ( timr , flags ) ; return ret ; }", -> it_overrun +=  hrtimer_forward ( timer
554,"CWE-287 static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ;  err = scm_send ( sock , msg , siocb -> scm ) ;  if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }"," siocb -> scm , false"
555,"CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ;  sctp_auth_key_put ( asoc -> asoc_shared_key ) ;  sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }", = NULL ;  sctp_auth_asoc_init_active_key ( asoc
556,"CWE-611 void * create_directory_config ( apr_pool_t * mp , char * path ) { directory_config * dcfg = ( directory_config * ) apr_pcalloc ( mp , sizeof ( directory_config ) ) ; if ( dcfg == NULL ) return NULL ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Createddirectoryconfig%pppath%s"" , dcfg , path ) ; # endif dcfg -> mp = mp ; dcfg -> is_enabled = NOT_SET ; dcfg -> reqbody_access = NOT_SET ; dcfg -> reqintercept_oe = NOT_SET ; dcfg -> reqbody_buffering = NOT_SET ; dcfg -> reqbody_inmemory_limit = NOT_SET ; dcfg -> reqbody_limit = NOT_SET ; dcfg -> reqbody_no_files_limit = NOT_SET ; dcfg -> resbody_access = NOT_SET ; dcfg -> debuglog_name = NOT_SET_P ; dcfg -> debuglog_level = NOT_SET ; dcfg -> debuglog_fd = NOT_SET_P ; dcfg -> of_limit = NOT_SET ; dcfg -> if_limit_action = NOT_SET ; dcfg -> of_limit_action = NOT_SET ; dcfg -> of_mime_types = NOT_SET_P ; dcfg -> of_mime_types_cleared = NOT_SET ; dcfg -> cookie_format = NOT_SET ; dcfg -> argument_separator = NOT_SET ; dcfg -> cookiev0_separator = NOT_SET_P ; dcfg -> rule_inheritance = NOT_SET ; dcfg -> rule_exceptions = apr_array_make ( mp , 16 , sizeof ( rule_exception * ) ) ; dcfg -> hash_method = apr_array_make ( mp , 16 , sizeof ( hash_method * ) ) ; dcfg -> auditlog_flag = NOT_SET ; dcfg -> auditlog_type = NOT_SET ; dcfg -> max_rule_time = NOT_SET ; dcfg -> auditlog_dirperms = NOT_SET ; dcfg -> auditlog_fileperms = NOT_SET ; dcfg -> auditlog_name = NOT_SET_P ; dcfg -> auditlog2_name = NOT_SET_P ; dcfg -> auditlog_fd = NOT_SET_P ; dcfg -> auditlog2_fd = NOT_SET_P ; dcfg -> auditlog_storage_dir = NOT_SET_P ; dcfg -> auditlog_parts = NOT_SET_P ; dcfg -> auditlog_relevant_regex = NOT_SET_P ; dcfg -> ruleset = NULL ; dcfg -> tmp_dir = NOT_SET_P ; dcfg -> upload_dir = NOT_SET_P ; dcfg -> upload_keep_files = NOT_SET ; dcfg -> upload_validates_files = NOT_SET ; dcfg -> upload_filemode = NOT_SET ; dcfg -> upload_file_limit = NOT_SET ; dcfg -> tmp_chain_starter = NULL ; dcfg -> tmp_default_actionset = NULL ; dcfg -> tmp_rule_placeholders = NULL ; dcfg -> data_dir = NOT_SET_P ; dcfg -> webappid = NOT_SET_P ; dcfg -> sensor_id = NOT_SET_P ; dcfg -> httpBlkey = NOT_SET_P ; dcfg -> content_injection_enabled = NOT_SET ; dcfg -> stream_inbody_inspection = NOT_SET ; dcfg -> stream_outbody_inspection = NOT_SET ; dcfg -> geo = NOT_SET_P ; dcfg -> gsb = NOT_SET_P ; dcfg -> u_map = NOT_SET_P ; dcfg -> cache_trans = NOT_SET ; dcfg -> cache_trans_incremental = NOT_SET ; dcfg -> cache_trans_min = NOT_SET ; dcfg -> cache_trans_max = NOT_SET ; dcfg -> cache_trans_maxitems = NOT_SET ; dcfg -> rule_id_htab = apr_hash_make ( mp ) ; dcfg -> component_signatures = apr_array_make ( mp , 16 , sizeof ( char * ) ) ; dcfg -> request_encoding = NOT_SET_P ; dcfg -> disable_backend_compression = NOT_SET ; dcfg -> col_timeout = NOT_SET ; dcfg -> crypto_key = NOT_SET_P ; dcfg -> crypto_key_len = NOT_SET ; dcfg -> crypto_key_add = NOT_SET ; dcfg -> crypto_param_name = NOT_SET_P ; dcfg -> hash_is_enabled = NOT_SET ; dcfg -> hash_enforcement = NOT_SET ; dcfg -> crypto_hash_href_rx = NOT_SET ; dcfg -> crypto_hash_faction_rx = NOT_SET ; dcfg -> crypto_hash_location_rx = NOT_SET ; dcfg -> crypto_hash_iframesrc_rx = NOT_SET ; dcfg -> crypto_hash_framesrc_rx = NOT_SET ; dcfg -> crypto_hash_href_pm = NOT_SET ; dcfg -> crypto_hash_faction_pm = NOT_SET ; dcfg -> crypto_hash_location_pm = NOT_SET ; dcfg -> crypto_hash_iframesrc_pm = NOT_SET ; dcfg -> crypto_hash_framesrc_pm = NOT_SET ;  return dcfg ;  }", = NOT_SET ; dcfg -> xml_external_entity = NOT_SET ;
557,"CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ;  pdf = calloc ( 1 , sizeof ( pdf_t ) ) ;  if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ;  pdf -> name = malloc ( strlen ( n ) + 1 ) ;  strcpy ( pdf -> name , n ) ; } else {  pdf -> name = malloc ( strlen ( ""Unknown"" ) + 1 ) ;  strcpy ( pdf -> name , ""Unknown"" ) ; } return pdf ; }", ; pdf = safe_calloc (  sizeof ( pdf_t  -> name = safe_calloc  ( strlen (  -> name = safe_calloc  ( strlen (
558,"CWE-20 struct sk_buff * __skb_recv_datagram ( struct sock * sk , unsigned int flags , int * peeked , int * off , int * err ) { struct sk_buff * skb ; long timeo ; int error = sock_error ( sk ) ; if ( error ) goto no_packet ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { unsigned long cpu_flags ; struct sk_buff_head * queue = & sk -> sk_receive_queue ; spin_lock_irqsave ( & queue -> lock , cpu_flags ) ; skb_queue_walk ( queue , skb ) { * peeked = skb -> peeked ; if ( flags & MSG_PEEK ) {  if ( * off >= skb -> len ) {  * off -= skb -> len ; continue ; } skb -> peeked = 1 ; atomic_inc ( & skb -> users ) ; } else __skb_unlink ( skb , queue ) ; spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; return skb ; } spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; error = - EAGAIN ; if ( ! timeo ) goto no_packet ; } while ( ! wait_for_packet ( sk , err , & timeo ) ) ; return NULL ; no_packet : * err = error ; return NULL ; }", skb -> len && skb -> len
559,"CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , ""MLTIwithmultiple(%d)MDPR"" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data ,  size2 , mime ) ;  if ( ret < 0 ) return ret ; } return 0 ; }"," , size2 , NULL  ) ; if"
560,"CWE-17 static int rt_fill_info ( struct net * net , __be32 dst , __be32 src , struct flowi4 * fl4 , struct sk_buff * skb , u32 portid , u32 seq , int event , int nowait , unsigned int flags ) { struct rtable * rt = skb_rtable ( skb ) ; struct rtmsg * r ; struct nlmsghdr * nlh ; unsigned long expires = 0 ; u32 error ; u32 metrics [ RTAX_MAX ] ; nlh = nlmsg_put ( skb , portid , seq , event , sizeof ( * r ) , flags ) ; if ( nlh == NULL ) return - EMSGSIZE ; r = nlmsg_data ( nlh ) ; r -> rtm_family = AF_INET ; r -> rtm_dst_len = 32 ; r -> rtm_src_len = 0 ; r -> rtm_tos = fl4 -> flowi4_tos ; r -> rtm_table = RT_TABLE_MAIN ; if ( nla_put_u32 ( skb , RTA_TABLE , RT_TABLE_MAIN ) ) goto nla_put_failure ; r -> rtm_type = rt -> rt_type ; r -> rtm_scope = RT_SCOPE_UNIVERSE ; r -> rtm_protocol = RTPROT_UNSPEC ; r -> rtm_flags = ( rt -> rt_flags & ~ 0xFFFF ) | RTM_F_CLONED ; if ( rt -> rt_flags & RTCF_NOTIFY )  r -> rtm_flags |= RTM_F_NOTIFY ;  if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ; if ( src ) { r -> rtm_src_len = 32 ; if ( nla_put_be32 ( skb , RTA_SRC , src ) ) goto nla_put_failure ; } if ( rt -> dst . dev && nla_put_u32 ( skb , RTA_OIF , rt -> dst . dev -> ifindex ) ) goto nla_put_failure ; # ifdef CONFIG_IP_ROUTE_CLASSID if ( rt -> dst . tclassid && nla_put_u32 ( skb , RTA_FLOW , rt -> dst . tclassid ) ) goto nla_put_failure ; # endif if ( ! rt_is_input_route ( rt ) && fl4 -> saddr != src ) { if ( nla_put_be32 ( skb , RTA_PREFSRC , fl4 -> saddr ) ) goto nla_put_failure ; } if ( rt -> rt_uses_gateway && nla_put_be32 ( skb , RTA_GATEWAY , rt -> rt_gateway ) ) goto nla_put_failure ; expires = rt -> dst . expires ; if ( expires ) { unsigned long now = jiffies ; if ( time_before ( now , expires ) ) expires -= now ; else expires = 0 ; } memcpy ( metrics , dst_metrics_ptr ( & rt -> dst ) , sizeof ( metrics ) ) ; if ( rt -> rt_pmtu && expires ) metrics [ RTAX_MTU - 1 ] = rt -> rt_pmtu ; if ( rtnetlink_put_metrics ( skb , metrics ) < 0 ) goto nla_put_failure ; if ( fl4 -> flowi4_mark && nla_put_u32 ( skb , RTA_MARK , fl4 -> flowi4_mark ) ) goto nla_put_failure ; error = rt -> dst . error ; if ( rt_is_input_route ( rt ) ) { # ifdef CONFIG_IP_MROUTE if ( ipv4_is_multicast ( dst ) && ! ipv4_is_local_multicast ( dst ) && IPV4_DEVCONF_ALL ( net , MC_FORWARDING ) ) { int err = ipmr_get_route ( net , skb , fl4 -> saddr , fl4 -> daddr , r , nowait ) ; if ( err <= 0 ) { if ( ! nowait ) { if ( err == 0 ) return 0 ; goto nla_put_failure ; } else { if ( err == - EMSGSIZE ) goto nla_put_failure ; error = err ; } } } else # endif if ( nla_put_u32 ( skb , RTA_IIF , skb -> dev -> ifindex ) ) goto nla_put_failure ; } if ( rtnl_put_cacheinfo ( skb , & rt -> dst , 0 , expires , error ) < 0 ) goto nla_put_failure ; return nlmsg_end ( skb , nlh ) ; nla_put_failure : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }", rtm_flags |= RTM_F_NOTIFY ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT
561,"CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = ""PredictorEncodeTile"" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""Outofmemoryallocating"" TIFF_SSIZE_FORMAT ""bytetempbuffer."" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ;  return 0 ;  } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }"," ""(cc0%rowsize)!=0"" ) ; _TIFFfree ( working_copy ) ;"
562,"CWE-000 unsigned int nf_nat_redirect_ipv4 ( struct sk_buff * skb , const struct nf_nat_ipv4_multi_range_compat * mr , unsigned int hooknum ) { struct nf_conn * ct ; enum ip_conntrack_info ctinfo ; __be32 newdst ; struct nf_nat_range newrange ; NF_CT_ASSERT ( hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_LOCAL_OUT ) ; ct = nf_ct_get ( skb , & ctinfo ) ; NF_CT_ASSERT ( ct && ( ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ) ) ; if ( hooknum == NF_INET_LOCAL_OUT ) { newdst = htonl ( 0x7F000001 ) ; } else { struct in_device * indev ; struct in_ifaddr * ifa ; newdst = 0 ; rcu_read_lock ( ) ; indev = __in_dev_get_rcu ( skb -> dev ) ;  if ( indev != NULL ) {  ifa = indev -> ifa_list ; newdst = ifa -> ifa_local ; } rcu_read_unlock ( ) ; if ( ! newdst ) return NF_DROP ; } memset ( & newrange . min_addr , 0 , sizeof ( newrange . min_addr ) ) ; memset ( & newrange . max_addr , 0 , sizeof ( newrange . max_addr ) ) ; newrange . flags = mr -> range [ 0 ] . flags | NF_NAT_RANGE_MAP_IPS ; newrange . min_addr . ip = newdst ; newrange . max_addr . ip = newdst ; newrange . min_proto = mr -> range [ 0 ] . min ; newrange . max_proto = mr -> range [ 0 ] . max ; return nf_nat_setup_info ( ct , & newrange , NF_NAT_MANIP_DST ) ; }", if ( indev && indev -> ifa_list  ) { ifa
563,"CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; }  truncate_pagecache ( inode , inode -> i_size ) ;  if ( shrink )  ext4_truncate ( inode ) ;  } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }", ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
564,"CWE-264 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ;  int procfd ;  signed long personality ; if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failedtogettheinitpid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failedtogetcontextoftheinitprocess,pid=%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failedtogetpersonalityofthecontainer"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; init_ctx -> container = lxc_container_new ( name , lxcpath ) ; if ( ! init_ctx -> container ) return - 1 ; if ( ! fetch_seccomp ( init_ctx -> container , options ) ) WARN ( ""Failedtogetseccomppolicy"" ) ; if ( ! no_new_privs ( init_ctx -> container , options ) ) WARN ( ""CouldnotdeterminewhetherPR_SET_NO_NEW_PRIVSisset."" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failedtoautomaticallydeterminethe"" ""namespaceswhichthecontainerunshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""couldnotsetuprequiredIPCmechanismforattaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failedtocreatefirstsubprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) {  pid_t to_cleanup_pid = pid ;  close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; }  status = 0 ;  ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""errorusingIPCtonotifyattachedprocessforinitialization(0)"" ) ; goto cleanup_error ; }  ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;  if ( ret <= 0 ) {  if ( ret != 0 )  ERROR ( ""errorusingIPCtoreceivepidofattachedprocess"" ) ; goto cleanup_error ; }  if ( options -> stdin_fd == 0 ) {  signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""errorusingIPCtonotifyattachedprocessforinitialization(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 )  ERROR ( ""errorusingIPCtoreceivenotificationfromattachedprocess(1)"" ) ;  goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) {  ERROR ( ""errorusingIPCtonotifyattachedprocessforinitialization(2)"" ) ;  goto cleanup_error ; }  shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;  close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ;  cleanup_error :  shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""errorcommunicatingwithchildprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) && cgns_supported ( ) ) options -> namespaces |= CLONE_NEWCGROUP ;  procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;  if ( procfd < 0 ) { SYSERROR ( ""Unabletoopen/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; if ( ret < 0 ) { ERROR ( ""failedtoenterthenamespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""couldnotchangedirectoryto\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload ,  . procfd = procfd  } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failedtocreatesubprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""errorusingIPCtonotifymainprocessofpidoftheattachedprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }"," 2 ] ;  signed long personality  pid ) { int procfd = - 1 ;  cleanup_error ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( ""Unabletoopen/proc.""  ) ; goto  cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status  , sizeof (  , sizeof ( status )  ) ; if  0 ) { ERROR ( ""errorusingIPCtonotifyattachedprocessforinitialization(0)""  ) ; goto  cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""errorusingIPCtoreceivepidofattachedprocess"" ) ; goto cleanup_error ; }  ) ERROR ( ""errorusingIPCtoreceivenotification"" ""fromattachedprocess(1)""  ) ; goto  { ERROR ( ""ErrorusingIPCtonotifyattachedprocessfor"" ""initialization(2):%s."" , strerror ( errno )  ) ; goto  cleanup_error ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""ErrorusingIPCforthechildtotellustoopenLSMfd(3):%s."" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""ErrorusingIPCtosendchildLSMfd(4):%s."" , strerror ( errno ) ) ; goto cleanup_error ; } }  ; cleanup_error : if ( procfd >= 0 ) close ( procfd ) ;  |= CLONE_NEWCGROUP ;  ret = lxc_attach_to_ns  = exec_payload ,  } ; pid"
565,"CWE-20 int mpi_powm ( MPI res , MPI base , MPI exp , MPI mod ) { mpi_ptr_t mp_marker = NULL , bp_marker = NULL , ep_marker = NULL ; mpi_ptr_t xp_marker = NULL ; mpi_ptr_t tspace = NULL ; mpi_ptr_t rp , ep , mp , bp ; mpi_size_t esize , msize , bsize , rsize ; int esign , msign , bsign , rsign ; mpi_size_t size ; int mod_shift_cnt ; int negative_result ; int assign_rp = 0 ; mpi_size_t tsize = 0 ; int rc = - ENOMEM ; esize = exp -> nlimbs ; msize = mod -> nlimbs ; size = 2 * msize ; esign = exp -> sign ; msign = mod -> sign ; rp = res -> d ; ep = exp -> d ; if ( ! msize ) return - EINVAL ; if ( ! esize ) {  rp [ 0 ] = 1 ;   res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ;  res -> sign = 0 ; goto leave ; } mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; mod_shift_cnt = count_leading_zeros ( mod -> d [ msize - 1 ] ) ; if ( mod_shift_cnt ) mpihelp_lshift ( mp , mod -> d , msize , mod_shift_cnt ) ; else MPN_COPY ( mp , mod -> d , msize ) ; bsize = base -> nlimbs ; bsign = base -> sign ; if ( bsize > msize ) { bp = bp_marker = mpi_alloc_limb_space ( bsize + 1 ) ; if ( ! bp ) goto enomem ; MPN_COPY ( bp , base -> d , bsize ) ; mpihelp_divrem ( bp + msize , 0 , bp , bsize , mp , msize ) ; bsize = msize ; MPN_NORMALIZE ( bp , bsize ) ; } else bp = base -> d ; if ( ! bsize ) { res -> nlimbs = 0 ; res -> sign = 0 ; goto leave ; } if ( res -> alloced < size ) { if ( rp == ep || rp == mp || rp == bp ) { rp = mpi_alloc_limb_space ( size ) ; if ( ! rp ) goto enomem ; assign_rp = 1 ; } else { if ( mpi_resize ( res , size ) < 0 ) goto enomem ; rp = res -> d ; } } else { if ( rp == bp ) { BUG_ON ( bp_marker ) ; bp = bp_marker = mpi_alloc_limb_space ( bsize ) ; if ( ! bp ) goto enomem ; MPN_COPY ( bp , rp , bsize ) ; } if ( rp == ep ) { ep = ep_marker = mpi_alloc_limb_space ( esize ) ; if ( ! ep ) goto enomem ; MPN_COPY ( ep , rp , esize ) ; } if ( rp == mp ) { BUG_ON ( mp_marker ) ; mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; MPN_COPY ( mp , rp , msize ) ; } } MPN_COPY ( rp , bp , bsize ) ; rsize = bsize ; rsign = bsign ; { mpi_size_t i ; mpi_ptr_t xp ; int c ; mpi_limb_t e ; mpi_limb_t carry_limb ; struct karatsuba_ctx karactx ; xp = xp_marker = mpi_alloc_limb_space ( 2 * ( msize + 1 ) ) ; if ( ! xp ) goto enomem ; memset ( & karactx , 0 , sizeof karactx ) ; negative_result = ( ep [ 0 ] & 1 ) && base -> sign ; i = esize - 1 ; e = ep [ i ] ; c = count_leading_zeros ( e ) ; e = ( e << c ) << 1 ; c = BITS_PER_MPI_LIMB - 1 - c ; for ( ; ; ) { while ( c ) { mpi_ptr_t tp ; mpi_size_t xsize ; if ( rsize < KARATSUBA_THRESHOLD ) mpih_sqr_n_basecase ( xp , rp , rsize ) ; else { if ( ! tspace ) { tsize = 2 * rsize ; tspace = mpi_alloc_limb_space ( tsize ) ; if ( ! tspace ) goto enomem ; } else if ( tsize < ( 2 * rsize ) ) { mpi_free_limb_space ( tspace ) ; tsize = 2 * rsize ; tspace = mpi_alloc_limb_space ( tsize ) ; if ( ! tspace ) goto enomem ; } mpih_sqr_n ( xp , rp , rsize , tspace ) ; } xsize = 2 * rsize ; if ( xsize > msize ) { mpihelp_divrem ( xp + msize , 0 , xp , xsize , mp , msize ) ; xsize = msize ; } tp = rp ; rp = xp ; xp = tp ; rsize = xsize ; if ( ( mpi_limb_signed_t ) e < 0 ) { if ( bsize < KARATSUBA_THRESHOLD ) { mpi_limb_t tmp ; if ( mpihelp_mul ( xp , rp , rsize , bp , bsize , & tmp ) < 0 ) goto enomem ; } else { if ( mpihelp_mul_karatsuba_case ( xp , rp , rsize , bp , bsize , & karactx ) < 0 ) goto enomem ; } xsize = rsize + bsize ; if ( xsize > msize ) { mpihelp_divrem ( xp + msize , 0 , xp , xsize , mp , msize ) ; xsize = msize ; } tp = rp ; rp = xp ; xp = tp ; rsize = xsize ; } e <<= 1 ; c -- ; } i -- ; if ( i < 0 ) break ; e = ep [ i ] ; c = BITS_PER_MPI_LIMB ; } if ( mod_shift_cnt ) { carry_limb = mpihelp_lshift ( res -> d , rp , rsize , mod_shift_cnt ) ; rp = res -> d ; if ( carry_limb ) { rp [ rsize ] = carry_limb ; rsize ++ ; } } else { MPN_COPY ( res -> d , rp , rsize ) ; rp = res -> d ; } if ( rsize >= msize ) { mpihelp_divrem ( rp + msize , 0 , rp , rsize , mp , msize ) ; rsize = msize ; } if ( mod_shift_cnt ) mpihelp_rshift ( rp , rp , rsize , mod_shift_cnt ) ; MPN_NORMALIZE ( rp , rsize ) ; mpihelp_release_karatsuba_ctx ( & karactx ) ; } if ( negative_result && rsize ) { if ( mod_shift_cnt ) mpihelp_rshift ( mp , mp , msize , mod_shift_cnt ) ; mpihelp_sub ( rp , mp , msize , rp , rsize ) ; rsize = msize ; rsign = msign ; MPN_NORMALIZE ( rp , rsize ) ; } res -> nlimbs = rsize ; res -> sign = rsign ; leave : rc = 0 ; enomem : if ( assign_rp ) mpi_assign_limb_space ( res , rp , size ) ; if ( mp_marker ) mpi_free_limb_space ( mp_marker ) ; if ( bp_marker ) mpi_free_limb_space ( bp_marker ) ; if ( ep_marker ) mpi_free_limb_space ( ep_marker ) ; if ( xp_marker ) mpi_free_limb_space ( xp_marker ) ; if ( tspace ) mpi_free_limb_space ( tspace ) ; return rc ; }"," esize ) {  res -> nlimbs  : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }"
566,"CWE-20 int tls1_change_cipher_state ( SSL * s , int which ) { unsigned char * p , * mac_secret ; unsigned char tmp1 [ EVP_MAX_KEY_LENGTH ] ; unsigned char tmp2 [ EVP_MAX_KEY_LENGTH ] ; unsigned char iv1 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char iv2 [ EVP_MAX_IV_LENGTH * 2 ] ; unsigned char * ms , * key , * iv ; EVP_CIPHER_CTX * dd ; const EVP_CIPHER * c ; # ifndef OPENSSL_NO_COMP const SSL_COMP * comp ; # endif const EVP_MD * m ; int mac_type ; int * mac_secret_size ; EVP_MD_CTX * mac_ctx ; EVP_PKEY * mac_key ; int n , i , j , k , cl ; int reuse_dd = 0 ; c = s -> s3 -> tmp . new_sym_enc ; m = s -> s3 -> tmp . new_hash ; mac_type = s -> s3 -> tmp . new_mac_pkey_type ; # ifndef OPENSSL_NO_COMP comp = s -> s3 -> tmp . new_compression ; # endif if ( which & SSL3_CC_READ ) {  if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC )  s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_READ_MAC_STREAM ; if ( s -> enc_read_ctx != NULL ) reuse_dd = 1 ; else if ( ( s -> enc_read_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; else EVP_CIPHER_CTX_reset ( s -> enc_read_ctx ) ; dd = s -> enc_read_ctx ; mac_ctx = ssl_replace_hash ( & s -> read_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> expand ) ; s -> expand = NULL ; if ( comp != NULL ) { s -> expand = COMP_CTX_new ( comp -> method ) ; if ( s -> expand == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_read_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> read_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> read_mac_secret_size ) ;  } else {  if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ; else s -> mac_flags &= ~ SSL_MAC_FLAG_WRITE_MAC_STREAM ; if ( s -> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) ) reuse_dd = 1 ; else if ( ( s -> enc_write_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_new ( ) ; if ( mac_ctx == NULL ) goto err ; s -> write_hash = mac_ctx ; } else { mac_ctx = ssl_replace_hash ( & s -> write_hash , NULL ) ; if ( mac_ctx == NULL ) goto err ; } # ifndef OPENSSL_NO_COMP COMP_CTX_free ( s -> compress ) ; s -> compress = NULL ; if ( comp != NULL ) { s -> compress = COMP_CTX_new ( comp -> method ) ; if ( s -> compress == NULL ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , SSL_R_COMPRESSION_LIBRARY_ERROR ) ; goto err2 ; } } # endif if ( ! SSL_IS_DTLS ( s ) ) RECORD_LAYER_reset_write_sequence ( & s -> rlayer ) ; mac_secret = & ( s -> s3 -> write_mac_secret [ 0 ] ) ; mac_secret_size = & ( s -> s3 -> write_mac_secret_size ) ; } if ( reuse_dd ) EVP_CIPHER_CTX_reset ( dd ) ; p = s -> s3 -> tmp . key_block ; i = * mac_secret_size = s -> s3 -> tmp . new_mac_secret_size ; cl = EVP_CIPHER_key_length ( c ) ; j = cl ; if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) k = EVP_GCM_TLS_FIXED_IV_LEN ; else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) k = EVP_CCM_TLS_FIXED_IV_LEN ; else k = EVP_CIPHER_iv_length ( c ) ; if ( ( which == SSL3_CHANGE_CIPHER_CLIENT_WRITE ) || ( which == SSL3_CHANGE_CIPHER_SERVER_READ ) ) { ms = & ( p [ 0 ] ) ; n = i + i ; key = & ( p [ n ] ) ; n += j + j ; iv = & ( p [ n ] ) ; n += k + k ; } else { n = i ; ms = & ( p [ n ] ) ; n += i + j ; key = & ( p [ n ] ) ; n += j + k ; iv = & ( p [ n ] ) ; n += k ; } if ( n > s -> s3 -> tmp . key_block_length ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } memcpy ( mac_secret , ms , i ) ; if ( ! ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) ) { mac_key = EVP_PKEY_new_mac_key ( mac_type , NULL , mac_secret , * mac_secret_size ) ; if ( mac_key == NULL || EVP_DigestSignInit ( mac_ctx , NULL , m , NULL , mac_key ) <= 0 ) { EVP_PKEY_free ( mac_key ) ; SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } EVP_PKEY_free ( mac_key ) ; } # ifdef SSL_DEBUG printf ( ""which=%04X\\nmackey="" , which ) ; { int z ; for ( z = 0 ; z < i ; z ++ ) printf ( ""%02X%c"" , ms [ z ] , ( ( z + 1 ) % 16 ) ? '' : '\\n' ) ; } # endif if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_GCM_SET_IV_FIXED , k , iv ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) { int taglen ; if ( s -> s3 -> tmp . new_cipher -> algorithm_enc & ( SSL_AES128CCM8 | SSL_AES256CCM8 ) ) taglen = 8 ; else taglen = 16 ; if ( ! EVP_CipherInit_ex ( dd , c , NULL , NULL , NULL , ( which & SSL3_CC_WRITE ) ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_IVLEN , 12 , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_TAG , taglen , NULL ) || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_CCM_SET_IV_FIXED , k , iv ) || ! EVP_CipherInit_ex ( dd , NULL , NULL , key , NULL , - 1 ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } else { if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , iv , ( which & SSL3_CC_WRITE ) ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } } if ( ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) && * mac_secret_size && ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_MAC_KEY , * mac_secret_size , mac_secret ) ) { SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; goto err2 ; } # ifdef OPENSSL_SSL_TRACE_CRYPTO if ( s -> msg_callback ) { int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0 ; if ( * mac_secret_size ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_MAC , mac_secret , * mac_secret_size , s , s -> msg_callback_arg ) ; if ( c -> key_len ) s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_KEY , key , c -> key_len , s , s -> msg_callback_arg ) ; if ( k ) { if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) wh |= TLS1_RT_CRYPTO_FIXED_IV ; else wh |= TLS1_RT_CRYPTO_IV ; s -> msg_callback ( 2 , s -> version , wh , iv , k , s , s -> msg_callback_arg ) ; } } # endif # ifdef SSL_DEBUG printf ( ""which=%04X\\nkey="" , which ) ; { int z ; for ( z = 0 ; z < EVP_CIPHER_key_length ( c ) ; z ++ ) printf ( ""%02X%c"" , key [ z ] , ( ( z + 1 ) % 16 ) ? '' : '\\n' ) ; } printf ( ""\\niv="" ) ; { int z ; for ( z = 0 ; z < k ; z ++ ) printf ( ""%02X%c"" , iv [ z ] , ( ( z + 1 ) % 16 ) ? '' : '\\n' ) ; } printf ( ""\\n"" ) ; # endif OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 1 ) ; err : SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_MALLOC_FAILURE ) ; err2 : OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; return ( 0 ) ; }", ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s ->  } else { if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;
567,"CWE-404 int nfs3svc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ~ 0 ; args -> count = ntohl ( * p ++ ) ;  args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ;  args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;  return xdr_argsize_check ( rqstp , p ) ;  }"," ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;  ) ; return 1  ; } "
568,"CWE-19 int xfs_attr_rmtval_get ( struct xfs_da_args * args ) { struct xfs_bmbt_irec map [ ATTR_RMTVALUE_MAPSIZE ] ; struct xfs_mount * mp = args -> dp -> i_mount ; struct xfs_buf * bp ; xfs_dablk_t lblkno = args -> rmtblkno ; __uint8_t * dst = args -> value ;  int valuelen = args -> valuelen ;  int nmap ; int error ; int blkcnt = args -> rmtblkcnt ; int i ; int offset = 0 ; trace_xfs_attr_rmtval_get ( args ) ;  ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ;  while ( valuelen > 0 ) { nmap = ATTR_RMTVALUE_MAPSIZE ; error = xfs_bmapi_read ( args -> dp , ( xfs_fileoff_t ) lblkno , blkcnt , map , & nmap , XFS_BMAPI_ATTRFORK ) ; if ( error ) return error ; ASSERT ( nmap >= 1 ) ; for ( i = 0 ; ( i < nmap ) && ( valuelen > 0 ) ; i ++ ) { xfs_daddr_t dblkno ; int dblkcnt ; ASSERT ( ( map [ i ] . br_startblock != DELAYSTARTBLOCK ) && ( map [ i ] . br_startblock != HOLESTARTBLOCK ) ) ; dblkno = XFS_FSB_TO_DADDR ( mp , map [ i ] . br_startblock ) ; dblkcnt = XFS_FSB_TO_BB ( mp , map [ i ] . br_blockcount ) ; error = xfs_trans_read_buf ( mp , NULL , mp -> m_ddev_targp , dblkno , dblkcnt , 0 , & bp , & xfs_attr3_rmt_buf_ops ) ; if ( error ) return error ; error = xfs_attr_rmtval_copyout ( mp , bp , args -> dp -> i_ino , & offset , & valuelen , & dst ) ; xfs_buf_relse ( bp ) ; if ( error ) return error ; lblkno += map [ i ] . br_blockcount ; blkcnt -= map [ i ] . br_blockcount ; } } ASSERT ( valuelen == 0 ) ; return 0 ; }", ; int valuelen  ; int nmap  ATTR_KERNOVAL ) ) ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen
569,"CWE-59 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ;  int openasuser ;  int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ;  int should_free_authpending_file = 0 ;  parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unabletogethostname"" ) ; goto done ; } DBG ( ""Originnotspecified,using\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unabletoallocatememory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appidnotspecified,usingthesamevalueoforigin(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unabletoallocatememory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximumdevicesnumbernotset.Usingdefault(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unabletoallocatememory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unabletoaccessuser%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requestingauthenticationforuser%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unabletoretrievecredentialsforuser%s,(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Founduser%s"" , user ) ; DBG ( ""Homedirectoryfor%sis%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable%sisnotset.Usingdefaultvalue($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unabletoallocatememory"" ) ; retval = PAM_IGNORE ; goto done ; }  snprintf ( buf , authfile_dir_len ,  ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable%ssetto%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unabletoallocatememory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ;  }  DBG ( ""Usingdefaultauthenticationfile%s"" , buf ) ;  cfg -> auth_file = buf ;  should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Usingauthenticationfile%s"" , cfg -> auth_file ) ; }  openasuser = geteuid ( ) == 0 && cfg -> openasuser ;   if ( openasuser ) {   if ( seteuid ( pw_s . pw_uid ) ) {   DBG ( ""Unabletoswitchusertouid%i"" , pw_s . pw_uid ) ;  retval = PAM_IGNORE ; goto done ; }  DBG ( ""Switchedtouid%i"" , pw_s . pw_uid ) ;  } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) {  if ( seteuid ( 0 ) ) {  DBG ( ""Unabletoswitchbacktouid0"" ) ; retval = PAM_IGNORE ; goto done ; }  DBG ( ""Switchedbacktouid0"" ) ;  } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Foundnodevicesbutnouserokspecified.Skippingauthentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unabletogetdevicesfromfile%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Foundnodevices.Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unabletoallocatememoryfortheauthpending_file,touchrequestnotificationswillnotbeemitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_fileissettoanemptyvalue,touchrequestnotificationswillbedisabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Usingfile\'%s\'foremittingtouchrequestnotifications"" , cfg -> authpending_file ) ; authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ; if ( authpending_file_descriptor < 0 ) { DBG ( ""Unabletoemit\'authenticationstarted\'notificationbyopeningthefile\'%s\',(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unabletoemit\'authenticationstopped\'notificationbyclosingthefile\'%s\',(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authenticationreturned%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysokneeded(otherwisereturnwith%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.[%s]"" , pam_strerror ( pamh , retval ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } return retval ; }"," ; int openasuser = 0  should_free_authpending_file = 0 ; PAM_MODUTIL_DEF_PRIVS ( privs )  done ; } openasuser = geteuid ( ) == 0 ? 1 : 0 ;  DEFAULT_AUTHFILE ) ; if ( ! openasuser ) { DBG ( ""WARNING:notdroppingprivilegeswhenreading%s,please"" ""considersettingopenasuser=1inthemoduleconfiguration""  , buf )  buf ) ; } } DBG ( ""Usingauthenticationfile%s"" , buf ) ;  ) ; } if ( ! openasuser ) { openasuser  = geteuid (  -> openasuser ; }  openasuser ) { DBG ( ""Droppingprivileges"" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw  ) ) {  ( ""Unabletoswitchusertouid%i"" , pw ->  pw_uid ) ;  ( ""Switchedtouid%i"" , pw ->  pw_uid ) ;  { if ( pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( ""couldnotrestoreprivileges""  ) ; retval  } DBG ( ""Restoredprivileges""  ) ; }"
570,"CWE-863 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ;  if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;  if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }", goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ;  ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )
571,"CWE-285 static int __reiserfs_set_acl ( struct reiserfs_transaction_handle * th , struct inode * inode , int type , struct posix_acl * acl ) { char * name ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) {  error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;  if ( error < 0 ) return error ; else { if ( error == 0 ) acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = reiserfs_posix_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = reiserfs_xattr_set_handle ( th , inode , name , value , size , 0 ) ; if ( error == - ENODATA ) { error = 0 ; if ( type == ACL_TYPE_ACCESS ) { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; } } kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }"," { error = posix_acl_update_mode ( inode  , & inode  inode -> i_mode , & acl ) ; if ( error ) return error ;  } break ;"
572,"CWE-362 void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ;  struct net * net = sock_net ( asoc -> base . sk ) ;   bh_lock_sock ( asoc -> base . sk ) ;   if ( sock_owned_by_user ( asoc -> base . sk ) ) {  pr_debug ( ""%s:sockisbusy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error )  asoc -> base . sk -> sk_err = - error ;  out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;  sctp_transport_put ( transport ) ; }", asoc ; struct sock * sk = asoc -> base . sk ; struct  = sock_net (  sk ) ;  ; bh_lock_sock (  sk ) ;  ( sock_owned_by_user (  sk ) )  ( error )  sk -> sk_err  : bh_unlock_sock (  sk ) ;
573,"CWE-119 void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ;  data -> l_head = NULL ;  data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }"," xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) )  ; parser ."
574,"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } }  ( void ) ReadBlobString ( image , text ) ;  if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }"
575,"CWE-399 static int inotify_release ( struct inode * ignored , struct file * file ) { struct fsnotify_group * group = file -> private_data ;  struct user_struct * user = group -> inotify_data . user ;  pr_debug ( ""%s:group=%p\\n"" , __func__ , group ) ; fsnotify_clear_marks_by_group ( group ) ; fsnotify_put_group ( group ) ;  atomic_dec ( & user -> inotify_devs ) ;  return 0 ; }"," -> private_data ;  pr_debug ( ""%s:group=%p\\n""  group ) ;  return 0 ;"
576,"CWE-772 static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; MagickPixelPacket transpix ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char  * lastrow ,  * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , ""FileFormatVersionMismatch"" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; GetMagickPixelPacket ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { IndexPacket index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  lastrow = ( unsigned char * ) NULL ;  if ( compressionType == PALM_COMPRESSION_SCANLINE ) {  lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row ,   2 * image -> columns ) , sizeof ( * lastrow ) ) ;  if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else  one_row [ i + bit ] = lastrow [ i + bit ] ;  } }  ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ;  } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;  ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( q , ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) ; SetPixelGreen ( q , ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) ; SetPixelBlue ( q , ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;  ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } index = ( IndexPacket ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { IndexPacket index = ConstrainColormapIndex ( image , ( mask - transparentIndex ) ) ; if ( bits_per_pixel != 16 ) SetMagickPixelPacket ( image , image -> colormap + ( ssize_t ) index , ( const IndexPacket * ) NULL , & transpix ) ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentOpacity , MagickFalse ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;  if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," unsigned char * last_row  , * one_row  ""MemoryAllocationFailed"" ) ; last_row  = ( unsigned  PALM_COMPRESSION_SCANLINE ) { last_row  = ( unsigned  sizeof ( * last_row ) ) ; if ( last_row  == ( unsigned  bit ] = last_row  [ i +  ) CopyMagickMemory ( last_row  , one_row ,  == PALM_COMPRESSION_SCANLINE ) last_row  = ( unsigned  ) RelinquishMagickMemory ( last_row  ) ; ThrowReaderException  == PALM_COMPRESSION_SCANLINE ) last_row  = ( unsigned  ) RelinquishMagickMemory ( last_row  ) ; ThrowReaderException  == PALM_COMPRESSION_SCANLINE ) last_row  = ( unsigned  ) RelinquishMagickMemory ( last_row  ) ; if"
577,"CWE-000 int main ( argc , argv ) int argc ; char * argv [ ] ; { krb5_data pname_data , tkt_data ; int sock = 0 ; socklen_t l ; int retval ; struct sockaddr_in l_inaddr , f_inaddr ; krb5_creds creds , * new_creds ; krb5_ccache cc ; krb5_data msgtext , msg ; krb5_context context ; krb5_auth_context auth_context = NULL ; # ifndef DEBUG freopen ( ""/tmp/uu-server.log"" , ""w"" , stderr ) ; # endif retval = krb5_init_context ( & context ) ; if ( retval ) { com_err ( argv [ 0 ] , retval , ""whileinitializingkrb5"" ) ; exit ( 1 ) ; } # ifdef DEBUG { int one = 1 ; int acc ; struct servent * sp ; socklen_t namelen = sizeof ( f_inaddr ) ; if ( ( sock = socket ( PF_INET , SOCK_STREAM , 0 ) ) < 0 ) { com_err ( ""uu-server"" , errno , ""creatingsocket"" ) ; exit ( 3 ) ; } l_inaddr . sin_family = AF_INET ; l_inaddr . sin_addr . s_addr = 0 ; if ( argc == 2 ) { l_inaddr . sin_port = htons ( atoi ( argv [ 1 ] ) ) ; } else { if ( ! ( sp = getservbyname ( ""uu-sample"" , ""tcp"" ) ) ) { com_err ( ""uu-server"" , 0 , ""can\'tfinduu-sample/tcpservice"" ) ; exit ( 3 ) ; } l_inaddr . sin_port = sp -> s_port ; } ( void ) setsockopt ( sock , SOL_SOCKET , SO_REUSEADDR , ( char * ) & one , sizeof ( one ) ) ; if ( bind ( sock , ( struct sockaddr * ) & l_inaddr , sizeof ( l_inaddr ) ) ) { com_err ( ""uu-server"" , errno , ""bindingsocket"" ) ; exit ( 3 ) ; } if ( listen ( sock , 1 ) == - 1 ) { com_err ( ""uu-server"" , errno , ""listening"" ) ; exit ( 3 ) ; } printf ( ""Serverstarted\\n"" ) ; fflush ( stdout ) ; if ( ( acc = accept ( sock , ( struct sockaddr * ) & f_inaddr , & namelen ) ) == - 1 ) { com_err ( ""uu-server"" , errno , ""accepting"" ) ; exit ( 3 ) ; } dup2 ( acc , 0 ) ; close ( sock ) ; sock = 0 ; } # endif retval = krb5_read_message ( context , ( krb5_pointer ) & sock , & pname_data ) ;  if ( retval ) {  com_err ( ""uu-server"" , retval , ""readingpname"" ) ; return 2 ; } retval = krb5_read_message ( context , ( krb5_pointer ) & sock , & tkt_data ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""readingticketdata"" ) ; return 2 ; } retval = krb5_cc_default ( context , & cc ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""gettingcredentialscache"" ) ; return 4 ; } memset ( & creds , 0 , sizeof ( creds ) ) ; retval = krb5_cc_get_principal ( context , cc , & creds . client ) ; if ( retval ) { com_err ( ""uu-client"" , retval , ""gettingprincipalname"" ) ; return 6 ; } printf ( ""uu-server:clientprincipalis\\""%s\\"".\\n"" , pname_data . data ) ; retval = krb5_parse_name ( context , pname_data . data , & creds . server ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""parsingclientname"" ) ; return 3 ; } creds . second_ticket = tkt_data ; printf ( ""uu-server:clientticketis%dbytes.\\n"" , creds . second_ticket . length ) ; retval = krb5_get_credentials ( context , KRB5_GC_USER_USER , cc , & creds , & new_creds ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""gettinguser-userticket"" ) ; return 5 ; } # ifndef DEBUG l = sizeof ( f_inaddr ) ; if ( getpeername ( 0 , ( struct sockaddr * ) & f_inaddr , & l ) == - 1 ) { com_err ( ""uu-server"" , errno , ""gettingclientaddress"" ) ; return 6 ; } # endif l = sizeof ( l_inaddr ) ; if ( getsockname ( 0 , ( struct sockaddr * ) & l_inaddr , & l ) == - 1 ) { com_err ( ""uu-server"" , errno , ""gettinglocaladdress"" ) ; return 6 ; } retval = krb5_auth_con_init ( context , & auth_context ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""makingauth_context"" ) ; return 8 ; } retval = krb5_auth_con_setflags ( context , auth_context , KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""initializingtheauth_contextflags"" ) ; return 8 ; } retval = krb5_auth_con_genaddrs ( context , auth_context , sock , KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR | KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""generatingaddrsforauth_context"" ) ; return 9 ; } # if 1 retval = krb5_mk_req_extended ( context , & auth_context , AP_OPTS_USE_SESSION_KEY , NULL , new_creds , & msg ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""makingAP_REQ"" ) ; return 8 ; } retval = krb5_write_message ( context , ( krb5_pointer ) & sock , & msg ) ; # else retval = krb5_sendauth ( context , & auth_context , ( krb5_pointer ) & sock , ""???"" , 0 , 0 , AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY , NULL , & creds , cc , NULL , NULL , NULL ) ; # endif if ( retval ) goto cl_short_wrt ; free ( msg . data ) ; msgtext . length = 32 ; msgtext . data = ""Hello,otherendofconnection."" ; retval = krb5_mk_safe ( context , auth_context , & msgtext , & msg , NULL ) ; if ( retval ) { com_err ( ""uu-server"" , retval , ""encodingmessagetoclient"" ) ; return 6 ; } retval = krb5_write_message ( context , ( krb5_pointer ) & sock , & msg ) ; if ( retval ) { cl_short_wrt : com_err ( ""uu-server"" , retval , ""writingmessagetoclient"" ) ; return 7 ; } krb5_free_data_contents ( context , & msg ) ; krb5_free_data_contents ( context , & pname_data ) ; krb5_free_cred_contents ( context , & creds ) ; krb5_free_creds ( context , new_creds ) ; krb5_cc_close ( context , cc ) ; krb5_auth_con_free ( context , auth_context ) ; krb5_free_context ( context ) ; return 0 ; }", if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0'
578,"CWE-119  static void mark_object ( struct object * obj , struct strbuf * path ,  const char * name , void * data ) { update_progress ( data ) ; }"," * obj ,  const char *"
579,"CWE-20  void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr )  {  vcpu -> arch . apic -> vapic_addr = vapic_addr ;  if ( vapic_addr ) __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;  else  __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;  } ","    int  kvm_lapic_set_vapic_addr ( struct  vapic_addr ) { if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , &  . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ;  __set_bit ( KVM_APIC_CHECK_VAPIC  apic_attention ) ; } else {  __clear_bit ( KVM_APIC_CHECK_VAPIC  ) ; } vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ; }"
580,"CWE-119 static vpx_codec_err_t ctrl_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {  int * const update_info = va_arg ( args , int * ) ;  if ( update_info ) {   if ( ctx -> pbi )   * update_info = ctx -> pbi -> refresh_frame_flags ;  else return VPX_CODEC_ERROR ; return VPX_CODEC_OK ; } else {  return VPX_CODEC_INVALID_PARAM ;  }  } "," * ctx ,  va_list args )  ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Notsupportedinframeparalleldecode"" ) ; return VPX_CODEC_INCAPABLE ; } if (  ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;  * update_info =  * update_info = frame_worker_data  -> pbi ->  pbi -> refresh_frame_flags  ; return VPX_CODEC_OK  else { return VPX_CODEC_ERROR  ; } }  ; } } return VPX_CODEC_INVALID_PARAM ; }"
581,"CWE-269 void virtio_config_writel ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val = data ;  if ( addr > ( vdev -> config_len - sizeof ( val ) ) )  return ; stl_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }", if ( addr +  sizeof ( val  ( val ) > vdev -> config_len ) { return ; }  stl_p ( vdev
582,"CWE-190 void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ;  * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ;   * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ;   * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ;   * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ;  * p_max_prec = 0 ; * p_max_res = 0 ; * p_dx_min = 0x7fffffff ; * p_dy_min = 0x7fffffff ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { OPJ_UINT32 l_level_no ; OPJ_INT32 l_rx0 , l_ry0 , l_rx1 , l_ry1 ; OPJ_INT32 l_px0 , l_py0 , l_px1 , py1 ; OPJ_UINT32 l_product ; OPJ_INT32 l_tcx0 , l_tcy0 , l_tcx1 , l_tcy1 ; OPJ_UINT32 l_pdx , l_pdy , l_pw , l_ph ; lResolutionPtr = p_resolutions [ compno ] ; l_tcx0 = opj_int_ceildiv ( * p_tx0 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy0 = opj_int_ceildiv ( * p_ty0 , ( OPJ_INT32 ) l_img_comp -> dy ) ; l_tcx1 = opj_int_ceildiv ( * p_tx1 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy1 = opj_int_ceildiv ( * p_ty1 , ( OPJ_INT32 ) l_img_comp -> dy ) ; if ( l_tccp -> numresolutions > * p_max_res ) { * p_max_res = l_tccp -> numresolutions ; } l_level_no = l_tccp -> numresolutions - 1 ; for ( resno = 0 ; resno < l_tccp -> numresolutions ; ++ resno ) { OPJ_UINT32 l_dx , l_dy ; l_pdx = l_tccp -> prcw [ resno ] ; l_pdy = l_tccp -> prch [ resno ] ; * lResolutionPtr ++ = l_pdx ; * lResolutionPtr ++ = l_pdy ; l_dx = l_img_comp -> dx * ( 1u << ( l_pdx + l_level_no ) ) ; l_dy = l_img_comp -> dy * ( 1u << ( l_pdy + l_level_no ) ) ; * p_dx_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dx_min , ( OPJ_INT32 ) l_dx ) ; * p_dy_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dy_min , ( OPJ_INT32 ) l_dy ) ; l_rx0 = opj_int_ceildivpow2 ( l_tcx0 , ( OPJ_INT32 ) l_level_no ) ; l_ry0 = opj_int_ceildivpow2 ( l_tcy0 , ( OPJ_INT32 ) l_level_no ) ; l_rx1 = opj_int_ceildivpow2 ( l_tcx1 , ( OPJ_INT32 ) l_level_no ) ; l_ry1 = opj_int_ceildivpow2 ( l_tcy1 , ( OPJ_INT32 ) l_level_no ) ; l_px0 = opj_int_floordivpow2 ( l_rx0 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; l_py0 = opj_int_floordivpow2 ( l_ry0 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_px1 = opj_int_ceildivpow2 ( l_rx1 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; py1 = opj_int_ceildivpow2 ( l_ry1 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_pw = ( l_rx0 == l_rx1 ) ? 0 : ( OPJ_UINT32 ) ( ( l_px1 - l_px0 ) >> l_pdx ) ; l_ph = ( l_ry0 == l_ry1 ) ? 0 : ( OPJ_UINT32 ) ( ( py1 - l_py0 ) >> l_pdy ) ; * lResolutionPtr ++ = l_pw ; * lResolutionPtr ++ = l_ph ; l_product = l_pw * l_ph ; if ( l_product > * p_max_prec ) { * p_max_prec = l_product ; } -- l_level_no ; } ++ l_tccp ; ++ l_img_comp ; } }"," * p_tx0 = ( OPJ_INT32 ) opj_uint_max  ( p_cp ->  p_cp -> tdx ,  p_image -> x0  * p_tx1 = ( OPJ_INT32 ) opj_uint_min  ( p_cp ->  p_cp -> tdx ,  p_image -> x1  * p_ty0 = ( OPJ_INT32 ) opj_uint_max  ( p_cp ->  p_cp -> tdy ,  p_image -> y0  * p_ty1 = ( OPJ_INT32 ) opj_uint_min  ( p_cp ->  p_cp -> tdy ,  p_image -> y1"
583,CWE-254 void arch_pick_mmap_layout ( struct mm_struct * mm ) { unsigned long random_factor = 0UL ; if ( current -> flags & PF_RANDOMIZE ) random_factor = arch_mmap_rnd ( ) ;  mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ;  if ( mmap_is_legacy ( ) ) { mm -> mmap_base = mm -> mmap_legacy_base ; mm -> get_unmapped_area = arch_get_unmapped_area ; } else { mm -> mmap_base = mmap_base ( random_factor ) ; mm -> get_unmapped_area = arch_get_unmapped_area_topdown ; } }, -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor  ; if (
584,"CWE-119 static INLINE void fdct32x32 ( int rd_transform ,  const int16_t * src , int16_t * dst , int src_stride ) {  if ( rd_transform )  vp9_fdct32x32_rd ( src , dst , src_stride ) ;  else  vp9_fdct32x32 ( src , dst , src_stride ) ;  }"," * src , tran_low_t  * dst ,  ( rd_transform ) vpx_fdct32x32_rd  ( src ,  ) ; else vpx_fdct32x32  ( src ,"
585,"CWE-119 void process_pfa ( FILE * ifp , const char * ifp_filename , struct font_reader * fr ) { char buffer [ LINESIZE ] ; int c = 0 ; int blocktyp = PFA_ASCII ; char saved_orphan = 0 ; ( void ) ifp_filename ; while ( c != EOF ) { char * line = buffer , * last = buffer ; int crlf = 0 ; c = getc ( ifp ) ; while ( c != EOF && c != '\\r' && c != '\\n' && last < buffer + LINESIZE - 1 ) { * last ++ = c ; c = getc ( ifp ) ; } if ( last == buffer + LINESIZE - 1 ) ungetc ( c , ifp ) ; else if ( c == '\\r' && blocktyp != PFA_BINARY ) { c = getc ( ifp ) ; if ( c != '\\n' ) ungetc ( c , ifp ) , crlf = 1 ; else crlf = 2 ; * last ++ = '\\n' ; } else if ( c != EOF ) * last ++ = c ; * last = 0 ; if ( blocktyp == PFA_ASCII ) {  if ( strncmp ( line , ""currentfileeexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {  char saved_p ;  for ( line += 18 ; isspace ( * line ) ; line ++ )  ; saved_p = * line ; * line = 0 ; fr -> output_ascii ( buffer , line - buffer ) ; * line = saved_p ; blocktyp = PFA_EEXEC_TEST ; if ( ! * line ) continue ; } else { fr -> output_ascii ( line , last - line ) ; continue ; } } if ( blocktyp == PFA_EEXEC_TEST ) {  for ( ; line < last && isspace ( * line ) ; line ++ )  ; if ( line == last ) continue ;  else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] )   && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) )  blocktyp = PFA_HEX ; else blocktyp = PFA_BINARY ; memmove ( buffer , line , last - line + 1 ) ; last = buffer + ( last - line ) ; line = buffer ; if ( blocktyp == PFA_BINARY && crlf ) { last [ - 1 ] = '\\r' ; if ( crlf == 2 ) * last ++ = '\\n' ; } } if ( all_zeroes ( line ) ) { fr -> output_ascii ( line , last - line ) ; blocktyp = PFA_ASCII ; } else if ( blocktyp == PFA_HEX ) { int len = translate_hex_string ( line , & saved_orphan ) ; if ( len ) fr -> output_binary ( ( unsigned char * ) line , len ) ; } else fr -> output_binary ( ( unsigned char * ) line , last - line ) ; } fr -> output_end ( ) ; }", && isspace ( ( unsigned char )  ; isspace ( ( unsigned char )  && isspace ( ( unsigned char )  && isxdigit ( ( unsigned char )  && isxdigit ( ( unsigned char )  && isxdigit ( ( unsigned char )  && isxdigit ( ( unsigned char )
586,"CWE-20 struct sk_buff * sock_alloc_send_pskb ( struct sock * sk , unsigned long header_len , unsigned long data_len , int noblock , int * errcode ) { struct sk_buff * skb ; gfp_t gfp_mask ; long timeo ; int err ;  gfp_mask = sk -> sk_allocation ;  if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ; timeo = sock_sndtimeo ( sk , noblock ) ; while ( 1 ) { err = sock_error ( sk ) ; if ( err != 0 ) goto failure ; err = - EPIPE ; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto failure ; if ( atomic_read ( & sk -> sk_wmem_alloc ) < sk -> sk_sndbuf ) { skb = alloc_skb ( header_len , gfp_mask ) ; if ( skb ) {  int npages ;  int i ; if ( ! data_len )  break ;  npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; skb -> truesize += data_len ; skb_shinfo ( skb ) -> nr_frags = npages ; for ( i = 0 ; i < npages ; i ++ ) { struct page * page ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( ! page ) { err = - ENOBUFS ; skb_shinfo ( skb ) -> nr_frags = i ; kfree_skb ( skb ) ; goto failure ; } __skb_fill_page_desc ( skb , i , page , 0 , ( data_len >= PAGE_SIZE ? PAGE_SIZE : data_len ) ) ; data_len -= PAGE_SIZE ; } break ; } err = - ENOBUFS ; goto failure ; } set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; set_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ; err = - EAGAIN ; if ( ! timeo ) goto failure ; if ( signal_pending ( current ) ) goto interrupted ; timeo = sock_wait_for_wmem ( sk , timeo ) ; } skb_set_owner_w ( skb , sk ) ; return skb ; interrupted : err = sock_intr_errno ( timeo ) ; failure : * errcode = err ; return NULL ; }", int err ; int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ;  ) { int  i ; if  data_len ) break  ; skb ->
587,"CWE-125 void arp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct arp_pkthdr * ap ; u_short pro , hrd , op , linkaddr ; ap = ( const struct arp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = HRD ( ap ) ; pro = PRO ( ap ) ; op = OP ( ap ) ; switch ( hrd ) { case ARPHRD_ATM2225 : atmarp_print ( ndo , bp , length , caplen ) ; return ; case ARPHRD_FRELAY : linkaddr = LINKADDR_FRELAY ; break ; default : linkaddr = LINKADDR_ETHER ; break ; }  if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) {  ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""ARP,"" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""%s(len%u),%s(len%u)"" , tok2str ( arphrd_values , ""UnknownHardware(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , ""%s%s"" , ndo -> ndo_vflag ? "","" : """" , tok2str ( arpop_values , ""Unknown(%u)"" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;  if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;  ND_PRINT ( ( ndo , ""tell%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;  break ; case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%sis-at%s"" ,  ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is%stell%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_REVREPLY :  ND_PRINT ( ( ndo , ""%sat%s"" ,   linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is%stell%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ; break ; case ARPOP_INVREPLY :  ND_PRINT ( ( ndo , ""%sat%s"" ,   linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , "",length%u"" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }"," ND_TTEST2 ( * TPA  ( ap )  ( ndo , ""who-has"" ) ) ; tpaddr_print_ip ( ndo , ap , pro  ) ; if  ( ndo , ""tell"" ) ) ; spaddr_print_ip ( ndo , ap , pro  ) ; break  case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""is-at%s""  , linkaddr_string (  ( ndo , ""%sat""  , linkaddr_string (  ap ) ) ) ) ; tpaddr_print_ip ( ndo , ap , pro  ) ; break  ( ndo , ""%sat""  , linkaddr_string (  ap ) ) ) ) ; spaddr_print_ip ( ndo , ap , pro  ) ; break"
588,"CWE-119 void vp9_update_layer_context_change_config ( VP9_COMP * const cpi , const int target_bandwidth ) { SVC * const svc = & cpi -> svc ;  const VP9_CONFIG * const oxcf = & cpi -> oxcf ;  const RATE_CONTROL * const rc = & cpi -> rc ;  int layer ;  int layer_end ; float bitrate_alloc = 1.0 ;  if ( svc -> number_temporal_layers > 1 ) {  layer_end = svc -> number_temporal_layers ; } else { layer_end = svc -> number_spatial_layers ; } for ( layer = 0 ; layer < layer_end ; ++ layer ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ;  RATE_CONTROL * const lrc = & lc -> rc ;   if ( svc -> number_temporal_layers > 1 ) {  lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ; } else { lc -> target_bandwidth = oxcf -> ss_target_bitrate [ layer ] * 1000 ; } bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lc -> starting_buffer_level = ( int64_t ) ( oxcf -> starting_buffer_level * bitrate_alloc ) ; lc -> optimal_buffer_level = ( int64_t ) ( oxcf -> optimal_buffer_level * bitrate_alloc ) ; lc -> maximum_buffer_size = ( int64_t ) ( oxcf -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lc -> maximum_buffer_size ) ; if ( svc -> number_temporal_layers > 1 ) {  lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ;  } else {  lc -> framerate = oxcf -> framerate ;  }  lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;  lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; }  } "," svc ; const VP9EncoderConfig  * const oxcf  rc ; int sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { int layer_end  ; if (  number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR  lc -> rc ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size )  number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR  ) { lc  -> framerate = cpi  -> framerate /  -> framerate = cpi  -> framerate ;  } lrc -> avg_frame_bandwidth  = ( int  ; } } }"
589,"CWE-119 int id3_skip ( SF_PRIVATE * psf ) { unsigned char buf [ 10 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; psf_binheader_readf ( psf , ""pb"" , 0 , buf , 10 ) ; if ( buf [ 0 ] == 'I' && buf [ 1 ] == 'D' && buf [ 2 ] == '3' ) { int offset = buf [ 6 ] & 0x7f ; offset = ( offset << 7 ) | ( buf [ 7 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 8 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 9 ] & 0x7f ) ; psf_log_printf ( psf , ""ID3length:%d\\n--------------------\\n"" , offset ) ; if ( offset < 0 ) return 0 ; psf -> fileoffset += offset + 10 ;  psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;  return 1 ; } ;  return 0 ;  }", + 10 ; if ( psf -> fileoffset < psf -> filelength ) {  ; } ; } ;
590,"CWE-190 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifierinternalerror:knownbutbadsbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifierinternalerror:knownbutbadubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d32-bitpointerarithmeticprohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dpointerarithmeticonPTR_TO_MAP_VALUE_OR_NULLprohibited,null-checkitfirst\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dpointerarithmeticonCONST_PTR_TO_MAPprohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dpointerarithmeticonPTR_TO_PACKET_ENDprohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ;  dst_reg -> id = ptr_reg -> id ;  switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dtriedtosubtractpointerfromscalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dsubtractionfromstackpointerprohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dbitwiseoperator%sonpointerprohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%dpointerarithmeticwith%soperatorprohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; }  __update_reg_bounds ( dst_reg ) ;  __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }"," ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL  EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;"
591,"CWE-125 static expr_ty ast_for_trailer ( struct compiling * c , const node * n , expr_ty left_expr ) { REQ ( n , trailer ) ; if ( TYPE ( CHILD ( n , 0 ) ) == LPAR ) { if ( NCH ( n ) == 2 ) return Call ( left_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else  return ast_for_call ( c , CHILD ( n , 1 ) , left_expr ) ;  } else if ( TYPE ( CHILD ( n , 0 ) ) == DOT ) { PyObject * attr_id = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! attr_id ) return NULL ; return Attribute ( left_expr , attr_id , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else { REQ ( CHILD ( n , 0 ) , LSQB ) ; REQ ( CHILD ( n , 2 ) , RSQB ) ; n = CHILD ( n , 1 ) ; if ( NCH ( n ) == 1 ) { slice_ty slc = ast_for_slice ( c , CHILD ( n , 0 ) ) ; if ( ! slc ) return NULL ; return Subscript ( left_expr , slc , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else { int j ; slice_ty slc ; expr_ty e ; int simple = 1 ; asdl_seq * slices , * elts ; slices = _Ta3_asdl_seq_new ( ( NCH ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! slices ) return NULL ; for ( j = 0 ; j < NCH ( n ) ; j += 2 ) { slc = ast_for_slice ( c , CHILD ( n , j ) ) ; if ( ! slc ) return NULL ; if ( slc -> kind != Index_kind ) simple = 0 ; asdl_seq_SET ( slices , j / 2 , slc ) ; } if ( ! simple ) { return Subscript ( left_expr , ExtSlice ( slices , c -> c_arena ) , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } elts = _Ta3_asdl_seq_new ( asdl_seq_LEN ( slices ) , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( j = 0 ; j < asdl_seq_LEN ( slices ) ; ++ j ) { slc = ( slice_ty ) asdl_seq_GET ( slices , j ) ; assert ( slc -> kind == Index_kind && slc -> v . Index . value ) ; asdl_seq_SET ( elts , j , slc -> v . Index . value ) ; } e = Tuple ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! e ) return NULL ; return Subscript ( left_expr , Index ( e , c -> c_arena ) , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } }"," ) , left_expr , true"
592,"CWE-000 SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ;  if ( ep_loop_check ( ep , tfile ) != 0 )   goto error_tgt_fput ;  } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }", != 0 ) { clear_tfile_check_list ( ) ;  goto error_tgt_fput ; }
593,"CWE-264 static void vmx_set_msr_bitmap ( struct kvm_vcpu * vcpu ) { unsigned long * msr_bitmap ; if ( is_guest_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_nested ;  else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) {  if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ; else msr_bitmap = vmx_msr_bitmap_legacy_x2apic ; } else { if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode ; else msr_bitmap = vmx_msr_bitmap_legacy ; } vmcs_write64 ( MSR_BITMAP , __pa ( msr_bitmap ) ) ; }", else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE )  ) { if
594,"CWE-200 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state = & env -> cur_state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs = state -> regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; init_reg_state ( regs ) ; insn_idx = 0 ; env -> varlen_map_value_access = false ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( ""invalidinsnidx%dinsn_cnt%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( ""BPFprogramistoolarge.Processed%dinsn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( log_level ) { if ( do_print_state ) verbose ( ""\\nfrom%dto%d:safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( ""%d:safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( log_level && do_print_state ) { verbose ( ""\\nfrom%dto%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( & env -> cur_state ) ; do_print_state = false ; } if ( log_level ) { verbose ( ""%d:"" , insn_idx ) ;  print_bpf_insn ( insn ) ;  } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; if ( BPF_SIZE ( insn -> code ) != BPF_W && BPF_SIZE ( insn -> code ) != BPF_DW ) { insn_idx ++ ; continue ; } prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( ""sameinsncannotbeusedwithdifferentpointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( ""sameinsncannotbeusedwithdifferentpointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( ""BPF_STusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_CALLusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_JAusesreservedfields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_EXITusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( ""R0leaksaddrasreturnvalue\\n"" ) ; return - EACCES ; } process_bpf_exit : insn_idx = pop_stack ( env , & prev_insn_idx ) ; if ( insn_idx < 0 ) { break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; } else { verbose ( ""invalidBPF_LDmode\\n"" ) ; return - EINVAL ; } reset_reg_range_values ( regs , insn -> dst_reg ) ; } else { verbose ( ""unknowninsnclass%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( ""processed%dinsns\\n"" , insn_processed ) ; return 0 ; }"," ; print_bpf_insn ( env ,"
595,"CWE-399 void mono_runtime_shutdown ( void ) { mono_domain_foreach ( fire_process_exit_event , NULL ) ;  } ", NULL ) ; mono_reflection_shutdown ( ) ;
596,"CWE-125 static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) {  stlv_type = * ( tptr ++ ) ;  stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t%ssubTLV#%u,length:%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ;  len = len - 2 ;  switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\tCISTRoot-ID:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",PathCost:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",Prio:%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\tRES:%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",V:%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",SPSource-ID:%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",NoofTrees:%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;  while ( tmp )  {  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\tU:%d,M:%d,A:%d,RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",ECT:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",BVID:%d,SPVID:%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ;  len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;  tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;  ND_PRINT ( ( ndo , ""\\n\\tBMAC:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",RES:%d,VID:%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tT:%d,R:%d,RES:%d,ISID:%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; }  }  return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }"," 2 ) { ND_TCHECK2 ( * tptr , 2 ) ;  len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len )  case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc  ; ND_PRINT (  - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;  tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc  ; ND_PRINT (  len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len  case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc  ; ND_PRINT (  break ; } tptr += stlv_len ; len -= stlv_len ;"
597,"CWE-190 static int _gd2GetHeader ( gdIOCtxPtr in , int * sx , int * sy , int * cs , int * vers , int * fmt , int * ncx , int * ncy , t_chunk_info * * chunkIdx ) { int i ; int ch ; char id [ 5 ] ; t_chunk_info * cidx ; int sidx ; int nc ; GD2_DBG ( php_gd_error ( ""Readinggd2headerinfo"" ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { ch = gdGetC ( in ) ; if ( ch == EOF ) { goto fail1 ; } id [ i ] = ch ; } id [ 4 ] = 0 ; GD2_DBG ( php_gd_error ( ""Gotfilecode:%s"" , id ) ) ; if ( strcmp ( id , GD2_ID ) != 0 ) { GD2_DBG ( php_gd_error ( ""Notavalidgd2file"" ) ) ; goto fail1 ; } if ( gdGetWord ( vers , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Version:%d"" , * vers ) ) ; if ( ( * vers != 1 ) && ( * vers != 2 ) ) { GD2_DBG ( php_gd_error ( ""Badversion:%d"" , * vers ) ) ; goto fail1 ; } if ( ! gdGetWord ( sx , in ) ) { GD2_DBG ( php_gd_error ( ""Couldnotgetx-size"" ) ) ; goto fail1 ; } if ( ! gdGetWord ( sy , in ) ) { GD2_DBG ( php_gd_error ( ""Couldnotgety-size"" ) ) ; goto fail1 ; } GD2_DBG ( php_gd_error ( ""Imageis%dx%d"" , * sx , * sy ) ) ; if ( gdGetWord ( cs , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""ChunkSize:%d"" , * cs ) ) ; if ( ( * cs < GD2_CHUNKSIZE_MIN ) || ( * cs > GD2_CHUNKSIZE_MAX ) ) { GD2_DBG ( php_gd_error ( ""Badchunksize:%d"" , * cs ) ) ; goto fail1 ; } if ( gdGetWord ( fmt , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Format:%d"" , * fmt ) ) ; if ( ( * fmt != GD2_FMT_RAW ) && ( * fmt != GD2_FMT_COMPRESSED ) && ( * fmt != GD2_FMT_TRUECOLOR_RAW ) && ( * fmt != GD2_FMT_TRUECOLOR_COMPRESSED ) ) { GD2_DBG ( php_gd_error ( ""Baddataformat:%d"" , * fmt ) ) ; goto fail1 ; } if ( gdGetWord ( ncx , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%dChunksWide"" , * ncx ) ) ; if ( gdGetWord ( ncy , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%dChunksvertically"" , * ncy ) ) ; if ( gd2_compressed ( * fmt ) ) { nc = ( * ncx ) * ( * ncy ) ; GD2_DBG ( php_gd_error ( ""Reading%dchunkindexentries"" , nc ) ) ;  sidx = sizeof ( t_chunk_info ) * nc ;  if ( sidx <= 0 ) { goto fail1 ; }  cidx = gdCalloc ( sidx , 1 ) ;  for ( i = 0 ; i < nc ; i ++ ) { if ( gdGetInt ( & cidx [ i ] . offset , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( gdGetInt ( & cidx [ i ] . size , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( cidx [ i ] . offset < 0 || cidx [ i ] . size < 0 ) { gdFree ( cidx ) ; goto fail1 ; } } * chunkIdx = cidx ; } GD2_DBG ( php_gd_error ( ""gd2headercomplete"" ) ) ; return 1 ; fail1 : return 0 ; }"," ) ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; }  1 ) ; if ( cidx == NULL ) { goto fail1 ; }"
598,"CWE-119 static int PredictorDecodeTile ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decodetile != NULL ) ; if ( ( * sp -> decodetile ) ( tif , op0 , occ0 , s ) ) { tmsize_t rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ;  assert ( ( occ0 % rowsize ) == 0 ) ;  assert ( sp -> decodepfunc != NULL ) ; while ( occ0 > 0 ) {  ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ;  occ0 -= rowsize ; op0 += rowsize ; } return 1 ; } else return 0 ; }"," 0 ) ; if  ( ( occ0  % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize!=0"" ) ; return 0 ; }  assert ( sp  0 ) { if ( !  , rowsize ) ) return 0"
599,"CWE-399 static int ovl_copy_up_locked ( struct dentry * workdir , struct dentry * upperdir , struct dentry * dentry , struct path * lowerpath , struct kstat * stat , struct iattr * attr , const char * link ) { struct inode * wdir = workdir -> d_inode ; struct inode * udir = upperdir -> d_inode ; struct dentry * newdentry = NULL ; struct dentry * upper = NULL ; umode_t mode = stat -> mode ; int err ; newdentry = ovl_lookup_temp ( workdir , dentry ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out1 ; stat -> mode &= S_IFMT ; err = ovl_create_real ( wdir , newdentry , stat , link , NULL , true ) ; stat -> mode = mode ; if ( err ) goto out2 ; if ( S_ISREG ( stat -> mode ) ) { struct path upperpath ; ovl_path_upper ( dentry , & upperpath ) ; BUG_ON ( upperpath . dentry != NULL ) ; upperpath . dentry = newdentry ; err = ovl_copy_up_data ( lowerpath , & upperpath , stat -> size ) ; if ( err ) goto out_cleanup ; } err = ovl_copy_xattr ( lowerpath -> dentry , newdentry ) ; if ( err ) goto out_cleanup ; mutex_lock ( & newdentry -> d_inode -> i_mutex ) ; err = ovl_set_attr ( newdentry , stat ) ; if ( ! err && attr ) err = notify_change ( newdentry , attr , NULL ) ; mutex_unlock ( & newdentry -> d_inode -> i_mutex ) ; if ( err ) goto out_cleanup ; err = ovl_do_rename ( wdir , newdentry , udir , upper , 0 ) ; if ( err ) goto out_cleanup ; ovl_dentry_update ( dentry , newdentry ) ; newdentry = NULL ; if ( ! S_ISDIR ( stat -> mode ) ) ovl_dentry_set_opaque ( dentry , true ) ; out2 : dput ( upper ) ; out1 : dput ( newdentry ) ; out : return err ; out_cleanup : ovl_cleanup ( wdir , newdentry ) ;  goto out ;  }", ) ; goto out2  ; } 
600,"CWE-125 bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } }  return ( xdr_opaque ( xdrs , * objp , size ) ) ;  case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }"," ; } } if ( !  xdr_opaque ( xdrs  size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE"
601,"CWE-835 static const u_char * ikev2_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { const struct ikev2_n * p ; struct ikev2_n n ; const u_char * cp ;  u_char showspi , showdata , showsomedata ;  const char * notify_name ; uint32_t type ; p = ( const struct ikev2_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_N ) , n . h . critical ) ; showspi = 1 ;  showdata = 0 ;  showsomedata = 0 ; notify_name = NULL ; ND_PRINT ( ( ndo , ""prot_id=%s"" , PROTOIDSTR ( n . prot_id ) ) ) ; type = ntohs ( n . type ) ; switch ( type ) { case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD : notify_name = ""unsupported_critical_payload"" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_IKE_SPI : notify_name = ""invalid_ike_spi"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_MAJOR_VERSION : notify_name = ""invalid_major_version"" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_SYNTAX : notify_name = ""invalid_syntax"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_MESSAGE_ID : notify_name = ""invalid_message_id"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_SPI : notify_name = ""invalid_spi"" ; showspi = 1 ; break ; case IV2_NOTIFY_NO_PROPOSAL_CHOSEN : notify_name = ""no_protocol_chosen"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_KE_PAYLOAD : notify_name = ""invalid_ke_payload"" ; showspi = 1 ; break ; case IV2_NOTIFY_AUTHENTICATION_FAILED : notify_name = ""authentication_failed"" ; showspi = 1 ; break ; case IV2_NOTIFY_SINGLE_PAIR_REQUIRED : notify_name = ""single_pair_required"" ; showspi = 1 ; break ; case IV2_NOTIFY_NO_ADDITIONAL_SAS : notify_name = ""no_additional_sas"" ; showspi = 0 ; break ; case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE : notify_name = ""internal_address_failure"" ; showspi = 0 ; break ; case IV2_NOTIFY_FAILED_CP_REQUIRED : notify_name = ""failed:cp_required"" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_SELECTORS : notify_name = ""invalid_selectors"" ; showspi = 0 ; break ; case IV2_NOTIFY_INITIAL_CONTACT : notify_name = ""initial_contact"" ; showspi = 0 ; break ; case IV2_NOTIFY_SET_WINDOW_SIZE : notify_name = ""set_window_size"" ; showspi = 0 ; break ; case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE : notify_name = ""additional_ts_possible"" ; showspi = 0 ; break ; case IV2_NOTIFY_IPCOMP_SUPPORTED : notify_name = ""ipcomp_supported"" ; showspi = 0 ; break ; case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP : notify_name = ""nat_detection_source_ip"" ; showspi = 1 ; break ; case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP : notify_name = ""nat_detection_destination_ip"" ; showspi = 1 ; break ; case IV2_NOTIFY_COOKIE : notify_name = ""cookie"" ; showspi = 1 ;  showsomedata = 1 ;  showdata = 0 ; break ; case IV2_NOTIFY_USE_TRANSPORT_MODE : notify_name = ""use_transport_mode"" ; showspi = 0 ; break ; case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED : notify_name = ""http_cert_lookup_supported"" ; showspi = 0 ; break ; case IV2_NOTIFY_REKEY_SA : notify_name = ""rekey_sa"" ; showspi = 1 ; break ; case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED : notify_name = ""tfc_padding_not_supported"" ; showspi = 0 ; break ; case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO : notify_name = ""non_first_fragment_also"" ; showspi = 0 ; break ; default : if ( type < 8192 ) { notify_name = ""error"" ; } else if ( type < 16384 ) { notify_name = ""private-error"" ; } else if ( type < 40960 ) { notify_name = ""status"" ; } else { notify_name = ""private-status"" ; } } if ( notify_name ) { ND_PRINT ( ( ndo , ""type=%u(%s)"" , type , notify_name ) ) ; } if ( showspi && n . spi_size ) { ND_PRINT ( ( ndo , ""spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ;  if ( 3 < ndo -> ndo_vflag ) {  showdata = 1 ; }  if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) {  ND_PRINT ( ( ndo , ""data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ;  } else if ( showsomedata && cp < ep ) {   if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;  } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }"," ; u_char showspi  , showsomedata ;  = 1 ;  showsomedata = 0  showsomedata = 1  ; break ;  ; if ( cp < ep ) { if (  ndo -> ndo_vflag  ndo -> ndo_vflag > 3  || ( showsomedata  30 ) )  { ND_PRINT (  if ( showsomedata  ) { if  goto trunc ; }"
602,"CWE-20 bool_t dm9000IrqHandler ( NetInterface * interface ) { bool_t flag ; uint8_t status ; uint8_t mask ; Dm9000Context * context ; flag = FALSE ; context = ( Dm9000Context * ) interface -> nicContext ;  status = dm9000ReadReg ( DM9000_REG_ISR ) ;  if ( ( status & ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_REG_IMR ) ;  dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ;  interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; }  if ( ( status & ISR_PT ) != 0 )  { if ( dm9000ReadReg ( DM9000_REG_NSR ) & ( NSR_TX2END | NSR_TX1END ) ) { if ( context -> queuedPackets > 0 ) { context -> queuedPackets -- ; } flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; }  dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ;  } if ( ( status & ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_REG_IMR ) ;  dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_PRI ) ;  interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } return flag ; }"," = dm9000ReadReg ( DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR  ) ; dm9000WriteReg  ; dm9000WriteReg ( DM9000_IMR  , mask &  mask & ~ DM9000_IMR_LNKCHGI  ) ; interface  ( status & DM9000_ISR_PT ) != 0 ) { if ( ( dm9000ReadReg ( DM9000_NSR ) & ( DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ) != 0  ) { if  } dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ; } if ( ( status & DM9000_ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR  ) ; dm9000WriteReg  ; dm9000WriteReg ( DM9000_IMR  , mask &  mask & ~ DM9000_IMR_PRI  ) ; interface"
603,"CWE-787 void avcodec_align_dimensions2 ( AVCodecContext * s , int * width , int * height , int linesize_align [ AV_NUM_DATA_POINTERS ] ) { int i ; int w_align = 1 ; int h_align = 1 ; AVPixFmtDescriptor const * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ; if ( desc ) { w_align = 1 << desc -> log2_chroma_w ; h_align = 1 << desc -> log2_chroma_h ; } switch ( s -> pix_fmt ) { case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUYV422 : case AV_PIX_FMT_YVYU422 : case AV_PIX_FMT_UYVY422 : case AV_PIX_FMT_YUV422P : case AV_PIX_FMT_YUV440P : case AV_PIX_FMT_YUV444P : case AV_PIX_FMT_GBRP : case AV_PIX_FMT_GBRAP : case AV_PIX_FMT_GRAY8 : case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : case AV_PIX_FMT_YUVJ420P : case AV_PIX_FMT_YUVJ422P : case AV_PIX_FMT_YUVJ440P : case AV_PIX_FMT_YUVJ444P : case AV_PIX_FMT_YUVA420P : case AV_PIX_FMT_YUVA422P : case AV_PIX_FMT_YUVA444P : case AV_PIX_FMT_YUV420P9LE : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10LE : case AV_PIX_FMT_YUV420P10BE : case AV_PIX_FMT_YUV420P12LE : case AV_PIX_FMT_YUV420P12BE : case AV_PIX_FMT_YUV420P14LE : case AV_PIX_FMT_YUV420P14BE : case AV_PIX_FMT_YUV420P16LE : case AV_PIX_FMT_YUV420P16BE : case AV_PIX_FMT_YUVA420P9LE : case AV_PIX_FMT_YUVA420P9BE : case AV_PIX_FMT_YUVA420P10LE : case AV_PIX_FMT_YUVA420P10BE : case AV_PIX_FMT_YUVA420P16LE : case AV_PIX_FMT_YUVA420P16BE : case AV_PIX_FMT_YUV422P9LE : case AV_PIX_FMT_YUV422P9BE : case AV_PIX_FMT_YUV422P10LE : case AV_PIX_FMT_YUV422P10BE : case AV_PIX_FMT_YUV422P12LE : case AV_PIX_FMT_YUV422P12BE : case AV_PIX_FMT_YUV422P14LE : case AV_PIX_FMT_YUV422P14BE : case AV_PIX_FMT_YUV422P16LE : case AV_PIX_FMT_YUV422P16BE : case AV_PIX_FMT_YUVA422P9LE : case AV_PIX_FMT_YUVA422P9BE : case AV_PIX_FMT_YUVA422P10LE : case AV_PIX_FMT_YUVA422P10BE : case AV_PIX_FMT_YUVA422P16LE : case AV_PIX_FMT_YUVA422P16BE : case AV_PIX_FMT_YUV440P10LE : case AV_PIX_FMT_YUV440P10BE : case AV_PIX_FMT_YUV440P12LE : case AV_PIX_FMT_YUV440P12BE : case AV_PIX_FMT_YUV444P9LE : case AV_PIX_FMT_YUV444P9BE : case AV_PIX_FMT_YUV444P10LE : case AV_PIX_FMT_YUV444P10BE : case AV_PIX_FMT_YUV444P12LE : case AV_PIX_FMT_YUV444P12BE : case AV_PIX_FMT_YUV444P14LE : case AV_PIX_FMT_YUV444P14BE : case AV_PIX_FMT_YUV444P16LE : case AV_PIX_FMT_YUV444P16BE : case AV_PIX_FMT_YUVA444P9LE : case AV_PIX_FMT_YUVA444P9BE : case AV_PIX_FMT_YUVA444P10LE : case AV_PIX_FMT_YUVA444P10BE : case AV_PIX_FMT_YUVA444P16LE : case AV_PIX_FMT_YUVA444P16BE : case AV_PIX_FMT_GBRP9LE : case AV_PIX_FMT_GBRP9BE : case AV_PIX_FMT_GBRP10LE : case AV_PIX_FMT_GBRP10BE : case AV_PIX_FMT_GBRP12LE : case AV_PIX_FMT_GBRP12BE : case AV_PIX_FMT_GBRP14LE : case AV_PIX_FMT_GBRP14BE : case AV_PIX_FMT_GBRP16LE : case AV_PIX_FMT_GBRP16BE : case AV_PIX_FMT_GBRAP12LE : case AV_PIX_FMT_GBRAP12BE : case AV_PIX_FMT_GBRAP16LE : case AV_PIX_FMT_GBRAP16BE : w_align = 16 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV411P : case AV_PIX_FMT_YUVJ411P : case AV_PIX_FMT_UYYVYY411 : w_align = 32 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV410P : if ( s -> codec_id == AV_CODEC_ID_SVQ1 ) { w_align = 64 ; h_align = 64 ; } break ; case AV_PIX_FMT_RGB555 : if ( s -> codec_id == AV_CODEC_ID_RPZA ) { w_align = 4 ; h_align = 4 ; }  break ;  case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; }  if ( s -> codec_id == AV_CODEC_ID_JV ) {  w_align = 8 ; h_align = 8 ; } break ; case AV_PIX_FMT_BGR24 : if ( ( s -> codec_id == AV_CODEC_ID_MSZH ) || ( s -> codec_id == AV_CODEC_ID_ZLIB ) ) { w_align = 4 ; h_align = 4 ; } break ; case AV_PIX_FMT_RGB24 : if ( s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } break ; default : break ; } if ( s -> codec_id == AV_CODEC_ID_IFF_ILBM ) { w_align = FFMAX ( w_align , 8 ) ; } * width = FFALIGN ( * width , w_align ) ; * height = FFALIGN ( * height , h_align ) ; if ( s -> codec_id == AV_CODEC_ID_H264 || s -> lowres ) { * height += 2 ; * width = FFMAX ( * width , 32 ) ; } for ( i = 0 ; i < 4 ; i ++ ) linesize_align [ i ] = STRIDE_ALIGN ; }", 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; }  codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO
604,"CWE-000 static int ext4_show_options ( struct seq_file * seq , struct vfsmount * vfs ) { int def_errors ; unsigned long def_mount_opts ; struct super_block * sb = vfs -> mnt_sb ; struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_super_block * es = sbi -> s_es ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; def_errors = le16_to_cpu ( es -> s_errors ) ; if ( sbi -> s_sb_block != 1 ) seq_printf ( seq , "",sb=%llu"" , sbi -> s_sb_block ) ; if ( test_opt ( sb , MINIX_DF ) ) seq_puts ( seq , "",minixdf"" ) ; if ( test_opt ( sb , GRPID ) && ! ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) ) seq_puts ( seq , "",grpid"" ) ; if ( ! test_opt ( sb , GRPID ) && ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) ) seq_puts ( seq , "",nogrpid"" ) ; if ( sbi -> s_resuid != EXT4_DEF_RESUID || le16_to_cpu ( es -> s_def_resuid ) != EXT4_DEF_RESUID ) { seq_printf ( seq , "",resuid=%u"" , sbi -> s_resuid ) ; } if ( sbi -> s_resgid != EXT4_DEF_RESGID || le16_to_cpu ( es -> s_def_resgid ) != EXT4_DEF_RESGID ) { seq_printf ( seq , "",resgid=%u"" , sbi -> s_resgid ) ; } if ( test_opt ( sb , ERRORS_RO ) ) { if ( def_errors == EXT4_ERRORS_PANIC || def_errors == EXT4_ERRORS_CONTINUE ) { seq_puts ( seq , "",errors=remount-ro"" ) ; } } if ( test_opt ( sb , ERRORS_CONT ) && def_errors != EXT4_ERRORS_CONTINUE ) seq_puts ( seq , "",errors=continue"" ) ; if ( test_opt ( sb , ERRORS_PANIC ) && def_errors != EXT4_ERRORS_PANIC ) seq_puts ( seq , "",errors=panic"" ) ; if ( test_opt ( sb , NO_UID32 ) && ! ( def_mount_opts & EXT4_DEFM_UID16 ) ) seq_puts ( seq , "",nouid32"" ) ; if ( test_opt ( sb , DEBUG ) && ! ( def_mount_opts & EXT4_DEFM_DEBUG ) ) seq_puts ( seq , "",debug"" ) ; if ( test_opt ( sb , OLDALLOC ) ) seq_puts ( seq , "",oldalloc"" ) ; # ifdef CONFIG_EXT4_FS_XATTR if ( test_opt ( sb , XATTR_USER ) && ! ( def_mount_opts & EXT4_DEFM_XATTR_USER ) ) seq_puts ( seq , "",user_xattr"" ) ; if ( ! test_opt ( sb , XATTR_USER ) && ( def_mount_opts & EXT4_DEFM_XATTR_USER ) ) { seq_puts ( seq , "",nouser_xattr"" ) ; } # endif # ifdef CONFIG_EXT4_FS_POSIX_ACL if ( test_opt ( sb , POSIX_ACL ) && ! ( def_mount_opts & EXT4_DEFM_ACL ) ) seq_puts ( seq , "",acl"" ) ; if ( ! test_opt ( sb , POSIX_ACL ) && ( def_mount_opts & EXT4_DEFM_ACL ) ) seq_puts ( seq , "",noacl"" ) ; # endif if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { seq_printf ( seq , "",commit=%u"" , ( unsigned ) ( sbi -> s_commit_interval / HZ ) ) ; } if ( sbi -> s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME ) { seq_printf ( seq , "",min_batch_time=%u"" , ( unsigned ) sbi -> s_min_batch_time ) ; } if ( sbi -> s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME ) { seq_printf ( seq , "",max_batch_time=%u"" , ( unsigned ) sbi -> s_min_batch_time ) ; } seq_puts ( seq , "",barrier="" ) ; seq_puts ( seq , test_opt ( sb , BARRIER ) ? ""1"" : ""0"" ) ; if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) seq_puts ( seq , "",journal_async_commit"" ) ; if ( test_opt ( sb , NOBH ) ) seq_puts ( seq , "",nobh"" ) ; if ( test_opt ( sb , I_VERSION ) ) seq_puts ( seq , "",i_version"" ) ; if ( ! test_opt ( sb , DELALLOC ) ) seq_puts ( seq , "",nodelalloc"" ) ; if ( sbi -> s_stripe ) seq_printf ( seq , "",stripe=%lu"" , sbi -> s_stripe ) ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) seq_puts ( seq , "",data=journal"" ) ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) seq_puts ( seq , "",data=ordered"" ) ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_WRITEBACK_DATA ) seq_puts ( seq , "",data=writeback"" ) ; if ( sbi -> s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS ) seq_printf ( seq , "",inode_readahead_blks=%u"" , sbi -> s_inode_readahead_blks ) ; if ( test_opt ( sb , DATA_ERR_ABORT ) ) seq_puts ( seq , "",data_err=abort"" ) ; if ( test_opt ( sb , NO_AUTO_DA_ALLOC ) ) seq_puts ( seq , "",noauto_da_alloc"" ) ; if ( test_opt ( sb , DISCARD ) ) seq_puts ( seq , "",discard"" ) ; if ( test_opt ( sb , NOLOAD ) ) seq_puts ( seq , "",norecovery"" ) ;  ext4_show_quota_options ( seq , sb ) ;  return 0 ; }"," "",norecovery"" ) ; if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , "",dioread_nolock"" ) ;"
605,"CWE-476 BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp )  {  if ( rdp -> decrypt_use_count >= 4096 ) { security_key_update ( rdp -> decrypt_key , rdp -> decrypt_update_key , rdp -> rc4_key_len ) ; crypto_rc4_free ( rdp -> rc4_decrypt_key ) ; rdp -> rc4_decrypt_key = crypto_rc4_init ( rdp -> decrypt_key , rdp -> rc4_key_len ) ; rdp -> decrypt_use_count = 0 ; } crypto_rc4 ( rdp -> rc4_decrypt_key , length , data , data ) ; rdp -> decrypt_use_count += 1 ; rdp -> decrypt_checksum_use_count ++ ; return TRUE ; }", rdp ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
606,"CWE-000 bgp_attr_parse_ret_t bgp_attr_parse ( struct peer * peer , struct attr * attr , bgp_size_t size , struct bgp_nlri * mp_update , struct bgp_nlri * mp_withdraw ) { bgp_attr_parse_ret_t ret ; uint8_t flag = 0 ; uint8_t type = 0 ; bgp_size_t length ; uint8_t * startp , * endp ; uint8_t * attr_endp ; uint8_t seen [ BGP_ATTR_BITMAP_SIZE ] ; struct aspath * as4_path = NULL ; as_t as4_aggregator = 0 ; struct in_addr as4_aggregator_addr = { . s_addr = 0 } ; memset ( seen , 0 , BGP_ATTR_BITMAP_SIZE ) ; endp = BGP_INPUT_PNT ( peer ) + size ; while ( BGP_INPUT_PNT ( peer ) < endp ) { if ( endp - BGP_INPUT_PNT ( peer ) < BGP_ATTR_MIN_LEN ) { flog_warn ( EC_BGP_ATTRIBUTE_TOO_SMALL , ""%s:errorBGPattributelength%luissmallerthanminlen"" , peer -> host , ( unsigned long ) ( endp - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; return BGP_ATTR_PARSE_ERROR ; } startp = BGP_INPUT_PNT ( peer ) ; flag = 0xF0 & stream_getc ( BGP_INPUT ( peer ) ) ; type = stream_getc ( BGP_INPUT ( peer ) ) ; if ( CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) && ( ( endp - startp ) < ( BGP_ATTR_MIN_LEN + 1 ) ) ) { flog_warn ( EC_BGP_EXT_ATTRIBUTE_TOO_SMALL , ""%s:Extendedlengthset,butjust%lubytesofattrheader"" , peer -> host , ( unsigned long ) ( endp - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; return BGP_ATTR_PARSE_ERROR ; } if ( CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) ) length = stream_getw ( BGP_INPUT ( peer ) ) ; else length = stream_getc ( BGP_INPUT ( peer ) ) ; if ( CHECK_BITMAP ( seen , type ) ) { flog_warn ( EC_BGP_ATTRIBUTE_REPEATED , ""%s:errorBGPattributetype%dappearstwiceinamessage"" , peer -> host , type ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_MAL_ATTR ) ; return BGP_ATTR_PARSE_ERROR ; } SET_BITMAP ( seen , type ) ; attr_endp = BGP_INPUT_PNT ( peer ) + length ; if ( attr_endp > endp ) { flog_warn ( EC_BGP_ATTRIBUTE_TOO_LARGE , ""%s:BGPtype%dlength%distoolarge,attributetotallengthis%d.attr_endpis%p.endpis%p"" , peer -> host , type , length , size , attr_endp , endp ) ; unsigned char ndata [ BGP_MAX_PACKET_SIZE ] ; memset ( ndata , 0x00 , sizeof ( ndata ) ) ; size_t lfl = CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) ? 2 : 1 ; stream_forward_getp ( BGP_INPUT ( peer ) , - ( 1 + lfl ) ) ; stream_get ( & ndata [ 0 ] , BGP_INPUT ( peer ) , 1 ) ; stream_get ( & ndata [ 1 ] , BGP_INPUT ( peer ) , lfl ) ; size_t atl = attr_endp - startp ; size_t ndl = MIN ( atl , STREAM_READABLE ( BGP_INPUT ( peer ) ) ) ; stream_get ( & ndata [ lfl + 1 ] , BGP_INPUT ( peer ) , ndl ) ; bgp_notify_send_with_data ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR , ndata , ndl + lfl + 1 ) ; return BGP_ATTR_PARSE_ERROR ; } struct bgp_attr_parser_args attr_args = { . peer = peer , . length = length , . attr = attr , . type = type , . flags = flag , . startp = startp , . total = attr_endp - startp , } ; if ( bgp_attr_flag_invalid ( & attr_args ) ) { ret = bgp_attr_malformed ( & attr_args , BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR , attr_args . total ) ; if ( ret == BGP_ATTR_PARSE_PROCEED ) continue ; return ret ; } switch ( type ) { case BGP_ATTR_ORIGIN : ret = bgp_attr_origin ( & attr_args ) ; break ; case BGP_ATTR_AS_PATH : ret = bgp_attr_aspath ( & attr_args ) ; break ; case BGP_ATTR_AS4_PATH : ret = bgp_attr_as4_path ( & attr_args , & as4_path ) ; break ; case BGP_ATTR_NEXT_HOP : ret = bgp_attr_nexthop ( & attr_args ) ; break ; case BGP_ATTR_MULTI_EXIT_DISC : ret = bgp_attr_med ( & attr_args ) ; break ; case BGP_ATTR_LOCAL_PREF : ret = bgp_attr_local_pref ( & attr_args ) ; break ; case BGP_ATTR_ATOMIC_AGGREGATE : ret = bgp_attr_atomic ( & attr_args ) ; break ; case BGP_ATTR_AGGREGATOR : ret = bgp_attr_aggregator ( & attr_args ) ; break ; case BGP_ATTR_AS4_AGGREGATOR : ret = bgp_attr_as4_aggregator ( & attr_args , & as4_aggregator , & as4_aggregator_addr ) ; break ; case BGP_ATTR_COMMUNITIES : ret = bgp_attr_community ( & attr_args ) ; break ; case BGP_ATTR_LARGE_COMMUNITIES : ret = bgp_attr_large_community ( & attr_args ) ; break ; case BGP_ATTR_ORIGINATOR_ID : ret = bgp_attr_originator_id ( & attr_args ) ; break ; case BGP_ATTR_CLUSTER_LIST : ret = bgp_attr_cluster_list ( & attr_args ) ; break ; case BGP_ATTR_MP_REACH_NLRI : ret = bgp_mp_reach_parse ( & attr_args , mp_update ) ; break ; case BGP_ATTR_MP_UNREACH_NLRI : ret = bgp_mp_unreach_parse ( & attr_args , mp_withdraw ) ; break ; case BGP_ATTR_EXT_COMMUNITIES : ret = bgp_attr_ext_communities ( & attr_args ) ; break ;  # if ENABLE_BGP_VNC  case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ; break ; case BGP_ATTR_PREFIX_SID : ret = bgp_attr_prefix_sid ( length , & attr_args , mp_update ) ; break ; case BGP_ATTR_PMSI_TUNNEL : ret = bgp_attr_pmsi_tunnel ( & attr_args ) ; break ; default : ret = bgp_attr_unknown ( & attr_args ) ; break ; } if ( ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS ) { bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_MAL_ATTR ) ; ret = BGP_ATTR_PARSE_ERROR ; } if ( ret == BGP_ATTR_PARSE_EOR ) { if ( as4_path ) aspath_unintern ( & as4_path ) ; return ret ; } if ( ret == BGP_ATTR_PARSE_ERROR ) { flog_warn ( EC_BGP_ATTRIBUTE_PARSE_ERROR , ""%s:Attribute%s,parseerror"" , peer -> host , lookup_msg ( attr_str , type , NULL ) ) ; if ( as4_path ) aspath_unintern ( & as4_path ) ; return ret ; } if ( ret == BGP_ATTR_PARSE_WITHDRAW ) { flog_warn ( EC_BGP_ATTRIBUTE_PARSE_WITHDRAW , ""%s:Attribute%s,parseerror-treatingaswithdrawal"" , peer -> host , lookup_msg ( attr_str , type , NULL ) ) ; if ( as4_path ) aspath_unintern ( & as4_path ) ; return ret ; } if ( BGP_INPUT_PNT ( peer ) != attr_endp ) { flog_warn ( EC_BGP_ATTRIBUTE_FETCH_ERROR , ""%s:BGPattribute%s,fetcherror"" , peer -> host , lookup_msg ( attr_str , type , NULL ) ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; if ( as4_path ) aspath_unintern ( & as4_path ) ; return BGP_ATTR_PARSE_ERROR ; } } if ( BGP_INPUT_PNT ( peer ) != endp ) { flog_warn ( EC_BGP_ATTRIBUTES_MISMATCH , ""%s:BGPattribute%s,lengthmismatch"" , peer -> host , lookup_msg ( attr_str , type , NULL ) ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; if ( as4_path ) aspath_unintern ( & as4_path ) ; return BGP_ATTR_PARSE_ERROR ; } if ( ( ret = bgp_attr_check ( peer , attr ) ) < 0 ) { if ( as4_path ) aspath_unintern ( & as4_path ) ; return ret ; } if ( CHECK_FLAG ( attr -> flag , ATTR_FLAG_BIT ( BGP_ATTR_AS_PATH ) ) && bgp_attr_munge_as4_attrs ( peer , attr , as4_path , as4_aggregator , & as4_aggregator_addr ) ) { bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_MAL_ATTR ) ; if ( as4_path ) aspath_unintern ( & as4_path ) ; return BGP_ATTR_PARSE_ERROR ; } if ( as4_path ) { aspath_unintern ( & as4_path ) ; } if ( attr -> flag & ( ATTR_FLAG_BIT ( BGP_ATTR_AS_PATH ) ) ) { ret = bgp_attr_aspath_check ( peer , attr ) ; if ( ret != BGP_ATTR_PARSE_PROCEED ) return ret ; } if ( attr -> transit ) attr -> transit = transit_intern ( attr -> transit ) ; if ( attr -> encap_subtlvs ) attr -> encap_subtlvs = encap_intern ( attr -> encap_subtlvs , ENCAP_SUBTLV_TYPE ) ; # if ENABLE_BGP_VNC if ( attr -> vnc_subtlvs ) attr -> vnc_subtlvs = encap_intern ( attr -> vnc_subtlvs , VNC_SUBTLV_TYPE ) ; # endif return BGP_ATTR_PARSE_PROCEED ; }", ; # if ENABLE_BGP_VNC_ATTR  case BGP_ATTR_VNC :
607,"CWE-000 static gboolean comics_check_decompress_command ( gchar * mime_type , ComicsDocument * comics_document , GError * * error ) { gboolean success ; gchar * std_out , * std_err ; gint retval ; GError * err = NULL ; if ( g_content_type_is_a ( mime_type , ""application/x-cbr"" ) || g_content_type_is_a ( mime_type , ""application/x-rar"" ) ) { comics_document -> selected_command = g_find_program_in_path ( ""unrar"" ) ; if ( comics_document -> selected_command ) { success = g_spawn_command_line_sync ( comics_document -> selected_command , & std_out , & std_err , & retval , & err ) ; if ( ! success ) { g_propagate_error ( error , err ) ; g_error_free ( err ) ; return FALSE ; } else if ( WIFEXITED ( retval ) ) { if ( g_strrstr ( std_out , ""freeware"" ) != NULL ) comics_document -> command_usage = RARLABS ; else comics_document -> command_usage = GNAUNRAR ; g_free ( std_out ) ; g_free ( std_err ) ; return TRUE ; } } comics_document -> selected_command = g_find_program_in_path ( ""unrar-free"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = GNAUNRAR ; return TRUE ; }  comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else if ( g_content_type_is_a ( mime_type , ""application/x-cbz"" ) || g_content_type_is_a ( mime_type , ""application/zip"" ) ) { comics_document -> selected_command = g_find_program_in_path ( ""unzip"" ) ; comics_document -> alternative_command = g_find_program_in_path ( ""zipnote"" ) ; if ( comics_document -> selected_command && comics_document -> alternative_command ) { comics_document -> command_usage = UNZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( ""7za"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; }  comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else if ( g_content_type_is_a ( mime_type , ""application/x-cb7"" ) || g_content_type_is_a ( mime_type , ""application/x-7z-compressed"" ) ) { comics_document -> selected_command = g_find_program_in_path ( ""7zr"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( ""7za"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; }  comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else if ( g_content_type_is_a ( mime_type , ""application/x-cbt"" ) || g_content_type_is_a ( mime_type , ""application/x-tar"" ) ) { comics_document -> selected_command = g_find_program_in_path ( ""tar"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( ""bsdtar"" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else { g_set_error ( error , EV_DOCUMENT_ERROR , EV_DOCUMENT_ERROR_INVALID , _ ( ""NotacomicbookMIMEtype:%s"" ) , mime_type ) ; return FALSE ; } g_set_error_literal ( error , EV_DOCUMENT_ERROR , EV_DOCUMENT_ERROR_INVALID , _ ( ""Can’tfindanappropriatecommandto"" ""decompressthistypeofcomicbook"" ) ) ; return FALSE ; }", TRUE ; }  } else if  TRUE ; }  } else if  TRUE ; } } else  { g_set_error (
608,"CWE-125 void wb_print ( netdissect_options * ndo , register const void * hdr , register u_int len ) { register const struct pkt_hdr * ph ; ph = ( const struct pkt_hdr * ) hdr ; if ( len < sizeof ( * ph ) || ! ND_TTEST ( * ph ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } len -= sizeof ( * ph ) ; if ( ph -> ph_flags ) ND_PRINT ( ( ndo , ""*"" ) ) ; switch ( ph -> ph_type ) { case PT_KILL : ND_PRINT ( ( ndo , ""wb-kill"" ) ) ; return ; case PT_ID : if ( wb_id ( ndo , ( const struct pkt_id * ) ( ph + 1 ) , len ) >= 0 ) return ;  break ;  case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ;  break ;  case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ;  break ;  case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ;  break ;  case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ;  break ;  case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 )  return ;  break ; default : ND_PRINT ( ( ndo , ""wb-%d!"" , ph -> ph_type ) ) ; return ; } }"," ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;  ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;  ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;  ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;  ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;  0 ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) )"
609,"CWE-119 static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ ETH_ALEN ] ;  int i , pktsz , ret ;  if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { dev_err ( dev , ""Can\'tsetaltsetting1.\\n"" ) ; return - EIO ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - ENOMEM ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = TX_TIMEOUT ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , ""Nofreeurbsavailable.\\n"" ) ; ret = - ENOMEM ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { dev_dbg ( dev , ""Testingforf5u011\\n"" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = RX_PKT_SZ ; } else { pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , NULL , NULL , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , NULL , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) {  dev_dbg ( dev , ""Checkingmemorysize\\n"" ) ;   i = 0x12345678 ;   catc_write_mem ( catc , 0x7a80 , & i , 4 ) ;   i = 0x87654321 ;   catc_write_mem ( catc , 0xfa80 , & i , 4 ) ;   catc_read_mem ( catc , 0x7a80 , & i , 4 ) ;   switch ( i ) {  case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ; catc_set_reg ( catc , RxBufCount , 32 ) ; dev_dbg ( dev , ""64kMemory\\n"" ) ; break ; default : dev_warn ( & intf -> dev , ""Couldn\'tdetectmemorysize,assuming32k\\n"" ) ; case 0x87654321 : catc_set_reg ( catc , TxBufCount , 4 ) ; catc_set_reg ( catc , RxBufCount , 16 ) ; dev_dbg ( dev , ""32kMemory\\n"" ) ; break ;  }  dev_dbg ( dev , ""GettingMACfromSEEROM.\\n"" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""SettingMACintoregisters.\\n"" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , ""Fillingthemulticastlist.\\n"" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , ""Clearingerrorcounters.\\n"" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , EthStats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , ""Enabling.\\n"" ) ; catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; catc_set_reg ( catc , LEDCtrl , LEDLink ) ; catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; } else { dev_dbg ( dev , ""Performingreset\\n"" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""SettingRXMode\\n"" ) ; catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , ""Initdone.\\n"" ) ; printk ( KERN_INFO ""%s:%sUSBEthernetatusb-%s-%s,%pM.\\n"" , netdev -> name , ( catc -> is_f5u011 ) ? ""BelkinF5U011"" : ""CATCEL1210ANetMate"" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; SET_NETDEV_DEV ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , NULL ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }"," ] ; int  pktsz , ret  is_f5u011 ) { u32 * buf ; int i ;  ""Checkingmemorysize\\n"" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf  = 0x12345678 ;  , 0x7a80 , buf  , 4 )  4 ) ; * buf  = 0x87654321 ;  , 0xfa80 , buf  , 4 )  , 0x7a80 , buf  , 4 )  ; switch ( * buf  ) { case  break ; } kfree ( buf ) ;"
610,"CWE-399 static int ceph_x_verify_authorizer_reply ( struct ceph_auth_client * ac , struct ceph_authorizer * a , size_t len ) { struct ceph_x_authorizer * au = ( void * ) a ; struct ceph_x_ticket_handler * th ; int ret = 0 ; struct ceph_x_authorize_reply reply ;  void * p = au -> reply_buf ;  void * end = p + sizeof ( au -> reply_buf ) ; th = get_ticket_handler ( ac , au -> service ) ; if ( IS_ERR ( th ) ) return PTR_ERR ( th ) ;  ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ;  if ( ret < 0 ) return ret ; if ( ret != sizeof ( reply ) ) return - EPERM ; if ( au -> nonce + 1 != le64_to_cpu ( reply . nonce_plus_one ) ) ret = - EPERM ; else ret = 0 ; dout ( ""verify_authorizer_replynonce%llxgot%llxret%d\\n"" , au -> nonce , le64_to_cpu ( reply . nonce_plus_one ) , ret ) ; return ret ; }"," ; void * preply = & reply ; void *  end , & preply  , sizeof ("
611,"CWE-125 void ip6_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { register const struct ip6_hdr * ip6 ; register int advance ; u_int len ; const u_char * ipend ; register const u_char * cp ; register u_int payload_len ; int nh ; int fragmented = 0 ; u_int flow ; ip6 = ( const struct ip6_hdr * ) bp ; ND_TCHECK ( * ip6 ) ; if ( length < sizeof ( struct ip6_hdr ) ) { ND_PRINT ( ( ndo , ""truncated-ip6%u"" , length ) ) ; return ; } if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IP6"" ) ) ; if ( IP6_VERSION ( ip6 ) != 6 ) { ND_PRINT ( ( ndo , ""versionerror:%u!=6"" , IP6_VERSION ( ip6 ) ) ) ; return ; } payload_len = EXTRACT_16BITS ( & ip6 -> ip6_plen ) ; len = payload_len + sizeof ( struct ip6_hdr ) ; if ( length < len ) ND_PRINT ( ( ndo , ""truncated-ip6-%ubytesmissing!"" , len - length ) ) ; if ( ndo -> ndo_vflag ) { flow = EXTRACT_32BITS ( & ip6 -> ip6_flow ) ; ND_PRINT ( ( ndo , ""("" ) ) ; # if 0 if ( flow & 0x0f000000 ) ND_PRINT ( ( ndo , ""pri0x%02x,"" , ( flow & 0x0f000000 ) >> 24 ) ) ; if ( flow & 0x00ffffff ) ND_PRINT ( ( ndo , ""flowlabel0x%06x,"" , flow & 0x00ffffff ) ) ; # else if ( flow & 0x0ff00000 ) ND_PRINT ( ( ndo , ""class0x%02x,"" , ( flow & 0x0ff00000 ) >> 20 ) ) ; if ( flow & 0x000fffff ) ND_PRINT ( ( ndo , ""flowlabel0x%05x,"" , flow & 0x000fffff ) ) ; # endif ND_PRINT ( ( ndo , ""hlim%u,next-header%s(%u)payloadlength:%u)"" , ip6 -> ip6_hlim , tok2str ( ipproto_values , ""unknown"" , ip6 -> ip6_nxt ) , ip6 -> ip6_nxt , payload_len ) ) ; } ipend = bp + len ; if ( ipend < ndo -> ndo_snapend ) ndo -> ndo_snapend = ipend ; cp = ( const u_char * ) ip6 ; advance = sizeof ( struct ip6_hdr ) ; nh = ip6 -> ip6_nxt ; while ( cp < ndo -> ndo_snapend && advance > 0 ) {  cp += advance ;  len -= advance ; if ( cp == ( const u_char * ) ( ip6 + 1 ) && nh != IPPROTO_TCP && nh != IPPROTO_UDP && nh != IPPROTO_DCCP && nh != IPPROTO_SCTP ) { ND_PRINT ( ( ndo , ""%s>%s:"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; } switch ( nh ) { case IPPROTO_HOPOPTS : advance = hbhopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_DSTOPTS : advance = dstopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_FRAGMENT : advance = frag6_print ( ndo , cp , ( const u_char * ) ip6 ) ; if ( advance < 0 || ndo -> ndo_snapend <= cp + advance ) return ; nh = * cp ; fragmented = 1 ; break ; case IPPROTO_MOBILITY_OLD : case IPPROTO_MOBILITY : advance = mobility_print ( ndo , cp , ( const u_char * ) ip6 ) ;  nh = * cp ;  return ; case IPPROTO_ROUTING :  advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ;   nh = * cp ;  break ; case IPPROTO_SCTP : sctp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_DCCP : dccp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_TCP : tcp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_UDP : udp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_ICMPV6 : icmp6_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_AH :  advance = ah_print ( ndo , cp ) ;  nh = * cp ; break ; case IPPROTO_ESP : { int enh , padlen ; advance = esp_print ( ndo , cp , len , ( const u_char * ) ip6 , & enh , & padlen ) ;  nh = enh & 0xff ;  len -= padlen ; break ; } case IPPROTO_IPCOMP : { ipcomp_print ( ndo , cp ) ; advance = - 1 ; break ; } case IPPROTO_PIM : pim_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_OSPF : ospf6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV6 : ip6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV4 : ip_print ( ndo , cp , len ) ; return ; case IPPROTO_PGM : pgm_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_GRE : gre_print ( ndo , cp , len ) ; return ; case IPPROTO_RSVP : rsvp_print ( ndo , cp , len ) ; return ; case IPPROTO_NONE : ND_PRINT ( ( ndo , ""nonextheader"" ) ) ; return ; default : ND_PRINT ( ( ndo , ""ip-proto-%d%d"" , nh , len ) ) ; return ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|ip6]"" ) ) ; }"," 0 ) { if ( len < ( u_int ) advance ) goto trunc ;  ip6 ) ; if ( advance < 0 ) return ;  case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ;  ip6 ) ; if ( advance < 0 ) return ;  , cp ) ; if ( advance < 0 ) return  padlen ) ; if ( advance < 0 ) return ;"
612,"CWE-189 Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ;  if ( p == q || size < 16 || size > 256 )  return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }", ; if ( (  p == q ) || (  size < 16  size < 16 ) || (  size > 256  size > 256 )
613,"CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""UnknownOriginTypecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values ,  ""?"" , tptr [ 0 ] ) ) ) ;  for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""AS#%s,origin%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""AS#%s,origin%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""AS#%s,origin%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "","" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "","" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\tAFI:%s(%u),%sSAFI:%s(%u)"" , tok2str ( af_values , ""UnknownAFI"" , af ) , af , ( safi > 128 ) ? ""vendorspecific"" : """" , tok2str ( bgp_safi_values , ""UnknownSAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\tnoAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\tnexthop:"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "","" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:%s,%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:%s,%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:%s,%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""=%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""=%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""noAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",nh-length:%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t%uSNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t%dbytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",noSNPA"" ) ) ; } while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegallength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\tnoAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\tAFI:%s(%u),%sSAFI:%s(%u)"" , tok2str ( af_values , ""UnknownAFI"" , af ) , af , ( safi > 128 ) ? ""vendorspecific"" : """" , tok2str ( bgp_safi_values , ""UnknownSAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\tEnd-of-RibMarker(emptyNLRI)"" ) ) ; tptr += 3 ; while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegallength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""noAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t%s(0x%04x),Flags[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknownextdcommunitytypecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":%u:%u(=%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":bandwidth:%.3fMbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":area:%s,router-type:%s,metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":%sControlFlags[0x%02x]:MTU%u"" , tok2str ( l2vpn_encaps_values , ""unknownencaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":AS%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\tTunnel-type%s(%u),Flags[%s],MPLSLabel%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tSender%s,P-Group%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tRoot-Node%s,P-Group%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tTunnel-Endpoint%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tRoot-Node%s,LSP-ID0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tExtended-Tunnel-ID%s,P2MP-ID0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; tlen = len ; while ( tlen >= 3 ) { type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t%sTLV(%u),length%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; switch ( type ) { case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; ND_PRINT ( ( ndo , "",metric%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr + 3 , ""\\n\\t"" , length - 3 ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\tOriginAS:%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t%s(%u),length:%u"" , tok2str ( bgp_attr_values , ""UnknownAttribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",Flags[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "","" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\tnoAttribute%udecoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t"" , len ) ; } return 1 ; trunc : return 0 ; }", ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
614,"CWE-119 static int jpc_dec_tileinit ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { jpc_dec_tcomp_t * tcomp ; int compno ; int rlvlno ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; jpc_dec_prc_t * prc ; int bndno ; jpc_tsfb_band_t * bnd ; int bandno ; jpc_dec_ccp_t * ccp ; int prccnt ; jpc_dec_cblk_t * cblk ; int cblkcnt ; uint_fast32_t tlprcxstart ; uint_fast32_t tlprcystart ; uint_fast32_t brprcxend ; uint_fast32_t brprcyend ; uint_fast32_t tlcbgxstart ; uint_fast32_t tlcbgystart ; uint_fast32_t brcbgxend ; uint_fast32_t brcbgyend ; uint_fast32_t cbgxstart ; uint_fast32_t cbgystart ; uint_fast32_t cbgxend ; uint_fast32_t cbgyend ; uint_fast32_t tlcblkxstart ; uint_fast32_t tlcblkystart ; uint_fast32_t brcblkxend ; uint_fast32_t brcblkyend ; uint_fast32_t cblkxstart ; uint_fast32_t cblkystart ; uint_fast32_t cblkxend ; uint_fast32_t cblkyend ; uint_fast32_t tmpxstart ; uint_fast32_t tmpystart ; uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ;  jpc_tsfb_band_t bnds [ 64 ] ;  jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ; cp = tile -> cp ; tile -> realmode = 0 ; if ( cp -> mctid == JPC_MCT_ICT ) { tile -> realmode = 1 ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { ccp = & tile -> cp -> ccps [ compno ] ; if ( ccp -> qmfbid == JPC_COX_INS ) { tile -> realmode = 1 ; } tcomp -> numrlvls = ccp -> numrlvls ; if ( ! ( tcomp -> rlvls = jas_alloc2 ( tcomp -> numrlvls , sizeof ( jpc_dec_rlvl_t ) ) ) ) { return - 1 ; } if ( ! ( tcomp -> data = jas_seq2d_create ( JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) , JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) , JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) , JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ) ) ) { return - 1 ; } if ( ! ( tcomp -> tsfb = jpc_cod_gettsfb ( ccp -> qmfbid , tcomp -> numrlvls - 1 ) ) ) { return - 1 ; } { jpc_tsfb_getbands ( tcomp -> tsfb , jas_seq2d_xstart ( tcomp -> data ) , jas_seq2d_ystart ( tcomp -> data ) , jas_seq2d_xend ( tcomp -> data ) , jas_seq2d_yend ( tcomp -> data ) , bnds ) ; } for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { rlvl -> bands = 0 ; rlvl -> xstart = JPC_CEILDIVPOW2 ( tcomp -> xstart , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> ystart = JPC_CEILDIVPOW2 ( tcomp -> ystart , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> xend = JPC_CEILDIVPOW2 ( tcomp -> xend , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> yend = JPC_CEILDIVPOW2 ( tcomp -> yend , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> prcwidthexpn = ccp -> prcwidthexpns [ rlvlno ] ; rlvl -> prcheightexpn = ccp -> prcheightexpns [ rlvlno ] ; tlprcxstart = JPC_FLOORDIVPOW2 ( rlvl -> xstart , rlvl -> prcwidthexpn ) << rlvl -> prcwidthexpn ; tlprcystart = JPC_FLOORDIVPOW2 ( rlvl -> ystart , rlvl -> prcheightexpn ) << rlvl -> prcheightexpn ; brprcxend = JPC_CEILDIVPOW2 ( rlvl -> xend , rlvl -> prcwidthexpn ) << rlvl -> prcwidthexpn ; brprcyend = JPC_CEILDIVPOW2 ( rlvl -> yend , rlvl -> prcheightexpn ) << rlvl -> prcheightexpn ; rlvl -> numhprcs = ( brprcxend - tlprcxstart ) >> rlvl -> prcwidthexpn ; rlvl -> numvprcs = ( brprcyend - tlprcystart ) >> rlvl -> prcheightexpn ; rlvl -> numprcs = rlvl -> numhprcs * rlvl -> numvprcs ; if ( rlvl -> xstart >= rlvl -> xend || rlvl -> ystart >= rlvl -> yend ) { rlvl -> bands = 0 ; rlvl -> numprcs = 0 ; rlvl -> numhprcs = 0 ; rlvl -> numvprcs = 0 ; continue ; } if ( ! rlvlno ) { tlcbgxstart = tlprcxstart ; tlcbgystart = tlprcystart ; brcbgxend = brprcxend ; brcbgyend = brprcyend ; rlvl -> cbgwidthexpn = rlvl -> prcwidthexpn ; rlvl -> cbgheightexpn = rlvl -> prcheightexpn ; } else { tlcbgxstart = JPC_CEILDIVPOW2 ( tlprcxstart , 1 ) ; tlcbgystart = JPC_CEILDIVPOW2 ( tlprcystart , 1 ) ; brcbgxend = JPC_CEILDIVPOW2 ( brprcxend , 1 ) ; brcbgyend = JPC_CEILDIVPOW2 ( brprcyend , 1 ) ; rlvl -> cbgwidthexpn = rlvl -> prcwidthexpn - 1 ; rlvl -> cbgheightexpn = rlvl -> prcheightexpn - 1 ; } rlvl -> cblkwidthexpn = JAS_MIN ( ccp -> cblkwidthexpn , rlvl -> cbgwidthexpn ) ; rlvl -> cblkheightexpn = JAS_MIN ( ccp -> cblkheightexpn , rlvl -> cbgheightexpn ) ; rlvl -> numbands = ( ! rlvlno ) ? 1 : 3 ; if ( ! ( rlvl -> bands = jas_alloc2 ( rlvl -> numbands , sizeof ( jpc_dec_band_t ) ) ) ) { return - 1 ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { bndno = ( ! rlvlno ) ? 0 : ( 3 * ( rlvlno - 1 ) + bandno + 1 ) ; bnd = & bnds [ bndno ] ; band -> orient = bnd -> orient ; band -> stepsize = ccp -> stepsizes [ bndno ] ; band -> analgain = JPC_NOMINALGAIN ( ccp -> qmfbid , tcomp -> numrlvls - 1 , rlvlno , band -> orient ) ; band -> absstepsize = jpc_calcabsstepsize ( band -> stepsize , cmpt -> prec + band -> analgain ) ; band -> numbps = ccp -> numguardbits + JPC_QCX_GETEXPN ( band -> stepsize ) - 1 ; band -> roishift = ( ccp -> roishift + band -> numbps >= JPC_PREC ) ? ( JPC_PREC - 1 - band -> numbps ) : ccp -> roishift ; band -> data = 0 ; band -> prcs = 0 ; if ( bnd -> xstart == bnd -> xend || bnd -> ystart == bnd -> yend ) { continue ; } if ( ! ( band -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) { return - 1 ; } jas_seq2d_bindsub ( band -> data , tcomp -> data , bnd -> locxstart , bnd -> locystart , bnd -> locxend , bnd -> locyend ) ; jas_seq2d_setshift ( band -> data , bnd -> xstart , bnd -> ystart ) ; assert ( rlvl -> numprcs ) ; if ( ! ( band -> prcs = jas_alloc2 ( rlvl -> numprcs , sizeof ( jpc_dec_prc_t ) ) ) ) { return - 1 ; } cbgxstart = tlcbgxstart ; cbgystart = tlcbgystart ; for ( prccnt = rlvl -> numprcs , prc = band -> prcs ; prccnt > 0 ; -- prccnt , ++ prc ) { cbgxend = cbgxstart + ( 1 << rlvl -> cbgwidthexpn ) ; cbgyend = cbgystart + ( 1 << rlvl -> cbgheightexpn ) ; prc -> xstart = JAS_MAX ( cbgxstart , JAS_CAST ( uint_fast32_t , jas_seq2d_xstart ( band -> data ) ) ) ; prc -> ystart = JAS_MAX ( cbgystart , JAS_CAST ( uint_fast32_t , jas_seq2d_ystart ( band -> data ) ) ) ; prc -> xend = JAS_MIN ( cbgxend , JAS_CAST ( uint_fast32_t , jas_seq2d_xend ( band -> data ) ) ) ; prc -> yend = JAS_MIN ( cbgyend , JAS_CAST ( uint_fast32_t , jas_seq2d_yend ( band -> data ) ) ) ; if ( prc -> xend > prc -> xstart && prc -> yend > prc -> ystart ) { tlcblkxstart = JPC_FLOORDIVPOW2 ( prc -> xstart , rlvl -> cblkwidthexpn ) << rlvl -> cblkwidthexpn ; tlcblkystart = JPC_FLOORDIVPOW2 ( prc -> ystart , rlvl -> cblkheightexpn ) << rlvl -> cblkheightexpn ; brcblkxend = JPC_CEILDIVPOW2 ( prc -> xend , rlvl -> cblkwidthexpn ) << rlvl -> cblkwidthexpn ; brcblkyend = JPC_CEILDIVPOW2 ( prc -> yend , rlvl -> cblkheightexpn ) << rlvl -> cblkheightexpn ; prc -> numhcblks = ( brcblkxend - tlcblkxstart ) >> rlvl -> cblkwidthexpn ; prc -> numvcblks = ( brcblkyend - tlcblkystart ) >> rlvl -> cblkheightexpn ; prc -> numcblks = prc -> numhcblks * prc -> numvcblks ; assert ( prc -> numcblks > 0 ) ; if ( ! ( prc -> incltagtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) { return - 1 ; } if ( ! ( prc -> numimsbstagtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) { return - 1 ; } if ( ! ( prc -> cblks = jas_alloc2 ( prc -> numcblks , sizeof ( jpc_dec_cblk_t ) ) ) ) { return - 1 ; } cblkxstart = cbgxstart ; cblkystart = cbgystart ; for ( cblkcnt = prc -> numcblks , cblk = prc -> cblks ; cblkcnt > 0 ; ) { cblkxend = cblkxstart + ( 1 << rlvl -> cblkwidthexpn ) ; cblkyend = cblkystart + ( 1 << rlvl -> cblkheightexpn ) ; tmpxstart = JAS_MAX ( cblkxstart , prc -> xstart ) ; tmpystart = JAS_MAX ( cblkystart , prc -> ystart ) ; tmpxend = JAS_MIN ( cblkxend , prc -> xend ) ; tmpyend = JAS_MIN ( cblkyend , prc -> yend ) ; if ( tmpxend > tmpxstart && tmpyend > tmpystart ) { cblk -> firstpassno = - 1 ; cblk -> mqdec = 0 ; cblk -> nulldec = 0 ; cblk -> flags = 0 ; cblk -> numpasses = 0 ; cblk -> segs . head = 0 ; cblk -> segs . tail = 0 ; cblk -> curseg = 0 ; cblk -> numimsbs = 0 ; cblk -> numlenbits = 3 ; cblk -> flags = 0 ; if ( ! ( cblk -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) { return - 1 ; } jas_seq2d_bindsub ( cblk -> data , band -> data , tmpxstart , tmpystart , tmpxend , tmpyend ) ; ++ cblk ; -- cblkcnt ; } cblkxstart += 1 << rlvl -> cblkwidthexpn ; if ( cblkxstart >= cbgxend ) { cblkxstart = cbgxstart ; cblkystart += 1 << rlvl -> cblkheightexpn ; } } } else { prc -> cblks = 0 ; prc -> incltagtree = 0 ; prc -> numimsbstagtree = 0 ; } cbgxstart += 1 << rlvl -> cbgwidthexpn ; if ( cbgxstart >= brcbgxend ) { cbgxstart = tlcbgxstart ; cbgystart += 1 << rlvl -> cbgheightexpn ; } } } } } if ( ! ( tile -> pi = jpc_dec_pi_create ( dec , tile ) ) ) { return - 1 ; } for ( pchgno = 0 ; pchgno < jpc_pchglist_numpchgs ( tile -> cp -> pchglist ) ; ++ pchgno ) { pchg = jpc_pchg_copy ( jpc_pchglist_get ( tile -> cp -> pchglist , pchgno ) ) ; assert ( pchg ) ; jpc_pi_addpchg ( tile -> pi , pchg ) ; } jpc_pi_init ( tile -> pi ) ; return 0 ; }", jpc_tsfb_band_t bnds [ JPC_MAXBANDS  ] ; jpc_pchg_t
615,"CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ;  if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) )  return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; switch ( mode ) { case PSR_AA32_MODE_USR : case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }", ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
616,"CWE-362 void snd_timer_interrupt ( struct snd_timer * timer , unsigned long ticks_left ) { struct snd_timer_instance * ti , * ts , * tmp ; unsigned long resolution , ticks ; struct list_head * p , * ack_list_head ; unsigned long flags ; int use_tasklet = 0 ; if ( timer == NULL ) return ; spin_lock_irqsave ( & timer -> lock , flags ) ; if ( timer -> hw . c_resolution ) resolution = timer -> hw . c_resolution ( timer ) ; else resolution = timer -> hw . resolution ; list_for_each_entry_safe ( ti , tmp , & timer -> active_list_head , active_list ) { if ( ! ( ti -> flags & SNDRV_TIMER_IFLG_RUNNING ) ) continue ; ti -> pticks += ticks_left ; ti -> resolution = resolution ; if ( ti -> cticks < ticks_left ) ti -> cticks = 0 ; else ti -> cticks -= ticks_left ; if ( ti -> cticks ) continue ; if ( ti -> flags & SNDRV_TIMER_IFLG_AUTO ) { ti -> cticks = ti -> ticks ; } else { ti -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; if ( -- timer -> running )  list_del ( & ti -> active_list ) ;  } if ( ( timer -> hw . flags & SNDRV_TIMER_HW_TASKLET ) || ( ti -> flags & SNDRV_TIMER_IFLG_FAST ) ) ack_list_head = & timer -> ack_list_head ; else ack_list_head = & timer -> sack_list_head ; if ( list_empty ( & ti -> ack_list ) ) list_add_tail ( & ti -> ack_list , ack_list_head ) ; list_for_each_entry ( ts , & ti -> slave_active_head , active_list ) { ts -> pticks = ti -> pticks ; ts -> resolution = resolution ; if ( list_empty ( & ts -> ack_list ) ) list_add_tail ( & ts -> ack_list , ack_list_head ) ; } } if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) snd_timer_reschedule ( timer , timer -> sticks ) ; if ( timer -> running ) { if ( timer -> hw . flags & SNDRV_TIMER_HW_STOP ) { timer -> hw . stop ( timer ) ; timer -> flags |= SNDRV_TIMER_FLG_CHANGE ; } if ( ! ( timer -> hw . flags & SNDRV_TIMER_HW_AUTO ) || ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } else { timer -> hw . stop ( timer ) ; } while ( ! list_empty ( & timer -> ack_list_head ) ) { p = timer -> ack_list_head . next ; ti = list_entry ( p , struct snd_timer_instance , ack_list ) ; list_del_init ( p ) ; ticks = ti -> pticks ; ti -> pticks = 0 ; ti -> flags |= SNDRV_TIMER_IFLG_CALLBACK ; spin_unlock ( & timer -> lock ) ; if ( ti -> callback ) ti -> callback ( ti , resolution , ticks ) ; spin_lock ( & timer -> lock ) ; ti -> flags &= ~ SNDRV_TIMER_IFLG_CALLBACK ; } use_tasklet = ! list_empty ( & timer -> sack_list_head ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; if ( use_tasklet ) tasklet_schedule ( & timer -> task_queue ) ; }", -> running ) list_del_init  ( & ti
617,"CWE-772 chrand_ret * chrand_principal3_2_svc ( chrand3_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_randkey_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , & k , & nkeys ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_randkey_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code == KADM5_OK ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }"," ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER  ; OM_uint32 minor_stat  prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ;  free_server_handle ( handle"
618,"CWE-59 void rs_filter_graph ( RSFilter * filter ) {  g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;  GString * str = g_string_new ( ""digraphG{\\n"" ) ; rs_filter_graph_helper ( str , filter ) ; g_string_append_printf ( str , ""}\\n"" ) ;  g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ;   if ( 0 != system ( ""dot-Tpng>/tmp/rs-filter-graph.png</tmp/rs-filter-graph"" ) )  g_warning ( ""Callingdotfailed"" ) ;  if ( 0 != system ( ""gnome-open/tmp/rs-filter-graph.png"" ) )   g_warning ( ""Callinggnome-openfailed."" ) ;  g_string_free ( str , TRUE ) ; }"," filter ) ) ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line  ""}\\n"" ) ; dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename  , str ->  NULL ) ; command_line = g_strdup_printf ( ""dot-Tpng>%s<%s"" , png_filename , dot_filename ) ;  != system ( command_line  ) ) g_warning  ""Callingdotfailed"" ) ; g_free ( command_line ) ; command_line = g_strdup_printf ( ""gnome-open%s"" , png_filename ) ;  != system ( command_line  ) ) g_warning  g_warning ( ""Callinggnome-openfailed."" ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename"
619,"CWE-362 fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , ""localhost"" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } }  return res ;  cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }", ; } } cleanup :  return res ;
620,"CWE-19 static int ext2_fill_super ( struct super_block * sb , void * data , int silent ) { struct buffer_head * bh ; struct ext2_sb_info * sbi ; struct ext2_super_block * es ; struct inode * root ; unsigned long block ; unsigned long sb_block = get_sb_block ( & data ) ; unsigned long logic_sb_block ; unsigned long offset = 0 ; unsigned long def_mount_opts ; long ret = - EINVAL ; int blocksize = BLOCK_SIZE ; int db_count ; int i , j ; __le32 features ; int err ; err = - ENOMEM ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto failed ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto failed ; } sb -> s_fs_info = sbi ; sbi -> s_sb_block = sb_block ; spin_lock_init ( & sbi -> s_lock ) ; blocksize = sb_min_blocksize ( sb , BLOCK_SIZE ) ; if ( ! blocksize ) { ext2_msg ( sb , KERN_ERR , ""error:unabletosetblocksize"" ) ; goto failed_sbi ; } if ( blocksize != BLOCK_SIZE ) { logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; } else { logic_sb_block = sb_block ; } if ( ! ( bh = sb_bread ( sb , logic_sb_block ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:unabletoreadsuperblock"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT2_SUPER_MAGIC ) goto cantfind_ext2 ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; if ( def_mount_opts & EXT2_DEFM_DEBUG ) set_opt ( sbi -> s_mount_opt , DEBUG ) ; if ( def_mount_opts & EXT2_DEFM_BSDGROUPS ) set_opt ( sbi -> s_mount_opt , GRPID ) ; if ( def_mount_opts & EXT2_DEFM_UID16 ) set_opt ( sbi -> s_mount_opt , NO_UID32 ) ; # ifdef CONFIG_EXT2_FS_XATTR if ( def_mount_opts & EXT2_DEFM_XATTR_USER ) set_opt ( sbi -> s_mount_opt , XATTR_USER ) ; # endif # ifdef CONFIG_EXT2_FS_POSIX_ACL if ( def_mount_opts & EXT2_DEFM_ACL ) set_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; # endif if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_PANIC ) set_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_CONTINUE ) set_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; else set_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; set_opt ( sbi -> s_mount_opt , RESERVATION ) ; if ( ! parse_options ( ( char * ) data , sb ) ) goto failed_mount ; sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( ( EXT2_SB ( sb ) -> s_mount_opt & EXT2_MOUNT_POSIX_ACL ) ? MS_POSIXACL : 0 ) ; sb -> s_iflags |= SB_I_CGROUPWB ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV && ( EXT2_HAS_COMPAT_FEATURE ( sb , ~ 0U ) || EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ 0U ) || EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ 0U ) ) ) ext2_msg ( sb , KERN_WARNING , ""warning:featureflagssetonrev0fs,"" ""runninge2fsckisrecommended"" ) ; features = EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ EXT2_FEATURE_INCOMPAT_SUPP ) ; if ( features ) { ext2_msg ( sb , KERN_ERR , ""error:couldn\'tmountbecauseof"" ""unsupportedoptionalfeatures(%x)"" , le32_to_cpu ( features ) ) ; goto failed_mount ; } if ( ! ( sb -> s_flags & MS_RDONLY ) && ( features = EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ EXT2_FEATURE_RO_COMPAT_SUPP ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:couldn\'tmountRDWRbecauseof"" ""unsupportedoptionalfeatures(%x)"" , le32_to_cpu ( features ) ) ; goto failed_mount ; } blocksize = BLOCK_SIZE << le32_to_cpu ( sbi -> s_es -> s_log_block_size ) ; if ( sbi -> s_mount_opt & EXT2_MOUNT_DAX ) { if ( blocksize != PAGE_SIZE ) { ext2_msg ( sb , KERN_ERR , ""error:unsupportedblocksizefordax"" ) ; goto failed_mount ; } if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { ext2_msg ( sb , KERN_ERR , ""error:devicedoesnotsupportdax"" ) ; goto failed_mount ; } } if ( sb -> s_blocksize != blocksize ) { brelse ( bh ) ; if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext2_msg ( sb , KERN_ERR , ""error:badblocksize%d"" , blocksize ) ; goto failed_sbi ; } logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; bh = sb_bread ( sb , logic_sb_block ) ; if ( ! bh ) { ext2_msg ( sb , KERN_ERR , ""error:couldn\'tread"" ""superblockon2ndtry"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT2_SUPER_MAGIC ) ) { ext2_msg ( sb , KERN_ERR , ""error:magicmismatch"" ) ; goto failed_mount ; } } sb -> s_maxbytes = ext2_max_size ( sb -> s_blocksize_bits ) ; sb -> s_max_links = EXT2_LINK_MAX ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT2_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT2_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT2_GOOD_OLD_INODE_SIZE ) || ! is_power_of_2 ( sbi -> s_inode_size ) || ( sbi -> s_inode_size > blocksize ) ) { ext2_msg ( sb , KERN_ERR , ""error:unsupportedinodesize:%d"" , sbi -> s_inode_size ) ; goto failed_mount ; } } sbi -> s_frag_size = EXT2_MIN_FRAG_SIZE << le32_to_cpu ( es -> s_log_frag_size ) ; if ( sbi -> s_frag_size == 0 ) goto cantfind_ext2 ; sbi -> s_frags_per_block = sb -> s_blocksize / sbi -> s_frag_size ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_frags_per_group = le32_to_cpu ( es -> s_frags_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; if ( EXT2_INODE_SIZE ( sb ) == 0 ) goto cantfind_ext2 ; sbi -> s_inodes_per_block = sb -> s_blocksize / EXT2_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 || sbi -> s_inodes_per_group == 0 ) goto cantfind_ext2 ; sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = sb -> s_blocksize / sizeof ( struct ext2_group_desc ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT2_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT2_DESC_PER_BLOCK ( sb ) ) ; if ( sb -> s_magic != EXT2_SUPER_MAGIC ) goto cantfind_ext2 ; if ( sb -> s_blocksize != bh -> b_size ) { if ( ! silent ) ext2_msg ( sb , KERN_ERR , ""error:unsupportedblocksize"" ) ; goto failed_mount ; } if ( sb -> s_blocksize != sbi -> s_frag_size ) { ext2_msg ( sb , KERN_ERR , ""error:fragsize%lu!=blocksize%lu"" ""(notsupportedyet)"" , sbi -> s_frag_size , sb -> s_blocksize ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:#blockspergrouptoobig:%lu"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } if ( sbi -> s_frags_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:#fragmentspergrouptoobig:%lu"" , sbi -> s_frags_per_group ) ; goto failed_mount ; } if ( sbi -> s_inodes_per_group > sb -> s_blocksize * 8 ) { ext2_msg ( sb , KERN_ERR , ""error:#inodespergrouptoobig:%lu"" , sbi -> s_inodes_per_group ) ; goto failed_mount ; } if ( EXT2_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext2 ; sbi -> s_groups_count = ( ( le32_to_cpu ( es -> s_blocks_count ) - le32_to_cpu ( es -> s_first_data_block ) - 1 ) / EXT2_BLOCKS_PER_GROUP ( sb ) ) + 1 ; db_count = ( sbi -> s_groups_count + EXT2_DESC_PER_BLOCK ( sb ) - 1 ) / EXT2_DESC_PER_BLOCK ( sb ) ; sbi -> s_group_desc = kmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext2_msg ( sb , KERN_ERR , ""error:notenoughmemory"" ) ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; sbi -> s_debts = kcalloc ( sbi -> s_groups_count , sizeof ( * sbi -> s_debts ) , GFP_KERNEL ) ; if ( ! sbi -> s_debts ) { ext2_msg ( sb , KERN_ERR , ""error:notenoughmemory"" ) ; goto failed_mount_group_desc ; } for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logic_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { for ( j = 0 ; j < i ; j ++ ) brelse ( sbi -> s_group_desc [ j ] ) ; ext2_msg ( sb , KERN_ERR , ""error:unabletoreadgroupdescriptors"" ) ; goto failed_mount_group_desc ; } } if ( ! ext2_check_descriptors ( sb ) ) { ext2_msg ( sb , KERN_ERR , ""groupdescriptorscorrupted"" ) ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; spin_lock_init ( & sbi -> s_rsv_window_lock ) ; sbi -> s_rsv_window_root = RB_ROOT ; sbi -> s_rsv_window_head . rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; sbi -> s_rsv_window_head . rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; sbi -> s_rsv_window_head . rsv_alloc_hit = 0 ; sbi -> s_rsv_window_head . rsv_goal_size = 0 ; ext2_rsv_window_add ( sb , & sbi -> s_rsv_window_head ) ; err = percpu_counter_init ( & sbi -> s_freeblocks_counter , ext2_count_free_blocks ( sb ) , GFP_KERNEL ) ; if ( ! err ) { err = percpu_counter_init ( & sbi -> s_freeinodes_counter , ext2_count_free_inodes ( sb ) , GFP_KERNEL ) ; } if ( ! err ) { err = percpu_counter_init ( & sbi -> s_dirs_counter , ext2_count_dirs ( sb ) , GFP_KERNEL ) ; } if ( err ) { ext2_msg ( sb , KERN_ERR , ""error:insufficientmemory"" ) ; goto failed_mount3 ; }  sb -> s_op = & ext2_sops ;  sb -> s_export_op = & ext2_export_ops ; sb -> s_xattr = ext2_xattr_handlers ; # ifdef CONFIG_QUOTA sb -> dq_op = & dquot_operations ; sb -> s_qcop = & dquot_quotactl_ops ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP ; # endif root = ext2_iget ( sb , EXT2_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ret = PTR_ERR ( root ) ; goto failed_mount3 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { iput ( root ) ; ext2_msg ( sb , KERN_ERR , ""error:corruptrootinode,rune2fsck"" ) ; goto failed_mount3 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext2_msg ( sb , KERN_ERR , ""error:getrootinodefailed"" ) ; ret = - ENOMEM ; goto failed_mount3 ; } if ( EXT2_HAS_COMPAT_FEATURE ( sb , EXT3_FEATURE_COMPAT_HAS_JOURNAL ) ) ext2_msg ( sb , KERN_WARNING , ""warning:mountingext3filesystemasext2"" ) ; if ( ext2_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; ext2_write_super ( sb ) ; return 0 ; cantfind_ext2 : if ( ! silent ) ext2_msg ( sb , KERN_ERR , ""error:can\'tfindanext2filesystemondev%s."" , sb -> s_id ) ; goto failed_mount ; failed_mount3 :  percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;  percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; failed_mount_group_desc : kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; failed_mount : brelse ( bh ) ; failed_sbi : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; failed : return ret ; }"," failed_mount3 ; } # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , ""Failedtocreateanmb_cache"" ) ; goto failed_mount3 ; } # endif  ; failed_mount3 : if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;"
621,"CWE-17 static int __mkroute_input ( struct sk_buff * skb , const struct fib_result * res , struct in_device * in_dev , __be32 daddr , __be32 saddr , u32 tos ) { struct fib_nh_exception * fnhe ; struct rtable * rth ; int err ; struct in_device * out_dev ; unsigned int flags = 0 ; bool do_cache ; u32 itag = 0 ; out_dev = __in_dev_get_rcu ( FIB_RES_DEV ( * res ) ) ; if ( out_dev == NULL ) { net_crit_ratelimited ( ""Buginip_route_input_slow().Pleasereport.\\n"" ) ; return - EINVAL ; } err = fib_validate_source ( skb , saddr , daddr , tos , FIB_RES_OIF ( * res ) , in_dev -> dev , in_dev , & itag ) ; if ( err < 0 ) { ip_handle_martian_source ( in_dev -> dev , in_dev , skb , daddr , saddr ) ; goto cleanup ; } do_cache = res -> fi && ! itag ; if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) &&  ( IN_DEV_SHARED_MEDIA ( out_dev ) ||   inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) {  flags |= RTCF_DOREDIRECT ; do_cache = false ; } if ( skb -> protocol != htons ( ETH_P_IP ) ) { if ( out_dev == in_dev && IN_DEV_PROXY_ARP_PVLAN ( in_dev ) == 0 ) { err = - EINVAL ; goto cleanup ; } } fnhe = find_exception ( & FIB_RES_NH ( * res ) , daddr ) ; if ( do_cache ) { if ( fnhe != NULL ) rth = rcu_dereference ( fnhe -> fnhe_rth_input ) ; else rth = rcu_dereference ( FIB_RES_NH ( * res ) . nh_rth_input ) ; if ( rt_cache_valid ( rth ) ) { skb_dst_set_noref ( skb , & rth -> dst ) ; goto out ; } } rth = rt_dst_alloc ( out_dev -> dev , IN_DEV_CONF_GET ( in_dev , NOPOLICY ) , IN_DEV_CONF_GET ( out_dev , NOXFRM ) , do_cache ) ; if ( ! rth ) { err = - ENOBUFS ; goto cleanup ; } rth -> rt_genid = rt_genid_ipv4 ( dev_net ( rth -> dst . dev ) ) ; rth -> rt_flags = flags ; rth -> rt_type = res -> type ; rth -> rt_is_input = 1 ; rth -> rt_iif = 0 ; rth -> rt_pmtu = 0 ; rth -> rt_gateway = 0 ; rth -> rt_uses_gateway = 0 ; INIT_LIST_HEAD ( & rth -> rt_uncached ) ; RT_CACHE_STAT_INC ( in_slow_tot ) ; rth -> dst . input = ip_forward ; rth -> dst . output = ip_output ; rt_set_nexthop ( rth , daddr , res , fnhe , res -> fi , res -> type , itag ) ; skb_dst_set ( skb , & rth -> dst ) ; out : err = 0 ; cleanup : return err ; }", out_dev ) && skb -> protocol == htons ( ETH_P_IP ) &&  ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ;  if ( skb
622,"CWE-20 static int keyring_search_iterator ( const void * object , void * iterator_data ) { struct keyring_search_context * ctx = iterator_data ; const struct key * key = keyring_ptr_to_key ( object ) ;  unsigned long kflags = key -> flags ;  kenter ( ""{%d}"" , key -> serial ) ; if ( key -> type != ctx -> index_key . type ) { kleave ( ""=0[!type]"" ) ; return 0 ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { if ( kflags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) ) ) { ctx -> result = ERR_PTR ( - EKEYREVOKED ) ; kleave ( ""=%d[invrev]"" , ctx -> skipped_ret ) ; goto skipped ; } if ( key -> expiry && ctx -> now . tv_sec >= key -> expiry ) { if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( - EKEYEXPIRED ) ; kleave ( ""=%d[expire]"" , ctx -> skipped_ret ) ; goto skipped ; } } if ( ! ctx -> match_data . cmp ( key , & ctx -> match_data ) ) { kleave ( ""=0[!match]"" ) ; return 0 ; } if ( ! ( ctx -> flags & KEYRING_SEARCH_NO_CHECK_PERM ) && key_task_permission ( make_key_ref ( key , ctx -> possessed ) , ctx -> cred , KEY_NEED_SEARCH ) < 0 ) { ctx -> result = ERR_PTR ( - EACCES ) ; kleave ( ""=%d[!perm]"" , ctx -> skipped_ret ) ; goto skipped ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) {  if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) {  smp_rmb ( ) ;  ctx -> result = ERR_PTR ( key -> reject_error ) ;  kleave ( ""=%d[neg]"" , ctx -> skipped_ret ) ; goto skipped ; } } ctx -> result = make_key_ref ( key , ctx -> possessed ) ; kleave ( ""=1[found]"" ) ; return 1 ; skipped : return ctx -> skipped_ret ; }", long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state )  ; kenter (  { if ( state < 0 ) {  ctx -> result  = ERR_PTR ( state  ) ; kleave
623,"CWE-476 av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) {  if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO )  c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }", { if ( c -> mpeg4_studio_profile  ) c ->
624,"CWE-787 opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failedtoopen%sforreading!!\\n"" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; }  subsampling_dx = parameters -> subsampling_dx ;  subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) subsampling_dy ; cmptparm [ i ] . w = image_width ; cmptparm [ i ] . h = image_height ; } image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm [ 0 ] , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = ! image -> x0 ? ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 : image -> x0 + ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 ; image -> y1 = ! image -> y0 ? ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 : image -> y0 + ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 ; for ( y = 0 ; y < image_height ; y ++ ) { int index ; if ( flip_image ) { index = ( int ) ( ( image_height - y - 1 ) * image_width ) ; } else { index = ( int ) ( y * image_width ) ; } if ( numcomps == 3 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; index ++ ; } } else if ( numcomps == 4 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b , a ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & a , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; image -> comps [ 3 ] . data [ index ] = a ; index ++ ; } } else { fprintf ( stderr , ""Currentlyunsupportedbitdepth:%s\\n"" , filename ) ; } } fclose ( f ) ; return image ; }"," OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }"
625,"CWE-000 static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; int i ; int retval = - ENOMEM ; dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; if ( dev == NULL ) { dev_err ( & interface -> dev , ""Outofmemory\\n"" ) ; return retval ; } mutex_init ( & dev -> mutex ) ; atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ;  dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ;  for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( endpoint ) ) dev -> int_in_endpoint = endpoint ; if ( usb_endpoint_is_int_out ( endpoint ) ) dev -> int_out_endpoint = endpoint ; } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) && ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) ) dev -> report_size = 7 ; dev -> int_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> int_in_urb ) { dev_err ( & interface -> dev , ""Couldn\'tallocateinterrupt_in_urb\\n"" ) ; goto error ; } dev -> int_in_buffer = kmalloc ( dev -> report_size , GFP_KERNEL ) ; if ( ! dev -> int_in_buffer ) { dev_err ( & interface -> dev , ""Couldn\'tallocateint_in_buffer\\n"" ) ; goto error ; } usb_fill_int_urb ( dev -> int_in_urb , dev -> udev , usb_rcvintpipe ( dev -> udev , dev -> int_in_endpoint -> bEndpointAddress ) , dev -> int_in_buffer , dev -> report_size , iowarrior_callback , dev , dev -> int_in_endpoint -> bInterval ) ; dev -> read_queue = kmalloc ( ( ( dev -> report_size + 1 ) * MAX_INTERRUPT_BUFFER ) , GFP_KERNEL ) ; if ( ! dev -> read_queue ) { dev_err ( & interface -> dev , ""Couldn\'tallocateread_queue\\n"" ) ; goto error ; } memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; usb_string ( udev , udev -> descriptor . iSerialNumber , dev -> chip_serial , sizeof ( dev -> chip_serial ) ) ; if ( strlen ( dev -> chip_serial ) != 8 ) memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; if ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) { usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0A , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; } dev -> present = 1 ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & iowarrior_class ) ; if ( retval ) { dev_err ( & interface -> dev , ""Notabletogetaminorforthisdevice.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""IOWarriorproduct=0x%x,serial=%sinterface=%d"" ""nowattachedtoiowarrior%d\\n"" , dev -> product_id , dev -> chip_serial , iface_desc -> desc . bInterfaceNumber , dev -> minor - IOWARRIOR_MINOR_BASE ) ; return retval ; error : iowarrior_delete ( dev ) ; return retval ; }"," idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalidnumberofendpoints\\n"" ) ; retval = - EINVAL ; goto error ; }"
626,"CWE-362 int __fsnotify_parent ( const struct path * path , struct dentry * dentry , __u32 mask ) { struct dentry * parent ; struct inode * p_inode ; int ret = 0 ; if ( ! dentry ) dentry = path -> dentry ; if ( ! ( dentry -> d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED ) ) return 0 ; parent = dget_parent ( dentry ) ; p_inode = parent -> d_inode ; if ( unlikely ( ! fsnotify_inode_watches_children ( p_inode ) ) ) __fsnotify_update_child_dentry_flags ( p_inode ) ; else if ( p_inode -> i_fsnotify_mask & mask ) {  mask |= FS_EVENT_ON_CHILD ;   if ( path )  ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH ,  dentry -> d_name . name , 0 ) ;  else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE ,  dentry -> d_name . name , 0 ) ;  } dput ( parent ) ; return ret ; }"," mask ) { struct name_snapshot name ;  |= FS_EVENT_ON_CHILD ; take_dentry_name_snapshot ( & name , dentry ) ;  , FSNOTIFY_EVENT_PATH , name  . name ,  , FSNOTIFY_EVENT_INODE , name  . name ,  name , 0 ) ; release_dentry_name_snapshot ( & name"
627,"CWE-264 static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP )  return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ;  if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }", SOL_PPPOL2TP ) return - EINVAL  ; if (
628,"CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ;  memcpy ( data -> strval , * bnode , size ) ;  data -> strval [ size ] = '\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }"," ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:Couldnotallocate%"" PRIu64 ""bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }"
629,"CWE-362 static int  mptctl_hp_targetinfo ( unsigned long arg )  { hp_target_info_t __user * uarg = ( void __user * ) arg ; SCSIDevicePage0_t * pg0_alloc ; SCSIDevicePage3_t * pg3_alloc ;  MPT_ADAPTER * ioc ;  MPT_SCSI_HOST * hd = NULL ;  hp_target_info_t karg ;  int iocnum ; int data_sz ; dma_addr_t page_dma ; CONFIGPARMS cfg ; ConfigPageHeader_t hdr ; int tmp , np , rc = 0 ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_target_info_t ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_hp_targetinfo-"" ""Unabletoreadinhp_host_targetinfostruct@%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; }  if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||   ( ioc == NULL ) ) {  printk ( KERN_DEBUG MYNAM ""%s::mptctl_hp_targetinfo()@%d-ioc%dnotfound!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ;  }  if ( karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_hp_targetinfocalled.\\n"" , ioc -> name ) ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) return 0 ; if ( ( ioc -> spi_data . sdp0length == 0 ) || ( ioc -> sh == NULL ) ) return 0 ; if ( ioc -> sh -> host_no != karg . hdr . host ) return - ENODEV ; data_sz = ioc -> spi_data . sdp0length * 4 ; pg0_alloc = ( SCSIDevicePage0_t * ) pci_alloc_consistent ( ioc -> pcidev , data_sz , & page_dma ) ; if ( pg0_alloc ) { hdr . PageVersion = ioc -> spi_data . sdp0version ; hdr . PageLength = data_sz ; hdr . PageNumber = 0 ; hdr . PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE ; cfg . cfghdr . hdr = & hdr ; cfg . action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT ; cfg . dir = 0 ; cfg . timeout = 0 ; cfg . physAddr = page_dma ; cfg . pageAddr = ( karg . hdr . channel << 8 ) | karg . hdr . id ; if ( ( rc = mpt_config ( ioc , & cfg ) ) == 0 ) { np = le32_to_cpu ( pg0_alloc -> NegotiatedParameters ) ; karg . negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ? HP_BUS_WIDTH_16 : HP_BUS_WIDTH_8 ; if ( np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK ) { tmp = ( np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK ) >> 8 ; if ( tmp < 0x09 ) karg . negotiated_speed = HP_DEV_SPEED_ULTRA320 ; else if ( tmp <= 0x09 ) karg . negotiated_speed = HP_DEV_SPEED_ULTRA160 ; else if ( tmp <= 0x0A ) karg . negotiated_speed = HP_DEV_SPEED_ULTRA2 ; else if ( tmp <= 0x0C ) karg . negotiated_speed = HP_DEV_SPEED_ULTRA ; else if ( tmp <= 0x25 ) karg . negotiated_speed = HP_DEV_SPEED_FAST ; else karg . negotiated_speed = HP_DEV_SPEED_ASYNC ; } else karg . negotiated_speed = HP_DEV_SPEED_ASYNC ; } pci_free_consistent ( ioc -> pcidev , data_sz , ( u8 * ) pg0_alloc , page_dma ) ; } karg . message_rejects = - 1 ; karg . phase_errors = - 1 ; karg . parity_errors = - 1 ; karg . select_timeouts = - 1 ; hdr . PageVersion = 0 ; hdr . PageLength = 0 ; hdr . PageNumber = 3 ; hdr . PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE ; cfg . cfghdr . hdr = & hdr ; cfg . action = MPI_CONFIG_ACTION_PAGE_HEADER ; cfg . dir = 0 ; cfg . timeout = 0 ; cfg . physAddr = - 1 ; if ( ( mpt_config ( ioc , & cfg ) == 0 ) && ( cfg . cfghdr . hdr -> PageLength > 0 ) ) { cfg . action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT ; data_sz = ( int ) cfg . cfghdr . hdr -> PageLength * 4 ; pg3_alloc = ( SCSIDevicePage3_t * ) pci_alloc_consistent ( ioc -> pcidev , data_sz , & page_dma ) ; if ( pg3_alloc ) { cfg . physAddr = page_dma ; cfg . pageAddr = ( karg . hdr . channel << 8 ) | karg . hdr . id ; if ( ( rc = mpt_config ( ioc , & cfg ) ) == 0 ) { karg . message_rejects = ( u32 ) le16_to_cpu ( pg3_alloc -> MsgRejectCount ) ; karg . phase_errors = ( u32 ) le16_to_cpu ( pg3_alloc -> PhaseErrorCount ) ; karg . parity_errors = ( u32 ) le16_to_cpu ( pg3_alloc -> ParityErrorCount ) ; } pci_free_consistent ( ioc -> pcidev , data_sz , ( u8 * ) pg3_alloc , page_dma ) ; } } hd = shost_priv ( ioc -> sh ) ; if ( hd != NULL ) karg . select_timeouts = hd -> sel_timeout [ karg . hdr . id ] ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( hp_target_info_t ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_hp_target_info-"" ""Unabletowriteoutmpt_ioctl_targetinfostruct@%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }"," int mptctl_hp_targetinfo ( MPT_ADAPTER * ioc ,  * pg3_alloc ;  MPT_SCSI_HOST * hd  ; hp_target_info_t karg  ; int data_sz  } if ( karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_hp_targetinfocalled.\\n"" , ioc -> name ) ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) return 0 ; if ( ( ioc -> spi_data . sdp0length == 0 ) || ( ioc -> sh  == NULL )  NULL ) ) return 0 ; if ( ioc -> sh -> host_no != karg . hdr . host )  return - ENODEV  - ENODEV ;  data_sz = ioc"
630,"CWE-252 void vsyslog ( pri , fmt , ap ) int pri ; register const char * fmt ; va_list ap ; { struct tm now_tm ; time_t now ; int fd ; FILE * f ; char * buf = 0 ; size_t bufsize = 0 ; size_t prioff , msgoff ; struct sigaction action , oldaction ; struct sigaction * oldaction_ptr = NULL ; int sigpipe ; int saved_errno = errno ; # define INTERNALLOG LOG_ERR | LOG_CONS | LOG_PERROR | LOG_PID if ( pri & ~ ( LOG_PRIMASK | LOG_FACMASK ) ) { syslog ( INTERNALLOG , ""syslog:unknownfacility/priority:%x"" , pri ) ; pri &= LOG_PRIMASK | LOG_FACMASK ; } if ( ( LOG_MASK ( LOG_PRI ( pri ) ) & LogMask ) == 0 ) return ; if ( ( pri & LOG_FACMASK ) == 0 ) pri |= LogFacility ; f = open_memstream ( & buf , & bufsize ) ; prioff = fprintf ( f , ""<%d>"" , pri ) ; ( void ) time ( & now ) ; # ifdef USE_IN_LIBIO f -> _IO_write_ptr += strftime ( f -> _IO_write_ptr , f -> _IO_write_end - f -> _IO_write_ptr , ""%h%e%T"" , __localtime_r ( & now , & now_tm ) ) ; # else f -> __bufp += strftime ( f -> __bufp , f -> __put_limit - f -> __bufp , ""%h%e%T"" , __localtime_r ( & now , & now_tm ) ) ; # endif msgoff = ftell ( f ) ; if ( LogTag == NULL ) LogTag = __progname ; if ( LogTag != NULL ) fputs_unlocked ( LogTag , f ) ; if ( LogStat & LOG_PID ) fprintf ( f , ""[%d]"" , __getpid ( ) ) ; if ( LogTag != NULL ) putc_unlocked ( ':' , f ) , putc_unlocked ( '' , f ) ; __set_errno ( saved_errno ) ; vfprintf ( f , fmt , ap ) ; fclose ( f ) ; if ( LogStat & LOG_PERROR ) { struct iovec iov [ 2 ] ; register struct iovec * v = iov ; v -> iov_base = buf + msgoff ; v -> iov_len = bufsize - msgoff ;  ++ v ;  v -> iov_base = ( char * ) ""\\n"" ; v -> iov_len = 1 ;  ( void ) __writev ( STDERR_FILENO , iov , 2 ) ;  } __libc_cleanup_region_start ( ( void ( * ) ( void * ) ) cancel_handler , & oldaction_ptr ) ; __libc_lock_lock ( syslog_lock ) ; memset ( & action , 0 , sizeof ( action ) ) ; action . sa_handler = sigpipe_handler ; sigemptyset ( & action . sa_mask ) ; sigpipe = __sigaction ( SIGPIPE , & action , & oldaction ) ; if ( sigpipe == 0 ) oldaction_ptr = & oldaction ; if ( ! connected ) openlog_internal ( LogTag , LogStat | LOG_NDELAY , 0 ) ; if ( LogType == SOCK_STREAM ) ++ bufsize ; if ( ! connected || __send ( LogFile , buf , bufsize , 0 ) < 0 ) { closelog_internal ( ) ; if ( LogStat & LOG_CONS && ( fd = __open ( _PATH_CONSOLE , O_WRONLY | O_NOCTTY , 0 ) ) >= 0 ) { dprintf ( fd , ""%s\\r\\n"" , buf + msgoff ) ; ( void ) __close ( fd ) ; } } if ( sigpipe == 0 ) __sigaction ( SIGPIPE , & oldaction , ( struct sigaction * ) NULL ) ; __libc_cleanup_region_end ( 0 ) ; __libc_lock_unlock ( syslog_lock ) ; free ( buf ) ; }"," - msgoff ; if ( buf [ bufsize - 1 ] != '\\n' ) {  = 1 ; }  , iov , v - iov + 1  ) ; }"
631,"CWE-119 void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; static BaseType_t xHeapHasBeenInitialised = pdFALSE ; void * pvReturn = NULL ; vTaskSuspendAll ( ) ; { if ( xHeapHasBeenInitialised == pdFALSE ) { prvHeapInit ( ) ; xHeapHasBeenInitialised = pdTRUE ; }  if ( xWantedSize > 0 )  { xWantedSize += heapSTRUCT_SIZE ;  if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )  { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;  }  }  if ( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )  { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != & xEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + heapSTRUCT_SIZE ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; } } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; # if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } } # endif return pvReturn ; }", } if ( (  > 0 ) && ( ( xWantedSize + heapSTRUCT_SIZE ) > xWantedSize ) )  ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize  & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize  ) { xWantedSize  ) ) ; configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { xWantedSize = 0 ; } } else { xWantedSize = 0 ;  } if (  && ( xWantedSize <= xFreeBytesRemaining  ) ) {
632,"CWE-125 static int str_lower_case_match ( OnigEncoding enc , int case_fold_flag , const UChar * t , const UChar * tend , const UChar * p , const UChar * end ) { int lowlen ; UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; while ( t < tend ) { lowlen = ONIGENC_MBC_CASE_FOLD ( enc , case_fold_flag , & p , end , lowbuf ) ; q = lowbuf ; while ( lowlen > 0 ) {  if ( * t ++ != * q ++ ) return 0 ;  lowlen -- ; } } return 1 ; }", { if ( t >= tend ) return 0 ; if (
633,"CWE-787  static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ; if ( context -> ChromaSubsamplingLevel > 0 ) { nsc_encode_subsampling_sse2 ( context ) ; }  } ",   static BOOL  nsc_encode_sse2 ( NSC_CONTEXT  ) ; } return TRUE ;
634,"CWE-125 static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) {  static char temp [ NFSX_V3FHMAX + 1 ] ;   strncpy ( temp , sfsname , NFSX_V3FHMAX ) ;   temp [ sizeof ( temp ) - 1 ] = '\\0' ;  spacep = strchr ( temp , '' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""fh%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""fh%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }"," sfsname ) {  char temp [  1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ;  , sfsname , stringlen  ) ; temp  ; temp [ stringlen  ] = '\\0'"
635,"CWE-284 static int process_cmd_sock ( int h ) { sock_cmd_t cmd = { - 1 , 0 , 0 , 0 , 0 } ; int fd = ts [ h ] . cmd_fdr ;  if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) )  { APPL_TRACE_ERROR ( ""recvcmderrno:%d"" , errno ) ; return FALSE ; } APPL_TRACE_DEBUG ( ""cmd.id:%d"" , cmd . id ) ; switch ( cmd . id ) { case CMD_ADD_FD : add_poll ( h , cmd . fd , cmd . type , cmd . flags , cmd . user_id ) ; break ; case CMD_REMOVE_FD : for ( int i = 1 ; i < MAX_POLL ; ++ i ) { poll_slot_t * poll_slot = & ts [ h ] . ps [ i ] ; if ( poll_slot -> pfd . fd == cmd . fd ) { remove_poll ( h , poll_slot , poll_slot -> flags ) ; break ; } } close ( cmd . fd ) ; break ; case CMD_WAKEUP : break ; case CMD_USER_PRIVATE : asrt ( ts [ h ] . cmd_callback ) ; if ( ts [ h ] . cmd_callback ) ts [ h ] . cmd_callback ( fd , cmd . type , cmd . flags , cmd . user_id ) ; break ; case CMD_EXIT : return FALSE ; default : APPL_TRACE_DEBUG ( ""unknowncmd:%d"" , cmd . id ) ; break ; } return TRUE ; }"," ; if ( TEMP_FAILURE_RETRY (  ) , MSG_WAITALL )"
636,"CWE-119 static int journal_unmap_buffer ( journal_t * journal , struct buffer_head * bh ) { transaction_t * transaction ; struct journal_head * jh ; int may_free = 1 ; int ret ; BUFFER_TRACE ( bh , ""entry"" ) ; if ( ! buffer_jbd ( bh ) ) goto zap_buffer_unlocked ; write_lock ( & journal -> j_state_lock ) ; jbd_lock_bh_state ( bh ) ; spin_lock ( & journal -> j_list_lock ) ; jh = jbd2_journal_grab_journal_head ( bh ) ; if ( ! jh ) goto zap_buffer_no_jh ; transaction = jh -> b_transaction ; if ( transaction == NULL ) { if ( ! jh -> b_cp_transaction ) { JBUFFER_TRACE ( jh , ""notonanytransaction:zap"" ) ; goto zap_buffer ; } if ( ! buffer_dirty ( bh ) ) { goto zap_buffer ; } if ( journal -> j_running_transaction ) { JBUFFER_TRACE ( jh , ""checkpointed:addtoBJ_Forget"" ) ; ret = __dispose_buffer ( jh , journal -> j_running_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { if ( journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , ""givetocommittingtrans"" ) ; ret = __dispose_buffer ( jh , journal -> j_committing_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { clear_buffer_jbddirty ( bh ) ; goto zap_buffer ; } } } else if ( transaction == journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , ""oncommittingtransaction"" ) ; set_buffer_freed ( bh ) ; if ( journal -> j_running_transaction && buffer_jbddirty ( bh ) ) jh -> b_next_transaction = journal -> j_running_transaction ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return 0 ; } else { J_ASSERT_JH ( jh , transaction == journal -> j_running_transaction ) ; JBUFFER_TRACE ( jh , ""onrunningtransaction"" ) ; may_free = __dispose_buffer ( jh , transaction ) ; } zap_buffer : jbd2_journal_put_journal_head ( jh ) ; zap_buffer_no_jh : spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; zap_buffer_unlocked : clear_buffer_dirty ( bh ) ; J_ASSERT_BH ( bh , ! buffer_jbddirty ( bh ) ) ; clear_buffer_mapped ( bh ) ; clear_buffer_req ( bh ) ; clear_buffer_new ( bh ) ;  bh -> b_bdev = NULL ;  return may_free ; }", bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
637,"CWE-190 static int jpc_ppm_putparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * out ) { jpc_ppm_t * ppm = & ms -> parms . ppm ; cstate = 0 ;  if ( JAS_CAST ( uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) {  return - 1 ; } return 0 ; }"," ( JAS_CAST ( jas_uint  , jas_stream_write ("
638,"CWE-119 interval * PGTYPESinterval_from_asc ( char * str , char * * endptr ) { interval * result = NULL ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; tm -> tm_year = 0 ; tm -> tm_mon = 0 ; tm -> tm_mday = 0 ; tm -> tm_hour = 0 ; tm -> tm_min = 0 ; tm -> tm_sec = 0 ; fsec = 0 ;  if ( strlen ( str ) >= sizeof ( lowstr ) )  { errno = PGTYPES_INTVL_BAD_INTERVAL ;  return NULL ;  } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ;  return NULL ;  } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; }  if ( tm2interval ( tm , fsec , result ) != 0 )  { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } errno = 0 ; return result ; }"," ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA  ) { errno  = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0  ) { errno  = PGTYPES_INTVL_BAD_INTERVAL ;  free ( result  NULL ; }  errno = 0"
639,"CWE-125 stmt_ty  AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncWith_kind ; p -> v . AsyncWith . items = items ; p -> v . AsyncWith . body = body ;  p -> lineno = lineno ;  p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }"," * body , string type_comment ,  ; p -> v . AsyncWith . type_comment = type_comment ; p ->"
640,"CWE-416 static int xfrm_dump_policy ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net * net = sock_net ( skb -> sk ) ;  struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;   struct xfrm_dump_info info ;  BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ; info . in_skb = cb -> skb ; info . out_skb = skb ; info . nlmsg_seq = cb -> nlh -> nlmsg_seq ; info . nlmsg_flags = NLM_F_MULTI ;  if ( ! cb -> args [ 0 ] ) {  cb -> args [ 0 ] = 1 ; xfrm_policy_walk_init ( walk , XFRM_POLICY_TYPE_ANY ) ; } ( void ) xfrm_policy_walk ( net , walk , dump_one_policy , & info ) ; return skb -> len ; }", xfrm_policy_walk * )  cb -> args  cb -> args  ; struct xfrm_dump_info  struct xfrm_dump_info info  ; info .  = NLM_F_MULTI ;  ( void )
641,"CWE-284 static my_bool get_one_option ( int optid , const struct my_option * opt , char * argument ) { my_bool add_option = TRUE ; switch ( optid ) { case '?' : printf ( ""%sVer%sDistrib%s,for%s(%s)\\n"" , my_progname , VER , MYSQL_SERVER_VERSION , SYSTEM_TYPE , MACHINE_TYPE ) ; puts ( ORACLE_WELCOME_COPYRIGHT_NOTICE ( ""2000"" ) ) ; puts ( ""MySQLutilityforupgradingdatabasestonewMySQLversions.\\n"" ) ; my_print_help ( my_long_options ) ; exit ( 0 ) ; break ; case '#' : DBUG_PUSH ( argument ? argument : default_dbug_option ) ; add_option = FALSE ; debug_check_flag = 1 ; break ; case 'p' : if ( argument == disabled_my_option ) argument = ( char * ) """" ; tty_password = 1 ; add_option = FALSE ; if ( argument ) { add_one_option ( & ds_args , opt , argument ) ; while ( * argument ) * argument ++ = 'x' ; tty_password = 0 ; } break ; case 't' : my_stpnmov ( opt_tmpdir , argument , sizeof ( opt_tmpdir ) ) ; add_option = FALSE ; break ; case 'k' : case 'v' : case 'f' : case 's' : case OPT_WRITE_BINLOG : add_option = FALSE ; break ;  case 'h' :  case 'W' : case 'P' : case 'S' : case OPT_MYSQL_PROTOCOL : case OPT_SHARED_MEMORY_BASE_NAME : case OPT_PLUGIN_DIR : case OPT_DEFAULT_AUTH : add_one_option ( & conn_args , opt , argument ) ; break ; } if ( add_option ) { add_one_option ( & ds_args , opt , argument ) ; } return 0 ; }", ; break ; # include < sslopt - case . h >
642,"CWE-119 ssize_t cdf_read_sector ( const cdf_info_t * info , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) {  assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ;   return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) ,  ( ( char * ) buf ) + offs , len ) ; }"," id ) { size_t ss =  CDF_SEC_SIZE ( h  ( h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss  ( off_t ) pos ,  ( ( char"
643,"CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ;  next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ;  if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ;  calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ;  al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }"," . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ;  ( ip , ( len > max_chunk_size ) ? max_chunk_size : len ,  & max_bytes ,"
644,"CWE-119 static int key_verify ( pam_handle_t * pamh , int flags , PKCS11_KEY * authkey ) { int ok = 0 ; unsigned char challenge [ 30 ] ;  unsigned char signature [ 256 ] ;   unsigned int siglen = sizeof signature ;  const EVP_MD * md = EVP_sha1 ( ) ; EVP_MD_CTX * md_ctx = EVP_MD_CTX_new ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ;  if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {  goto err ; } if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md || ! EVP_SignInit ( md_ctx , md ) || ! EVP_SignUpdate ( md_ctx , challenge , sizeof challenge ) || ! EVP_SignFinal ( md_ctx , signature , & siglen , privkey ) || ! EVP_MD_CTX_reset ( md_ctx ) || ! EVP_VerifyInit ( md_ctx , md ) || ! EVP_VerifyUpdate ( md_ctx , challenge , sizeof challenge ) || 1 != EVP_VerifyFinal ( md_ctx , signature , siglen , pubkey ) ) { pam_syslog ( pamh , LOG_DEBUG , ""Errorverifyingkey:%s\\n"" , ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags , pamh , PAM_ERROR_MSG , NULL , _ ( ""Errorverifyingkey"" ) ) ; goto err ; } ok = 1 ;  err :  if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL != privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL != md_ctx ) { EVP_MD_CTX_free ( md_ctx ) ; } return ok ; }", ; unsigned char * signature = NULL  ; unsigned int  unsigned int siglen  ; const EVP_MD  ; if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if (  ; err : free ( signature ) ;
645,"CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ;  atomic_dec ( & user -> inotify_devs ) ;  out_free_uid : free_uid ( user ) ; return ret ; }", return ret ; fsnotify_put_group ( group ) ;
646,CWE-416 static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ;  put_device ( & dev -> dev ) ;  return 0 ; }, -> device_data ; cancel_autoload_drivers ( ) ;
647,"CWE-476 static void srpt_handle_tsk_mgmt ( struct srpt_rdma_ch * ch , struct srpt_recv_ioctx * recv_ioctx , struct srpt_send_ioctx * send_ioctx ) { struct srp_tsk_mgmt * srp_tsk ; struct se_cmd * cmd ; struct se_session * sess = ch -> sess ; uint64_t unpacked_lun ;  uint32_t tag = 0 ;  int tcm_tmr ; int rc ; BUG_ON ( ! send_ioctx ) ; srp_tsk = recv_ioctx -> ioctx . buf ; cmd = & send_ioctx -> cmd ; pr_debug ( ""recvtsk_mgmtfn%dfortask_tag%lldandcmdtag%lld"" ""cm_id%psess%p\\n"" , srp_tsk -> tsk_mgmt_func , srp_tsk -> task_tag , srp_tsk -> tag , ch -> cm_id , ch -> sess ) ; srpt_set_cmd_state ( send_ioctx , SRPT_STATE_MGMT ) ; send_ioctx -> cmd . tag = srp_tsk -> tag ; tcm_tmr = srp_tmr_to_tcm ( srp_tsk -> tsk_mgmt_func ) ;  if ( tcm_tmr < 0 ) {  send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ; goto fail ; } unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) {  rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ;  if ( rc < 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_DOES_NOT_EXIST ; goto fail ; } tag = srp_tsk -> task_tag ; } rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ; if ( rc != 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_FUNCTION_REJECTED ; goto fail ; } return ; fail : transport_send_check_condition_and_sense ( cmd , 0 , 0 ) ; }"," uint64_t unpacked_lun ;  int tcm_tmr ;  tsk_mgmt_func ) ; unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL  , srp_tsk ->  srp_tsk -> task_tag  , TARGET_SCF_ACK_KREF )"
648,"CWE-78 static char * __filterQuotedShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { switch ( * arg ) { case '' : case '=' :  case '\\r' :  case '\\n' : break ; default : * b ++ = * arg ; break ; } arg ++ ; } * b = 0 ; return a ; }"," '=' : case \'""\' : case '\\\\' : case"
649,CWE-59 void w3m_exit ( int i ) { # ifdef USE_MIGEMO init_migemo ( ) ; # endif stopDownload ( ) ; deleteFiles ( ) ; # ifdef USE_SSL free_ssl_ctx ( ) ; # endif disconnectFTP ( ) ; # ifdef USE_NNTP disconnectNews ( ) ; # endif # ifdef __MINGW32_VERSION WSACleanup ( ) ; # endif  exit ( i ) ;  }," ; # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , ""Can\'tremovetemporarydirectory(%s)!\\n"" , tmp_dir ) ; exit ( 1 ) ; } # endif"
650,"CWE-190 static int vfio_msi_enable ( struct vfio_pci_device * vdev , int nvec , bool msix ) { struct pci_dev * pdev = vdev -> pdev ; unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI ; int ret ; if ( ! is_irq_none ( vdev ) ) return - EINVAL ;  vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;  if ( ! vdev -> ctx ) return - ENOMEM ; ret = pci_alloc_irq_vectors ( pdev , 1 , nvec , flag ) ; if ( ret < nvec ) { if ( ret > 0 ) pci_free_irq_vectors ( pdev ) ; kfree ( vdev -> ctx ) ; return ret ; } vdev -> num_ctx = nvec ; vdev -> irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX ; if ( ! msix ) { vdev -> msi_qmax = fls ( nvec * 2 - 1 ) - 1 ; } return 0 ; }"," -> ctx = kcalloc ( nvec ,  sizeof ( struct"
651,"CWE-125 static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) {  OPCODE_DESC * opcode_desc ;  ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }", * opcode_desc ; if ( len < 2 ) { return NULL ; }
652,"CWE-119 static void decode_residue ( vorb * f , float * residue_buffers [ ] , int ch , int n , int rn , uint8 * do_not_decode ) { int i , j , pass ; Residue * r = f -> residue_config + rn ; int rtype = f -> residue_types [ rn ] ; int c = r -> classbook ; int classwords = f -> codebooks [ c ] . dimensions ;  int n_read = r -> end - r -> begin ;  int part_read = n_read / r -> part_size ; int temp_alloc_point = temp_alloc_save ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE uint8 * * * part_classdata = ( uint8 * * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * part_classdata ) ) ; # else int * * classifications = ( int * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * classifications ) ) ; # endif CHECK ( f ) ; for ( i = 0 ; i < ch ; ++ i ) if ( ! do_not_decode [ i ] ) memset ( residue_buffers [ i ] , 0 , sizeof ( float ) * n ) ; if ( rtype == 2 && ch != 1 ) { for ( j = 0 ; j < ch ; ++ j ) if ( ! do_not_decode [ j ] ) break ; if ( j == ch ) goto done ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; if ( ch == 2 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = ( z & 1 ) , p_inter = z >> 1 ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; # ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; # else if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; # endif } else { z += r -> part_size ; c_inter = z & 1 ; p_inter = z >> 1 ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } else if ( ch == 1 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = 0 , p_inter = z ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; } else { z += r -> part_size ; c_inter = 0 ; p_inter = z ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } else { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = z % ch , p_inter = z / ch ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; } else { z += r -> part_size ; c_inter = z % ch ; p_inter = z / ch ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } } goto done ; } CHECK ( f ) ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; while ( pcount < part_read ) { if ( pass == 0 ) { for ( j = 0 ; j < ch ; ++ j ) { if ( ! do_not_decode [ j ] ) { Codebook * c = f -> codebooks + r -> classbook ; int temp ; DECODE ( temp , f , c ) ; if ( temp == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ j ] [ class_set ] = r -> classdata [ temp ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ j ] [ i + pcount ] = temp % r -> classifications ; temp /= r -> classifications ; } # endif } } } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { for ( j = 0 ; j < ch ; ++ j ) { if ( ! do_not_decode [ j ] ) { # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ j ] [ class_set ] [ i ] ; # else int c = classifications [ j ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { float * target = residue_buffers [ j ] ; int offset = r -> begin + pcount * r -> part_size ; int n = r -> part_size ; Codebook * book = f -> codebooks + b ; if ( ! residue_decode ( f , book , target , offset , n , rtype ) ) goto done ; } } } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } done : CHECK ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE temp_free ( f , part_classdata ) ; # else temp_free ( f , classifications ) ; # endif temp_alloc_restore ( f , temp_alloc_point ) ; }", . dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ;  int n_read = limit_r_end - limit_r_begin  ; int part_read
653,"CWE-200 static void * __alloc_from_pool ( size_t size , struct page * * ret_page , gfp_t flags ) { unsigned long val ; void * ptr = NULL ; if ( ! atomic_pool ) { WARN ( 1 , ""coherentpoolnotinitialised!\\n"" ) ; return NULL ; } val = gen_pool_alloc ( atomic_pool , size ) ; if ( val ) { phys_addr_t phys = gen_pool_virt_to_phys ( atomic_pool , val ) ; * ret_page = phys_to_page ( phys ) ; ptr = ( void * ) val ;  if ( flags & __GFP_ZERO )  memset ( ptr , 0 , size ) ; } return ptr ; }", ) val ;  memset ( ptr
654,"CWE-200 static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;  if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ;  if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;  out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }"," ) goto out_nofree  ; skb =  != NULL ) {  , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; }  out : skb_free_datagram"
655,"CWE-190 static uint8_t * extend_raw_data ( LHAFileHeader * * header , LHAInputStream * stream , size_t nbytes ) { LHAFileHeader * new_header ; size_t new_raw_len ;  uint8_t * result ;  new_raw_len = RAW_DATA_LEN ( header ) + nbytes ; new_header = realloc ( * header , sizeof ( LHAFileHeader ) + new_raw_len ) ; if ( new_header == NULL ) { return NULL ; } * header = new_header ; new_header -> raw_data = ( uint8_t * ) ( new_header + 1 ) ; result = new_header -> raw_data + new_header -> raw_data_len ; if ( ! lha_input_stream_read ( stream , result , nbytes ) ) { return NULL ; } new_header -> raw_data_len = new_raw_len ; return result ; }", * result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
656,"CWE-400 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; }  for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ )  { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;"
657,CWE-284 static bool msr_mtrr_valid ( unsigned msr ) { switch ( msr ) { case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1 : case MSR_MTRRfix64K_00000 : case MSR_MTRRfix16K_80000 : case MSR_MTRRfix16K_A0000 : case MSR_MTRRfix4K_C0000 : case MSR_MTRRfix4K_C8000 : case MSR_MTRRfix4K_D0000 : case MSR_MTRRfix4K_D8000 : case MSR_MTRRfix4K_E0000 : case MSR_MTRRfix4K_E8000 : case MSR_MTRRfix4K_F0000 : case MSR_MTRRfix4K_F8000 : case MSR_MTRRdefType : case MSR_IA32_CR_PAT : return true ;  case 0x2f8 :  return true ; } return false ; }, return true ;  } return false
658,"CWE-399 static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ;  struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ;  struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ; struct xen_netif_tx_request * txp ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ;  if ( unlikely ( err ) ) {  pending_ring_idx_t index ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;  netbk -> pending_ring [ index ] = pending_idx ;  xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ;  pending_ring_idx_t index ;  pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) )  xen_netbk_idx_release ( netbk , pending_idx ) ;  continue ; }  txp = & netbk -> pending_tx_info [ pending_idx ] . req ;  make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;  index = pending_index ( netbk -> pending_prod ++ ) ;  netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; if ( err ) continue ; pending_idx = * ( ( u16 * ) skb -> data ) ;  xen_netbk_idx_release ( netbk , pending_idx ) ;  for ( j = start ; j < i ; j ++ ) { pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ;  xen_netbk_idx_release ( netbk , pending_idx ) ;  } err = newerr ; } * gopp = gop + 1 ; return err ; }"," ) ; struct  skb_shared_info * shinfo  err ) ) xen_netbk_idx_release ( netbk , pending_idx  , XEN_NETIF_RSP_ERROR )  XEN_NETIF_RSP_ERROR ) ;  start = (  , newerr ;  pending_idx = frag_get_pending_idx  netbk , pending_idx , XEN_NETIF_RSP_OKAY  continue ; } xen_netbk_idx_release ( netbk , pending_idx  , XEN_NETIF_RSP_ERROR )  XEN_NETIF_RSP_ERROR ) ;  if ( err  netbk , pending_idx , XEN_NETIF_RSP_OKAY  netbk , pending_idx , XEN_NETIF_RSP_OKAY"
659,"CWE-19 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ;  args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;  args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; if ( retval ) return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }", ; args . rmtvaluelen = valuelen ; args .
660,"CWE-119 static int fwnet_incoming_packet ( struct fwnet_device * dev , __be32 * buf , int len , int source_node_id , int generation , bool is_broadcast ) { struct sk_buff * skb ; struct net_device * net = dev -> netdev ; struct rfc2734_header hdr ; unsigned lf ; unsigned long flags ; struct fwnet_peer * peer ; struct fwnet_partial_datagram * pd ; int fg_off ; int dg_size ; u16 datagram_label ; int retval ; u16 ether_type ;  hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;  lf = fwnet_get_hdr_lf ( & hdr ) ; if ( lf == RFC2374_HDR_UNFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; buf ++ ; len -= RFC2374_UNFRAG_HDR_SIZE ; skb = dev_alloc_skb ( len + LL_RESERVED_SPACE ( net ) ) ; if ( unlikely ( ! skb ) ) { net -> stats . rx_dropped ++ ; return - ENOMEM ; } skb_reserve ( skb , LL_RESERVED_SPACE ( net ) ) ; memcpy ( skb_put ( skb , len ) , buf , len ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , is_broadcast , ether_type ) ; }  hdr . w1 = ntohl ( buf [ 1 ] ) ;  buf += 2 ; len -= RFC2374_FRAG_HDR_SIZE ; if ( lf == RFC2374_HDR_FIRSTFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; fg_off = 0 ; } else { ether_type = 0 ; fg_off = fwnet_get_hdr_fg_off ( & hdr ) ; } datagram_label = fwnet_get_hdr_dgl ( & hdr ) ; dg_size = fwnet_get_hdr_dg_size ( & hdr ) ;  spin_lock_irqsave ( & dev -> lock , flags ) ;  peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ; if ( ! peer ) { retval = - ENOENT ; goto fail ; } pd = fwnet_pd_find ( peer , datagram_label ) ; if ( pd == NULL ) { while ( peer -> pdg_size >= FWNET_MAX_FRAGMENTS ) { fwnet_pd_delete ( list_first_entry ( & peer -> pd_list , struct fwnet_partial_datagram , pd_link ) ) ; peer -> pdg_size -- ; } pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { retval = - ENOMEM ; goto fail ; } peer -> pdg_size ++ ; } else { if ( fwnet_frag_overlap ( pd , fg_off , len ) || pd -> datagram_size != dg_size ) { fwnet_pd_delete ( pd ) ; pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } else { if ( ! fwnet_pd_update ( peer , pd , buf , fg_off , len ) ) { fwnet_pd_delete ( pd ) ; peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } } if ( lf == RFC2374_HDR_FIRSTFRAG ) pd -> ether_type = ether_type ; if ( fwnet_pd_is_complete ( pd ) ) { ether_type = pd -> ether_type ; peer -> pdg_size -- ; skb = skb_get ( pd -> skb ) ; fwnet_pd_delete ( pd ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , false , ether_type ) ; } retval = 0 ; fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ; return retval ; }", u16 ether_type ; if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ;  ) ; } if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ;  hdr ) ; if ( fg_off + len > dg_size ) return 0 ;
661,"CWE-119 static int pit_ioport_read ( struct kvm_io_device * this , gpa_t addr , int len , void * data ) { struct kvm_pit * pit = dev_to_pit ( this ) ; struct kvm_kpit_state * pit_state = & pit -> pit_state ; struct kvm * kvm = pit -> kvm ; int ret , count ; struct kvm_kpit_channel_state * s ; if ( ! pit_in_range ( addr ) ) return - EOPNOTSUPP ; addr &= KVM_PIT_CHANNEL_MASK ;  s = & pit_state -> channels [ addr ] ;  mutex_lock ( & pit_state -> lock ) ; if ( s -> status_latched ) { s -> status_latched = 0 ; ret = s -> status ; } else if ( s -> count_latched ) { switch ( s -> count_latched ) { default : case RW_STATE_LSB : ret = s -> latched_count & 0xff ; s -> count_latched = 0 ; break ; case RW_STATE_MSB : ret = s -> latched_count >> 8 ; s -> count_latched = 0 ; break ; case RW_STATE_WORD0 : ret = s -> latched_count & 0xff ; s -> count_latched = RW_STATE_MSB ; break ; } } else { switch ( s -> read_state ) { default : case RW_STATE_LSB : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; break ; case RW_STATE_MSB : count = pit_get_count ( kvm , addr ) ; ret = ( count >> 8 ) & 0xff ; break ; case RW_STATE_WORD0 : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; s -> read_state = RW_STATE_WORD1 ; break ; case RW_STATE_WORD1 : count = pit_get_count ( kvm , addr ) ; ret = ( count >> 8 ) & 0xff ; s -> read_state = RW_STATE_WORD0 ; break ; } } if ( len > sizeof ( ret ) ) len = sizeof ( ret ) ; memcpy ( data , ( char * ) & ret , len ) ; mutex_unlock ( & pit_state -> lock ) ; return 0 ; }", &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;
662,"CWE-200 int get_devices_from_authfile ( const char * authfile , const char * username , unsigned max_devs , int verbose , FILE * debug_file , device_t * devices , unsigned * n_devs ) { char * buf = NULL ; char * s_user , * s_token ; int retval = 0 ; int fd = - 1 ; struct stat st ; struct passwd * pw = NULL , pw_s ; char buffer [ BUFSIZE ] ; int gpu_ret ; FILE * opwfile = NULL ; unsigned i , j ; * n_devs = 0 ;  fd = open ( authfile , O_RDONLY , 0 ) ;  if ( fd < 0 ) { if ( verbose ) D ( debug_file , ""Cannotopenfile:%s(%s)"" , authfile , strerror ( errno ) ) ; goto err ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , ""Cannotstatfile:%s(%s)"" , authfile , strerror ( errno ) ) ; goto err ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , ""%sisnotaregularfile"" , authfile ) ; goto err ; } if ( st . st_size == 0 ) { if ( verbose ) D ( debug_file , ""File%sisempty"" , authfile ) ; goto err ; } gpu_ret = getpwuid_r ( st . st_uid , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpu_ret != 0 || pw == NULL ) { D ( debug_file , ""Unabletoretrievecredentialsforuid%u,(%s)"" , st . st_uid , strerror ( errno ) ) ; goto err ; } if ( strcmp ( pw -> pw_name , username ) != 0 && strcmp ( pw -> pw_name , ""root"" ) != 0 ) { if ( strcmp ( username , ""root"" ) != 0 ) { D ( debug_file , ""Theowneroftheauthenticationfileisneither%snorroot"" , username ) ; } else { D ( debug_file , ""Theowneroftheauthenticationfileisnotroot"" ) ; } goto err ; } opwfile = fdopen ( fd , ""r"" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , ""fdopen:%s"" , strerror ( errno ) ) ;  goto err ;  } buf = malloc ( sizeof ( char ) * ( DEVSIZE * max_devs ) ) ; if ( ! buf ) { if ( verbose ) D ( debug_file , ""Unabletoallocatememory"" ) ; goto err ; } retval = - 2 ; while ( fgets ( buf , ( int ) ( DEVSIZE * ( max_devs - 1 ) ) , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( verbose ) D ( debug_file , ""Authorizationline:%s"" , buf ) ; s_user = strtok_r ( buf , "":"" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , ""Matcheduser:%s"" , s_user ) ; retval = - 1 ; for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; i = 0 ; while ( ( s_token = strtok_r ( NULL , "","" , & saveptr ) ) ) { devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; if ( ( * n_devs ) ++ > MAX_DEVS - 1 ) { * n_devs = MAX_DEVS ; if ( verbose ) D ( debug_file , ""Foundmorethan%ddevices,ignoringtheremainingones"" , MAX_DEVS ) ; break ; } if ( verbose ) D ( debug_file , ""KeyHandlefordevicenumber%d:%s"" , i + 1 , s_token ) ; devices [ i ] . keyHandle = strdup ( s_token ) ; if ( ! devices [ i ] . keyHandle ) { if ( verbose ) D ( debug_file , ""UnabletoallocatememoryforkeyHandlenumber%d"" , i ) ; goto err ; } s_token = strtok_r ( NULL , "":"" , & saveptr ) ; if ( ! s_token ) { if ( verbose ) D ( debug_file , ""UnabletoretrievepublicKeynumber%d"" , i + 1 ) ; goto err ; } if ( verbose ) D ( debug_file , ""publicKeyfordevicenumber%d:%s"" , i + 1 , s_token ) ; if ( strlen ( s_token ) % 2 != 0 ) { if ( verbose ) D ( debug_file , ""Lengthofkeynumber%dnoteven"" , i + 1 ) ; goto err ; } devices [ i ] . key_len = strlen ( s_token ) / 2 ; if ( verbose ) D ( debug_file , ""Lengthofkeynumber%dis%zu"" , i + 1 , devices [ i ] . key_len ) ; devices [ i ] . publicKey = malloc ( ( sizeof ( unsigned char ) * devices [ i ] . key_len ) ) ; if ( ! devices [ i ] . publicKey ) { if ( verbose ) D ( debug_file , ""UnabletoallocatememoryforpublicKeynumber%d"" , i ) ; goto err ; } for ( j = 0 ; j < devices [ i ] . key_len ; j ++ ) { unsigned int x ; if ( sscanf ( & s_token [ 2 * j ] , ""%2x"" , & x ) != 1 ) { if ( verbose ) D ( debug_file , ""Invalidhexnumberinkey"" ) ; goto err ; } devices [ i ] . publicKey [ j ] = ( unsigned char ) x ; } i ++ ; } } } if ( verbose ) D ( debug_file , ""Found%ddevice(s)foruser%s"" , * n_devs , username ) ; retval = 1 ; goto out ; err : for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; out : if ( buf ) { free ( buf ) ; buf = NULL ; } if ( opwfile ) fclose ( opwfile ) ;  else if ( fd >= 0 )  close ( fd ) ; return retval ; }"," authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY  ) ; if  ; goto err ; } else { fd = - 1  opwfile ) ;  if ( fd  if ( fd != - 1  ) close ("
663,"CWE-787 void pdf_load_pages_kids ( FILE * fp , pdf_t * pdf ) { int i , id , dummy ; char * buf , * c ; long start , sz ; start = ftell ( fp ) ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . version && ( pdf -> xrefs [ i ] . end != 0 ) ) { fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; while ( SAFE_F ( fp , ( fgetc ( fp ) != 't' ) ) ) ; sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ;  buf = malloc ( sz + 1 ) ;  SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failedtoload/Root.\\n"" ) ; buf [ sz ] = '\\0' ; if ( ! ( c = strstr ( buf , ""/Root"" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( ""/Root"" ) + 1 ) ; free ( buf ) ; buf = get_object ( fp , id , & pdf -> xrefs [ i ] , NULL , & dummy ) ; if ( ! buf || ! ( c = strstr ( buf , ""/Pages"" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( ""/Pages"" ) + 1 ) ; load_kids ( fp , id , & pdf -> xrefs [ i ] ) ; free ( buf ) ; } } fseek ( fp , start , SEEK_SET ) ; }", ; buf = safe_calloc  ( sz +
664,"CWE-190  static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) {  mongo_message * mm = ( mongo_message * ) bson_malloc ( len ) ; if ( ! id ) id = rand ( ) ;  mm -> head . len = len ;  mm -> head . id = id ; mm -> head . responseTo = responseTo ; mm -> head . op = op ; return mm ; }"," * mongo_message_create ( size_t  len , int  . len = ( int )"
665,"CWE-190 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ;  for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ;  image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", depth ++ ) if ( depth >= 64 ) break
666,"CWE-125 const char * linkaddr_string ( netdissect_options * ndo , const u_char * ep , const unsigned int type , const unsigned int len ) { register u_int i ; register char * cp ;  register struct enamemem * tp ;  if ( len == 0 ) return ( ""<empty>"" ) ; if ( type == LINKADDR_ETHER && len == ETHER_ADDR_LEN ) return ( etheraddr_string ( ndo , ep ) ) ; if ( type == LINKADDR_FRELAY ) return ( q922_string ( ndo , ep , len ) ) ; tp = lookup_bytestring ( ndo , ep , len ) ;  if ( tp -> e_name )  return ( tp -> e_name ) ; tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ;  if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:malloc"" ) ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; for ( i = len - 1 ; i > 0 ; -- i ) { * cp ++ = ':' ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; } * cp = '\\0' ;  return ( tp -> e_name ) ;  }", ; register struct bsnamemem  * tp ;  ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name  = cp =  ( tp -> bs_name  == NULL )  ( tp -> bs_name  ) ; }
667,"CWE-125 static size_t consume_init_expr ( ut8 * buf , ut8 * max , ut8 eoc , void * out , ut32 * offset ) { ut32 i = 0 ; while ( buf + i < max && buf [ i ] != eoc ) {  i += 1 ;  } if ( buf [ i ] != eoc ) { return 0 ; } if ( offset ) { * offset += i + 1 ; } return i + 1 ; }", ) { i ++  ; } if
668,"CWE-119 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_setbindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_REUSEPORT : sk -> sk_reuseport = valbool ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ;  sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;  sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ;  sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;  break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check_tx = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""setsockopt"" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } if ( val & SOF_TIMESTAMPING_OPT_ID && ! ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) ) { if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) { if ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) { ret = - EINVAL ; break ; } sk -> sk_tskey = tcp_sk ( sk ) -> snd_una ; } else { sk -> sk_tskey = 0 ; } } sk -> sk_tsflags = val ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_BPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_attach_bpf ( ufd , sk ) ; } break ; case SO_ATTACH_REUSEPORT_CBPF : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_reuseport_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_REUSEPORT_EBPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_reuseport_attach_bpf ( ufd , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_LOCK_FILTER : if ( sock_flag ( sk , SOCK_FILTER_LOCKED ) && ! valbool ) ret = - EPERM ; else sock_valbool_flag ( sk , SOCK_FILTER_LOCKED , valbool ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) ret = sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; case SO_SELECT_ERR_QUEUE : sock_valbool_flag ( sk , SOCK_SELECT_ERR_QUEUE , valbool ) ; break ; # ifdef CONFIG_NET_RX_BUSY_POLL case SO_BUSY_POLL : if ( ( val > sk -> sk_ll_usec ) && ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else { if ( val < 0 ) ret = - EINVAL ; else sk -> sk_ll_usec = val ; } break ; # endif case SO_MAX_PACING_RATE : sk -> sk_max_pacing_rate = val ; sk -> sk_pacing_rate = min ( sk -> sk_pacing_rate , sk -> sk_max_pacing_rate ) ; break ; case SO_INCOMING_CPU : sk -> sk_incoming_cpu = val ; break ; case SO_CNX_ADVICE : if ( val == 1 ) dst_negative_advice ( sk ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }"," = max_t ( int  , val *  = max_t ( int  , val *"
669,"CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ;  memcpy ( data -> strval , * bnode , size ) ;  data -> strval [ size ] = '\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }"," ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:Couldnotallocate%"" PRIu64 ""bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }"
670,"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:objectheadersize%unotamultipleof4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:objectheadertooshort%u<%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%sObject(%u)Flags:[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""andforward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""ifunknown],Class-Type:%s(%u),length:%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:objectgoespastendofobjectsTLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4DestAddress:%s,ProtocolID:0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%sFlags:[0x%02x],DestPort%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6DestAddress:%s,ProtocolID:0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%sFlags:[0x%02x],DestPort%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelEndPoint:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6P2MPLSPID:0x%08x,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4P2MPLSPID:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelEndPoint:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4ReceiverAddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6ReceiverAddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4NotifyNodeAddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6NotifyNodeAddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sGeneralizedLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sWavebandID:%u%sStartLabel:%u,StopLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sReservationStyle:%s,Flags:[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%smergecapability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%sMinimumVPI/VCI:%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%sMaximumVPI/VCI:%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%sMinimum/MaximumDLCI:%u/%u,%s%sbitDLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sLSPEncodingType:%s(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%sSwitchingType:%s(%u),PayloadID:%s(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%sSubobjectType:%s,length%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%sERROR:zerolengthEROsubtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""ERROR:length!=8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""ERROR:Prefixlength%u!=32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",%s,%s/%u,Flags:[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""ERROR:length!=8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",Flags:[%s](%#x),Class-Type:%s(%u),%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceInstance:0x%08x,DestinationInstance:0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sRestartTime:%ums,RecoveryTime:%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%sSessionName:"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Flags:[%s](%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { if ( total_subobj_len < 4 ) goto invalid ; subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%sSubobjectType:%s(%u),AF:%s(%u),length:%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; if ( subobj_len < 4 || subobj_len > total_subobj_len ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sUNIIPv4TNAaddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sUNIIPv6TNAaddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%sU-bit:%x,Labeltype:%u,Logicalportid:%u,Label:%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%sServicelevel:%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sPrevious/NextInterface:%s,LogicalInterfaceHandle:0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sPrevious/NextInterface:%s,LogicalInterfaceHandle:0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sRefreshPeriod:%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sMsg-Version:%u,length:%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%sServiceType:%s(%u),breakbit%sset,Servicelength:%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,FlowLabel:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Hop-limit:%u,Bandwidth:%.10gMbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%sInclude-any:0x%08x,Exclude-any:0x%08x,Include-all:0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Hop-limit:%u,Bandwidth:%.10gMbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%sIncludeColors:0x%08x,ExcludeColors:0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%sPLR-ID:%s,Avoid-Node-ID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 :  ND_PRINT ( ( ndo , ""%sCT:%u"" ,  ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%sErrorNodeAddress:%s,Flags:[0x%02x]%sErrorCode:%s(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",UnknownErrorValue(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%sErrorNodeAddress:%s,Flags:[0x%02x]%sErrorCode:%s(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%sTLVcount:%u,paddingbytes:%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s%sTLV(0x%02x),length:%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sFlags[0x%02x],epoch:%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sMessage-ID0x%08x(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%sKey-ID0x%04x%08x,Sequence0x%08x%08x,Flags[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%sMD5-sum0x%08x%08x%08x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sFlags[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%sAction:%s(%u),Labeltype:%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sStartrange:%u,Endrange:%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sSubchannel#%u:%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSub-LSPdestinationaddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSub-LSPdestinationaddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }", case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
671,"CWE-200 int udpv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ;  bool slow ;  if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { struct sockaddr_in6 * sin6 ; sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; }  }  if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }", ; bool slow  ; if (  ) ; } * addr_len = sizeof ( * sin6 ) ;
672,"CWE-476 smb_sdrc_t smb2_flush ( smb_request_t * sr ) {  smb_ofile_t * of = NULL ;  uint16_t StructSize ; uint16_t reserved1 ; uint32_t reserved2 ; smb2fid_t smb2fid ; uint32_t status ; int rc = 0 ; rc = smb_mbc_decodef ( & sr -> smb_data , ""wwlqq"" , & StructSize , & reserved1 , & reserved2 , & smb2fid . persistent , & smb2fid . temporal ) ; if ( rc ) return ( SDRC_ERROR ) ; if ( StructSize != 24 ) return ( SDRC_ERROR ) ; status = smb2sr_lookup_fid ( sr , & smb2fid ) ; if ( status ) { smb2sr_put_error ( sr , status ) ; return ( SDRC_SUCCESS ) ; }  of = sr -> fid_ofile ;  if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ; ( void ) smb_mbc_encodef ( & sr -> reply , ""wwl"" , 4 , 0 ) ; return ( SDRC_SUCCESS ) ; }"," sr ) {  uint16_t StructSize ;  ) ; } smb_ofile_flush ( sr ,  sr -> fid_ofile  sr -> fid_ofile  ) ; ("
673,"CWE-416 static void regulator_ena_gpio_free ( struct regulator_dev * rdev ) { struct regulator_enable_gpio * pin , * n ; if ( ! rdev -> ena_pin ) return ; list_for_each_entry_safe ( pin , n , & regulator_ena_gpio_list , list ) { if ( pin -> gpiod == rdev -> ena_pin -> gpiod ) { if ( pin -> request_count <= 1 ) { pin -> request_count = 0 ; gpiod_put ( pin -> gpiod ) ; list_del ( & pin -> list ) ; kfree ( pin ) ;  } else {  pin -> request_count -- ; } } } }", pin ) ; rdev -> ena_pin = NULL ; return ;
674,"CWE-125  int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  { if ( fields -> Len > 0 ) {  if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) )  return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }",    static  0 ) { const UINT64 offset = ( UINT64 )  fields -> BufferOffset  -> BufferOffset + ( UINT64 )  fields -> Len ; if ( offset  > Stream_Length (
675,"CWE-401 static int __ipmi_bmc_register ( struct ipmi_smi * intf , struct ipmi_device_id * id , bool guid_set , guid_t * guid , int intf_num ) { int rv ; struct bmc_device * bmc ; struct bmc_device * old_bmc ; intf -> in_bmc_register = true ; mutex_unlock ( & intf -> bmc_reg_mutex ) ; mutex_lock ( & ipmidriver_mutex ) ; if ( guid_set ) old_bmc = ipmi_find_bmc_guid ( & ipmidriver . driver , guid ) ; else old_bmc = ipmi_find_bmc_prod_dev_id ( & ipmidriver . driver , id -> product_id , id -> device_id ) ; if ( old_bmc ) { bmc = old_bmc ; intf -> bmc = old_bmc ; mutex_lock ( & bmc -> dyn_mutex ) ; list_add_tail ( & intf -> bmc_link , & bmc -> intfs ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; dev_info ( intf -> si_dev , ""interfacingexistingBMC(man_id:0x%6.6x,prod_id:0x%4.4x,dev_id:0x%2.2x)\\n"" , bmc -> id . manufacturer_id , bmc -> id . product_id , bmc -> id . device_id ) ; } else { bmc = kzalloc ( sizeof ( * bmc ) , GFP_KERNEL ) ; if ( ! bmc ) { rv = - ENOMEM ; goto out ; } INIT_LIST_HEAD ( & bmc -> intfs ) ; mutex_init ( & bmc -> dyn_mutex ) ; INIT_WORK ( & bmc -> remove_work , cleanup_bmc_work ) ; bmc -> id = * id ; bmc -> dyn_id_set = 1 ; bmc -> dyn_guid_set = guid_set ; bmc -> guid = * guid ; bmc -> dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY ; bmc -> pdev . name = ""ipmi_bmc"" ; rv = ida_simple_get ( & ipmi_bmc_ida , 0 , 0 , GFP_KERNEL ) ;  if ( rv < 0 )   goto out ;  bmc -> pdev . dev . driver = & ipmidriver . driver ; bmc -> pdev . id = rv ; bmc -> pdev . dev . release = release_bmc_device ; bmc -> pdev . dev . type = & bmc_device_type ; kref_init ( & bmc -> usecount ) ; intf -> bmc = bmc ; mutex_lock ( & bmc -> dyn_mutex ) ; list_add_tail ( & intf -> bmc_link , & bmc -> intfs ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; rv = platform_device_register ( & bmc -> pdev ) ; if ( rv ) { dev_err ( intf -> si_dev , ""Unabletoregisterbmcdevice:%d\\n"" , rv ) ; goto out_list_del ; } dev_info ( intf -> si_dev , ""FoundnewBMC(man_id:0x%6.6x,prod_id:0x%4.4x,dev_id:0x%2.2x)\\n"" , bmc -> id . manufacturer_id , bmc -> id . product_id , bmc -> id . device_id ) ; } rv = sysfs_create_link ( & intf -> si_dev -> kobj , & bmc -> pdev . dev . kobj , ""bmc"" ) ; if ( rv ) { dev_err ( intf -> si_dev , ""Unabletocreatebmcsymlink:%d\\n"" , rv ) ; goto out_put_bmc ; } if ( intf_num == - 1 ) intf_num = intf -> intf_num ; intf -> my_dev_name = kasprintf ( GFP_KERNEL , ""ipmi%d"" , intf_num ) ; if ( ! intf -> my_dev_name ) { rv = - ENOMEM ; dev_err ( intf -> si_dev , ""UnabletoallocatelinkfromBMC:%d\\n"" , rv ) ; goto out_unlink1 ; } rv = sysfs_create_link ( & bmc -> pdev . dev . kobj , & intf -> si_dev -> kobj , intf -> my_dev_name ) ; if ( rv ) { kfree ( intf -> my_dev_name ) ; intf -> my_dev_name = NULL ; dev_err ( intf -> si_dev , ""Unabletocreatesymlinktobmc:%d\\n"" , rv ) ; goto out_free_my_dev_name ; } intf -> bmc_registered = true ; out : mutex_unlock ( & ipmidriver_mutex ) ; mutex_lock ( & intf -> bmc_reg_mutex ) ; intf -> in_bmc_register = false ; return rv ; out_free_my_dev_name : kfree ( intf -> my_dev_name ) ; intf -> my_dev_name = NULL ; out_unlink1 : sysfs_remove_link ( & intf -> si_dev -> kobj , ""bmc"" ) ; out_put_bmc : mutex_lock ( & bmc -> dyn_mutex ) ; list_del ( & intf -> bmc_link ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; intf -> bmc = & intf -> tmp_bmc ; kref_put ( & bmc -> usecount , cleanup_bmc_device ) ; goto out ; out_list_del : mutex_lock ( & bmc -> dyn_mutex ) ; list_del ( & intf -> bmc_link ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; intf -> bmc = & intf -> tmp_bmc ; put_device ( & bmc -> pdev . dev ) ; goto out ; }", < 0 ) { kfree ( bmc ) ;  goto out ; }
676,"CWE-119 void test_base64_lengths ( void ) { const char * in = ""FuseMuse"" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( ""Expected:%zu"" , 0 ) ; TEST_MSG ( ""Actual:%zu"" , enclen ) ; } out1 [ 0 ] = '\\0' ;  declen = mutt_b64_decode ( out2 , out1 ) ;  if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( ""Expected:%zu"" , - 1 ) ; TEST_MSG ( ""Actual:%zu"" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( ""Expected:%zu"" , exp ) ; TEST_MSG ( ""Actual:%zu"" , enclen ) ; }  declen = mutt_b64_decode ( out2 , out1 ) ;  if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( ""Expected:%zu"" , i ) ; TEST_MSG ( ""Actual:%zu"" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( ""Expected:%s"" , in ) ; TEST_MSG ( ""Actual:%s"" , out2 ) ; } } }"," out2 , out1 , sizeof ( out2 )  out2 , out1 , sizeof ( out2 )"
677,"CWE-284 UINT32 UIPC_Read ( tUIPC_CH_ID ch_id , UINT16 * p_msg_evt , UINT8 * p_buf , UINT32 len ) { int n ; int n_read = 0 ; int fd = uipc_main . ch [ ch_id ] . fd ; struct pollfd pfd ; UNUSED ( p_msg_evt ) ; if ( ch_id >= UIPC_CH_NUM ) { BTIF_TRACE_ERROR ( ""UIPC_Read:invalidchid%d"" , ch_id ) ; return 0 ; } if ( fd == UIPC_DISCONNECTED ) { BTIF_TRACE_ERROR ( ""UIPC_Read:channel%dclosed"" , ch_id ) ; return 0 ; } while ( n_read < ( int ) len ) { pfd . fd = fd ; pfd . events = POLLIN | POLLHUP ;  if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 )  { BTIF_TRACE_EVENT ( ""polltimeout(%dms)"" , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ; break ; } if ( pfd . revents & ( POLLHUP | POLLNVAL ) ) { BTIF_TRACE_EVENT ( ""poll:channeldetachedremotely"" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; }  n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ;  if ( n == 0 ) { BTIF_TRACE_EVENT ( ""UIPC_Read:channeldetachedremotely"" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } if ( n < 0 ) { BTIF_TRACE_EVENT ( ""UIPC_Read:readfailed(%s)"" , strerror ( errno ) ) ; return 0 ; } n_read += n ; } return n_read ; }"," ; if ( TEMP_FAILURE_RETRY (  ] . read_poll_tmo_ms )  } n = TEMP_FAILURE_RETRY (  , 0 ) )"
678,"CWE-74 PS_SERIALIZER_DECODE_FUNC ( php ) { const char * p , * q ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ;  PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;  p = val ; while ( p < endptr ) { zval * * tmp ;  q = p ;  while ( * q != PS_DELIMITER ) { if ( ++ q >= endptr ) goto break_outer_loop ; } if ( p [ 0 ] == PS_UNDEF_MARKER ) { p ++ ; has_value = 0 ; } else { has_value = 1 ; } namelen = q - p ; name = estrndup ( p , namelen ) ; q ++ ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) {  goto skip ;  } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & q , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) {  php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;  } else { var_push_dtor_no_addref ( & var_hash , & current ) ; efree ( name ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; }  PS_ADD_VARL ( name , namelen ) ;  skip : efree ( name ) ; p = q ; } break_outer_loop : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }", php_unserialize_data_t var_hash ; int skip = 0 ;  q = p ; skip = 0  ) ) { skip = 1  ; } }  ) ) { if ( ! skip ) {  TSRMLS_CC ) ; }  ) ; } if ( ! skip ) {  namelen ) ; }
679,"CWE-20 void enc28j60EventHandler ( NetInterface * interface ) { error_t error ; uint16_t status ; uint16_t value ;  status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ;   if ( ( status & EIR_LINKIF ) != 0 )  {  enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHIR ) ;   enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_LINKIF ) ;   value = enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHSTAT2 ) ;   if ( ( value & PHSTAT2_LSTAT ) != 0 )  { interface -> linkSpeed = NIC_LINK_SPEED_10MBPS ; # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) interface -> duplexMode = NIC_FULL_DUPLEX_MODE ; # else interface -> duplexMode = NIC_HALF_DUPLEX_MODE ; # endif interface -> linkState = TRUE ; } else { interface -> linkState = FALSE ; } nicNotifyLinkChange ( interface ) ; }  if ( ( status & EIR_PKTIF ) != 0 )  {  enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_PKTIF ) ;  do { error = enc28j60ReceivePacket ( interface ) ; } while ( error != ERROR_BUFFER_EMPTY ) ; }  enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ;  }"," ( interface , ENC28J60_EIR  ) ; if  ( status & ENC28J60_EIR_LINKIF  ) != 0  ( interface , ENC28J60_PHIR  ) ; enc28j60ClearBit  ( interface , ENC28J60_EIR , ENC28J60_EIR_LINKIF  ) ; value  ( interface , ENC28J60_PHSTAT2  ) ; if  ( value & ENC28J60_PHSTAT2_LSTAT  ) != 0  } if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT  ) != 0  ( interface , ENC28J60_EIR , ENC28J60_EIR_PKTIF  ) ; do  ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE | ENC28J60_EIE_PKTIE  ) ; }"
680,"CWE-20 static int create_filesystem_object ( struct archive_write_disk * a ) { const char * linkname ; mode_t final_mode , mode ; int r ;  linkname = archive_entry_hardlink ( a -> entry ) ;  if ( linkname != NULL ) { # if ! HAVE_LINK return ( EPERM ) ;  # else  r = link ( linkname , a -> name ) ? errno : 0 ; if ( r == 0 && a -> filesize <= 0 ) { a -> todo = 0 ; a -> deferred = 0 ; } else if ( r == 0 && a -> filesize > 0 ) { a -> fd = open ( a -> name , O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC ) ; __archive_ensure_cloexec_flag ( a -> fd ) ; if ( a -> fd < 0 ) r = errno ; } return ( r ) ; # endif } linkname = archive_entry_symlink ( a -> entry ) ; if ( linkname != NULL ) { # if HAVE_SYMLINK return symlink ( linkname , a -> name ) ? errno : 0 ; # else return ( EPERM ) ; # endif } final_mode = a -> mode & 07777 ; mode = final_mode & 0777 & ~ a -> user_umask ; switch ( a -> mode & AE_IFMT ) { default : case AE_IFREG : a -> fd = open ( a -> name , O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC , mode ) ; __archive_ensure_cloexec_flag ( a -> fd ) ; r = ( a -> fd < 0 ) ; break ; case AE_IFCHR : # ifdef HAVE_MKNOD r = mknod ( a -> name , mode | S_IFCHR , archive_entry_rdev ( a -> entry ) ) ; break ; # else return ( EINVAL ) ; # endif case AE_IFBLK : # ifdef HAVE_MKNOD r = mknod ( a -> name , mode | S_IFBLK , archive_entry_rdev ( a -> entry ) ) ; break ; # else return ( EINVAL ) ; # endif case AE_IFDIR : mode = ( mode | MINIMUM_DIR_MODE ) & MAXIMUM_DIR_MODE ; r = mkdir ( a -> name , mode ) ; if ( r == 0 ) { a -> deferred |= ( a -> todo & TODO_TIMES ) ; a -> todo &= ~ TODO_TIMES ; if ( ( mode != final_mode ) || ( a -> flags & ARCHIVE_EXTRACT_PERM ) ) a -> deferred |= ( a -> todo & TODO_MODE ) ; a -> todo &= ~ TODO_MODE ; } break ; case AE_IFIFO : # ifdef HAVE_MKFIFO r = mkfifo ( a -> name , mode ) ; break ; # else return ( EINVAL ) ; # endif } if ( r ) return ( errno ) ; if ( mode == final_mode ) a -> todo &= ~ TODO_MODE ; return ( 0 ) ; }"," int r ; char * linkname_copy ; struct archive_string error_string ; int error_number ;  ; # else archive_string_init ( & error_string ) ; linkname_copy = strdup ( linkname ) ; if ( linkname_copy == NULL ) { return ( EPERM ) ; } r = cleanup_pathname_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } r = check_symlinks_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } free ( linkname_copy ) ;"
681,"CWE-310 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ;  snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ;  rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }"," crypto_report_cipher rcipher ; strncpy  ( rcipher .  . type , ""cipher"" , sizeof ( rcipher . type )  ) ; rcipher"
682,CWE-200 void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; }  kfree ( bprm ) ;  }, ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;
683,"CWE-119  void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {  if ( eob > 1 )  vp9_iwht4x4_16_add ( input , dest , stride ) ;  else  vp9_iwht4x4_1_add ( input , dest , stride ) ;  }"," vp9_iwht4x4_add ( const tran_low_t  * input ,  > 1 ) vpx_iwht4x4_16_add  ( input ,  ) ; else vpx_iwht4x4_1_add  ( input ,"
684,"CWE-787 static int next_state_val ( CClassNode * cc , OnigCodePoint * vs , OnigCodePoint v , int * vs_israw , int v_israw , enum CCVALTYPE intype , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; switch ( * state ) { case CCS_VALUE : if ( * type == CCV_SB ) {  BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;  } else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } break ; case CCS_RANGE : if ( intype == * type ) { if ( intype == CCV_SB ) { if ( * vs > 0xff || v > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) v ) ; } else { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , v ) ; if ( r < 0 ) return r ; } } else { # if 0 if ( intype == CCV_CODE_POINT && * type == CCV_SB ) { # endif if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) ( v < 0xff ? v : 0xff ) ) ; r = add_code_range ( & ( cc -> mbuf ) , env , ( OnigCodePoint ) * vs , v ) ; if ( r < 0 ) return r ; # if 0 } else return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE ; # endif } ccs_range_end : * state = CCS_COMPLETE ; break ; case CCS_COMPLETE : case CCS_START : * state = CCS_VALUE ; break ; default : break ; } * vs_israw = v_israw ; * vs = v ; * type = intype ; return 0 ; }", CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
685,"CWE-119 static void suffix_object ( cJSON * prev , cJSON * item ) { prev -> next = item ; item -> prev = prev ; }","
"
686,"CWE-362 int ip_queue_xmit ( struct sk_buff * skb ) { struct sock * sk = skb -> sk ; struct inet_sock * inet = inet_sk ( sk ) ;  struct ip_options * opt = inet -> opt ;  struct rtable * rt ; struct iphdr * iph ; int res ; rcu_read_lock ( ) ;  rt = skb_rtable ( skb ) ;  if ( rt != NULL ) goto packet_routed ; rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; if ( rt == NULL ) { __be32 daddr ; daddr = inet -> inet_daddr ;  if ( opt && opt -> srr )   daddr = opt -> faddr ;  rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( IS_ERR ( rt ) ) goto no_route ; sk_setup_caps ( sk , & rt -> dst ) ; } skb_dst_set_noref ( skb , & rt -> dst ) ; packet_routed :  if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway )  goto no_route ;  skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ;  skb_reset_network_header ( skb ) ; iph = ip_hdr ( skb ) ; * ( ( __be16 * ) iph ) = htons ( ( 4 << 12 ) | ( 5 << 8 ) | ( inet -> tos & 0xff ) ) ; if ( ip_dont_fragment ( sk , & rt -> dst ) && ! skb -> local_df ) iph -> frag_off = htons ( IP_DF ) ; else iph -> frag_off = 0 ; iph -> ttl = ip_select_ttl ( inet , & rt -> dst ) ; iph -> protocol = sk -> sk_protocol ; iph -> saddr = rt -> rt_src ; iph -> daddr = rt -> rt_dst ;  if ( opt && opt -> optlen ) {   iph -> ihl += opt -> optlen >> 2 ;   ip_options_build ( skb , opt , inet -> inet_daddr , rt , 0 ) ;  } ip_select_ident_more ( iph , & rt -> dst , sk , ( skb_shinfo ( skb ) -> gso_segs ? : 1 ) - 1 ) ; skb -> priority = sk -> sk_priority ; skb -> mark = sk -> sk_mark ; res = ip_local_out ( skb ) ; rcu_read_unlock ( ) ; return res ; no_route : rcu_read_unlock ( ) ; IP_INC_STATS ( sock_net ( sk ) , IPSTATS_MIB_OUTNOROUTES ) ; kfree_skb ( skb ) ; return - EHOSTUNREACH ; }"," ) ; struct ip_options_rcu * inet_opt  ; struct rtable  ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ;  ; if ( inet_opt && inet_opt -> opt .  srr ) daddr  ) daddr = inet_opt -> opt .  faddr ; rt  : if ( inet_opt && inet_opt -> opt .  is_strictroute && rt  ) + ( inet_opt ? inet_opt -> opt .  optlen : 0  ; if ( inet_opt && inet_opt -> opt .  optlen ) {  -> ihl += inet_opt -> opt .  optlen >> 2  ( skb , & inet_opt ->"
687,"CWE-190 void posixtimer_rearm ( struct siginfo * info ) { struct k_itimer * timr ; unsigned long flags ; timr = lock_timer ( info -> si_tid , & flags ) ; if ( ! timr ) return ; if ( timr -> it_requeue_pending == info -> si_sys_private ) { timr -> kclock -> timer_rearm ( timr ) ; timr -> it_active = 1 ; timr -> it_overrun_last = timr -> it_overrun ;  timr -> it_overrun = - 1 ;  ++ timr -> it_requeue_pending ;  info -> si_overrun += timr -> it_overrun_last ;  } unlock_timer ( timr , flags ) ; }"," it_overrun = - 1LL  ; ++ timr  info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun )  ; } unlock_timer"
688,"CWE-190 static PyObject * _pickle_PicklerMemoProxy_copy_impl ( PicklerMemoProxyObject * self ) {  Py_ssize_t i ;  PyMemoTable * memo ; PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; memo = self -> pickler -> memo ;  for ( i = 0 ; i < memo -> mt_allocated ; ++ i ) {  PyMemoEntry entry = memo -> mt_table [ i ] ; if ( entry . me_key != NULL ) { int status ; PyObject * key , * value ; key = PyLong_FromVoidPtr ( entry . me_key ) ; value = Py_BuildValue ( ""nO"" , entry . me_value , entry . me_key ) ; if ( key == NULL || value == NULL ) { Py_XDECREF ( key ) ; Py_XDECREF ( value ) ; goto error ; } status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; Py_DECREF ( value ) ; if ( status < 0 ) goto error ; } } return new_memo ; error : Py_XDECREF ( new_memo ) ; return NULL ; }", self ) {  PyMemoTable * memo  ; for ( size_t
689,"CWE-264 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_bindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET  if ( sk -> sk_protocol == IPPROTO_TCP )  tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || capable ( CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""setsockopt"" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE , val & SOF_TIMESTAMPING_TX_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE , val & SOF_TIMESTAMPING_TX_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE , val & SOF_TIMESTAMPING_RX_HARDWARE ) ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE , val & SOF_TIMESTAMPING_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE , val & SOF_TIMESTAMPING_SYS_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE , val & SOF_TIMESTAMPING_RAW_HARDWARE ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }", sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM
690,"CWE-285 static int __btrfs_set_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct posix_acl * acl , int type ) { int ret , size = 0 ; const char * name ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) {  ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;  if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; } ret = 0 ; break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ; name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out ; } ret = __btrfs_setxattr ( trans , inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! ret ) set_cached_acl ( inode , type , acl ) ; return ret ; }"," { ret = posix_acl_update_mode ( inode  , & inode  inode -> i_mode , & acl ) ; if ( ret ) return ret  ; } ret"
691,"CWE-94 int StreamTcpPacket ( ThreadVars * tv , Packet * p , StreamTcpThread * stt , PacketQueue * pq ) { SCEnter ( ) ; DEBUG_ASSERT_FLOW_LOCKED ( p -> flow ) ; SCLogDebug ( ""p->pcap_cnt%"" PRIu64 , p -> pcap_cnt ) ; HandleThreadId ( tv , p , stt ) ; TcpSession * ssn = ( TcpSession * ) p -> flow -> protoctx ; if ( ssn != NULL ) { ssn -> tcp_packet_flags |= p -> tcph -> th_flags ; if ( PKT_IS_TOSERVER ( p ) ) ssn -> client . tcp_flags |= p -> tcph -> th_flags ; else if ( PKT_IS_TOCLIENT ( p ) ) ssn -> server . tcp_flags |= p -> tcph -> th_flags ; if ( ssn -> flags & STREAMTCP_FLAG_ASYNC && ssn -> client . tcp_flags != 0 && ssn -> server . tcp_flags != 0 ) { SCLogDebug ( ""ssn%p:removingASYNCflagaswehavepacketsonbothsides"" , ssn ) ; ssn -> flags &= ~ STREAMTCP_FLAG_ASYNC ; } } if ( ( p -> tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) { StatsIncr ( tv , stt -> counter_tcp_synack ) ; } else if ( p -> tcph -> th_flags & ( TH_SYN ) ) { StatsIncr ( tv , stt -> counter_tcp_syn ) ; } if ( p -> tcph -> th_flags & ( TH_RST ) ) { StatsIncr ( tv , stt -> counter_tcp_rst ) ; } if ( ! ( p -> tcph -> th_flags & TH_ACK ) && TCP_GET_ACK ( p ) != 0 ) {  StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ;  } if ( StreamTcpCheckFlowDrops ( p ) == 1 ) { SCLogDebug ( ""Thisflow/streamtriggeredadroprule"" ) ; FlowSetNoPacketInspectionFlag ( p -> flow ) ; DecodeSetNoPacketInspectionFlag ( p ) ; StreamTcpDisableAppLayer ( p -> flow ) ; PACKET_DROP ( p ) ; StreamTcpSessionPktFree ( p ) ; SCReturnInt ( 0 ) ; } if ( ssn == NULL || ssn -> state == TCP_NONE ) { if ( StreamTcpPacketStateNone ( tv , p , stt , ssn , & stt -> pseudo_queue ) == - 1 ) { goto error ; } if ( ssn != NULL ) SCLogDebug ( ""ssn->alproto%"" PRIu16 """" , p -> flow -> alproto ) ; } else { if ( p -> flags & PKT_PSEUDO_STREAM_END ) { if ( PKT_IS_TOCLIENT ( p ) ) { ssn -> client . last_ack = TCP_GET_ACK ( p ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> server , p , pq ) ; } else { ssn -> server . last_ack = TCP_GET_ACK ( p ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> client , p , pq ) ; } goto skip ; } if ( p -> flow -> flags & FLOW_WRONG_THREAD || ssn -> client . flags & STREAMTCP_STREAM_FLAG_GAP || ssn -> server . flags & STREAMTCP_STREAM_FLAG_GAP ) { p -> flags |= PKT_STREAM_NO_EVENTS ; } if ( StreamTcpPacketIsKeepAlive ( ssn , p ) == 1 ) { goto skip ; } if ( StreamTcpPacketIsKeepAliveACK ( ssn , p ) == 1 ) { StreamTcpClearKeepAliveFlag ( ssn , p ) ; goto skip ; } StreamTcpClearKeepAliveFlag ( ssn , p ) ; if ( StreamTcpPacketIsFinShutdownAck ( ssn , p ) == 0 ) if ( StreamTcpPacketIsWindowUpdate ( ssn , p ) == 0 ) if ( StreamTcpPacketIsBadWindowUpdate ( ssn , p ) ) goto skip ; if ( StreamTcpStateDispatch ( tv , p , stt , ssn , & stt -> pseudo_queue , ssn -> state ) < 0 ) goto error ; skip : StreamTcpPacketCheckPostRst ( ssn , p ) ; if ( ssn -> state >= TCP_ESTABLISHED ) { p -> flags |= PKT_STREAM_EST ; } } if ( ssn != NULL ) { while ( stt -> pseudo_queue . len > 0 ) { SCLogDebug ( ""processingpseudopacket/streamend"" ) ; Packet * np = PacketDequeue ( & stt -> pseudo_queue ) ; if ( np != NULL ) { if ( PKT_IS_TOSERVER ( np ) ) { SCLogDebug ( ""pseudopacketistoserver"" ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> client , np , NULL ) ; } else { SCLogDebug ( ""pseudopacketistoclient"" ) ; StreamTcpReassembleHandleSegment ( tv , stt -> ra_ctx , ssn , & ssn -> server , np , NULL ) ; } PacketEnqueue ( pq , np ) ; } SCLogDebug ( ""processingpseudopacket/streamenddone"" ) ; } if ( p -> flags & PKT_STREAM_MODIFIED ) { ReCalculateChecksum ( p ) ; } if ( ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) || ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) ) { if ( StreamTcpBypassEnabled ( ) ) { PacketBypassCallback ( p ) ; } } if ( ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) || ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED ) ) { p -> flags |= PKT_STREAM_NOPCAPLOG ; } if ( ( PKT_IS_TOSERVER ( p ) && ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) ) || ( PKT_IS_TOCLIENT ( p ) && ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) ) ) { p -> flags |= PKT_STREAM_NOPCAPLOG ; } if ( ssn -> flags & STREAMTCP_FLAG_BYPASS ) { if ( StreamTcpBypassEnabled ( ) ) { PacketBypassCallback ( p ) ; } } else if ( g_detect_disabled && ( ssn -> client . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) && ( ssn -> server . flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY ) && StreamTcpBypassEnabled ( ) ) { SCLogDebug ( ""bypassasstreamisdeadandwehavenorules"" ) ; PacketBypassCallback ( p ) ; } } SCReturnInt ( 0 ) ; error : while ( stt -> pseudo_queue . len > 0 ) { Packet * np = PacketDequeue ( & stt -> pseudo_queue ) ; if ( np != NULL ) { PacketEnqueue ( pq , np ) ; } } if ( p -> flags & PKT_STREAM_MODIFIED ) { ReCalculateChecksum ( p ) ; } if ( StreamTcpInlineDropInvalid ( ) ) { DecodeSetNoPayloadInspectionFlag ( p ) ; PACKET_DROP ( p ) ; } SCReturnInt ( - 1 ) ; }"," , STREAM_PKT_BROKEN_ACK ) ; goto error"
692,"CWE-119 static int su3000_power_ctrl ( struct dvb_usb_device * d , int i ) { struct dw2102_state * state = ( struct dw2102_state * ) d -> priv ;  u8 obuf [ ] = { 0xde , 0 } ;  info ( ""%s:%d,initialized%d"" , __func__ , i , state -> initialized ) ; if ( i && ! state -> initialized ) {  state -> initialized = 1 ;   return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;   }  return 0 ; }"," -> priv ; int ret = 0  ; info (  initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ;  = 1 ; ret =  dvb_usb_generic_rw ( d  ( d , state -> data  , 2 ,  0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret  ; } "
693,CWE-399  void unix_notinflight ( struct file * fp )  { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; }  fp -> f_cred -> user -> unix_inflight -- ;  spin_unlock ( & unix_gc_lock ) ; }," void unix_notinflight ( struct user_struct * user ,  -- ; }  user -> unix_inflight"
694,"CWE-20 void init_util ( void ) { filegen_register ( statsdir , ""peerstats"" , & peerstats ) ; filegen_register ( statsdir , ""loopstats"" , & loopstats ) ; filegen_register ( statsdir , ""clockstats"" , & clockstats ) ; filegen_register ( statsdir , ""rawstats"" , & rawstats ) ; filegen_register ( statsdir , ""sysstats"" , & sysstats ) ; filegen_register ( statsdir , ""protostats"" , & protostats ) ;  # ifdef AUTOKEY  filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;  # endif  # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;  # endif  step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }", protostats ) ;  filegen_register ( statsdir  cryptostats ) ;  filegen_register ( statsdir  timingstats ) ;  step_callback = &
695,"CWE-476 int migrate_page_move_mapping ( struct address_space * mapping , struct page * newpage , struct page * page , struct buffer_head * head , enum migrate_mode mode , int extra_count ) {  int expected_count = 1 + extra_count ;  void * * pslot ; if ( ! mapping ) { if ( page_count ( page ) != expected_count ) return - EAGAIN ; set_page_memcg ( newpage , page_memcg ( page ) ) ; newpage -> index = page -> index ; newpage -> mapping = page -> mapping ; if ( PageSwapBacked ( page ) ) SetPageSwapBacked ( newpage ) ; return MIGRATEPAGE_SUCCESS ;  }  spin_lock_irq ( & mapping -> tree_lock ) ; pslot = radix_tree_lookup_slot ( & mapping -> page_tree , page_index ( page ) ) ; expected_count += 1 + page_has_private ( page ) ; if ( page_count ( page ) != expected_count || radix_tree_deref_slot_protected ( pslot , & mapping -> tree_lock ) != page ) { spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } if ( ! page_freeze_refs ( page , expected_count ) ) { spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } if ( mode == MIGRATE_ASYNC && head && ! buffer_migrate_lock_buffers ( head , mode ) ) { page_unfreeze_refs ( page , expected_count ) ; spin_unlock_irq ( & mapping -> tree_lock ) ; return - EAGAIN ; } set_page_memcg ( newpage , page_memcg ( page ) ) ; newpage -> index = page -> index ; newpage -> mapping = page -> mapping ; if ( PageSwapBacked ( page ) ) SetPageSwapBacked ( newpage ) ; get_page ( newpage ) ; if ( PageSwapCache ( page ) ) { SetPageSwapCache ( newpage ) ; set_page_private ( newpage , page_private ( page ) ) ; }  radix_tree_replace_slot ( pslot , newpage ) ;  page_unfreeze_refs ( page , expected_count - 1 ) ;  __dec_zone_page_state ( page , NR_FILE_PAGES ) ;   __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ;   if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) {  __dec_zone_page_state ( page , NR_SHMEM ) ; __inc_zone_page_state ( newpage , NR_SHMEM ) ; } spin_unlock_irq ( & mapping -> tree_lock ) ; return MIGRATEPAGE_SUCCESS ; }"," extra_count ) { struct zone * oldzone , * newzone ; int dirty ;  MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ;  ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; }  1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone  , NR_FILE_PAGES )  NR_FILE_PAGES ) ; __inc_zone_state ( newzone  , NR_FILE_PAGES )  ; if ( PageSwapBacked ( page ) &&  ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable (  ) ; return"
696,CWE-119 static inline struct futex_hash_bucket * queue_lock ( struct futex_q * q ) {  struct futex_hash_bucket * hb ;  get_futex_key_refs ( & q -> key ) ; hb = hash_futex ( & q -> key ) ; q -> lock_ptr = & hb -> lock ; spin_lock ( & hb -> lock ) ; return hb ; }, futex_hash_bucket * hb  ; hb =
697,"CWE-119 static char * bittok2str_internal ( register const struct tok * lp , register const char * fmt , register u_int v , const char * sep ) {  static char buf [ 256 ] ;  int buflen = 0 ; register u_int rotbit ; register u_int tokval ; const char * sepstr = """" ; while ( lp != NULL && lp -> s != NULL ) { tokval = lp -> v ; rotbit = 1 ; while ( rotbit != 0 ) { if ( tokval == ( v & rotbit ) ) {  buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" ,   sepstr , lp -> s ) ;  sepstr = sep ; break ; } rotbit = rotbit << 1 ; } lp ++ ; }  if ( buflen == 0 )  ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? ""#%08x"" : fmt , v ) ; return ( buf ) ; }"," char buf [ 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size  ; register u_int  ) ) { if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp  , lp ->  lp -> s , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size  ; sepstr =  } if ( bufp == buf  ) ( void"
698,"CWE-834 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacketbegin="" # define EndXMPPacket ""<?xpacketend="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""RenderingPostscript..."" # define SpotColor ""+"" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) ResetMagickMemory ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) ResetMagickMemory ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) ResetMagickMemory ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""%lu%lu"" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""%lu"" , & extent ) ; if ( count != 1 ) continue ;  length = extent ;  profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , i + 1 ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = AcquireString ( p ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""%lf%lf%lf%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""%lf%lf%lf%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""%lf%lf%lf%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""%lf%lf%lf%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""%lf%lf%lf%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\'"" , option ) ; image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } ( void ) CloseBlob ( image ) ; if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice{pop}bind1indexwhere{"" ""dupwcheck{31rollput}{popdef}ifelse}{def}ifelse\\n"" ""<</UseCIEColortrue>>setpagedevice\\n"" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , ""%g%gtranslate\\n"" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , ""-g%.20gx%.20g"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , ""-dFirstPage=%.20g"" ""-dLastPage=%.20g"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop"" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage"" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""-cshowpage"" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }"," length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" )"
699,"CWE-119 int ssh_packet_set_state ( struct ssh * ssh , struct sshbuf * m ) { struct session_state * state = ssh -> state ; const u_char * ssh1key , * ivin , * ivout , * keyin , * keyout , * input , * output ; size_t ssh1keylen , rlen , slen , ilen , olen ; int r ; u_int ssh1cipher = 0 ; if ( ! compat20 ) { if ( ( r = sshbuf_get_u32 ( m , & state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_get_u32 ( m , & ssh1cipher ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & ssh1key , & ssh1keylen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & ivout , & slen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & ivin , & rlen ) ) != 0 ) return r ; if ( ssh1cipher > INT_MAX ) return SSH_ERR_KEY_UNKNOWN_CIPHER ; ssh_packet_set_encryption_key ( ssh , ssh1key , ssh1keylen , ( int ) ssh1cipher ) ; if ( cipher_get_keyiv_len ( state -> send_context ) != ( int ) slen || cipher_get_keyiv_len ( state -> receive_context ) != ( int ) rlen ) return SSH_ERR_INVALID_FORMAT ; if ( ( r = cipher_set_keyiv ( state -> send_context , ivout ) ) != 0 || ( r = cipher_set_keyiv ( state -> receive_context , ivin ) ) != 0 ) return r ; } else { if ( ( r = kex_from_blob ( m , & ssh -> kex ) ) != 0 || ( r = newkeys_from_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_from_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> rekey_limit ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> rekey_interval ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_send . blocks ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_send . packets ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_send . bytes ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_read . blocks ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_read . packets ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_read . bytes ) ) != 0 ) return r ; state -> rekey_time = monotime ( ) ; if ( ( r = ssh_set_newkeys ( ssh , MODE_IN ) ) != 0 || ( r = ssh_set_newkeys ( ssh , MODE_OUT ) ) != 0 ) return r ; } if ( ( r = sshbuf_get_string_direct ( m , & keyout , & slen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & keyin , & rlen ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> send_context , NULL ) != ( int ) slen || cipher_get_keycontext ( state -> receive_context , NULL ) != ( int ) rlen ) return SSH_ERR_INVALID_FORMAT ; cipher_set_keycontext ( state -> send_context , keyout ) ; cipher_set_keycontext ( state -> receive_context , keyin ) ;  if ( ( r = ssh_packet_set_compress_state ( ssh , m ) ) != 0 ||  ( r = ssh_packet_set_postauth ( ssh ) ) != 0 ) return r ; sshbuf_reset ( state -> input ) ; sshbuf_reset ( state -> output ) ; if ( ( r = sshbuf_get_string_direct ( m , & input , & ilen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & output , & olen ) ) != 0 || ( r = sshbuf_put ( state -> input , input , ilen ) ) != 0 || ( r = sshbuf_put ( state -> output , output , olen ) ) != 0 ) return r ; if ( sshbuf_len ( m ) ) return SSH_ERR_INVALID_FORMAT ; debug3 ( ""%s:done"" , __func__ ) ; return 0 ; }", ( r =  ssh_packet_set_postauth ( ssh
700,"CWE-416 int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , ""%s"" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( ""mii_bus%sfailedtoregister\\n"" , bus -> id ) ;  put_device ( & bus -> dev ) ;  return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , ""reset"" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , ""mii_bus%scouldn\'tgetresetGPIO\\n"" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( ""%s:probed\\n"" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }", id ) ;  return - EINVAL
701,"CWE-20 static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) {  case RESPONSE_RUN :  { screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launchinguntrustedlauncher%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ;  }  break ; case RESPONSE_MARK_TRUSTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; g_object_unref ( file ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }"," ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ;  screen = gtk_widget_get_screen  uri ) ;  g_object_unref ( file"
702,"CWE-119 static FILE * open_outfile ( const char * name ) { if ( strcmp ( ""-"" , name ) == 0 ) { set_binary_mode ( stdout ) ; return stdout ; } else { FILE * file = fopen ( name , ""wb"" ) ; if ( ! file )  fatal ( ""Failedtooutputfile%s"" , name ) ;  return file ; } }"," ) fatal ( ""Failedtoopenoutputfile\'%s\'""  , name )"
703,"CWE-20 static int lua_websocket_read ( lua_State * L ) { apr_socket_t * sock ; apr_status_t rv ;  int n = 0 ;  apr_size_t len = 1 ; apr_size_t plen = 0 ; unsigned short payload_short = 0 ; apr_uint64_t payload_long = 0 ; unsigned char * mask_bytes ; char byte ; int plaintext ; request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ; mask_bytes = apr_pcalloc ( r -> pool , 4 ) ;  sock = ap_get_conn_socket ( r -> connection ) ;  if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { unsigned char ubyte , fin , opcode , mask , payload ; ubyte = ( unsigned char ) byte ; fin = ubyte >> ( CHAR_BIT - 1 ) ; opcode = ubyte & 0xf ; if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { ubyte = ( unsigned char ) byte ; mask = ubyte >> ( CHAR_BIT - 1 ) ; payload = ubyte & 0x7f ; plen = payload ; if ( payload == 126 ) { len = 2 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ) ; } payload_short = ntohs ( payload_short ) ; if ( rv == APR_SUCCESS ) { plen = payload_short ; } else { return 0 ; } } if ( payload == 127 ) { len = 8 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ) ; } if ( rv == APR_SUCCESS ) { plen = ap_ntoh64 ( & payload_long ) ; } else { return 0 ; } } ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , ""Websocket:Reading%"" APR_SIZE_T_FMT ""(%s)bytes,maskingis%s.%s"" , plen , ( payload >= 126 ) ? ""extrapayload"" : ""noextrapayload"" , mask ? ""on"" : ""off"" , fin ? ""Thisisafinalframe"" : ""moretofollow"" ) ; if ( mask ) { len = 4 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ) ; } if ( rv != APR_SUCCESS ) { return 0 ; } } if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 ) { apr_size_t remaining = plen ; apr_size_t received ; apr_off_t at = 0 ; char * buffer = apr_palloc ( r -> pool , plen + 1 ) ; buffer [ plen ] = 0 ; if ( plaintext ) { while ( remaining > 0 ) { received = remaining ; rv = apr_socket_recv ( sock , buffer + at , & received ) ; if ( received > 0 ) { remaining -= received ; at += received ; } } ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , ""Websocket:Framecontained%"" APR_OFF_T_FMT ""bytes,pushedtoLuastack"" , at ) ; } else { rv = lua_websocket_readbytes ( r -> connection , buffer , remaining ) ; ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , ""Websocket:SSLFramecontained%"" APR_SIZE_T_FMT ""bytes,"" ""pushedtoLuastack"" , remaining ) ; } if ( mask ) { for ( n = 0 ; n < plen ; n ++ ) { buffer [ n ] ^= mask_bytes [ n % 4 ] ; } } lua_pushlstring ( L , buffer , ( size_t ) plen ) ; lua_pushboolean ( L , fin ) ; return 2 ; } if ( opcode == 0x09 ) { char frame [ 2 ] ; plen = 2 ; frame [ 0 ] = 0x8A ; frame [ 1 ] = 0 ; apr_socket_send ( sock , frame , & plen ) ;  lua_websocket_read ( L ) ;  } } } return 0 ; }", rv ; int do_read = 1 ; int  -> connection ) ; while ( do_read ) { do_read = 0  plen ) ; do_read = 1 ; }  } } }
704,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , rescale_intercept , rescale_slope , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1"" , MagickPathExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; rescale_intercept = 0 ; rescale_slope = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX%4ld%s-%s(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%dquantum=%d"" ""length=%dgroup=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corruptedimage-tryingexplicitformat\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : {  for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ )  photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; polarity = LocaleCompare ( photometric , ""MONOCHROME1"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 :  {  number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , """" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( depth ) ;  for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ )  scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; PixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { if ( signed_data ) pixel_value = ReadDCMSignedShort ( stream_info , image ) ; else pixel_value = ReadDCMShort ( stream_info , image ) ; if ( polarity != MagickFalse ) pixel_value = ( int ) max_value - pixel_value ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMSignedShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) index , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) {  pixel . red = scale [ pixel . red ] ;   pixel . green = scale [ pixel . green ] ;   pixel . blue = scale [ pixel . blue ] ;  } } SetPixelRed ( image , ( Quantum ) pixel . red , q ) ; SetPixelGreen ( image , ( Quantum ) pixel . green , q ) ; SetPixelBlue ( image , ( Quantum ) pixel . blue , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) ( ( ( size_t ) GetPixelIndex ( image , q ) ) | ( ( ( size_t ) index ) << 8 ) ) , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( image , ( Quantum ) ( ( ( size_t ) GetPixelRed ( image , q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( ( size_t ) GetPixelGreen ( image , q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( ( size_t ) GetPixelBlue ( image , q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }", 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ;  0x0008 : { if ( data == ( unsigned char * ) NULL ) break ;  0 ; i <=  ( ssize_t )  ( ssize_t )  GetQuantumRange ( depth  GetQuantumRange ( depth  ) ; i  NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) )  red ] ; if ( pixel . green <= GetQuantumRange ( depth ) )  green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
705,"CWE-284 void btsnoop_net_write ( const void * data , size_t length ) { # if ( ! defined ( BT_NET_DEBUG ) || ( BT_NET_DEBUG != TRUE ) ) return ; # endif pthread_mutex_lock ( & client_socket_lock_ ) ; if ( client_socket_ != - 1 ) {  if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) {  safe_close_ ( & client_socket_ ) ; } } pthread_mutex_unlock ( & client_socket_lock_ ) ; }"," { if ( TEMP_FAILURE_RETRY (  length , 0 )"
706,"CWE-400 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { struct mount * n , * p ; bool done ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ;  return 0 ;  }"," ) ; return count_mounts ( m -> mnt_ns , child )  ; } "
707,"CWE-119 static void tokenadd ( struct jv_parser * p , char c ) { assert ( p -> tokenpos <= p -> tokenlen ) ;  if ( p -> tokenpos == p -> tokenlen ) {  p -> tokenlen = p -> tokenlen * 2 + 256 ; p -> tokenbuf = jv_mem_realloc ( p -> tokenbuf , p -> tokenlen ) ; } assert ( p -> tokenpos < p -> tokenlen ) ; p -> tokenbuf [ p -> tokenpos ++ ] = c ; }", p -> tokenpos >= (  p -> tokenlen  p -> tokenlen - 1 )
708,"CWE-119 static int DecodeNumberField ( int len , char * str , int fmask , int * tmask , struct tm * tm , fsec_t * fsec , int * is2digits ) { char * cp ; if ( ( cp = strchr ( str , '.' ) ) != NULL ) { # ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;  strcpy ( fstr , ( cp + 1 ) ) ; strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , NULL , 10 ) ; # else * fsec = strtod ( cp , NULL ) ; # endif * cp = '\\0' ; len = strlen ( str ) ; } else if ( ( fmask & DTK_DATE_M ) != DTK_DATE_M ) { if ( len == 8 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 6 ) ; * ( str + 6 ) = '\\0' ; tm -> tm_mon = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_year = atoi ( str + 0 ) ; return DTK_DATE ; } else if ( len == 6 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_mon = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } else if ( len == 5 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_mon = 1 ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } } if ( ( fmask & DTK_TIME_M ) != DTK_TIME_M ) { if ( len == 6 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } else if ( len == 4 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = 0 ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } } return - 1 ; }", char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ]  = '\\0' ;
709,"CWE-787 char * parse_tags ( ASS_Renderer * render_priv , char * p , char * end , double pwr ) { for ( char * q ; p < end ; p = q ) { while ( * p != '\\\\' && p != end ) ++ p ; if ( * p != '\\\\' ) break ; ++ p ; if ( p != end ) skip_spaces ( & p ) ; q = p ; while ( * q != '(' && * q != '\\\\' && q != end ) ++ q ; if ( q == p ) continue ; char * name_end = q ; struct arg args [ MAX_VALID_NARGS + 1 ] ; int nargs = 0 ; for ( int i = 0 ; i <= MAX_VALID_NARGS ; ++ i ) args [ i ] . start = args [ i ] . end = """" ; if ( * q == '(' ) { ++ q ; while ( 1 ) { if ( q != end ) skip_spaces ( & q ) ; char * r = q ; while ( * r != ',' && * r != '\\\\' && * r != ')' && r != end ) ++ r ; if ( * r == ',' ) { push_arg ( args , & nargs , q , r ) ; q = r + 1 ; } else { while ( * r != ')' && r != end ) ++ r ; push_arg ( args , & nargs , q , r ) ; q = r ; if ( q != end ) ++ q ; break ; } } } # define tag ( name ) ( mystrcmp ( & p , ( name ) ) && ( push_arg ( args , & nargs , p , name_end ) , 1 ) ) # define complex_tag ( name ) mystrcmp ( & p , ( name ) ) if ( tag ( ""xbord"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val = render_priv -> state . border_x * ( 1 - pwr ) + val * pwr ; val = ( val < 0 ) ? 0 : val ; } else val = render_priv -> state . style -> Outline ; render_priv -> state . border_x = val ; } else if ( tag ( ""ybord"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val = render_priv -> state . border_y * ( 1 - pwr ) + val * pwr ; val = ( val < 0 ) ? 0 : val ; } else val = render_priv -> state . style -> Outline ; render_priv -> state . border_y = val ; } else if ( tag ( ""xshad"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val = render_priv -> state . shadow_x * ( 1 - pwr ) + val * pwr ; } else val = render_priv -> state . style -> Shadow ; render_priv -> state . shadow_x = val ; } else if ( tag ( ""yshad"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val = render_priv -> state . shadow_y * ( 1 - pwr ) + val * pwr ; } else val = render_priv -> state . style -> Shadow ; render_priv -> state . shadow_y = val ; } else if ( tag ( ""fax"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; render_priv -> state . fax = val * pwr + render_priv -> state . fax * ( 1 - pwr ) ; } else render_priv -> state . fax = 0. ; } else if ( tag ( ""fay"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; render_priv -> state . fay = val * pwr + render_priv -> state . fay * ( 1 - pwr ) ; } else render_priv -> state . fay = 0. ; } else if ( complex_tag ( ""iclip"" ) ) { if ( nargs == 4 ) { int x0 , y0 , x1 , y1 ; x0 = argtoi ( args [ 0 ] ) ; y0 = argtoi ( args [ 1 ] ) ; x1 = argtoi ( args [ 2 ] ) ; y1 = argtoi ( args [ 3 ] ) ; render_priv -> state . clip_x0 = render_priv -> state . clip_x0 * ( 1 - pwr ) + x0 * pwr ; render_priv -> state . clip_x1 = render_priv -> state . clip_x1 * ( 1 - pwr ) + x1 * pwr ; render_priv -> state . clip_y0 = render_priv -> state . clip_y0 * ( 1 - pwr ) + y0 * pwr ; render_priv -> state . clip_y1 = render_priv -> state . clip_y1 * ( 1 - pwr ) + y1 * pwr ; render_priv -> state . clip_mode = 1 ; } else if ( ! render_priv -> state . clip_drawing ) { if ( parse_vector_clip ( render_priv , args , nargs ) ) render_priv -> state . clip_drawing_mode = 1 ; } } else if ( tag ( ""blur"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val = render_priv -> state . blur * ( 1 - pwr ) + val * pwr ; val = ( val < 0 ) ? 0 : val ; val = ( val > BLUR_MAX_RADIUS ) ? BLUR_MAX_RADIUS : val ; render_priv -> state . blur = val ; } else render_priv -> state . blur = 0.0 ; } else if ( tag ( ""fscx"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) / 100 ; val = render_priv -> state . scale_x * ( 1 - pwr ) + val * pwr ; val = ( val < 0 ) ? 0 : val ; } else val = render_priv -> state . style -> ScaleX ; render_priv -> state . scale_x = val ; } else if ( tag ( ""fscy"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) / 100 ; val = render_priv -> state . scale_y * ( 1 - pwr ) + val * pwr ; val = ( val < 0 ) ? 0 : val ; } else val = render_priv -> state . style -> ScaleY ; render_priv -> state . scale_y = val ; } else if ( tag ( ""fsc"" ) ) { render_priv -> state . scale_x = render_priv -> state . style -> ScaleX ; render_priv -> state . scale_y = render_priv -> state . style -> ScaleY ; } else if ( tag ( ""fsp"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; render_priv -> state . hspacing = render_priv -> state . hspacing * ( 1 - pwr ) + val * pwr ; } else render_priv -> state . hspacing = render_priv -> state . style -> Spacing ; } else if ( tag ( ""fs"" ) ) { double val = 0 ; if ( nargs ) { val = argtod ( * args ) ; if ( * args -> start == '+' || * args -> start == '-' ) val = render_priv -> state . font_size * ( 1 + pwr * val / 10 ) ; else val = render_priv -> state . font_size * ( 1 - pwr ) + val * pwr ; } if ( val <= 0 ) val = render_priv -> state . style -> FontSize ; if ( render_priv -> state . font ) change_font_size ( render_priv , val ) ; } else if ( tag ( ""bord"" ) ) { double val , xval , yval ; if ( nargs ) { val = argtod ( * args ) ; xval = render_priv -> state . border_x * ( 1 - pwr ) + val * pwr ; yval = render_priv -> state . border_y * ( 1 - pwr ) + val * pwr ; xval = ( xval < 0 ) ? 0 : xval ; yval = ( yval < 0 ) ? 0 : yval ; } else xval = yval = render_priv -> state . style -> Outline ; render_priv -> state . border_x = xval ; render_priv -> state . border_y = yval ; } else if ( complex_tag ( ""move"" ) ) { double x1 , x2 , y1 , y2 ; long long t1 , t2 , delta_t , t ; double x , y ; double k ; if ( nargs == 4 || nargs == 6 ) { x1 = argtod ( args [ 0 ] ) ; y1 = argtod ( args [ 1 ] ) ; x2 = argtod ( args [ 2 ] ) ; y2 = argtod ( args [ 3 ] ) ; t1 = t2 = 0 ; if ( nargs == 6 ) { t1 = argtoll ( args [ 4 ] ) ; t2 = argtoll ( args [ 5 ] ) ; if ( t1 > t2 ) { long long tmp = t2 ; t2 = t1 ; t1 = tmp ; } } } else continue ; if ( t1 <= 0 && t2 <= 0 ) { t1 = 0 ; t2 = render_priv -> state . event -> Duration ; } delta_t = t2 - t1 ; t = render_priv -> time - render_priv -> state . event -> Start ; if ( t <= t1 ) k = 0. ; else if ( t >= t2 ) k = 1. ; else k = ( ( double ) ( t - t1 ) ) / delta_t ; x = k * ( x2 - x1 ) + x1 ; y = k * ( y2 - y1 ) + y1 ; if ( render_priv -> state . evt_type != EVENT_POSITIONED ) { render_priv -> state . pos_x = x ; render_priv -> state . pos_y = y ; render_priv -> state . detect_collisions = 0 ; render_priv -> state . evt_type = EVENT_POSITIONED ; } } else if ( tag ( ""frx"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val *= M_PI / 180 ; render_priv -> state . frx = val * pwr + render_priv -> state . frx * ( 1 - pwr ) ; } else render_priv -> state . frx = 0. ; } else if ( tag ( ""fry"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val *= M_PI / 180 ; render_priv -> state . fry = val * pwr + render_priv -> state . fry * ( 1 - pwr ) ; } else render_priv -> state . fry = 0. ; } else if ( tag ( ""frz"" ) || tag ( ""fr"" ) ) { double val ; if ( nargs ) { val = argtod ( * args ) ; val *= M_PI / 180 ; render_priv -> state . frz = val * pwr + render_priv -> state . frz * ( 1 - pwr ) ; } else render_priv -> state . frz = M_PI * render_priv -> state . style -> Angle / 180. ; } else if ( tag ( ""fn"" ) ) { char * family ; char * start = args -> start ; if ( nargs && strncmp ( start , ""0"" , args -> end - start ) ) { skip_spaces ( & start ) ; family = strndup ( start , args -> end - start ) ; } else family = strdup ( render_priv -> state . style -> FontName ) ; free ( render_priv -> state . family ) ; render_priv -> state . family = family ; update_font ( render_priv ) ; } else if ( tag ( ""alpha"" ) ) { int i ; if ( nargs ) { int32_t a = parse_alpha_tag ( args -> start ) ; for ( i = 0 ; i < 4 ; ++ i ) change_alpha ( & render_priv -> state . c [ i ] , a , pwr ) ; } else { change_alpha ( & render_priv -> state . c [ 0 ] , _a ( render_priv -> state . style -> PrimaryColour ) , 1 ) ; change_alpha ( & render_priv -> state . c [ 1 ] , _a ( render_priv -> state . style -> SecondaryColour ) , 1 ) ; change_alpha ( & render_priv -> state . c [ 2 ] , _a ( render_priv -> state . style -> OutlineColour ) , 1 ) ; change_alpha ( & render_priv -> state . c [ 3 ] , _a ( render_priv -> state . style -> BackColour ) , 1 ) ; } } else if ( tag ( ""an"" ) ) { int val = argtoi ( * args ) ; if ( ( render_priv -> state . parsed_tags & PARSED_A ) == 0 ) { if ( val >= 1 && val <= 9 ) render_priv -> state . alignment = numpad2align ( val ) ; else render_priv -> state . alignment = render_priv -> state . style -> Alignment ; render_priv -> state . parsed_tags |= PARSED_A ; } } else if ( tag ( ""a"" ) ) { int val = argtoi ( * args ) ; if ( ( render_priv -> state . parsed_tags & PARSED_A ) == 0 ) { if ( val >= 1 && val <= 11 ) render_priv -> state . alignment = ( ( val & 3 ) == 0 ) ? 5 : val ; else render_priv -> state . alignment = render_priv -> state . style -> Alignment ; render_priv -> state . parsed_tags |= PARSED_A ; } } else if ( complex_tag ( ""pos"" ) ) { double v1 , v2 ; if ( nargs == 2 ) { v1 = argtod ( args [ 0 ] ) ; v2 = argtod ( args [ 1 ] ) ; } else continue ; if ( render_priv -> state . evt_type == EVENT_POSITIONED ) { ass_msg ( render_priv -> library , MSGL_V , ""Subtitlehasanew\\\\pos"" ""after\\\\moveor\\\\pos,ignoring"" ) ; } else { render_priv -> state . evt_type = EVENT_POSITIONED ; render_priv -> state . detect_collisions = 0 ; render_priv -> state . pos_x = v1 ; render_priv -> state . pos_y = v2 ; } } else if ( complex_tag ( ""fade"" ) || complex_tag ( ""fad"" ) ) { int a1 , a2 , a3 ; long long t1 , t2 , t3 , t4 ; if ( nargs == 2 ) { a1 = 0xFF ; a2 = 0 ; a3 = 0xFF ; t1 = - 1 ; t2 = argtoll ( args [ 0 ] ) ; t3 = argtoll ( args [ 1 ] ) ; t4 = - 1 ; } else if ( nargs == 7 ) { a1 = argtoi ( args [ 0 ] ) ; a2 = argtoi ( args [ 1 ] ) ; a3 = argtoi ( args [ 2 ] ) ; t1 = argtoll ( args [ 3 ] ) ; t2 = argtoll ( args [ 4 ] ) ; t3 = argtoll ( args [ 5 ] ) ; t4 = argtoll ( args [ 6 ] ) ; } else continue ; if ( t1 == - 1 && t4 == - 1 ) { t1 = 0 ; t4 = render_priv -> state . event -> Duration ; t3 = t4 - t3 ; } if ( ( render_priv -> state . parsed_tags & PARSED_FADE ) == 0 ) { render_priv -> state . fade = interpolate_alpha ( render_priv -> time - render_priv -> state . event -> Start , t1 , t2 , t3 , t4 , a1 , a2 , a3 ) ; render_priv -> state . parsed_tags |= PARSED_FADE ; } } else if ( complex_tag ( ""org"" ) ) { double v1 , v2 ; if ( nargs == 2 ) { v1 = argtod ( args [ 0 ] ) ; v2 = argtod ( args [ 1 ] ) ; } else continue ; if ( ! render_priv -> state . have_origin ) { render_priv -> state . org_x = v1 ; render_priv -> state . org_y = v2 ; render_priv -> state . have_origin = 1 ; render_priv -> state . detect_collisions = 0 ; } } else if ( complex_tag ( ""t"" ) ) { double accel ; int cnt = nargs - 1 ; long long t1 , t2 , t , delta_t ; double k ; if ( cnt == 3 ) { t1 = argtoll ( args [ 0 ] ) ; t2 = argtoll ( args [ 1 ] ) ; accel = argtod ( args [ 2 ] ) ; } else if ( cnt == 2 ) { t1 = argtoll ( args [ 0 ] ) ; t2 = argtoll ( args [ 1 ] ) ; accel = 1. ; } else if ( cnt == 1 ) { t1 = 0 ; t2 = 0 ; accel = argtod ( args [ 0 ] ) ; } else if ( cnt == 0 ) { t1 = 0 ; t2 = 0 ; accel = 1. ; } else continue ; render_priv -> state . detect_collisions = 0 ; if ( t2 == 0 ) t2 = render_priv -> state . event -> Duration ; delta_t = t2 - t1 ; t = render_priv -> time - render_priv -> state . event -> Start ; if ( t <= t1 ) k = 0. ; else if ( t >= t2 ) k = 1. ; else { assert ( delta_t != 0. ) ; k = pow ( ( ( double ) ( t - t1 ) ) / delta_t , accel ) ; } p = args [ cnt ] . start ;  p = parse_tags ( render_priv , p , args [ cnt ] . end , k ) ;  } else if ( complex_tag ( ""clip"" ) ) { if ( nargs == 4 ) { int x0 , y0 , x1 , y1 ; x0 = argtoi ( args [ 0 ] ) ; y0 = argtoi ( args [ 1 ] ) ; x1 = argtoi ( args [ 2 ] ) ; y1 = argtoi ( args [ 3 ] ) ; render_priv -> state . clip_x0 = render_priv -> state . clip_x0 * ( 1 - pwr ) + x0 * pwr ; render_priv -> state . clip_x1 = render_priv -> state . clip_x1 * ( 1 - pwr ) + x1 * pwr ; render_priv -> state . clip_y0 = render_priv -> state . clip_y0 * ( 1 - pwr ) + y0 * pwr ; render_priv -> state . clip_y1 = render_priv -> state . clip_y1 * ( 1 - pwr ) + y1 * pwr ; render_priv -> state . clip_mode = 0 ; } else if ( ! render_priv -> state . clip_drawing ) { if ( parse_vector_clip ( render_priv , args , nargs ) ) render_priv -> state . clip_drawing_mode = 0 ; } } else if ( tag ( ""c"" ) || tag ( ""1c"" ) ) { if ( nargs ) { uint32_t val = parse_color_tag ( args -> start ) ; change_color ( & render_priv -> state . c [ 0 ] , val , pwr ) ; } else change_color ( & render_priv -> state . c [ 0 ] , render_priv -> state . style -> PrimaryColour , 1 ) ; } else if ( tag ( ""2c"" ) ) { if ( nargs ) { uint32_t val = parse_color_tag ( args -> start ) ; change_color ( & render_priv -> state . c [ 1 ] , val , pwr ) ; } else change_color ( & render_priv -> state . c [ 1 ] , render_priv -> state . style -> SecondaryColour , 1 ) ; } else if ( tag ( ""3c"" ) ) { if ( nargs ) { uint32_t val = parse_color_tag ( args -> start ) ; change_color ( & render_priv -> state . c [ 2 ] , val , pwr ) ; } else change_color ( & render_priv -> state . c [ 2 ] , render_priv -> state . style -> OutlineColour , 1 ) ; } else if ( tag ( ""4c"" ) ) { if ( nargs ) { uint32_t val = parse_color_tag ( args -> start ) ; change_color ( & render_priv -> state . c [ 3 ] , val , pwr ) ; } else change_color ( & render_priv -> state . c [ 3 ] , render_priv -> state . style -> BackColour , 1 ) ; } else if ( tag ( ""1a"" ) ) { if ( nargs ) { uint32_t val = parse_alpha_tag ( args -> start ) ; change_alpha ( & render_priv -> state . c [ 0 ] , val , pwr ) ; } else change_alpha ( & render_priv -> state . c [ 0 ] , _a ( render_priv -> state . style -> PrimaryColour ) , 1 ) ; } else if ( tag ( ""2a"" ) ) { if ( nargs ) { uint32_t val = parse_alpha_tag ( args -> start ) ; change_alpha ( & render_priv -> state . c [ 1 ] , val , pwr ) ; } else change_alpha ( & render_priv -> state . c [ 1 ] , _a ( render_priv -> state . style -> SecondaryColour ) , 1 ) ; } else if ( tag ( ""3a"" ) ) { if ( nargs ) { uint32_t val = parse_alpha_tag ( args -> start ) ; change_alpha ( & render_priv -> state . c [ 2 ] , val , pwr ) ; } else change_alpha ( & render_priv -> state . c [ 2 ] , _a ( render_priv -> state . style -> OutlineColour ) , 1 ) ; } else if ( tag ( ""4a"" ) ) { if ( nargs ) { uint32_t val = parse_alpha_tag ( args -> start ) ; change_alpha ( & render_priv -> state . c [ 3 ] , val , pwr ) ; } else change_alpha ( & render_priv -> state . c [ 3 ] , _a ( render_priv -> state . style -> BackColour ) , 1 ) ; } else if ( tag ( ""r"" ) ) { if ( nargs ) { int len = args -> end - args -> start ; reset_render_context ( render_priv , lookup_style_strict ( render_priv -> track , args -> start , len ) ) ; } else reset_render_context ( render_priv , NULL ) ; } else if ( tag ( ""be"" ) ) { double dval ; if ( nargs ) { int val ; dval = argtod ( * args ) ; val = ( int ) ( render_priv -> state . be * ( 1 - pwr ) + dval * pwr + 0.5 ) ; val = ( val < 0 ) ? 0 : val ; val = ( val > MAX_BE ) ? MAX_BE : val ; render_priv -> state . be = val ; } else render_priv -> state . be = 0 ; } else if ( tag ( ""b"" ) ) { int val = argtoi ( * args ) ; if ( ! nargs || ! ( val == 0 || val == 1 || val >= 100 ) ) val = render_priv -> state . style -> Bold ; render_priv -> state . bold = val ; update_font ( render_priv ) ; } else if ( tag ( ""i"" ) ) { int val = argtoi ( * args ) ; if ( ! nargs || ! ( val == 0 || val == 1 ) ) val = render_priv -> state . style -> Italic ; render_priv -> state . italic = val ; update_font ( render_priv ) ; } else if ( tag ( ""kf"" ) || tag ( ""K"" ) ) { double val = 100 ; if ( nargs ) val = argtod ( * args ) ; render_priv -> state . effect_type = EF_KARAOKE_KF ; if ( render_priv -> state . effect_timing ) render_priv -> state . effect_skip_timing += render_priv -> state . effect_timing ; render_priv -> state . effect_timing = val * 10 ; } else if ( tag ( ""ko"" ) ) { double val = 100 ; if ( nargs ) val = argtod ( * args ) ; render_priv -> state . effect_type = EF_KARAOKE_KO ; if ( render_priv -> state . effect_timing ) render_priv -> state . effect_skip_timing += render_priv -> state . effect_timing ; render_priv -> state . effect_timing = val * 10 ; } else if ( tag ( ""k"" ) ) { double val = 100 ; if ( nargs ) val = argtod ( * args ) ; render_priv -> state . effect_type = EF_KARAOKE ; if ( render_priv -> state . effect_timing ) render_priv -> state . effect_skip_timing += render_priv -> state . effect_timing ; render_priv -> state . effect_timing = val * 10 ; } else if ( tag ( ""shad"" ) ) { double val , xval , yval ; if ( nargs ) { val = argtod ( * args ) ; xval = render_priv -> state . shadow_x * ( 1 - pwr ) + val * pwr ; yval = render_priv -> state . shadow_y * ( 1 - pwr ) + val * pwr ; xval = ( xval < 0 ) ? 0 : xval ; yval = ( yval < 0 ) ? 0 : yval ; } else xval = yval = render_priv -> state . style -> Shadow ; render_priv -> state . shadow_x = xval ; render_priv -> state . shadow_y = yval ; } else if ( tag ( ""s"" ) ) { int val = argtoi ( * args ) ; if ( ! nargs || ! ( val == 0 || val == 1 ) ) val = render_priv -> state . style -> StrikeOut ; if ( val ) render_priv -> state . flags |= DECO_STRIKETHROUGH ; else render_priv -> state . flags &= ~ DECO_STRIKETHROUGH ; } else if ( tag ( ""u"" ) ) { int val = argtoi ( * args ) ; if ( ! nargs || ! ( val == 0 || val == 1 ) ) val = render_priv -> state . style -> Underline ; if ( val ) render_priv -> state . flags |= DECO_UNDERLINE ; else render_priv -> state . flags &= ~ DECO_UNDERLINE ; } else if ( tag ( ""pbo"" ) ) { double val = argtod ( * args ) ; render_priv -> state . pbo = val ; } else if ( tag ( ""p"" ) ) { int val = argtoi ( * args ) ; val = ( val < 0 ) ? 0 : val ; render_priv -> state . drawing_scale = val ; } else if ( tag ( ""q"" ) ) { int val = argtoi ( * args ) ; if ( ! nargs || ! ( val >= 0 && val <= 3 ) ) val = render_priv -> track -> WrapStyle ; render_priv -> state . wrap_style = val ; } else if ( tag ( ""fe"" ) ) { int val ; if ( nargs ) val = argtoi ( * args ) ; else val = render_priv -> state . style -> Encoding ; render_priv -> state . font_encoding = val ; } } return p ; }", . start ; if ( args [ cnt ] . end < end ) {  k ) ; } else { assert ( q == end ) ; pwr = k ; q = p ; }
710,"CWE-285 static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) {  error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;  if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ;  if ( error == 0 )  acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }"," { error = posix_acl_update_mode ( inode  , & inode  inode -> i_mode , & acl ) ; if ( error ) return error ;  inode -> i_ctime  inode ) ;  } break ;"
711,"CWE-119 void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) {  size_t len = 0 ;  lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }"," len = 0 ; luaL_checkstack ( L , 3 , ""infunctionmp_encode_lua_table_as_map"" )"
712,"CWE-125 static MagickBooleanType load_tile ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) { ssize_t y ; register ssize_t x ; register Quantum * q ; ssize_t count ; unsigned char * graydata ; XCFPixelInfo * xcfdata , * xcfodata ;  xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ;  if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; xcfodata = xcfdata ; graydata = ( unsigned char * ) xcfdata ; count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; if ( count != ( ssize_t ) data_length ) ThrowBinaryException ( CorruptImageError , ""NotEnoughPixelData"" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( inDocInfo -> image_type == GIMP_GRAY ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; graydata ++ ; q += GetPixelChannels ( tile_image ) ; } } else if ( inDocInfo -> image_type == GIMP_RGB ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; xcfdata ++ ; q += GetPixelChannels ( tile_image ) ; } } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; } xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; return MagickTrue ; }"," ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows )  , sizeof ("
713,"CWE-200 static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB )  goto out ;  if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  }  if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }", ) goto out  ; if (  ) ) ; * addr_len = sizeof ( * sin ) ;
714,"CWE-119 void vp9_end_first_pass ( VP9_COMP * cpi ) {  if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) {  int i ; for ( i = 0 ; i < cpi -> svc . number_spatial_layers ; ++ i ) { output_stats ( & cpi -> svc . layer_context [ i ] . twopass . total_stats , cpi -> output_pkt_list ) ; } } else { output_stats ( & cpi -> twopass . total_stats , cpi -> output_pkt_list ) ; } }", { if ( is_two_pass_svc ( cpi )  ) { int
715,"CWE-20 static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , anum_t last , int restore ) { struct NntpData * nntp_data = ctx -> data ; struct FetchCtx fc ; struct Header * hdr = NULL ; char buf [ HUGE_STRING ] ; int rc = 0 ; int oldmsgcount = ctx -> msgcount ; anum_t current ; anum_t first_over = first ; # ifdef USE_HCACHE void * hdata = NULL ; # endif if ( ! last || first > last ) return 0 ; fc . ctx = ctx ; fc . first = first ; fc . last = last ; fc . restore = restore ;  fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;  # ifdef USE_HCACHE fc . hc = hc ; # endif if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) { if ( ! ctx -> quiet ) mutt_message ( _ ( ""Fetchinglistofarticles..."" ) ) ; if ( nntp_data -> nserv -> hasLISTGROUPrange ) snprintf ( buf , sizeof ( buf ) , ""LISTGROUP%s%u-%u\\r\\n"" , nntp_data -> group , first , last ) ; else snprintf ( buf , sizeof ( buf ) , ""LISTGROUP%s\\r\\n"" , nntp_data -> group ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ; if ( rc > 0 ) { mutt_error ( ""LISTGROUP:%s"" , buf ) ; } if ( rc == 0 ) { for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( fc . messages [ current - first ] ) continue ; snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#1mutt_bcache_del%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } # ifdef USE_HCACHE if ( fc . hc ) { mutt_debug ( 2 , ""mutt_hcache_delete%s\\n"" , buf ) ; mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ; } # endif } } } else { for ( current = first ; current <= last ; current ++ ) fc . messages [ current - first ] = 1 ; } if ( ! ctx -> quiet ) { mutt_progress_init ( & fc . progress , _ ( ""Fetchingmessageheaders..."" ) , MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ; } for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ; # ifdef USE_HCACHE snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; # endif if ( ! fc . messages [ current - first ] ) continue ; if ( ctx -> msgcount >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; # ifdef USE_HCACHE hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ; if ( hdata ) { mutt_debug ( 2 , ""mutt_hcache_fetch%s\\n"" , buf ) ; ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ; mutt_hcache_free ( fc . hc , & hdata ) ; hdr -> data = 0 ; if ( hdr -> deleted && ! restore ) { mutt_header_free ( & hdr ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , ""#2mutt_bcache_del%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } continue ; } hdr -> read = false ; hdr -> old = false ; } else # endif if ( nntp_data -> deleted ) continue ; else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) { if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) break ; else continue ; } else { FILE * fp = mutt_file_mkstemp ( ) ; if ( ! fp ) { mutt_perror ( ""mutt_file_mkstemp()failed!"" ) ; rc = - 1 ; break ; } snprintf ( buf , sizeof ( buf ) , ""HEAD%u\\r\\n"" , current ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ; if ( rc ) { mutt_file_fclose ( & fp ) ; if ( rc < 0 ) break ; if ( mutt_str_strncmp ( ""423"" , buf , 3 ) != 0 ) { mutt_error ( ""HEAD:%s"" , buf ) ; break ; } if ( nntp_data -> bcache ) { snprintf ( buf , sizeof ( buf ) , ""%u"" , current ) ; mutt_debug ( 2 , ""#3mutt_bcache_del%s\\n"" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } rc = 0 ; continue ; } hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ; hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ; hdr -> received = hdr -> date_sent ; mutt_file_fclose ( & fp ) ; } hdr -> index = ctx -> msgcount ++ ; hdr -> read = false ; hdr -> old = false ; hdr -> deleted = false ; hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ; NHDR ( hdr ) -> article_num = current ; if ( restore ) hdr -> changed = true ; else { nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ; if ( ! hdr -> read ) nntp_parse_xref ( ctx , hdr ) ; } if ( current > nntp_data -> last_loaded ) nntp_data -> last_loaded = current ; first_over = current + 1 ; } if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) current = first_over ; if ( current <= last && rc == 0 && ! nntp_data -> deleted ) { char * cmd = nntp_data -> nserv -> hasOVER ? ""OVER"" : ""XOVER"" ; snprintf ( buf , sizeof ( buf ) , ""%s%u-%u\\r\\n"" , cmd , current , last ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ; if ( rc > 0 ) { mutt_error ( ""%s:%s"" , cmd , buf ) ; } } if ( ctx -> msgcount > oldmsgcount ) mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ; FREE ( & fc . messages ) ; if ( rc != 0 ) return - 1 ; mutt_clear_error ( ) ; return 0 ; }", char ) ) ; if ( fc . messages == NULL ) return - 1
716,"CWE-125 void bit_write_UMC ( Bit_Chain * dat , BITCODE_UMC val ) { int i , j ; int negative ; unsigned char byte [ 5 ] ; BITCODE_UMC mask ; BITCODE_UMC value ; value = val ; mask = 0x0000007f ; for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ;  if ( byte [ i ] & 0x40 )  i -- ; byte [ i ] &= 0x7f ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }", ] & 0x40 && i > 0
717,"CWE-399 static int xfrm6_tunnel_rcv ( struct sk_buff * skb ) { struct ipv6hdr * iph = ipv6_hdr ( skb ) ; __be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ;  return xfrm6_rcv_spi ( skb , spi ) ;  }"," , spi ) > 0 ? : 0"
718,"CWE-399 static void unix_detach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; scm -> fp = UNIXCB ( skb ) . fp ; UNIXCB ( skb ) . fp = NULL ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- )  unix_notinflight ( scm -> fp -> fp [ i ] ) ;  }"," -> fp -> user , scm -> fp ->"
719,"CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , ""."" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-mem-track"" ) || ! strcmp ( arg , ""-mem-track-stack"" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , ""-mem-track-stack"" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , ""WARNING-GPACnotcompiledwithMemoryTracker-ignoring\\""%s\\""\\n"" , arg ) ; # endif } else if ( ! strcmp ( arg , ""-gui"" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , ""-guid"" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , ""-h"" ) || ! strcmp ( arg , ""-help"" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , ""Error:ConfigurationFilenotfound\\n"" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , ""General"" , ""Logs"" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , ""General"" , ""Logs"" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , ""General"" , ""ForceGUI"" ) ; if ( str && ! strcmp ( str , ""yes"" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-rti"" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-rtix"" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , ""-size"" ) ) { if ( sscanf ( argv [ i + 1 ] , ""%dx%d"" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , ""-quiet"" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , ""-strict-error"" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , ""-log-file"" ) || ! strcmp ( arg , ""-lf"" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , ""wt"" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , ""-logs"" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , ""-log-clock"" ) || ! strcmp ( arg , ""-lc"" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , ""-log-utc"" ) || ! strcmp ( arg , ""-lu"" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , ""-thread"" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , ""-no-thread"" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , ""-no-cthread"" ) || ! strcmp ( arg , ""-no-compositor-thread"" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , ""-no-audio"" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , ""-no-regulation"" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , ""-fs"" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , ""-opt"" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-conf"" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , ""-ifce"" ) ) { gf_cfg_set_key ( cfg_file , ""Network"" , ""DefaultMCastInterface"" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , ""-help"" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , ""-noprog"" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , ""-no-save"" ) || ! stricmp ( arg , ""--no-save"" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , ""-ntp-shift"" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , ""-run-for"" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , ""-out"" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-fps"" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-avi"" ) || ! strcmp ( arg , ""-sha"" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , ""-sha"" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , ""-avi"" ) && ( nb_times != 2 ) ) { fprintf ( stderr , ""Onlyonetimeargfoundfor-avi-checkusage\\n"" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , ""-rgbds"" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , ""-rgbd"" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , ""-depth"" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , ""-bmp"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , ""-png"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , ""-raw"" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , ""-scale"" ) ) { sscanf ( argv [ i + 1 ] , ""%f"" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , ""SeveralinputURLsprovided(\\""%s\\"",\\""%s\\"").Checkyourcommand-line.\\n"" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , ""-loop"" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , ""-bench"" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , ""-vbench"" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , ""-sbench"" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , ""-no-addon"" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , ""-pause"" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , ""-play-from"" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , ""-speed"" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , ""-no-wnd"" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , ""-no-back"" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , ""-align"" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , ""-fill"" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , ""-show"" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , ""-uncache"" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , ""-exit"" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , ""-views"" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-mosaic"" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , ""-com"" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , ""-service"" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , ""GPACConfigupdated\\n"" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , ""General"" , ""CacheDirectory"" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , ""GPACCachedir%sflattened\\n"" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) ; test = url_arg ? gf_fopen ( url_arg , ""rt"" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , ""Missingargumentfordump\\n"" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , ""General"" , ""ModulesDirectory"" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , ""Systeminfo:%dMBRAM-%dcores\\n"" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , ""Audio"" , ""DriverName"" , ""RawAudioOutput"" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , ""Error:nomodulesfound-exiting\\n"" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , ""ModulesFound:%d\\n"" , i ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""GPACVersion"" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , ""PluginsCache"" ) ; gf_cfg_set_key ( cfg_file , ""General"" , ""GPACVersion"" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , ""Audio"" , ""DriverName"" , ""RawAudioOutput"" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , ""Video"" , ""DriverName"" , ""RawVideoOutput"" ) ; gf_cfg_set_key ( user . config , ""RAWVideo"" , ""RawOutput"" , ""null"" ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""OpenGLMode"" , ""disable"" ) ; } else { gf_cfg_set_key ( user . config , ""Video"" , ""DisableVSync"" , ""yes"" ) ; } } { char dim [ 50 ] ; sprintf ( dim , ""%d"" , forced_width ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""DefaultWidth"" , forced_width ? dim : NULL ) ; sprintf ( dim , ""%d"" , forced_height ) ; gf_cfg_set_key ( user . config , ""Compositor"" , ""DefaultHeight"" , forced_height ? dim : NULL ) ; } fprintf ( stderr , ""LoadingGPACTerminal\\n"" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , ""\\nIniterror-checkyouhaveatleastonevideooutandonerasterizer...\\nFoundmodules:\\n"" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , ""TerminalLoadedin%dms\\n"" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , ""Video"" , ""DriverName"" ) ; if ( ! bench_mode && ! strcmp ( str , ""RawVideoOutput"" ) ) fprintf ( stderr , ""WARNING:usingrawoutputvideo(memoryonly)-nodisplayused\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""Audio"" , ""DriverName"" ) ; if ( ! str || ! strcmp ( str , ""NoAudioOutputAvailable"" ) ) fprintf ( stderr , ""WARNING:noaudiooutputavailable-makesurenootherprogramislockingthesoundcard\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""NoMIMETypeFetch"" ) ; no_mime_check = ( str && ! stricmp ( str , ""yes"" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , ""HTTPProxy"" , ""Enabled"" ) ; if ( str && ! strcmp ( str , ""yes"" ) ) { str = gf_cfg_get_key ( cfg_file , ""HTTPProxy"" , ""Name"" ) ; if ( str ) fprintf ( stderr , ""HTTPProxy%senabled\\n"" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , ""General"" , ""RTIRefreshPeriod"" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , ""General"" , ""RTIRefreshPeriod"" , ""200"" ) ; } UpdateRTInfo ( ""AtGPACloadtime\\n"" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Inputurl%sistoolong,truncatingto%dchars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , "".m3u"" ) || ! stricmp ( ext , "".pls"" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , ""OpeningPlaylist%s\\n"" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( ""http:"" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ;  the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;  } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , ""rt"" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , ""Failedtoopenplaylist%s:%s\\n"" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , ""Hit\'h\'forhelp\\n\\n"" ) ; } } else { fprintf ( stderr , ""OpeningURL%s\\n"" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , ""[Status:Paused]\\n"" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , ""Hit\'h\'forhelp\\n\\n"" ) ; str = gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) ; if ( str ) { strncpy ( the_url , ""MP4Client"" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , ""views://%s"" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , ""mosaic://%s"" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , ""General"" , ""StartupFile"" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , ""-com"" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , ""EntertheabsoluteURL\\n"" ) ; if ( 1 > scanf ( ""%s"" , the_url ) ) { fprintf ( stderr , ""CannotreadabsoluteURL,aborting\\n"" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , ""EntertheabsoluteURLtotheplaylist\\n"" ) ; if ( 1 > scanf ( ""%s"" , the_url ) ) { fprintf ( stderr , ""CannotreadtheabsoluteURL,aborting.\\n"" ) ; break ; } playlist = gf_fopen ( the_url , ""rt"" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , ""%s"" , the_url ) ) { fprintf ( stderr , ""CannotreadanyURLfromplaylist,aborting.\\n"" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , ""OpeningURL%s\\n"" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , ""%s"" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , ""%s"" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , ""Nomoreitems-exiting\\n"" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , ""OpeningURL%s\\n"" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( ""%u"" , & count ) ) { fprintf ( stderr , ""Cannotreadnumber,aborting.\\n"" ) ; break ; } while ( count ) { if ( fscanf ( playlist , ""%s"" , the_url ) ) { fprintf ( stderr , ""Failedtoreadline,aborting\\n"" ) ; break ; } count -- ; } fprintf ( stderr , ""OpeningURL%s\\n"" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , ""[Status:%s]\\n"" , is_pause ? ""Playing"" : ""Paused"" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , ""Steptime:"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""\\n"" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , ""scenenotseekable\\n"" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , ""Duration:"" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , ""(current%.2f%%)\\nEnterSeekpercentage:\\n"" , res ) ; if ( scanf ( ""%d"" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , ""-CurrentTime:"" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , ""\\nEnterseektime(Format:s,m:sorh:m:s):\\n"" ) ; h = m = s = 0 ; r = scanf ( ""%d:%d:%d"" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , ""CurrentTime:"" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , ""-Duration:"" ) ; PrintTime ( Duration ) ; fprintf ( stderr , ""\\n"" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , ""Root"" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , ""EnterODID(0formainOD):"" ) ; fflush ( stderr ) ; if ( scanf ( ""%ud"" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( ""%s"" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , ""EnterODnumber(0formainOD):"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%ud"" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , ""EnterInlineODIDifanyor0:"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%ud"" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , ""Enterfileradicalname(+\\\'.x\\\'forXMLdumping)-\\""std\\""forstderr:"" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( ""%s"" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , "".x"" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , ""std"" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , ""Dumpdone(%s)\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , ""Using%sfor2Ddrawing\\n"" , use_3d ? ""OpenGL"" : ""2Drasterizer"" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , ""Turningstressmode%s\\n"" , opt ? ""on"" : ""off"" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , ""StreamingCacheisrunning-pleasestopitfirst\\n"" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , ""StreamingCacheEnabled\\n"" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , ""StreamingCacheDisabled\\n"" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , ""StreamingCacheRunning\\n"" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , ""StreamingCachestopped\\n"" ) ; } else { fprintf ( stderr , ""StreamingCachenotrunning\\n"" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , ""Entercommandtosend:\\n"" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szCom ) ) { fprintf ( stderr , ""Cannotreadcommandtosend,aborting.\\n"" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , ""Processingcommandfailed:%s\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , ""EnterJavaScriptcodetoevaluate:\\n"" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , jsCode ) ) { fprintf ( stderr , ""Cannotreadcodetoevaluate,aborting.\\n"" ) ; break ; } e = gf_term_scene_update ( term , ""application/ecmascript"" , jsCode ) ; if ( e ) fprintf ( stderr , ""ProcessingJScodefailed:%s\\n"" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , ""Enternewloglevel(currenttools%s):\\n"" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( ""%s"" , szLog ) < 1 ) { fprintf ( stderr , ""Cannotreadnewloglevel,aborting.\\n"" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , ""GPACallocatedmemory"" LLD ""\\n"" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , ""EnternewvideocachememoryinkBytes(current%ud):\\n"" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( ""%ud"" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , ""Enternewhttpbitrateinbps(0fornone)-currentlimit:%d\\n"" , http_bitrate ) ; } while ( 1 > scanf ( ""%ud"" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , ""Enteroptiontoset(Section:Name=Value):\\n"" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szOpt ) ) { fprintf ( stderr , ""Cannotreadoption\\n"" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , ""Auto-stereomodedetected-typenumberofviewtodump(0ismainoutput,1to%doffscreenview,%dforalloffscreen,%dforalloffscreenandmain)\\n"" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( ""%d"" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , ""view%d_dump.png"" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , ""gpac_video_dump_"" LLU "".png"" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , ""Errordumpingscreenbuffer%s\\n"" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , ""ErrorencodingPNG%s\\n"" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , ""wb"" ) ; if ( ! png ) { fprintf ( stderr , ""Errorwritingfile%s\\n"" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , ""Dumpto%s\\n"" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , ""Done:%s\\n"" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , ""Enter0-basedindexofobjecttoselectorserviceID:\\n"" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( ""%[^\\t\\n]"" , szOpt ) ) { fprintf ( stderr , ""CannotreadODID\\n"" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , ""Cannotfindservice%d-tryingwithobjectindex\\n"" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , ""Cannotfindobjectatindex%d\\n"" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( ""Disconnected\\n"" ) ; fprintf ( stderr , ""Deletingterminal..."" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , ""done(in%dms)-ranfor%dms\\n"" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , ""GPACcleanup...\\n"" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }", [ sizeof ( the_url  ) - 1
720,"CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ;  u8 smac [ ETH_ALEN ] ;  u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ;  if ( is_iboe ) {  if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; }  mutex_lock ( & lock ) ;  if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }"," , ret ;  listen_id = cm_id  goto err3 ;  mutex_lock ( &  ( & lock  ) ; if"
721,"CWE-20 bool __skb_flow_dissect ( const struct sk_buff * skb , struct flow_dissector * flow_dissector , void * target_container , void * data , __be16 proto , int nhoff , int hlen ) { struct flow_dissector_key_control * key_control ; struct flow_dissector_key_basic * key_basic ; struct flow_dissector_key_addrs * key_addrs ; struct flow_dissector_key_ports * key_ports ; struct flow_dissector_key_tags * key_tags ; struct flow_dissector_key_keyid * key_keyid ;  u8 ip_proto = 0 ;  if ( ! data ) { data = skb -> data ; proto = skb -> protocol ; nhoff = skb_network_offset ( skb ) ; hlen = skb_headlen ( skb ) ; } key_control = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_CONTROL , target_container ) ; key_basic = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_BASIC , target_container ) ; if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_ETH_ADDRS ) ) { struct ethhdr * eth = eth_hdr ( skb ) ; struct flow_dissector_key_eth_addrs * key_eth_addrs ; key_eth_addrs = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_ETH_ADDRS , target_container ) ; memcpy ( key_eth_addrs , & eth -> h_dest , sizeof ( * key_eth_addrs ) ) ; } again : switch ( proto ) { case htons ( ETH_P_IP ) : { const struct iphdr * iph ; struct iphdr _iph ; ip : iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; if ( ! iph || iph -> ihl < 5 )  return false ;  nhoff += iph -> ihl * 4 ; ip_proto = iph -> protocol ; if ( ip_is_fragment ( iph ) ) ip_proto = 0 ; if ( ! skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_IPV4_ADDRS ) ) break ; key_addrs = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_IPV4_ADDRS , target_container ) ; memcpy ( & key_addrs -> v4addrs , & iph -> saddr , sizeof ( key_addrs -> v4addrs ) ) ; key_control -> addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS ; break ; } case htons ( ETH_P_IPV6 ) : { const struct ipv6hdr * iph ; struct ipv6hdr _iph ; __be32 flow_label ; ipv6 : iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; if ( ! iph )  return false ;  ip_proto = iph -> nexthdr ; nhoff += sizeof ( struct ipv6hdr ) ; if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_IPV6_ADDRS ) ) { struct flow_dissector_key_ipv6_addrs * key_ipv6_addrs ; key_ipv6_addrs = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_IPV6_ADDRS , target_container ) ; memcpy ( key_ipv6_addrs , & iph -> saddr , sizeof ( * key_ipv6_addrs ) ) ; key_control -> addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS ; } flow_label = ip6_flowlabel ( iph ) ; if ( flow_label ) { if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_FLOW_LABEL ) ) { key_tags = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_FLOW_LABEL , target_container ) ; key_tags -> flow_label = ntohl ( flow_label ) ; } } break ; } case htons ( ETH_P_8021AD ) : case htons ( ETH_P_8021Q ) : { const struct vlan_hdr * vlan ; struct vlan_hdr _vlan ; vlan = __skb_header_pointer ( skb , nhoff , sizeof ( _vlan ) , data , hlen , & _vlan ) ; if ( ! vlan )  return false ;  if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) { key_tags = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID , target_container ) ; key_tags -> vlan_id = skb_vlan_tag_get_id ( skb ) ; } proto = vlan -> h_vlan_encapsulated_proto ; nhoff += sizeof ( * vlan ) ; goto again ; } case htons ( ETH_P_PPP_SES ) : { struct { struct pppoe_hdr hdr ; __be16 proto ; } * hdr , _hdr ; hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr )  return false ;  proto = hdr -> proto ; nhoff += PPPOE_SES_HLEN ; switch ( proto ) { case htons ( PPP_IP ) : goto ip ; case htons ( PPP_IPV6 ) : goto ipv6 ; default :  return false ;  } } case htons ( ETH_P_TIPC ) : { struct { __be32 pre [ 3 ] ; __be32 srcnode ; } * hdr , _hdr ; hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr )  return false ;  key_basic -> n_proto = proto ; key_control -> thoff = ( u16 ) nhoff ; if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_TIPC_ADDRS ) ) { key_addrs = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_TIPC_ADDRS , target_container ) ; key_addrs -> tipcaddrs . srcnode = hdr -> srcnode ; key_control -> addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS ; }  return true ;  } case htons ( ETH_P_MPLS_UC ) : case htons ( ETH_P_MPLS_MC ) : { struct mpls_label * hdr , _hdr [ 2 ] ; mpls : hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr )  return false ;  if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) { if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_MPLS_ENTROPY ) ) { key_keyid = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_MPLS_ENTROPY , target_container ) ; key_keyid -> keyid = hdr [ 1 ] . entry & htonl ( MPLS_LS_LABEL_MASK ) ; }  key_basic -> n_proto = proto ;  key_basic -> ip_proto = ip_proto ; key_control -> thoff = ( u16 ) nhoff ; return true ; } return true ; } case htons ( ETH_P_FCOE ) : key_control -> thoff = ( u16 ) ( nhoff + FCOE_HEADER_LEN ) ; default :  return false ;  } ip_proto_again : switch ( ip_proto ) { case IPPROTO_GRE : { struct gre_hdr { __be16 flags ; __be16 proto ; } * hdr , _hdr ; hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; if ( ! hdr )  return false ;  if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ; proto = hdr -> proto ; nhoff += 4 ; if ( hdr -> flags & GRE_CSUM ) nhoff += 4 ; if ( hdr -> flags & GRE_KEY ) { const __be32 * keyid ; __be32 _keyid ; keyid = __skb_header_pointer ( skb , nhoff , sizeof ( _keyid ) , data , hlen , & _keyid ) ; if ( ! keyid )  return false ;  if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) { key_keyid = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID , target_container ) ; key_keyid -> keyid = * keyid ; } nhoff += 4 ; } if ( hdr -> flags & GRE_SEQ ) nhoff += 4 ; if ( proto == htons ( ETH_P_TEB ) ) { const struct ethhdr * eth ; struct ethhdr _eth ; eth = __skb_header_pointer ( skb , nhoff , sizeof ( _eth ) , data , hlen , & _eth ) ; if ( ! eth )  return false ;  proto = eth -> h_proto ; nhoff += sizeof ( * eth ) ; } goto again ; } case NEXTHDR_HOP : case NEXTHDR_ROUTING : case NEXTHDR_DEST : { u8 _opthdr [ 2 ] , * opthdr ; if ( proto != htons ( ETH_P_IPV6 ) ) break ; opthdr = __skb_header_pointer ( skb , nhoff , sizeof ( _opthdr ) , data , hlen , & _opthdr ) ; if ( ! opthdr )  return false ;  ip_proto = opthdr [ 0 ] ; nhoff += ( opthdr [ 1 ] + 1 ) << 3 ; goto ip_proto_again ; } case IPPROTO_IPIP : proto = htons ( ETH_P_IP ) ; goto ip ; case IPPROTO_IPV6 : proto = htons ( ETH_P_IPV6 ) ; goto ipv6 ; case IPPROTO_MPLS : proto = htons ( ETH_P_MPLS_UC ) ; goto mpls ; default : break ; }  key_basic -> n_proto = proto ;  key_basic -> ip_proto = ip_proto ; key_control -> thoff = ( u16 ) nhoff ;  if ( skb_flow_dissector_uses_key ( flow_dissector ,  FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } return true ; }"," ip_proto = 0 ; bool ret = false  < 5 ) goto out_bad  ; nhoff +=  ! iph ) goto out_bad  ; ip_proto =  ! vlan ) goto out_bad  ; if (  ! hdr ) goto out_bad  ; proto =  ; default : goto out_bad  ; } }  ! hdr ) goto out_bad  ; if (  FLOW_DISSECTOR_KEY_TIPC_ADDRS ; } goto out_good  ; } case  ! hdr ) goto out_bad  ; if (  ) ; } goto out_good ; } goto out_good  ; } case  ; default : goto out_bad  ; } ip_proto_again  ! hdr ) goto out_bad  ; if (  ! keyid ) goto out_bad  ; if (  ! eth ) goto out_bad  ; proto =  ! opthdr ) goto out_bad  ; ip_proto =  break ; } if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad :  ) nhoff ; return ret  ; } "
722,"CWE-772 static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; PixelInfo transpix ; Quantum index ; register ssize_t i , x ; register Quantum * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char  * lastrow ,  * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , ""FileFormatVersionMismatch"" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; GetPixelInfo ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { ssize_t index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  lastrow = ( unsigned char * ) NULL ;  if ( compressionType == PALM_COMPRESSION_SCANLINE ) {  lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row ,   2 * image -> columns ) , sizeof ( * lastrow ) ) ;  if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else  one_row [ i + bit ] = lastrow [ i + bit ] ;  } }  ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ;  } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;  ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;  ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } index = ( Quantum ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { ssize_t index = ConstrainColormapIndex ( image , ( ssize_t ) ( mask - transparentIndex ) , exception ) ; if ( bits_per_pixel != 16 ) transpix = image -> colormap [ index ] ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentAlpha , MagickFalse , exception ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;  if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," unsigned char * last_row  , * one_row  ""MemoryAllocationFailed"" ) ; last_row  = ( unsigned  PALM_COMPRESSION_SCANLINE ) { last_row  = ( unsigned  sizeof ( * last_row ) ) ; if ( last_row  == ( unsigned  bit ] = last_row  [ i +  ) CopyMagickMemory ( last_row  , one_row ,  == PALM_COMPRESSION_SCANLINE ) last_row  = ( unsigned  ) RelinquishMagickMemory ( last_row  ) ; ThrowReaderException  == PALM_COMPRESSION_SCANLINE ) last_row  = ( unsigned  ) RelinquishMagickMemory ( last_row  ) ; ThrowReaderException  == PALM_COMPRESSION_SCANLINE ) last_row  = ( unsigned  ) RelinquishMagickMemory ( last_row  ) ; if"
723,"CWE-119 static int logi_dj_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct dj_receiver_dev * djrcv_dev = hid_get_drvdata ( hdev ) ; struct dj_report * dj_report = ( struct dj_report * ) data ; unsigned long flags ; bool report_processed = false ;  dbg_hid ( ""%s,size:%d\\n"" , __func__ , size ) ;  spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ; if ( dj_report -> report_id == REPORT_ID_DJ_SHORT ) { switch ( dj_report -> report_type ) { case REPORT_TYPE_NOTIF_DEVICE_PAIRED : case REPORT_TYPE_NOTIF_DEVICE_UNPAIRED : logi_dj_recv_queue_notification ( djrcv_dev , dj_report ) ; break ; case REPORT_TYPE_NOTIF_CONNECTION_STATUS : if ( dj_report -> report_params [ CONNECTION_STATUS_PARAM_STATUS ] == STATUS_LINKLOSS ) { logi_dj_recv_forward_null_report ( djrcv_dev , dj_report ) ; } break ; default : logi_dj_recv_forward_report ( djrcv_dev , dj_report ) ; } report_processed = true ; } spin_unlock_irqrestore ( & djrcv_dev -> lock , flags ) ; return report_processed ; }"," size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:invaliddeviceindex:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; }"
724,"CWE-89 static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ;  int len ;  if ( ! * path ) path = ""INBOX"" ;  imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ;   if ( ! imapc -> mailbox )  return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }"," . path ;  if ( !  = ""INBOX"" ; return Curl_urldecode  ( data ,  0 , &  imapc -> mailbox  imapc -> mailbox , NULL , TRUE )  ; } "
725,"CWE-119 static int journal_unmap_buffer ( journal_t * journal , struct buffer_head * bh ) { transaction_t * transaction ; struct journal_head * jh ; int may_free = 1 ; int ret ; BUFFER_TRACE ( bh , ""entry"" ) ; if ( ! buffer_jbd ( bh ) ) goto zap_buffer_unlocked ; write_lock ( & journal -> j_state_lock ) ; jbd_lock_bh_state ( bh ) ; spin_lock ( & journal -> j_list_lock ) ; jh = jbd2_journal_grab_journal_head ( bh ) ; if ( ! jh ) goto zap_buffer_no_jh ; transaction = jh -> b_transaction ; if ( transaction == NULL ) { if ( ! jh -> b_cp_transaction ) { JBUFFER_TRACE ( jh , ""notonanytransaction:zap"" ) ; goto zap_buffer ; } if ( ! buffer_dirty ( bh ) ) { goto zap_buffer ; } if ( journal -> j_running_transaction ) { JBUFFER_TRACE ( jh , ""checkpointed:addtoBJ_Forget"" ) ; ret = __dispose_buffer ( jh , journal -> j_running_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { if ( journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , ""givetocommittingtrans"" ) ; ret = __dispose_buffer ( jh , journal -> j_committing_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { clear_buffer_jbddirty ( bh ) ; goto zap_buffer ; } } } else if ( transaction == journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , ""oncommittingtransaction"" ) ; set_buffer_freed ( bh ) ; if ( journal -> j_running_transaction && buffer_jbddirty ( bh ) ) jh -> b_next_transaction = journal -> j_running_transaction ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return 0 ; } else { J_ASSERT_JH ( jh , transaction == journal -> j_running_transaction ) ; JBUFFER_TRACE ( jh , ""onrunningtransaction"" ) ; may_free = __dispose_buffer ( jh , transaction ) ; } zap_buffer : jbd2_journal_put_journal_head ( jh ) ; zap_buffer_no_jh : spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; zap_buffer_unlocked : clear_buffer_dirty ( bh ) ; J_ASSERT_BH ( bh , ! buffer_jbddirty ( bh ) ) ; clear_buffer_mapped ( bh ) ; clear_buffer_req ( bh ) ; clear_buffer_new ( bh ) ;  bh -> b_bdev = NULL ;  return may_free ; }", bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
726,"CWE-416 int blk_init_allocated_queue ( struct request_queue * q ) { WARN_ON_ONCE ( q -> mq_ops ) ; q -> fq = blk_alloc_flush_queue ( q , NUMA_NO_NODE , q -> cmd_size ) ; if ( ! q -> fq ) return - ENOMEM ; if ( q -> init_rq_fn && q -> init_rq_fn ( q , q -> fq -> flush_rq , GFP_KERNEL ) ) goto out_free_flush_queue ; if ( blk_init_rl ( & q -> root_rl , q , GFP_KERNEL ) ) goto out_exit_flush_rq ; INIT_WORK ( & q -> timeout_work , blk_timeout_work ) ; q -> queue_flags |= QUEUE_FLAG_DEFAULT ; blk_queue_make_request ( q , blk_queue_bio ) ; q -> sg_reserved_size = INT_MAX ; if ( elevator_init ( q ) ) goto out_exit_flush_rq ; return 0 ; out_exit_flush_rq : if ( q -> exit_rq_fn ) q -> exit_rq_fn ( q , q -> fq -> flush_rq ) ; out_free_flush_queue : blk_free_flush_queue ( q -> fq ) ;  return - ENOMEM ;  }", fq ) ; q -> fq = NULL ;
727,"CWE-20  int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode )  {  int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ;  if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) {  result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ;  } return result ; }"," inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ;  int result =  , inode , flags  ) ; if  , inode , flags | RR_REGARD_XA  ) ; }"
728,"CWE-125 struct r_bin_dyldcache_lib_t * r_bin_dyldcache_extract ( struct r_bin_dyldcache_obj_t * bin , int idx , int * nlib ) { ut64 liboff , linkedit_offset ; ut64 dyld_vmbase ; ut32 addend = 0 ; struct r_bin_dyldcache_lib_t * ret = NULL ; struct dyld_cache_image_info * image_infos = NULL ; struct mach_header * mh ; ut8 * data , * cmdptr ; int cmd , libsz = 0 ; RBuffer * dbuf ; char * libname ; if ( ! bin ) { return NULL ; } if ( bin -> size < 1 ) { eprintf ( ""Emptyfile?(%s)\\n"" , bin -> file ? bin -> file : ""(null)"" ) ; return NULL ; } if ( bin -> nlibs < 0 || idx < 0 || idx >= bin -> nlibs ) { return NULL ; } * nlib = bin -> nlibs ; ret = R_NEW0 ( struct r_bin_dyldcache_lib_t ) ; if ( ! ret ) {  perror ( ""malloc(ret)"" ) ;  return NULL ; } if ( bin -> hdr . startaddr > bin -> size ) { eprintf ( ""corrupteddyldcache"" ) ; free ( ret ) ; return NULL ; } if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) { eprintf ( ""corrupteddyldcache"" ) ; free ( ret ) ; return NULL ; }  image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ;   dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ;  liboff = image_infos [ idx ] . address - dyld_vmbase ; if ( liboff > bin -> size ) { eprintf ( ""Corruptedfile\\n"" ) ; free ( ret ) ; return NULL ; } ret -> offset = liboff ;  if ( image_infos [ idx ] . pathFileOffset > bin -> size ) {   eprintf ( ""corruptedfile\\n"" ) ;  free ( ret ) ; return NULL ; }  libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ;  data = bin -> b -> buf + liboff ; mh = ( struct mach_header * ) data ; if ( mh -> magic != MH_MAGIC && mh -> magic != MH_MAGIC_64 ) { if ( mh -> magic == 0xbebafeca ) { eprintf ( ""FATBinary\\n"" ) ; } eprintf ( ""Notmach-o\\n"" ) ; free ( ret ) ; return NULL ; } if ( ! ( dbuf = r_buf_new ( ) ) ) { eprintf ( ""new(dbuf)\\n"" ) ; free ( ret ) ; return NULL ; } addend = mh -> magic == MH_MAGIC ? sizeof ( struct mach_header ) : sizeof ( struct mach_header_64 ) ; r_buf_set_bytes ( dbuf , data , addend ) ; cmdptr = data + addend ; for ( cmd = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; r_buf_append_bytes ( dbuf , ( ut8 * ) lc , lc -> cmdsize ) ; cmdptr += lc -> cmdsize ; } cmdptr = data + addend ; for ( cmd = linkedit_offset = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; cmdptr += lc -> cmdsize ; switch ( lc -> cmd ) { case LC_SEGMENT : { struct segment_command * seg = ( struct segment_command * ) lc ; int t = seg -> filesize ; if ( seg -> fileoff + seg -> filesize > bin -> size || seg -> fileoff > bin -> size ) { eprintf ( ""malformeddyldcache\\n"" ) ; free ( ret ) ; r_buf_free ( dbuf ) ; return NULL ; } r_buf_append_bytes ( dbuf , bin -> b -> buf + seg -> fileoff , t ) ; r_bin_dyldcache_apply_patch ( dbuf , dbuf -> length , ( ut64 ) ( ( size_t ) & seg -> fileoff - ( size_t ) data ) ) ; int sect_offset = seg -> fileoff - libsz ; libsz = dbuf -> length ; if ( ! strcmp ( seg -> segname , ""__LINKEDIT"" ) ) { linkedit_offset = sect_offset ; } if ( seg -> nsects > 0 ) { struct section * sects = ( struct section * ) ( ( ut8 * ) seg + sizeof ( struct segment_command ) ) ; int nsect ; for ( nsect = 0 ; nsect < seg -> nsects ; nsect ++ ) { if ( sects [ nsect ] . offset > libsz ) { r_bin_dyldcache_apply_patch ( dbuf , sects [ nsect ] . offset - sect_offset , ( ut64 ) ( ( size_t ) & sects [ nsect ] . offset - ( size_t ) data ) ) ; } } } } break ; case LC_SYMTAB : { struct symtab_command * st = ( struct symtab_command * ) lc ; NZ_OFFSET ( st -> symoff ) ; NZ_OFFSET ( st -> stroff ) ; } break ; case LC_DYSYMTAB : { struct dysymtab_command * st = ( struct dysymtab_command * ) lc ; NZ_OFFSET ( st -> tocoff ) ; NZ_OFFSET ( st -> modtaboff ) ; NZ_OFFSET ( st -> extrefsymoff ) ; NZ_OFFSET ( st -> indirectsymoff ) ; NZ_OFFSET ( st -> extreloff ) ; NZ_OFFSET ( st -> locreloff ) ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { struct dyld_info_command * st = ( struct dyld_info_command * ) lc ; NZ_OFFSET ( st -> rebase_off ) ; NZ_OFFSET ( st -> bind_off ) ; NZ_OFFSET ( st -> weak_bind_off ) ; NZ_OFFSET ( st -> lazy_bind_off ) ; NZ_OFFSET ( st -> export_off ) ; } break ; } } ret -> b = dbuf ; strncpy ( ret -> path , libname , sizeof ( ret -> path ) - 1 ) ; ret -> size = libsz ; return ret ; }"," ret ) {  return NULL ;  NULL ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at  ( bin ->  bin -> b ,  bin -> hdr  hdr . startaddr , ( ut8 * ) image_infos , sz  ; dyld_vmbase = r_buf_read64le  ( bin ->  bin -> b ,  bin -> hdr  = liboff ; int pfo =  image_infos [ idx  ] . pathFileOffset ; if ( pfo < 0 || pfo  { eprintf ( ""corruptedfile:pathFileOffset>bin->size(%d)\\n"" , pfo  ) ; free  } libname = r_buf_read_string  ( bin ->  bin -> b , pfo , 64  ) ; data"
729,CWE-000  static ssize_t aio_setup_single_vector ( struct kiocb * kiocb )   {  kiocb -> ki_iovec = & kiocb -> ki_inline_vec ; kiocb -> ki_iovec -> iov_base = kiocb -> ki_buf ;  kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ;  kiocb -> ki_nr_segs = 1 ; kiocb -> ki_cur_seg = 0 ; return 0 ; }," ssize_t aio_setup_single_vector ( int type , struct file * file ,  kiocb ) { int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ;  -> iov_len = bytes  ; kiocb ->"
730,"CWE-190 static bool snd_ctl_remove_numid_conflict ( struct snd_card * card , unsigned int count ) {  struct snd_kcontrol * kctl ;  list_for_each_entry ( kctl , & card -> controls , list ) { if ( kctl -> id . numid < card -> last_numid + 1 + count && kctl -> id . numid + kctl -> count > card -> last_numid + 1 ) { card -> last_numid = kctl -> id . numid + kctl -> count - 1 ; return true ; } } return false ; }", snd_kcontrol * kctl ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0
731,CWE-476 static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) {  struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ;  struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; }, tfm ) {  return 0 ;
732,"CWE-264 int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , struct mount * source_mnt , struct list_head * tree_list ) {  struct mount * m , * child ;  int ret = 0 ; struct mount * prev_dest_mnt = dest_mnt ; struct mount * prev_src_mnt = source_mnt ; LIST_HEAD ( tmp_list ) ; LIST_HEAD ( umount_list ) ; for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; m = propagation_next ( m , dest_mnt ) ) { int type ; struct mount * source ; if ( IS_MNT_NEW ( m ) ) continue ;  source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;  child = copy_tree ( source , source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) { ret = PTR_ERR ( child ) ; list_splice ( tree_list , tmp_list . prev ) ; goto out ; } if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { mnt_set_mountpoint ( m , dest_dentry , child ) ; list_add_tail ( & child -> mnt_hash , tree_list ) ; } else { list_add_tail ( & child -> mnt_hash , & tmp_list ) ; } prev_dest_mnt = m ; prev_src_mnt = child ; } out : br_write_lock ( & vfsmount_lock ) ; while ( ! list_empty ( & tmp_list ) ) { child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; umount_tree ( child , 0 , & umount_list ) ; } br_write_unlock ( & vfsmount_lock ) ; release_mounts ( & umount_list ) ; return ret ; }", ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct  & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
733,"CWE-119 static INLINE void mi_buf_shift ( MACROBLOCK * x , int i ) { MB_MODE_INFO * const mbmi = & x -> e_mbd . mi [ 0 ] -> mbmi ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; struct macroblockd_plane * const pd = & x -> e_mbd . plane [ 0 ] ;  p -> src . buf = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;  assert ( ( ( intptr_t ) pd -> pre [ 0 ] . buf & 0x7 ) == 0 ) ;  pd -> pre [ 0 ] . buf = & pd -> pre [ 0 ] . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> pre [ 0 ] . stride ) ] ; if ( has_second_ref ( mbmi ) )  pd -> pre [ 1 ] . buf = & pd -> pre [ 1 ] . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> pre [ 1 ] . stride ) ] ; }"," . buf [ vp9_raster_block_offset  ( BLOCK_8X8 ,  . buf [ vp9_raster_block_offset  ( BLOCK_8X8 ,  . buf [ vp9_raster_block_offset  ( BLOCK_8X8 ,"
734,"CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = ""*"" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( ""kadm5_get_principals"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_principals"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; }  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }"," ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER  ; OM_uint32 minor_stat  ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ;  free_server_handle ( handle"
735,"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""badpkt!"" : ""noheaderatall!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""nlpid0x%02xpacketnotsupported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""version%dpacketnotsupported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""lengthindicator(%u)>PDUsize(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""lengthindicator%u<minPDUsize:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,length%u"" , ndo -> ndo_eflag ? """" : "","" , tok2str ( esis_pdu_values , ""unknowntype(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength%u\\n\\t%s(%u)"" , ndo -> ndo_eflag ? """" : "","" , length , tok2str ( esis_pdu_values , ""unknowntype:%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",v:%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",checksum:0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",holdingtime:%us,lengthindicator:%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",badredirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",badredirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",badredirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",badredirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",badredirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",badredirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\tSNPA(length:%u):%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tSNPA(length:%u):%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != 0 ) ND_PRINT ( ( ndo , ""\\n\\tNET(length:%u)%s"" , netal , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",badesh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\tNumberofSourceAddresses:%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",badesh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",badesh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\tNET(length:%u):%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",badish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",badish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\tNET(length:%u):%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",badopts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",opt(%d)toolong"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t%sOption#%u,length%u,value:"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(badlength)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) {  ND_TCHECK ( * pptr ) ;  ND_PRINT ( ( ndo , ""%s(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "","" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t"" , opli ) ; pptr += opli ; } trunc :  return ;  }"," ND_TCHECK ( * tptr  ) ; ND_PRINT  } trunc : ND_PRINT ( ( ndo , ""[|esis]"" ) )  ; } "
736,"CWE-269 static int store_asoundrc ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_ASOUNDRC_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0644 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { fprintf ( stderr , ""Error:Cannotaccess%s\\n"" , src ) ; exit ( 1 ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { fprintf ( stderr , ""Error:.asoundrcisasymboliclinkpointingtoafileoutsidehomedirectory\\n"" ) ; exit ( 1 ) ; } free ( rp ) ; }  pid_t child = fork ( ) ;  if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ;  if ( rv )  fprintf ( stderr , ""Warning:cannottransfer.asoundrcinprivatehomedirectory\\n"" ) ; else {  fs_logger2 ( ""clone"" , dest ) ;  } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; return 1 ; } return 0 ; }"," ) ; } copy_file_as_user  ( src ,  0644 ) ;  fs_logger2 ( ""clone""  ""clone"" , dest  ) ; return"
737,"CWE-362 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; if ( task ) { err = mutex_lock_interruptible ( & task -> signal -> cred_guard_mutex ) ; if ( err ) goto err_cpus ; err = - EACCES ; if ( ! ptrace_may_access ( task , PTRACE_MODE_READ_REALCREDS ) ) goto err_cred ; } if ( flags & PERF_FLAG_PID_CGROUP ) cgroup_fd = pid ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL , cgroup_fd ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cred ; } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - EOPNOTSUPP ; goto err_alloc ; } } pmu = event -> pmu ; if ( attr . use_clockid ) { err = perf_event_set_clock ( event , attr . clockid ) ; if ( err ) goto err_alloc ; } if ( pmu -> task_ctx_nr == perf_sw_context ) event -> event_caps |= PERF_EV_CAP_SOFTWARE ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( ( pmu -> capabilities & PERF_PMU_CAP_EXCLUSIVE ) && group_leader ) { err = - EBUSY ; goto err_context ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( group_leader -> clock != event -> clock ) goto err_context ; if ( move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu ) goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; event_file = NULL ; goto err_context ; } if ( move_group ) {  gctx = group_leader -> ctx ;  mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; if ( gctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; }  } else {  mutex_lock ( & ctx -> mutex ) ; } if ( ctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } if ( ! perf_event_validate_size ( event ) ) { err = - E2BIG ; goto err_locked ; } if ( ! exclusive_event_installable ( event , ctx ) ) { WARN_ON_ONCE ( move_group ) ; err = - EBUSY ; goto err_locked ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { perf_remove_from_context ( group_leader , 0 ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , 0 ) ; put_ctx ( gctx ) ; } synchronize_rcu ( ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_event__state_init ( sibling ) ; perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } perf_event__state_init ( group_leader ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; put_ctx ( gctx ) ; } perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; event -> owner = current ; perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;  mutex_unlock ( & ctx -> mutex ) ; if ( task ) { mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; put_task_struct ( task ) ; } put_online_cpus ( ) ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_locked : if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;  mutex_unlock ( & ctx -> mutex ) ; fput ( event_file ) ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : if ( ! event_file ) free_event ( event ) ; err_cred : if ( task ) mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }"," { gctx = __perf_event_ctx_lock_double ( group_leader , ctx  ) ; if  err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } }  ( move_group ) perf_event_ctx_unlock ( group_leader , gctx  ) ; mutex_unlock  ( move_group ) perf_event_ctx_unlock ( group_leader , gctx  ) ; mutex_unlock"
738,"CWE-399 static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret ,  void * * p , void * end ,  void * dbuf , void * ticket_buf ) { struct ceph_x_info * xi = ac -> private ; int type ; u8 tkt_struct_v , blob_struct_v ; struct ceph_x_ticket_handler * th ;  void * dp , * dend ;  int dlen ; char is_enc ; struct timespec validity ;  struct ceph_crypto_key old_key ;  void * tp , * tpend ; struct ceph_timespec new_validity ; struct ceph_crypto_key new_session_key ; struct ceph_buffer * new_ticket_blob ; unsigned long new_expires , new_renew_after ; u64 new_secret_id ; int ret ; ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ; type = ceph_decode_32 ( p ) ; dout ( ""tickettype%d%s\\n"" , type , ceph_entity_type_name ( type ) ) ; tkt_struct_v = ceph_decode_8 ( p ) ; if ( tkt_struct_v != 1 ) goto bad ; th = get_ticket_handler ( ac , type ) ; if ( IS_ERR ( th ) ) { ret = PTR_ERR ( th ) ; goto out ; }  dlen = ceph_x_decrypt ( secret , p , end , dbuf ,  TEMP_TICKET_BUF_LEN ) ; if ( dlen <= 0 ) { ret = dlen ; goto out ; } dout ( ""decrypted%dbytes\\n"" , dlen ) ; dp = dbuf ; dend = dp + dlen ; tkt_struct_v = ceph_decode_8 ( & dp ) ; if ( tkt_struct_v != 1 ) goto bad ; memcpy ( & old_key , & th -> session_key , sizeof ( old_key ) ) ; ret = ceph_crypto_key_decode ( & new_session_key , & dp , dend ) ; if ( ret ) goto out ; ceph_decode_copy ( & dp , & new_validity , sizeof ( new_validity ) ) ; ceph_decode_timespec ( & validity , & new_validity ) ; new_expires = get_seconds ( ) + validity . tv_sec ; new_renew_after = new_expires - ( validity . tv_sec / 4 ) ; dout ( ""expires=%lurenew_after=%lu\\n"" , new_expires , new_renew_after ) ; ceph_decode_8_safe ( p , end , is_enc , bad ) ;  tp = ticket_buf ;  if ( is_enc ) { dout ( ""encryptedticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , TEMP_TICKET_BUF_LEN ) ; if ( dlen < 0 ) { ret = dlen ; goto out ;  }  dlen = ceph_decode_32 ( & tp ) ; } else { ceph_decode_32_safe ( p , end , dlen , bad ) ;  ceph_decode_need ( p , end , dlen , bad ) ;  ceph_decode_copy ( p , ticket_buf , dlen ) ; } tpend = tp + dlen ; dout ( ""ticketblobis%dbytes\\n"" , dlen ) ; ceph_decode_need ( & tp , tpend , 1 + sizeof ( u64 ) , bad ) ; blob_struct_v = ceph_decode_8 ( & tp ) ; new_secret_id = ceph_decode_64 ( & tp ) ; ret = ceph_decode_buffer ( & new_ticket_blob , & tp , tpend ) ; if ( ret ) goto out ; ceph_crypto_key_destroy ( & th -> session_key ) ; if ( th -> ticket_blob ) ceph_buffer_put ( th -> ticket_blob ) ; th -> session_key = new_session_key ; th -> ticket_blob = new_ticket_blob ; th -> validity = new_validity ; th -> secret_id = new_secret_id ; th -> expires = new_expires ; th -> renew_after = new_renew_after ; dout ( ""gotticketservice%d(%s)secret_id%lldlen%d\\n"" , type , ceph_entity_type_name ( type ) , th -> secret_id , ( int ) th -> ticket_blob -> vec . iov_len ) ; xi -> have_keys |= th -> service ; out :  return ret ;  bad : ret = - EINVAL ; goto out ; }"," void * end  ) { struct  ; void * dbuf = NULL ; void *  struct ceph_crypto_key old_key ; void * ticket_buf = NULL  , end , & dbuf , 0  ) ; if  bad ) ; if ( is_enc ) { dout ( ""encryptedticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0  ) ; if  out ; } tp = ticket_buf ;  bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ;  ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;"
739,"CWE-125 static int isis_print_mt_port_cap_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len ; const struct isis_subtlv_spb_mcid * subtlv_spb_mcid ; int i ; while ( len > 2 ) {  stlv_type = * ( tptr ++ ) ;  stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t%ssubTLV#%u,length:%u"" , tok2str ( isis_mt_port_cap_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ;  len = len - 2 ;  switch ( stlv_type ) { case ISIS_SUBTLV_SPB_MCID : {  ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ;  subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ; ND_PRINT ( ( ndo , ""\\n\\tMCID:"" ) ) ; isis_print_mcid ( ndo , & ( subtlv_spb_mcid -> mcid ) ) ; ND_PRINT ( ( ndo , ""\\n\\tAUX-MCID:"" ) ) ; isis_print_mcid ( ndo , & ( subtlv_spb_mcid -> aux_mcid ) ) ;  tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ;  len = len - sizeof ( struct isis_subtlv_spb_mcid ) ; break ; } case ISIS_SUBTLV_SPB_DIGEST : {  ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\tRES:%dV:%dA:%dD:%d"" , ( * ( tptr ) >> 5 ) , ( ( ( * tptr ) >> 4 ) & 0x01 ) , ( ( * ( tptr ) >> 2 ) & 0x03 ) , ( ( * tptr ) & 0x03 ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , ""\\n\\tDigest:"" ) ) ; for ( i = 1 ; i <= 8 ; i ++ ) { ND_PRINT ( ( ndo , ""%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( i % 4 == 0 && i != 8 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; tptr = tptr + 4 ; } len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ;  break ;  } case ISIS_SUBTLV_SPB_BVID : {  ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;  while ( len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) {  ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\tECT:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""BVID:%d,U:%01xM:%01x"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) , ( EXTRACT_16BITS ( tptr ) >> 3 ) & 0x01 , ( EXTRACT_16BITS ( tptr ) >> 2 ) & 0x01 ) ) ; tptr = tptr + 2 ; len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ;  }  break ; } default : break ; }  }  return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }"," 2 ) { ND_TCHECK2 ( * tptr , 2 ) ;  len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len )  ISIS_SUBTLV_SPB_MCID : { if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc  ; subtlv_spb_mcid =  = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN  ; break ;  ISIS_SUBTLV_SPB_DIGEST : { if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc  ; ND_PRINT (  - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ;  ISIS_SUBTLV_SPB_BVID : { while ( stlv_len  >= ISIS_SUBTLV_SPB_BVID_MIN_LEN )  ISIS_SUBTLV_SPB_BVID_MIN_LEN ) {  ND_PRINT ( (  - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ;  break ; } tptr += stlv_len ; len -= stlv_len ;"
740,CWE-264 static int em_grp45 ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; switch ( ctxt -> modrm_reg ) { case 2 : { long int old_eip ; old_eip = ctxt -> _eip ;  ctxt -> _eip = ctxt -> src . val ;  ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; break ; } case 4 :  ctxt -> _eip = ctxt -> src . val ;  break ; case 5 : rc = em_jmp_far ( ctxt ) ; break ; case 6 : rc = em_push ( ctxt ) ; break ; } return rc ; }," -> _eip ; rc = assign_eip_near ( ctxt ,  ctxt -> src  src . val ) ; if ( rc != X86EMUL_CONTINUE ) break  case 4 : rc = assign_eip_near ( ctxt ,  ctxt -> src  src . val )"
741,"CWE-17 static int do_dentry_open ( struct file * f , int ( * open ) ( struct inode * , struct file * ) , const struct cred * cred ) { static const struct file_operations empty_fops = { } ; struct inode * inode ; int error ; f -> f_mode = OPEN_FMODE ( f -> f_flags ) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE ; if ( unlikely ( f -> f_flags & O_PATH ) ) f -> f_mode = FMODE_PATH ; path_get ( & f -> f_path ) ; inode = f -> f_inode = f -> f_path . dentry -> d_inode ; if ( f -> f_mode & FMODE_WRITE ) { error = __get_file_write_access ( inode , f -> f_path . mnt ) ; if ( error ) goto cleanup_file ; if ( ! special_file ( inode -> i_mode ) ) file_take_write ( f ) ; } f -> f_mapping = inode -> i_mapping ;  file_sb_list_add ( f , inode -> i_sb ) ;  if ( unlikely ( f -> f_mode & FMODE_PATH ) ) { f -> f_op = & empty_fops ; return 0 ; } f -> f_op = fops_get ( inode -> i_fop ) ; if ( unlikely ( WARN_ON ( ! f -> f_op ) ) ) { error = - ENODEV ; goto cleanup_all ; } error = security_file_open ( f , cred ) ; if ( error ) goto cleanup_all ; error = break_lease ( inode , f -> f_flags ) ; if ( error ) goto cleanup_all ; if ( ! open ) open = f -> f_op -> open ; if ( open ) { error = open ( inode , f ) ; if ( error ) goto cleanup_all ; } if ( ( f -> f_mode & ( FMODE_READ | FMODE_WRITE ) ) == FMODE_READ ) i_readcount_inc ( inode ) ; f -> f_flags &= ~ ( O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC ) ; file_ra_state_init ( & f -> f_ra , f -> f_mapping -> host -> i_mapping ) ; return 0 ; cleanup_all : fops_put ( f -> f_op ) ;  file_sb_list_del ( f ) ;  if ( f -> f_mode & FMODE_WRITE ) { put_write_access ( inode ) ; if ( ! special_file ( inode -> i_mode ) ) { file_reset_write ( f ) ; __mnt_drop_write ( f -> f_path . mnt ) ; } } cleanup_file : path_put ( & f -> f_path ) ; f -> f_path . mnt = NULL ; f -> f_path . dentry = NULL ; f -> f_inode = NULL ; return error ; }", -> i_mapping ;  if ( unlikely  f_op ) ;  if ( f
742,"CWE-362 int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ;  int err ;  dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ;  if ( inet -> opt != NULL && inet -> opt -> srr ) {  if ( daddr == 0 ) return - EINVAL ;  nexthop = inet -> opt -> faddr ;  } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; }  if ( inet -> opt == NULL || ! inet -> opt -> srr )  daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;  if ( inet -> opt != NULL )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }"," ; int err ; struct ip_options_rcu * inet_opt  . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt  != NULL &&  != NULL && inet_opt -> opt .  srr ) {  ; nexthop = inet_opt -> opt .  faddr ; }  } if ( inet_opt  == NULL ||  NULL || ! inet_opt -> opt .  srr ) daddr  ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt .  optlen ; dccp_set_state"
743,"CWE-415 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return ""N/A"" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return ""N/A"" ; case SC_AC_NEVER : return ""NEVR"" ; case SC_AC_NONE : return ""NONE"" ; case SC_AC_CHV : strcpy ( buf , ""CHV"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , ""TERM"" ) ; break ; case SC_AC_PRO : strcpy ( buf , ""PROT"" ) ; break ; case SC_AC_AUT : strcpy ( buf , ""AUTH"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , ""%d"" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , ""Sec.Env."" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , ""Sec.ControlByte"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""Ox%X"" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , ""PKCS#15AuthID"" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , ""#%d"" , e -> key_ref ) ; break ; default : strcpy ( buf , ""????"" ) ; break ; }  strcat ( line , buf ) ;   strcat ( line , """" ) ;  e = e -> next ; }  line [ strlen ( line ) - 1 ] = 0 ;  return line ; }"," break ; } strncat ( line , buf , sizeof line ) ; strncat  ( line ,  line , """" , sizeof line  } line [ ( sizeof  line ) -  1 ] = '\\0' ; line [ strlen ( line ) - 1 ] ="
744,"CWE-190 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ;  int iskew = imagew - tilew ;  uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) { if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,can\'treadtileat%lu%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; }  if ( colb + tilew > imagew ) {  uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }", in ) ; int64 iskew = ( int64 ) imagew - ( int64 )  tilew ; uint8  if ( colb > iskew  ) { uint32
745,"CWE-000 LUA_API void lua_sethook ( lua_State * L , lua_Hook func , int mask , int count ) { if ( func == NULL || mask == 0 ) { mask = 0 ; func = NULL ; }  if ( isLua ( L -> ci ) )  L -> oldpc = L -> ci -> u . l . savedpc ; L -> hook = func ; L -> basehookcount = count ; resethookcount ( L ) ; L -> hookmask = cast_byte ( mask ) ; if ( mask ) settraps ( L -> ci ) ; }", NULL ; }  L -> hook
746,"CWE-119 static int store_icy ( URLContext * h , int size ) { HTTPContext * s = h -> priv_data ;  int remaining = s -> icy_metaint - s -> icy_data_read ;  if ( remaining < 0 ) return AVERROR_INVALIDDATA ; if ( ! remaining ) { uint8_t ch ; int len = http_read_stream_all ( h , & ch , 1 ) ; if ( len < 0 ) return len ; if ( ch > 0 ) { char data [ 255 * 16 + 1 ] ; int ret ; len = ch * 16 ; ret = http_read_stream_all ( h , data , len ) ; if ( ret < 0 ) return ret ; data [ len + 1 ] = 0 ; if ( ( ret = av_opt_set ( s , ""icy_metadata_packet"" , data , 0 ) ) < 0 ) return ret ; update_metadata ( s , data ) ; } s -> icy_data_read = 0 ; remaining = s -> icy_metaint ; } return FFMIN ( size , remaining ) ; }", -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ;  remaining = s  s -> icy_data_read  ; if (
747,"CWE-200 unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ;  if ( len < 5 )   return len ;  b -> opcode = 0xe9 ; b -> delta = delta ; return 5 ; }"," < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""FailingtopatchindirectJMPin%ps\\n"" , ( void * ) addr ) ; # endif  return len ; }"
748,"CWE-59 void lxc_execute_bind_init ( struct lxc_conf * conf ) { int ret ; char path [ PATH_MAX ] , destpath [ PATH_MAX ] , * p ; p = choose_init ( conf -> rootfs . mount ) ; if ( p ) { free ( p ) ; return ; } ret = snprintf ( path , PATH_MAX , SBINDIR ""/init.lxc.static"" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( ""Pathnametoolongsearchingforlxc.init.static"" ) ; return ; } if ( ! file_exists ( path ) ) { INFO ( ""%sdoesnotexistonhost"" , path ) ; return ; } ret = snprintf ( destpath , PATH_MAX , ""%s%s"" , conf -> rootfs . mount , ""/init.lxc.static"" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( ""Pathnametoolongforcontainer\'slxc.init.static"" ) ; return ; } if ( ! file_exists ( destpath ) ) { FILE * pathfile = fopen ( destpath , ""wb"" ) ; if ( ! pathfile ) { SYSERROR ( ""Failedtocreatemounttarget\'%s\'"" , destpath ) ; return ; } fclose ( pathfile ) ; }  ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;  if ( ret < 0 ) SYSERROR ( ""Failedtobindlxc.init.staticintocontainer"" ) ; INFO ( ""lxc.init.staticboundintocontainerat%s"" , path ) ; }"," } ret = safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount  ) ; if"
749,"CWE-119 void vp8_loopfilter_frame ( VP8_COMP * cpi , VP8_COMMON * cm ) {  const FRAME_TYPE frame_type = cm -> frame_type ;  if ( cm -> no_lpf ) { cm -> filter_level = 0 ; } else { struct vpx_usec_timer timer ; vp8_clear_system_state ( ) ; vpx_usec_timer_start ( & timer ) ;  if ( cpi -> sf . auto_filter == 0 )  vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ;  else   vp8cx_pick_filter_level ( cpi -> Source , cpi ) ;  if ( cm -> filter_level > 0 ) { vp8cx_set_alt_lf_level ( cpi , cm -> filter_level ) ; } vpx_usec_timer_mark ( & timer ) ; cpi -> time_pick_lpf += vpx_usec_timer_elapsed ( & timer ) ; } # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) sem_post ( & cpi -> h_event_end_lpf ) ; # endif  if ( cm -> filter_level > 0 )  { vp8_loop_filter_frame ( cm , & cpi -> mb . e_mbd , frame_type ) ; } vp8_yv12_extend_frame_borders ( cm -> frame_to_show ) ; }"," -> frame_type ; int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; }  == 0 ) { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast (  cpi -> Source  cpi ) ; } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level (  cpi -> Source  cpi ) ; } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif }  filter_level > 0 && update_any_ref_buffers"
750,"CWE-119  int vp8_denoiser_filter_neon ( YV12_BUFFER_CONFIG * mc_running_avg ,  YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) { const uint8x16_t v_level1_adjustment = vdupq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vdupq_n_u8 ( 4 ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ;  unsigned char * sig = signal -> thismb ;  int sig_stride = 16 ; unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; int mc_running_avg_y_stride = mc_running_avg -> y_stride ; unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; int running_avg_y_stride = running_avg -> y_stride ; int i ; int sum_diff = 0 ;  for ( i = 0 ; i < 16 ; ++ i ) {   int8x16_t v_sum_diff = vdupq_n_s8 ( 0 ) ;  uint8x16_t v_running_avg_y ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; v_sum_diff = vqaddq_s8 ( v_sum_diff , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; v_sum_diff = vqsubq_s8 ( v_sum_diff , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { int s0 = vgetq_lane_s8 ( v_sum_diff , 0 ) + vgetq_lane_s8 ( v_sum_diff , 1 ) + vgetq_lane_s8 ( v_sum_diff , 2 ) + vgetq_lane_s8 ( v_sum_diff , 3 ) ; int s1 = vgetq_lane_s8 ( v_sum_diff , 4 ) + vgetq_lane_s8 ( v_sum_diff , 5 ) + vgetq_lane_s8 ( v_sum_diff , 6 ) + vgetq_lane_s8 ( v_sum_diff , 7 ) ; int s2 = vgetq_lane_s8 ( v_sum_diff , 8 ) + vgetq_lane_s8 ( v_sum_diff , 9 ) + vgetq_lane_s8 ( v_sum_diff , 10 ) + vgetq_lane_s8 ( v_sum_diff , 11 ) ; int s3 = vgetq_lane_s8 ( v_sum_diff , 12 ) + vgetq_lane_s8 ( v_sum_diff , 13 ) + vgetq_lane_s8 ( v_sum_diff , 14 ) + vgetq_lane_s8 ( v_sum_diff , 15 ) ; sum_diff += s0 + s1 + s2 + s3 ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; }  if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD )  return COPY_BLOCK ;  vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride ,   signal -> thismb , sig_stride ) ;  return FILTER_BLOCK ; }"," int vp8_denoiser_filter_neon ( unsigned char * mc_running_avg_y , int mc_running_avg_y_stride , unsigned char * running_avg_y , int running_avg_y_stride ,  unsigned char *  char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { int shift_inc = ( increase_denoising && motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; const uint8x16_t v_level1_adjustment = vmovq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 + shift_inc : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vmovq_n_u8 ( 4 + shift_inc ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ; int64x2_t v_sum_diff_total = vdupq_n_s64 ( 0 ) ; int r  ; for (  ; for ( r  = 0 ;  = 0 ; r  < 16 ;  16 ; ++ r ) { const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; uint8x16_t v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const  int8x16_t v_sum_diff =  int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_pos_adjustment ) , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 )  ; } sig  running_avg_y_stride ; } { int64x1_t x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; int sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; int sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( sum_diff > sum_diff_thresh ) { int delta = ( ( sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const uint8x16_t k_delta = vmovq_n_u8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_running_avg_y_stride * 16 ; running_avg_y -= running_avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { uint8x16_t v_running_avg_y = vld1q_u8 ( running_avg_y ) ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_abs_adjustment = vminq_u8 ( v_abs_diff , ( k_delta ) ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_pos_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_neg_adjustment ) , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; } { x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; if ( sum_diff > sum_diff_thresh ) {  return COPY_BLOCK ;  return COPY_BLOCK ; } } } else { return COPY_BLOCK ; } } } running_avg_y -= running_avg_y_stride * 16 ; sig -= sig_stride * 16 ; vp8_copy_mem16x16 ( running_avg_y  , running_avg_y_stride ,  , running_avg_y_stride , sig  , sig_stride )"
751,"CWE-20 static ssize_t generic_perform_write ( struct file * file , struct iov_iter * i , loff_t pos ) { struct address_space * mapping = file -> f_mapping ; const struct address_space_operations * a_ops = mapping -> a_ops ; long status = 0 ; ssize_t written = 0 ; unsigned int flags = 0 ; if ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) flags |= AOP_FLAG_UNINTERRUPTIBLE ; do { struct page * page ; pgoff_t index ; unsigned long offset ; unsigned long bytes ; size_t copied ; void * fsdata ; offset = ( pos & ( PAGE_CACHE_SIZE - 1 ) ) ; index = pos >> PAGE_CACHE_SHIFT ; bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_count ( i ) ) ; again : if ( unlikely ( iov_iter_fault_in_readable ( i , bytes ) ) ) { status = - EFAULT ; break ; } status = a_ops -> write_begin ( file , mapping , pos , bytes , flags , & page , & fsdata ) ; if ( unlikely ( status ) ) break ; pagefault_disable ( ) ; copied = iov_iter_copy_from_user_atomic ( page , i , offset , bytes ) ; pagefault_enable ( ) ; flush_dcache_page ( page ) ; status = a_ops -> write_end ( file , mapping , pos , bytes , copied , page , fsdata ) ; if ( unlikely ( status < 0 ) ) break ; copied = status ; cond_resched ( ) ;  if ( unlikely ( copied == 0 ) ) {  bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ; goto again ; }  iov_iter_advance ( i , copied ) ;  pos += copied ; written += copied ; balance_dirty_pages_ratelimited ( mapping ) ; } while ( iov_iter_count ( i ) ) ; return written ? written : status ; }"," ( ) ; iov_iter_advance ( i , copied ) ;  again ; }  pos += copied"
752,"CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem )  {  uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ;  return TEE_SUCCESS ;  }"," mem ) { size_t req_size = 0 ;  size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;"
753,"CWE-20 static void gimp_write_and_read_file ( Gimp * gimp , gboolean with_unusual_stuff , gboolean compat_paths , gboolean use_gimp_2_8_features ) { GimpImage * image ; GimpImage * loaded_image ; GimpPlugInProcedure * proc ;  gchar * filename ;  GFile * file ; image = gimp_create_mainimage ( gimp , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; gimp_assert_mainimage ( image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ;  filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ;  file = g_file_new_for_path ( filename ) ; g_free ( filename ) ; proc = gimp_plug_in_manager_file_procedure_find ( image -> gimp -> plug_in_manager , GIMP_FILE_PROCEDURE_GROUP_SAVE , file , NULL ) ; file_save ( gimp , image , NULL , file , proc , GIMP_RUN_NONINTERACTIVE , FALSE , FALSE , FALSE , NULL ) ; loaded_image = gimp_test_load_image ( image -> gimp , file ) ; gimp_assert_mainimage ( loaded_image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; g_file_delete ( file , NULL , NULL ) ; g_object_unref ( file ) ; }"," gchar * filename = NULL ; gint file_handle  use_gimp_2_8_features ) ; file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle  ) ; file"
754,"CWE-000 bool_t auth_gssapi_unwrap_data ( OM_uint32 * major , OM_uint32 * minor , gss_ctx_id_t context , uint32_t seq_num , XDR * in_xdrs , bool_t ( * xdr_func ) ( ) , caddr_t xdr_ptr ) { gss_buffer_desc in_buf , out_buf ; XDR temp_xdrs ; uint32_t verf_seq_num ; int conf , qop ; unsigned int length ; PRINTF ( ( ""gssapi_unwrap_data:starting\\n"" ) ) ; * major = GSS_S_COMPLETE ; * minor = 0 ; in_buf . value = NULL ; out_buf . value = NULL ; if ( ! xdr_bytes ( in_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ) { PRINTF ( ( ""gssapi_unwrap_data:deserializingencrypteddatafailed\\n"" ) ) ; temp_xdrs . x_op = XDR_FREE ; ( void ) xdr_bytes ( & temp_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ; return FALSE ; } in_buf . length = length ; * major = gss_unseal ( minor , context , & in_buf , & out_buf , & conf , & qop ) ; free ( in_buf . value ) ; if ( * major != GSS_S_COMPLETE ) return FALSE ; PRINTF ( ( ""gssapi_unwrap_data:%llubytesdata,%llubytessealed\\n"" , ( unsigned long long ) out_buf . length , ( unsigned long long ) in_buf . length ) ) ; xdrmem_create ( & temp_xdrs , out_buf . value , out_buf . length , XDR_DECODE ) ; if ( ! xdr_u_int32 ( & temp_xdrs , & verf_seq_num ) ) { PRINTF ( ( ""gssapi_unwrap_data:deserializingverf_seq_numfailed\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } if ( verf_seq_num != seq_num ) { PRINTF ( ( ""gssapi_unwrap_data:seq%dspecified,read%d\\n"" , seq_num , verf_seq_num ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( ""gssapi_unwrap_data:unwrapseq_num%dokay\\n"" , verf_seq_num ) ) ; if ( ! ( * xdr_func ) ( & temp_xdrs , xdr_ptr ) ) { PRINTF ( ( ""gssapi_unwrap_data:deserializingargumentsfailed\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ;  xdr_free ( xdr_func , xdr_ptr ) ;  XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( ""gssapi_unwrap_data:succeeding\\n\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return TRUE ; }", out_buf ) ;  XDR_DESTROY ( &
755,"CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ;  if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {  DPRINTF ( ( ""Outofboundsread%"" SIZE_T_FORMAT ""u>%"" SIZE_T_FORMAT ""u\\n"" ,  pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ;  return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }"," if ( pos + len  ""u\\n"" , pos + len"
756,"CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , ""excluded_channels():exclude_mask"" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , ""excluded_channels():additional_excluded_chns"" ) ) ) == 1 ) {  for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ )  { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , ""excluded_channels():exclude_mask"" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }", 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
757,"CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id ,  va_list args ) {  vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ;  if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }"," * ctx ,  va_list args )  args ) { vpx_decrypt_init  * init =  ( args , vpx_decrypt_init  * ) ;"
758,"CWE-415 SPL_METHOD ( SplDoublyLinkedList , offsetSet ) { zval * zindex , * value ; spl_dllist_object * intern ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""zz"" , & zindex , & value ) == FAILURE ) { return ; } intern = Z_SPLDLLIST_P ( getThis ( ) ) ; if ( Z_TYPE_P ( zindex ) == IS_NULL ) { spl_ptr_llist_push ( intern -> llist , value ) ; } else { zend_long index ; spl_ptr_llist_element * element ; index = spl_offset_convert_to_long ( zindex ) ; if ( index < 0 || index >= intern -> llist -> count ) {  zval_ptr_dtor ( value ) ;  zend_throw_exception ( spl_ce_OutOfRangeException , ""Offsetinvalidoroutofrange"" , 0 ) ; return ; } element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ; if ( element != NULL ) { if ( intern -> llist -> dtor ) { intern -> llist -> dtor ( element ) ; } zval_ptr_dtor ( & element -> data ) ; ZVAL_COPY_VALUE ( & element -> data , value ) ; if ( intern -> llist -> ctor ) { intern -> llist -> ctor ( element ) ; } } else { zval_ptr_dtor ( value ) ; zend_throw_exception ( spl_ce_OutOfRangeException , ""Offsetinvalid"" , 0 ) ; return ; } } }", count ) {  zend_throw_exception ( spl_ce_OutOfRangeException
759,"CWE-000 static void nfs4_open_prepare ( struct rpc_task * task , void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state_owner * sp = data -> owner ; if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ; if ( data -> state != NULL ) { struct nfs_delegation * delegation ;  if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) )  goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) == 0 ) { rcu_read_unlock ( ) ; goto out_no_action ; } rcu_read_unlock ( ) ; } data -> o_arg . id = sp -> so_owner_id . id ; data -> o_arg . clientid = sp -> so_client -> cl_clientid ; if ( data -> o_arg . claim == NFS4_OPEN_CLAIM_PREVIOUS ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_NOATTR ] ; nfs_copy_fh ( & data -> o_res . fh , data -> o_arg . fh ) ; } data -> timestamp = jiffies ; rpc_call_start ( task ) ; return ; out_no_action : task -> tk_action = NULL ; }"," -> o_arg . fmode , data -> o_arg . open_flags  ) ) goto"
760,"CWE-200 static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct hci_ufilter uf ; struct sock * sk = sock -> sk ; int len , opt , err = 0 ; BT_DBG ( ""sk%p,opt%d"" , sk , optname ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { err = - EINVAL ; goto done ; } switch ( optname ) { case HCI_DATA_DIR : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_TIME_STAMP : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_FILTER : {  struct hci_filter * f = & hci_pi ( sk ) -> filter ;  uf . type_mask = f -> type_mask ; uf . opcode = f -> opcode ; uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; } len = min_t ( unsigned int , len , sizeof ( uf ) ) ; if ( copy_to_user ( optval , & uf , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } done : release_sock ( sk ) ; return err ; }"," ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )"
761,CWE-119 cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; },"
"
762,"CWE-119 static int put_chars ( u32 vtermno , const char * buf , int count ) { struct port * port ;  struct scatterlist sg [ 1 ] ;  if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ; port = find_port_by_vtermno ( vtermno ) ; if ( ! port ) return - EPIPE ;  sg_init_one ( sg , buf , count ) ;   return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ;   } "," [ 1 ] ; void * data ; int ret  - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ;  ( sg , data  , count )  count ) ; ret =  __send_to_port ( port  , count , data  , false )  false ) ; kfree ( data ) ; return ret ;"
763,"CWE-787 int main ( int argc , char * argv [ ] ) { int32_t ret = GPMF_OK ; GPMF_stream metadata_stream , * ms = & metadata_stream ; double metadatalength ; uint32_t * payload = NULL ; if ( argc != 2 ) { printf ( ""usage:%s<file_with_GPMF>\\n"" , argv [ 0 ] ) ; return - 1 ; } size_t mp4 = OpenMP4Source ( argv [ 1 ] , MOV_GPMF_TRAK_TYPE , MOV_GPMF_TRAK_SUBTYPE ) ;  metadatalength = GetDuration ( mp4 ) ;  if ( metadatalength > 0.0 ) { uint32_t index , payloads = GetNumberPayloads ( mp4 ) ; # if 1 if ( payloads == 1 ) { uint32_t payloadsize = GetPayloadSize ( mp4 , 0 ) ; payload = GetPayload ( mp4 , payload , 0 ) ; if ( payload == NULL ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Validate ( ms , GPMF_RECURSE_LEVELS ) ; if ( GPMF_OK != ret ) { printf ( ""InvalidStructure\\n"" ) ; goto cleanup ; } GPMF_ResetState ( ms ) ; do { PrintGPMF ( ms ) ; } while ( GPMF_OK == GPMF_Next ( ms , GPMF_RECURSE_LEVELS ) ) ; GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif for ( index = 0 ; index < payloads ; index ++ ) { uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ;  float in = 0.0 , out = 0.0 ;  payload = GetPayload ( mp4 , payload , index ) ; if ( payload == NULL ) goto cleanup ; ret = GetPayloadTime ( mp4 , index , & in , & out ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; # if 1 if ( index == 0 ) { ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; while ( GPMF_OK == ret ) { ret = GPMF_SeekToSamples ( ms ) ; if ( GPMF_OK == ret ) { uint32_t key = GPMF_Key ( ms ) ; GPMF_SampleType type = GPMF_Type ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; if ( samples ) { printf ( ""STRMof%c%c%c%c"" , PRINTF_4CC ( key ) ) ; if ( type == GPMF_TYPE_COMPLEX ) { GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TYPE , GPMF_CURRENT_LEVEL ) ) { char tmp [ 64 ] ; char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int size = GPMF_RawDataSize ( & find_stream ) ; if ( size < sizeof ( tmp ) ) { memcpy ( tmp , data , size ) ; tmp [ size ] = 0 ; printf ( ""oftype%s"" , tmp ) ; } } } else { printf ( ""oftype%c"" , type ) ; } printf ( ""with%dsample%s"" , samples , samples > 1 ? ""s"" : """" ) ; if ( elements > 1 ) printf ( ""--%delementspersample"" , elements ) ; printf ( ""\\n"" ) ; } ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; } else { if ( ret == GPMF_ERROR_BAD_STRUCTURE ) { ret = GPMF_Next ( ms , GPMF_CURRENT_LEVEL ) ; } } } GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif # if 1 if ( index == 0 ) { if ( GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( ""GPS5"" ) , GPMF_RECURSE_LEVELS ) || GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( ""GPRI"" ) , GPMF_RECURSE_LEVELS ) ) { uint32_t key = GPMF_Key ( ms ) ; uint32_t samples = GPMF_Repeat ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t buffersize = samples * elements * sizeof ( double ) ; GPMF_stream find_stream ; double * ptr , * tmpbuffer = malloc ( buffersize ) ; char units [ 10 ] [ 6 ] = { """" } ; uint32_t unit_samples = 1 ; printf ( ""MP4Payloadtime%.3fto%.3fseconds\\n"" , in , out ) ; if ( tmpbuffer && samples ) { uint32_t i , j ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_SI_UNITS , GPMF_CURRENT_LEVEL ) || GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_UNITS , GPMF_CURRENT_LEVEL ) ) { char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int ssize = GPMF_StructSize ( & find_stream ) ; unit_samples = GPMF_Repeat ( & find_stream ) ; for ( i = 0 ; i < unit_samples ; i ++ ) { memcpy ( units [ i ] , data , ssize ) ; units [ i ] [ ssize ] = 0 ; data += ssize ; } } GPMF_ScaledData ( ms , tmpbuffer , buffersize , 0 , samples , GPMF_TYPE_DOUBLE ) ; ptr = tmpbuffer ; for ( i = 0 ; i < samples ; i ++ ) { printf ( ""%c%c%c%c"" , PRINTF_4CC ( key ) ) ; for ( j = 0 ; j < elements ; j ++ ) printf ( ""%.3f%s,"" , * ptr ++ , units [ j % unit_samples ] ) ; printf ( ""\\n"" ) ; } free ( tmpbuffer ) ; } } GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif } # if 1 while ( GPMF_OK == GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ) { if ( GPMF_OK == GPMF_SeekToSamples ( ms ) ) {  uint32_t fourcc = GPMF_Key ( ms ) ;   double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ;   printf ( ""%c%c%c%csamplingrate=%fHz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ;  } } # endif cleanup : if ( payload ) FreePayload ( payload ) ; payload = NULL ; CloseSource ( mp4 ) ; } return ret ; }"," MOV_GPMF_TRAK_SUBTYPE ) ; if ( mp4 == 0 ) { printf ( ""error:%sisaninvalidMP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; }  index ) ; double  in = 0.0  ) ) { double in = 0.0 , out = 0.0 ;  fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ; printf ( ""%c%c%c%csamplingrate=%fHz(from%fto%f)\\n""  , PRINTF_4CC (  ) , rate , in , out"
764,"CWE-000 static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ;  cur_logical ++ ;  pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }", pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;
765,"CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , ""tty_ioctl"" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD :  return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ;  case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }"," TIOCGETD : return tiocgetd ( tty ,  p ) ;"
766,"CWE-125 struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ;  uint32_t track_size ;  uint8_t * * tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 4 ; if ( tmp_val != 6 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , NULL , 0 ) ; return ( NULL ) ; } tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val > 2 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } midi_type = tmp_val ; tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val < 1 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(notracks)"" , 0 ) ; return ( NULL ) ; } no_tracks = tmp_val ; if ( ( midi_type == 0 ) && ( no_tracks > 1 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , ""(expected1trackfortype0midifile,foundmore)"" , 0 ) ; return ( NULL ) ; } divisions = * midi_data ++ << 8 ; divisions |= * midi_data ++ ; midi_size -= 2 ; if ( divisions & 0x00008000 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mdi , divisions ) ; tracks = malloc ( sizeof ( uint8_t * ) * no_tracks ) ;  track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;  track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ; running_event = malloc ( sizeof ( uint8_t ) * no_tracks ) ; smallest_delta = 0xffffffff ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( midi_size < 8 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; goto _end ; } if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missingtrackheader)"" , 0 ) ; goto _end ; } midi_data += 4 ; midi_size -= 4 ;  track_size = * midi_data ++ << 24 ;   track_size |= * midi_data ++ << 16 ;   track_size |= * midi_data ++ << 8 ;   track_size |= * midi_data ++ ;  midi_size -= 4 ;  if ( midi_size < track_size ) {  _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; goto _end ; }  if ( track_size < 3 ) {  _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(badtracksize)"" , 0 ) ; goto _end ; }  if ( ( midi_data [ track_size - 3 ] != 0xFF )   || ( midi_data [ track_size - 2 ] != 0x2F )   || ( midi_data [ track_size - 1 ] != 0x00 ) ) {  _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missingEOT)"" , 0 ) ; goto _end ; } tracks [ i ] = midi_data ;  midi_data += track_size ;   midi_size -= track_size ;  track_end [ i ] = 0 ; running_event [ i ] = 0 ; track_delta [ i ] = 0 ; while ( * tracks [ i ] > 0x7F ) { track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; tracks [ i ] ++ ;  }  track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;  tracks [ i ] ++ ;  if ( midi_type == 1 ) { if ( track_delta [ i ] < smallest_delta ) { smallest_delta = track_delta [ i ] ; } } else { if ( i == 0 ) smallest_delta = track_delta [ i ] ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; if ( midi_type == 1 ) { while ( end_of_tracks != no_tracks ) { smallest_delta = 0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( track_end [ i ] ) continue ; if ( track_delta [ i ] ) { track_delta [ i ] -= subtract_delta ; if ( track_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } continue ; } } do {  setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;  if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { end_of_tracks ++ ; track_end [ i ] = 1 ; tracks [ i ] += 3 ;  goto NEXT_TRACK ;  } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ;  if ( * tracks [ i ] > 0x7f ) {  do {  track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;  tracks [ i ] ++ ;  } while ( * tracks [ i ] > 0x7f ) ;  }  track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;   tracks [ i ] ++ ;  } while ( ! track_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } NEXT_TRACK : continue ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; } } else { if ( midi_type == 2 ) { mdi -> is_type2 = 1 ; } sample_remainder = 0.0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do {  setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;  if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { track_end [ i ] = 1 ; goto NEXT_TRACK2 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ;  track_delta [ i ] = 0 ;  if ( * tracks [ i ] > 0x7f ) { do {  track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;  tracks [ i ] ++ ;  } while ( * tracks [ i ] > 0x7f ) ;  }  track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;   tracks [ i ] ++ ;  sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; NEXT_TRACK2 : smallest_delta = track_delta [ i ] ; UNUSED ( smallest_delta ) ; } while ( track_end [ i ] == 0 ) ; } } if ( ( mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""toinitreverb"" , 0 ) ; goto _end ; } mdi -> extra_info . current_sample = 0 ; mdi -> current_event = & mdi -> events [ 0 ] ; mdi -> samples_to_mix = 0 ; mdi -> note = NULL ; _WM_ResetToStart ( mdi ) ; _end : free ( sysex_store ) ; free ( track_end ) ; free ( track_delta ) ; free ( running_event ) ; free ( tracks ) ;  if ( mdi -> reverb ) return ( mdi ) ;  _WM_freeMDI ( mdi ) ; return ( NULL ) ; }"," uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size  ; uint32_t end_of_tracks  no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ;  -= 4 ; tmp_val  = * midi_data  << 24 ; tmp_val  |= * midi_data  << 16 ; tmp_val  |= * midi_data  << 8 ; tmp_val  |= * midi_data  ( midi_size < tmp_val  ) { _WM_GLOBAL_ERROR  } if ( tmp_val  < 3 )  ( midi_data [ tmp_val  - 3 ]  ( midi_data [ tmp_val  - 2 ]  ( midi_data [ tmp_val  - 1 ]  = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val  ; midi_size -=  ; midi_size -= tmp_val  ; track_end [  ] ++ ; track_size [ i ] -- ;  i ] ++ ; track_size [ i ] --  i ] , track_size [ i ] ,  += 3 ; track_size [ i ] -= 3 ;  += setup_ret ; track_size [ i ] -= setup_ret ;  { do { if ( ! track_size [ i ] ) break ;  ] ++ ; track_size [ i ] -- ;  ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; goto _end ; }  i ] ++ ; track_size [ i ] --  i ] , track_size [ i ] ,  += setup_ret ; track_size [ i ] -= setup_ret ;  { do { if ( ! track_size [ i ] ) break ;  ] ++ ; track_size [ i ] -- ;  ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; goto _end ; }  i ] ++ ; track_size [ i ] --  tracks ) ; free ( track_size ) ;"
767,"CWE-264 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cpus ; } if ( flags & PERF_FLAG_PID_CGROUP ) { err = perf_cgroup_connect ( pid , event , & attr , group_leader ) ; if ( err ) { __free_event ( event ) ; goto err_cpus ; } } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - ENOTSUPP ; goto err_alloc ; } } account_event ( event ) ; pmu = event -> pmu ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_flags & PERF_GROUP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event -> cpu ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( task ) { put_task_struct ( task ) ; task = NULL ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( move_group ) {  if ( group_leader -> ctx -> type != ctx -> type )  goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; goto err_context ; } if ( move_group ) { struct perf_event_context * gctx = group_leader -> ctx ; mutex_lock ( & gctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } mutex_unlock ( & gctx -> mutex ) ; put_ctx ( gctx ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; mutex_lock ( & ctx -> mutex ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; mutex_unlock ( & ctx -> mutex ) ; put_online_cpus ( ) ; event -> owner = current ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : free_event ( event ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }", -> ctx -> task  != ctx ->  != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu  ) goto err_context
768,"CWE-682 WORD32 ihevcd_decode ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { WORD32 ret = IV_SUCCESS ; codec_t * ps_codec = ( codec_t * ) ( ps_codec_obj -> pv_codec_handle ) ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; WORD32 proc_idx = 0 ; WORD32 prev_proc_idx = 0 ; ps_codec -> i4_error_code = 0 ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } if ( ps_codec -> i4_init_done != 1 ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_INIT_NOT_DONE ; return IV_FAIL ; } if ( ps_codec -> u4_pic_cnt >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED ; return IV_FAIL ; } if ( ps_codec -> i4_reset_flag ) { ps_codec -> i4_flush_mode = 1 ; } if ( 0 == ps_codec -> i4_flush_mode ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= MIN_START_CODE_LEN ) { if ( ( WORD32 ) ps_dec_ip -> u4_num_Bytes > 0 ) ps_dec_op -> u4_num_bytes_consumed = ps_dec_ip -> u4_num_Bytes ; else ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } # ifdef APPLY_CONCEALMENT { WORD32 num_mbs ; num_mbs = ( ps_codec -> i4_wd * ps_codec -> i4_ht + 255 ) >> 8 ; ps_codec -> mb_count = 0 ; memset ( ps_codec -> mb_map , 0 , ( ( num_mbs + 7 ) >> 3 ) ) ; } # endif if ( 0 == ps_codec -> i4_share_disp_buf && ps_codec -> i4_header_mode == 0 ) { UWORD32 i ; if ( ps_dec_ip -> s_out_buffer . u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec_ip -> s_out_buffer . u4_num_bufs ; i ++ ) { if ( ps_dec_ip -> s_out_buffer . pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> s_out_buffer . u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } ps_codec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_codec -> u4_ts = ps_dec_ip -> u4_ts ; if ( ps_codec -> i4_flush_mode ) { ps_dec_op -> u4_pic_wd = ps_codec -> i4_disp_wd ; ps_dec_op -> u4_pic_ht = ps_codec -> i4_disp_ht ; ps_dec_op -> u4_new_seq = 0 ; ps_codec -> ps_disp_buf = ( pic_buf_t * ) ihevc_disp_mgr_get ( ( disp_mgr_t * ) ps_codec -> pv_disp_buf_mgr , & ps_codec -> i4_disp_buf_id ) ; if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ prev_proc_idx ] ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } ret = ihevcd_check_out_buf_size ( ps_codec ) ; RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; ret = ihevcd_fmt_conv ( ps_codec , & ps_codec -> as_process [ prev_proc_idx ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , 0 , ps_codec -> i4_disp_ht ) ; ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> i4_disp_buf_id , BUF_MGR_DISP ) ; } ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; if ( 1 == ps_dec_op -> u4_output_present ) { WORD32 xpos = ps_codec -> i4_disp_wd - 32 - LOGO_WD ; WORD32 ypos = ps_codec -> i4_disp_ht - 32 - LOGO_HT ; if ( ypos < 0 ) ypos = 0 ; if ( xpos < 0 ) xpos = 0 ; INSERT_LOGO ( ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> i4_disp_strd , xpos , ypos , ps_codec -> e_chroma_fmt , ps_codec -> i4_disp_wd , ps_codec -> i4_disp_ht ) ; } if ( NULL == ps_codec -> ps_disp_buf ) { if ( ps_codec -> i4_reset_flag ) { ihevcd_init ( ps_codec ) ; } return ( IV_FAIL ) ; } return ( IV_SUCCESS ) ; } if ( ( 0 == ps_codec -> i4_header_mode ) && ( 1 == ps_codec -> i4_share_disp_buf ) ) { WORD32 buf_status ; buf_status = 1 ; if ( ps_codec -> pv_pic_buf_mgr ) buf_status = ihevc_buf_mgr_check_free ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr ) ; if ( 0 == buf_status ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return IV_FAIL ; } } ps_codec -> i4_bytes_remaining = ps_dec_ip -> u4_num_Bytes ; ps_codec -> pu1_inp_bitsbuf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer ; ps_codec -> s_parse . i4_end_of_frame = 0 ; ps_codec -> i4_pic_present = 0 ; ps_codec -> i4_slice_error = 0 ; ps_codec -> ps_disp_buf = NULL ; if ( ps_codec -> i4_num_cores > 1 ) { ithread_set_affinity ( 0 ) ; } while ( MIN_START_CODE_LEN < ps_codec -> i4_bytes_remaining ) { WORD32 nal_len ; WORD32 nal_ofst ; WORD32 bits_len ; if ( ps_codec -> i4_slice_error ) { slice_header_t * ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_codec -> s_parse . ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) ps_codec -> i4_slice_error = 0 ; } if ( ps_codec -> pu1_bitsbuf_dynamic ) { ps_codec -> pu1_bitsbuf = ps_codec -> pu1_bitsbuf_dynamic ; ps_codec -> u4_bitsbuf_size = ps_codec -> u4_bitsbuf_size_dynamic ; } else { ps_codec -> pu1_bitsbuf = ps_codec -> pu1_bitsbuf_static ; ps_codec -> u4_bitsbuf_size = ps_codec -> u4_bitsbuf_size_static ; } nal_ofst = ihevcd_nal_search_start_code ( ps_codec -> pu1_inp_bitsbuf , ps_codec -> i4_bytes_remaining ) ; ps_codec -> i4_nal_ofst = nal_ofst ; { WORD32 bytes_remaining = ps_codec -> i4_bytes_remaining - nal_ofst ; bytes_remaining = MIN ( ( UWORD32 ) bytes_remaining , ps_codec -> u4_bitsbuf_size ) ; ihevcd_nal_remv_emuln_bytes ( ps_codec -> pu1_inp_bitsbuf + nal_ofst , ps_codec -> pu1_bitsbuf , bytes_remaining , & nal_len , & bits_len ) ; if ( bits_len < ( WORD32 ) ( ps_codec -> u4_bitsbuf_size - 8 ) ) { memset ( ps_codec -> pu1_bitsbuf + bits_len , 0 , 2 * sizeof ( UWORD32 ) ) ; } } ps_codec -> i4_num_emln_bytes = nal_len - bits_len ; ps_codec -> i4_nal_len = nal_len ; ihevcd_bits_init ( & ps_codec -> s_parse . s_bitstrm , ps_codec -> pu1_bitsbuf , bits_len ) ; ret = ihevcd_nal_unit ( ps_codec ) ; if ( ps_codec -> i4_pic_present && ( ps_codec -> s_parse . i4_next_ctb_indx != ps_codec -> s_parse . ps_sps -> i4_pic_size_in_ctb ) ) { if ( ( ps_codec -> i4_bytes_remaining - ( nal_len + nal_ofst ) <= MIN_START_CODE_LEN ) || ( ps_codec -> i4_header_in_slice_mode ) ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; ps_codec -> i4_slice_error = 1 ; continue ; } } if ( IHEVCD_IGNORE_SLICE == ret ) {  ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ;  ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ; ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ; continue ; } if ( ( IVD_RES_CHANGED == ret ) || ( IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret ) ) { break ; } if ( ret != IHEVCD_SLICE_IN_HEADER_MODE ) { if ( ( 0 == ps_codec -> i4_slice_error ) || ( ps_codec -> i4_bytes_remaining - ( nal_len + nal_ofst ) <= MIN_START_CODE_LEN ) ) { ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ; ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ; } if ( ret != IHEVCD_SUCCESS ) break ; if ( ps_codec -> s_parse . i4_end_of_frame ) break ; } else { ret = IHEVCD_SUCCESS ; break ; } if ( ( ps_codec -> u4_allocate_dynamic_done == 0 ) && ps_codec -> i4_sps_done ) { WORD32 ret ; ret = ihevcd_allocate_dynamic_bufs ( ps_codec ) ; if ( ret != IV_SUCCESS ) { ihevcd_free_dynamic_bufs ( ps_codec ) ; ps_codec -> i4_error_code = IVD_MEM_ALLOC_FAILED ; ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IVD_MEM_ALLOC_FAILED ; return IV_FAIL ; } } BREAK_AFTER_SLICE_NAL ( ) ; } if ( ( ps_codec -> u4_pic_cnt == 0 ) && ( ret != IHEVCD_SUCCESS ) ) { ps_codec -> i4_error_code = ret ; ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; return IV_FAIL ; } if ( 1 == ps_codec -> i4_pic_present ) { WORD32 i ; sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> i4_first_pic_done = 1 ; if ( ps_codec -> i4_num_cores > 1 && ps_codec -> s_parse . i4_end_of_frame ) { process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ps_codec -> i4_num_cores - 1 ] ; if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) ) { if ( ( 0 == ps_codec -> u4_enable_fmt_conv_ahead ) || ( ps_codec -> i4_disp_buf_id == ps_proc -> i4_cur_pic_buf_id ) ) for ( i = 0 ; i < ps_sps -> i2_pic_ht_in_ctb ; i ++ ) { proc_job_t s_job ; IHEVCD_ERROR_T ret ; s_job . i4_cmd = CMD_FMTCONV ; s_job . i2_ctb_cnt = 0 ; s_job . i2_ctb_x = 0 ; s_job . i2_ctb_y = i ; s_job . i2_slice_idx = 0 ; s_job . i4_tu_coeff_data_ofst = 0 ; ret = ihevcd_jobq_queue ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) return ( WORD32 ) ret ; } } ret = ihevcd_jobq_terminate ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq ) ; while ( 1 ) { IHEVCD_ERROR_T ret ; proc_job_t s_job ; process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ps_codec -> i4_num_cores - 1 ] ; ret = ihevcd_jobq_dequeue ( ( jobq_t * ) ps_proc -> pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS != ret ) break ; ps_proc -> i4_ctb_cnt = s_job . i2_ctb_cnt ; ps_proc -> i4_ctb_x = s_job . i2_ctb_x ; ps_proc -> i4_ctb_y = s_job . i2_ctb_y ; ps_proc -> i4_cur_slice_idx = s_job . i2_slice_idx ; if ( CMD_PROCESS == s_job . i4_cmd ) { ihevcd_init_proc_ctxt ( ps_proc , s_job . i4_tu_coeff_data_ofst ) ; ihevcd_process ( ps_proc ) ; } else if ( CMD_FMTCONV == s_job . i4_cmd ) { sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; WORD32 num_rows = 1 << ps_sps -> i1_log2_ctb_size ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } num_rows = MIN ( num_rows , ( ps_codec -> i4_disp_ht - ( s_job . i2_ctb_y << ps_sps -> i1_log2_ctb_size ) ) ) ; if ( num_rows < 0 ) num_rows = 0 ; ihevcd_fmt_conv ( ps_codec , ps_proc , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , s_job . i2_ctb_y << ps_sps -> i1_log2_ctb_size , num_rows ) ; } } } else if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) && ( ps_codec -> s_parse . i4_end_of_frame ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ proc_idx ] ; ps_codec -> s_fmt_conv . i4_num_rows = ps_codec -> i4_disp_ht - ps_codec -> s_fmt_conv . i4_cur_row ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } if ( ps_codec -> s_fmt_conv . i4_num_rows < 0 ) ps_codec -> s_fmt_conv . i4_num_rows = 0 ; ret = ihevcd_fmt_conv ( ps_codec , ps_proc , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> s_fmt_conv . i4_cur_row , ps_codec -> s_fmt_conv . i4_num_rows ) ; ps_codec -> s_fmt_conv . i4_cur_row += ps_codec -> s_fmt_conv . i4_num_rows ; } DEBUG_DUMP_MV_MAP ( ps_codec ) ; ihevc_buf_mgr_set_status ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , ps_codec -> as_process [ proc_idx ] . i4_cur_mv_bank_buf_id , BUF_MGR_REF ) ; ihevc_buf_mgr_set_status ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> as_process [ proc_idx ] . i4_cur_pic_buf_id , BUF_MGR_REF ) ; ihevc_buf_mgr_set_status ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> as_process [ proc_idx ] . i4_cur_pic_buf_id , BUF_MGR_DISP ) ; ihevc_dpb_mgr_insert_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ps_codec -> as_process [ proc_idx ] . ps_cur_pic , ps_codec -> as_process [ proc_idx ] . i4_cur_pic_buf_id ) ; if ( ( 0 == ps_codec -> i4_share_disp_buf ) && ( ps_codec -> ps_disp_buf ) ) ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> i4_disp_buf_id , BUF_MGR_DISP ) ; for ( i = 0 ; i < ( ps_codec -> i4_num_cores - 1 ) ; i ++ ) { if ( ps_codec -> ai4_process_thread_created [ i ] ) { ithread_join ( ps_codec -> apv_process_thread_handle [ i ] , NULL ) ; ps_codec -> ai4_process_thread_created [ i ] = 0 ; } } DEBUG_VALIDATE_PADDED_REGION ( & ps_codec -> as_process [ proc_idx ] ) ; if ( ps_codec -> u4_pic_cnt > 0 ) { DEBUG_DUMP_PIC_PU ( ps_codec ) ; } DEBUG_DUMP_PIC_BUFFERS ( ps_codec ) ; ps_codec -> u4_pic_cnt ++ ; } ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; if ( 1 == ps_dec_op -> u4_output_present ) { WORD32 xpos = ps_codec -> i4_disp_wd - 32 - LOGO_WD ; WORD32 ypos = ps_codec -> i4_disp_ht - 32 - LOGO_HT ; if ( ypos < 0 ) ypos = 0 ; if ( xpos < 0 ) xpos = 0 ; INSERT_LOGO ( ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> i4_disp_strd , xpos , ypos , ps_codec -> e_chroma_fmt , ps_codec -> i4_disp_wd , ps_codec -> i4_disp_ht ) ; } return ret ; }", { ps_codec ->  pu1_inp_bitsbuf += (
769,"CWE-399 void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) {  struct br_mdb_entry entry ;  entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }"," struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )"
770,"CWE-416 static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , ""deviceupdated:%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , ""updateDevice():memoryallocationerror"" ) ;  free ( p ) ;  return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , ""newdevicediscovered:%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , ""updateDevice():cannotallocatememory"" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }"," ""updateDevice():memoryallocationerror"" ) ; * pp = p -> next ;"
771,"CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ;  char * dbuf ;  char * ticket_buf ; u8 reply_struct_v ; u32 num ;  int ret ;  dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( ""%dtickets\\n"" , num ) ; while ( num -- ) {  ret = process_one_ticket ( ac , secret , & p , end ,  dbuf , ticket_buf ) ; if ( ret )  goto out ;  } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad :  ret = - EINVAL ;   goto out ;  }"," = buf ;  u8 reply_struct_v ;  ; int ret  ; ceph_decode_8_safe (  p , end  ) ; if  ( ret ) return ret ; } return 0  ; bad :  ; bad : return  - EINVAL ;  - EINVAL ;  }  "
772,"CWE-000  int fit_config_verify_required_sigs ( const void * fit , int conf_noffset ,  const void * sig_blob ) {  int noffset ;  int sig_node ; int verified = 0 ; int reqd_sigs = 0 ; bool reqd_policy_all = true ;  const char * reqd_mode ;  sig_node = fdt_subnode_offset ( sig_blob , 0 , FIT_SIG_NODENAME ) ; if ( sig_node < 0 ) { debug ( ""%s:Nosignaturenodefound:%s\\n"" , __func__ , fdt_strerror ( sig_node ) ) ; return 0 ; } reqd_mode = fdt_getprop ( sig_blob , sig_node , ""required-mode"" , NULL ) ; if ( reqd_mode && ! strcmp ( reqd_mode , ""any"" ) ) reqd_policy_all = false ; debug ( ""%s:required-modepolicysetto\'%s\'\\n"" , __func__ , reqd_policy_all ? ""all"" : ""any"" ) ; fdt_for_each_subnode ( noffset , sig_blob , sig_node ) { const char * required ; int ret ; required = fdt_getprop ( sig_blob , noffset , FIT_KEY_REQUIRED , NULL ) ; if ( ! required || strcmp ( required , ""conf"" ) ) continue ; reqd_sigs ++ ; ret = fit_config_verify_sig ( fit , conf_noffset , sig_blob , noffset ) ; if ( ret ) { if ( reqd_policy_all ) { printf ( ""Failedtoverifyrequiredsignature\'%s\'\\n"" , fit_get_name ( sig_blob , noffset , NULL ) ) ; return ret ; } } else { verified ++ ; if ( ! reqd_policy_all ) break ; } } if ( reqd_sigs && ! verified ) { printf ( ""Failedtoverify\'any\'oftherequiredsignature(s)\\n"" ) ; return - EPERM ; } return 0 ; }","    static  sig_blob ) { const char * name = fit_get_name ( fit , conf_noffset , NULL ) ;  * reqd_mode ; if ( strchr ( name , '@' ) ) { printf ( ""Configurationnode\'%s\'contains\'@\'\\n"" , name ) ; return - EPERM ; }"
773,"CWE-119  void vp9_rc_init_minq_luts ( ) {  int i ; for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) { const double maxq = vp9_convert_qindex_to_q ( i ) ; kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.15 ) ; kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ; gf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.32 ) ; gf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ; afq_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.33 ) ; afq_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.55 ) ; inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.75 ) ; } }"," void vp9_rc_init_minq_luts ( void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif  }  "
774,"CWE-295 void log_flush ( LOG_MODE new_mode ) { CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_LOG_MODE ] ) ;  if ( log_mode != LOG_MODE_CONFIGURED || new_mode != LOG_MODE_ERROR )  log_mode = new_mode ; if ( new_mode != LOG_MODE_BUFFER ) { CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_LOG_BUFFER ] ) ; while ( head ) { struct LIST * tmp = head ; head = head -> next ; log_raw ( tmp -> opt , tmp -> level , tmp -> stamp , tmp -> id , tmp -> text ) ; str_free ( tmp ) ; } head = tail = NULL ; CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_LOG_BUFFER ] ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_LOG_MODE ] ) ; }", ] ) ;  log_mode = new_mode
775,"CWE-269 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ;  s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;  s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;  s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;  if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""GenericHardware"" ) ) device = ""GenericSoftware"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""FailedtoopenOpenALdevice\'%s\',tryingdefault.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""FailedtoopenOpenALdevice.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""FailedtocreateOpenALcontext.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated%dsources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenALcapturesupportdisabledbyuser(\'+sets_alCapture1\'toenable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenALcapturesupportdisabledforMumblesupport\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""NoALC_EXT_capturesupport,can\'trecordaudio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenALdefaultcapturedeviceis\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""FailedtoopenOpenALInputdevice\'%s\',tryingdefault.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenALcapturedevice%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failedtoopen"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }"," CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED  CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""RejectingDLLnamed\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }"
776,"CWE-189 int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ;  if ( args -> buffer_count < 1 ) {  DRM_DEBUG ( ""execbuf2with%dbuffers\\n"" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( ""Failedtoallocateexeclistfor%dbuffers\\n"" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( ""copy%dexecentriesfailed%d\\n"" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( ""failedtocopy%dexecentries"" ""backtouser(%d)\\n"" , args -> buffer_count , ret ) ; } } drm_free_large ( exec2_list ) ; return ret ; }", buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
777,"CWE-284 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) {  p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;  list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ;  pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ;  if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ;  umount_mnt ( p ) ;  }  change_mnt_propagation ( p , MS_PRIVATE ) ;  } }"," ) ) { bool disconnect ;  |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;  -> mnt , disconnect ? & unmounted : NULL  ) ; if  1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else {  ) ; } }"
778,"CWE-119 php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Redirectionlimitreached,aborting"" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) { if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) { php_url_free ( resource ) ; return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; } request_fulluri = 1 ; use_ssl = 0 ; use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { if ( strpbrk ( mode , ""awx+"" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTPwrapperdoesnotsupportwriteableconnections"" ) ; php_url_free ( resource ) ; return NULL ; } use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ; else if ( resource -> port == 0 ) resource -> port = 80 ; if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { transport_len = spprintf ( & transport_string , 0 , ""%s://%s:%d"" , use_ssl ? ""ssl"" : ""tcp"" , resource -> host , resource -> port ) ; } } if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; } else { timeout . tv_sec = FG ( default_socket_timeout ) ; timeout . tv_usec = 0 ; } stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ; if ( stream ) { php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; } if ( errstr ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ; efree ( errstr ) ; errstr = NULL ; } efree ( transport_string ) ; if ( stream && use_proxy && use_ssl ) { smart_str header = { 0 } ; if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) { MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ; } smart_str_appendl ( & header , ""CONNECT"" , sizeof ( ""CONNECT"" ) - 1 ) ; smart_str_appends ( & header , resource -> host ) ; smart_str_appendc ( & header , ':' ) ; smart_str_append_unsigned ( & header , resource -> port ) ; smart_str_appendl ( & header , ""HTTP/1.0\\r\\n"" , sizeof ( ""HTTP/1.0\\r\\n"" ) - 1 ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { char * s , * p ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { s = Z_STRVAL_PP ( tmpheader ) ; do { while ( * s == '' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { s = Z_STRVAL_PP ( tmpzval ) ; do { while ( * s == '' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } finish : smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""CannotconnecttoHTTPSserverthroughproxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } smart_str_free ( & header ) ; if ( stream ) { char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) { break ; } } } if ( stream ) { if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""CannotconnecttoHTTPSserverthroughproxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } } } if ( stream == NULL ) goto out ; if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; php_stream_context_set ( stream , context ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; redirect_max = Z_LVAL_PP ( tmpzval ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) { if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) { scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; scratch = emalloc ( scratch_len ) ; strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; strncat ( scratch , """" , 1 ) ; } } } if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ; } if ( ! scratch ) { scratch_len = strlen ( path ) + 29 + protocol_version_len ; scratch = emalloc ( scratch_len ) ; strncpy ( scratch , ""GET"" , scratch_len ) ; } if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) { zval ztmp = * * tmpzval ; zval_copy_ctor ( & ztmp ) ; convert_to_boolean ( & ztmp ) ; request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; zval_dtor ( & ztmp ) ; } if ( request_fulluri ) { strcat ( scratch , path ) ; } else { if ( resource -> path && * resource -> path ) { strlcat ( scratch , resource -> path , scratch_len ) ; } else { strlcat ( scratch , ""/"" , scratch_len ) ; } if ( resource -> query ) { strlcat ( scratch , ""?"" , scratch_len ) ; strlcat ( scratch , resource -> query , scratch_len ) ; } } if ( protocol_version ) { strlcat ( scratch , ""HTTP/"" , scratch_len ) ; strlcat ( scratch , protocol_version , scratch_len ) ; strlcat ( scratch , ""\\r\\n"" , scratch_len ) ; } else { strlcat ( scratch , ""HTTP/1.0\\r\\n"" , scratch_len ) ; } php_stream_write ( stream , scratch , strlen ( scratch ) ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { tmp = NULL ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; smart_str tmpstr = { 0 } ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; smart_str_appendl ( & tmpstr , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } } smart_str_0 ( & tmpstr ) ; if ( tmpstr . c ) { tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; smart_str_free ( & tmpstr ) ; } } if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; } if ( tmp && strlen ( tmp ) > 0 ) { char * s ; user_headers = estrdup ( tmp ) ; php_strtolower ( tmp , strlen ( tmp ) ) ; if ( ! header_init ) { strip_header ( user_headers , tmp , ""content-length:"" ) ; strip_header ( user_headers , tmp , ""content-type:"" ) ; } if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_USER_AGENT ; } if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_HOST ; } if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_FROM ; } if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_AUTH ; } if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_CONTENT_LENGTH ; } if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_TYPE ; } if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { have_header |= HTTP_HEADER_CONNECTION ; } if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '' ) ) { char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ; while ( s > tmp && ( * ( s - 1 ) == '' || * ( s - 1 ) == '\\t' ) ) s -- ; while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; while ( * p == '\\r' || * p == '\\n' ) p ++ ; if ( * p == 0 ) { if ( s == tmp ) { efree ( user_headers ) ; user_headers = NULL ; } else { while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; user_headers [ s - tmp ] = 0 ; } } else { memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; } } } if ( tmp ) { efree ( tmp ) ; } } if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; strcpy ( scratch , resource -> user ) ; strcat ( scratch , "":"" ) ; if ( resource -> pass ) { php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; strcat ( scratch , resource -> pass ) ; } tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; if ( snprintf ( scratch , scratch_len , ""Authorization:Basic%s\\r\\n"" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; } efree ( tmp ) ; tmp = NULL ; } if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { if ( snprintf ( scratch , scratch_len , ""From:%s\\r\\n"" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , ""Host:%s:%i\\r\\n"" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } else { if ( snprintf ( scratch , scratch_len , ""Host:%s\\r\\n"" , resource -> host ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } } } if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { php_stream_write_string ( stream , ""Connection:close\\r\\n"" ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ; } else if ( FG ( user_agent ) ) { ua_str = FG ( user_agent ) ; } if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { # define _UA_HEADER ""User-Agent:%s\\r\\n"" char * ua ; size_t ua_len ; ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; if ( ua_len > sizeof ( _UA_HEADER ) ) { ua = emalloc ( ua_len + 1 ) ; if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { ua [ ua_len ] = 0 ; php_stream_write ( stream , ua , ua_len ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""CannotconstructUser-agentheader"" ) ; } if ( ua ) { efree ( ua ) ; } } } if ( user_headers ) { if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; have_header |= HTTP_HEADER_CONTENT_LENGTH ; } php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; efree ( user_headers ) ; } if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; } if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { php_stream_write ( stream , ""Content-Type:application/x-www-form-urlencoded\\r\\n"" , sizeof ( ""Content-Type:application/x-www-form-urlencoded\\r\\n"" ) - 1 ) ; php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-typenotspecifiedassumingapplication/x-www-form-urlencoded"" ) ; } php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } location [ 0 ] = '\\0' ; if ( ! EG ( active_symbol_table ) ) { zend_rebuild_symbol_table ( TSRMLS_C ) ; } if ( header_init ) { zval * ztmp ; MAKE_STD_ZVAL ( ztmp ) ; array_init ( ztmp ) ; ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ; } { zval * * rh ; if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTPrequestfailed,http_response_headeroverwritten"" ) ; goto out ; } response_header = * rh ; Z_ADDREF_P ( response_header ) ; } if ( ! php_stream_eof ( stream ) ) { size_t tmp_line_len ; if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { zval * http_response ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) { ignore_errors = zend_is_true ( * tmpzval ) ; } if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { reqok = 1 ; } if ( response_code >= 100 && response_code < 200 ) { while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } } if ( response_code >= 200 && response_code < 400 ) { reqok = 1 ; } else { switch ( response_code ) { case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ; break ; default : if ( ! tmp_line_len ) { tmp_line [ 0 ] = '\\0' ; } php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ; } }  if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) {  -- tmp_line_len ;  if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) {  -- tmp_line_len ; } } MAKE_STD_ZVAL ( http_response ) ; ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; } } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTPrequestfailed,unexpectedendofsocket!"" ) ; goto out ; } http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; while ( ! body && ! php_stream_eof ( stream ) ) { size_t http_header_line_length ; if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { char * e = http_header_line + http_header_line_length - 1 ; if ( * e != '\\n' ) { do { if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""FailedtoreadHTTPheaders"" ) ; goto out ; } e = http_header_line + http_header_line_length - 1 ; } while ( * e != '\\n' ) ; continue ; } while ( * e == '\\n' || * e == '\\r' ) { e -- ; } http_header_line_length = e - http_header_line + 1 ; http_header_line [ http_header_line_length ] = '\\0' ; if ( ! strncasecmp ( http_header_line , ""Location:"" , 10 ) ) { if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; follow_location = Z_LVAL_PP ( tmpzval ) ; } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { follow_location = 0 ; } strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Type:"" , 14 ) ) { php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Length:"" , 16 ) ) { file_size = atoi ( http_header_line + 16 ) ; php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:chunked"" , sizeof ( ""Transfer-Encoding:chunked"" ) ) ) { if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { long decode = 1 ; if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_boolean ( * tmpzval ) ; decode = Z_LVAL_PP ( tmpzval ) ; } if ( decode ) { transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; if ( transfer_encoding ) { continue ; } } } } if ( http_header_line [ 0 ] == '\\0' ) { body = 1 ; } else { zval * http_header ; MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else { break ; } } if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { goto out ; } if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; php_stream_close ( stream ) ; stream = NULL ; if ( location [ 0 ] != '\\0' ) { char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; * new_path = '\\0' ; if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) { if ( * location != '/' ) { if ( * ( location + 1 ) != '\\0' && resource -> path ) { char * s = strrchr ( resource -> path , '/' ) ; if ( ! s ) { s = resource -> path ; if ( ! s [ 0 ] ) { efree ( s ) ; s = resource -> path = estrdup ( ""/"" ) ; } else { * s = '/' ; } } s [ 1 ] = '\\0' ; if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ; } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ; } } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ; } } else { strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; } if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; } else { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ; } } else { strlcpy ( new_path , location , sizeof ( new_path ) ) ; } php_url_free ( resource ) ; if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""InvalidredirectURL!%s"" , new_path ) ; goto out ; }  # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""InvalidredirectURL!%s"" , new_path ) ; goto out ; } s ++ ; } } }  if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) { CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) } stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTPrequestfailed!%s"" , tmp_line ) ; } } out : if ( protocol_version ) { efree ( protocol_version ) ; } if ( http_header_line ) { efree ( http_header_line ) ; } if ( scratch ) { efree ( scratch ) ; } if ( resource ) { php_url_free ( resource ) ; } if ( stream ) { if ( header_init ) { stream -> wrapperdata = response_header ; } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } } php_stream_notify_progress_init ( context , 0 , file_size ) ; if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ; stream -> flags |= eol_detect ; stream -> position = 0 ; strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; if ( transfer_encoding ) { php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; } } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } if ( transfer_encoding ) { php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; } } return stream ; }", } if ( tmp_line_len >= 1 &&  ; if ( tmp_line_len >= 1 &&  ; } } \\\n}  if ( strncasecmp
779,"CWE-416 void comps_objrtree_unite ( COMPS_ObjRTree * rt1 , COMPS_ObjRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ;  char added ;  } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data != NULL ) { comps_objrtree_set ( rt1 , pair -> key , ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }", * key ;  } * pair
780,"CWE-119 static grub_err_t read_foo ( struct grub_disk * disk , grub_disk_addr_t sector , grub_size_t size , char * buf ) {  if ( disk != NULL ) {   const int blocksize = 512 ;  int ret ; RIOBind * iob = disk -> data ;  if ( bio ) iob = bio ;   ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) ,   ( ut8 * ) buf , size * blocksize ) ;   if ( ret == - 1 )  return 1 ;  } else eprintf ( ""oops.nodisk\\n"" ) ;  return 0 ; }"," { if ( ! disk ) { eprintf ( ""oops.nodisk\\n"" ) ; return 1 ; }  const int blocksize  blocksize = 512  ; RIOBind *  ( bio ) {  = bio ; } if (  iob -> read_at  * blocksize )  == - 1  - 1 ) {  1 ; }  return 0 ;"
781,"CWE-200 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , ""tty_ioctl"" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD :  return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ;  case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }"," TIOCGETD : return tiocgetd ( tty ,  p ) ;"
782,"CWE-362 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ;  start = vma -> vm_start ;  if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }", return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;
783,"CWE-20 error_t coapClientReadBody ( CoapClientRequest * request , void * data , size_t size , size_t * received ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; * received = 0 ; while ( * received < size ) { responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientReadPayload ( responseMsg , data , size - * received , & n ) ; if ( error == NO_ERROR ) { data = ( uint8_t * ) data + n ; * received += n ; } else if ( error == ERROR_END_OF_STREAM ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapClientGetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> rxBlockSzx ; } error = coapClientGetUintOption ( responseMsg , COAP_OPT_BLOCK2 , 0 , & value ) ; if ( ! error ) { if ( COAP_GET_BLOCK_SZX ( value ) >= COAP_BLOCK_SIZE_RESERVED ) { error = ERROR_FAILURE ; break ; } if ( COAP_GET_BLOCK_POS ( value ) != blockPos ) { error = ERROR_FAILURE ; break ; } if ( ! COAP_GET_BLOCK_M ( value ) ) { error = ERROR_END_OF_STREAM ; break ; } error = coapClientGetPayload ( responseMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( payloadLen != COAP_GET_BLOCK_SIZE ( value ) ) { error = ERROR_FAILURE ; break ; } if ( blockSzx > COAP_GET_BLOCK_SZX ( value ) ) blockSzx = COAP_GET_BLOCK_SZX ( value ) ; blockPos += COAP_GET_BLOCK_SIZE ( value ) ; COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; COAP_SET_BLOCK_M ( value , 0 ) ; COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , value ) ; if ( error ) break ; error = coapClientSendRequest ( request , NULL , NULL ) ; if ( error ) break ; responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientGetResponseCode ( responseMsg , & responseCode ) ; if ( error ) break ; if ( COAP_GET_CODE_CLASS ( responseCode ) != COAP_CODE_CLASS_SUCCESS ) { error = ERROR_INVALID_STATUS ; break ; } } else { if ( blockPos == 0 )  error = ERROR_END_OF_STREAM ;   else   error = ERROR_FAILURE ;  break ; } } else { break ; } } if ( * received > 0 ) { if ( error == ERROR_END_OF_STREAM ) error = NO_ERROR ; } return error ; }", == 0 ) {  = ERROR_END_OF_STREAM ; } else {  error = ERROR_FAILURE  = ERROR_FAILURE ; }
784,"CWE-119 static size_t encode_tiles ( VP9_COMP * cpi , uint8_t * data_ptr ) { VP9_COMMON * const cm = & cpi -> common ;  vp9_writer residual_bc ;  int tile_row , tile_col ;  TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ;  size_t total_size = 0 ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ;  vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) *  mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ;  tok [ 0 ] [ 0 ] = cpi -> tok ;  for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { if ( tile_row ) tok [ tile_row ] [ 0 ] = tok [ tile_row - 1 ] [ tile_cols - 1 ] + cpi -> tok_count [ tile_row - 1 ] [ tile_cols - 1 ] ; for ( tile_col = 1 ; tile_col < tile_cols ; tile_col ++ ) tok [ tile_row ] [ tile_col ] = tok [ tile_row ] [ tile_col - 1 ] + cpi -> tok_count [ tile_row ] [ tile_col - 1 ] ; } for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { TileInfo tile ; vp9_tile_init ( & tile , cm , tile_row , tile_col ) ;  tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ;  if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 )  vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ;  else  vp9_start_encode ( & residual_bc , data_ptr + total_size ) ;   write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ;   assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ;   vp9_stop_encode ( & residual_bc ) ;  if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) { mem_put_be32 ( data_ptr + total_size , residual_bc . pos ) ; total_size += 4 ; } total_size += residual_bc . pos ; } } return total_size ; }"," -> common ; vpx_writer  residual_bc ; int  tile_col ; TOKENEXTRA  * tok_end ;  -> log2_tile_rows ; memset  ( cm ->  ) ) ; for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ]  ; tok_end =  ; tok_end = cpi -> tile_tok [ tile_row ] [ tile_col ] +  cpi -> tok_count  - 1 ) vpx_start_encode  ( & residual_bc  ) ; else vpx_start_encode  ( & residual_bc  cpi , & cpi -> tile_data [ tile_idx ] . tile_info ,  & residual_bc ,  , & tok  , tok_end )  assert ( tok  == tok_end )  tok_end ) ; vpx_stop_encode  ( & residual_bc"
785,"CWE-264 static void opl3_setup_voice ( int dev , int voice , int chn ) {  struct channel_info * info =  & synth_devs [ dev ] -> chn_info [ chn ] ; opl3_set_instr ( dev , voice , info -> pgm_num ) ; devc -> voc [ voice ] . bender = 0 ; devc -> voc [ voice ] . bender_range = info -> bender_range ; devc -> voc [ voice ] . volume = info -> controllers [ CTL_MAIN_VOLUME ] ; devc -> voc [ voice ] . panning = ( info -> controllers [ CTL_PAN ] * 2 ) - 128 ; }", channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info
786,"CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR ) {  for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j )  if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneouspagecount.Leakingpages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( ( npages - i ) >= HPAGE_PMD_NR ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ;  for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j )  if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneouspagecount.Leakingpages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }", ( j = 1  ; j <  ( j = 1  ; j <
787,"CWE-200 static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB )  goto out ;  if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  }  if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }", ) goto out  ; skb =  ) ) ; * addr_len = sizeof ( * sin ) ;
788,"CWE-119  static void reset_fpf_position ( struct twopass_rc * p ,  const FIRSTPASS_STATS * position ) { p -> stats_in = position ; }"," void reset_fpf_position ( TWO_PASS  * p ,"
789,"CWE-787 void exif_data_load_data ( ExifData * data , const unsigned char * d_orig , unsigned int ds ) { unsigned int l ; ExifLong offset ; ExifShort n ; const unsigned char * d = d_orig ; unsigned int len , fullds ; if ( ! data || ! data -> priv || ! d || ! ds ) return ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Parsing%ibyte(s)EXIFdata...\\n"" , ds ) ; if ( ds < 6 ) { LOG_TOO_SMALL ; return ; } if ( ! memcmp ( d , ExifHeader , 6 ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""FoundEXIFheaderatstart."" ) ; } else { while ( ds >= 3 ) { while ( ds && ( d [ 0 ] == 0xff ) ) { d ++ ; ds -- ; } if ( ds && d [ 0 ] == JPEG_MARKER_SOI ) { d ++ ; ds -- ; continue ; } if ( ds && d [ 0 ] == JPEG_MARKER_APP1 ) break ; if ( ds >= 3 && d [ 0 ] >= 0xe0 && d [ 0 ] <= 0xef ) { d ++ ; ds -- ; l = ( d [ 0 ] << 8 ) | d [ 1 ] ; if ( l > ds ) return ; d += l ; ds -= l ; continue ; } exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , _ ( ""EXIFmarkernotfound."" ) ) ; return ; } if ( ds < 3 ) { LOG_TOO_SMALL ; return ; } d ++ ; ds -- ; len = ( d [ 0 ] << 8 ) | d [ 1 ] ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Wehavetodealwith%ibyte(s)ofEXIFdata."" , len ) ; d += 2 ; ds -= 2 ; } if ( ds < 6 ) { LOG_TOO_SMALL ; return ; } if ( memcmp ( d , ExifHeader , 6 ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , _ ( ""EXIFheadernotfound."" ) ) ; return ; } exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""FoundEXIFheader."" ) ; if ( ds < 14 ) return ; fullds = ds ; if ( ds > 0xfffe ) ds = 0xfffe ; if ( ! memcmp ( d + 6 , ""II"" , 2 ) ) data -> priv -> order = EXIF_BYTE_ORDER_INTEL ; else if ( ! memcmp ( d + 6 , ""MM"" , 2 ) ) data -> priv -> order = EXIF_BYTE_ORDER_MOTOROLA ; else { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , _ ( ""Unknownencoding."" ) ) ; return ; } if ( exif_get_short ( d + 8 , data -> priv -> order ) != 0x002a ) return ; offset = exif_get_long ( d + 10 , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""IFD0at%i."" , ( int ) offset ) ; if ( offset > ds || offset + 6 + 2 > ds ) return ; exif_data_load_data_content ( data , EXIF_IFD_0 , d + 6 , ds - 6 , offset , 0 ) ; n = exif_get_short ( d + 6 + offset , data -> priv -> order ) ; if ( offset + 6 + 2 + 12 * n + 4 > ds ) return ; offset = exif_get_long ( d + 6 + offset + 2 + 12 * n , data -> priv -> order ) ; if ( offset ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""IFD1at%i."" , ( int ) offset ) ;  if ( offset > ds || offset + 6 > ds ) {  exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""BogusoffsetofIFD1."" ) ; } else { exif_data_load_data_content ( data , EXIF_IFD_1 , d + 6 , ds - 6 , offset , 0 ) ; } } interpret_maker_note ( data , d , fullds ) ; if ( data -> priv -> options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION ) exif_data_fix ( data ) ; }", offset > ds - 6  ) { exif_log
790,"CWE-264 struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ;  opt2 -> tot_len = tot_len ;  p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }"," tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;"
791,"CWE-125 static wStream * rdg_receive_packet ( rdpRdg * rdg ) { wStream * s ; const size_t header = sizeof ( RdgPacketHeader ) ; size_t packetLength ; assert ( header <= INT_MAX ) ; s = Stream_New ( NULL , 1024 ) ; if ( ! s ) return NULL ; if ( ! rdg_read_all ( rdg -> tlsOut , Stream_Buffer ( s ) , header ) ) { Stream_Free ( s , TRUE ) ; return NULL ; } Stream_Seek ( s , 4 ) ; Stream_Read_UINT32 ( s , packetLength ) ;  if ( ( packetLength > INT_MAX ) || ! Stream_EnsureCapacity ( s , packetLength ) )  { Stream_Free ( s , TRUE ) ; return NULL ; } if ( ! rdg_read_all ( rdg -> tlsOut , Stream_Buffer ( s ) + header , ( int ) packetLength - ( int ) header ) ) { Stream_Free ( s , TRUE ) ; return NULL ; } Stream_SetLength ( s , packetLength ) ; return s ; }"," , packetLength ) || ( packetLength < header )"
792,"CWE-399  static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events )  { struct fsnotify_group * group ; group = fsnotify_alloc_group ( & inotify_fsnotify_ops ) ; if ( IS_ERR ( group ) ) return group ; group -> max_events = max_events ; spin_lock_init ( & group -> inotify_data . idr_lock ) ; idr_init ( & group -> inotify_data . idr ) ; group -> inotify_data . last_wd = 0 ;  group -> inotify_data . user = user ;   group -> inotify_data . fa = NULL ;  return group ; }", * inotify_new_group (  unsigned int max_events  -> inotify_data . fa = NULL  ; group ->  -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; }  return group ;
793,"CWE-476 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ;  asoc -> peer . i = new -> peer . i ;  sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }", -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
794,"CWE-125 static void l2tp_q931_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length )  {  print_16bits_val ( ndo , ( const uint16_t * ) dat ) ; ND_PRINT ( ( ndo , "",%02x"" , dat [ 2 ] ) ) ;  if ( length > 3 ) {  ND_PRINT ( ( ndo , """" ) ) ;  print_string ( ndo , dat + 3 , length - 3 ) ;  } }"," length ) { if ( length < 3 ) { ND_PRINT ( ( ndo , ""AVPtooshort"" ) ) ; return ; }  ) ) ; dat += 3 ; length -= 3 ;  if ( length != 0  ) { ND_PRINT  ndo , dat , length  ) ; }"
795,"CWE-476 static int mailimf_group_parse ( const char * message , size_t length , size_t * indx , struct mailimf_group * * result ) { size_t cur_token ; char * display_name ; struct mailimf_mailbox_list * mailbox_list ; struct mailimf_group * group ; int r ; int res ;  cur_token = * indx ;  mailbox_list = NULL ; r = mailimf_display_name_parse ( message , length , & cur_token , & display_name ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto err ; } r = mailimf_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_display_name ; } r = mailimf_mailbox_list_parse ( message , length , & cur_token , & mailbox_list ) ; switch ( r ) { case MAILIMF_NO_ERROR : break ; case MAILIMF_ERROR_PARSE : r = mailimf_cfws_parse ( message , length , & cur_token ) ; if ( ( r != MAILIMF_NO_ERROR ) && ( r != MAILIMF_ERROR_PARSE ) ) {  res = r ;  goto free_display_name ; } break ; default : res = r ; goto free_display_name ; } r = mailimf_semi_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_mailbox_list ; } group = mailimf_group_new ( display_name , mailbox_list ) ; if ( group == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_mailbox_list ; } * indx = cur_token ; * result = group ; return MAILIMF_NO_ERROR ; free_mailbox_list : if ( mailbox_list != NULL ) { mailimf_mailbox_list_free ( mailbox_list ) ; } free_display_name : mailimf_display_name_free ( display_name ) ; err : return res ; }", int res ; clist * list ;  res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )
796,"CWE-399 static void vhost_net_ubuf_put_and_wait ( struct vhost_net_ubuf_ref * ubufs ) { kref_put ( & ubufs -> kref , vhost_net_zerocopy_done_signal ) ; wait_event ( ubufs -> wait , ! atomic_read ( & ubufs -> kref . refcount ) ) ;  kfree ( ubufs ) ;  }", ) ) ;  }  
797,"CWE-119  void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) {  fdct16_8col ( in0 ) ; fdct16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }",    static
798,"CWE-755 void acpi_ns_terminate ( void ) { acpi_status status ;  ACPI_FUNCTION_TRACE ( ns_terminate ) ;  # ifdef ACPI_EXEC_APP { union acpi_operand_object * prev ;  union acpi_operand_object * next ;  next = acpi_gbl_module_code_list ; while ( next ) { prev = next ; next = next -> method . mutex ; prev -> method . mutex = NULL ; acpi_ut_remove_reference ( prev ) ; }  }  # endif acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ; status = acpi_ut_acquire_mutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( status ) ) { return_VOID ; } acpi_ns_delete_node ( acpi_gbl_root_node ) ; ( void ) acpi_ut_release_mutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespacefreed\\n"" ) ) ; return_VOID ; }", acpi_status status ;  union acpi_operand_object *  acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate )  ) ; }  acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node
799,"CWE-119 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) )  return ( 0 ) ;  tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }", tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ;  0 ) ; }
800,CWE-119 static vpx_codec_err_t encoder_destroy ( vpx_codec_alg_priv_t * ctx ) { free ( ctx -> cx_data ) ; vp9_remove_compressor ( ctx -> cpi ) ;  free ( ctx ) ;  return VPX_CODEC_OK ; }, cpi ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free  ( ctx )
801,"CWE-119 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ;  bool is_drop_n_account = false ;  BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ;  if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;  macoff = netoff - maclen ;  } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ;  if ( ( int ) snaplen < 0 )   snaplen = 0 ;  } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:packettoobig,clampedfrom%uto%u.macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ;  }  } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ;  if ( po -> has_vnet_hdr ) {  if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }", ; bool is_drop_n_account = false ; bool do_vnet  -> has_vnet_hdr ) {  virtio_net_hdr ) ; do_vnet = true ; }  < 0 ) {  = 0 ; do_vnet = false ; }  -> max_frame_len ; do_vnet = false ;  ; if ( do_vnet  ) { if
802,"CWE-426 static void set_own_dir ( const char * argv0 ) { size_t l = strlen ( argv0 ) ; while ( l && argv0 [ l - 1 ] != '/' ) l -- ; if ( l == 0 )  memcpy ( own_dir , ""."" , 2 ) ;  else { memcpy ( own_dir , argv0 , l - 1 ) ; own_dir [ l ] = 0 ; } }"," == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else  2 ) ; # endif"
803,"CWE-000  static int can_open_delegated ( struct nfs_delegation * delegation , mode_t open_flags )  {  if ( ( delegation -> type & open_flags ) != open_flags )  return 0 ; if ( test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) ) return 0 ; nfs_mark_delegation_referenced ( delegation ) ; return 1 ; }"," * delegation , fmode_t fmode  ) { if  -> type & fmode ) != fmode  ) return 0"
804,"CWE-000 static int em_jmp_far ( struct x86_emulate_ctxt * ctxt ) { int rc ;  unsigned short sel ;  memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;  rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ;  if ( rc != X86EMUL_CONTINUE ) return rc ;  ctxt -> _eip = 0 ;   memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;   return X86EMUL_CONTINUE ;  }"," unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS )  ; rc = __load_segment_descriptor  ( ctxt ,  sel , VCPU_SREG_CS , cpl , false , & new_desc  return rc ; rc = assign_eip_far ( ctxt  , ctxt ->  -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS  ) ; return  ) ; return rc ; } return rc  ; } "
805,"CWE-119  static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) { int * corrupted = va_arg ( args , int * ) ; VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; if ( corrupted && pbi ) {  * corrupted = pbi -> common . frame_to_show -> corrupted ;  return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }"," vpx_codec_alg_priv_t * ctx  , va_list args  pbi ) { const YV12_BUFFER_CONFIG * const frame  = pbi ->  common . frame_to_show ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame"
806,"CWE-787 char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) {  char src [ PATH_MAX + 1 ] ;   memcpy ( src , dir , dir_len ) ;  src [ dir_len ] = 0 ; char * dst = ptr ; if ( ! dst ) dst = uwsgi_malloc ( PATH_MAX + 1 ) ; if ( ! realpath ( src , dst ) ) { uwsgi_error_realpath ( src ) ; if ( ! ptr ) free ( dst ) ;  return NULL ;   }  return dst ; }"," ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalidpathsize:%d(max%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n (  dir , dir_len  dir , dir_len , """" , 0 )  ; char *  dst ) ; free ( src ) ;  NULL ; } free ( src ) ;"
807,"CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ;  int index , count , i ;  if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ;  int index , count , i ;  u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }", * ublue ; unsigned  -> cmap ; unsigned
808,"CWE-362 static long __mptctl_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { mpt_ioctl_header __user * uhdr = ( void __user * ) arg ; mpt_ioctl_header khdr ; int iocnum ; unsigned iocnumX ; int nonblock = ( file -> f_flags & O_NONBLOCK ) ; int ret ; MPT_ADAPTER * iocp = NULL ; if ( copy_from_user ( & khdr , uhdr , sizeof ( khdr ) ) ) { printk ( KERN_ERR MYNAM ""%s::mptctl_ioctl()@%d-"" ""Unabletocopympt_ioctl_headerdata@%p\\n"" , __FILE__ , __LINE__ , uhdr ) ; return - EFAULT ; } ret = - ENXIO ; iocnumX = khdr . iocnum & 0xFF ; if ( ( ( iocnum = mpt_verify_adapter ( iocnumX , & iocp ) ) < 0 ) || ( iocp == NULL ) ) return - ENODEV ; if ( ! iocp -> active ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_ioctl()@%d-Controllerdisabled.\\n"" , __FILE__ , __LINE__ ) ; return - EFAULT ; } if ( ( cmd & ~ IOCSIZE_MASK ) == ( MPTIOCINFO & ~ IOCSIZE_MASK ) ) {  return mptctl_getiocinfo ( arg , _IOC_SIZE ( cmd ) ) ;  } else if ( cmd == MPTTARGETINFO ) {  return mptctl_gettargetinfo ( arg ) ;  } else if ( cmd == MPTTEST ) {  return mptctl_readtest ( arg ) ;  } else if ( cmd == MPTEVENTQUERY ) {  return mptctl_eventquery ( arg ) ;  } else if ( cmd == MPTEVENTENABLE ) {  return mptctl_eventenable ( arg ) ;  } else if ( cmd == MPTEVENTREPORT ) {  return mptctl_eventreport ( arg ) ;  } else if ( cmd == MPTFWREPLACE ) {  return mptctl_replace_fw ( arg ) ;  } if ( ( ret = mptctl_syscall_down ( iocp , nonblock ) ) != 0 ) return ret ; if ( cmd == MPTFWDOWNLOAD )  ret = mptctl_fw_download ( arg ) ;  else if ( cmd == MPTCOMMAND )  ret = mptctl_mpt_command ( arg ) ;  else if ( cmd == MPTHARDRESET )  ret = mptctl_do_reset ( arg ) ;  else if ( ( cmd & ~ IOCSIZE_MASK ) == ( HP_GETHOSTINFO & ~ IOCSIZE_MASK ) )  ret = mptctl_hp_hostinfo ( arg , _IOC_SIZE ( cmd ) ) ;  else if ( cmd == HP_GETTARGETINFO )  ret = mptctl_hp_targetinfo ( arg ) ;  else ret = - EINVAL ; mutex_unlock ( & iocp -> ioctl_cmds . mutex ) ; return ret ; }"," return mptctl_getiocinfo ( iocp ,  return mptctl_gettargetinfo ( iocp ,  return mptctl_readtest ( iocp ,  return mptctl_eventquery ( iocp ,  return mptctl_eventenable ( iocp ,  return mptctl_eventreport ( iocp ,  return mptctl_replace_fw ( iocp ,  = mptctl_fw_download ( iocp ,  = mptctl_mpt_command ( iocp ,  = mptctl_do_reset ( iocp ,  = mptctl_hp_hostinfo ( iocp ,  = mptctl_hp_targetinfo ( iocp ,"
809,"CWE-264  int xt_check_entry_offsets ( const void * base ,  unsigned int target_offset , unsigned int next_offset ) {  const struct xt_entry_target * t ;   const char * e = base ;  if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }"," void * base , const char * elems  next_offset ) { long size_of_base_struct = elems - ( const char * ) base ;  e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL"
810,"CWE-20 static int pppol2tp_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int err ; struct sk_buff * skb ; struct sock * sk = sock -> sk ; err = - EIO ; if ( sk -> sk_state & PPPOX_BOUND )  goto end ;  msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , len ) ; if ( likely ( err == 0 ) ) err = len ; kfree_skb ( skb ) ; end : return err ; }", ) goto end  ; err =
811,"CWE-617 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ;  assert ( bidx <= PCI_BARMAX ) ;   assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 ||   pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ;  assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi << 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }"," ) arg2 ; if ( addr + size >  pdi -> bar  bidx ] . addr +  pdi -> bar  bidx ] . size ) { pr_err ( ""%s,Outofemulatedmemoryrange\\n"" , __func__ ) ; return - ESRCH ; }  offset = addr"
812,"CWE-190  void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart ,  int ystart , int xend , int yend ) { jas_matrix_bindsub ( s , s1 , ystart - s1 -> ystart_ , xstart - s1 -> xstart_ , yend - s1 -> ystart_ - 1 , xend - s1 -> xstart_ - 1 ) ; }"," * s1 , jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t  yend ) {"
813,"CWE-362 int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , ""cannotfindtheslotforindex%d(range0-%i),error:%d\\n"" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices ) ; init_rwsem ( & card -> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ;  INIT_LIST_HEAD ( & card -> controls ) ;  INIT_LIST_HEAD ( & card -> ctl_files ) ; spin_lock_init ( & card -> files_lock ) ; INIT_LIST_HEAD ( & card -> files_list ) ; # ifdef CONFIG_PM mutex_init ( & card -> power_lock ) ; init_waitqueue_head ( & card -> power_sleep ) ; # endif device_initialize ( & card -> card_dev ) ; card -> card_dev . parent = parent ; card -> card_dev . class = sound_class ; card -> card_dev . release = release_card_device ; card -> card_dev . groups = card_dev_attr_groups ; err = kobject_set_name ( & card -> card_dev . kobj , ""card%d"" , idx ) ; if ( err < 0 ) goto __error ; err = snd_ctl_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unabletoregistercontrolminors\\n"" ) ; goto __error ; } err = snd_info_card_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unabletocreatecardinfo\\n"" ) ; goto __error_ctl ; } * card_ret = card ; return 0 ; __error_ctl : snd_device_free_all ( card ) ; __error : put_device ( & card -> card_dev ) ; return err ; }", ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
814,"CWE-119 static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {  const int ref_frame_flags = va_arg ( args , int ) ; vp9_update_reference ( ctx -> cpi , ref_frame_flags ) ; return VPX_CODEC_OK ; }"," * ctx ,  va_list args )"
815,"CWE-119 static void setup_features ( VP8_COMP * cpi ) { if ( cpi -> mb . e_mbd . segmentation_enabled ) { cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; } else { cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ; } cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ;  vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;   vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;   vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;   vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;  set_default_lf_deltas ( cpi ) ; }", = 0 ; memset  ( cpi ->  ) ) ; memset  ( cpi ->  ) ) ; memset  ( cpi ->  ) ) ; memset  ( cpi ->
816,"CWE-404 static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) {  struct usb_serial * serial = port -> serial ;  struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }", port ) {  return usb_serial_generic_open (
817,"CWE-787 BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) { UINT32 i ; BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; if ( ! bitmapUpdate ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 2 ) goto fail ; Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; WLog_Print ( update -> log , WLOG_TRACE , ""BitmapUpdate:%"" PRIu32 """" , bitmapUpdate -> number ) ; if ( bitmapUpdate -> number > bitmapUpdate -> count ) {  UINT16 count ;  BITMAP_DATA * newdata ; count = bitmapUpdate -> number * 2 ;  newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles ,  sizeof ( BITMAP_DATA ) * count ) ; if ( ! newdata ) goto fail ; bitmapUpdate -> rectangles = newdata ; ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; bitmapUpdate -> count = count ; } for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) { if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) goto fail ; } return bitmapUpdate ; fail : free_bitmap_update ( update -> context , bitmapUpdate ) ; return NULL ; }", count ) { UINT32  count = bitmapUpdate  * 2 ; BITMAP_DATA *
818,"CWE-119 static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ;  uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; }  if ( ! tmp )  return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; return 1 ; }", uint8 * tmp  ; if (  0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
819,"CWE-908 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ;  if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; }  memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;  neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""newroot:num%d(%d),lblock%d,ptr%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }"," = 0 ; size_t ext_size = 0 ;  out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ;  -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size  ) ; neh"
820,"CWE-362 static struct sock * tcp_v6_syn_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * treq ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; struct ipv6_txoptions * opt ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } treq = inet6_rsk ( req ) ; opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , req ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & treq -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & treq -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & treq -> loc_addr ) ; newsk -> sk_bound_dev_if = treq -> iif ;  newinet -> opt = NULL ;  newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( treq -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( treq -> pktopts , GFP_ATOMIC ) ; kfree_skb ( treq -> pktopts ) ; treq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; tcp_mtup_init ( newsk ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG if ( ( key = tcp_v6_md5_do_lookup ( sk , & newnp -> daddr ) ) != NULL ) { char * newkey = kmemdup ( key -> key , key -> keylen , GFP_ATOMIC ) ; if ( newkey != NULL ) tcp_v6_md5_do_add ( newsk , & newnp -> daddr , newkey , key -> keylen ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : if ( opt && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }", ; newinet -> inet_opt  = NULL ;
821,"CWE-264 int touch ( const char * path ) {  return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;  }"," , GID_INVALID , MODE_INVALID  ) ; }"
822,"CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , ""sd_ioctl:disk=%s,"" ""cmd=0x%x\\n"" , disk -> disk_name , cmd ) ) ;  error = scsi_nonblockable_ioctl ( sdp , cmd , p ,  ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }"," ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error ="
823,"CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""SendingCONNECT\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ;  size += service_name_tlv_length ;  } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ;  size += miux_tlv_length ;  rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;  size += rw_tlv_length ;  pr_debug ( ""SKBsize%dSNlength%zu\\n"" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error%d\\n"" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }", service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; }  miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; }  rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
824,"CWE-200 static void copy_to_user_state ( struct xfrm_state * x , struct xfrm_usersa_info * p ) {  memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ;  memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & x -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & x -> curlft , sizeof ( p -> curlft ) ) ; memcpy ( & p -> stats , & x -> stats , sizeof ( p -> stats ) ) ; memcpy ( & p -> saddr , & x -> props . saddr , sizeof ( p -> saddr ) ) ; p -> mode = x -> props . mode ; p -> replay_window = x -> props . replay_window ; p -> reqid = x -> props . reqid ; p -> family = x -> props . family ; p -> flags = x -> props . flags ; p -> seq = x -> km . seq ; }"," p ) { memset ( p , 0 , sizeof ( * p ) ) ;"
825,"CWE-617 int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; MpegEncContext * s = avctx -> priv_data ; int ret ; int slice_ret = 0 ; AVFrame * pict = data ; if ( buf_size == 0 ) { if ( s -> low_delay == 0 && s -> next_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> next_picture_ptr -> f ) ) < 0 ) return ret ; s -> next_picture_ptr = NULL ; * got_frame = 1 ; } return 0 ; } if ( s -> avctx -> flags & AV_CODEC_FLAG_TRUNCATED ) { int next ; if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) { next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263P_DECODER && s -> codec_id == AV_CODEC_ID_H263P ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else { av_log ( s -> avctx , AV_LOG_ERROR , ""thiscodecdoesnotsupporttruncatedbitstreams\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) return buf_size ; } retry : if ( s -> divx_packed && s -> bitstream_buffer_size ) { int i ; for ( i = 0 ; i < buf_size - 3 ; i ++ ) { if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 ) { if ( buf [ i + 3 ] == 0xB0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Discardingexcessivebitstreaminpackedxvid\\n"" ) ; s -> bitstream_buffer_size = 0 ; } break ; } } } if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size <= MAX_NVOP_SIZE ) ) ret = init_get_bits8 ( & s -> gb , s -> bitstream_buffer , s -> bitstream_buffer_size ) ; else ret = init_get_bits8 ( & s -> gb , buf , buf_size ) ; s -> bitstream_buffer_size = 0 ; if ( ret < 0 ) return ret ; if ( ! s -> context_initialized ) ff_mpv_idct_init ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_picture_header ( s ) ; } else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) { ret = ff_msmpeg4_decode_picture_header ( s ) ; } else if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) { GetBitContext gb ; if ( init_get_bits8 ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size ) >= 0 ) ff_mpeg4_decode_picture_header ( avctx -> priv_data , & gb ) ; } ret = ff_mpeg4_decode_picture_header ( avctx -> priv_data , & s -> gb ) ; } else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) { ret = ff_intel_h263_decode_picture_header ( s ) ; } else if ( CONFIG_FLV_DECODER && s -> h263_flv ) { ret = ff_flv_decode_picture_header ( s ) ; } else { ret = ff_h263_decode_picture_header ( s ) ; } if ( ret < 0 || ret == FRAME_SKIPPED ) { if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Revertingpicturedimensionschangeduetoheaderdecodingfailure\\n"" ) ; s -> width = avctx -> coded_width ; s -> height = avctx -> coded_height ; } } if ( ret == FRAME_SKIPPED ) return get_consumed_bytes ( s , buf_size ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""headerdamaged\\n"" ) ; return ret ; } if ( ! s -> context_initialized ) { avctx -> pix_fmt = h263_get_format ( avctx ) ; if ( ( ret = ff_mpv_common_init ( s ) ) < 0 ) return ret ; } if ( ! s -> current_picture_ptr || s -> current_picture_ptr -> f -> data [ 0 ] ) { int i = ff_find_unused_picture ( s -> avctx , s -> picture , 0 ) ; if ( i < 0 ) return i ; s -> current_picture_ptr = & s -> picture [ i ] ; } avctx -> has_b_frames = ! s -> low_delay ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( ff_mpeg4_workaround_bugs ( avctx ) == 1 ) goto retry ; if ( s -> studio_profile != ( s -> idsp . idct == NULL ) ) ff_mpv_idct_init ( s ) ; } if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height || s -> context_reinit ) { s -> context_reinit = 0 ; ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; if ( ret < 0 ) return ret ; ff_set_sar ( avctx , avctx -> sample_aspect_ratio ) ; if ( ( ret = ff_mpv_common_frame_size_change ( s ) ) ) return ret ; if ( avctx -> pix_fmt != h263_get_format ( avctx ) ) { av_log ( avctx , AV_LOG_ERROR , ""formatchangenotsupported\\n"" ) ; avctx -> pix_fmt = AV_PIX_FMT_NONE ; return AVERROR_UNKNOWN ; } } if ( s -> codec_id == AV_CODEC_ID_H263 || s -> codec_id == AV_CODEC_ID_H263P || s -> codec_id == AV_CODEC_ID_H263I ) s -> gob_index = H263_GOB_HEIGHT ( s -> height ) ; s -> current_picture . f -> pict_type = s -> pict_type ; s -> current_picture . f -> key_frame = s -> pict_type == AV_PICTURE_TYPE_I ; if ( ! s -> last_picture_ptr && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) return get_consumed_bytes ( s , buf_size ) ; if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) return get_consumed_bytes ( s , buf_size ) ; if ( s -> next_p_frame_damaged ) { if ( s -> pict_type == AV_PICTURE_TYPE_B ) return get_consumed_bytes ( s , buf_size ) ; else s -> next_p_frame_damaged = 0 ; } if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) { s -> me . qpel_put = s -> qdsp . put_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } else { s -> me . qpel_put = s -> qdsp . put_no_rnd_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } if ( ( ret = ff_mpv_frame_start ( s , avctx ) ) < 0 ) return ret ; if ( ! s -> divx_packed ) ff_thread_finish_setup ( avctx ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) ; if ( ret < 0 ) return ret ; } ff_mpeg_er_frame_start ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_secondary_picture_header ( s ) ; if ( ret < 0 ) return ret ; if ( ret == 1 ) goto frame_end ; } s -> mb_x = 0 ; s -> mb_y = 0 ; slice_ret = decode_slice ( s ) ; while ( s -> mb_y < s -> mb_height ) { if ( s -> msmpeg4_version ) { if ( s -> slice_height == 0 || s -> mb_x != 0 || slice_ret < 0 || ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) break ; } else { int prev_x = s -> mb_x , prev_y = s -> mb_y ; if ( ff_h263_resync ( s ) < 0 ) break ; if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) s -> er . error_occurred = 1 ; } if ( s -> msmpeg4_version < 4 && s -> h263_pred ) ff_mpeg4_clean_buffers ( s ) ; if ( decode_slice ( s ) < 0 ) slice_ret = AVERROR_INVALIDDATA ; } if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) if ( ! CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ; av_assert1 ( s -> bitstream_buffer_size == 0 ) ;  frame_end :  ff_er_frame_end ( & s -> er ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> end_frame ( avctx ) ; if ( ret < 0 ) return ret ; } ff_mpv_frame_end ( s ) ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) ff_mpeg4_frame_end ( avctx , buf , buf_size ) ; if ( ! s -> divx_packed && avctx -> hwaccel ) ff_thread_finish_setup ( avctx ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> current_picture_ptr -> f -> pict_type ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> pict_type ) ; if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> current_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> current_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } else if ( s -> last_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> last_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> last_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } if ( s -> last_picture_ptr || s -> low_delay ) { if ( pict -> format == AV_PIX_FMT_YUV420P && ( s -> codec_tag == AV_RL32 ( ""GEOV"" ) || s -> codec_tag == AV_RL32 ( ""GEOX"" ) ) ) { int x , y , p ; av_frame_make_writable ( pict ) ; for ( p = 0 ; p < 3 ; p ++ ) { int w = AV_CEIL_RSHIFT ( pict -> width , ! ! p ) ; int h = AV_CEIL_RSHIFT ( pict -> height , ! ! p ) ; int linesize = pict -> linesize [ p ] ; for ( y = 0 ; y < ( h >> 1 ) ; y ++ ) for ( x = 0 ; x < w ; x ++ ) FFSWAP ( int , pict -> data [ p ] [ x + y * linesize ] , pict -> data [ p ] [ x + ( h - 1 - y ) * linesize ] ) ; } } * got_frame = 1 ; } if ( slice_ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return slice_ret ; else return get_consumed_bytes ( s , buf_size ) ; }", ; frame_end : if ( ! s -> studio_profile )
826,"CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ;  RAnalOp next_op ;  avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }", ; RAnalOp next_op = { 0 }
827,"CWE-119  int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) {  int start_index = rc -> worst_quality ; int target_index = rc -> worst_quality ; int i ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { start_index = i ;  if ( vp9_convert_qindex_to_q ( i ) >= qstart )  break ; } for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { target_index = i ;  if ( vp9_convert_qindex_to_q ( i ) >= qtarget )  break ; } return target_index - start_index ; }"," , double qtarget , vpx_bit_depth_t bit_depth  vp9_convert_qindex_to_q ( i , bit_depth  vp9_convert_qindex_to_q ( i , bit_depth"
828,"CWE-362 struct dentry * debugfs_rename ( struct dentry * old_dir , struct dentry * old_dentry , struct dentry * new_dir , const char * new_name ) { int error ; struct dentry * dentry = NULL , * trap ;  const char * old_name ;  trap = lock_rename ( new_dir , old_dir ) ; if ( d_really_is_negative ( old_dir ) || d_really_is_negative ( new_dir ) ) goto exit ; if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ; dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ; if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ;  old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;  error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { fsnotify_oldname_free ( old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;  fsnotify_oldname_free ( old_name ) ;  unlock_rename ( new_dir , old_dir ) ; dput ( dentry ) ; return old_dentry ; exit : if ( dentry && ! IS_ERR ( dentry ) ) dput ( dentry ) ; unlock_rename ( new_dir , old_dir ) ; return NULL ; }"," * trap ; struct name_snapshot  old_name ; trap  goto exit ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name  , d_is_dir (  old_dentry ) ; release_dentry_name_snapshot ( &  old_name ) ;"
829,"CWE-834  static unsigned int XBMInteger ( Image * image , short int * hex_digits )  { int c ; unsigned int value ; do { c = ReadBlobByte ( image ) ; if ( c == EOF )  return ( 0 ) ;  } while ( ( c == '' ) || ( c == '\\t' ) || ( c == '\\n' ) || ( c == '\\r' ) ) ; value = 0 ; do { if ( value > ( unsigned int ) ( INT_MAX / 10 ) ) break ; value *= 16 ; c &= 0xff ; if ( value > ( unsigned int ) ( INT_MAX - hex_digits [ c ] ) ) break ; value += hex_digits [ c ] ; c = ReadBlobByte ( image ) ; if ( c == EOF )  return ( 0 ) ;  } while ( hex_digits [ c ] >= 0 ) ;  return ( value ) ;  }",   static  int XBMInteger (  ) return ( - 1  ) ; }  ) return ( - 1  ) ; }  ; return ( ( int )
830,"CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:"" ""emptyextentsbtree\\n"" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:startingat"" ""rootnode%"" PRIu32 "";nodesize=%"" PRIu16 ""\\n"" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:Node%dtoolargeforfile"" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( ""hfs_cat_traverse:Errorreadingnode%datoffset%"" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:Nodesize%distoosmalltobevalid"" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:node%"" PRIu32 ""@%"" PRIu64 ""has%"" PRIu16 ""records\\n"" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:zerorecordsinnode%"" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ;  uint16_t keylen ;  rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:offsetofrecord%dinindexnode%dtoolarge(%dvs%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:lengthofkey%dinindexnode%dtoolarge(%dvs%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:Callbackreturnederror"" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:offsetofrecordandkeylength%dinindexnode%dtoolarge(%dvs%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:didnotfindanykeysinindexnode%d"" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:node%dreferencesitselfasnextnode"" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ;  uint16_t keylen ;  rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:offsetofrecord%dinleafnode%dtoolarge(%dvs%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:lengthofkey%dinleafnode%dtoolarge(%dvs%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:Callbackreturnederror"" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:movingforwardtonextleaf"" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:btreenode%"" PRIu32 ""(%"" PRIu64 "")isneitherindexnorleaf(%"" PRIu8 "")"" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }", uint8_t retval ; int  keylen ; rec_off  uint8_t retval ; int  keylen ; rec_off
831,"CWE-20 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { sco_conn_defer_accept ( pi -> conn -> hcon , pi -> setting ) ; sk -> sk_state = BT_CONFIG ;  msg -> msg_namelen = 0 ;  release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }", = BT_CONFIG ;  release_sock ( sk
832,"CWE-190 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ;  if ( uniforms_offset < shader_rec_offset ||  exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflowinexecarguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failedtoallocatestorageforcopying"" ""inbin/renderCLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'tallocateBOforbinning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }", ; if ( shader_rec_offset < args -> bin_cl_size ||
833,"CWE-119 void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ;  if ( s ) {   struct unix_sock * u = unix_sk ( s ) ;  spin_lock ( & unix_gc_lock ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ;  spin_unlock ( & unix_gc_lock ) ;  }  } ", fp ) ; spin_lock ( & unix_gc_lock ) ;  unix_sk ( s  ) ; if  unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ;  ) ; }    
834,"CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ;  newinet -> opt = NULL ;  newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }", ; newinet -> inet_opt  = NULL ;
835,"CWE-119 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ;  dtls1_process_buffered_records ( s ) ;  if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) {  dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ;  } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; }  return ( 1 ) ;  }"," rrec ) ; if (  ( s ) < 0 ) return - 1  listen ) { if (  rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap  again ; } dtls1_record_bitmap_update ( s , bitmap ) ;"
836,"CWE-264 struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ;  }  return opt2 ; }"," += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;"
837,"CWE-189 Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; }  key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ;  for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }"," NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""numberofpairs(%d)exceedsthemaximumallowed(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;"
838,"CWE-119 static void nonrd_use_partition ( VP9_COMP * cpi ,  const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ,  int * totrate , int64_t * totdist ) {  VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ;  const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;  const int mis = cm -> mi_stride ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ;  int rate = INT_MAX ;  int64_t dist = INT64_MAX ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;  subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ;  partition = partition_lookup [ bsl ] [ subsize ] ;  switch ( partition ) {  case PARTITION_NONE :  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ;   get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  break ; case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;   nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ;   get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;   if ( mi_col + hbs < cm -> mi_cols ) {  * get_sb_index ( x , subsize ) = 1 ;  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs ,  & rate , & dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;  if ( rate != INT_MAX && dist != INT64_MAX &&  * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } } break ; case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;   nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ;   get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;   if ( mi_row + hbs < cm -> mi_rows ) {  * get_sb_index ( x , subsize ) = 1 ;  nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col ,  & rate , & dist , subsize ) ;  get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ;   if ( rate != INT_MAX && dist != INT64_MAX &&  * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } } break ; case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;  * get_sb_index ( x , subsize ) = 0 ;   nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col ,   subsize , output_enabled , totrate , totdist ) ;  * get_sb_index ( x , subsize ) = 1 ;  nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp ,  mi_row , mi_col + hbs , subsize , output_enabled ,  & rate , & dist ) ;  if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } * get_sb_index ( x , subsize ) = 2 ;  nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp ,   mi_row + hbs , mi_col , subsize , output_enabled ,   & rate , & dist ) ;  if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } * get_sb_index ( x , subsize ) = 3 ; nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis + hbs , tp , mi_row + hbs , mi_col + hbs , subsize , output_enabled , & rate , & dist ) ; if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } break ; default :  assert ( ""Invalidpartitiontype."" ) ;   }   if ( bsize == BLOCK_64X64 && output_enabled ) {  if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , * totrate , * totdist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , 1 , bsize ) ;  }  }"," * cpi , ThreadData * td , TileDataEnc * tile_data  , MODE_INFO *  MODE_INFO * * mi  , TOKENEXTRA *  int output_enabled , RD_COST * dummy_cost , PC_TREE * pc_tree  ) { VP9_COMMON  -> common ; TileInfo * tile_info = & tile_data -> tile_info ;  x = & td  -> mb ;  int bsl = b_width_log2_lookup [ bsize ]  , hbs =  BLOCK_SIZE subsize ;  if ( mi_row  BLOCK_8X8 ) ? mi  [ 0 ]  subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; }  case PARTITION_NONE : pc_tree -> none . pred_pixel_ready = 1 ;  ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none .  mic . mbmi  ] -> mbmi ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none )  case PARTITION_VERT : pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1  ; nonrd_pick_sb_modes (  ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] .  mic . mbmi  ] -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] )  cm -> mi_cols && bsize > BLOCK_8X8 ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready  = 1 ;  ( cpi , tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] .  mic . mbmi  -> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ;  } break ;  case PARTITION_HORZ : pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1  ; nonrd_pick_sb_modes (  ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] .  mic . mbmi  ] -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] )  cm -> mi_rows && bsize > BLOCK_8X8 ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready  = 1 ;  ( cpi , tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] .  mic . mbmi  . mbmi = xd -> mi  [ 0 ]  -> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ;  } break ;  PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else {  nonrd_use_partition ( cpi  ( cpi , td , tile_data , mi  , tp ,  , output_enabled , dummy_cost , pc_tree -> split [ 0 ] )  ; nonrd_use_partition (  ( cpi , td , tile_data , mi  + hbs ,  , output_enabled , dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] )  ; nonrd_use_partition (  ( cpi , td , tile_data , mi  + hbs *  hbs * mis + hbs  hbs , mi_col + hbs  , output_enabled , dummy_cost , pc_tree -> split [ 3 ] )  ; } break  : assert ( 0 &&  ""Invalidpartitiontype."" ) ; break ;  } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize  , bsize )  bsize ) ;  }  "
839,"CWE-787 static int next_state_class ( CClassNode * cc , OnigCodePoint * vs , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; if ( * state == CCS_RANGE ) return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE ; if ( * state == CCS_VALUE && * type != CCV_CLASS ) { if ( * type == CCV_SB ) BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } }  * state = CCS_VALUE ;  * type = CCV_CLASS ; return 0 ; }", ; } } if ( * state != CCS_START )
840,"CWE-000 int jpc_bitstream_putbits ( jpc_bitstream_t * bitstream , int n , long v ) { int m ;  assert ( n >= 0 && n < 32 ) ;  assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ; m = n - 1 ; while ( -- n >= 0 ) { if ( jpc_bitstream_putbit ( bitstream , ( v >> m ) & 1 ) == EOF ) { return EOF ; } v <<= 1 ; } return 0 ; }", int m ; if ( n < 0 || n >= 32 ) { return EOF ; }  assert ( !
841,"CWE-119 static __u8 * nci_extract_rf_params_nfcb_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) {  nfcb_poll -> sensb_res_len = * data ++ ;  pr_debug ( ""sensb_res_len%d\\n"" , nfcb_poll -> sensb_res_len ) ; memcpy ( nfcb_poll -> sensb_res , data , nfcb_poll -> sensb_res_len ) ; data += nfcb_poll -> sensb_res_len ; return data ; }"," -> sensb_res_len = min_t ( __u8 ,  * data ++ , NFC_SENSB_RES_MAXSIZE )"
842,"CWE-835 static Status accept_xsmp_connection ( SmsConn sms_conn , GsmXsmpServer * server , unsigned long * mask_ret , SmsCallbacks * callbacks_ret , char * * failure_reason_ret ) { IceConn ice_conn ;  GsmXSMPClient * client ;  if ( server -> priv -> xsmp_sockets == NULL ) { g_debug ( ""GsmXsmpServer:Inshutdown,rejectingnewclient"" ) ; * failure_reason_ret = strdup ( _ ( ""Refusingnewclientconnectionbecausethesessioniscurrentlybeingshutdown\\n"" ) ) ; return FALSE ; } ice_conn = SmsGetIceConnection ( sms_conn ) ;  client = ice_conn -> context ;   g_return_val_if_fail ( client != NULL , TRUE ) ;   gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ;  return TRUE ; }"," IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data  ; if (  sms_conn ) ; data  = ice_conn ->  -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client  ) ; gsm_xsmp_client_connect  ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client )  , sms_conn ,"
843,"CWE-125 static MagickBooleanType Get8BIMProperty ( const Image * image , const char * key , ExceptionInfo * exception ) { char * attribute , format [ MagickPathExtent ] , name [ MagickPathExtent ] , * resource ; const StringInfo * profile ; const unsigned char * info ; long start , stop ; MagickBooleanType status ; register ssize_t i ; size_t length ; ssize_t count , id , sub_number ; profile = GetImageProfile ( image , ""8bim"" ) ; if ( profile == ( StringInfo * ) NULL ) return ( MagickFalse ) ; count = ( ssize_t ) sscanf ( key , ""8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]"" , & start , & stop , name , format ) ; if ( ( count != 2 ) && ( count != 3 ) && ( count != 4 ) ) return ( MagickFalse ) ; if ( count < 4 ) ( void ) CopyMagickString ( format , ""SVG"" , MagickPathExtent ) ; if ( count < 3 ) * name = '\\0' ; sub_number = 1 ; if ( * name == '#' ) sub_number = ( ssize_t ) StringToLong ( & name [ 1 ] ) ; sub_number = MagickMax ( sub_number , 1L ) ; resource = ( char * ) NULL ; status = MagickFalse ; length = GetStringInfoLength ( profile ) ; info = GetStringInfoDatum ( profile ) ; while ( ( length > 0 ) && ( status == MagickFalse ) ) { if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) '8' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'B' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'I' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'M' ) continue ; id = ( ssize_t ) ReadPropertyMSBShort ( & info , & length ) ; if ( id < ( ssize_t ) start ) continue ; if ( id > ( ssize_t ) stop ) continue ; if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; count = ( ssize_t ) ReadPropertyByte ( & info , & length ) ; if ( ( count != 0 ) && ( ( size_t ) count <= length ) ) { resource = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) resource = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * resource ) ) ; if ( resource != ( char * ) NULL ) { for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) resource [ i ] = ( char ) ReadPropertyByte ( & info , & length ) ; resource [ count ] = '\\0' ; } } if ( ( count & 0x01 ) == 0 ) ( void ) ReadPropertyByte ( & info , & length ) ; count = ( ssize_t ) ReadPropertyMSBLong ( & info , & length ) ;  if ( ( * name != '\\0' ) && ( * name != '#' ) )  if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) { info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } if ( ( * name == '#' ) && ( sub_number != 1 ) ) { sub_number -- ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } attribute = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) attribute = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * attribute ) ) ; if ( attribute != ( char * ) NULL ) { ( void ) CopyMagickMemory ( attribute , ( char * ) info , ( size_t ) count ) ; attribute [ count ] = '\\0' ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; if ( ( id <= 1999 ) || ( id >= 2999 ) ) ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) attribute , exception ) ; else { char * path ; if ( LocaleCompare ( format , ""svg"" ) == 0 ) path = TraceSVGClippath ( ( unsigned char * ) attribute , ( size_t ) count , image -> columns , image -> rows ) ; else path = TracePSClippath ( ( unsigned char * ) attribute , ( size_t ) count ) ; ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) path , exception ) ; path = DestroyString ( path ) ; } attribute = DestroyString ( attribute ) ; status = MagickTrue ; } } if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; return ( status ) ; }", if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
844,"CWE-119  static void fadst4 ( const int16_t * input , int16_t * output ) {   int x0 , x1 , x2 , x3 ;  int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; x0 = input [ 0 ] ; x1 = input [ 1 ] ; x2 = input [ 2 ] ; x3 = input [ 3 ] ; if ( ! ( x0 | x1 | x2 | x3 ) ) { output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ; return ; } s0 = sinpi_1_9 * x0 ; s1 = sinpi_4_9 * x0 ; s2 = sinpi_2_9 * x1 ; s3 = sinpi_1_9 * x1 ; s4 = sinpi_3_9 * x2 ; s5 = sinpi_4_9 * x3 ; s6 = sinpi_2_9 * x3 ; s7 = x0 + x1 - x3 ; x0 = s0 + s2 + s5 ; x1 = sinpi_3_9 * s7 ; x2 = s1 - s3 + s6 ; x3 = s4 ; s0 = x0 + x3 ; s1 = x1 ; s2 = x2 - x3 ; s3 = x2 - x0 + x3 ;  output [ 0 ] = fdct_round_shift ( s0 ) ;   output [ 1 ] = fdct_round_shift ( s1 ) ;   output [ 2 ] = fdct_round_shift ( s2 ) ;   output [ 3 ] = fdct_round_shift ( s3 ) ;  }"," fadst4 ( const tran_low_t * input , tran_low_t  * output )  output ) { tran_high_t x0 , x1 , x2 , x3 ; tran_high_t  s0 , s1  0 ] = ( tran_low_t )  1 ] = ( tran_low_t )  2 ] = ( tran_low_t )  3 ] = ( tran_low_t )"
845,"CWE-119 PHP_FUNCTION ( msgfmt_format_message ) { zval * args ; UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; int pattern_len = 0 ; const char * slocale = NULL ; int slocale_len = 0 ; MessageFormatter_object mf = { 0 } ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_method_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , getThis ( ) , ""ssa"" , & slocale , & slocale_len , & pattern , & pattern_len , & args ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""msgfmt_format_message:unabletoparseinputparams"" , 0 TSRMLS_CC ) ; RETURN_FALSE ;  }  msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""msgfmt_format_message:errorconvertingpatterntoUTF-16"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( TSRMLS_C ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , ""msgfmt_format_message:errorconvertingpatterntoquote-friendlyformat"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , ""Creatingmessageformatterfailed"" ) ; msgfmt_do_format ( mfo , args , return_value TSRMLS_CC ) ; msgformat_data_free ( & mfo -> mf_data TSRMLS_CC ) ; }", RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
846,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ;  return true ;  case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , ""Unexpectedoperator%dinResolveLhs\\n"" , expr -> expr . op ) ; return false ; }", NULL ; return ( * field_rtrn != NULL )  ; case EXPR_FIELD_REF
847,"CWE-20 error_t udpSendDatagram ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ;  NetTxAncillary ancillary ;  buffer = udpAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( ! error ) { ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif  error = udpSendBuffer ( socket -> interface , & message -> srcIpAddr ,  socket -> localPort , & message -> destIpAddr , message -> destPort , buffer , offset , & ancillary ) ; } netBufferFree ( buffer ) ; return error ; }"," * buffer ; NetInterface * interface ;  NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; }  = udpSendBuffer (  interface , &"
848,"CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;  nexthdr = * prevhdr ;  * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }", prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
849,"CWE-404 int nfs3svc_decode_readdirplusargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { int len ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ntohl ( * p ++ ) ; args -> count = ntohl ( * p ++ ) ;  len = args -> count = min ( args -> count , max_blocksize ) ;  while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; if ( ! args -> buffer ) args -> buffer = page_address ( p ) ; len -= PAGE_SIZE ; }  return xdr_argsize_check ( rqstp , p ) ;  }"," ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;  ; } return 1  ; } "
850,"CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ;  set_exception_intercept ( svm , MC_VECTOR ) ;  set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }"," svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR"
851,"CWE-200 static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , AVDictionary * opts , AVDictionary * opts2 , int * is_http ) { HLSContext * c = s -> priv_data ; AVDictionary * tmp = NULL ; const char * proto_name = NULL ; int ret ; av_dict_copy ( & tmp , opts , 0 ) ; av_dict_copy ( & tmp , opts2 , 0 ) ; if ( av_strstart ( url , ""crypto"" , NULL ) ) { if ( url [ 6 ] == '+' || url [ 6 ] == ':' ) proto_name = avio_find_protocol_name ( url + 7 ) ; } if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ; if ( ! proto_name ) return AVERROR_INVALIDDATA ;  if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) )  return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ':' ) ; else if ( av_strstart ( url , ""crypto"" , NULL ) && ! strncmp ( proto_name , url + 7 , strlen ( proto_name ) ) && url [ 7 + strlen ( proto_name ) ] == ':' ) ; else if ( strcmp ( proto_name , ""file"" ) || ! strncmp ( url , ""file,"" , 5 ) ) return AVERROR_INVALIDDATA ; ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp ) ; if ( ret >= 0 ) { char * new_cookies = NULL ; if ( ! ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ) av_opt_get ( * pb , ""cookies"" , AV_OPT_SEARCH_CHILDREN , ( uint8_t * * ) & new_cookies ) ; if ( new_cookies ) { av_free ( c -> cookies ) ; c -> cookies = new_cookies ; } av_dict_set ( & opts , ""cookies"" , c -> cookies , 0 ) ; } av_dict_free ( & tmp ) ; if ( is_http ) * is_http = av_strstart ( proto_name , ""http"" , NULL ) ; return ret ; }"," ; if (  av_strstart ( proto_name  ( proto_name , ""file"" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , ""Filenameextensionof\\\'%s\\\'isnotacommonmultimediaextension,blockedforsecurityreasons.\\n"" ""Ifyouwishtooverridethisadjustallowed_extensions,youcansetitto\\\'ALL\\\'toallowall\\n"" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name ,  , NULL ) ) { ; } else  return AVERROR_INVALIDDATA ;"
852,"CWE-400 static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! IS_ERR ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ;  list_add ( & mnt -> mnt_list , & new_ns -> list ) ;  } else { mntput ( m ) ; } return new_ns ; }", = mnt ; new_ns -> mounts ++ ;
