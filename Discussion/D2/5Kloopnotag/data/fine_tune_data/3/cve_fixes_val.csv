,source,target
0,"CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ;  if ( j >= length ) return - 1 ;  GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length ) return - 1 ; if ( ++ ptr_count > length ) return - 1 ; continue ; } if ( label_len > 63 ) return - 1 ; if ( cp != name_out ) { if ( cp + 1 >= end ) return - 1 ; * cp ++ = '.' ; } if ( cp + label_len >= end ) return - 1 ;  memcpy ( cp , packet + j , label_len ) ;  cp += label_len ; j += label_len ; } if ( cp >= end ) return - 1 ; * cp = '\\0' ; if ( name_end < 0 ) * idx = j ; else * idx = name_end ; return 0 ; err : return - 1 ; }", u8 label_len ;  GET8 ( label_len  - 1 ; if ( j + label_len > length ) return - 1 ;
1,"CWE-125 void beep_print ( netdissect_options * ndo , const u_char * bp , u_int length ) {  if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPMSG"" ) ) ;  else if ( l_strnstart ( ""RPY"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPRPY"" ) ) ;  else if ( l_strnstart ( ""ERR"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPERR"" ) ) ;  else if ( l_strnstart ( ""ANS"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPANS"" ) ) ;  else if ( l_strnstart ( ""NUL"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPNUL"" ) ) ;  else if ( l_strnstart ( ""SEQ"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPSEQ"" ) ) ;  else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""BEEPEND"" ) ) ; else ND_PRINT ( ( ndo , ""BEEP(payloadorundecoded)"" ) ) ; }"," ( l_strnstart ( ndo ,  ( l_strnstart ( ndo ,  ( l_strnstart ( ndo ,  ( l_strnstart ( ndo ,  ( l_strnstart ( ndo ,  ( l_strnstart ( ndo ,  ( l_strnstart ( ndo ,"
2,"CWE-787 opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failedtoopen%sforreading!!\\n"" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; }  subsampling_dx = parameters -> subsampling_dx ;  subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) subsampling_dy ; cmptparm [ i ] . w = image_width ; cmptparm [ i ] . h = image_height ; } image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm [ 0 ] , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = ! image -> x0 ? ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 : image -> x0 + ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 ; image -> y1 = ! image -> y0 ? ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 : image -> y0 + ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 ; for ( y = 0 ; y < image_height ; y ++ ) { int index ; if ( flip_image ) { index = ( int ) ( ( image_height - y - 1 ) * image_width ) ; } else { index = ( int ) ( y * image_width ) ; } if ( numcomps == 3 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; index ++ ; } } else if ( numcomps == 4 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b , a ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & a , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; image -> comps [ 3 ] . data [ index ] = a ; index ++ ; } } else { fprintf ( stderr , ""Currentlyunsupportedbitdepth:%s\\n"" , filename ) ; } } fclose ( f ) ; return image ; }"," OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }"
3,"CWE-310 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ;  snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ;  if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }"," crypto_report_comp rcomp ; strncpy  ( rcomp .  . type , ""compression"" , sizeof ( rcomp . type )  ) ; if"
4,"CWE-404 static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ;  unsigned long flags ;  int ret ;  spin_lock_irqsave ( & dev -> lock , flags ) ;  buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 << offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , ""errorsettingGPIOvalues:%d\\n"" , ret ) ;  spin_unlock_irqrestore ( & dev -> lock , flags ) ;  }", -> in_out_buffer ;  int ret ;  int ret ; mutex_lock  ( & dev  dev -> lock  ) ; buf  ret ) ; mutex_unlock  ( & dev  dev -> lock  ) ; }
5,"CWE-119 static int evaluate_inter_mode_rd ( int mdcounts [ 4 ] , RATE_DISTORTION * rd , int * disable_skip , VP8_COMP * cpi , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int distortion ; vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . predictor , 16 ) ; if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { x -> skip = 1 ; } else if ( x -> encode_breakout ) { unsigned int sse ; unsigned int var ; unsigned int threshold = ( xd -> block [ 0 ] . dequant [ 1 ] * xd -> block [ 0 ] . dequant [ 1 ] >> 4 ) ; if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ;  var = vp8_variance16x16  ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; if ( sse < threshold ) { unsigned int q2dc = xd -> block [ 24 ] . dequant [ 0 ] ; if ( ( sse - var < q2dc * q2dc >> 4 ) || ( sse / 2 > var && sse - var < 64 ) ) { unsigned int sse2 = VP8_UVSSE ( x ) ; if ( sse2 * 2 < threshold ) { x -> skip = 1 ; rd -> distortion2 = sse + sse2 ; rd -> rate2 = 500 ; rd -> rate_uv = 0 ; rd -> distortion_uv = sse2 ; * disable_skip = 1 ; return RDCOST ( x -> rdmult , x -> rddiv , rd -> rate2 , rd -> distortion2 ) ; } } } } rd -> rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; macro_block_yrd ( x , & rd -> rate_y , & distortion ) ; rd -> rate2 += rd -> rate_y ; rd -> distortion2 += distortion ; rd_inter16x16_uv ( cpi , x , & rd -> rate_uv , & rd -> distortion_uv , cpi -> common . full_pixel ) ; rd -> rate2 += rd -> rate_uv ; rd -> distortion2 += rd -> distortion_uv ; return INT_MAX ; }", ; var = vpx_variance16x16  ( * (
6,"CWE-190  int mongo_env_read_socket ( mongo * conn , void * buf , int len ) {  char * cbuf = buf ; while ( len ) {  int sent = recv ( conn -> sock , cbuf , len , 0 ) ;  if ( sent == 0 || sent == - 1 ) { __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }"," * buf , size_t  len ) {  len ) { size_t  sent = recv"
7,"CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ;  char added ;  } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ;  pair -> added = 0 ;  for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }", * key ;  } * pair  it ) ;  for ( it
8,CWE-119 void vp9_cyclic_refresh_free ( CYCLIC_REFRESH * cr ) { vpx_free ( cr -> map ) ;  vpx_free ( cr ) ;  }, vpx_free ( cr -> last_coded_q_map ) ; vpx_free ( cr
9,CWE-119 SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) {  return in ;  } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }, ) { return NULL  ; } while
10,"CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) &&  value [ n ] >= min && value [ n ] <= max &&  field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max  && field -> usage [ field -> value [ n ] - min ] . hid  && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max  && field -> usage [ value [ n ] - min ] . hid  && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }", ] <= max && value [ n ] - min < field -> maxusage  && field -> value [ n ] - min < field -> maxusage && field ->  <= max && value [ n ] - min < field -> maxusage &&
11,"CWE-787 static void InsertRow ( Image * image , unsigned char * p , ssize_t y , int bpp , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ;  for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 )  { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }", ; x += 4  ) { index
12,"CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB :  if ( nbytes < sizeof ( * hwrpb ) )  return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }", if ( nbytes >  sizeof ( *
13,"CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ;  list_del ( & key -> graveyard_link ) ;  kdebug ( ""-%u"" , key -> serial ) ; key_check ( key ) ;  if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) &&  ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ;  if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }", graveyard_link ) ; short state = key -> state ;  ; if ( state == KEY_IS_POSITIVE &&  key -> type  ; if ( state != KEY_IS_UNINSTANTIATED  ) atomic_dec (
14,"CWE-401 static int mwifiex_pcie_alloc_cmdrsp_buf ( struct mwifiex_adapter * adapter ) { struct pcie_service_card * card = adapter -> card ; struct sk_buff * skb ; skb = dev_alloc_skb ( MWIFIEX_UPLD_SIZE ) ; if ( ! skb ) { mwifiex_dbg ( adapter , ERROR , ""Unabletoallocateskbforcommandresponsedata.\\n"" ) ; return - ENOMEM ; } skb_put ( skb , MWIFIEX_UPLD_SIZE ) ; if ( mwifiex_map_pci_memory ( adapter , skb , MWIFIEX_UPLD_SIZE ,  PCI_DMA_FROMDEVICE ) )   return - 1 ;  card -> cmdrsp_buf = skb ; return 0 ; }", PCI_DMA_FROMDEVICE ) ) { kfree_skb ( skb ) ;  - 1 ; }
15,"CWE-617 void pci_lintr_request ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int bestpin , bestcount , pin ; bi = pci_businfo [ dev -> bus ] ;  assert ( bi != NULL ) ;  si = & bi -> slotinfo [ dev -> slot ] ; bestpin = 0 ; bestcount = si -> si_intpins [ 0 ] . ii_count ; for ( pin = 1 ; pin < 4 ; pin ++ ) { if ( si -> si_intpins [ pin ] . ii_count < bestcount ) { bestpin = pin ; bestcount = si -> si_intpins [ pin ] . ii_count ; } } si -> si_intpins [ bestpin ] . ii_count ++ ; dev -> lintr . pin = bestpin + 1 ; pci_set_cfgdata8 ( dev , PCIR_INTPIN , bestpin + 1 ) ; }"," bus ] ; if ( bi == NULL ) { pr_err ( ""%s:pci[%s]haswrongbus%dinfo!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; }  si = &"
16,"CWE-59 static int setup_dev_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console ) { char path [ MAXPATHLEN ] ; struct stat s ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/dev/console"" , rootfs -> mount ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""consolepathtoolong"" ) ; return - 1 ; } if ( access ( path , F_OK ) ) { WARN ( ""rootfsspecifiedbutnoconsolefoundat\'%s\'"" , path ) ; return 0 ; } if ( console -> master < 0 ) { INFO ( ""noconsole"" ) ; return 0 ; } if ( stat ( path , & s ) ) { SYSERROR ( ""failedtostat\'%s\'"" , path ) ; return - 1 ; } if ( chmod ( console -> name , s . st_mode ) ) { SYSERROR ( ""failedtosetmode\'0%o\'to\'%s\'"" , s . st_mode , console -> name ) ; return - 1 ; }  if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {  ERROR ( ""failedtomount\'%s\'on\'%s\'"" , console -> name , path ) ; return - 1 ; } INFO ( ""consolehasbeensetup"" ) ; return 0 ; }"," } if ( safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount  ) ) {"
17,"CWE-400 int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ;  if ( wp -> listening_socket != STDIN_FILENO ) {  if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , ""failedtoinitchildstdio:dup2()"" ) ; return - 1 ; } } return 0 ; }", 1 ) ;  return 0 ;
18,"CWE-119 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ;  scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ;  if ( ! newscratch ) { failf ( data , ""Failedtoallocscratchbuffer!"" ) ; return CURLE_OUT_OF_MEMORY ; }  }  eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent = 0 ; smtp -> trailing_crlf = FALSE ; } if ( SMTP_EOB_FIND_LEN == smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB_REPL [ eob_sent ] , SMTP_EOB_REPL_LEN - eob_sent ) ; si += SMTP_EOB_REPL_LEN - eob_sent ; smtp -> eob = 0 ; eob_sent = 0 ; } else if ( ! smtp -> eob ) scratch [ si ++ ] = data -> req . upload_fromhere [ i ] ; } if ( smtp -> eob - eob_sent ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; } if ( si != nread ) { data -> req . upload_fromhere = scratch ; data -> state . scratch = scratch ; free ( oldscratch ) ; data -> req . upload_present = si ; } else free ( newscratch ) ; return CURLE_OK ; }", ( 2 * UPLOAD_BUFSIZE  ) ; if  ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;
19,"CWE-119 static void test_decode ( struct stream_state * stream , enum TestDecodeFatality fatal , const VpxInterface * codec ) { vpx_image_t enc_img , dec_img ; if ( stream -> mismatch_seen ) return ; if ( strcmp ( codec -> name , ""vp8"" ) == 0 ) { struct vpx_ref_frame ref_enc , ref_dec ; int width , height ; width = ( stream -> config . cfg . g_w + 15 ) & ~ 15 ; height = ( stream -> config . cfg . g_h + 15 ) & ~ 15 ; vpx_img_alloc ( & ref_enc . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; enc_img = ref_enc . img ; vpx_img_alloc ( & ref_dec . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; dec_img = ref_dec . img ; ref_enc . frame_type = VP8_LAST_FRAME ; ref_dec . frame_type = VP8_LAST_FRAME ; vpx_codec_control ( & stream -> encoder , VP8_COPY_REFERENCE , & ref_enc ) ; vpx_codec_control ( & stream -> decoder , VP8_COPY_REFERENCE , & ref_dec ) ; } else {  struct vp9_ref_frame ref ;  ref . idx = 0 ;  vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ;  enc_img = ref . img ;  vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ;  dec_img = ref . img ; } ctx_exit_on_error ( & stream -> encoder , ""Failedtogetencoderreferenceframe"" ) ; ctx_exit_on_error ( & stream -> decoder , ""Failedtogetdecoderreferenceframe"" ) ; if ( ! compare_img ( & enc_img , & dec_img ) ) { int y [ 4 ] , u [ 4 ] , v [ 4 ] ;  find_mismatch ( & enc_img , & dec_img , y , u , v ) ;  stream -> decoder . err = 1 ; warn_or_exit_on_error ( & stream -> decoder , fatal == TEST_DECODE_FATAL , ""Stream%d:Encode/decodemismatchonframe%dat"" ""Y[%d,%d]{%d/%d},"" ""U[%d,%d]{%d/%d},"" ""V[%d,%d]{%d/%d}"" , stream -> index , stream -> frames_out , y [ 0 ] , y [ 1 ] , y [ 2 ] , y [ 3 ] , u [ 0 ] , u [ 1 ] , u [ 2 ] , u [ 3 ] , v [ 0 ] , v [ 1 ] , v [ 2 ] , v [ 3 ] ) ; stream -> mismatch_seen = stream -> frames_out ; } vpx_img_free ( & enc_img ) ; vpx_img_free ( & dec_img ) ; }"," { struct vp9_ref_frame ref_enc , ref_dec ; ref_enc  . idx =  = 0 ; ref_dec . idx = 0 ;  VP9_GET_REFERENCE , & ref_enc ) ; enc_img = ref_enc  . img ;  VP9_GET_REFERENCE , & ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif  } ctx_exit_on_error (  4 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else {  v ) ; } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif"
20,"CWE-119  static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image )  { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t  number_threads ;  number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;  for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ )  {  pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns ,  sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ;  for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ )   GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ;  } return ( pixels ) ; }"," const Image * images ) { const Image * next ;  MagickPixelPacket * *  j ; size_t columns ,  ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for (  i = 0  ) AcquireQuantumMemory (  columns , sizeof  ( ssize_t )  columns ; j  ) GetMagickPixelPacket ( images  , & pixels"
21,"CWE-119  static void  swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ;  horDiff16 ( tif , cp0 , cc ) ;  TIFFSwabArrayOfShort ( wp , wc ) ;  } ","   static int  swabHorDiff16 ( TIFF  / 2 ; if ( !  , cc ) ) return 0  wc ) ; return 1 ;"
22,"CWE-20 static int snd_hrtimer_stop ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ;  return 0 ;  }", 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
23,"CWE-119 static bool ldm_frag_add ( const u8 * data , int size , struct list_head * frags ) { struct frag * f ; struct list_head * item ; int rec , num , group ; BUG_ON ( ! data || ! frags ) ; if ( size < 2 * VBLK_SIZE_HEAD ) { ldm_error ( ""Valueofsizeistosmall."" ) ; return false ; } group = get_unaligned_be32 ( data + 0x08 ) ; rec = get_unaligned_be16 ( data + 0x0C ) ; num = get_unaligned_be16 ( data + 0x0E ) ; if ( ( num < 1 ) || ( num > 4 ) ) { ldm_error ( ""AVBLKclaimstohave%dparts."" , num ) ; return false ; } if ( rec >= num ) { ldm_error ( ""RECvalue(%d)exceedsNUMvalue(%d)"" , rec , num ) ; return false ; } list_for_each ( item , frags ) { f = list_entry ( item , struct frag , list ) ; if ( f -> group == group ) goto found ; } f = kmalloc ( sizeof ( * f ) + size * num , GFP_KERNEL ) ; if ( ! f ) { ldm_crit ( ""Outofmemory."" ) ; return false ; } f -> group = group ; f -> num = num ; f -> rec = rec ; f -> map = 0xFF << num ; list_add_tail ( & f -> list , frags ) ; found :  if ( f -> map & ( 1 << rec ) ) {  ldm_error ( ""DuplicateVBLK,part%d."" , rec ) ; f -> map &= 0x7F ; return false ; } f -> map |= ( 1 << rec ) ; data += VBLK_SIZE_HEAD ; size -= VBLK_SIZE_HEAD ; memcpy ( f -> data + rec * ( size - VBLK_SIZE_HEAD ) + VBLK_SIZE_HEAD , data , size ) ; return true ; }"," : if ( rec >= f -> num ) { ldm_error ( ""RECvalue(%d)exceedsNUMvalue(%d)"" , rec , f -> num ) ; return false ; } if ("
24,"CWE-119  static void estimate_ref_frame_costs ( VP9_COMP * cpi , int segment_id ,  unsigned int * ref_costs_single , unsigned int * ref_costs_comp ,  vp9_prob * comp_mode_p ) {   VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int seg_ref_active = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { vpx_memset ( ref_costs_single , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_single ) ) ;  vpx_memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ;  * comp_mode_p = 128 ; } else {  vp9_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ;   vp9_prob comp_inter_p = 128 ;  if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { comp_inter_p = vp9_get_reference_mode_prob ( cm , xd ) ; * comp_mode_p = comp_inter_p ; } else { * comp_mode_p = 128 ; } ref_costs_single [ INTRA_FRAME ] = vp9_cost_bit ( intra_inter_p , 0 ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) {  vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ;   vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ;  unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) base_cost += vp9_cost_bit ( comp_inter_p , 0 ) ; ref_costs_single [ LAST_FRAME ] = ref_costs_single [ GOLDEN_FRAME ] = ref_costs_single [ ALTREF_FRAME ] = base_cost ; ref_costs_single [ LAST_FRAME ] += vp9_cost_bit ( ref_single_p1 , 0 ) ; ref_costs_single [ GOLDEN_FRAME ] += vp9_cost_bit ( ref_single_p1 , 1 ) ; ref_costs_single [ ALTREF_FRAME ] += vp9_cost_bit ( ref_single_p1 , 1 ) ; ref_costs_single [ GOLDEN_FRAME ] += vp9_cost_bit ( ref_single_p2 , 0 ) ; ref_costs_single [ ALTREF_FRAME ] += vp9_cost_bit ( ref_single_p2 , 1 ) ; } else { ref_costs_single [ LAST_FRAME ] = 512 ; ref_costs_single [ GOLDEN_FRAME ] = 512 ; ref_costs_single [ ALTREF_FRAME ] = 512 ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) {  vp9_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ;  unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) base_cost += vp9_cost_bit ( comp_inter_p , 1 ) ; ref_costs_comp [ LAST_FRAME ] = base_cost + vp9_cost_bit ( ref_comp_p , 0 ) ; ref_costs_comp [ GOLDEN_FRAME ] = base_cost + vp9_cost_bit ( ref_comp_p , 1 ) ; } else { ref_costs_comp [ LAST_FRAME ] = 512 ; ref_costs_comp [ GOLDEN_FRAME ] = 512 ; } } }"," void estimate_ref_frame_costs ( const VP9_COMMON * cm , const MACROBLOCKD * xd ,  int segment_id ,  * ref_costs_comp , vpx_prob  * comp_mode_p )  comp_mode_p ) { int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset  ( ref_costs_single ,  ) ) ; memset  ( ref_costs_comp ,  } else { vpx_prob  intra_inter_p = vp9_get_intra_inter_prob  xd ) ; vpx_prob  comp_inter_p = 128  COMPOUND_REFERENCE ) { vpx_prob  ref_single_p1 = vp9_get_pred_prob_single_ref_p1  xd ) ; vpx_prob  ref_single_p2 = vp9_get_pred_prob_single_ref_p2  SINGLE_REFERENCE ) { vpx_prob  ref_comp_p = vp9_get_pred_prob_comp_ref_p"
25,"CWE-119 static int write_superframe_index ( vpx_codec_alg_priv_t * ctx ) { uint8_t marker = 0xc0 ; unsigned int mask ; int mag , index_sz ; assert ( ctx -> pending_frame_count ) ; assert ( ctx -> pending_frame_count <= 8 ) ; marker |= ctx -> pending_frame_count - 1 ; for ( mag = 0 , mask = 0xff ; mag < 4 ; mag ++ ) { if ( ctx -> pending_frame_magnitude < mask ) break ; mask <<= 8 ; mask |= 0xff ; } marker |= mag << 3 ; index_sz = 2 + ( mag + 1 ) * ctx -> pending_frame_count ; if ( ctx -> pending_cx_data_sz + index_sz < ctx -> cx_data_sz ) { uint8_t * x = ctx -> pending_cx_data + ctx -> pending_cx_data_sz ;  int i , j ;  * x ++ = marker ; for ( i = 0 ; i < ctx -> pending_frame_count ; i ++ ) { unsigned int this_sz = ( unsigned int ) ctx -> pending_frame_sizes [ i ] ; for ( j = 0 ; j <= mag ; j ++ ) { * x ++ = this_sz & 0xff ; this_sz >>= 8 ; } } * x ++ = marker ; ctx -> pending_cx_data_sz += index_sz ;  }  return index_sz ; }"," , j ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( ""Addedsupplementalsuperframedata\\n"" ) ; # endif  += index_sz ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif"
26,"CWE-119 static int http_receive_data ( HTTPContext * c ) { HTTPContext * c1 ; int len , loop_run = 0 ; while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , 1 , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; return 0 ; } else if ( len == 0 ) { goto fail ; } else if ( c -> buffer_ptr - c -> buffer >= 2 && ! memcmp ( c -> buffer_ptr - 1 , ""\\r\\n"" , 2 ) ) { c -> chunk_size = strtol ( c -> buffer , 0 , 16 ) ;  if ( c -> chunk_size == 0 )  goto fail ; c -> buffer_ptr = c -> buffer ; break ; } else if ( ++ loop_run > 10 ) goto fail ; else c -> buffer_ptr ++ ; } if ( c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , FFMIN ( c -> chunk_size , c -> buffer_end - c -> buffer_ptr ) , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; } else if ( len == 0 ) goto fail ;  else {  c -> chunk_size -= len ; c -> buffer_ptr += len ; c -> data_count += len ; update_datarate ( & c -> datarate , c -> data_count ) ; } } if ( c -> buffer_ptr - c -> buffer >= 2 && c -> data_count > FFM_PACKET_SIZE ) { if ( c -> buffer [ 0 ] != 'f' || c -> buffer [ 1 ] != 'm' ) { http_log ( ""Feedstreamhasbecomedesynchronized--disconnecting\\n"" ) ; goto fail ; } } if ( c -> buffer_ptr >= c -> buffer_end ) { FFServerStream * feed = c -> stream ; if ( c -> data_count > FFM_PACKET_SIZE ) { if ( lseek ( c -> feed_fd , feed -> feed_write_index , SEEK_SET ) == - 1 ) http_log ( ""Seekto%"" PRId64 ""failed\\n"" , feed -> feed_write_index ) ; if ( write ( c -> feed_fd , c -> buffer , FFM_PACKET_SIZE ) < 0 ) { http_log ( ""Errorwritingtofeedfile:%s\\n"" , strerror ( errno ) ) ; goto fail ; } feed -> feed_write_index += FFM_PACKET_SIZE ; if ( feed -> feed_write_index > c -> stream -> feed_size ) feed -> feed_size = feed -> feed_write_index ; if ( c -> stream -> feed_max_size && feed -> feed_write_index >= c -> stream -> feed_max_size ) feed -> feed_write_index = FFM_PACKET_SIZE ; if ( ffm_write_write_index ( c -> feed_fd , feed -> feed_write_index ) < 0 ) { http_log ( ""Errorwritingindextofeedfile:%s\\n"" , strerror ( errno ) ) ; goto fail ; } for ( c1 = first_http_ctx ; c1 ; c1 = c1 -> next ) { if ( c1 -> state == HTTPSTATE_WAIT_FEED && c1 -> stream -> feed == c -> stream -> feed ) c1 -> state = HTTPSTATE_SEND_DATA ; } } else { AVFormatContext * s = avformat_alloc_context ( ) ; AVIOContext * pb ; AVInputFormat * fmt_in ; int i ; if ( ! s ) goto fail ; fmt_in = av_find_input_format ( feed -> fmt -> name ) ; if ( ! fmt_in ) goto fail ; pb = avio_alloc_context ( c -> buffer , c -> buffer_end - c -> buffer , 0 , NULL , NULL , NULL , NULL ) ; if ( ! pb ) goto fail ; pb -> seekable = 0 ; s -> pb = pb ; if ( avformat_open_input ( & s , c -> stream -> feed_filename , fmt_in , NULL ) < 0 ) { av_freep ( & pb ) ; goto fail ; } if ( s -> nb_streams != feed -> nb_streams ) { avformat_close_input ( & s ) ; av_freep ( & pb ) ; http_log ( ""Feed\'%s\'streamnumberdoesnotmatchregisteredfeed\\n"" , c -> stream -> feed_filename ) ; goto fail ; } for ( i = 0 ; i < s -> nb_streams ; i ++ ) { LayeredAVStream * fst = feed -> streams [ i ] ; AVStream * st = s -> streams [ i ] ; avcodec_parameters_to_context ( fst -> codec , st -> codecpar ) ; avcodec_parameters_from_context ( fst -> codecpar , fst -> codec ) ; } avformat_close_input ( & s ) ; av_freep ( & pb ) ; } c -> buffer_ptr = c -> buffer ; } return 0 ; fail : c -> stream -> feed_opened = 0 ; close ( c -> feed_fd ) ; for ( c1 = first_http_ctx ; c1 ; c1 = c1 -> next ) { if ( c1 -> state == HTTPSTATE_WAIT_FEED && c1 -> stream -> feed == c -> stream -> feed ) c1 -> state = HTTPSTATE_SEND_DATA_TRAILER ; } return - 1 ; }", c -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; }  c -> buffer_ptr  ; else { av_assert0 ( len <= c -> chunk_size ) ;
27,"CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""postdattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""postdattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""attr:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er )  ND_PRINT ( ( ndo , ""c%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ;  return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""%ubytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , ""EOF"" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""%ubytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""from:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""to:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""filePOST:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""dir:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }"," ! er ) { ND_TCHECK (  dp [ 0  0 ] ) ; ND_PRINT ( ( ndo , ""c%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; }  return ; case"
28,"CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) {  struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ;  struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ;  if ( ! i_ext || ! i_ext -> len )  return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ;  return false ;  }"," i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext  ) ; if  if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT  ) ; return  ) ; return ret  ; } "
29,"CWE-399 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } }  typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) {  buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;  return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }", ( n ) \\\n{  sum = (  ++ ; } \\\n}  typedef struct PCDTable  buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;  RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
30,"CWE-119 static void write_image_file ( const vpx_image_t * img , const int planes [ 3 ] , FILE * file ) {  int i , y ;  for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) {  fwrite ( buf , 1 , w , file ) ;  buf += stride ; } } }"," , y ; # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif  ( buf , bytes_per_sample  , w ,"
31,"CWE-119 static vpx_codec_err_t decoder_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , int * is_intra_only , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { int intra_only_flag = 0 ;  uint8_t clear_buffer [ 9 ] ;  if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ; si -> is_kf = 0 ; si -> w = si -> h = 0 ; if ( decrypt_cb ) { data_sz = VPXMIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , data_sz ) ; data = clear_buffer ;  }  { int show_frame ; int error_resilient ; struct vpx_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; const int frame_marker = vpx_rb_read_literal ( & rb , 2 ) ; const BITSTREAM_PROFILE profile = vp9_read_profile ( & rb ) ; if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( profile >= MAX_PROFILES ) return VPX_CODEC_UNSUP_BITSTREAM ;  if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 )  return VPX_CODEC_UNSUP_BITSTREAM ; if ( vpx_rb_read_bit ( & rb ) ) { vpx_rb_read_literal ( & rb , 3 ) ; return VPX_CODEC_OK ; }  if ( data_sz <= 8 )  return VPX_CODEC_UNSUP_BITSTREAM ; si -> is_kf = ! vpx_rb_read_bit ( & rb ) ; show_frame = vpx_rb_read_bit ( & rb ) ; error_resilient = vpx_rb_read_bit ( & rb ) ; if ( si -> is_kf ) { if ( ! vp9_read_sync_code ( & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( ! parse_bitdepth_colorspace_sampling ( profile , & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; vp9_read_frame_size ( & rb , ( int * ) & si -> w , ( int * ) & si -> h ) ; } else { intra_only_flag = show_frame ? 0 : vpx_rb_read_bit ( & rb ) ; rb . bit_offset += error_resilient ? 0 : 2 ; if ( intra_only_flag ) { if ( ! vp9_read_sync_code ( & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( profile > PROFILE_0 ) { if ( ! parse_bitdepth_colorspace_sampling ( profile , & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; } rb . bit_offset += REF_FRAMES ; vp9_read_frame_size ( & rb , ( int * ) & si -> w , ( int * ) & si -> h ) ; } } } if ( is_intra_only != NULL ) * is_intra_only = intra_only_flag ; return VPX_CODEC_OK ; }", uint8_t clear_buffer [ 10  ] ; if  clear_buffer ; } if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ;  ; if ( vpx_rb_read_bit ( & rb ) ) { if ( profile >  2 && data_sz  2 && data_sz < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ;  vpx_rb_read_literal ( &  if ( data_sz < 10  ) return VPX_CODEC_UNSUP_BITSTREAM
32,"CWE-200 int keepalived_main ( int argc , char * * argv ) { bool report_stopped = true ; struct utsname uname_buf ; char * end ; set_time_now ( ) ; save_cmd_line_options ( argc , argv ) ; debug = 0 ; # ifndef _DEBUG_ prog_type = PROG_TYPE_PARENT ; # endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ;  # endif  openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; # ifdef _MEM_CHECK_ mem_log_init ( PACKAGE_NAME , ""Parentprocess"" ) ; # endif if ( uname ( & uname_buf ) ) log_message ( LOG_INFO , ""Unabletogetuname()information-error%d"" , errno ) ; else { os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { if ( ! isdigit ( end [ 1 ] ) ) os_major = 0 ; else os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; } } if ( ! os_major ) log_message ( LOG_INFO , ""Unabletoparsekernelversion%s"" , uname_buf . release ) ; if ( ! config_id ) { end = strchrnul ( uname_buf . nodename , '.' ) ; config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ; strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ; config_id [ end - uname_buf . nodename ] = '\\0' ; } } if ( parse_cmdline ( argc , argv ) ) { closelog ( ) ; if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) enable_console_log ( ) ; # ifdef GIT_COMMIT log_message ( LOG_INFO , ""Starting%s,gitcommit%s"" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , ""Starting%s"" , version_string ) ; # endif core_dump_init ( ) ; if ( os_major ) { if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) { log_message ( LOG_INFO , ""WARNING-keepalivedwasbuildfornewerLinux%d.%d.%d,runningon%s%s%s"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; } else { log_message ( LOG_INFO , ""Runningon%s%s%s(builtforLinux%d.%d.%d)"" , uname_buf . sysname , uname_buf . release , uname_buf . version , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; } } # ifndef _DEBUG_ log_command_line ( 0 ) ; # endif if ( ! check_conf_file ( conf_file ) ) { if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) config_test_exit ( ) ; goto end ; } global_data = alloc_global_data ( ) ;  read_config_file ( ) ;  init_global_data ( global_data , NULL ) ; # if HAVE_DECL_CLONE_NEWNET if ( override_namespace ) { if ( global_data -> network_namespace ) { log_message ( LOG_INFO , ""Overridingconfignet_namespace\'%s\'withcommandlinenamespace\'%s\'"" , global_data -> network_namespace , override_namespace ) ; FREE ( global_data -> network_namespace ) ; } global_data -> network_namespace = override_namespace ; override_namespace = NULL ; } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && ( global_data -> instance_name # if HAVE_DECL_CLONE_NEWNET || global_data -> network_namespace # endif ) ) { if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) { log_message ( LOG_INFO , ""Changingsyslogidentto%s"" , syslog_ident ) ; closelog ( ) ; openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } else log_message ( LOG_INFO , ""Unabletochangesyslogident"" ) ; use_pid_dir = true ; open_log_file ( log_file_name , NULL , # if HAVE_DECL_CLONE_NEWNET global_data -> network_namespace , # else NULL , # endif global_data -> instance_name ) ; } set_child_finder_name ( find_keepalived_child_name ) ; if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( use_pid_dir ) { create_pid_dir ( ) ; } } # if HAVE_DECL_CLONE_NEWNET if ( global_data -> network_namespace ) { if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) { log_message ( LOG_ERR , ""Unabletosetnetworknamespace%s-exiting"" , global_data -> network_namespace ) ; goto end ; } } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( global_data -> instance_name ) { if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_main_pidfile = true ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_checkers_pidfile = true ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_vrrp_pidfile = true ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_bfd_pidfile = true ; # endif } if ( use_pid_dir ) { if ( ! main_pidfile ) main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } else { if ( ! main_pidfile ) main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } if ( keepalived_running ( daemon_mode ) ) { log_message ( LOG_INFO , ""daemonisalreadyrunning"" ) ; report_stopped = false ; goto end ; } } if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && xdaemon ( false , false , true ) > 0 ) { closelog ( ) ; FREE_PTR ( config_id ) ; FREE_PTR ( orig_core_dump_pattern ) ; close_std_fd ( ) ; exit ( 0 ) ; }  umask ( 0 ) ;  # ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ; # endif if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) { validate_config ( ) ; config_test_exit ( ) ; } if ( ! pidfile_write ( main_pidfile , getpid ( ) ) ) goto end ; master = thread_make_master ( ) ; signal_init ( ) ; if ( ! start_keepalived ( ) ) log_message ( LOG_INFO , ""Warning-keepalivedhasnoconfigurationtorun"" ) ; initialise_debug_options ( ) ; # ifdef THREAD_DUMP register_parent_thread_addresses ( ) ; # endif launch_thread_scheduler ( master ) ; stop_keepalived ( ) ; # ifdef THREAD_DUMP deregister_thread_addresses ( ) ; # endif end : if ( report_stopped ) { # ifdef GIT_COMMIT log_message ( LOG_INFO , ""Stopped%s,gitcommit%s"" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , ""Stopped%s"" , version_string ) ; # endif } # if HAVE_DECL_CLONE_NEWNET if ( global_data && global_data -> network_namespace ) clear_namespaces ( ) ; # endif if ( use_pid_dir ) remove_pid_dir ( ) ; if ( orig_core_dump_pattern ) update_core_dump_pattern ( orig_core_dump_pattern ) ; free_parent_mallocs_startup ( false ) ; free_parent_mallocs_exit ( ) ; free_global_data ( global_data ) ; closelog ( ) ; # ifndef _MEM_CHECK_LOG_ FREE_PTR ( syslog_ident ) ; # else if ( syslog_ident ) free ( syslog_ident ) ; # endif close_std_fd ( ) ; exit ( KEEPALIVED_EXIT_OK ) ; }", ; # endif umask ( 022 ) ;  ( ) ; global_data -> umask = umask_val ;  ) ; }  # ifdef _MEM_CHECK_
33,"CWE-125 static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ;  ut8 * directory_base ;  struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , ""mdmp_directory.offset"" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , ""mdmp_directory.format"" , ""[4]E?"" ""(mdmp_stream_type)StreamType"" ""(mdmp_location_descriptor)Location"" , 0 ) ;  for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) {   entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ;   r_bin_mdmp_init_directory_entry ( obj , entry ) ;  } return true ; }"," int i ; struct minidump_directory entry  ; sdb_num_set (  0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ;  ++ ) { ut32 delta =  i * sizeof  struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory  ) ) ; if ( r ) {  ( obj , &  entry ) ; }"
34,"CWE-269 void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) {  Com_Printf ( ""Usage:writeconfig<filename>\\n"" ) ;  return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }"," Com_Printf ( ""Usage:writeconfig<filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:Onlythe\\"".cfg\\""extensionissupportedbythiscommand!\\n"""
35,"CWE-89 int msPostGISLayerSetTimeFilter ( layerObj * lp , const char * timestring , const char * timefield ) { char * * atimes , * * aranges = NULL ; int numtimes = 0 , i = 0 , numranges = 0 ; size_t buffer_size = 512 ; char buffer [ 512 ] , bufferTmp [ 512 ] ; buffer [ 0 ] = '\\0' ; bufferTmp [ 0 ] = '\\0' ; if ( ! lp || ! timestring || ! timefield )  return MS_FALSE ;  if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) { createPostgresTimeCompareSimple ( timefield , timestring , buffer , buffer_size ) ; } else { atimes = msStringSplit ( timestring , ',' , & numtimes ) ; if ( atimes == NULL || numtimes < 1 ) return MS_FALSE ; strlcat ( buffer , ""("" , buffer_size ) ; for ( i = 0 ; i < numtimes ; i ++ ) { if ( i != 0 ) { strlcat ( buffer , ""OR"" , buffer_size ) ; } strlcat ( buffer , ""("" , buffer_size ) ; aranges = msStringSplit ( atimes [ i ] , '/' , & numranges ) ; if ( ! aranges ) return MS_FALSE ; if ( numranges == 1 ) { createPostgresTimeCompareSimple ( timefield , atimes [ i ] , bufferTmp , buffer_size ) ; strlcat ( buffer , bufferTmp , buffer_size ) ; } else if ( numranges == 2 ) { createPostgresTimeCompareRange ( timefield , aranges [ 0 ] , aranges [ 1 ] , bufferTmp , buffer_size ) ; strlcat ( buffer , bufferTmp , buffer_size ) ; } else { return MS_FALSE ; } msFreeCharArray ( aranges , numranges ) ; strlcat ( buffer , "")"" , buffer_size ) ; } strlcat ( buffer , "")"" , buffer_size ) ; msFreeCharArray ( atimes , numtimes ) ; } if ( ! * buffer ) { return MS_FALSE ; } if ( lp -> filteritem ) free ( lp -> filteritem ) ; lp -> filteritem = msStrdup ( timefield ) ; if ( & lp -> filter ) { if ( lp -> filter . type == MS_EXPRESSION ) { snprintf ( bufferTmp , buffer_size , ""(%s)and%s"" , lp -> filter . string , buffer ) ; loadExpressionString ( & lp -> filter , bufferTmp ) ; } else { freeExpression ( & lp -> filter ) ; loadExpressionString ( & lp -> filter , buffer ) ; } } return MS_TRUE ; }"," return MS_FALSE ; if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , ""Invalidtimefilter."" , ""msPostGISLayerSetTimeFilter()"" ) ; return MS_FALSE ; }"
36,"CWE-20 void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) { u32 data , tpr ; int max_irr , max_isr ;  struct kvm_lapic * apic = vcpu -> arch . apic ;  void * vapic ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; max_irr = apic_find_highest_irr ( apic ) ; if ( max_irr < 0 ) max_irr = 0 ; max_isr = apic_find_highest_isr ( apic ) ; if ( max_isr < 0 ) max_isr = 0 ; data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ;  vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;  * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; kunmap_atomic ( vapic ) ; }"," arch . apic  ; apic_sync_pv_eoi_to_guest (  24 ) ; kvm_write_guest_cached ( vcpu -> kvm , &  vcpu -> arch  . apic -> vapic_cache , & data , sizeof ( u32 )  ) ; }"
37,"CWE-369 static void box_blur_line ( gint box_width , gint even_offset , guchar * src , guchar * dest , gint len , gint bpp ) { gint i ; gint lead ; gint output ; gint trail ;  gint * ac ;  ac = g_new0 ( gint , bpp ) ; lead = 0 ; if ( box_width % 2 != 0 ) { output = lead - ( box_width - 1 ) / 2 ; trail = lead - box_width ; } else { if ( even_offset == 1 ) { output = lead + 1 - box_width / 2 ; trail = lead - box_width ; } else if ( even_offset == - 1 ) { output = lead - box_width / 2 ; trail = lead - box_width ; } else { g_assert_not_reached ( ) ; } } for ( i = 0 ; i < bpp ; i ++ ) ac [ i ] = 0 ; while ( output < len ) { guint coverage = ( lead < len ? lead : len - 1 ) - ( trail >= 0 ? trail : - 1 ) ; # ifdef READABLE_BOXBLUR_CODE for ( i = 0 ; i < bpp ; i ++ ) { if ( lead < len ) ac [ i ] += src [ bpp * lead + i ] ; if ( trail >= 0 ) ac [ i ] -= src [ bpp * trail + i ] ; if ( output >= 0 ) dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } # endif if ( lead < len ) { if ( trail >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) { ac [ i ] += src [ bpp * lead + i ] ; ac [ i ] -= src [ bpp * trail + i ] ; dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } } else if ( output >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) { ac [ i ] += src [ bpp * lead + i ] ; dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } } else { for ( i = 0 ; i < bpp ; i ++ ) ac [ i ] += src [ bpp * lead + i ] ; } } else if ( trail >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) { ac [ i ] -= src [ bpp * trail + i ] ; dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } } else if ( output >= 0 ) { for ( i = 0 ; i < bpp ; i ++ ) dest [ bpp * output + i ] = ( ac [ i ] + ( coverage >> 1 ) ) / coverage ; } lead ++ ; output ++ ; trail ++ ; } g_free ( ac ) ; }", gint * ac ; g_assert ( box_width > 0 )
38,"CWE-264 static void start_daemon ( ) { struct usb_sock_t * usb_sock ; if ( g_options . noprinter_mode == 0 ) { usb_sock = usb_open ( ) ; if ( usb_sock == NULL ) goto cleanup_usb ; } else usb_sock = NULL ; uint16_t desired_port = g_options . desired_port ;  struct tcp_sock_t * tcp_socket ;   while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL &&   g_options . only_desired_port == 0 ) {  desired_port ++ ; if ( desired_port == 1 || desired_port == 0 ) desired_port = 49152 ;  }  if ( tcp_socket == NULL ) goto cleanup_tcp ;  uint16_t real_port = tcp_port_number_get ( tcp_socket ) ;  if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) { ERR ( ""Receivedportnumberdidnotmatchrequestedportnumber."" ""Therequestedportnumbermaybetoohigh."" ) ; goto cleanup_tcp ; } printf ( ""%u|"" , real_port ) ; fflush ( stdout ) ;  uint16_t pid ;  if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) { printf ( ""%u|"" , pid ) ; exit ( 0 ) ; } if ( usb_can_callback ( usb_sock ) ) usb_register_callback ( usb_sock ) ; for ( ; ; ) { struct service_thread_param * args = calloc ( 1 , sizeof ( * args ) ) ; if ( args == NULL ) { ERR ( ""Failedtoallocspaceforthreadargs"" ) ; goto cleanup_thread ; } args -> usb_sock = usb_sock ;  args -> tcp = tcp_conn_accept ( tcp_socket ) ;  if ( args -> tcp == NULL ) { ERR ( ""Failedtoopentcpconnection"" ) ; goto cleanup_thread ; } int status = pthread_create ( & args -> thread_handle , NULL , & service_connection , args ) ; if ( status ) { ERR ( ""Failedtospawnthread,error%d"" , status ) ; goto cleanup_thread ; } continue ; cleanup_thread : if ( args != NULL ) { if ( args -> tcp != NULL ) tcp_conn_close ( args -> tcp ) ; free ( args ) ; } break ; } cleanup_tcp : if ( tcp_socket != NULL ) tcp_close ( tcp_socket ) ;  cleanup_usb :  if ( usb_sock != NULL ) usb_close ( usb_sock ) ; return ; }"," tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) {  tcp_socket = tcp_open  ( desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket ||  g_options . only_desired_port  g_options . only_desired_port ) break ;  desired_port ++ ;  = 49152 ; NOTE ( ""Accesstodesiredportfailed,tryingalternativeport%d"" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket  == NULL )  ; uint16_t real_port ; if ( tcp_socket ) real_port  tcp_port_number_get ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket  stdout ) ; NOTE ( ""Port:%d,IPv4%savailable,IPv6%savailable"" , real_port , tcp_socket ? """" : ""not"" , tcp6_socket ? """" : ""not"" ) ;  -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket  ) ; if  tcp_socket ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;"
39,"CWE-252 static void init_syntax_once ( ) { register int c ;  static int done ;  if ( done ) return ; bzero ( re_syntax_table , sizeof re_syntax_table ) ;  for ( c = 'a' ; c <= 'z' ; c ++ )  re_syntax_table [ c ] = Sword ; for ( c = 'A' ; c <= 'Z' ; c ++ ) re_syntax_table [ c ] = Sword ; for ( c = '0' ; c <= '9' ; c ++ ) re_syntax_table [ c ] = Sword ; re_syntax_table [ '_' ] = Sword ; done = 1 ; }", static int done = 0  ( c = 0 ; c < CHAR_SET_SIZE ; ++ c ) if ( ISALNUM ( c )  ) re_syntax_table [
40,"CWE-119 void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ;  YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;  if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ; if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ; cpi -> mbgraph_n_frames = n_frames ; for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ;  vpx_memset ( frame_stats -> mb_stats , 0 ,  cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; } for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; assert ( q_cur != NULL ) ; update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ; }  vp9_clear_system_state ( ) ;  separate_arf_mbs ( cpi ) ; }"," cpi , GOLDEN_FRAME ) ; assert ( golden_ref != NULL  i ] ; memset  ( frame_stats ->  ) ; } vpx_clear_system_state  ( ) ;"
41,"CWE-000 static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; int i ; int retval = - ENOMEM ; dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; if ( dev == NULL ) { dev_err ( & interface -> dev , ""Outofmemory\\n"" ) ; return retval ; } mutex_init ( & dev -> mutex ) ; atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ;  dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ;  for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( endpoint ) ) dev -> int_in_endpoint = endpoint ; if ( usb_endpoint_is_int_out ( endpoint ) ) dev -> int_out_endpoint = endpoint ; } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) && ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) ) dev -> report_size = 7 ; dev -> int_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> int_in_urb ) { dev_err ( & interface -> dev , ""Couldn\'tallocateinterrupt_in_urb\\n"" ) ; goto error ; } dev -> int_in_buffer = kmalloc ( dev -> report_size , GFP_KERNEL ) ; if ( ! dev -> int_in_buffer ) { dev_err ( & interface -> dev , ""Couldn\'tallocateint_in_buffer\\n"" ) ; goto error ; } usb_fill_int_urb ( dev -> int_in_urb , dev -> udev , usb_rcvintpipe ( dev -> udev , dev -> int_in_endpoint -> bEndpointAddress ) , dev -> int_in_buffer , dev -> report_size , iowarrior_callback , dev , dev -> int_in_endpoint -> bInterval ) ; dev -> read_queue = kmalloc ( ( ( dev -> report_size + 1 ) * MAX_INTERRUPT_BUFFER ) , GFP_KERNEL ) ; if ( ! dev -> read_queue ) { dev_err ( & interface -> dev , ""Couldn\'tallocateread_queue\\n"" ) ; goto error ; } memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; usb_string ( udev , udev -> descriptor . iSerialNumber , dev -> chip_serial , sizeof ( dev -> chip_serial ) ) ; if ( strlen ( dev -> chip_serial ) != 8 ) memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; if ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) { usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0A , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; } dev -> present = 1 ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & iowarrior_class ) ; if ( retval ) { dev_err ( & interface -> dev , ""Notabletogetaminorforthisdevice.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""IOWarriorproduct=0x%x,serial=%sinterface=%d"" ""nowattachedtoiowarrior%d\\n"" , dev -> product_id , dev -> chip_serial , iface_desc -> desc . bInterfaceNumber , dev -> minor - IOWARRIOR_MINOR_BASE ) ; return retval ; error : iowarrior_delete ( dev ) ; return retval ; }"," idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalidnumberofendpoints\\n"" ) ; retval = - EINVAL ; goto error ; }"
42,"CWE-285 static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) {  exit_client ( client_p , client_p , client_p , ""Mixingclientandserverprotocol"" ) ;  return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL ) { sendto_one ( saslserv_p , "":%sENCAP%sSASL%s%sH%s%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , source_p -> host , source_p -> sockhost ) ; if ( ! strcmp ( parv [ 1 ] , ""EXTERNAL"" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , "":%sENCAP%sSASL%s%sS%s%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ; else sendto_one ( saslserv_p , "":%sENCAP%sSASL%s%sS%s"" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ; rb_strlcpy ( source_p -> localClient -> sasl_agent , saslserv_p -> id , IDLEN ) ; } else sendto_one ( agent_p , "":%sENCAP%sSASL%s%sC%s"" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ; source_p -> localClient -> sasl_out ++ ; return 0 ; }"," client_p , ""Mixingclientandserverprotocol"" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '' ) ) { exit_client ( client_p , client_p , client_p , ""MalformedAUTHENTICATE"""
43,"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:objectheadersize%unotamultipleof4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:objectheadertooshort%u<%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%sObject(%u)Flags:[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""andforward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""ifunknown],Class-Type:%s(%u),length:%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:objectgoespastendofobjectsTLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4DestAddress:%s,ProtocolID:0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%sFlags:[0x%02x],DestPort%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6DestAddress:%s,ProtocolID:0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%sFlags:[0x%02x],DestPort%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelEndPoint:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6P2MPLSPID:0x%08x,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4P2MPLSPID:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelEndPoint:%s,TunnelID:0x%04x,ExtendedTunnelID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4ReceiverAddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6ReceiverAddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4NotifyNodeAddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6NotifyNodeAddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sGeneralizedLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sWavebandID:%u%sStartLabel:%u,StopLabel:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sReservationStyle:%s,Flags:[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%smergecapability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%sMinimumVPI/VCI:%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%sMaximumVPI/VCI:%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sL3ProtocolID:%s"" , ident , tok2str ( ethertype_values , ""UnknownProtocol(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%sMinimum/MaximumDLCI:%u/%u,%s%sbitDLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sLSPEncodingType:%s(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%sSwitchingType:%s(%u),PayloadID:%s(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%sSubobjectType:%s,length%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%sERROR:zerolengthEROsubtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""ERROR:length!=8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""ERROR:Prefixlength%u!=32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",%s,%s/%u,Flags:[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""ERROR:length!=8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",Flags:[%s](%#x),Class-Type:%s(%u),%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceInstance:0x%08x,DestinationInstance:0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sRestartTime:%ums,RecoveryTime:%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%sSessionName:"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Flags:[%s](%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%sSubobjectType:%s(%u),AF:%s(%u),length:%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; if ( subobj_len == 0 ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sUNIIPv4TNAaddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sUNIIPv6TNAaddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%sU-bit:%x,Labeltype:%u,Logicalportid:%u,Label:%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%sServicelevel:%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sPrevious/NextInterface:%s,LogicalInterfaceHandle:0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sPrevious/NextInterface:%s,LogicalInterfaceHandle:0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sRefreshPeriod:%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sMsg-Version:%u,length:%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%sServiceType:%s(%u),breakbit%sset,Servicelength:%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,SourcePort:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,FlowLabel:%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv6TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSourceAddress:%s,LSP-ID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sIPv4TunnelSenderAddress:%s,LSPID:0x%04x"" ""%sSub-GroupOriginatorID:%s,Sub-GroupID:0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ;  bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;   switch ( rsvp_obj_ctype ) {  case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Hop-limit:%u,Bandwidth:%.10gMbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%sInclude-any:0x%08x,Exclude-any:0x%08x,Include-all:0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ;  ND_PRINT ( ( ndo , ""%sSetupPriority:%u,HoldingPriority:%u,Hop-limit:%u,Bandwidth:%.10gMbps"" ,  ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%sIncludeColors:0x%08x,ExcludeColors:0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%sPLR-ID:%s,Avoid-Node-ID:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%sCT:%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%sErrorNodeAddress:%s,Flags:[0x%02x]%sErrorCode:%s(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",UnknownErrorValue(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%sErrorNodeAddress:%s,Flags:[0x%02x]%sErrorCode:%s(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",ErrorValue:%s(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%sTLVcount:%u,paddingbytes:%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s%sTLV(0x%02x),length:%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%sFlags[0x%02x],epoch:%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sMessage-ID0x%08x(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%sKey-ID0x%04x%08x,Sequence0x%08x%08x,Flags[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%sMD5-sum0x%08x%08x%08x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sFlags[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%sAction:%s(%u),Labeltype:%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%sStartrange:%u,Endrange:%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%sSubchannel#%u:%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSub-LSPdestinationaddress:%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%sSub-LSPdestinationaddress:%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }", ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;  bandwidth ) ;  ND_PRINT ( (  - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
44,"CWE-20 static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ;  struct sock * sk = sock -> sk ;  struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG ""%s:len%d,flags%xch.nr%d,proto%x\\n"" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ;  if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) {  msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms ( sk ) -> ch . nr ; maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; }  } else {   if ( msg -> msg_namelen )  printk ( KERN_WARNING ""%s:toosmallnamelen%d\\n"" , __func__ , msg -> msg_namelen ) ; msg -> msg_namelen = 0 ; } copied = skb -> len + MISDN_HEADER_LEN ; if ( len < copied ) { if ( flags & MSG_PEEK ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - ENOSPC ; } memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; mISDN_sock_cmsg ( sk , msg , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }", sock -> sk  ; int copied  ( msg -> msg_name ) { struct sockaddr_mISDN * maddr =  msg -> msg_name  0xFF ; }  msg -> msg_namelen  msg -> msg_namelen = sizeof ( * maddr )  ; } copied
45,"CWE-20 static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;  up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }"," == 0 ) mark_key_instantiated ( key , 0  ) ; up_write"
46,"CWE-264 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;  final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;  dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }"," ) ) ; rcu_read_lock ( ) ;  & fl6 , rcu_dereference (  np -> opt ) , & final ) ; rcu_read_unlock (  ) ; dst"
47,"CWE-20 static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ;  struct sock * sk = sock -> sk ;  struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG ""%s:len%d,flags%xch.nr%d,proto%x\\n"" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ;  if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) {  msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms ( sk ) -> ch . nr ; maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; }  } else {   if ( msg -> msg_namelen )  printk ( KERN_WARNING ""%s:toosmallnamelen%d\\n"" , __func__ , msg -> msg_namelen ) ; msg -> msg_namelen = 0 ; } copied = skb -> len + MISDN_HEADER_LEN ; if ( len < copied ) { if ( flags & MSG_PEEK ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - ENOSPC ; } memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; mISDN_sock_cmsg ( sk , msg , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }", sock -> sk  ; int copied  ( msg -> msg_name ) { struct sockaddr_mISDN * maddr =  msg -> msg_name  0xFF ; }  msg -> msg_namelen  msg -> msg_namelen = sizeof ( * maddr )  ; } copied
48,"CWE-200 int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ;  bool slow ;  if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  }  if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }", ; bool slow  ; if (  ) ) ; * addr_len = sizeof ( * sin ) ;
49,"CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : {  register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;  ND_PRINT ( ( ndo , ""\\n\\tOptions[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , ""\\n\\tHelloTimer%us,DeadTimer%us,Interface-ID%s,Priority%u"" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , ""\\n\\tDesignatedRouter%s"" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , "",BackupDesignatedRouter%s"" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""\\n\\tNeighborList:"" ) ) ; ap = hellop -> hello_neighbor ; while ( ( const u_char * ) ap < dataend ) { ND_TCHECK ( * ap ) ; ND_PRINT ( ( ndo , ""\\n\\t%s"" , ipaddr_string ( ndo , ap ) ) ) ; ++ ap ; } } break ; } case OSPF_TYPE_DD : { register const struct dd6 * ddp = ( const struct dd6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( ddp -> db_options ) ; ND_PRINT ( ( ndo , ""\\n\\tOptions[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & ddp -> db_options ) ) ) ) ; ND_TCHECK ( ddp -> db_flags ) ; ND_PRINT ( ( ndo , "",DDFlags[%s]"" , bittok2str ( ospf6_dd_flag_values , ""none"" , ddp -> db_flags ) ) ) ; ND_TCHECK ( ddp -> db_seq ) ; ND_PRINT ( ( ndo , "",MTU%u,DD-Sequence0x%08x"" , EXTRACT_16BITS ( & ddp -> db_mtu ) , EXTRACT_32BITS ( & ddp -> db_seq ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { lshp = ddp -> db_lshdr ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; } case OSPF_TYPE_LS_REQ : if ( ndo -> ndo_vflag > 1 ) { lsrp = ( const struct lsr6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lsrp < dataend ) { ND_TCHECK ( * lsrp ) ; ND_PRINT ( ( ndo , ""\\n\\tAdvertisingRouter%s"" , ipaddr_string ( ndo , & lsrp -> ls_router ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lsrp -> ls_type ) , & lsrp -> ls_stateid ) ; ++ lsrp ; } } break ; case OSPF_TYPE_LS_UPDATE : if ( ndo -> ndo_vflag > 1 ) { register const struct lsu6 * lsup = ( const struct lsu6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( lsup -> lsu_count ) ; i = EXTRACT_32BITS ( & lsup -> lsu_count ) ; lsap = lsup -> lsu_lsa ; while ( ( const u_char * ) lsap < dataend && i -- ) { if ( ospf6_print_lsa ( ndo , lsap , dataend ) ) goto trunc ; lsap = ( const struct lsa6 * ) ( ( const u_char * ) lsap + EXTRACT_16BITS ( & lsap -> ls_hdr . ls_length ) ) ; } } break ; case OSPF_TYPE_LS_ACK : if ( ndo -> ndo_vflag > 1 ) { lshp = ( const struct lsa6_hdr * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; default : break ; } return ( 0 ) ; trunc : return ( 1 ) ; }", op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
50,"CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) {  case 0 :  # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""UnsupportedZIPcompressionmethod(%s)"" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Macmetadataistoolarge:%jd>4Mbytes"" ,  ( intmax_t ) rsrc -> uncompressed_size ) ;  return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'tallocatememoryforMacmetadata"" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""TruncatedZIPfileheader"" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 :  memcpy ( mp , p , bytes_avail ) ;  bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , ""OutofmemoryforZIPdecompression"" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""ZIPdecompressionfailed(%d)"" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }"," case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""MalformedOSXmetadataentry:inconsistentsize"" ) ; return ( ARCHIVE_FATAL ) ; }  rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Macmetadataistoolarge:%jd>4Mbytes"" , ( intmax_t ) rsrc -> compressed_size  case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;"
51,"CWE-119 static void update_layer_contexts ( VP8_COMP * cpi ) { VP8_CONFIG * oxcf = & cpi -> oxcf ; if ( oxcf -> number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ;  for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ )  { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / oxcf -> rate_decimator [ i ] ; lc -> target_bandwidth = oxcf -> target_bitrate [ i ] * 1000 ; lc -> starting_buffer_level = rescale ( ( int ) oxcf -> starting_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> optimal_buffer_level == 0 ) lc -> optimal_buffer_level = lc -> target_bandwidth / 8 ; else lc -> optimal_buffer_level = rescale ( ( int ) oxcf -> optimal_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> maximum_buffer_size == 0 ) lc -> maximum_buffer_size = lc -> target_bandwidth / 8 ; else lc -> maximum_buffer_size = rescale ( ( int ) oxcf -> maximum_buffer_size_in_ms , lc -> target_bandwidth , 1000 ) ; if ( i > 0 ) lc -> avg_frame_size_for_layer = ( int ) ( ( oxcf -> target_bitrate [ i ] - oxcf -> target_bitrate [ i - 1 ] ) * 1000 / ( lc -> framerate - prev_layer_framerate ) ) ; prev_layer_framerate = lc -> framerate ; } } }", oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i  ) { LAYER_CONTEXT
52,"CWE-20 static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , """" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if ( strcmp ( command , ""permipc"" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; COMMON_AUDIT_DATA_INIT ( & sa , NONE ) ; sa . aad . op = OP_SETPROCATTR ; sa . aad . info = name ; sa . aad . error = - EINVAL ;  return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL ,  & sa , NULL ) ; } } else if ( strcmp ( name , ""exec"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; } else { return - EINVAL ; } if ( ! error ) error = size ; return error ; }"," ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL  ) ; }"
53,"CWE-125 static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t%sSubtype(%u)"" , tok2str ( lldp_8023_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\tautonegotiation[%s](0x%02x)"" , bittok2str ( lldp_8023_autonegotiation_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tPMDautonegcapability[%s](0x%04x)"" , bittok2str ( lldp_pmd_capability_values , ""unknown"" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMAUtype%s(0x%04x)"" , tok2str ( lldp_mau_types_values , ""unknown"" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\tMDIpowersupport[%s],powerpair%s,powerclass%s"" , bittok2str ( lldp_mdi_values , ""none"" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , ""unknown"" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , ""unknown"" , * ( tptr + 6 ) ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\taggregationstatus[%s],aggregationportID%u"" , bittok2str ( lldp_aggregation_values , ""none"" , * ( tptr + 4 ) ) , EXTRACT_32BITS ( tptr + 5 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MTU :  ND_PRINT ( ( ndo , ""\\n\\tMTUsize%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ;  break ; default : hexdump = TRUE ; break ; } return hexdump ; }", case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
54,"CWE-119 vpx_codec_err_t vpx_codec_set_frame_buffer_functions ( vpx_codec_ctx_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { vpx_codec_err_t res ; if ( ! ctx || ! cb_get || ! cb_release ) { res = VPX_CODEC_INVALID_PARAM ; } else if ( ! ctx -> iface || ! ctx -> priv || ! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { res = VPX_CODEC_ERROR ; } else {  res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release ,  cb_priv ) ; } return SAVE_STATUS ( ctx , res ) ; }"," . set_fb_fn ( get_alg_priv ( ctx )  , cb_get ,"
55,"CWE-20 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ;  int res , ret ;  if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }"," res , ret ; if ( uaddr == uaddr2 ) return - EINVAL"
56,"CWE-200 static void tty_set_termios_ldisc ( struct tty_struct * tty , int num ) { down_write ( & tty -> termios_rwsem ) ; tty -> termios . c_line = num ; up_write ( & tty -> termios_rwsem ) ;  } ", termios_rwsem ) ; tty -> disc_data = NULL ; tty -> receive_room = 0 ;
57,"CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ;  if ( n <= 0 ) return ( n ) ;  if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && * p == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }", if ( n  != i )
58,"CWE-415 struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newicsk -> icsk_bind_hash = NULL ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , SOCK_RCU_FREE ) ;  newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;  atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }", SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
59,"CWE-362 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:asoc:%p,timeo:%ld,msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ;  BUG_ON ( sk != asoc -> base . sk ) ;  lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }", current_timeo ) ; if  ( sk !=  . sk ) goto do_error
60,"CWE-119 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ;  dlen -= 2 ;  for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }", ; dlen -= 3  ; for (
61,"CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , ""INVALID-PAYLOAD-TYPE"" , ""DOI-NOT-SUPPORTED"" , ""SITUATION-NOT-SUPPORTED"" , ""INVALID-COOKIE"" , ""INVALID-MAJOR-VERSION"" , ""INVALID-MINOR-VERSION"" , ""INVALID-EXCHANGE-TYPE"" , ""INVALID-FLAGS"" , ""INVALID-MESSAGE-ID"" , ""INVALID-PROTOCOL-ID"" , ""INVALID-SPI"" , ""INVALID-TRANSFORM-ID"" , ""ATTRIBUTES-NOT-SUPPORTED"" , ""NO-PROPOSAL-CHOSEN"" , ""BAD-PROPOSAL-SYNTAX"" , ""PAYLOAD-MALFORMED"" , ""INVALID-KEY-INFORMATION"" , ""INVALID-ID-INFORMATION"" , ""INVALID-CERT-ENCODING"" , ""INVALID-CERTIFICATE"" , ""CERT-TYPE-UNSUPPORTED"" , ""INVALID-CERT-AUTHORITY"" , ""INVALID-HASH-INFORMATION"" , ""AUTHENTICATION-FAILED"" , ""INVALID-SIGNATURE"" , ""ADDRESS-NOTIFICATION"" , ""NOTIFY-SA-LIFETIME"" , ""CERTIFICATE-UNAVAILABLE"" , ""UNSUPPORTED-EXCHANGE-TYPE"" , ""UNEQUAL-PAYLOAD-LENGTHS"" , } ; static const char * ipsec_notify_error_str [ ] = { ""RESERVED"" , } ; static const char * notify_status_str [ ] = { ""CONNECTED"" , } ; static const char * ipsec_notify_status_str [ ] = { ""RESPONDER-LIFETIME"" , ""REPLAY-STATUS"" , ""INITIAL-CONTACT"" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , ""doi=%d"" , doi ) ) ; ND_PRINT ( ( ndo , ""proto=%d"" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , ""doi=ipsec"" ) ) ; ND_PRINT ( ( ndo , ""proto=%s"" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""type=%s"" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , ""type=%s"" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , ""attrs=("" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp ,  ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;  } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""status=("" ) ) ; ND_PRINT ( ( ndo , ""replaydetection%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }"," , cp , ep2  , map ,  nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; }"
62,"CWE-119  static void fdct8 ( const int16_t * input , int16_t * output ) {   int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;   int t0 , t1 , t2 , t3 ;  int x0 , x1 , x2 , x3 ; s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x2 * cospi_24_64 + x3 * cospi_8_64 ; t3 = - x2 * cospi_8_64 + x3 * cospi_24_64 ;  output [ 0 ] = fdct_round_shift ( t0 ) ;   output [ 2 ] = fdct_round_shift ( t2 ) ;   output [ 4 ] = fdct_round_shift ( t1 ) ;   output [ 6 ] = fdct_round_shift ( t3 ) ;  t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ;  t2 = fdct_round_shift ( t0 ) ;  t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ;  output [ 1 ] = fdct_round_shift ( t0 ) ;   output [ 3 ] = fdct_round_shift ( t2 ) ;   output [ 5 ] = fdct_round_shift ( t1 ) ;   output [ 7 ] = fdct_round_shift ( t3 ) ;  }"," fdct8 ( const tran_low_t * input , tran_low_t  * output )  output ) { tran_high_t  s0 , s1  , s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t  x0 , x1  0 ] = ( tran_low_t )  2 ] = ( tran_low_t )  4 ] = ( tran_low_t )  6 ] = ( tran_low_t )  ; t2 = ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t )  fdct_round_shift ( t1  1 ] = ( tran_low_t )  3 ] = ( tran_low_t )  5 ] = ( tran_low_t )  7 ] = ( tran_low_t )"
63,"CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , ""MLTIwithmultiple(%d)MDPR"" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data ,  size2 , mime ) ;  if ( ret < 0 ) return ret ; } return 0 ; }"," , size2 , NULL  ) ; if"
64,"CWE-19 int xfs_attr3_leaf_flipflags ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf1 ; struct xfs_attr_leafblock * leaf2 ; struct xfs_attr_leaf_entry * entry1 ; struct xfs_attr_leaf_entry * entry2 ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp1 ; struct xfs_buf * bp2 ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr1 ; struct xfs_attr3_icleaf_hdr ichdr2 ; xfs_attr_leaf_name_local_t * name_loc ; int namelen1 , namelen2 ; char * name1 , * name2 ; # endif trace_xfs_attr_leaf_flipflags ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ; if ( error ) return error ; if ( args -> blkno2 != args -> blkno ) { error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ; if ( error ) return error ; } else { bp2 = bp1 ; } leaf1 = bp1 -> b_addr ; entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ; leaf2 = bp2 -> b_addr ; entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ; ASSERT ( args -> index < ichdr1 . count ) ; ASSERT ( args -> index >= 0 ) ; xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ; ASSERT ( args -> index2 < ichdr2 . count ) ; ASSERT ( args -> index2 >= 0 ) ; if ( entry1 -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf1 , args -> index ) ; namelen1 = name_loc -> namelen ; name1 = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ; namelen1 = name_rmt -> namelen ; name1 = ( char * ) name_rmt -> name ; } if ( entry2 -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf2 , args -> index2 ) ; namelen2 = name_loc -> namelen ; name2 = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ; namelen2 = name_rmt -> namelen ; name2 = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry1 -> hashval ) == be32_to_cpu ( entry2 -> hashval ) ) ; ASSERT ( namelen1 == namelen2 ) ; ASSERT ( memcmp ( name1 , name2 , namelen1 ) == 0 ) ; # endif ASSERT ( entry1 -> flags & XFS_ATTR_INCOMPLETE ) ; ASSERT ( ( entry2 -> flags & XFS_ATTR_INCOMPLETE ) == 0 ) ; entry1 -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , entry1 , sizeof ( * entry1 ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;  name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;  xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ; } entry2 -> flags |= XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp2 , XFS_DA_LOGRANGE ( leaf2 , entry2 , sizeof ( * entry2 ) ) ) ; if ( ( entry2 -> flags & XFS_ATTR_LOCAL ) == 0 ) { name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ; name_rmt -> valueblk = 0 ; name_rmt -> valuelen = 0 ; xfs_trans_log_buf ( args -> trans , bp2 , XFS_DA_LOGRANGE ( leaf2 , name_rmt , sizeof ( * name_rmt ) ) ) ; } error = xfs_trans_roll ( & args -> trans , args -> dp ) ; return error ; }", ( args -> rmtvaluelen  ) ; xfs_trans_log_buf
65,"CWE-119 static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  int mi_row , int mi_col , vp9_reader * r ) {  MODE_INFO * const mi = xd -> mi [ 0 ] ; MB_MODE_INFO * const mbmi = & mi -> mbmi ;  const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ;   const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;  const BLOCK_SIZE bsize = mbmi -> sb_type ; int i ;  mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ;  mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ;  mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ;  mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; switch ( bsize ) { case BLOCK_4X4 : for ( i = 0 ; i < 4 ; ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , i ) ) ; mbmi -> mode = mi -> bmi [ 3 ] . as_mode ; break ; case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; mi -> bmi [ 1 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 1 ) ) ; break ; case BLOCK_8X4 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 1 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; mi -> bmi [ 2 ] . as_mode = mi -> bmi [ 3 ] . as_mode = mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 2 ) ) ; break ; default : mbmi -> mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } mbmi -> uv_mode = read_intra_mode ( r , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }"," int mi_col , vpx_reader  * r )  = xd -> above_mi  ; const MODE_INFO  = xd -> left_mi  ; const BLOCK_SIZE  int i ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ;  ( cm , mi_offset , x_mis , y_mis  , r )  cm , xd  , 1 ,"
66,CWE-119 cJSON * cJSON_CreateFalse ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_False ; return item ; },"
"
67,"CWE-772 struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; if ( ret < local_nr_pages ) { ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = PAGE_SIZE - offset ;  if ( len <= 0 )  break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ;  len -= bytes ;  offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , BIO_USER_MAPPED ) ; bio_get ( bio ) ; return bio ; out_unmap : for ( j = 0 ; j < nr_pages ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return ERR_PTR ( ret ) ; }", - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ;  ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;
68,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent ,  length ;  ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;  sun_pixels = sun_data ;  bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;  }  p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," , extent , height ,  ""UnableToReadImageData"" ) ;  height = sun_info  ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED )  sun_data ) ;  p = sun_pixels"
69,"CWE-264 int regset_tls_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct user_desc infobuf [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ;  if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) ||  ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ; if ( kbuf ) info = kbuf ; else if ( __copy_from_user ( infobuf , ubuf , count ) ) return - EFAULT ; else info = infobuf ;  set_tls_desc ( target ,  GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ; return 0 ; }", * info ; int i ;  = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;
70,"CWE-19 int xfs_attr_rmtval_set ( struct xfs_da_args * args ) { struct xfs_inode * dp = args -> dp ; struct xfs_mount * mp = dp -> i_mount ; struct xfs_bmbt_irec map ; xfs_dablk_t lblkno ; xfs_fileoff_t lfileoff = 0 ; __uint8_t * src = args -> value ; int blkcnt ; int valuelen ; int nmap ; int error ; int offset = 0 ; trace_xfs_attr_rmtval_set ( args ) ;  blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ;  error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error ) return error ; args -> rmtblkno = lblkno = ( xfs_dablk_t ) lfileoff ; args -> rmtblkcnt = blkcnt ; while ( blkcnt > 0 ) { int committed ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_write ( args -> trans , dp , ( xfs_fileoff_t ) lblkno , blkcnt , XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA , args -> firstblock , args -> total , & map , & nmap , args -> flist ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK ) ) ; lblkno += map . br_blockcount ; blkcnt -= map . br_blockcount ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; } lblkno = args -> rmtblkno ; blkcnt = args -> rmtblkcnt ;  valuelen = args -> valuelen ;  while ( valuelen > 0 ) { struct xfs_buf * bp ; xfs_daddr_t dblkno ; int dblkcnt ; ASSERT ( blkcnt > 0 ) ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_read ( dp , ( xfs_fileoff_t ) lblkno , blkcnt , & map , & nmap , XFS_BMAPI_ATTRFORK ) ; if ( error ) return ( error ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK ) ) ; dblkno = XFS_FSB_TO_DADDR ( mp , map . br_startblock ) , dblkcnt = XFS_FSB_TO_BB ( mp , map . br_blockcount ) ; bp = xfs_buf_get ( mp -> m_ddev_targp , dblkno , dblkcnt , 0 ) ; if ( ! bp ) return ENOMEM ; bp -> b_ops = & xfs_attr3_rmt_buf_ops ; xfs_attr_rmtval_copyin ( mp , bp , args -> dp -> i_ino , & offset , & valuelen , & src ) ; error = xfs_bwrite ( bp ) ; xfs_buf_relse ( bp ) ; if ( error ) return error ; lblkno += map . br_blockcount ; blkcnt -= map . br_blockcount ; } ASSERT ( valuelen == 0 ) ; return 0 ; }"," , args -> rmtvaluelen  ) ; error  = args -> rmtvaluelen  ; while ("
71,"CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ;  set_exception_intercept ( svm , AC_VECTOR ) ;  set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }"," svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR"
72,"CWE-20 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd ; UWORD16 pic_ht ; UWORD32 num_mbs ; pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> s_high_profile . u1_scaling_present = 0 ; ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; if ( ps_dec -> u1_first_slice_in_stream ) { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------DisplayBuffersReset--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""gotabuffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""didnotgetabuffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row += 2 ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row += 2 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ;  H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;  return OK ; }", = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;
73,"CWE-269 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:condump<filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ;  COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;  f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:couldn\'topen%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumpedconsoletextto%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }"," "".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:Onlythe\\"".txt\\""extensionissupportedbythiscommand!\\n"" ) ; return ; }"
74,"CWE-89 char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ;  int strindex = 0 ;  size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , ""%%%02X"" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }", = alloc ; size_t  strindex = 0
75,"CWE-189 static bool states_equal ( struct bpf_verifier_env * env , struct bpf_verifier_state * old , struct bpf_verifier_state * cur ) { int i ;  if ( old -> curframe != cur -> curframe )  return false ; for ( i = 0 ; i <= old -> curframe ; i ++ ) { if ( old -> frame [ i ] -> callsite != cur -> frame [ i ] -> callsite ) return false ; if ( ! func_states_equal ( old -> frame [ i ] , cur -> frame [ i ] ) ) return false ; } return true ; }", cur -> curframe ) return false ; if ( old -> speculative && ! cur -> speculative
76,"CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ;  set_exception_intercept ( svm , AC_VECTOR ) ;  set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }"," svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR"
77,"CWE-189 static int fixup_bpf_calls ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; struct bpf_insn mask_and_div [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn mask_and_mod [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , } ; struct bpf_insn * patchlet ; if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { patchlet = mask_and_div + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ; } else { patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ; } new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) { cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpfverifierismisconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }  if ( insn -> code != ( BPF_JMP | BPF_CALL ) )  continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; aux = & env -> insn_aux_data [ i + delta ] ;  if ( ! bpf_map_ptr_unpriv ( aux ) )  continue ;  if ( bpf_map_ptr_poisoned ( aux ) ) {  verbose ( env , ""tail_callabusingmap_ptr\\n"" ) ; return - EINVAL ; } map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }  if ( prog -> jit_requested && BITS_PER_LONG == 64 &&  ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ;  if ( bpf_map_ptr_poisoned ( aux ) )   goto patch_call_imm ;  map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;  ops = map_ptr -> ops ;  if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {  cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;  if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpfverifierismisconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }  BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem ,  ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_delete_elem , ( int ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_update_elem , ( int ( * ) ( struct bpf_map * map , void * key , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_push_elem , ( int ( * ) ( struct bpf_map * map , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_pop_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_peek_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; switch ( insn -> imm ) { case BPF_FUNC_map_lookup_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_lookup_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_update_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_update_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_delete_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_delete_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_push_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_push_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_pop_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_pop_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_peek_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_peek_elem ) - __bpf_call_base ; continue ; } goto patch_call_imm ; } patch_call_imm : fn = env -> ops -> get_func_proto ( insn -> imm , env -> prog ) ; if ( ! fn -> func ) { verbose ( env , ""kernelsubsystemmisconfiguredfunc%s#%d\\n"" , func_id_name ( insn -> imm ) , insn -> imm ) ; return - EFAULT ; } insn -> imm = fn -> func - __bpf_call_base ; } return 0 ; }"," insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg  ; aux =  if ( ! aux -> alu_state  ) continue ;  ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf  ; new_prog =  } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ;  aux = &  ; if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if (  aux ) ) { verbose ( env , ""tail_callabusingmap_ptr\\n"" ) ; return - EINVAL ; }  map_ptr = BPF_MAP_PTR  map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of  ( map_ptr ,  ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ;  new_prog = bpf_patch_insn_data  continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpfverifierismisconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }"
78,"CWE-787 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ;  context . Xtogo = i -> width ;  context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Localpalette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced"" ) ; fprintf ( i -> parent -> log , ""imgpos(%hu,%hu)size%hux%hupalbits=%hhuimgbits=%hhuncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Endofimagecode\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assezdepixels,Onsecasse!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Codeclear(free=%hu)npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; WritePixel ( i , & context , casspecial ) ; npix -- ; } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; WritePixels ( i , & context , stackp , stack_top - stackp ) ; npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }"," parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***ERROR***ImagebiggerthanglobalGIFcanvas!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***WARNING***AdjustingXposition\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***WARNING***AdjustingYposition\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }"
79,"CWE-119 void vpx_free ( void * memblk ) { if ( memblk ) { void * addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ;  # if CONFIG_MEM_MANAGER  hmm_free ( & hmm_d , addr ) ; # else VPX_FREE_L ( addr ) ;  # endif  } }", ] ) ; free  ( addr )  addr ) ;  } } 
80,"CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { ""date-time-at-completed"" , ""date-time-at-creation"" , ""date-time-at-processing"" , ""job-detailed-status-messages"" , ""job-document-access-errors"" , ""job-id"" , ""job-impressions-completed"" , ""job-k-octets-completed"" , ""job-media-sheets-completed"" , ""job-pages-completed"" , ""job-printer-up-time"" , ""job-printer-uri"" , ""job-state"" , ""job-state-message"" , ""job-state-reasons"" , ""job-uri"" , ""number-of-documents"" , ""number-of-intervening-jobs"" , ""output-device-assigned"" , ""time-at-completed"" , ""time-at-creation"" , ""time-at-processing"" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , ""add_job(%p[%d],%p(%s),%p(%s/%s))"" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : ""none"" , filetype ? filetype -> type : ""none"" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , ""localhost"" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""Theprinterorclassisnotshared."" ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , ""auth-info"" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return ( NULL ) ; } else if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , ""negotiate"" ) && ! con -> username [ 0 ] ) { send_http_error ( con , HTTP_UNAUTHORIZED , printer ) ; return ( NULL ) ; } # ifdef HAVE_SSL else if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) ) { send_http_error ( con , HTTP_UPGRADE_REQUIRED , printer ) ; return ( NULL ) ; } # endif if ( ! printer -> accepting ) { send_ipp_status ( con , IPP_NOT_ACCEPTING , _ ( ""Destination\\""%s\\""isnotacceptingjobs."" ) , printer -> name ) ; return ( NULL ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( readonly ) / sizeof ( readonly [ 0 ] ) ) ; i ++ ) { if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL ) { ippDeleteAttribute ( con -> request , attr ) ; if ( StrictConformance ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""The\'%s\'JobStatusattributecannotbesuppliedinajobcreationrequest."" ) , readonly [ i ] ) ; return ( NULL ) ; } cupsdLogMessage ( CUPSD_LOG_INFO , ""Unexpected\'%s\'JobStatusattributeinajobcreationrequest."" , readonly [ i ] ) ; } } if ( printer -> pc ) { for ( mandatory = ( char * ) cupsArrayFirst ( printer -> pc -> mandatory ) ; mandatory ; mandatory = ( char * ) cupsArrayNext ( printer -> pc -> mandatory ) ) { if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) ) { send_ipp_status ( con , IPP_CONFLICT , _ ( ""The\\""%s\\""attributeisrequiredforprintjobs."" ) , mandatory ) ; return ( NULL ) ; } } } if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) ) { char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; snprintf ( mimetype , sizeof ( mimetype ) , ""%s/%s"" , filetype -> super , filetype -> type ) ; send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( ""Unsupportedformat\\""%s\\""."" ) , mimetype ) ; ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , ""document-format"" , NULL , mimetype ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""copies"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badcopiesvalue%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""copies"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Badjob-sheetsvaluetype."" ) ) ; return ( NULL ) ; } if ( attr -> num_values > 2 ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Toomanyjob-sheetsvalues(%d>2)."" ) , attr -> num_values ) ; return ( NULL ) ; } for ( i = 0 ; i < attr -> num_values ; i ++ ) if ( strcmp ( attr -> values [ i ] . string . text , ""none"" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Badjob-sheetsvalue\\""%s\\""."" ) , attr -> values [ i ] . string . text ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""number-up"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badnumber-upvalue%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""number-up"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""page-ranges"" , IPP_TAG_RANGE ) ) != NULL ) { for ( i = 0 , lowerpagerange = 1 ; i < attr -> num_values ; i ++ ) { if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Badpage-rangesvalues%d-%d."" ) , attr -> values [ i ] . range . lower , attr -> values [ i ] . range . upper ) ; return ( NULL ) ; } lowerpagerange = attr -> values [ i ] . range . upper + 1 ; } } if ( ! ippFindAttribute ( con -> request , ""PageRegion"" , IPP_TAG_ZERO ) && ! ippFindAttribute ( con -> request , ""PageSize"" , IPP_TAG_ZERO ) && _ppdCacheGetPageSize ( printer -> pc , con -> request , NULL , & exact ) ) { if ( ! exact && ( media_col = ippFindAttribute ( con -> request , ""media-col"" , IPP_TAG_BEGIN_COLLECTION ) ) != NULL ) { send_ipp_status ( con , IPP_OK_SUBST , _ ( ""Unsupportedmargins."" ) ) ; unsup_col = ippNew ( ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-bottom-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-bottom-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-left-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-left-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-right-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-right-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-top-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-top-margin"" , media_margin -> values [ 0 ] . integer ) ; ippAddCollection ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , ""media-col"" , unsup_col ) ; ippDelete ( unsup_col ) ; } } if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) cupsdCleanJobs ( ) ; if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Toomanyactivejobs."" ) ) ; return ( NULL ) ; } if ( ( i = check_quotas ( con , printer ) ) < 0 ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Quotalimitreached."" ) ) ; return ( NULL ) ; } else if ( i == 0 ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""Notallowedtoprint."" ) ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-priority"" , IPP_TAG_INTEGER ) ) != NULL ) priority = attr -> values [ 0 ] . integer ; else { if ( ( val = cupsGetOption ( ""job-priority"" , printer -> num_options , printer -> options ) ) != NULL ) priority = atoi ( val ) ; else priority = 50 ; ippAddInteger ( con -> request , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-priority"" , priority ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_ZERO ) ) == NULL ) ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_NAME , ""job-name"" , NULL , ""Untitled"" ) ; else if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badjob-namevalue:Wrongtypeorcount."" ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } else if ( ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badjob-namevalue:%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; }  if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  { send_ipp_status ( con , IPP_INTERNAL_ERROR , _ ( ""Unabletoaddjobfordestination\\""%s\\""."" ) , printer -> name ) ; return ( NULL ) ; } job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ) ; job -> attrs = con -> request ; job -> dirty = 1 ; con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ) ; cupsdMarkDirty ( CUPSD_DIRTY_JOBS ) ; add_job_uuid ( job ) ;  apply_printer_defaults ( printer , job ) ;  attr = ippFindAttribute ( job -> attrs , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( con -> username [ 0 ] ) { cupsdSetString ( & job -> username , con -> username ) ; if ( attr ) ippSetString ( job -> attrs , & attr , 0 , con -> username ) ; } else if ( attr ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""add_job:requesting-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text ) ; cupsdSetString ( & job -> username , attr -> values [ 0 ] . string . text ) ; } else cupsdSetString ( & job -> username , ""anonymous"" ) ; if ( ! attr ) ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-user-name"" , NULL , job -> username ) ; else { ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; ippSetName ( job -> attrs , & attr , ""job-originating-user-name"" ) ; } if ( con -> username [ 0 ] || auth_info ) { save_auth_info ( con , job , auth_info ) ; if ( auth_info ) ippDeleteAttribute ( job -> attrs , auth_info ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_NAME ) ) != NULL ) cupsdSetString ( & ( job -> name ) , attr -> values [ 0 ] . string . text ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-originating-host-name"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , ""localhost"" ) ) { ippDeleteAttribute ( job -> attrs , attr ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } else ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; } else { ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-completed"" ) ; ippAddDate ( job -> attrs , IPP_TAG_JOB , ""date-time-at-creation"" , ippTimeToDate ( time ( NULL ) ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-processing"" ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-completed"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""time-at-creation"" , time ( NULL ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-processing"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , IPP_JOB_STOPPED ) ; job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer ; job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , ""job-incoming"" ) ; job -> impressions = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-impressions-completed"" , 0 ) ; job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-media-sheets-completed"" , 0 ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_URI , ""job-printer-uri"" , NULL , printer -> uri ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-k-octets"" , IPP_TAG_INTEGER ) ) != NULL ) attr -> values [ 0 ] . integer = 0 ; else ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-k-octets"" , 0 ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_KEYWORD ) ) == NULL ) attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_NAME ) ; if ( ! attr ) { if ( ( val = cupsGetOption ( ""job-hold-until"" , printer -> num_options , printer -> options ) ) == NULL ) val = ""no-hold"" ; attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-hold-until"" , NULL , val ) ; } if ( printer -> holding_new_jobs ) { if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) cupsdSetJobHoldUntil ( job , ippGetString ( attr , 0 , NULL ) , 0 ) ; else cupsdSetJobHoldUntil ( job , ""indefinite"" , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-held-on-create"" ) ; } else if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) { cupsdSetJobHoldUntil ( job , attr -> values [ 0 ] . string . text , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-hold-until-specified"" ) ; } else if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB ) { job -> hold_until = time ( NULL ) + MultipleOperationTimeout ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; } else { job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING ; job -> state_value = IPP_JOB_PENDING ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""none"" ) ; } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification ) { if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) == NULL ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""Addingdefaultjob-sheetsvalues\\""%s,%s\\""..."" , printer -> job_sheets [ 0 ] , printer -> job_sheets [ 1 ] ) ; attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-sheets"" , 2 , NULL , NULL ) ; ippSetString ( job -> attrs , & attr , 0 , printer -> job_sheets [ 0 ] ) ; ippSetString ( job -> attrs , & attr , 1 , printer -> job_sheets [ 1 ] ) ; } job -> job_sheets = attr ; if ( Classification ) { cupsdLogMessage ( CUPSD_LOG_INFO , ""Classification=\\""%s\\"",ClassifyOverride=%d"" , Classification ? Classification : ""(null)"" , ClassifyOverride ) ; if ( ClassifyOverride ) { if ( ! strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s,none\\"","" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } else if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) { ippSetString ( job -> attrs , & attr , 1 , attr -> values [ 0 ] . string . text ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s,%s\\"","" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) ) { if ( attr -> num_values == 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONOVERRIDDEN"" ""job-sheets=\\""%s\\"","" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONOVERRIDDEN"" ""job-sheets=\\""%s,%s\\"",fffff"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) ) { if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } else { if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 0 , Classification ) ; if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } if ( attr -> num_values > 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s,%s\\"","" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s\\"","" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) ) { cupsdLogJob ( job , CUPSD_LOG_INFO , ""Addingstartbannerpage\\""%s\\""."" , attr -> values [ 0 ] . string . text ) ; if ( ( kbytes = copy_banner ( con , job , attr -> values [ 0 ] . string . text ) ) < 0 ) { cupsdSetJobState ( job , IPP_JOB_ABORTED , CUPSD_JOB_PURGE , ""Abortingjobbecausethestartbannercouldnotbe"" ""copied."" ) ; return ( NULL ) ; } cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ) ; } } else if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) job -> job_sheets = attr ; httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , ""ipp"" , NULL , con -> clientname , con -> clientport , ""/jobs/%d"" , job -> id ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , ""job-uri"" , NULL , job_uri ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , job -> state_value ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_TEXT , ""job-state-message"" , NULL , """" ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , job -> reasons -> values [ 0 ] . string . text ) ; con -> response -> request . status . status_code = IPP_OK ; add_job_subscriptions ( con , job ) ; for ( attr = job -> attrs -> attrs -> next -> next ; attr ; attr = attr -> next ) attr -> group_tag = IPP_TAG_JOB ; cupsdAddEvent ( CUPSD_EVENT_JOB_CREATED , printer , job , ""Jobcreated."" ) ; return ( job ) ; }"," ) ; } attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badrequesting-user-namevalue:%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; }  printer , job  ) ; if"
81,"CWE-787 rfbBool InitialiseRFBConnection ( rfbClient * client ) { rfbProtocolVersionMsg pv ; int major , minor ; uint32_t authScheme ; uint32_t subAuthScheme ; rfbClientInitMsg ci ; if ( client -> listenSpecified ) errorMessageOnReadFailure = FALSE ; if ( ! ReadFromRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; errorMessageOnReadFailure = TRUE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; if ( sscanf ( pv , rfbProtocolVersionFormat , & major , & minor ) != 2 ) { rfbClientLog ( ""NotavalidVNCserver(%s)\\n"" , pv ) ; return FALSE ; } DefaultSupportedMessages ( client ) ; client -> major = major ; client -> minor = minor ; if ( ( major == rfbProtocolMajorVersion ) && ( minor > rfbProtocolMinorVersion ) ) client -> minor = rfbProtocolMinorVersion ; if ( major == 3 && ( minor == 4 || minor == 6 ) ) { rfbClientLog ( ""UltraVNCserverdetected,enablingUltraVNCspecificmessages\\n"" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && ( minor == 14 || minor == 16 ) ) { minor = minor - 10 ; client -> minor = minor ; rfbClientLog ( ""UltraVNCSingleClickserverdetected,enablingUltraVNCspecificmessages\\n"" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && minor == 5 ) { rfbClientLog ( ""TightVNCserverdetected,enablingTightVNCspecificmessages\\n"" , pv ) ; DefaultSupportedMessagesTightVNC ( client ) ; } if ( ( major == 3 && minor > 8 ) || major > 3 ) { client -> major = 3 ; client -> minor = 8 ; } rfbClientLog ( ""VNCserversupportsprotocolversion%d.%d(viewer%d.%d)\\n"" , major , minor , rfbProtocolMajorVersion , rfbProtocolMinorVersion ) ; sprintf ( pv , rfbProtocolVersionFormat , client -> major , client -> minor ) ; if ( ! WriteToRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; if ( client -> major == 3 && client -> minor > 6 ) { if ( ! ReadSupportedSecurityType ( client , & authScheme , FALSE ) ) return FALSE ; } else { if ( ! ReadFromRFBServer ( client , ( char * ) & authScheme , 4 ) ) return FALSE ; authScheme = rfbClientSwap32IfLE ( authScheme ) ; } rfbClientLog ( ""SelectedSecurityScheme%d\\n"" , authScheme ) ; client -> authScheme = authScheme ; switch ( authScheme ) { case rfbConnFailed : ReadReason ( client ) ; return FALSE ; case rfbNoAuth : rfbClientLog ( ""Noauthenticationneeded\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVncAuth : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif case rfbMSLogon : if ( ! HandleMSLogonAuth ( client ) ) return FALSE ; break ; case rfbARD : # ifndef LIBVNCSERVER_WITH_CLIENT_GCRYPT rfbClientLog ( ""GCryptsupportwasnotcompiledin\\n"" ) ; return FALSE ; # else if ( ! HandleARDAuth ( client ) ) return FALSE ; # endif break ; case rfbTLS : if ( ! HandleAnonTLSAuth ( client ) ) return FALSE ; if ( ! ReadSupportedSecurityType ( client , & subAuthScheme , TRUE ) ) return FALSE ; client -> subAuthScheme = subAuthScheme ; switch ( subAuthScheme ) { case rfbConnFailed : ReadReason ( client ) ; return FALSE ; case rfbNoAuth : rfbClientLog ( ""Nosubauthenticationneeded\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVncAuth : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif default : rfbClientLog ( ""UnknownsubauthenticationschemefromVNCserver:%d\\n"" , ( int ) subAuthScheme ) ; return FALSE ; } break ; case rfbVeNCrypt : if ( ! HandleVeNCryptAuth ( client ) ) return FALSE ; switch ( client -> subAuthScheme ) { case rfbVeNCryptTLSNone : case rfbVeNCryptX509None : rfbClientLog ( ""Nosubauthenticationneeded\\n"" ) ; if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; break ; case rfbVeNCryptTLSVNC : case rfbVeNCryptX509VNC : if ( ! HandleVncAuth ( client ) ) return FALSE ; break ; case rfbVeNCryptTLSPlain : case rfbVeNCryptX509Plain : if ( ! HandlePlainAuth ( client ) ) return FALSE ; break ; # ifdef LIBVNCSERVER_HAVE_SASL case rfbVeNCryptX509SASL : case rfbVeNCryptTLSSASL : if ( ! HandleSASLAuth ( client ) ) return FALSE ; break ; # endif default : rfbClientLog ( ""UnknownsubauthenticationschemefromVNCserver:%d\\n"" , client -> subAuthScheme ) ; return FALSE ; } break ; default : { rfbBool authHandled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; e ; e = e -> next ) { uint32_t const * secType ; if ( ! e -> handleAuthentication ) continue ; for ( secType = e -> securityTypes ; secType && * secType ; secType ++ ) { if ( authScheme == * secType ) { if ( ! e -> handleAuthentication ( client , authScheme ) ) return FALSE ; if ( ! rfbHandleAuthResult ( client ) ) return FALSE ; authHandled = TRUE ; } } } if ( authHandled ) break ; } rfbClientLog ( ""UnknownauthenticationschemefromVNCserver:%d\\n"" , ( int ) authScheme ) ; return FALSE ; } ci . shared = ( client -> appData . shareDesktop ? 1 : 0 ) ; if ( ! WriteToRFBServer ( client , ( char * ) & ci , sz_rfbClientInitMsg ) ) return FALSE ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> si , sz_rfbServerInitMsg ) ) return FALSE ; client -> si . framebufferWidth = rfbClientSwap16IfLE ( client -> si . framebufferWidth ) ; client -> si . framebufferHeight = rfbClientSwap16IfLE ( client -> si . framebufferHeight ) ; client -> si . format . redMax = rfbClientSwap16IfLE ( client -> si . format . redMax ) ; client -> si . format . greenMax = rfbClientSwap16IfLE ( client -> si . format . greenMax ) ; client -> si . format . blueMax = rfbClientSwap16IfLE ( client -> si . format . blueMax ) ; client -> si . nameLength = rfbClientSwap32IfLE ( client -> si . nameLength ) ;  client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ;  if ( ! client -> desktopName ) { rfbClientLog ( ""Errorallocatingmemoryfordesktopname,%lubytes\\n"" , ( unsigned long ) client -> si . nameLength ) ; return FALSE ; } if ( ! ReadFromRFBServer ( client , client -> desktopName , client -> si . nameLength ) ) return FALSE ; client -> desktopName [ client -> si . nameLength ] = 0 ; rfbClientLog ( ""Desktopname\\""%s\\""\\n"" , client -> desktopName ) ; rfbClientLog ( ""ConnectedtoVNCserver,usingprotocolversion%d.%d\\n"" , client -> major , client -> minor ) ; rfbClientLog ( ""VNCserverdefaultformat:\\n"" ) ; PrintPixelFormat ( & client -> si . format ) ; return TRUE ; }"," nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( ""Toobigdesktopnamelengthsentbyserver:%uB>1MB\\n"" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; }  = malloc (  client -> si"
82,"CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ;  size_t  value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; }  value = ( size_t ) ( buffer [ 0 ] << 24 ) ;   value |= buffer [ 1 ] << 16 ;   value |= buffer [ 2 ] << 8 ;   value |= buffer [ 3 ] ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }", 4 ] ; unsigned int  value ; if  value = ( unsigned int )  buffer [ 0  ] << 24  ; value |=  ; value |= ( unsigned int )  ; value |= ( unsigned int )  ; value |= ( unsigned int )  . unsigned_value =  value & 0xffffffff  value & 0xffffffff  ; return (
83,"CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:trunc)"" ) ) ; goto trunc ; }  ND_PRINT ( ( ndo , ""(refresh:%u)"" ,  EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(ni:ho=0x%04xco=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type%u:trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }", trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
84,"CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ;  char added ;  } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ;  pair -> added = 0 ;  for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }", * key ;  } * pair  it ) ;  for ( it
85,"CWE-399 static ssize_t fuse_fill_write_pages ( struct fuse_req * req , struct address_space * mapping , struct iov_iter * ii , loff_t pos ) { struct fuse_conn * fc = get_fuse_conn ( mapping -> host ) ; unsigned offset = pos & ( PAGE_CACHE_SIZE - 1 ) ; size_t count = 0 ; int err ; req -> in . argpages = 1 ; req -> page_descs [ 0 ] . offset = offset ; do { size_t tmp ; struct page * page ; pgoff_t index = pos >> PAGE_CACHE_SHIFT ; size_t bytes = min_t ( size_t , PAGE_CACHE_SIZE - offset , iov_iter_count ( ii ) ) ; bytes = min_t ( size_t , bytes , fc -> max_write - count ) ; again : err = - EFAULT ; if ( iov_iter_fault_in_readable ( ii , bytes ) ) break ; err = - ENOMEM ; page = grab_cache_page_write_begin ( mapping , index , 0 ) ; if ( ! page ) break ; if ( mapping_writably_mapped ( mapping ) ) flush_dcache_page ( page ) ; tmp = iov_iter_copy_from_user_atomic ( page , ii , offset , bytes ) ;  flush_dcache_page ( page ) ;  if ( ! tmp ) { unlock_page ( page ) ; page_cache_release ( page ) ; bytes = min ( bytes , iov_iter_single_seg_count ( ii ) ) ; goto again ; } err = 0 ; req -> pages [ req -> num_pages ] = page ; req -> page_descs [ req -> num_pages ] . length = tmp ; req -> num_pages ++ ;  iov_iter_advance ( ii , tmp ) ;  count += tmp ; pos += tmp ; offset += tmp ; if ( offset == PAGE_CACHE_SIZE ) offset = 0 ; if ( ! fc -> big_writes ) break ; } while ( iov_iter_count ( ii ) && count < fc -> max_write && req -> num_pages < req -> max_pages && offset == 0 ) ; return count > 0 ? count : err ; }"," flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp  num_pages ++ ;  count += tmp"
86,"CWE-264 SYSCALL_DEFINE2 ( osf_getdomainname , char __user * , name , int , namelen ) { unsigned len ; int i ; if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ; len = namelen ;  if ( namelen > 32 )  len = 32 ; down_read ( & uts_sem ) ; for ( i = 0 ; i < len ; ++ i ) { __put_user ( utsname ( ) -> domainname [ i ] , name + i ) ; if ( utsname ( ) -> domainname [ i ] == '\\0' ) break ; } up_read ( & uts_sem ) ; return 0 ; }", ; if ( len  > 32 )
87,"CWE-59 static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( ""lxc.lxcpath"" ) ; if ( ! lxcpath ) { ERROR ( ""Outofmemory"" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , ""%s/%s/rootfs"" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( ""ignoringmountpoint\'%s\'"" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , ""%s/%s"" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( ""pathnmetoolongfor\'%s\'"" , mntent -> mnt_dir ) ; return - 1 ; }  return mount_entry_on_generic ( mntent , path ) ;  }"," mntent , path , rootfs -> mount"
88,"CWE-119 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; int retsize ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( ""Downmix_Commandcommand%"" PRIu32 ""cmdSize%"" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT :  if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {  return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t )  || pReplyData == NULL || * replySize != sizeof ( int ) ) {  return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( ""Downmix_CommandEFFECT_CMD_GET_PARAMpCmdData%p,*replySize%"" PRIu32 "",pReplyData:%p"" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ||  pReplyData == NULL ||  * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( ""Downmix_CommandEFFECT_CMD_GET_PARAMparam%"" PRId32 "",replySize%"" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( ""Downmix_CommandEFFECT_CMD_SET_PARAMcmdSize%dpCmdData%p,*replySize%"" PRIu32 "",pReplyData%p"" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) )  || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) {  return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( ""Downmix_CommandcommandEFFECT_CMD_SET_PARAM_DEFERREDnotsupported,FIXME"" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( ""Downmix_CommandcommandEFFECT_CMD_SET_PARAM_COMMITnotsupported,FIXME"" ) ; break ; case EFFECT_CMD_ENABLE :  if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {  return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( ""EFFECT_CMD_ENABLE()OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE :  if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {  return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( ""EFFECT_CMD_DISABLE()OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_CommandEFFECT_CMD_SET_DEVICE:0x%08"" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( ""Downmix_CommandcommandEFFECT_CMD_SET_VOLUMEnotsupported,FIXME"" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( ""Downmix_CommandEFFECT_CMD_SET_VOLUME:left%f,right%f"" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_CommandEFFECT_CMD_SET_AUDIO_MODE:%"" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( ""Downmix_Commandinvalidcommand%"" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }", == NULL || replySize == NULL ||  ) || pReplyData == NULL || replySize  ) || pReplyData == NULL || replySize  == NULL || replySize == NULL ||  == NULL || replySize == NULL ||  if ( pReplyData == NULL || replySize
89,"CWE-20 static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ;  msg -> msg_namelen = 0 ;  skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }", goto out ;  skb = skb_recv_datagram
90,"CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ;  if ( debug ) {  printk ( KERN_INFO ""cx24116:%s("" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO ""0x%02x"" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO "","" ) ; } printk ( "")toneburst=%d\\n"" , toneburst ) ; }  if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) )  return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( ""%sburst=%d\\n"" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }", ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if (  ) ; }  for ( i
91,"CWE-125 void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRPversion%upacketnotsupported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP%s,length:%u"" , tok2str ( eigrp_opcode_values , ""unknown(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; }  tlen = len - sizeof ( struct eigrp_common_header ) ;  ND_PRINT ( ( ndo , ""\\n\\tEIGRPv%u,opcode:%s(%u),chksum:0x%04x,Flags:[%s]\\n\\tseq:0x%08x,ack:0x%08x,AS:%u,length:%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,type:%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t%sTLV(0x%04x),length:%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ;  tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;  tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\tholdtime:%us,k1%u,k2%u,k3%u,k4%u,k5%u"" ,  EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\tIOSversion:%u.%u,EIGRPversion%u.%u"" ,  tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\tillegalprefixlength%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\tIPv4prefix:%15s/%u,nexthop:"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tdelay%ums,bandwidth%uKbps,mtu%u,hop%u,reliability%u,load%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ;  bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;  if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\tillegalprefixlength%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\tIPv4prefix:%15s/%u,nexthop:"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\torigin-router%s,origin-as%u,origin-proto%s,flags[0x%02x],tag0x%08x,metric%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tdelay%ums,bandwidth%uKbps,mtu%u,hop%u,reliability%u,load%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\tCable-range:%u-%u,Router-ID%u"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\tCable-Range:%u-%u,nexthop:"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tdelay%ums,bandwidth%uKbps,mtu%u,hop%u,reliability%u,load%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ;  ND_PRINT ( ( ndo , ""\\n\\tCable-Range:%u-%u,nexthop:"" ,  EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\torigin-router%u,origin-as%u,origin-proto%s,flags[0x%02x],tag0x%08x,metric%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tdelay%ums,bandwidth%uKbps,mtu%u,hop%u,reliability%u,load%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\tpacketexceededsnapshot"" ) ) ; }"," return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP%s,length:%u(tooshort,<%u)"" , tok2str ( eigrp_opcode_values , ""unknown(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; }  ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; }  ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""(tooshort,<%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }"
92,"CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , ""Badlyformattedoption%s-expectedSection:Name=Value\\n"" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ;  strncpy ( szSec , opt_string , sepIdx ) ;  szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , ""Badlyformattedoption%s-expectedSection:Name=Value\\n"" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ;  strncpy ( szKey , sep , sepIdx ) ;  szKey [ sepIdx ] = 0 ;  strcpy ( szVal , sep2 + 1 ) ;  } if ( ! stricmp ( szKey , ""*"" ) ) { if ( stricmp ( szVal , ""null"" ) ) { fprintf ( stderr , ""Badlyformattedoption%s-expectedSection:*=null\\n"" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , ""null"" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }"," - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badlyformattedoption%s-Sectionnameistoolong\\n"" , opt_string ) ; return ; }  - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badlyformattedoption%s-keynameistoolong\\n"" , opt_string ) ; return ; }  = 0 ; if ( strlen (  sep2 + 1  + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badlyformattedoption%s-valueistoolong\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )"
93,"CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ;  if ( size_bmp > BMP_HEADER_SIZE ) {  int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }", size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
94,"CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ;  switch ( pc -> componentType ) {  case 1 : if ( pc -> lengthComponentIdent > 0 )  break ;  case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , ""../"" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""./"" , 2 ) ; p += 2 ; tolen -= 2 ; break ;  case 5 :  comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; }  elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ;  } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }", elen ) ; elen += sizeof ( struct pathComponent ) ;  > 0 ) { elen += pc -> lengthComponentIdent ; break ; }  case 2 :  case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ;  break ; }  } if (
95,"CWE-269 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; if ( requeue_pi ) {  if ( refill_pi_state_cache ( ) )  return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : if ( pi_state != NULL ) { free_pi_state ( pi_state ) ; pi_state = NULL ; } ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) )  goto out_put_key1 ;  hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( ret , hb2 , & key2 , & pi_state , NULL ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { wake_futex ( this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { atomic_inc ( & pi_state -> refcount ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task , 1 ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; free_pi_state ( pi_state ) ; goto out_unlock ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } out_unlock : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : if ( pi_state != NULL ) free_pi_state ( pi_state ) ; return ret ? ret : task_count ; }"," { if ( uaddr1 == uaddr2 ) return - EINVAL ; if (  goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }"
96,"CWE-20 static void keyring_describe ( const struct key * keyring , struct seq_file * m ) { if ( keyring -> description ) seq_puts ( m , keyring -> description ) ; else seq_puts ( m , ""[anon]"" ) ;  if ( key_is_instantiated ( keyring ) ) {  if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":%lu"" , keyring -> keys . nr_leaves_on_tree ) ; else seq_puts ( m , "":empty"" ) ; } }", ; if ( key_is_positive  ( keyring )
97,"CWE-189 Datum hstore_from_record ( PG_FUNCTION_ARGS ) { HeapTupleHeader rec ; int32 buflen ; HStore * out ; Pairs * pairs ; Oid tupType ; int32 tupTypmod ; TupleDesc tupdesc ; HeapTupleData tuple ; RecordIOData * my_extra ; int ncolumns ; int i , j ; Datum * values ; bool * nulls ; if ( PG_ARGISNULL ( 0 ) ) { Oid argtype = get_fn_expr_argtype ( fcinfo -> flinfo , 0 ) ; tupType = argtype ; tupTypmod = - 1 ; rec = NULL ; } else { rec = PG_GETARG_HEAPTUPLEHEADER ( 0 ) ; tupType = HeapTupleHeaderGetTypeId ( rec ) ; tupTypmod = HeapTupleHeaderGetTypMod ( rec ) ; } tupdesc = lookup_rowtype_tupdesc ( tupType , tupTypmod ) ; ncolumns = tupdesc -> natts ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; if ( my_extra == NULL || my_extra -> ncolumns != ncolumns ) { fcinfo -> flinfo -> fn_extra = MemoryContextAlloc ( fcinfo -> flinfo -> fn_mcxt , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; my_extra -> record_type = InvalidOid ; my_extra -> record_typmod = 0 ; } if ( my_extra -> record_type != tupType || my_extra -> record_typmod != tupTypmod ) { MemSet ( my_extra , 0 , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra -> record_type = tupType ; my_extra -> record_typmod = tupTypmod ; my_extra -> ncolumns = ncolumns ; }  pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;  if ( rec ) { tuple . t_len = HeapTupleHeaderGetDatumLength ( rec ) ; ItemPointerSetInvalid ( & ( tuple . t_self ) ) ; tuple . t_tableOid = InvalidOid ; tuple . t_data = rec ; values = ( Datum * ) palloc ( ncolumns * sizeof ( Datum ) ) ; nulls = ( bool * ) palloc ( ncolumns * sizeof ( bool ) ) ; heap_deform_tuple ( & tuple , tupdesc , values , nulls ) ; } else { values = NULL ; nulls = NULL ; } for ( i = 0 , j = 0 ; i < ncolumns ; ++ i ) { ColumnIOData * column_info = & my_extra -> columns [ i ] ; Oid column_type = tupdesc -> attrs [ i ] -> atttypid ; char * value ; if ( tupdesc -> attrs [ i ] -> attisdropped ) continue ; pairs [ j ] . key = NameStr ( tupdesc -> attrs [ i ] -> attname ) ; pairs [ j ] . keylen = hstoreCheckKeyLen ( strlen ( NameStr ( tupdesc -> attrs [ i ] -> attname ) ) ) ; if ( ! nulls || nulls [ i ] ) { pairs [ j ] . val = NULL ; pairs [ j ] . vallen = 4 ; pairs [ j ] . isnull = true ; pairs [ j ] . needfree = false ; ++ j ; continue ; } if ( column_info -> column_type != column_type ) { bool typIsVarlena ; getTypeOutputInfo ( column_type , & column_info -> typiofunc , & typIsVarlena ) ; fmgr_info_cxt ( column_info -> typiofunc , & column_info -> proc , fcinfo -> flinfo -> fn_mcxt ) ; column_info -> column_type = column_type ; } value = OutputFunctionCall ( & column_info -> proc , values [ i ] ) ; pairs [ j ] . val = value ; pairs [ j ] . vallen = hstoreCheckValLen ( strlen ( value ) ) ; pairs [ j ] . isnull = false ; pairs [ j ] . needfree = false ; ++ j ; } ncolumns = hstoreUniquePairs ( pairs , j , & buflen ) ; out = hstorePairs ( pairs , ncolumns , buflen ) ; ReleaseTupleDesc ( tupdesc ) ; PG_RETURN_POINTER ( out ) ; }", ncolumns ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;
98,"CWE-20 error_t enc28j60ReceivePacket ( NetInterface * interface ) { error_t error ;  uint16_t n ;  uint16_t status ;  Enc28j60Context * context ;  context = ( Enc28j60Context * ) interface -> nicContext ;  if ( enc28j60ReadReg ( interface , ENC28J60_REG_EPKTCNT ) )  { enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTL , LSB ( context -> nextPacket ) ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTH , MSB ( context -> nextPacket ) ) ;   enc28j60ReadBuffer ( interface , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ;  enc28j60ReadBuffer ( interface , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; enc28j60ReadBuffer ( interface , ( uint8_t * ) & status , sizeof ( uint16_t ) ) ;  if ( ( status & RSV_RECEIVED_OK ) != 0 )  {  n = MIN ( n , ETH_MAX_FRAME_SIZE ) ;   enc28j60ReadBuffer ( interface , context -> rxBuffer , n ) ;  error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC28J60_RX_BUFFER_START ) {  enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;  } else {  enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ;  }  enc28j60SetBit ( interface , ENC28J60_REG_ECON2 , ECON2_PKTDEC ) ;  } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ;  nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ;  } return error ; }"," error ; uint16_t length  ; uint16_t status  uint16_t status ; uint8_t header [ 6 ] ;  ( interface , ENC28J60_EPKTCNT ) != 0 ) { enc28j60WriteReg ( interface , ENC28J60_ERDPTL  , LSB (  ( interface , ENC28J60_ERDPTH  , MSB (  ( interface , header  , sizeof (  , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD16LE ( header + 4  ) ; if  ( status & ENC28J60_RSV_RECEIVED_OK  ) != 0  0 ) { length  = MIN (  = MIN ( length  , ETH_MAX_FRAME_SIZE )  -> rxBuffer , length  ) ; error  ( interface , ENC28J60_ERXRDPTL  , LSB (  ( interface , ENC28J60_ERXRDPTH  , MSB (  ( interface , ENC28J60_ERXRDPTL  , LSB (  ( interface , ENC28J60_ERXRDPTH  , MSB (  ( interface , ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC  ) ; }  -> rxBuffer , length  , & ancillary"
99,"CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ;  cleanup_free char * base_path = NULL ;  int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , ""--version"" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( ""prctl(PR_SET_NO_NEW_CAPS)failed"" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( ""--cap-addinsetuidmodecanbeusedonlybyroot"" ) ; if ( opt_userns_block_fd != - 1 && ! opt_unshare_user ) die ( ""--userns-block-fdrequires--unshare-user"" ) ; if ( opt_userns_block_fd != - 1 && opt_info_fd == - 1 ) die ( ""--userns-block-fdrequires--info-fd"" ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # ifdef ENABLE_REQUIRE_USERNS if ( is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # endif if ( opt_unshare_user_try && stat ( ""/proc/self/ns/user"" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( ""/sys/module/user_namespace/parameters/enable"" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , ""/sys/module/user_namespace/parameters/enable"" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( stat ( ""/proc/sys/user/max_user_namespaces"" , & sbuf ) == 0 ) { cleanup_free char * max_user_ns = NULL ; max_user_ns = load_file_at ( AT_FDCWD , ""/proc/sys/user/max_user_namespaces"" ) ; if ( max_user_ns != NULL && strcmp ( max_user_ns , ""0\\n"" ) == 0 ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( ""Creatingrootmountpoint\\n"" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( ""Specifying--uidrequires--unshare-user"" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( ""Specifying--gidrequires--unshare-user"" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( ""Specifying--hostnamerequires--unshare-uts"" ) ; if ( opt_as_pid_1 && ! opt_unshare_pid ) die ( ""Specifying--as-pid-1requires--unshare-pid"" ) ; if ( opt_as_pid_1 && lock_files != NULL ) die ( ""Specifying--as-pid-1and--lock-fileisnotpermitted"" ) ; proc_fd = open ( ""/proc"" , O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( ""Can\'topen/proc"" ) ;  base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ;  if ( ensure_dir ( base_path , 0755 ) ) { free ( base_path ) ; base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ; if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( ""Creatingrootmountpointfailed"" ) ; } __debug__ ( ( ""creatingnewnamespace\\n"" ) ) ; if ( opt_unshare_pid && ! opt_as_pid_1 ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) { if ( errno == ENOENT ) die ( ""Cannotcreatenewcgroupnamespacebecausethekerneldoesnotsupportit"" ) ; else die_with_error ( ""staton/proc/self/ns/cgroupfailed"" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( ""/proc/self/ns/cgroup"" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( ""eventfd()"" ) ; if ( opt_json_status_fd != - 1 ) { int ret ; ret = pipe2 ( setup_finished_pipe , O_CLOEXEC ) ; if ( ret == - 1 ) die_with_error ( ""pipe2()"" ) ; } pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( ""Creatingnewnamespacefailed,likelybecausethekerneldoesnotsupportusernamespaces.bwrapmustbeinstalledsetuidonsuchsystems."" ) ; else if ( errno == EPERM && ! is_privileged ) die ( ""Nopermissionstocreatingnewnamespace,likelybecausethekerneldoesnotallownon-privilegedusernamespaces.One.g.debianthiscanbeenabledwith\'sysctlkernel.unprivileged_userns_clone=1\'."" ) ; } die_with_error ( ""Creatingnewnamespacefailed"" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( FALSE ) ; handle_die_with_parent ( ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{\\n\\""child-pid\\"":%i\\n}\\n"" , pid ) ; dump_info ( opt_info_fd , output , TRUE ) ; close ( opt_info_fd ) ; } if ( opt_json_status_fd != - 1 ) { cleanup_free char * output = xasprintf ( ""{\\""child-pid\\"":%i}\\n"" , pid ) ; dump_info ( opt_json_status_fd , output , TRUE ) ; } if ( opt_userns_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_userns_block_fd , b , 1 ) ) ; close ( opt_userns_block_fd ) ; } val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; return monitor_child ( event_fd , pid , setup_finished_pipe [ 0 ] ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; if ( opt_json_status_fd != - 1 ) close ( opt_json_status_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net ) loopback_setup ( ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( ""Failedtomake/slave"" ) ; if ( mount ( ""tmpfs"" , base_path , ""tmpfs"" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( ""Failedtomounttmpfs"" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( ""chdirbase_path"" ) ; if ( mkdir ( ""newroot"" , 0755 ) ) die_with_error ( ""Creatingnewrootfailed"" ) ; if ( mount ( ""newroot"" , ""newroot"" , NULL , MS_MGC_VAL | MS_BIND | MS_REC , NULL ) < 0 ) die_with_error ( ""settingupnewrootbind"" ) ; if ( mkdir ( ""oldroot"" , 0755 ) ) die_with_error ( ""Creatingoldrootfailed"" ) ; if ( pivot_root ( base_path , ""oldroot"" ) ) die_with_error ( ""pivot_root"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir/(basepath)"" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( ""Can\'tcreateprivsepsocket"" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( ""Can\'tforkunprivilegedhelper"" ) ; if ( child == 0 ) { drop_privs ( FALSE ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( ""Can\'twritetoop_socket"" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } close_ops_fd ( ) ; if ( mount ( ""oldroot"" , ""oldroot"" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( ""Failedtomakeoldrootrprivate"" ) ; if ( umount2 ( ""oldroot"" , MNT_DETACH ) ) die_with_error ( ""unmountoldroot"" ) ; { cleanup_fd int oldrootfd = open ( ""/"" , O_DIRECTORY | O_RDONLY ) ; if ( oldrootfd < 0 ) die_with_error ( ""can\'topen/"" ) ; if ( chdir ( ""/newroot"" ) != 0 ) die_with_error ( ""chdir/newroot"" ) ; if ( pivot_root ( ""."" , ""."" ) != 0 ) die_with_error ( ""pivot_root(/newroot)"" ) ; if ( fchdir ( oldrootfd ) < 0 ) die_with_error ( ""fchdirtooldroot"" ) ; if ( umount2 ( ""."" , MNT_DETACH ) < 0 ) die_with_error ( ""umountoldroot"" ) ; if ( chdir ( ""/"" ) != 0 ) die_with_error ( ""chdir/"" ) ; } if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) && opt_userns_block_fd == - 1 ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( ""unshareuserns"" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } drop_privs ( ! is_privileged ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_block_fd , b , 1 ) ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( ""Can\'treadseccompdata"" ) ; if ( seccomp_len % 8 != 0 ) die ( ""Invalidseccompdata,mustbemultipleof8"" ) ; seccomp_prog . len = seccomp_len / 8 ; seccomp_prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; } umask ( old_umask ) ; new_cwd = ""/"" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( ""Can\'tchdirto%s"" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( ""HOME"" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( ""PWD"" , new_cwd , 1 ) ; free ( old_cwd ) ; if ( opt_new_session && setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( ""label_exec%s"" , argv [ 0 ] ) ; __debug__ ( ( ""forkingforchild\\n"" ) ) ; if ( ! opt_as_pid_1 && ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( ""Can\'tforkforpid1"" ) ; if ( pid != 0 ) { drop_all_caps ( FALSE ) ; { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid , seccomp_data != NULL ? & seccomp_prog : NULL ) ; } } __debug__ ( ( ""launchexecutable%s\\n"" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( ! opt_as_pid_1 ) { if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; } unblock_sigchild ( ) ; handle_die_with_parent ( ) ; if ( ! is_privileged ) set_ambient_capabilities ( ) ; if ( seccomp_data != NULL && prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & seccomp_prog ) != 0 ) die_with_error ( ""prctl(PR_SET_SECCOMP)"" ) ; if ( setup_finished_pipe [ 1 ] != - 1 ) { char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; } if ( execvp ( argv [ 0 ] , argv ) == - 1 ) { if ( setup_finished_pipe [ 1 ] != - 1 ) { int saved_errno = errno ; char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; errno = saved_errno ; } die_with_error ( ""execvp%s"" , argv [ 0 ] ) ; } return 0 ; }"," mode_t old_umask ; const  char * base_path  ; base_path = ""/tmp"" ;  __debug__ ( ("
100,"CWE-617 static int connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , edge_connection_t * conn , crypt_path_t * layer_hint ) { static int num_seen = 0 ; relay_header_t rh ; unsigned domain = layer_hint ? LD_APP : LD_EXIT ; int reason ; int optimistic_data = 0 ; tor_assert ( cell ) ; tor_assert ( circ ) ; relay_header_unpack ( & rh , cell -> payload ) ; num_seen ++ ; log_debug ( domain , ""Nowseen%drelaycellshere(command%d,stream%d)."" , num_seen , rh . command , rh . stream_id ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relaycelllengthfieldtoolong.Closingcircuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( rh . stream_id == 0 ) { switch ( rh . command ) { case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_CONNECTED : case RELAY_COMMAND_DATA : case RELAY_COMMAND_END : case RELAY_COMMAND_RESOLVE : case RELAY_COMMAND_RESOLVED : case RELAY_COMMAND_BEGIN_DIR : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relaycommand%dwithzero"" ""stream_id.Dropping."" , ( int ) rh . command ) ; return 0 ; default : ; } } if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { if ( conn -> base_ . type == CONN_TYPE_EXIT && ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && rh . command == RELAY_COMMAND_DATA ) { optimistic_data = 1 ; } else { return connection_edge_process_relay_cell_not_open ( & rh , cell , circ , conn , layer_hint ) ; } } switch ( rh . command ) { case RELAY_COMMAND_DROP : return 0 ; case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_BEGIN_DIR : if ( layer_hint && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""RelaybeginrequestunsupportedatAP.Dropping."" ) ; return 0 ; } if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED && layer_hint != TO_ORIGIN_CIRCUIT ( circ ) -> cpath -> prev ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""RelaybeginrequesttoHiddenService"" ""fromintermediarynode.Dropping."" ) ; return 0 ; } if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""Begincellforknownstream.Dropping."" ) ; return 0 ; }  if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) {  static uint64_t next_id = 0 ; circ -> dirreq_id = ++ next_id ; TO_OR_CIRCUIT ( circ ) -> p_chan -> dirreq_id = circ -> dirreq_id ; } return connection_exit_begin_conn ( cell , circ ) ; case RELAY_COMMAND_DATA : ++ stats_n_data_cells_received ; if ( ( layer_hint && -- layer_hint -> deliver_window < 0 ) || ( ! layer_hint && -- circ -> deliver_window < 0 ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relaydata)circdeliver_windowbelow0.Killing."" ) ; if ( conn ) { connection_edge_end ( conn , END_STREAM_REASON_TORPROTOCOL ) ; connection_mark_for_close ( TO_CONN ( conn ) ) ; } return - END_CIRC_REASON_TORPROTOCOL ; } log_debug ( domain , ""circdeliver_windownow%d."" , layer_hint ? layer_hint -> deliver_window : circ -> deliver_window ) ; circuit_consider_sending_sendme ( circ , layer_hint ) ; if ( ! conn ) { log_info ( domain , ""datacelldropped,unknownstream(streamid%d)."" , rh . stream_id ) ; return 0 ; } if ( -- conn -> deliver_window < 0 ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relaydata)conndeliver_windowbelow0.Killing."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } stats_n_data_bytes_received += rh . length ; connection_write_to_buf ( ( char * ) ( cell -> payload + RELAY_HEADER_SIZE ) , rh . length , TO_CONN ( conn ) ) ; if ( ! optimistic_data ) { connection_edge_consider_sending_sendme ( conn ) ; } return 0 ; case RELAY_COMMAND_END : reason = rh . length > 0 ? get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) : END_STREAM_REASON_MISC ; if ( ! conn ) { log_info ( domain , ""endcell(%s)dropped,unknownstream."" , stream_end_reason_to_string ( reason ) ) ; return 0 ; } log_info ( domain , TOR_SOCKET_T_FORMAT "":endcell(%s)forstream%d."" ""Removingstream."" , conn -> base_ . s , stream_end_reason_to_string ( reason ) , conn -> stream_id ) ; if ( conn -> base_ . type == CONN_TYPE_AP ) { entry_connection_t * entry_conn = EDGE_TO_ENTRY_CONN ( conn ) ; if ( entry_conn -> socks_request && ! entry_conn -> socks_request -> has_finished ) log_warn ( LD_BUG , ""openstreamhasn\'tsentsocksansweryet?Closing."" ) ; } conn -> edge_has_sent_end = 1 ; if ( ! conn -> end_reason ) conn -> end_reason = reason | END_STREAM_REASON_FLAG_REMOTE ; if ( ! conn -> base_ . marked_for_close ) { connection_mark_and_flush ( TO_CONN ( conn ) ) ; } return 0 ; case RELAY_COMMAND_EXTEND : case RELAY_COMMAND_EXTEND2 : { static uint64_t total_n_extend = 0 , total_nonearly = 0 ; total_n_extend ++ ; if ( rh . stream_id ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'extend\'cellreceivedfornon-zerostream.Dropping."" ) ; return 0 ; } if ( cell -> command != CELL_RELAY_EARLY && ! networkstatus_get_param ( NULL , ""AllowNonearlyExtend"" , 0 , 0 , 1 ) ) { # define EARLY_WARNING_INTERVAL 3600 static ratelim_t early_warning_limit = RATELIM_INIT ( EARLY_WARNING_INTERVAL ) ; char * m ; if ( cell -> command == CELL_RELAY ) { ++ total_nonearly ; if ( ( m = rate_limit_log ( & early_warning_limit , approx_time ( ) ) ) ) { double percentage = ( ( double ) total_nonearly ) / total_n_extend ; percentage *= 100 ; log_fn ( LOG_PROTOCOL_WARN , domain , ""EXTENDcellreceived,"" ""butnotviaRELAY_EARLY.Dropping.%s"" , m ) ; log_fn ( LOG_PROTOCOL_WARN , domain , ""(Wehavedropped%.02f%%of"" ""allEXTENDcellsforthisreason)"" , percentage ) ; tor_free ( m ) ; } } else { log_fn ( LOG_WARN , domain , ""EXTENDcellreceived,inacellwithtype%d!Dropping."" , cell -> command ) ; } return 0 ; } return circuit_extend ( cell , circ ) ; } case RELAY_COMMAND_EXTENDED : case RELAY_COMMAND_EXTENDED2 : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'extended\'unsupportedatnon-origin.Dropping."" ) ; return 0 ; } log_debug ( domain , ""Gotanextendedcell!Yay."" ) ; { extended_cell_t extended_cell ; if ( extended_cell_parse ( & extended_cell , rh . command , ( const uint8_t * ) cell -> payload + RELAY_HEADER_SIZE , rh . length ) < 0 ) { log_warn ( LD_PROTOCOL , ""Can\'tparseEXTENDEDcell;killingcircuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( ( reason = circuit_finish_handshake ( TO_ORIGIN_CIRCUIT ( circ ) , & extended_cell . created_cell ) ) < 0 ) { log_warn ( domain , ""circuit_finish_handshakefailed."" ) ; return reason ; } } if ( ( reason = circuit_send_next_onion_skin ( TO_ORIGIN_CIRCUIT ( circ ) ) ) < 0 ) { log_info ( domain , ""circuit_send_next_onion_skin()failed."" ) ; return reason ; } return 0 ; case RELAY_COMMAND_TRUNCATE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""\'truncate\'unsupportedatorigin.Dropping."" ) ; return 0 ; } if ( circ -> n_hop ) { if ( circ -> n_chan ) log_warn ( LD_BUG , ""n_chanandn_hopsetonthesamecircuit!"" ) ; extend_info_free ( circ -> n_hop ) ; circ -> n_hop = NULL ; tor_free ( circ -> n_chan_create_cell ) ; circuit_set_state ( circ , CIRCUIT_STATE_OPEN ) ; } if ( circ -> n_chan ) { uint8_t trunc_reason = get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ; circuit_clear_cell_queue ( circ , circ -> n_chan ) ; channel_send_destroy ( circ -> n_circ_id , circ -> n_chan , trunc_reason ) ; circuit_set_n_circid_chan ( circ , 0 , NULL ) ; } log_debug ( LD_EXIT , ""Processed\'truncate\',replying."" ) ; { char payload [ 1 ] ; payload [ 0 ] = ( char ) END_CIRC_REASON_REQUESTED ; relay_send_command_from_edge ( 0 , circ , RELAY_COMMAND_TRUNCATED , payload , sizeof ( payload ) , NULL ) ; } return 0 ; case RELAY_COMMAND_TRUNCATED : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_EXIT , ""\'truncated\'unsupportedatnon-origin.Dropping."" ) ; return 0 ; } circuit_truncated ( TO_ORIGIN_CIRCUIT ( circ ) , layer_hint , get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ) ; return 0 ; case RELAY_COMMAND_CONNECTED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'connected\'unsupportedwhileopen.Closingcirc."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'connected\'received,noconnattachedanymore.Ignoring."" ) ; return 0 ; case RELAY_COMMAND_SENDME : if ( ! rh . stream_id ) { if ( layer_hint ) { if ( layer_hint -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpectedsendmecellfromexitrelay."" ""Closingcirc."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } layer_hint -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-levelsendmeatorigin,packagewindow%d."" , layer_hint -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } else { if ( circ -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpectedsendmecellfromclient."" ""Closingcirc(window%d)."" , circ -> package_window ) ; return - END_CIRC_REASON_TORPROTOCOL ; } circ -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-levelsendmeatnon-origin,packagewindow%d."" , circ -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } return 0 ; } if ( ! conn ) { log_info ( domain , ""sendmecelldropped,unknownstream(streamid%d)."" , rh . stream_id ) ; return 0 ; } conn -> package_window += STREAMWINDOW_INCREMENT ; log_debug ( domain , ""stream-levelsendme,packagewindownow%d."" , conn -> package_window ) ; if ( circuit_queue_streams_are_blocked ( circ ) ) { return 0 ; } connection_start_reading ( TO_CONN ( conn ) ) ; if ( connection_edge_package_raw_inbuf ( conn , 1 , NULL ) < 0 ) { connection_mark_for_close ( TO_CONN ( conn ) ) ; return 0 ; } return 0 ; case RELAY_COMMAND_RESOLVE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""resolverequestunsupportedatAP;dropping."" ) ; return 0 ; } else if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolverequestforknownstream;dropping."" ) ; return 0 ; } else if ( circ -> purpose != CIRCUIT_PURPOSE_OR ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolverequestoncircwithpurpose%d;dropping"" , circ -> purpose ) ; return 0 ; } connection_exit_begin_resolve ( cell , TO_OR_CIRCUIT ( circ ) ) ; return 0 ; case RELAY_COMMAND_RESOLVED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'resolved\'unsupportedwhileopen.Closingcirc."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'resolved\'received,noconnattachedanymore.Ignoring."" ) ; return 0 ; case RELAY_COMMAND_ESTABLISH_INTRO : case RELAY_COMMAND_ESTABLISH_RENDEZVOUS : case RELAY_COMMAND_INTRODUCE1 : case RELAY_COMMAND_INTRODUCE2 : case RELAY_COMMAND_INTRODUCE_ACK : case RELAY_COMMAND_RENDEZVOUS1 : case RELAY_COMMAND_RENDEZVOUS2 : case RELAY_COMMAND_INTRO_ESTABLISHED : case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED : rend_process_relay_cell ( circ , layer_hint , rh . command , rh . length , cell -> payload + RELAY_HEADER_SIZE ) ; return 0 ; } log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Receivedunknownrelaycommand%d.Perhapstheothersideisusing"" ""anewerversionofTor?Dropping."" , rh . command ) ; return 0 ; }", command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
101,"CWE-834 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ;  for ( i = 0 ; i < name_len ; i ++ )  avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ;  int name_len ;  avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }"," pb ) ; avio_skip ( pb , name_len  ) ; for  ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA"
102,"CWE-476 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) {  * head = NULL ;  * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }"," PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , ""Invalidemptypacket"" ) ; return GIT_ERROR  ; } if"
103,"CWE-264  int xmkstemp ( char * * tmpname , char * dir )  { char * localtmp ;  char * tmpenv ;  mode_t old_mode ; int fd , rc ;  if ( dir != NULL )   tmpenv = dir ;  else tmpenv = getenv ( ""TMPDIR"" ) ;  if ( tmpenv )  rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , tmpenv ,  program_invocation_short_name ) ;  else rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , _PATH_TMP , program_invocation_short_name ) ; if ( rc < 0 ) return - 1 ; old_mode = umask ( 077 ) ; fd = mkostemp ( localtmp , O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC ) ; umask ( old_mode ) ; if ( fd == - 1 ) { free ( localtmp ) ; localtmp = NULL ; } * tmpname = localtmp ; return fd ; }"," * tmpname , const  char * dir , const char * prefix  * localtmp ; const  , rc ;  tmpenv = dir  tmpenv = dir ? dir :  getenv ( ""TMPDIR""  ; if ( ! tmpenv ) tmpenv = _PATH_TMP ;  rc = asprintf  , tmpenv , prefix  ) ; if"
104,"CWE-20 void dhcpClientProcessMessage ( NetInterface * interface , const IpPseudoHeader * pseudoHeader , const UdpHeader * udpHeader , const NetBuffer * buffer , size_t offset , const NetRxAncillary * ancillary , void * param ) { size_t length ; DhcpClientContext * context ; DhcpMessage * message ; DhcpOption * option ; context = ( DhcpClientContext * ) param ; length = netBufferGetLength ( buffer ) - offset ;  if ( length < sizeof ( DhcpMessage ) )  return ; if ( length > DHCP_MAX_MSG_SIZE ) return ; message = netBufferAt ( buffer , offset ) ; if ( message == NULL ) return ; TRACE_DEBUG ( ""\\r\\n%s:DHCPmessagereceived(%"" PRIuSIZE ""bytes)...\\r\\n"" , formatSystemTime ( osGetSystemTime ( ) , NULL ) , length ) ; dhcpDumpMessage ( message , length ) ; if ( message -> op != DHCP_OPCODE_BOOTREPLY ) return ; if ( message -> htype != DHCP_HARDWARE_TYPE_ETH ) return ; if ( message -> hlen != sizeof ( MacAddr ) ) return ; if ( message -> magicCookie != HTONL ( DHCP_MAGIC_COOKIE ) ) return ; option = dhcpGetOption ( message , length , DHCP_OPT_DHCP_MESSAGE_TYPE ) ; if ( option == NULL || option -> length != 1 ) return ; switch ( option -> value [ 0 ] ) { case DHCP_MESSAGE_TYPE_OFFER : dhcpClientParseOffer ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_ACK : dhcpClientParseAck ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_NAK : dhcpClientParseNak ( context , message , length ) ; break ; default : break ; } }", ( DhcpMessage ) ||  length > DHCP_MAX_MSG_SIZE
105,"CWE-119 static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct strbuf * path , const char * name , void * cb_data ) { struct object * obj = & blob -> object ;  if ( ! revs -> blob_objects )  return ; if ( ! obj ) die ( ""badblobobject"" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; obj -> flags |= SEEN ;  show ( obj , path , name , cb_data ) ;   } "," -> object ; size_t pathlen ;  |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ;  obj , path -> buf  , cb_data )  cb_data ) ; strbuf_setlen ( path , pathlen ) ;"
106,"CWE-119 int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( ""Enteringrequestloop!\\n"" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( ""%d:"" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , ""Disconnectrequestreceived."" ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( ""Notenoughmagic."" ) ;  if ( len > BUFSIZE + sizeof ( struct nbd_reply ) )  err ( ""Requesttoobig!"" ) ; # ifdef DODBG printf ( ""%sfrom%llu(%llu)len%d,"" , request . type ? ""WRITE"" : ""READ"" , ( unsigned long long ) request . from , ( unsigned long long ) request . from / 512 , len ) ; # endif memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; if ( ( request . from + len ) > ( OFFT_MAX ) ) { DEBUG ( ""[Numbertoolarge!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { DEBUG ( ""[RANGE!]"" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( request . type == NBD_CMD_WRITE ) { DEBUG ( ""wr:net->buf,"" ) ; readit ( client -> net , buf , len ) ; DEBUG ( ""buf->exp,"" ) ; if ( ( client -> server -> flags & F_READONLY ) || ( client -> server -> flags & F_AUTOREADONLY ) ) { DEBUG ( ""[WRITEtoREADONLY!]"" ) ; ERROR ( client , reply , EPERM ) ; continue ; } if ( expwrite ( request . from , buf , len , client ) ) { DEBUG ( ""Writefailed:%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } SEND ( client -> net , reply ) ; DEBUG ( ""OK!\\n"" ) ; continue ; } DEBUG ( ""exp->buf,"" ) ; if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { DEBUG ( ""Readfailed:%m"" ) ; ERROR ( client , reply , errno ) ; continue ; } DEBUG ( ""buf->net,"" ) ; memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; DEBUG ( ""OK!\\n"" ) ; } return 0 ; }", len > BUFSIZE -  sizeof ( struct
107,"CWE-000  static void __nfs4_close ( struct path * path , struct nfs4_state * state , mode_t mode , int wait )  { struct nfs4_state_owner * owner = state -> owner ; int call_close = 0 ;  int newstate ;  atomic_inc ( & owner -> so_count ) ; spin_lock ( & owner -> so_lock ) ;  switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) {  case FMODE_READ : state -> n_rdonly -- ; break ; case FMODE_WRITE : state -> n_wronly -- ; break ; case FMODE_READ | FMODE_WRITE : state -> n_rdwr -- ; } newstate = FMODE_READ | FMODE_WRITE ; if ( state -> n_rdwr == 0 ) { if ( state -> n_rdonly == 0 ) { newstate &= ~ FMODE_READ ; call_close |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ; call_close |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( state -> n_wronly == 0 ) { newstate &= ~ FMODE_WRITE ; call_close |= test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ; call_close |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( newstate == 0 ) clear_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } nfs4_state_set_mode_locked ( state , newstate ) ; spin_unlock ( & owner -> so_lock ) ; if ( ! call_close ) { nfs4_put_open_state ( state ) ; nfs4_put_state_owner ( owner ) ; } else nfs4_do_close ( path , state , wait ) ; }"," * state , fmode_t fmode  , int wait  = 0 ; fmode_t  newstate ; atomic_inc  ; switch ( fmode  & ( FMODE_READ"
108,"CWE-200 static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - EBADFD ; t = tu -> timeri -> timer ; if ( ! t ) return - EBADFD ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - EFAULT ; if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { err = - EINVAL ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - EINVAL ; goto _end ; } if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) | ( 1 << SNDRV_TIMER_EVENT_START ) | ( 1 << SNDRV_TIMER_EVENT_STOP ) | ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_RESUME ) | ( 1 << SNDRV_TIMER_EVENT_MSTART ) | ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { err = - EINVAL ; goto _end ; } snd_timer_stop ( tu -> timeri ) ; spin_lock_irq ( & t -> lock ) ; tu -> timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_AUTO | SNDRV_TIMER_IFLG_EXCLUSIVE | SNDRV_TIMER_IFLG_EARLY_EVENT ) ; if ( params . flags & SNDRV_TIMER_PSFLG_AUTO ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_AUTO ; if ( params . flags & SNDRV_TIMER_PSFLG_EXCLUSIVE ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EXCLUSIVE ; if ( params . flags & SNDRV_TIMER_PSFLG_EARLY_EVENT ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EARLY_EVENT ; spin_unlock_irq ( & t -> lock ) ; if ( params . queue_size > 0 && ( unsigned int ) tu -> queue_size != params . queue_size ) { if ( tu -> tread ) { ttr = kmalloc ( params . queue_size * sizeof ( * ttr ) , GFP_KERNEL ) ; if ( ttr ) { kfree ( tu -> tqueue ) ; tu -> queue_size = params . queue_size ; tu -> tqueue = ttr ; } } else { tr = kmalloc ( params . queue_size * sizeof ( * tr ) , GFP_KERNEL ) ; if ( tr ) { kfree ( tu -> queue ) ; tu -> queue_size = params . queue_size ; tu -> queue = tr ; } } } tu -> qhead = tu -> qtail = tu -> qused = 0 ; if ( tu -> timeri -> flags & SNDRV_TIMER_IFLG_EARLY_EVENT ) { if ( tu -> tread ) { struct snd_timer_tread tread ;  tread . event = SNDRV_TIMER_EVENT_EARLY ;  tread . tstamp . tv_sec = 0 ; tread . tstamp . tv_nsec = 0 ; tread . val = 0 ; snd_timer_user_append_to_tqueue ( tu , & tread ) ; } else { struct snd_timer_read * r = & tu -> queue [ 0 ] ; r -> resolution = 0 ; r -> ticks = 0 ; tu -> qused ++ ; tu -> qtail ++ ; } } tu -> filter = params . filter ; tu -> ticks = params . ticks ; err = 0 ; _end : if ( copy_to_user ( _params , & params , sizeof ( params ) ) ) return - EFAULT ; return err ; }"," snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;"
109,"CWE-362 int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = NULL ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = NULL ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , NULL , skb ) || ! af -> addr_valid ( & dest , NULL , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport ) ; if ( ! asoc ) ep = __sctp_rcv_lookup_endpoint ( & dest ) ; rcvr = asoc ? & asoc -> base : & ep -> base ; sk = rcvr -> sk ; if ( sk -> sk_bound_dev_if && ( sk -> sk_bound_dev_if != af -> skb_iif ( skb ) ) ) { if ( asoc ) { sctp_association_put ( asoc ) ; asoc = NULL ; } else { sctp_endpoint_put ( ep ) ; ep = NULL ; } sk = sctp_get_ctl_sock ( ) ; ep = sctp_sk ( sk ) -> ep ; sctp_endpoint_hold ( ep ) ; rcvr = & ep -> base ; } if ( ! asoc ) { if ( sctp_rcv_ootb ( skb ) ) { SCTP_INC_STATS_BH ( SCTP_MIB_OUTOFBLUES ) ; goto discard_release ; } } if ( ! xfrm_policy_check ( sk , XFRM_POLICY_IN , skb , family ) ) goto discard_release ; nf_reset ( skb ) ; if ( sk_filter ( sk , skb ) ) goto discard_release ; chunk = sctp_chunkify ( skb , asoc , sk ) ; if ( ! chunk ) goto discard_release ; SCTP_INPUT_CB ( skb ) -> chunk = chunk ; chunk -> rcvr = rcvr ; chunk -> sctp_hdr = sh ; sctp_init_addrs ( chunk , & src , & dest ) ; chunk -> transport = transport ; sctp_bh_lock_sock ( sk ) ;  if ( sock_owned_by_user ( sk ) ) {  SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ; sctp_add_backlog ( sk , skb ) ; } else { SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_SOFTIRQ ) ; sctp_inq_push ( & chunk -> rcvr -> inqueue , chunk ) ; } sctp_bh_unlock_sock ( sk ) ; if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; return 0 ; discard_it : SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_DISCARDS ) ; kfree_skb ( skb ) ; return 0 ; discard_release : if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; goto discard_it ; }", ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
110,"CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""UnknownOriginTypecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values ,  ""?"" , tptr [ 0 ] ) ) ) ;  for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""AS#%s,origin%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""AS#%s,origin%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""AS#%s,origin%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "","" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "","" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\tAFI:%s(%u),%sSAFI:%s(%u)"" , tok2str ( af_values , ""UnknownAFI"" , af ) , af , ( safi > 128 ) ? ""vendorspecific"" : """" , tok2str ( bgp_safi_values , ""UnknownSAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\tnoAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\tnexthop:"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "","" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:%s,%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:%s,%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:%s,%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""=%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""=%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""noAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",nh-length:%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t%uSNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t%dbytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",noSNPA"" ) ) ; } while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegallength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\tnoAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\tAFI:%s(%u),%sSAFI:%s(%u)"" , tok2str ( af_values , ""UnknownAFI"" , af ) , af , ( safi > 128 ) ? ""vendorspecific"" : """" , tok2str ( bgp_safi_values , ""UnknownSAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\tEnd-of-RibMarker(emptyNLRI)"" ) ) ; tptr += 3 ; while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegallength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t(illegalprefixlength)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""noAFI%u/SAFI%udecoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t%s(0x%04x),Flags[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknownextdcommunitytypecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":%u:%u(=%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":bandwidth:%.3fMbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":area:%s,router-type:%s,metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":%sControlFlags[0x%02x]:MTU%u"" , tok2str ( l2vpn_encaps_values , ""unknownencaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":AS%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\tTunnel-type%s(%u),Flags[%s],MPLSLabel%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tSender%s,P-Group%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tRoot-Node%s,P-Group%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tTunnel-Endpoint%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tRoot-Node%s,LSP-ID0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tExtended-Tunnel-ID%s,P2MP-ID0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; tlen = len ; while ( tlen >= 3 ) { type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t%sTLV(%u),length%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; switch ( type ) { case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; ND_PRINT ( ( ndo , "",metric%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr + 3 , ""\\n\\t"" , length - 3 ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\tOriginAS:%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t%s(%u),length:%u"" , tok2str ( bgp_attr_values , ""UnknownAttribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",Flags[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "","" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\tnoAttribute%udecoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t"" , len ) ; } return 1 ; trunc : return 0 ; }", ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
111,"CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 )  return chg ;  if ( hugepage_subpool_get_pages ( spool , chg ) )  return - ENOSPC ;   ret = hugetlb_acct_memory ( h , chg ) ;  if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ;  return ret ;  } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ;  } ", < 0 ) { ret = chg ; goto out_err ; }  if ( hugepage_subpool_get_pages  chg ) ) { ret =  - ENOSPC ;  - ENOSPC ; goto out_err ; }  chg ) ; goto out_err  ; } if  return 0 ; out_err : resv_map_put ( vma ) ; return ret ;
112,"CWE-000 char * guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) {  CLEANUP_FREE char * * lines = NULL ;  int64_t size ; char * ret ; size = guestfs_filesize ( g , filename ) ; if ( size == - 1 ) return NULL ; if ( size > MAX_SMALL_FILE_SIZE ) { error ( g , _ ( ""sizeof%sisunreasonablylarge(%"" PRIi64 ""bytes)"" ) , filename , size ) ; return NULL ; } lines = guestfs_head_n ( g , 1 , filename ) ; if ( lines == NULL ) return NULL ; if ( lines [ 0 ] == NULL ) { guestfs___free_string_list ( lines ) ; return safe_strdup ( g , """" ) ; } ret = lines [ 0 ] ;  return ret ;  }", filename ) {  char * *  0 ] ; free ( lines ) ;
113,"CWE-264 static int perf_trace_event_perm ( struct ftrace_event_call * tp_event , struct perf_event * p_event ) { if ( ftrace_event_is_function ( tp_event ) &&  perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) )  return - EPERM ; if ( ! ( p_event -> attr . sample_type & PERF_SAMPLE_RAW ) ) return 0 ; if ( p_event -> attach_state == PERF_ATTACH_TASK ) { if ( tp_event -> flags & TRACE_EVENT_FL_CAP_ANY ) return 0 ; } if ( perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; return 0 ; }", tp_event ) && perf_paranoid_tracepoint_raw  ( ) &&
114,"CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ;  case 'c' : return getnum ( L , fmt , 1 ) ;  case 'i' : case 'I' : {  int sz = getnum ( L , fmt , sizeof ( int ) ) ;  if ( sz > MAXINTSIZE ) luaL_error ( L , ""integralsize%dislargerthanlimitof%d"" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }"," return getnum (  fmt , 1  = getnum (  fmt , sizeof"
115,CWE-362 int get_evtchn_to_irq ( evtchn_port_t evtchn ) { if ( evtchn >= xen_evtchn_max_channels ( ) ) return - 1 ; if ( evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] == NULL ) return - 1 ;  return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ;  }, 1 ; return READ_ONCE (  evtchn ) ] )
116,"CWE-119  static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv ,  int_mv * dst_mv , int mb_row , int mb_col ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err , tmp_err ;  int_mv tmp_mv ;  err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,  xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ,  INT_MAX ) ; dst_mv -> as_int = 0 ;  tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv ,  mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_int = tmp_mv . as_int ; } if ( ref_mv -> as_int ) { unsigned int tmp_err ; int_mv zero_ref_mv , tmp_mv ; zero_ref_mv . as_int = 0 ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv . as_mv , & tmp_mv . as_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_int = tmp_mv . as_int ; err = tmp_err ; } } return err ; }"," cpi , const MV * ref_mv , int_mv *  dst_mv , int  & cpi -> td .  , tmp_err ; MV tmp_mv ; err = vpx_sad16x16  ( x ->  ] . stride  ) ; dst_mv  ( cpi , ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv  ; err ="
117,"CWE-20 error_t tcpSendResetSegment ( NetInterface * interface , IpPseudoHeader * pseudoHeader , TcpHeader * segment , size_t length ) { error_t error ; size_t offset ; uint8_t flags ; uint32_t seqNum ; uint32_t ackNum ; NetBuffer * buffer ; TcpHeader * segment2 ; IpPseudoHeader pseudoHeader2 ; NetTxAncillary ancillary ; if ( segment -> flags & TCP_FLAG_ACK ) { flags = TCP_FLAG_RST ; seqNum = segment -> ackNum ; ackNum = 0 ; } else { flags = TCP_FLAG_RST | TCP_FLAG_ACK ; seqNum = 0 ; ackNum = segment -> seqNum + length ; if ( segment -> flags & TCP_FLAG_SYN )  ackNum ++ ;   if ( segment -> flags & TCP_FLAG_FIN )   ackNum ++ ;  } buffer = ipAllocBuffer ( sizeof ( TcpHeader ) , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; segment2 = netBufferAt ( buffer , offset ) ; segment2 -> srcPort = htons ( segment -> destPort ) ; segment2 -> destPort = htons ( segment -> srcPort ) ; segment2 -> seqNum = htonl ( seqNum ) ; segment2 -> ackNum = htonl ( ackNum ) ; segment2 -> reserved1 = 0 ; segment2 -> dataOffset = 5 ; segment2 -> flags = flags ; segment2 -> reserved2 = 0 ; segment2 -> window = 0 ; segment2 -> checksum = 0 ; segment2 -> urgentPointer = 0 ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader2 . ipv4Data . srcAddr = pseudoHeader -> ipv4Data . destAddr ; pseudoHeader2 . ipv4Data . destAddr = pseudoHeader -> ipv4Data . srcAddr ; pseudoHeader2 . ipv4Data . reserved = 0 ; pseudoHeader2 . ipv4Data . protocol = IPV4_PROTOCOL_TCP ; pseudoHeader2 . ipv4Data . length = HTONS ( sizeof ( TcpHeader ) ) ; segment2 -> checksum = ipCalcUpperLayerChecksumEx ( & pseudoHeader2 . ipv4Data , sizeof ( Ipv4PseudoHeader ) , buffer , offset , sizeof ( TcpHeader ) ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader2 . ipv6Data . srcAddr = pseudoHeader -> ipv6Data . destAddr ; pseudoHeader2 . ipv6Data . destAddr = pseudoHeader -> ipv6Data . srcAddr ; pseudoHeader2 . ipv6Data . length = HTONL ( sizeof ( TcpHeader ) ) ; pseudoHeader2 . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader2 . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader2 . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader2 . ipv6Data . nextHeader = IPV6_TCP_HEADER ; segment2 -> checksum = ipCalcUpperLayerChecksumEx ( & pseudoHeader2 . ipv6Data , sizeof ( Ipv6PseudoHeader ) , buffer , offset , sizeof ( TcpHeader ) ) ; } else # endif { netBufferFree ( buffer ) ; return ERROR_INVALID_ADDRESS ; } MIB2_INC_COUNTER32 ( tcpGroup . tcpOutSegs , 1 ) ; TCP_MIB_INC_COUNTER32 ( tcpOutSegs , 1 ) ; TCP_MIB_INC_COUNTER64 ( tcpHCOutSegs , 1 ) ; MIB2_INC_COUNTER32 ( tcpGroup . tcpOutRsts , 1 ) ; TCP_MIB_INC_COUNTER32 ( tcpOutRsts , 1 ) ; TRACE_DEBUG ( ""%s:SendingTCPresetsegment...\\r\\n"" , formatSystemTime ( osGetSystemTime ( ) , NULL ) ) ; tcpDumpHeader ( segment2 , length , 0 , 0 ) ; ancillary = NET_DEFAULT_TX_ANCILLARY ; error = ipSendDatagram ( interface , & pseudoHeader2 , buffer , offset , & ancillary ) ; netBufferFree ( buffer ) ; return error ; }", & TCP_FLAG_SYN ) {  ackNum ++ ; }  & TCP_FLAG_FIN ) {  ackNum ++ ; }
118,"CWE-362 static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) {  struct snd_timer_user * tu ;  void __user * argp = ( void __user * ) arg ; int __user * p = argp ; tu = file -> private_data ;  switch ( cmd ) {  case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ; case SNDRV_TIMER_IOCTL_NEXT_DEVICE : return snd_timer_user_next_device ( argp ) ; case SNDRV_TIMER_IOCTL_TREAD : { int xarg ;  mutex_lock ( & tu -> tread_sem ) ;  if ( tu -> timeri ) { mutex_unlock ( & tu -> tread_sem ) ; return - EBUSY ; } if ( get_user ( xarg , p ) ) { mutex_unlock ( & tu -> tread_sem ) ; return - EFAULT ; } tu -> tread = xarg ? 1 : 0 ;  mutex_unlock ( & tu -> tread_sem ) ;   return 0 ;  } case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ; case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ; case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ; case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ; case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ; case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ; case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ; case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ; case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop ( file ) ; case SNDRV_TIMER_IOCTL_CONTINUE : case SNDRV_TIMER_IOCTL_CONTINUE_OLD : return snd_timer_user_continue ( file ) ; case SNDRV_TIMER_IOCTL_PAUSE : case SNDRV_TIMER_IOCTL_PAUSE_OLD : return snd_timer_user_pause ( file ) ; } return - ENOTTY ; }"," snd_timer_user * tu  = file ->  -> private_data ; long ret  ; mutex_lock (  & tu -> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg )  ; mutex_unlock (  & tu -> ioctl_lock  ) ; return  ) ; return ret  ; } "
119,"CWE-119 void monitor_apply_keystate ( struct monitor * pmonitor ) { struct ssh * ssh = active_state ; struct kex * kex ; int r ; debug3 ( ""%s:packet_set_state"" , __func__ ) ; if ( ( r = ssh_packet_set_state ( ssh , child_state ) ) != 0 ) fatal ( ""%s:packet_set_state:%s"" , __func__ , ssh_err ( r ) ) ; sshbuf_free ( child_state ) ; child_state = NULL ; if ( ( kex = ssh -> kex ) != NULL ) { # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; }  if ( options . compression ) {  ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } }", sshd_hostkey_sign ; }  }  
120,"CWE-17 static void ndisc_router_discovery ( struct sk_buff * skb ) { struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; struct neighbour * neigh = NULL ; struct inet6_dev * in6_dev ; struct rt6_info * rt = NULL ; int lifetime ; struct ndisc_options ndopts ; int optlen ; unsigned int pref = 0 ; __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - sizeof ( struct ra_msg ) ; ND_PRINTK ( 2 , info , ""RA:%s,dev:%s\\n"" , __func__ , skb -> dev -> name ) ; if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { ND_PRINTK ( 2 , warn , ""RA:sourceaddressisnotlink-local\\n"" ) ; return ; } if ( optlen < 0 ) { ND_PRINTK ( 2 , warn , ""RA:packettooshort\\n"" ) ; return ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { ND_PRINTK ( 2 , warn , ""RA:fromhostorunauthorizedrouter\\n"" ) ; return ; } # endif in6_dev = __in6_dev_get ( skb -> dev ) ; if ( in6_dev == NULL ) { ND_PRINTK ( 0 , err , ""RA:can\'tfindinet6devicefor%s\\n"" , skb -> dev -> name ) ; return ; } if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { ND_PRINTK ( 2 , warn , ""RA:invalidNDoptions\\n"" ) ; return ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK ( 2 , info , ""RA:%s,didnotacceptrafordev:%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_linkparms ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { ND_PRINTK ( 2 , info , ""RA:%s,nodetypeisNODEFAULT,dev:%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_linkparms ; } # endif if ( in6_dev -> if_flags & IF_RS_SENT ) { in6_dev -> if_flags |= IF_RA_RCVD ; } in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ) ; if ( ! in6_dev -> cnf . accept_ra_defrtr ) { ND_PRINTK ( 2 , info , ""RA:%s,defrtrisfalsefordev:%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_defrtr ; } if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) { ND_PRINTK ( 2 , info , ""RAfromlocaladdressdetectedondev:%s:defaultrouterignored\\n"" , skb -> dev -> name ) ; goto skip_defrtr ; } lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ) ; # ifdef CONFIG_IPV6_ROUTER_PREF pref = ra_msg -> icmph . icmp6_router_pref ; if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref ) pref = ICMPV6_ROUTER_PREF_MEDIUM ; # endif rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ) ; if ( rt ) { neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; if ( ! neigh ) { ND_PRINTK ( 0 , err , ""RA:%sgotdefaultrouterwithoutneighbour\\n"" , __func__ ) ; ip6_rt_put ( rt ) ; return ; } } if ( rt && lifetime == 0 ) { ip6_del_rt ( rt ) ; rt = NULL ; } ND_PRINTK ( 3 , info , ""RA:rt:%plifetime:%d,fordev:%s\\n"" , rt , lifetime , skb -> dev -> name ) ; if ( rt == NULL && lifetime ) { ND_PRINTK ( 3 , info , ""RA:addingdefaultrouter\\n"" ) ; rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ) ; if ( rt == NULL ) { ND_PRINTK ( 0 , err , ""RA:%sfailedtoadddefaultroute\\n"" , __func__ ) ; return ; } neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; if ( neigh == NULL ) { ND_PRINTK ( 0 , err , ""RA:%sgotdefaultrouterwithoutneighbour\\n"" , __func__ ) ; ip6_rt_put ( rt ) ; return ; } neigh -> flags |= NTF_ROUTER ; } else if ( rt ) { rt -> rt6i_flags = ( rt -> rt6i_flags & ~ RTF_PREF_MASK ) | RTF_PREF ( pref ) ; } if ( rt ) rt6_set_expires ( rt , jiffies + ( HZ * lifetime ) ) ; if ( ra_msg -> icmph . icmp6_hop_limit ) {  in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;  if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ; } skip_defrtr : if ( in6_dev -> nd_parms ) { unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) { rtime = ( rtime * HZ ) / 1000 ; if ( rtime < HZ / 10 ) rtime = HZ / 10 ; NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ; in6_dev -> tstamp = jiffies ; inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; } rtime = ntohl ( ra_msg -> reachable_time ) ; if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) { rtime = ( rtime * HZ ) / 1000 ; if ( rtime < HZ / 10 ) rtime = HZ / 10 ; if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) { NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ; NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ; in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ; in6_dev -> tstamp = jiffies ; inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; } } } skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ; if ( neigh ) { u8 * lladdr = NULL ; if ( ndopts . nd_opts_src_lladdr ) { lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ; if ( ! lladdr ) { ND_PRINTK ( 2 , warn , ""RA:invalidlink-layeraddresslength\\n"" ) ; goto out ; } } neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK ( 2 , info , ""RA:%s,accept_raisfalsefordev:%s\\n"" , __func__ , skb -> dev -> name ) ; goto out ; } # ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) { ND_PRINTK ( 2 , info , ""RAfromlocaladdressdetectedondev:%s:routerinfoignored.\\n"" , skb -> dev -> name ) ; goto skip_routeinfo ; } if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_opts_ri ; p ; p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) { struct route_info * ri = ( struct route_info * ) p ; # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ; # endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ; if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ; rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ; } } skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { ND_PRINTK ( 2 , info , ""RA:%s,nodetypeisNODEFAULT(interiorroutes),dev:%s\\n"" , __func__ , skb -> dev -> name ) ; goto out ; } # endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_opts_pi ; p ; p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) { addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ; } } if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) { __be32 n ; u32 mtu ; memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ; mtu = ntohl ( n ) ; if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) { ND_PRINTK ( 2 , warn , ""RA:invalidmtu:%d\\n"" , mtu ) ; } else if ( in6_dev -> cnf . mtu6 != mtu ) { in6_dev -> cnf . mtu6 = mtu ; if ( rt ) dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ) ; rt6_mtu_change ( skb -> dev , mtu ) ; } } if ( ndopts . nd_useropts ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_useropts ; p ; p = ndisc_next_useropt ( p , ndopts . nd_useropts_end ) ) { ndisc_ra_useropt ( skb , p ) ; } } if ( ndopts . nd_opts_tgt_lladdr || ndopts . nd_opts_rh ) { ND_PRINTK ( 2 , warn , ""RA:invalidRAoptions\\n"" ) ; } out : ip6_rt_put ( rt ) ; if ( neigh ) neigh_release ( neigh ) ; }"," icmp6_hop_limit ) { if (  cnf . hop_limit <  ra_msg -> icmph  icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , ""RA:Gotrouteadvertisementwithlowerhop_limitthancurrent\\n"" ) ; }  if ( rt"
121,"CWE-119 int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v . val == 0 ) v . val = xchg ( & sk -> sk_err_soft , 0 ) ; break ; case SO_OOBINLINE : v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; break ; case SO_NO_CHECK : v . val = sk -> sk_no_check ; break ; case SO_PRIORITY : v . val = sk -> sk_priority ; break ; case SO_LINGER : lv = sizeof ( v . ling ) ; v . ling . l_onoff = ! ! sock_flag ( sk , SOCK_LINGER ) ; v . ling . l_linger = sk -> sk_lingertime / HZ ; break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""getsockopt"" ) ; break ; case SO_TIMESTAMP : v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPNS : v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPING : v . val = 0 ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_TX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_TX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_RX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_SYS_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RAW_HARDWARE ; break ; case SO_RCVTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_rcvtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_rcvtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_SNDTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_sndtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_sndtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_sndtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_RCVLOWAT : v . val = sk -> sk_rcvlowat ; break ; case SO_SNDLOWAT : v . val = 1 ; break ; case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERCRED : { struct ucred peercred ; if ( len > sizeof ( peercred ) ) len = sizeof ( peercred ) ; cred_to_ucred ( sk -> sk_peer_pid , sk -> sk_peer_cred , & peercred ) ; if ( copy_to_user ( optval , & peercred , len ) ) return - EFAULT ; goto lenout ; } case SO_PEERNAME : { char address [ 128 ] ; if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) ) return - ENOTCONN ; if ( lv < len ) return - EINVAL ; if ( copy_to_user ( optval , address , len ) ) return - EFAULT ; goto lenout ; } case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ; break ; case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;  break ; case SO_PEERSEC : return security_socket_getpeersec_stream ( sock , optval , optlen , len ) ; case SO_MARK : v . val = sk -> sk_mark ; break ; case SO_RXQ_OVFL : v . val = ! ! sock_flag ( sk , SOCK_RXQ_OVFL ) ; break ; case SO_WIFI_STATUS : v . val = ! ! sock_flag ( sk , SOCK_WIFI_STATUS ) ; break ; case SO_PEEK_OFF : if ( ! sock -> ops -> set_peek_off ) return - EOPNOTSUPP ; v . val = sk -> sk_peek_off ; break ; case SO_NOFCS : v . val = ! ! sock_flag ( sk , SOCK_NOFCS ) ; break ; default : return - ENOPROTOOPT ; } if ( len > lv ) len = lv ; if ( copy_to_user ( optval , & v , len ) ) return - EFAULT ; lenout : if ( put_user ( len , optlen ) ) return - EFAULT ; return 0 ; }", . val = ! !  -> flags )  ; break ;  . val = ! !  -> flags )  ; break ;
122,"CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ;  if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] )  return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }", attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
123,"CWE-362 static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) {  struct net * net = sock_net ( asoc -> base . sk ) ;  int error = 0 ;  bh_lock_sock ( asoc -> base . sk ) ;   if ( sock_owned_by_user ( asoc -> base . sk ) ) {  pr_debug ( ""%s:sockisbusy:timer%d\\n"" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error )  asoc -> base . sk -> sk_err = - error ;  out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;  sctp_association_put ( asoc ) ; }", ) { struct sock * sk = asoc -> base . sk ; struct  = sock_net (  sk ) ;  ; bh_lock_sock (  sk ) ;  ( sock_owned_by_user (  sk ) )  ( error )  sk -> sk_err  : bh_unlock_sock (  sk ) ;
124,"CWE-190 void *  xmalloc ( size_t size )   {   void * ptr = malloc ( size ) ;  if ( ! ptr && ( size != 0 ) ) { perror ( ""xmalloc:Memoryallocationfailure"" ) ; abort ( ) ; } return ptr ; }"," xmalloc ( size_t num , size_t  size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;  = malloc ( res  ) ; if"
125,CWE-119 void lzxd_free ( struct lzxd_stream * lzx ) { struct mspack_system * sys ; if ( lzx ) { sys = lzx -> sys ;  sys -> free ( lzx -> inbuf ) ;  sys -> free ( lzx -> window ) ; sys -> free ( lzx ) ; } }, -> sys ; if ( lzx -> inbuf )  inbuf ) ; if ( lzx -> window )
126,"CWE-400 struct sk_buff * * udp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb , struct udphdr * uh ) { struct udp_offload_priv * uo_priv ; struct sk_buff * p , * * pp = NULL ; struct udphdr * uh2 ; unsigned int off = skb_gro_offset ( skb ) ; int flush = 1 ;  if ( NAPI_GRO_CB ( skb ) -> udp_mark ||  ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ;  NAPI_GRO_CB ( skb ) -> udp_mark = 1 ;  rcu_read_lock ( ) ; uo_priv = rcu_dereference ( udp_offload_base ) ; for ( ; uo_priv != NULL ; uo_priv = rcu_dereference ( uo_priv -> next ) ) { if ( net_eq ( read_pnet ( & uo_priv -> net ) , dev_net ( skb -> dev ) ) && uo_priv -> offload -> port == uh -> dest && uo_priv -> offload -> callbacks . gro_receive ) goto unflush ; } goto out_unlock ; unflush : flush = 0 ; for ( p = * head ; p ; p = p -> next ) { if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; uh2 = ( struct udphdr * ) ( p -> data + off ) ; if ( ( * ( u32 * ) & uh -> source != * ( u32 * ) & uh2 -> source ) || ( ! uh -> check ^ ! uh2 -> check ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } skb_gro_pull ( skb , sizeof ( struct udphdr ) ) ; skb_gro_postpull_rcsum ( skb , uh , sizeof ( struct udphdr ) ) ; NAPI_GRO_CB ( skb ) -> proto = uo_priv -> offload -> ipproto ; pp = uo_priv -> offload -> callbacks . gro_receive ( head , skb , uo_priv -> offload ) ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }", skb ) -> encap_mark  || ( skb  skb ) -> encap_mark  = 1 ;
127,"CWE-119 static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) { MACROBLOCKD * xd = & x -> e_mbd ;  MB_PREDICTION_MODE mode ;  MB_PREDICTION_MODE mode_selected = DC_PRED ; int64_t best_rd = INT64_MAX , this_rd ; int this_rate_tokenonly , this_rate , s ;  int64_t this_distortion , this_sse ;  for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ; xd -> mi [ 0 ] -> mbmi . uv_mode = mode ;  super_block_uvrd ( cpi , x , & this_rate_tokenonly ,   & this_distortion , & s , & this_sse , bsize , best_rd ) ;  if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly +  x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ;  this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ;  if ( ! x -> select_txfm_size ) {  int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; for ( i = 1 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ; ctx -> coeff_pbuf [ i ] [ 2 ] = ctx -> coeff_pbuf [ i ] [ 0 ] ; ctx -> qcoeff_pbuf [ i ] [ 2 ] = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; ctx -> dqcoeff_pbuf [ i ] [ 2 ] = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; ctx -> eobs_pbuf [ i ] [ 2 ] = ctx -> eobs_pbuf [ i ] [ 0 ] ; ctx -> coeff_pbuf [ i ] [ 0 ] = p [ i ] . coeff ; ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ; ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ; ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ; } } } } xd -> mi [ 0 ] -> mbmi . uv_mode = mode_selected ; return best_rd ; }"," -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE  mode_selected = DC_PRED  this_distortion , this_sse ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) )  = mode ; if ( !  , best_rd )  ) continue ;  = this_rate_tokenonly + cpi  -> intra_uv_mode_cost [  ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ;  } } xd"
128,"CWE-125 int obj2ast_keyword ( PyObject * obj , keyword_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty value ;  if ( exists_not_none ( obj , & PyId_arg ) ) {  int res ;  tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ;  if ( tmp == NULL ) goto failed ;  res = obj2ast_identifier ( tmp , & arg , arena ) ;  if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ;  } else {  arg = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""value\\""missingfromkeyword"" ) ; return 1 ; } * out = keyword ( arg , value , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }"," ; if ( lookup_attr_id  ( obj ,  , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; arg = NULL ; } else  { int res  int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0  ) goto failed  goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""value\\""missingfromkeyword"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value  , arena )  ) ; }  * out ="
129,"CWE-416 static void sunkbd_enable ( struct sunkbd * sunkbd , bool enable ) { serio_pause_rx ( sunkbd -> serio ) ; sunkbd -> enabled = enable ; serio_continue_rx ( sunkbd -> serio ) ;  } ", serio ) ; if ( ! enable ) { wake_up_interruptible ( & sunkbd -> wait ) ; cancel_work_sync ( & sunkbd -> tq ) ; }
130,"CWE-20 static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ;  dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;  BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK && dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) set_bit ( IPS_ASSURED_BIT , & ct -> status ) ; break ; case CT_DCCP_IGNORE : if ( ct -> proto . dccp . last_dir == ! dir && ct -> proto . dccp . last_pkt == DCCP_PKT_REQUEST && type == DCCP_PKT_RESPONSE ) { ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; new_state = CT_DCCP_RESPOND ; break ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:invalidpacketignored"" ) ; return NF_ACCEPT ; case CT_DCCP_INVALID : spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:invalidstatetransition"" ) ; return - NF_ACCEPT ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; ct -> proto . dccp . state = new_state ; spin_unlock_bh ( & ct -> lock ) ; if ( new_state != old_state ) nf_conntrack_event_cache ( IPCT_PROTOINFO , ct ) ; nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; return NF_ACCEPT ; }"," ) , & _dh  ) ; BUG_ON"
131,"CWE-20  static int read_fragment_table ( long long * directory_table_end )  { int res , i ;  int bytes = SQUASHFS_FRAGMENT_BYTES ( sBlk . s . fragments ) ;   int indexes = SQUASHFS_FRAGMENT_INDEXES ( sBlk . s . fragments ) ;  long long fragment_table_index [ indexes ] ; TRACE ( ""read_fragment_table:%dfragments,reading%dfragmentindexes"" ""from0x%llx\\n"" , sBlk . s . fragments , indexes , sBlk . s . fragment_table_start ) ;  if ( sBlk . s . fragments == 0 ) {  * directory_table_end = sBlk . s . fragment_table_start ; return TRUE ; } fragment_table = malloc ( bytes ) ; if ( fragment_table == NULL ) EXIT_UNSQUASH ( ""read_fragment_table:failedtoallocate"" ""fragmenttable\\n"" ) ; res = read_fs_bytes ( fd , sBlk . s . fragment_table_start ,  SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk . s . fragments ) ,  fragment_table_index ) ; if ( res == FALSE ) { ERROR ( ""read_fragment_table:failedtoreadfragmenttable"" ""index\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_FRAGMENT_INDEXES ( fragment_table_index , indexes ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , fragment_table_index [ i ] , NULL , expected , ( ( char * ) fragment_table ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( ""Readfragmenttableblock%d,from0x%llx,length%d\\n"" , i , fragment_table_index [ i ] , length ) ; if ( length == FALSE ) { ERROR ( ""read_fragment_table:failedtoreadfragment"" ""tableindex\\n"" ) ; return FALSE ; } } for ( i = 0 ; i < sBlk . s . fragments ; i ++ ) SQUASHFS_INSWAP_FRAGMENT_ENTRY ( & fragment_table [ i ] ) ;  * directory_table_end = fragment_table_index [ 0 ] ;  return TRUE ; }"," long long * table_start  ) { int  , i ; long long  bytes = SQUASHFS_FRAGMENT_BYTES  = SQUASHFS_FRAGMENT_BYTES ( ( long long )  = SQUASHFS_FRAGMENT_INDEXES ( ( long long ) sBlk . s . fragments ) ; int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ; long long * fragment_table_index ; if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) { ERROR ( ""read_fragment_table:Badfragmentcountinsuperblock\\n"" ) ; return FALSE ; }  TRACE ( ""read_fragment_table:%dfragments,reading%dfragmentindexes""  fragment_table_start ) ; fragment_table_index = alloc_index_table ( indexes ) ;  fragment_table = malloc  . fragment_table_start , length  , fragment_table_index )  ) ; * table_start  = fragment_table_index ["
132,"CWE-000 static int ras_getcmap ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap ) { int i ; int j ; int x ; int c ; int numcolors ; int actualnumcolors ; switch ( hdr -> maptype ) { case RAS_MT_NONE : break ; case RAS_MT_EQUALRGB : { jas_eprintf ( ""warning:palettizedimagesnotfullysupported\\n"" ) ; numcolors = 1 << hdr -> depth ;  assert ( numcolors <= RAS_CMAP_MAXSIZ ) ;  actualnumcolors = hdr -> maplength / 3 ; for ( i = 0 ; i < numcolors ; i ++ ) { cmap -> data [ i ] = 0 ; } if ( ( hdr -> maplength % 3 ) || hdr -> maplength < 0 || hdr -> maplength > 3 * numcolors ) { return - 1 ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < actualnumcolors ; j ++ ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } x = 0 ; switch ( i ) { case 0 : x = RAS_RED ( c ) ; break ; case 1 : x = RAS_GREEN ( c ) ; break ; case 2 : x = RAS_BLUE ( c ) ; break ; } cmap -> data [ j ] |= x ; } } } break ; default : return - 1 ; break ; } return 0 ; }", -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; }  actualnumcolors = hdr
133,"CWE-000 static int efind ( name ) char * name ; { static char efbuf [ 100 ] ; my_regex_t re ;  sprintf ( efbuf , ""REG_%s"" , name ) ;  assert ( strlen ( efbuf ) < sizeof ( efbuf ) ) ; re . re_endp = efbuf ; ( void ) my_regerror ( REG_ATOI , & re , efbuf , sizeof ( efbuf ) ) ; return ( atoi ( efbuf ) ) ; }"," my_regex_t re ; snprintf ( efbuf , sizeof ( efbuf )  , ""REG_%s"" ,"
134,"CWE-191 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) {  dlen -= 2 ;  if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }", ) ) { if ( dlen < 2 ) break ;  dlen -= 2  ; * pt
135,"CWE-119 static __u8 * nci_extract_rf_params_nfcb_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) {  nfcb_poll -> sensb_res_len = * data ++ ;  pr_debug ( ""sensb_res_len%d\\n"" , nfcb_poll -> sensb_res_len ) ; memcpy ( nfcb_poll -> sensb_res , data , nfcb_poll -> sensb_res_len ) ; data += nfcb_poll -> sensb_res_len ; return data ; }"," -> sensb_res_len = min_t ( __u8 ,  * data ++ , NFC_SENSB_RES_MAXSIZE )"
136,"CWE-399 int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ;  unsigned int maxfraglen , fragheaderlen ;  int exthdrlen ; int dst_exthdrlen ;  int hh_len ;  int mtu ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; if ( rt -> dst . flags & DST_XFRM_TUNNEL ) mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; else mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; length += exthdrlen ; transhdrlen += exthdrlen ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) sock_tx_timestamp ( sk , & tx_flags ) ; cork -> length += length ; if ( length > mtu ) { int proto = sk -> sk_protocol ; if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } if ( proto == IPPROTO_UDP && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ; if ( err ) goto error ; return 0 ; } } if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen ,  fragheaderlen , skb , rt ) ;  skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> ip_summed = CHECKSUM_NONE ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; struct page_frag * pfrag = sk_page_frag ( sk ) ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }"," maxfraglen , fragheaderlen , mtu  ; int hh_len  ; int copy  skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE"
137,"CWE-665 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {  uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ;  unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( ""%sisnotavalid.CAFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( ""%s:can\'thandleversion%d.CAFfiles!"" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( ""%sisnotavalid.CAFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , ""desc"" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%sisnotavalid.CAFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; }  WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;  if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( ""format=%s,flags=%x,samplingrate=%g"" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( ""packet=%dbytesand%dframes"" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( ""channelsperframe=%d,bitsperchannel=%d"" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , ""lpcm"" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( ""%sisanunsupported.CAFformat!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""dataformat:32-bit%s-endianfloatingpoint"" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" ) ; else error_line ( ""dataformat:%d-bit%s-endianintegersstoredin%dbyte(s)"" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? ""big"" : ""little"" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""chan"" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( ""this.CAFfilehasaninvalid\'chan\'chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'chunkis%dbytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( ""%sisnotavalid.CAFfile!"" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( ""thisCAFfilealreadyhaschannelorderinformation!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( ""channeldescriptionsin\'chan\'chunkarethewrongsize!"" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( ""%dchanneldescriptionsismorethanwecanhandle...ignoring!"" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( ""chan%d-->%d"" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( ""warning:unknownchanneldescriptionslabel:%d"" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( ""layout_tag=0x%08x,sogeneratedbitmapof0x%08xfrom%ddescriptions,%dnon-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = ""12345678"" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( ""reorderingstring=\\""%s\\""\\n"" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( ""layout_tag=0x%08x,sousingsuppliedbitmapof0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( ""layout_tag0x%08xfoundintable,bitmap=0x%08x,reorder=%s,identities=%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag0x%08xnotfoundintable...allchannelsunassigned"" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) { uint32_t mEditCount ;  if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) ||  bcount != sizeof ( mEditCount ) ) { error_line ( ""%sisnotavalid.CAFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( "".CAFfile%shasover16MBofextraCAFFdata,probablyiscorrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( "".CAFfile%shasaninvaliddatachunksize,probablyiscorrupt!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( ""this.CAFfilehasnoaudiosamples,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%shastoomanysamplesforWavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%sisnotavalid.CAFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( ""problemwithsettingchannellayout(shouldnothappen)"" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }"," { uint32_t chan_chunk = 0 , desc_chunk  , CAFAudioFormatFormat ) ; desc_chunk = 1  if ( ! desc_chunk || !"
138,"CWE-119  static int cost_segmap ( int * segcounts , vp9_prob * probs ) {  const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ; const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ; const int c0123 = c01 + c23 ; const int c4567 = c45 + c67 ; int cost = c0123 * vp9_cost_zero ( probs [ 0 ] ) + c4567 * vp9_cost_one ( probs [ 0 ] ) ; if ( c0123 > 0 ) { cost += c01 * vp9_cost_zero ( probs [ 1 ] ) + c23 * vp9_cost_one ( probs [ 1 ] ) ; if ( c01 > 0 ) cost += segcounts [ 0 ] * vp9_cost_zero ( probs [ 3 ] ) + segcounts [ 1 ] * vp9_cost_one ( probs [ 3 ] ) ; if ( c23 > 0 ) cost += segcounts [ 2 ] * vp9_cost_zero ( probs [ 4 ] ) + segcounts [ 3 ] * vp9_cost_one ( probs [ 4 ] ) ; } if ( c4567 > 0 ) { cost += c45 * vp9_cost_zero ( probs [ 2 ] ) + c67 * vp9_cost_one ( probs [ 2 ] ) ; if ( c45 > 0 ) cost += segcounts [ 4 ] * vp9_cost_zero ( probs [ 5 ] ) + segcounts [ 5 ] * vp9_cost_one ( probs [ 5 ] ) ; if ( c67 > 0 ) cost += segcounts [ 6 ] * vp9_cost_zero ( probs [ 6 ] ) + segcounts [ 7 ] * vp9_cost_one ( probs [ 6 ] ) ; } return cost ; }"," * segcounts , vpx_prob  * probs )"
139,"CWE-119 static void accumulate_frame_motion_stats ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame , double * this_frame_mv_in_out , double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { double this_frame_mvr_ratio ; double this_frame_mvc_ratio ; double motion_pct ;  motion_pct = this_frame -> pcnt_motion ;  * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; if ( motion_pct > 0.05 ) { this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) ? ( this_frame_mvr_ratio * motion_pct ) : this_frame -> mvr_abs * motion_pct ; * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) ? ( this_frame_mvc_ratio * motion_pct ) : this_frame -> mvc_abs * motion_pct ; } }", double motion_pct ; ( void ) cpi ;
140,"CWE-120 static int try_read_command_binary ( conn * c ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { memcpy ( & c -> binary_header , c -> rcurr , sizeof ( c -> binary_header ) ) ; protocol_binary_request_header * req ; req = & c -> binary_header ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%dReadbinaryprotocoldata:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d"" , c -> sfd ) ; } fprintf ( stderr , ""0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalidmagic:%x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } uint8_t extlen = c -> binary_header . request . extlen ; uint16_t keylen = c -> binary_header . request . keylen ; if ( c -> rbytes < keylen + extlen + sizeof ( c -> binary_header ) ) { return 0 ; } if ( ! resp_start ( c ) ) { conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; c -> last_cmd_time = current_time ;  char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ;   memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ;  c -> rbytes -= sizeof ( c -> binary_header ) + extlen + keylen ; c -> rcurr += sizeof ( c -> binary_header ) + extlen + keylen ; dispatch_bin_command ( c , extbuf ) ; } return 1 ; }"," ) + BIN_MAX_EXTLEN + 1  binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN :"
141,"CWE-189 static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { long i ;  for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) {  long a = * ( long * ) ( src + i ) ; long b = * ( long * ) ( dst + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] += src [ i + 0 ] ; }", <= w - ( int )
142,CWE-119  void * H264SwDecMalloc ( u32 size )  {  return malloc ( size ) ;  }," ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; }  return malloc (  malloc ( size * num"
143,"CWE-835 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; }  offset = tbl -> indent ;  if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ;  }  if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }", INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ;  -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
144,"CWE-125 static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ;  ut32 len = sec -> payload_len ;  ut32 count = sec -> count ; ut32 i = 0 , r = 0 ;  while ( i < len && r < count ) {  if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) {  free ( ptr ) ;  return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) {  free ( ptr ) ;  return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) {  free ( ptr ) ;  return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i ) ) ) { free ( ptr ) ; return ret ; } } r_list_append ( ret , ptr ) ; r += 1 ; } return ret ;  } ", -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ;  i < len && len < buflen  ) ) { goto beach  ; } if  ) ) { goto beach  ; } if  ) ) { goto beach  ; } ut32  return ret ; beach : free ( ptr ) ; return ret ;
145,"CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ;  default :  errno = EINVAL ; return - 1 ; } }", return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
146,"CWE-416 static void nodeConstruct ( struct SaveNode * node , tr_variant const * v , bool sort_dicts ) { node -> isVisited = false ; node -> childIndex = 0 ; if ( sort_dicts && tr_variantIsDict ( v ) ) { size_t const n = v -> val . l . count ; struct KeyIndex * tmp = tr_new ( struct KeyIndex , n ) ; for ( size_t i = 0 ; i < n ; i ++ ) { tmp [ i ] . val = v -> val . l . vals + i ; tmp [ i ] . keystr = tr_quark_get_string ( tmp [ i ] . val -> key , NULL ) ; } qsort ( tmp , n , sizeof ( struct KeyIndex ) , compareKeyIndex ) ;  tr_variantInitDict ( & node -> sorted , n ) ;  for ( size_t i = 0 ; i < n ; ++ i ) {  node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ;  }  node -> sorted . val . l . count = n ;  tr_free ( tmp ) ;  node -> v = & node -> sorted ;  } else {  node -> v = v ;  } }"," compareKeyIndex ) ; node -> sorted = tr_new ( tr_variant , 1 ) ; tr_variantInitDict (  node -> sorted  node -> sorted ->  val . l  node -> sorted ->  val . l  tmp ) ; v =  node -> sorted  { node -> sorted = NULL ; } node -> v = v ;  }  "
147,"CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) {  Py_INCREF ( Py_None ) ;  return Py_None ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }", o ) { Py_RETURN_NONE  ; } result
148,"CWE-200 static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , buffer [ 257 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , buffer ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) buffer , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) buffer , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; if ( global_colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) { count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; if ( count != ( ssize_t ) ( 3 * global_colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } delay = 0 ; dispose = 0 ; duration = 0 ; iterations = 1 ; opacity = ( - 1 ) ; image_count = 0 ; meta_image = AcquireImage ( image_info , exception ) ; for ( ; ; ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) break ; if ( c == ( unsigned char ) ';' ) break ; if ( c == ( unsigned char ) '!' ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadExtensionBlock"" ) ; } switch ( c ) { case 0xf9 : { while ( ReadBlobBlock ( image , buffer ) != 0 ) ; dispose = ( size_t ) ( buffer [ 0 ] >> 2 ) ; delay = ( size_t ) ( ( buffer [ 2 ] << 8 ) | buffer [ 1 ] ) ; if ( ( ssize_t ) ( buffer [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) buffer [ 3 ] ; break ; } case 0xfe : { char * comments ; size_t length ; comments = AcquireString ( ( char * ) NULL ) ; for ( length = 0 ; ; length += count ) { count = ( ssize_t ) ReadBlobBlock ( image , buffer ) ; if ( count == 0 ) break ; buffer [ count ] = '\\0' ; ( void ) ConcatenateString ( & comments , ( const char * ) buffer ) ; } ( void ) SetImageProperty ( meta_image , ""comment"" , comments , exception ) ; comments = DestroyString ( comments ) ; break ; } case 0xff : { MagickBooleanType loop ; loop = MagickFalse ; if ( ReadBlobBlock ( image , buffer ) != 0 ) loop = LocaleNCompare ( ( char * ) buffer , ""NETSCAPE2.0"" , 11 ) == 0 ? MagickTrue : MagickFalse ; if ( loop != MagickFalse ) { while ( ReadBlobBlock ( image , buffer ) != 0 ) iterations = ( size_t ) ( ( buffer [ 2 ] << 8 ) | buffer [ 1 ] ) ; break ; } else { char name [ MagickPathExtent ] ; int block_length , info_length , reserved_length ; MagickBooleanType i8bim , icc , iptc , magick ; StringInfo * profile ; unsigned char * info ; icc = LocaleNCompare ( ( char * ) buffer , ""ICCRGBG1012"" , 11 ) == 0 ? MagickTrue : MagickFalse ; magick = LocaleNCompare ( ( char * ) buffer , ""ImageMagick"" , 11 ) == 0 ? MagickTrue : MagickFalse ; i8bim = LocaleNCompare ( ( char * ) buffer , ""MGK8BIM0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; iptc = LocaleNCompare ( ( char * ) buffer , ""MGKIPTC0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; number_extensionss ++ ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""ReadingGIFapplicationextension"" ) ; info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) { meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } reserved_length = 255 ; for ( info_length = 0 ; ; ) { block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; if ( block_length == 0 ) break ; info_length += block_length ; if ( info_length > ( reserved_length - 255 ) ) { reserved_length += 4096 ; info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) { meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } } profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; if ( profile == ( StringInfo * ) NULL ) { meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , ""8bim"" , sizeof ( name ) ) ; else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , ""icc"" , sizeof ( name ) ) ; else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , ""iptc"" , sizeof ( name ) ) ; else if ( magick != MagickFalse ) { ( void ) CopyMagickString ( name , ""magick"" , sizeof ( name ) ) ; meta_image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ; } else ( void ) FormatLocaleString ( name , sizeof ( name ) , ""gif:%.11s"" , buffer ) ; info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""profilename=%s"" , name ) ; } break ; } default : { while ( ReadBlobBlock ( image , buffer ) != 0 ) ; break ; } } } if ( c != ( unsigned char ) ',' ) continue ; if ( image_count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } image_count ++ ; meta_image -> scene = image -> scene ; ( void ) CloneImageProperties ( image , meta_image ) ; DestroyImageProperties ( meta_image ) ; ( void ) CloneImageProfiles ( image , meta_image ) ; DestroyImageProfiles ( meta_image ) ; image -> storage_class = PseudoClass ; image -> compression = LZWCompression ; page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> depth = 8 ; flag = ( unsigned char ) ReadBlobByte ( image ) ; image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ; if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ; image -> page . width = page . width ; image -> page . height = page . height ; image -> page . y = page . y ; image -> page . x = page . x ; image -> delay = delay ; image -> ticks_per_second = 100 ; image -> dispose = ( DisposeType ) dispose ; image -> iterations = iterations ; image -> alpha_trait = opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait ; delay = 0 ; dispose = 0 ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) { p = global_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ( double ) ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) { image -> colormap [ i ] . alpha = ( double ) TransparentAlpha ; image -> transparent_color = image -> colormap [ opacity ] ; } } image -> background_color = image -> colormap [ MagickMin ( ( ssize_t ) background , ( ssize_t ) image -> colors - 1 ) ] ; } else { unsigned char * colormap ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; if ( count != ( ssize_t ) ( 3 * image -> colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( double ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ( double ) ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) image -> colormap [ i ] . alpha = ( double ) TransparentAlpha ; } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } if ( image -> gamma == 1.0 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( IsPixelInfoGray ( image -> colormap + i ) == MagickFalse ) break ; ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace , exception ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image , exception ) ; else status = DecodeImage ( image , opacity , exception ) ; if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; meta_image = DestroyImage ( meta_image ) ; ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } duration += image -> delay * image -> iterations ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; opacity = ( - 1 ) ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } image -> duration = duration ; meta_image = DestroyImage ( meta_image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )"
149,"CWE-200 static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( """" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ;  dl = kmalloc ( size , GFP_KERNEL ) ;  if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - EFAULT : 0 ; }"," ; dl = kzalloc  ( size ,"
150,"CWE-264 static void otp_verify ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * pa , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_keyblock * armor_key = NULL ; krb5_pa_otp_req * req = NULL ; struct request_state * rs ; krb5_error_code retval ; krb5_data d , plaintext ; char * config ;  enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;  armor_key = cb -> fast_armor ( context , rock ) ; if ( armor_key == NULL ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; com_err ( ""otp"" , retval , ""Noarmorkeyfoundwhenverifyingpadata"" ) ; goto error ; } d = make_data ( pa -> contents , pa -> length ) ; retval = decode_krb5_pa_otp_req ( & d , & req ) ; if ( retval != 0 ) { com_err ( ""otp"" , retval , ""UnabletodecodeOTPrequest"" ) ; goto error ; } retval = decrypt_encdata ( context , armor_key , req , & plaintext ) ; if ( retval != 0 ) { com_err ( ""otp"" , retval , ""Unabletodecryptnonce"" ) ; goto error ; } retval = nonce_verify ( context , armor_key , & plaintext ) ; if ( retval != 0 ) retval = timestamp_verify ( context , & plaintext ) ; krb5_free_data_contents ( context , & plaintext ) ; if ( retval != 0 ) { com_err ( ""otp"" , retval , ""Unabletoverifynonceortimestamp"" ) ; goto error ; } rs = k5alloc ( sizeof ( struct request_state ) , & retval ) ; if ( rs == NULL ) goto error ; rs -> arg = arg ;  rs -> respond = respond ;  retval = cb -> get_string ( context , rock , ""otp"" , & config ) ; if ( retval == 0 && config == NULL ) retval = KRB5_PREAUTH_FAILED ; if ( retval != 0 ) { free ( rs ) ; goto error ; } otp_state_verify ( ( otp_state * ) moddata , cb -> event_context ( context , rock ) , request -> client , config , req , on_response , rs ) ; cb -> free_string ( context , rock , config ) ; k5_free_pa_otp_req ( context , req ) ; return ; error : k5_free_pa_otp_req ( context , req ) ; ( * respond ) ( arg , retval , NULL , NULL , NULL ) ; }", * config ;  armor_key = cb  respond = respond ; rs -> enc_tkt_reply = enc_tkt_reply
151,"CWE-119  void  byteSwap ( UWORD32 * buf , unsigned words ) { md5byte * p ; int i = 1 ; if ( * ( char * ) & i == 1 ) return ; p = ( md5byte * ) buf ; do { * buf ++ = ( UWORD32 ) ( ( unsigned ) p [ 3 ] << 8 | p [ 2 ] ) << 16 | ( ( unsigned ) p [ 1 ] << 8 | p [ 0 ] ) ; p += 4 ; } while ( -- words ) ; }",    static
152,"CWE-120 uint8_t ethereum_extractThorchainData ( const EthereumSignTx * msg , char * buffer ) { uint16_t offset = 4 + ( 5 * 32 ) ; int16_t len = msg -> data_length - offset ;  if ( msg -> has_data_length && len > 0 ) {  memcpy ( buffer , msg -> data_initial_chunk . bytes + offset , len ) ;  return len < 256 ? ( uint8_t ) len : 0 ;  } return 0 ; }", len > 0 && len < 256  ) ; return  ( uint8_t )  uint8_t ) len  ; } return
153,"CWE-284 static MYSQL * db_connect ( char * host , char * database , char * user , char * passwd ) { MYSQL * mysql ; if ( verbose ) fprintf ( stdout , ""Connectingto%s\\n"" , host ? host : ""localhost"" ) ; if ( ! ( mysql = mysql_init ( NULL ) ) ) return 0 ; if ( opt_compress ) mysql_options ( mysql , MYSQL_OPT_COMPRESS , NullS ) ; if ( opt_local_file ) mysql_options ( mysql , MYSQL_OPT_LOCAL_INFILE , ( char * ) & opt_local_file ) ;  # ifdef HAVE_OPENSSL  if ( opt_use_ssl ) { mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( mysql , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlimport"" ) ; if ( ! ( mysql_real_connect ( mysql , host , user , passwd , database , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { ignore_errors = 0 ; db_error ( mysql ) ; } mysql -> reconnect = 0 ; if ( verbose ) fprintf ( stdout , ""Selectingdatabase%s\\n"" , database ) ; if ( mysql_select_db ( mysql , database ) ) { ignore_errors = 0 ; db_error ( mysql ) ; } return mysql ; }", opt_local_file ) ; SSL_SET_OPTIONS ( mysql ) ;  if ( opt_protocol
154,"CWE-190 static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) { struct iso9660 * iso9660 ; struct isoent * np ; unsigned char * p ; size_t l ; int r ;  int ffmax , parent_len ;  static const struct archive_rb_tree_ops rb_ops = { isoent_cmp_node_joliet , isoent_cmp_key_joliet } ; if ( isoent -> children . cnt == 0 ) return ( 0 ) ; iso9660 = a -> format_data ; if ( iso9660 -> opt . joliet == OPT_JOLIET_LONGNAME ) ffmax = 206 ; else ffmax = 128 ;  r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ;  if ( r < 0 ) return ( r ) ; parent_len = 1 ; for ( np = isoent ; np -> parent != np ; np = np -> parent ) parent_len += np -> mb_len + 1 ; for ( np = isoent -> children . first ; np != NULL ; np = np -> chnext ) { unsigned char * dot ; int ext_off , noff , weight ; size_t lt ;  if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax )  l = ffmax ; p = malloc ( ( l + 1 ) * 2 ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'tallocatememory"" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( p , np -> file -> basename_utf16 . s , l ) ; p [ l ] = 0 ; p [ l + 1 ] = 0 ; np -> identifier = ( char * ) p ; lt = l ; dot = p + l ; weight = 0 ; while ( lt > 0 ) { if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ; else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ; p += 2 ; lt -= 2 ; } ext_off = ( int ) ( dot - ( unsigned char * ) np -> identifier ) ; np -> ext_off = ext_off ; np -> ext_len = ( int ) l - ext_off ; np -> id_len = ( int ) l ;  if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) {  if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) { archive_set_error ( & a -> archive , errno , ""Nomemory"" ) ; return ( ARCHIVE_FATAL ) ; } np -> mb_len = ( int ) iso9660 -> mbs . length ; if ( np -> mb_len != ( int ) np -> file -> basename . length ) weight = np -> mb_len ; } else np -> mb_len = ( int ) np -> file -> basename . length ;  if ( parent_len + np -> mb_len > 240 ) {  archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""TheregulationofJolietextensions;"" ""Alengthofafull-pathnameof`%s\'is"" ""longerthan240bytes,(p=%d,b=%d)"" , archive_entry_pathname ( np -> file -> entry ) , ( int ) parent_len , ( int ) np -> mb_len ) ; return ( ARCHIVE_FATAL ) ; }  if ( ( int ) l == ffmax )  noff = ext_off - 6 ;  else if ( ( int ) l == ffmax - 2 )  noff = ext_off - 4 ;  else if ( ( int ) l == ffmax - 4 )  noff = ext_off - 2 ; else noff = ext_off ; idr_register ( idr , np , weight , noff ) ; } idr_resolve ( idr , idr_set_num_beutf16 ) ; return ( ARCHIVE_OK ) ; }"," int r ; size_t  ffmax , parent_len  . cnt , ( int )  if ( (  l = np  ; if (  np -> file  if ( parent_len > 240 ||  np -> mb_len  mb_len > 240 || parent_len + np -> mb_len > 240  } if (  l == ffmax  else if (  l == ffmax  else if (  l == ffmax"
155,"CWE-119 int vp8_set_active_map ( VP8_COMP * cpi , unsigned char * map , unsigned int rows , unsigned int cols ) { if ( rows == cpi -> common . mb_rows && cols == cpi -> common . mb_cols ) { if ( map ) {  vpx_memcpy ( cpi -> active_map , map , rows * cols ) ;  cpi -> active_map_enabled = 1 ; } else cpi -> active_map_enabled = 0 ; return 0 ; } else { return - 1 ; } }", map ) { memcpy  ( cpi ->
156,"CWE-400 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) {  bool disconnect ;  p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ;  __touch_mnt_namespace ( p -> mnt_ns ) ;  p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = disconnect_mount ( p , how ) ; pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; } }", ) ) { struct mnt_namespace * ns ;  mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; }  p -> mnt_ns
157,"CWE-119  static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  { struct bitmap * base = data ; bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ; mark_as_seen ( object ) ; }"," * object ,  const char *  const char * name  , void *"
158,"CWE-119 static void tree_to_node ( void * data , BLOCK_SIZE bsize , variance_node * node ) { int i ;  switch ( bsize ) {  case BLOCK_64X64 : { v64x64 * vt = ( v64x64 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_32X32 : { v32x32 * vt = ( v32x32 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_16X16 : { v16x16 * vt = ( v16x16 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_8X8 : { v8x8 * vt = ( v8x8 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ )  node -> split [ i ] = & vt -> split [ i ] ;  break ; } default : { assert ( 0 ) ;  }  } }", int i ; node -> part_variances = NULL ;  [ i ] . part_variances . none ; break ; } case BLOCK_4X4 : { v4x4 * vt = ( v4x4 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ]  0 ) ; break ;
159,CWE-264 int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool :  case NPNVSupportsWindowless :  type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }, : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling
160,"CWE-119 static void copy_and_extend_plane ( const uint8_t * src , int src_pitch , uint8_t * dst , int dst_pitch , int w , int h , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i , linesize ; const uint8_t * src_ptr1 = src ; const uint8_t * src_ptr2 = src + w - 1 ; uint8_t * dst_ptr1 = dst - extend_left ; uint8_t * dst_ptr2 = dst + w ; for ( i = 0 ; i < h ; i ++ ) {  vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ;   vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ;  vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; src_ptr1 += src_pitch ; src_ptr2 += src_pitch ; dst_ptr1 += dst_pitch ; dst_ptr2 += dst_pitch ; } src_ptr1 = dst - extend_left ; src_ptr2 = dst + dst_pitch * ( h - 1 ) - extend_left ; dst_ptr1 = dst + dst_pitch * ( - extend_top ) - extend_left ; dst_ptr2 = dst + dst_pitch * ( h ) - extend_left ; linesize = extend_left + extend_right + w ; for ( i = 0 ; i < extend_top ; i ++ ) {  vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ;  dst_ptr1 += dst_pitch ; } for ( i = 0 ; i < extend_bottom ; i ++ ) {  vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ;  dst_ptr2 += dst_pitch ; } }"," ++ ) { memset  ( dst_ptr1 ,  extend_left ) ; memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; memset  ( dst_ptr2 ,  ++ ) { memcpy  ( dst_ptr1 ,  ++ ) { memcpy  ( dst_ptr2 ,"
161,"CWE-476 RCMS * r_pkcs7_parse_cms ( const ut8 * buffer , ut32 length ) { RASN1Object * object ; RCMS * container ; if ( ! buffer || ! length ) { return NULL ; } container = R_NEW0 ( RCMS ) ; if ( ! container ) { return NULL ; } object = r_asn1_create_object ( buffer , length ) ;  if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) {  r_asn1_free_object ( object ) ; free ( container ) ; return NULL ; } container -> contentType = r_asn1_stringify_oid ( object -> list . objects [ 0 ] -> sector , object -> list . objects [ 0 ] -> length ) ; r_pkcs7_parse_signeddata ( & container -> signedData , object -> list . objects [ 1 ] -> list . objects [ 0 ] ) ; r_asn1_free_object ( object ) ; return container ; }", list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] ||  object -> list
162,"CWE-200 static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; struct sk_buff * skb ; size_t copied ; int err ; if ( flags & MSG_OOB )  return - EOPNOTSUPP ;  if ( addr_len ) * addr_len = sizeof ( * sin6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } if ( skb_csum_unnecessary ( skb ) ) { err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else if ( msg -> msg_flags & MSG_TRUNC ) { if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else { err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( err ) goto out_free ; if ( sin6 ) { sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_flowinfo = 0 ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;  } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = skb -> len ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; csum_copy_err : skb_kill_datagram ( sk , skb , flags ) ; err = ( flags & MSG_DONTWAIT ) ? - EAGAIN : - EHOSTUNREACH ; goto out ; }", return - EOPNOTSUPP  ; if (  ) -> iif ) ; * addr_len = sizeof ( * sin6
163,"CWE-20 error_t dm9000ReceivePacket ( NetInterface * interface ) { error_t error ; size_t i ; size_t n ; size_t length ; volatile uint8_t status ; volatile uint16_t data ; Dm9000Context * context ; context = ( Dm9000Context * ) interface -> nicContext ;  data = dm9000ReadReg ( DM9000_REG_MRCMDX ) ;   DM9000_INDEX_REG = DM9000_REG_MRCMDX1 ;  status = LSB ( DM9000_DATA_REG ) ; if ( status == 0x01 ) {  DM9000_INDEX_REG = DM9000_REG_MRCMD ;  status = MSB ( DM9000_DATA_REG ) ; length = DM9000_DATA_REG ; n = MIN ( length , ETH_MAX_FRAME_SIZE ) ; i = 0 ;  if ( ( status & ( RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE ) ) == 0 )  { while ( ( i + 1 ) < n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ++ ] = LSB ( data ) ; context -> rxBuffer [ i ++ ] = MSB ( data ) ; } if ( ( i + 1 ) == n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ] = LSB ( data ) ; i += 2 ; } error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } while ( i < length ) { data = DM9000_DATA_REG ; i += 2 ; } } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; } return error ; }", = dm9000ReadReg ( DM9000_MRCMDX  ) ; DM9000_INDEX_REG  ; DM9000_INDEX_REG = DM9000_MRCMDX1  ; status =  { DM9000_INDEX_REG = DM9000_MRCMD  ; status =  status & ( DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE  ) ) ==
164,"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ;  if ( nposargs + nkwonlyargs > 255 ) {  ast_error ( c , n , ""morethan255arguments"" ) ; return NULL ; } i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-defaultargumentfollowsdefaultargument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ;  if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""namedargumentsmustfollowbare*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ;  if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {  ast_error ( c , CHILD ( n , i ) , ""bare*hasassociatedtypecomment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ;  if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;  if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {  vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ;  if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpectednodeinvarargslist:%d@%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }", return NULL ;  i = 0  ; if (  TYPE ( CHILD  ; if (  TYPE ( CHILD  ; if (  TYPE ( CHILD  ; if (  TYPE ( CHILD  ; if (  TYPE ( CHILD
165,"CWE-120 SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) {  return SECURE_ELEMENT_ERROR_NPE ;  } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } memcpy1 ( decJoinAccept , encJoinAccept , encJoinAcceptSize ) ; if ( SecureElementAesEncrypt ( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE , encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE , encKeyID , decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_ENCRYPT ; } * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; uint32_t mic = 0 ; mic = ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ] << 0 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1 ] << 8 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2 ] << 16 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3 ] << 24 ) ; if ( * versionMinor == 0 ) { if ( SecureElementVerifyAesCmac ( decJoinAccept , ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ) , mic , NWK_KEY ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_CMAC ; } } # if ( USE_LRWAN_1_1_X_CRYPTO == 1 ) else if ( * versionMinor == 1 ) { uint8_t micHeader11 [ JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; uint16_t bufItr = 0 ; micHeader11 [ bufItr ++ ] = ( uint8_t ) joinReqType ; memcpyr ( micHeader11 + bufItr , joinEui , LORAMAC_JOIN_EUI_FIELD_SIZE ) ; bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE ; micHeader11 [ bufItr ++ ] = devNonce & 0xFF ; micHeader11 [ bufItr ++ ] = ( devNonce >> 8 ) & 0xFF ; uint8_t localBuffer [ LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; memcpy1 ( localBuffer , micHeader11 , JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ) ; memcpy1 ( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1 , decJoinAccept , encJoinAcceptSize ) ; if ( SecureElementVerifyAesCmac ( localBuffer , encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE , mic , J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_CMAC ; } } # endif else { return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION ; } return SECURE_ELEMENT_SUCCESS ; }", { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
166,"CWE-125 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( ""nfnetlink-subsys-%d"" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ;  if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ||  skb -> len < nlh -> nlmsg_len ) { err = - EINVAL ; goto ack ; } if ( ! ( nlh -> nlmsg_flags & NLM_F_REQUEST ) ) { err = - EINVAL ; goto ack ; } type = nlh -> nlmsg_type ; if ( type == NFNL_MSG_BATCH_BEGIN ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } else if ( type == NFNL_MSG_BATCH_END ) { status |= NFNL_BATCH_DONE ; goto done ; } else if ( type < NLMSG_MIN_TYPE ) { err = - EINVAL ; goto ack ; } if ( NFNL_SUBSYS_ID ( type ) != subsys_id ) { err = - EINVAL ; goto ack ; } nc = nfnetlink_find_client ( type , ss ) ; if ( ! nc ) { err = - EINVAL ; goto ack ; } { int min_len = nlmsg_total_size ( sizeof ( struct nfgenmsg ) ) ; u_int8_t cb_id = NFNL_MSG_TYPE ( nlh -> nlmsg_type ) ; struct nlattr * cda [ ss -> cb [ cb_id ] . attr_count + 1 ] ; struct nlattr * attr = ( void * ) nlh + min_len ; int attrlen = nlh -> nlmsg_len - min_len ; err = nla_parse ( cda , ss -> cb [ cb_id ] . attr_count , attr , attrlen , ss -> cb [ cb_id ] . policy ) ; if ( err < 0 ) goto ack ; if ( nc -> call_batch ) { err = nc -> call_batch ( net , net -> nfnl , skb , nlh , ( const struct nlattr * * ) cda ) ; } if ( err == - EAGAIN ) { status |= NFNL_BATCH_REPLAY ; goto next ; } } ack : if ( nlh -> nlmsg_flags & NLM_F_ACK || err ) { if ( nfnl_err_add ( & err_list , nlh , err ) < 0 ) { nfnl_err_reset ( & err_list ) ; netlink_ack ( oskb , nlmsg_hdr ( oskb ) , - ENOMEM ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } if ( err ) status |= NFNL_BATCH_FAILURE ; } next : msglen = NLMSG_ALIGN ( nlh -> nlmsg_len ) ; if ( msglen > skb -> len ) msglen = skb -> len ; skb_pull ( skb , msglen ) ; } done : if ( status & NFNL_BATCH_REPLAY ) { ss -> abort ( net , oskb ) ; nfnl_err_reset ( & err_list ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; goto replay ; } else if ( status == NFNL_BATCH_DONE ) { ss -> commit ( net , oskb ) ; } else { ss -> abort ( net , oskb ) ; } nfnl_err_deliver ( & err_list , oskb ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; }", ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len ||  struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done  ; } if
167,"CWE-125 int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unabletogetBOSdescriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unabletogetBOSdescriptorset\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ;  length = cap -> bLength ;  if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptortypeinvalid,skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }", ) buffer ; if ( total_len < sizeof ( * cap ) || total_len <  cap -> bLength  cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength  ; total_len -=
168,"CWE-399 static int ape_read_header ( AVFormatContext * s , AVFormatParameters * ap ) { AVIOContext * pb = s -> pb ; APEContext * ape = s -> priv_data ; AVStream * st ; uint32_t tag ; int i ; int total_blocks ; int64_t pts ; ape -> junklength = 0 ; tag = avio_rl32 ( pb ) ; if ( tag != MKTAG ( 'M' , 'A' , 'C' , '' ) ) return - 1 ; ape -> fileversion = avio_rl16 ( pb ) ; if ( ape -> fileversion < APE_MIN_VERSION || ape -> fileversion > APE_MAX_VERSION ) { av_log ( s , AV_LOG_ERROR , ""Unsupportedfileversion-%d.%02d\\n"" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 ) ; return - 1 ; } if ( ape -> fileversion >= 3980 ) { ape -> padding1 = avio_rl16 ( pb ) ; ape -> descriptorlength = avio_rl32 ( pb ) ; ape -> headerlength = avio_rl32 ( pb ) ; ape -> seektablelength = avio_rl32 ( pb ) ; ape -> wavheaderlength = avio_rl32 ( pb ) ; ape -> audiodatalength = avio_rl32 ( pb ) ; ape -> audiodatalength_high = avio_rl32 ( pb ) ; ape -> wavtaillength = avio_rl32 ( pb ) ; avio_read ( pb , ape -> md5 , 16 ) ; if ( ape -> descriptorlength > 52 ) avio_seek ( pb , ape -> descriptorlength - 52 , SEEK_CUR ) ; ape -> compressiontype = avio_rl16 ( pb ) ; ape -> formatflags = avio_rl16 ( pb ) ; ape -> blocksperframe = avio_rl32 ( pb ) ; ape -> finalframeblocks = avio_rl32 ( pb ) ; ape -> totalframes = avio_rl32 ( pb ) ; ape -> bps = avio_rl16 ( pb ) ; ape -> channels = avio_rl16 ( pb ) ; ape -> samplerate = avio_rl32 ( pb ) ; } else { ape -> descriptorlength = 0 ; ape -> headerlength = 32 ; ape -> compressiontype = avio_rl16 ( pb ) ; ape -> formatflags = avio_rl16 ( pb ) ; ape -> channels = avio_rl16 ( pb ) ; ape -> samplerate = avio_rl32 ( pb ) ; ape -> wavheaderlength = avio_rl32 ( pb ) ; ape -> wavtaillength = avio_rl32 ( pb ) ; ape -> totalframes = avio_rl32 ( pb ) ; ape -> finalframeblocks = avio_rl32 ( pb ) ; if ( ape -> formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL ) { avio_seek ( pb , 4 , SEEK_CUR ) ; ape -> headerlength += 4 ; } if ( ape -> formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS ) { ape -> seektablelength = avio_rl32 ( pb ) ; ape -> headerlength += 4 ; ape -> seektablelength *= sizeof ( int32_t ) ; } else ape -> seektablelength = ape -> totalframes * sizeof ( int32_t ) ; if ( ape -> formatflags & MAC_FORMAT_FLAG_8_BIT ) ape -> bps = 8 ; else if ( ape -> formatflags & MAC_FORMAT_FLAG_24_BIT ) ape -> bps = 24 ; else ape -> bps = 16 ; if ( ape -> fileversion >= 3950 ) ape -> blocksperframe = 73728 * 4 ; else if ( ape -> fileversion >= 3900 || ( ape -> fileversion >= 3800 && ape -> compressiontype >= 4000 ) ) ape -> blocksperframe = 73728 ; else ape -> blocksperframe = 9216 ; if ( ! ( ape -> formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER ) ) avio_seek ( pb , ape -> wavheaderlength , SEEK_CUR ) ; }  if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) {  av_log ( s , AV_LOG_ERROR , ""Toomanyframes:%d\\n"" , ape -> totalframes ) ; return - 1 ; } ape -> frames = av_malloc ( ape -> totalframes * sizeof ( APEFrame ) ) ; if ( ! ape -> frames ) return AVERROR ( ENOMEM ) ; ape -> firstframe = ape -> junklength + ape -> descriptorlength + ape -> headerlength + ape -> seektablelength + ape -> wavheaderlength ; ape -> currentframe = 0 ; ape -> totalsamples = ape -> finalframeblocks ; if ( ape -> totalframes > 1 ) ape -> totalsamples += ape -> blocksperframe * ( ape -> totalframes - 1 ) ; if ( ape -> seektablelength > 0 ) { ape -> seektable = av_malloc ( ape -> seektablelength ) ; for ( i = 0 ; i < ape -> seektablelength / sizeof ( uint32_t ) ; i ++ ) ape -> seektable [ i ] = avio_rl32 ( pb ) ; } ape -> frames [ 0 ] . pos = ape -> firstframe ; ape -> frames [ 0 ] . nblocks = ape -> blocksperframe ; ape -> frames [ 0 ] . skip = 0 ; for ( i = 1 ; i < ape -> totalframes ; i ++ ) { ape -> frames [ i ] . pos = ape -> seektable [ i ] ; ape -> frames [ i ] . nblocks = ape -> blocksperframe ; ape -> frames [ i - 1 ] . size = ape -> frames [ i ] . pos - ape -> frames [ i - 1 ] . pos ; ape -> frames [ i ] . skip = ( ape -> frames [ i ] . pos - ape -> frames [ 0 ] . pos ) & 3 ; } ape -> frames [ ape -> totalframes - 1 ] . size = ape -> finalframeblocks * 4 ; ape -> frames [ ape -> totalframes - 1 ] . nblocks = ape -> finalframeblocks ; for ( i = 0 ; i < ape -> totalframes ; i ++ ) { if ( ape -> frames [ i ] . skip ) { ape -> frames [ i ] . pos -= ape -> frames [ i ] . skip ; ape -> frames [ i ] . size += ape -> frames [ i ] . skip ; } ape -> frames [ i ] . size = ( ape -> frames [ i ] . size + 3 ) & ~ 3 ; } ape_dumpinfo ( s , ape ) ; if ( ! url_is_streamed ( pb ) ) { ff_ape_parse_tag ( s ) ; avio_seek ( pb , 0 , SEEK_SET ) ; } av_log ( s , AV_LOG_DEBUG , ""Decodingfile-v%d.%02d,compressionlevel%d\\n"" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 , ape -> compressiontype ) ; st = av_new_stream ( s , 0 ) ; if ( ! st ) return - 1 ; total_blocks = ( ape -> totalframes == 0 ) ? 0 : ( ( ape -> totalframes - 1 ) * ape -> blocksperframe ) + ape -> finalframeblocks ; st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codec -> codec_id = CODEC_ID_APE ; st -> codec -> codec_tag = MKTAG ( 'A' , 'P' , 'E' , '' ) ; st -> codec -> channels = ape -> channels ; st -> codec -> sample_rate = ape -> samplerate ; st -> codec -> bits_per_coded_sample = ape -> bps ; st -> codec -> frame_size = MAC_SUBFRAME_SIZE ; st -> nb_frames = ape -> totalframes ; st -> start_time = 0 ; st -> duration = total_blocks / MAC_SUBFRAME_SIZE ; av_set_pts_info ( st , 64 , MAC_SUBFRAME_SIZE , ape -> samplerate ) ; st -> codec -> extradata = av_malloc ( APE_EXTRADATA_SIZE ) ; st -> codec -> extradata_size = APE_EXTRADATA_SIZE ; AV_WL16 ( st -> codec -> extradata + 0 , ape -> fileversion ) ; AV_WL16 ( st -> codec -> extradata + 2 , ape -> compressiontype ) ; AV_WL16 ( st -> codec -> extradata + 4 , ape -> formatflags ) ; pts = 0 ; for ( i = 0 ; i < ape -> totalframes ; i ++ ) { ape -> frames [ i ] . pts = pts ; av_add_index_entry ( st , ape -> frames [ i ] . pos , ape -> frames [ i ] . pts , 0 , 0 , AVINDEX_KEYFRAME ) ; pts += ape -> blocksperframe / MAC_SUBFRAME_SIZE ; } return 0 ; }"," } if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , ""Noframesinthefile!\\n"" ) ; return AVERROR ( EINVAL ) ; } if ("
169,"CWE-119  static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) {  int delp = remap_prob ( newp , oldp ) ; return update_bits [ delp ] * 256 ; }"," int prob_diff_update_cost ( vpx_prob newp , vpx_prob  oldp ) {"
170,"CWE-834 static av_cold int rl2_read_header ( AVFormatContext * s ) { AVIOContext * pb = s -> pb ; AVStream * st ; unsigned int frame_count ; unsigned int audio_frame_counter = 0 ; unsigned int video_frame_counter = 0 ; unsigned int back_size ; unsigned short sound_rate ; unsigned short rate ; unsigned short channels ; unsigned short def_sound_size ; unsigned int signature ; unsigned int pts_den = 11025 ; unsigned int pts_num = 1103 ; unsigned int * chunk_offset = NULL ; int * chunk_size = NULL ; int * audio_size = NULL ; int i ; int ret = 0 ; avio_skip ( pb , 4 ) ; back_size = avio_rl32 ( pb ) ; signature = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; frame_count = avio_rl32 ( pb ) ; if ( back_size > INT_MAX / 2 || frame_count > INT_MAX / sizeof ( uint32_t ) ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 2 ) ; sound_rate = avio_rl16 ( pb ) ; rate = avio_rl16 ( pb ) ; channels = avio_rl16 ( pb ) ; def_sound_size = avio_rl16 ( pb ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RL2 ; st -> codecpar -> codec_tag = 0 ; st -> codecpar -> width = 320 ; st -> codecpar -> height = 200 ; st -> codecpar -> extradata_size = EXTRADATA1_SIZE ; if ( signature == RLV3_TAG && back_size > 0 ) st -> codecpar -> extradata_size += back_size ; if ( ff_get_extradata ( s , st -> codecpar , pb , st -> codecpar -> extradata_size ) < 0 ) return AVERROR ( ENOMEM ) ; if ( sound_rate ) { if ( ! channels || channels > 42 ) { av_log ( s , AV_LOG_ERROR , ""Invalidnumberofchannels:%d\\n"" , channels ) ; return AVERROR_INVALIDDATA ; } pts_num = def_sound_size ; pts_den = rate ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; st -> codecpar -> codec_tag = 1 ; st -> codecpar -> channels = channels ; st -> codecpar -> bits_per_coded_sample = 8 ; st -> codecpar -> sample_rate = rate ; st -> codecpar -> bit_rate = st -> codecpar -> channels * st -> codecpar -> sample_rate * st -> codecpar -> bits_per_coded_sample ; st -> codecpar -> block_align = st -> codecpar -> channels * st -> codecpar -> bits_per_coded_sample / 8 ; avpriv_set_pts_info ( st , 32 , 1 , rate ) ; } avpriv_set_pts_info ( s -> streams [ 0 ] , 32 , pts_num , pts_den ) ; chunk_size = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; audio_size = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; chunk_offset = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; if ( ! chunk_size || ! audio_size || ! chunk_offset ) { av_free ( chunk_size ) ; av_free ( audio_size ) ; av_free ( chunk_offset ) ; return AVERROR ( ENOMEM ) ; }  for ( i = 0 ; i < frame_count ; i ++ )   chunk_size [ i ] = avio_rl32 ( pb ) ;   for ( i = 0 ; i < frame_count ; i ++ )   chunk_offset [ i ] = avio_rl32 ( pb ) ;   for ( i = 0 ; i < frame_count ; i ++ )  audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ;  for ( i = 0 ; i < frame_count ; i ++ ) {  if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) { ret = AVERROR_INVALIDDATA ; break ; } if ( sound_rate && audio_size [ i ] ) { av_add_index_entry ( s -> streams [ 1 ] , chunk_offset [ i ] , audio_frame_counter , audio_size [ i ] , 0 , AVINDEX_KEYFRAME ) ; audio_frame_counter += audio_size [ i ] / channels ; } av_add_index_entry ( s -> streams [ 0 ] , chunk_offset [ i ] + audio_size [ i ] , video_frame_counter , chunk_size [ i ] - audio_size [ i ] , 0 , AVINDEX_KEYFRAME ) ; ++ video_frame_counter ; } av_free ( chunk_size ) ; av_free ( audio_size ) ; av_free ( chunk_offset ) ; return ret ; }", i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;  pb ) ; }  i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;  pb ) ; }  i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;  & 0xFFFF ; }
171,"CWE-000 static int parseFileInner ( MaState * state , cchar * path ) { MaDirective * directive ; char * tok , * key , * line , * value ; assert ( state ) ; assert ( path && * path ) ; if ( openConfig ( state , path ) < 0 ) { return MPR_ERR_CANT_OPEN ; } for ( state -> lineNumber = 1 ; state -> file && ( line = mprReadLine ( state -> file , 0 , NULL ) ) != 0 ; state -> lineNumber ++ ) { for ( tok = line ; isspace ( ( uchar ) * tok ) ; tok ++ ) ; if ( * tok == '\\0' || * tok == '#' ) { continue ; } state -> key = 0 ;  key = getDirective ( line , & value ) ;  if ( ! state -> enabled ) { if ( key [ 0 ] != '<' ) { continue ; } } if ( ( directive = mprLookupKey ( directives , key ) ) == 0 ) { mprLog ( ""errorappwebconfig"" , 0 , ""Unknowndirective\\""%s\\"".Atline%din%s"" , key , state -> lineNumber , state -> filename ) ; return MPR_ERR_BAD_SYNTAX ; } state -> key = key ; mprPauseGC ( ) ; if ( ( * directive ) ( state , key , value ) < 0 ) { mprResumeGC ( ) ; mprLog ( ""errorappwebconfig"" , 0 , ""Errorwithdirective\\""%s\\"".Atline%din%s"" , state -> key , state -> lineNumber , state -> filename ) ; return MPR_ERR_BAD_SYNTAX ; } mprResumeGC ( ) ; mprYield ( 0 ) ; state = state -> top -> current ; } if ( state -> prev && state -> file == state -> prev -> file ) { mprLog ( ""errorappwebconfig"" , 0 , ""Uncloseddirectivesin%s"" , state -> filename ) ; while ( state -> prev && state -> file == state -> prev -> file ) { state = state -> prev ; } } mprCloseFile ( state -> file ) ; return 0 ; }", = 0 ; if ( (  & value ) ) == 0 ) { continue ; }  if ( !
172,"CWE-119 static vpx_codec_err_t decoder_set_fb_fn ( vpx_codec_alg_priv_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { if ( cb_get == NULL || cb_release == NULL ) { return VPX_CODEC_INVALID_PARAM ;  } else if ( ctx -> pbi == NULL ) {  ctx -> get_ext_fb_cb = cb_get ; ctx -> release_ext_fb_cb = cb_release ; ctx -> ext_priv = cb_priv ; return VPX_CODEC_OK ; } return VPX_CODEC_ERROR ; }", ( ctx -> frame_workers  == NULL )
173,"CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( ""BPF_LDXusesreservedfields\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( ""BPF_STXusesreservedfields\\n"" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( ""invalidbpf_ld_imm64insn\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( ""unrecognizedbpf_ld_imm64insn\\n"" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( ""fd%disnotpointingtovalidbpf_map\\n"" , insn -> imm ) ; return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; }  env -> used_maps [ env -> used_map_cnt ++ ] = map ;   bpf_map_inc ( map , false ) ;  fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }"," E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; }  = map ;  fdput ( f"
174,"CWE-476 key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ;  if ( ! index_key . type -> match || ! index_key . type -> instantiate ||  ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } if ( ! index_key . description ) index_key . description = prep . description ; key_ref = ERR_PTR ( - EINVAL ) ; if ( ! index_key . description ) goto error_free_prep ; } index_key . desc_len = strlen ( index_key . description ) ; key_ref = ERR_PTR ( - EPERM ) ; if ( ! prep . trusted && test_bit ( KEY_FLAG_TRUSTED_ONLY , & keyring -> flags ) ) goto error_free_prep ; flags |= prep . trusted ? KEY_ALLOC_TRUSTED : 0 ; ret = __key_link_begin ( keyring , & index_key , & edit ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } ret = key_permission ( keyring_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } if ( index_key . type -> update ) { key_ref = find_key_to_update ( keyring_ref , & index_key ) ; if ( key_ref ) goto found_matching_key ; } if ( perm == KEY_PERM_UNDEF ) { perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR ; perm |= KEY_USR_VIEW ; if ( index_key . type -> read ) perm |= KEY_POS_READ ; if ( index_key . type == & key_type_keyring || index_key . type -> update ) perm |= KEY_POS_WRITE ; } key = key_alloc ( index_key . type , index_key . description , cred -> fsuid , cred -> fsgid , cred , perm , flags ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error_link_end ; } ret = __key_instantiate_and_link ( key , & prep , keyring , NULL , & edit ) ; if ( ret < 0 ) { key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } key_ref = make_key_ref ( key , is_key_possessed ( keyring_ref ) ) ; error_link_end : __key_link_end ( keyring , & index_key , edit ) ; error_free_prep : if ( index_key . type -> preparse ) index_key . type -> free_preparse ( & prep ) ; error_put_type : key_type_put ( index_key . type ) ; error : return key_ref ; found_matching_key : __key_link_end ( keyring , & index_key , edit ) ; key_ref = __key_update ( key_ref , & prep ) ; goto error_free_prep ; }", ; if (  ! index_key .
175,"CWE-125 static int telnet_parse ( netdissect_options * ndo , const u_char * sp , u_int length , int print ) { int i , x ; u_int c ; const u_char * osp , * p ; # define FETCH ( c , sp , length ) do { if ( length < 1 ) goto pktend ; ND_TCHECK ( * sp ) ; c = * sp ++ ; length -- ; } while ( 0 ) osp = sp ; FETCH ( c , sp , length ) ; if ( c != IAC ) goto pktend ; FETCH ( c , sp , length ) ; if ( c == IAC ) { if ( print ) ND_PRINT ( ( ndo , ""IACIAC"" ) ) ; goto done ; } i = c - TELCMD_FIRST ; if ( i < 0 || i > IAC - TELCMD_FIRST ) goto pktend ; switch ( c ) { case DONT : case DO : case WONT : case WILL : case SB : FETCH ( x , sp , length ) ; if ( x >= 0 && x < NTELOPTS ) { if ( print ) ND_PRINT ( ( ndo , ""%s%s"" , telcmds [ i ] , telopts [ x ] ) ) ; } else { if ( print ) ND_PRINT ( ( ndo , ""%s%#x"" , telcmds [ i ] , x ) ) ; } if ( c != SB ) break ; p = sp ; while ( length > ( u_int ) ( p + 1 - sp ) ) { ND_TCHECK2 ( * p , 2 ) ; if ( p [ 0 ] == IAC && p [ 1 ] == SE ) break ; p ++ ; }  if ( * p != IAC )  goto pktend ; switch ( x ) { case TELOPT_AUTHENTICATION : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""%s"" , STR_OR_ID ( c , authcmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""%s"" , STR_OR_ID ( c , authtype ) ) ) ; break ; case TELOPT_ENCRYPT : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""%s"" , STR_OR_ID ( c , enccmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""%s"" , STR_OR_ID ( c , enctype ) ) ) ; break ; default : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""%s"" , STR_OR_ID ( c , cmds ) ) ) ; break ; } while ( p > sp ) { FETCH ( x , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""%#x"" , x ) ) ; } if ( print ) ND_PRINT ( ( ndo , ""SE"" ) ) ; sp += 2 ; break ; default : if ( print ) ND_PRINT ( ( ndo , ""%s"" , telcmds [ i ] ) ) ; goto done ; } done : return sp - osp ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; pktend : return - 1 ; # undef FETCH }", ++ ; } ND_TCHECK ( * p ) ;
176,"CWE-787 static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { ""Title"" , """" } , { ""Author"" , """" } , { ""Subject"" , """" } , { ""Keywords"" , """" } , { ""Creator"" , """" } , { ""Producer"" , """" } , { ""CreationDate"" , """" } , { ""ModDate"" , """" } , { ""Trapped"" , """" } , } ;  daddy = malloc ( sizeof ( creator_template ) ) ;  memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }", ; daddy = safe_calloc  ( sizeof (
177,"CWE-125 static PyObject * builtin_compile_impl ( PyObject * module , PyObject * source , PyObject * filename , const char * mode , int flags , int dont_inherit , int optimize ) { PyObject * source_copy ; const char * str ; int compile_mode = - 1 ; int is_ast ; PyCompilerFlags cf ;  int start [ ] = { Py_file_input , Py_eval_input , Py_single_input } ;  PyObject * result ; cf . cf_flags = flags | PyCF_SOURCE_IS_UTF8 ; if ( flags &  ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST ) )  { PyErr_SetString ( PyExc_ValueError , ""compile():unrecognisedflags"" ) ; goto error ; } if ( optimize < - 1 || optimize > 2 ) { PyErr_SetString ( PyExc_ValueError , ""compile():invalidoptimizevalue"" ) ; goto error ; } if ( ! dont_inherit ) { PyEval_MergeCompilerFlags ( & cf ) ; } if ( strcmp ( mode , ""exec"" ) == 0 ) compile_mode = 0 ; else if ( strcmp ( mode , ""eval"" ) == 0 ) compile_mode = 1 ; else if ( strcmp ( mode , ""single"" ) == 0 ) compile_mode = 2 ;  else {  PyErr_SetString ( PyExc_ValueError ,  ""compile()modemustbe\'exec\',\'eval\'or\'single\'"" ) ;  goto error ; } is_ast = PyAST_Check ( source ) ; if ( is_ast == - 1 ) goto error ; if ( is_ast ) { if ( flags & PyCF_ONLY_AST ) { Py_INCREF ( source ) ; result = source ; } else { PyArena * arena ; mod_ty mod ; arena = PyArena_New ( ) ; if ( arena == NULL ) goto error ; mod = PyAST_obj2mod ( source , arena , compile_mode ) ; if ( mod == NULL ) { PyArena_Free ( arena ) ; goto error ; } if ( ! PyAST_Validate ( mod ) ) { PyArena_Free ( arena ) ; goto error ; } result = ( PyObject * ) PyAST_CompileObject ( mod , filename , & cf , optimize , arena ) ; PyArena_Free ( arena ) ; } goto finally ; } str = source_as_string ( source , ""compile"" , ""string,bytesorAST"" , & cf , & source_copy ) ; if ( str == NULL ) goto error ; result = Py_CompileStringObject ( str , filename , start [ compile_mode ] , & cf , optimize ) ; Py_XDECREF ( source_copy ) ; goto finally ; error : result = NULL ; finally : Py_DECREF ( filename ) ; return result ; }"," Py_eval_input , Py_single_input , Py_func_type_input  PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST | PyCF_TYPE_COMMENTS  2 ; else if ( strcmp ( mode , ""func_type"" ) == 0 ) { if ( ! ( flags & PyCF_ONLY_AST ) )  ( PyExc_ValueError , ""compile()mode\'func_type\'requiresflagPyCF_ONLY_AST"" ) ; goto error ; } compile_mode = 3 ; } else { const char * msg ; if ( flags & PyCF_ONLY_AST ) msg = ""compile()modemustbe\'exec\',\'eval\',\'single\'or\'func_type\'"" ; else msg = ""compile()modemustbe\'exec\',\'eval\'or\'single\'"" ; PyErr_SetString ( PyExc_ValueError , msg  ) ; goto"
178,"CWE-22 int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( ""%s\\n"" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) {  char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;  printf ( ""Extracting%s\\n"" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( ""%s:extracterroron\\""%s\\"":%s\\n"" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( ""%s:can\'topen--%s\\n"" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }", = create_output_name (  f [ i  ] -> filename  ) ; printf
179,"CWE-119 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ;  if ( size < 6 )  ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }  } "," ( size < 5 + 1  ) ASSERT (  ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }"
180,"CWE-787 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ;  char combname [ L_BUF_SIZE ] ;  l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( ""selaGetCombName"" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( ""selanotdefined"" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( ""invaliddirection"" , procName , NULL ) ; if ( direction == L_HORIZ )  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ;  else  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ;  found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( ""selnotfound"" , procName , NULL ) ; }"," char combname [ L_BUFSIZE  ] ; l_int32  ( combname , L_BUFSIZE  , ""sel_comb_%dh"" ,  ( combname , L_BUFSIZE  , ""sel_comb_%dv"" ,"
181,"CWE-119  static void update_switchable_interp_probs ( VP9_COMMON * cm , vp9_writer * w ) {  int j ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) prob_diff_update ( vp9_switchable_interp_tree ,  cm -> fc . switchable_interp_prob [ j ] ,   cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ;  }"," * cm , vpx_writer * w , FRAME_COUNTS * counts  ) { int  cm -> fc ->  switchable_interp_prob [ j  j ] , counts ->  switchable_interp [ j"
182,"CWE-000 int tipc_nl_publ_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { int err ; u32 tsk_portid = cb -> args [ 0 ] ; u32 last_publ = cb -> args [ 1 ] ; u32 done = cb -> args [ 2 ] ; struct net * net = sock_net ( skb -> sk ) ; struct tipc_sock * tsk ; if ( ! tsk_portid ) { struct nlattr * * attrs ; struct nlattr * sock [ TIPC_NLA_SOCK_MAX + 1 ] ; err = tipc_nlmsg_parse ( cb -> nlh , & attrs ) ; if ( err ) return err ;  err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX ,   attrs [ TIPC_NLA_SOCK ] ,  tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ;  tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ;  } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;  lock_sock ( & tsk -> sk ) ;  err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ; if ( ! err ) done = 1 ; release_sock ( & tsk -> sk ) ; sock_put ( & tsk -> sk ) ; cb -> args [ 0 ] = tsk_portid ; cb -> args [ 1 ] = last_publ ; cb -> args [ 2 ] = done ; return skb -> len ; }"," return err ; if ( !  attrs [ TIPC_NLA_SOCK  attrs [ TIPC_NLA_SOCK  ] ) return  - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock  [ TIPC_NLA_SOCK_REF ]  [ TIPC_NLA_SOCK_REF ]  ) return -  - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;"
183,"CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; }  truncate_pagecache ( inode , ioffset ) ;   ext4_inode_block_unlocked_dio ( inode ) ;  inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ;  goto out_dio ;  } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ;  out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }", out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  ioffset ) ;  credits = ext4_writepage_trans_blocks  ) ; goto out_mmap  ; } inode  handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  ext4_inode_resume_unlocked_dio ( inode
184,"CWE-120 static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ;  name . name = buf ;  name . len = outarg . namelen ;  err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;  if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }"," goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) +  outarg . namelen  + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )"
185,"CWE-200 static int cdrom_ioctl_select_disc ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""enteringCDROM_SELECT_DISC\\n"" ) ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) ) return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) {  if ( ( int ) arg >= cdi -> capacity )  return - EINVAL ; } if ( cdi -> ops -> select_disc ) return cdi -> ops -> select_disc ( cdi , arg ) ; cd_dbg ( CD_CHANGER , ""Usinggenericcdrom_select_disc()\\n"" ) ; return cdrom_select_disc ( cdi , arg ) ; }", { if (  arg >= cdi
186,"CWE-119 static int nci_extract_activation_params_iso_dep ( struct nci_dev * ndev , struct nci_rf_intf_activated_ntf * ntf , __u8 * data ) { struct activation_params_nfca_poll_iso_dep * nfca_poll ; struct activation_params_nfcb_poll_iso_dep * nfcb_poll ; switch ( ntf -> activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep ;  nfca_poll -> rats_res_len = * data ++ ;  pr_debug ( ""rats_res_len%d\\n"" , nfca_poll -> rats_res_len ) ; if ( nfca_poll -> rats_res_len > 0 ) { memcpy ( nfca_poll -> rats_res , data , nfca_poll -> rats_res_len ) ; } break ; case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep ;  nfcb_poll -> attrib_res_len = * data ++ ;  pr_debug ( ""attrib_res_len%d\\n"" , nfcb_poll -> attrib_res_len ) ; if ( nfcb_poll -> attrib_res_len > 0 ) { memcpy ( nfcb_poll -> attrib_res , data , nfcb_poll -> attrib_res_len ) ; } break ; default : pr_err ( ""unsupportedactivation_rf_tech_and_mode0x%x\\n"" , ntf -> activation_rf_tech_and_mode ) ; return NCI_STATUS_RF_PROTOCOL_ERROR ; } return NCI_STATUS_OK ; }"," -> rats_res_len = min_t ( __u8 ,  * data ++ , 20 )  -> attrib_res_len = min_t ( __u8 ,  * data ++ , 50 )"
187,"CWE-200 static void snd_timer_user_tinterrupt ( struct snd_timer_instance * timeri , unsigned long resolution , unsigned long ticks ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread * r , r1 ; struct timespec tstamp ; int prev , append = 0 ; memset ( & tstamp , 0 , sizeof ( tstamp ) ) ; spin_lock ( & tu -> qlock ) ; if ( ( tu -> filter & ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) ) ) == 0 ) { spin_unlock ( & tu -> qlock ) ; return ; } if ( tu -> last_resolution != resolution || ticks > 0 ) { if ( timer_tstamp_monotonic ) ktime_get_ts ( & tstamp ) ; else getnstimeofday ( & tstamp ) ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) ) && tu -> last_resolution != resolution ) {  r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ;  r1 . tstamp = tstamp ; r1 . val = resolution ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; tu -> last_resolution = resolution ; append ++ ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_TICK ) ) == 0 ) goto __wake ; if ( ticks == 0 ) goto __wake ; if ( tu -> qused > 0 ) { prev = tu -> qtail == 0 ? tu -> queue_size - 1 : tu -> qtail - 1 ; r = & tu -> tqueue [ prev ] ; if ( r -> event == SNDRV_TIMER_EVENT_TICK ) { r -> tstamp = tstamp ; r -> val += ticks ; append ++ ; goto __wake ; } } r1 . event = SNDRV_TIMER_EVENT_TICK ; r1 . tstamp = tstamp ; r1 . val = ticks ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; append ++ ; __wake : spin_unlock ( & tu -> qlock ) ; if ( append == 0 ) return ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }"," resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;"
188,"CWE-416 static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ;  set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;  err = hci_uart_register_dev ( hu ) ; if ( err ) {  clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;   return err ;  } return 0 ; }"," = p ;  err = hci_uart_register_dev  err ) { return err ; } set_bit  ( HCI_UART_PROTO_READY ,  ) ; return  0 ; }"
189,"CWE-119 static void mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd , int start_mb_row ) { volatile const int * last_row_current_mb_col ; volatile int * current_mb_col ; int mb_row ; VP8_COMMON * pc = & pbi -> common ; const int nsync = pbi -> sync_range ; const int first_row_no_sync_above = pc -> mb_cols + nsync ; int num_part = 1 << pbi -> common . multi_token_partition ; int last_mb_row = start_mb_row ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; YV12_BUFFER_CONFIG * yv12_fb_lst = pbi -> dec_fb_ref [ LAST_FRAME ] ; int recon_y_stride = yv12_fb_new -> y_stride ; int recon_uv_stride = yv12_fb_new -> uv_stride ; unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; unsigned char * dst_buffer [ 3 ] ; int i ; int ref_fb_corrupted [ MAX_REF_FRAMES ] ; ref_fb_corrupted [ INTRA_FRAME ] = 0 ; for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) { YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; ref_fb_corrupted [ i ] = this_fb -> corrupted ; } dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; dst_buffer [ 2 ] = yv12_fb_new -> v_buffer ; xd -> up_available = ( start_mb_row != 0 ) ; for ( mb_row = start_mb_row ; mb_row < pc -> mb_rows ; mb_row += ( pbi -> decoding_thread_count + 1 ) ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int filter_level ; loop_filter_info_n * lfi_n = & pc -> lf_info ; last_mb_row = mb_row ; xd -> current_bc = & pbi -> mbc [ mb_row % num_part ] ; if ( mb_row > 0 ) last_row_current_mb_col = & pbi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & first_row_no_sync_above ; current_mb_col = & pbi -> mt_current_mb_col [ mb_row ] ; recon_yoffset = mb_row * recon_y_stride * 16 ; recon_uvoffset = mb_row * recon_uv_stride * 8 ; xd -> above_context = pc -> above_context ;  vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;  xd -> left_available = 0 ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) ) << 3 ; xd -> mb_to_bottom_edge = ( ( pc -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; if ( pbi -> common . filter_level ) { xd -> recon_above [ 0 ] = pbi -> mt_yabove_row [ mb_row ] + 0 * 16 + 32 ; xd -> recon_above [ 1 ] = pbi -> mt_uabove_row [ mb_row ] + 0 * 8 + 16 ; xd -> recon_above [ 2 ] = pbi -> mt_vabove_row [ mb_row ] + 0 * 8 + 16 ; xd -> recon_left [ 0 ] = pbi -> mt_yleft_col [ mb_row ] ; xd -> recon_left [ 1 ] = pbi -> mt_uleft_col [ mb_row ] ; xd -> recon_left [ 2 ] = pbi -> mt_vleft_col [ mb_row ] ; xd -> recon_left_stride [ 0 ] = 1 ; xd -> recon_left_stride [ 1 ] = 1 ; } else { xd -> recon_above [ 0 ] = dst_buffer [ 0 ] + recon_yoffset ; xd -> recon_above [ 1 ] = dst_buffer [ 1 ] + recon_uvoffset ; xd -> recon_above [ 2 ] = dst_buffer [ 2 ] + recon_uvoffset ; xd -> recon_left [ 0 ] = xd -> recon_above [ 0 ] - 1 ; xd -> recon_left [ 1 ] = xd -> recon_above [ 1 ] - 1 ; xd -> recon_left [ 2 ] = xd -> recon_above [ 2 ] - 1 ; xd -> recon_above [ 0 ] -= xd -> dst . y_stride ; xd -> recon_above [ 1 ] -= xd -> dst . uv_stride ; xd -> recon_above [ 2 ] -= xd -> dst . uv_stride ; xd -> recon_left_stride [ 0 ] = xd -> dst . y_stride ; xd -> recon_left_stride [ 1 ] = xd -> dst . uv_stride ; setup_intra_recon_left ( xd -> recon_left [ 0 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> dst . y_stride , xd -> dst . uv_stride ) ; } for ( mb_col = 0 ; mb_col < pc -> mb_cols ; mb_col ++ ) { * current_mb_col = mb_col - 1 ; if ( ( mb_col & ( nsync - 1 ) ) == 0 ) { while ( mb_col > ( * last_row_current_mb_col - nsync ) ) { x86_pause_hint ( ) ; thread_sleep ( 0 ) ; } } xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( pc -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; # if CONFIG_ERROR_CONCEALMENT { int corrupt_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) || vp8dx_bool_error ( xd -> current_bc ) ; if ( pbi -> ec_active && ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && corrupt_residual ) { vp8_interpolate_motion ( xd , mb_row , mb_col , pc -> mb_rows , pc -> mb_cols , pc -> mode_info_stride ) ; } } # endif xd -> dst . y_buffer = dst_buffer [ 0 ] + recon_yoffset ; xd -> dst . u_buffer = dst_buffer [ 1 ] + recon_uvoffset ; xd -> dst . v_buffer = dst_buffer [ 2 ] + recon_uvoffset ; xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ; mt_decode_macroblock ( pbi , xd , 0 ) ; xd -> left_available = 1 ; xd -> corrupted |= vp8dx_bool_error ( xd -> current_bc ) ; xd -> recon_above [ 0 ] += 16 ; xd -> recon_above [ 1 ] += 8 ; xd -> recon_above [ 2 ] += 8 ; if ( ! pbi -> common . filter_level ) { xd -> recon_left [ 0 ] += 16 ; xd -> recon_left [ 1 ] += 8 ; xd -> recon_left [ 2 ] += 8 ; } if ( pbi -> common . filter_level ) { int skip_lf = ( xd -> mode_info_context -> mbmi . mode != B_PRED && xd -> mode_info_context -> mbmi . mode != SPLITMV && xd -> mode_info_context -> mbmi . mb_skip_coeff ) ; const int mode_index = lfi_n -> mode_lf_lut [ xd -> mode_info_context -> mbmi . mode ] ; const int seg = xd -> mode_info_context -> mbmi . segment_id ; const int ref_frame = xd -> mode_info_context -> mbmi . ref_frame ; filter_level = lfi_n -> lvl [ seg ] [ ref_frame ] [ mode_index ] ; if ( mb_row != pc -> mb_rows - 1 ) {  vpx_memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ;   vpx_memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ;   vpx_memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ;  } if ( mb_col != pc -> mb_cols - 1 ) { MODE_INFO * next = xd -> mode_info_context + 1 ; if ( next -> mbmi . ref_frame == INTRA_FRAME ) { for ( i = 0 ; i < 16 ; i ++ ) pbi -> mt_yleft_col [ mb_row ] [ i ] = xd -> dst . y_buffer [ i * recon_y_stride + 15 ] ; for ( i = 0 ; i < 8 ; i ++ ) { pbi -> mt_uleft_col [ mb_row ] [ i ] = xd -> dst . u_buffer [ i * recon_uv_stride + 7 ] ; pbi -> mt_vleft_col [ mb_row ] [ i ] = xd -> dst . v_buffer [ i * recon_uv_stride + 7 ] ; } } } if ( filter_level ) { if ( pc -> filter_type == NORMAL_LOOPFILTER ) { loop_filter_info lfi ; FRAME_TYPE frame_type = pc -> frame_type ; const int hev_index = lfi_n -> hev_thr_lut [ frame_type ] [ filter_level ] ; lfi . mblim = lfi_n -> mblim [ filter_level ] ; lfi . blim = lfi_n -> blim [ filter_level ] ; lfi . lim = lfi_n -> lim [ filter_level ] ; lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ; if ( mb_col > 0 ) vp8_loop_filter_mbv ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; if ( ! skip_lf ) vp8_loop_filter_bv ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; if ( mb_row > 0 ) vp8_loop_filter_mbh ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; if ( ! skip_lf ) vp8_loop_filter_bh ( xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , recon_y_stride , recon_uv_stride , & lfi ) ; } else { if ( mb_col > 0 ) vp8_loop_filter_simple_mbv ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> mblim [ filter_level ] ) ; if ( ! skip_lf ) vp8_loop_filter_simple_bv ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> blim [ filter_level ] ) ; if ( mb_row > 0 ) vp8_loop_filter_simple_mbh ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> mblim [ filter_level ] ) ; if ( ! skip_lf ) vp8_loop_filter_simple_bh ( xd -> dst . y_buffer , recon_y_stride , lfi_n -> blim [ filter_level ] ) ; } } } recon_yoffset += 16 ; recon_uvoffset += 8 ; ++ xd -> mode_info_context ; xd -> above_context ++ ; } if ( pbi -> common . filter_level ) { if ( mb_row != pc -> mb_rows - 1 ) { int lasty = yv12_fb_lst -> y_width + VP8BORDERINPIXELS ; int lastuv = ( yv12_fb_lst -> y_width >> 1 ) + ( VP8BORDERINPIXELS >> 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { pbi -> mt_yabove_row [ mb_row + 1 ] [ lasty + i ] = pbi -> mt_yabove_row [ mb_row + 1 ] [ lasty - 1 ] ; pbi -> mt_uabove_row [ mb_row + 1 ] [ lastuv + i ] = pbi -> mt_uabove_row [ mb_row + 1 ] [ lastuv - 1 ] ; pbi -> mt_vabove_row [ mb_row + 1 ] [ lastuv + i ] = pbi -> mt_vabove_row [ mb_row + 1 ] [ lastuv - 1 ] ; } } } else vp8_extend_mb_row ( yv12_fb_new , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; * current_mb_col = mb_col + nsync ; ++ xd -> mode_info_context ; xd -> up_available = 1 ; xd -> mode_info_context += xd -> mode_info_stride * pbi -> decoding_thread_count ; } if ( last_mb_row == ( pc -> mb_rows - 1 ) ) sem_post ( & pbi -> h_event_end_decoding ) ; }", -> above_context ; memset  ( xd ->  1 ) { memcpy  ( ( pbi  16 ) ; memcpy  ( ( pbi  8 ) ; memcpy  ( ( pbi
190,"CWE-125 static PyTypeObject * make_type ( char * type , PyTypeObject * base , char * * fields , int num_fields )  {  PyObject * fnames , * result ; int i ; fnames = PyTuple_New ( num_fields ) ; if ( ! fnames ) return NULL ; for ( i = 0 ; i < num_fields ; i ++ ) { PyObject * field = PyUnicode_FromString ( fields [ i ] ) ; if ( ! field ) { Py_DECREF ( fnames ) ; return NULL ; } PyTuple_SET_ITEM ( fnames , i , field ) ; }  result = PyObject_CallFunction ( ( PyObject * ) & PyType_Type , ""s(O){sOss}"" ,   type , base , ""_fields"" , fnames , ""__module__"" , ""_ast3"" ) ;  Py_DECREF ( fnames ) ; return ( PyTypeObject * ) result ; }"," num_fields ) { _Py_IDENTIFIER ( __module__ ) ; _Py_IDENTIFIER ( _ast3 ) ;  & PyType_Type , ""s(O){OOOO}""  , type ,  , base , _PyUnicode_FromId ( & PyId__fields )  , fnames ,  , fnames , _PyUnicode_FromId ( & PyId___module__ ) , _PyUnicode_FromId ( & PyId__ast3 )  ) ; Py_DECREF"
191,"CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ;  count = be32_to_cpu ( aclp -> acl_cnt ) ;  acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }", aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
192,"CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ;  sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ;  if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , ""PPSidoutofrange:%d\\n"" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , ""PPSchangedbetweenslices.\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ; if ( s -> ps . sps != ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ) { const HEVCSPS * sps = ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ; const HEVCSPS * last_sps = s -> ps . sps ; enum AVPixelFormat pix_fmt ; if ( last_sps && IS_IRAP ( s ) && s -> nal_unit_type != HEVC_NAL_CRA_NUT ) { if ( sps -> width != last_sps -> width || sps -> height != last_sps -> height || sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering != last_sps -> temporal_layer [ last_sps -> max_sub_layers - 1 ] . max_dec_pic_buffering ) sh -> no_output_of_prior_pics_flag = 0 ; } ff_hevc_clear_refs ( s ) ; ret = set_sps ( s , sps , sps -> pix_fmt ) ; if ( ret < 0 ) return ret ; pix_fmt = get_format ( s , sps ) ; if ( pix_fmt < 0 ) return pix_fmt ; s -> avctx -> pix_fmt = pix_fmt ; s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; } sh -> dependent_slice_segment_flag = 0 ; if ( ! sh -> first_slice_in_pic_flag ) { int slice_address_length ; if ( s -> ps . pps -> dependent_slice_segments_enabled_flag ) sh -> dependent_slice_segment_flag = get_bits1 ( gb ) ; slice_address_length = av_ceil_log2 ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ; sh -> slice_segment_addr = get_bitsz ( gb , slice_address_length ) ; if ( sh -> slice_segment_addr >= s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalidslicesegmentaddress:%u.\\n"" , sh -> slice_segment_addr ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> dependent_slice_segment_flag ) { sh -> slice_addr = sh -> slice_segment_addr ; s -> slice_idx ++ ; } } else { sh -> slice_segment_addr = sh -> slice_addr = 0 ; s -> slice_idx = 0 ; s -> slice_initialized = 0 ; } if ( ! sh -> dependent_slice_segment_flag ) { s -> slice_initialized = 0 ; for ( i = 0 ; i < s -> ps . pps -> num_extra_slice_header_bits ; i ++ ) skip_bits ( gb , 1 ) ; sh -> slice_type = get_ue_golomb_long ( gb ) ; if ( ! ( sh -> slice_type == HEVC_SLICE_I || sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknownslicetype:%d.\\n"" , sh -> slice_type ) ; return AVERROR_INVALIDDATA ; } if ( IS_IRAP ( s ) && sh -> slice_type != HEVC_SLICE_I ) { av_log ( s -> avctx , AV_LOG_ERROR , ""InterslicesinanIRAPframe.\\n"" ) ; return AVERROR_INVALIDDATA ; } sh -> pic_output_flag = 1 ; if ( s -> ps . pps -> output_flag_present_flag ) sh -> pic_output_flag = get_bits1 ( gb ) ; if ( s -> ps . sps -> separate_colour_plane_flag ) sh -> colour_plane_id = get_bits ( gb , 2 ) ; if ( ! IS_IDR ( s ) ) { int poc , pos ; sh -> pic_order_cnt_lsb = get_bits ( gb , s -> ps . sps -> log2_max_poc_lsb ) ; poc = ff_hevc_compute_poc ( s -> ps . sps , s -> pocTid0 , sh -> pic_order_cnt_lsb , s -> nal_unit_type ) ; if ( ! sh -> first_slice_in_pic_flag && poc != s -> poc ) { av_log ( s -> avctx , AV_LOG_WARNING , ""IgnoringPOCchangebetweenslices:%d->%d\\n"" , s -> poc , poc ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; poc = s -> poc ; } s -> poc = poc ; sh -> short_term_ref_pic_set_sps_flag = get_bits1 ( gb ) ; pos = get_bits_left ( gb ) ; if ( ! sh -> short_term_ref_pic_set_sps_flag ) { ret = ff_hevc_decode_short_term_rps ( gb , s -> avctx , & sh -> slice_rps , s -> ps . sps , 1 ) ; if ( ret < 0 ) return ret ; sh -> short_term_rps = & sh -> slice_rps ; } else { int numbits , rps_idx ; if ( ! s -> ps . sps -> nb_st_rps ) { av_log ( s -> avctx , AV_LOG_ERROR , ""NoreflistsintheSPS.\\n"" ) ; return AVERROR_INVALIDDATA ; } numbits = av_ceil_log2 ( s -> ps . sps -> nb_st_rps ) ; rps_idx = numbits > 0 ? get_bits ( gb , numbits ) : 0 ; sh -> short_term_rps = & s -> ps . sps -> st_rps [ rps_idx ] ; } sh -> short_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; pos = get_bits_left ( gb ) ; ret = decode_lt_rps ( s , & sh -> long_term_rps , gb ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""InvalidlongtermRPS.\\n"" ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; } sh -> long_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; if ( s -> ps . sps -> sps_temporal_mvp_enabled_flag ) sh -> slice_temporal_mvp_enabled_flag = get_bits1 ( gb ) ; else sh -> slice_temporal_mvp_enabled_flag = 0 ; } else { s -> sh . short_term_rps = NULL ; s -> poc = 0 ; } if ( sh -> first_slice_in_pic_flag && s -> temporal_id == 0 && s -> nal_unit_type != HEVC_NAL_TRAIL_N && s -> nal_unit_type != HEVC_NAL_TSA_N && s -> nal_unit_type != HEVC_NAL_STSA_N && s -> nal_unit_type != HEVC_NAL_RADL_N && s -> nal_unit_type != HEVC_NAL_RADL_R && s -> nal_unit_type != HEVC_NAL_RASL_N && s -> nal_unit_type != HEVC_NAL_RASL_R ) s -> pocTid0 = s -> poc ; if ( s -> ps . sps -> sao_enabled ) { sh -> slice_sample_adaptive_offset_flag [ 0 ] = get_bits1 ( gb ) ; if ( s -> ps . sps -> chroma_format_idc ) { sh -> slice_sample_adaptive_offset_flag [ 1 ] = sh -> slice_sample_adaptive_offset_flag [ 2 ] = get_bits1 ( gb ) ; } } else { sh -> slice_sample_adaptive_offset_flag [ 0 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 1 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 2 ] = 0 ; } sh -> nb_refs [ L0 ] = sh -> nb_refs [ L1 ] = 0 ; if ( sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) { int nb_refs ; sh -> nb_refs [ L0 ] = s -> ps . pps -> num_ref_idx_l0_default_active ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = s -> ps . pps -> num_ref_idx_l1_default_active ; if ( get_bits1 ( gb ) ) { sh -> nb_refs [ L0 ] = get_ue_golomb_long ( gb ) + 1 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = get_ue_golomb_long ( gb ) + 1 ; } if ( sh -> nb_refs [ L0 ] > HEVC_MAX_REFS || sh -> nb_refs [ L1 ] > HEVC_MAX_REFS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Toomanyrefs:%d/%d.\\n"" , sh -> nb_refs [ L0 ] , sh -> nb_refs [ L1 ] ) ; return AVERROR_INVALIDDATA ; } sh -> rpl_modification_flag [ 0 ] = 0 ; sh -> rpl_modification_flag [ 1 ] = 0 ; nb_refs = ff_hevc_frame_nb_refs ( s ) ; if ( ! nb_refs ) { av_log ( s -> avctx , AV_LOG_ERROR , ""ZerorefsforaframewithPorBslices.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> ps . pps -> lists_modification_present_flag && nb_refs > 1 ) { sh -> rpl_modification_flag [ 0 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 0 ] ) { for ( i = 0 ; i < sh -> nb_refs [ L0 ] ; i ++ ) sh -> list_entry_lx [ 0 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } if ( sh -> slice_type == HEVC_SLICE_B ) { sh -> rpl_modification_flag [ 1 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 1 ] == 1 ) for ( i = 0 ; i < sh -> nb_refs [ L1 ] ; i ++ ) sh -> list_entry_lx [ 1 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } } if ( sh -> slice_type == HEVC_SLICE_B ) sh -> mvd_l1_zero_flag = get_bits1 ( gb ) ; if ( s -> ps . pps -> cabac_init_present_flag ) sh -> cabac_init_flag = get_bits1 ( gb ) ; else sh -> cabac_init_flag = 0 ; sh -> collocated_ref_idx = 0 ; if ( sh -> slice_temporal_mvp_enabled_flag ) { sh -> collocated_list = L0 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> collocated_list = ! get_bits1 ( gb ) ; if ( sh -> nb_refs [ sh -> collocated_list ] > 1 ) { sh -> collocated_ref_idx = get_ue_golomb_long ( gb ) ; if ( sh -> collocated_ref_idx >= sh -> nb_refs [ sh -> collocated_list ] ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalidcollocated_ref_idx:%d.\\n"" , sh -> collocated_ref_idx ) ; return AVERROR_INVALIDDATA ; } } } if ( ( s -> ps . pps -> weighted_pred_flag && sh -> slice_type == HEVC_SLICE_P ) || ( s -> ps . pps -> weighted_bipred_flag && sh -> slice_type == HEVC_SLICE_B ) ) { int ret = pred_weight_table ( s , gb ) ; if ( ret < 0 ) return ret ; } sh -> max_num_merge_cand = 5 - get_ue_golomb_long ( gb ) ; if ( sh -> max_num_merge_cand < 1 || sh -> max_num_merge_cand > 5 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""InvalidnumberofmergingMVPcandidates:%d.\\n"" , sh -> max_num_merge_cand ) ; return AVERROR_INVALIDDATA ; } } sh -> slice_qp_delta = get_se_golomb ( gb ) ; if ( s -> ps . pps -> pic_slice_level_chroma_qp_offsets_present_flag ) { sh -> slice_cb_qp_offset = get_se_golomb ( gb ) ; sh -> slice_cr_qp_offset = get_se_golomb ( gb ) ; } else { sh -> slice_cb_qp_offset = 0 ; sh -> slice_cr_qp_offset = 0 ; } if ( s -> ps . pps -> chroma_qp_offset_list_enabled_flag ) sh -> cu_chroma_qp_offset_enabled_flag = get_bits1 ( gb ) ; else sh -> cu_chroma_qp_offset_enabled_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_control_present_flag ) { int deblocking_filter_override_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_override_enabled_flag ) deblocking_filter_override_flag = get_bits1 ( gb ) ; if ( deblocking_filter_override_flag ) { sh -> disable_deblocking_filter_flag = get_bits1 ( gb ) ; if ( ! sh -> disable_deblocking_filter_flag ) { int beta_offset_div2 = get_se_golomb ( gb ) ; int tc_offset_div2 = get_se_golomb ( gb ) ; if ( beta_offset_div2 < - 6 || beta_offset_div2 > 6 || tc_offset_div2 < - 6 || tc_offset_div2 > 6 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invaliddeblockfilteroffsets:%d,%d\\n"" , beta_offset_div2 , tc_offset_div2 ) ; return AVERROR_INVALIDDATA ; } sh -> beta_offset = beta_offset_div2 * 2 ; sh -> tc_offset = tc_offset_div2 * 2 ; } } else { sh -> disable_deblocking_filter_flag = s -> ps . pps -> disable_dbf ; sh -> beta_offset = s -> ps . pps -> beta_offset ; sh -> tc_offset = s -> ps . pps -> tc_offset ; } } else { sh -> disable_deblocking_filter_flag = 0 ; sh -> beta_offset = 0 ; sh -> tc_offset = 0 ; } if ( s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag && ( sh -> slice_sample_adaptive_offset_flag [ 0 ] || sh -> slice_sample_adaptive_offset_flag [ 1 ] || ! sh -> disable_deblocking_filter_flag ) ) { sh -> slice_loop_filter_across_slices_enabled_flag = get_bits1 ( gb ) ; } else { sh -> slice_loop_filter_across_slices_enabled_flag = s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag ; } } else if ( ! s -> slice_initialized ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Independentslicesegmentmissing.\\n"" ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = 0 ; if ( s -> ps . pps -> tiles_enabled_flag || s -> ps . pps -> entropy_coding_sync_enabled_flag ) { unsigned num_entry_point_offsets = get_ue_golomb_long ( gb ) ; if ( num_entry_point_offsets > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , ""num_entry_point_offsets%disinvalid\\n"" , num_entry_point_offsets ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = num_entry_point_offsets ; if ( sh -> num_entry_point_offsets > 0 ) { int offset_len = get_ue_golomb_long ( gb ) + 1 ; if ( offset_len < 1 || offset_len > 32 ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , ""offset_len%disinvalid\\n"" , offset_len ) ; return AVERROR_INVALIDDATA ; } av_freep ( & sh -> entry_point_offset ) ; av_freep ( & sh -> offset ) ; av_freep ( & sh -> size ) ; sh -> entry_point_offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( unsigned ) ) ; sh -> offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; sh -> size = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; if ( ! sh -> entry_point_offset || ! sh -> offset || ! sh -> size ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , ""Failedtoallocatememory\\n"" ) ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < sh -> num_entry_point_offsets ; i ++ ) { unsigned val = get_bits_long ( gb , offset_len ) ; sh -> entry_point_offset [ i ] = val + 1 ; } if ( s -> threads_number > 1 && ( s -> ps . pps -> num_tile_rows > 1 || s -> ps . pps -> num_tile_columns > 1 ) ) { s -> enable_parallel_tiles = 0 ; s -> threads_number = 1 ; } else s -> enable_parallel_tiles = 0 ; } else s -> enable_parallel_tiles = 0 ; } if ( s -> ps . pps -> slice_header_extension_present_flag ) { unsigned int length = get_ue_golomb_long ( gb ) ; if ( length * 8LL > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , ""toomanyslice_header_extension_data_bytes\\n"" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < length ; i ++ ) skip_bits ( gb , 8 ) ; } sh -> slice_qp = 26U + s -> ps . pps -> pic_init_qp_minus26 + sh -> slice_qp_delta ; if ( sh -> slice_qp > 51 || sh -> slice_qp < - s -> ps . sps -> qp_bd_offset ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Theslice_qp%disoutsidethevalidrange"" ""[%d,51].\\n"" , sh -> slice_qp , - s -> ps . sps -> qp_bd_offset ) ; return AVERROR_INVALIDDATA ; } sh -> slice_ctb_addr_rs = sh -> slice_segment_addr ; if ( ! s -> sh . slice_ctb_addr_rs && s -> sh . dependent_slice_segment_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Impossibleslicesegment.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits_left ( gb ) < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Overreadsliceheaderby%dbits\\n"" , - get_bits_left ( gb ) ) ; return AVERROR_INVALIDDATA ; } s -> HEVClc -> first_qp_group = ! s -> sh . dependent_slice_segment_flag ; if ( ! s -> ps . pps -> cu_qp_delta_enabled_flag ) s -> HEVClc -> qp_y = s -> sh . slice_qp ; s -> slice_initialized = 1 ; s -> HEVClc -> tu . cu_qp_offset_cb = 0 ; s -> HEVClc -> tu . cu_qp_offset_cr = 0 ; return 0 ; }"," gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Twoslicesreportingbeingthefirstinthesameframe.\\n"" ) ; return 1 ; }"
193,"CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) {  * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ;  if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ; } if ( nc >= 'A' && nc <= 'F' ) { ec |= nc - ( 'A' - 10 ) ; continue ; } return - EINVAL ; } * op ++ = ec & 0xFF ; * op ++ = ec >> 8 ; ip += 5 ; i += 5 ; } else { if ( ( charlen = nls -> char2uni ( ip , len - i , ( wchar_t * ) op ) ) < 0 ) return - EINVAL ; ip += charlen ; i += charlen ; op += 2 ; } } if ( i < len ) return - ENAMETOOLONG ; } else { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; i ++ , * outlen += 1 ) { * op ++ = * ip ++ ; * op ++ = 0 ; } if ( i < len ) return - ENAMETOOLONG ; } } * longlen = * outlen ; if ( * outlen % 13 ) { * op ++ = 0 ; * op ++ = 0 ; * outlen += 1 ; if ( * outlen % 13 ) { fill = 13 - ( * outlen % 13 ) ; for ( i = 0 ; i < fill ; i ++ ) { * op ++ = 0xff ; * op ++ = 0xff ; } * outlen += fill ; } } return 0 ; }"," , len , UTF16_HOST_ENDIAN ,  * ) outname , FAT_LFN_LEN + 2"
194,"CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; }  else if ( rc == - ENODATA )  rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;  return rc ;  }", == - ENODATA && inode -> i_op -> removexattr ) {  rc = inode  XATTR_NAME_EVM ) ; }
195,"CWE-59 static inline int mount_entry_on_generic ( struct mntent * mntent ,  const char * path )  { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , ""optional"" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type ,  mntflags , mntdata , optional ) ;  free ( mntdata ) ; return ret ; }"," char * path , const char * rootfs  mntdata , optional , rootfs"
196,"CWE-119  static int tile_worker_hook ( void * arg1 , void * arg2 ) {   TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;   const TileInfo * const tile = ( TileInfo * ) arg2 ;   int mi_row , mi_col ;  for ( mi_row = tile -> mi_row_start ; mi_row < tile -> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) {  decode_partition ( tile_data -> cm , & tile_data -> xd , tile ,   mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ;  } } return ! tile_data -> xd . corrupted ; }"," int tile_worker_hook (  TileWorkerData * const  * const tile_data ,  const TileInfo *  * const tile ) {  int mi_row ,  mi_row , mi_col ; if ( setjmp ( tile_data -> error_info . jmp ) ) { tile_data -> error_info . setjmp = 0 ; tile_data -> xd . corrupted = 1 ; return 0 ; } tile_data -> error_info . setjmp = 1 ; tile_data -> xd . error_info = & tile_data -> error_info  ( tile_data -> pbi  , & tile_data  tile_data -> xd  , mi_row ,  bit_reader , BLOCK_64X64 , 4"
197,"CWE-119 static void subtract_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame -= frame -> frame ;  section -> intra_error -= frame -> intra_error ;  section -> coded_error -= frame -> coded_error ; section -> sr_coded_error -= frame -> sr_coded_error ;  section -> ssim_weighted_pred_err -= frame -> ssim_weighted_pred_err ;  section -> pcnt_inter -= frame -> pcnt_inter ; section -> pcnt_motion -= frame -> pcnt_motion ; section -> pcnt_second_ref -= frame -> pcnt_second_ref ;  section -> pcnt_neutral -= frame -> pcnt_neutral ;  section -> MVr -= frame -> MVr ; section -> mvr_abs -= frame -> mvr_abs ; section -> MVc -= frame -> MVc ; section -> mvc_abs -= frame -> mvc_abs ; section -> MVrv -= frame -> MVrv ; section -> MVcv -= frame -> MVcv ; section -> mv_in_out_count -= frame -> mv_in_out_count ; section -> new_mv_count -= frame -> new_mv_count ; section -> count -= frame -> count ; section -> duration -= frame -> duration ; }", ; section -> weight -= frame -> weight ; section ->  ; section ->  pcnt_inter -= frame  frame -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols
198,"CWE-119 static int check_stack_boundary ( struct bpf_verifier_env * env , int regno , int access_size , bool zero_size_allowed , struct bpf_call_arg_meta * meta ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = state -> regs ; int off , i , slot , spi ; if ( regs [ regno ] . type != PTR_TO_STACK ) { if ( zero_size_allowed && access_size == 0 && register_is_null ( regs [ regno ] ) ) return 0 ; verbose ( env , ""R%dtype=%sexpected=%s\\n"" , regno , reg_type_str [ regs [ regno ] . type ] , reg_type_str [ PTR_TO_STACK ] ) ; return - EACCES ; } if ( ! tnum_is_const ( regs [ regno ] . var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , regs [ regno ] . var_off ) ; verbose ( env , ""invalidvariablestackreadR%dvar_off=%s\\n"" , regno , tn_buf ) ;  }  off = regs [ regno ] . off + regs [ regno ] . var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK || off + access_size > 0 || access_size < 0 || ( access_size == 0 && ! zero_size_allowed ) ) { verbose ( env , ""invalidstacktypeR%doff=%daccess_size=%d\\n"" , regno , off , access_size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( meta && meta -> raw_mode ) { meta -> access_size = access_size ; meta -> regno = regno ; return 0 ; } for ( i = 0 ; i < access_size ; i ++ ) { slot = - ( off + i ) - 1 ; spi = slot / BPF_REG_SIZE ; if ( state -> allocated_stack <= slot || state -> stack [ spi ] . slot_type [ slot % BPF_REG_SIZE ] != STACK_MISC ) { verbose ( env , ""invalidindirectreadfromstackoff%d+%dsize%d\\n"" , off , i , access_size ) ; return - EACCES ; } } return 0 ; }", tn_buf ) ; return - EACCES ;
199,"CWE-59 static int fill_autodev ( const struct lxc_rootfs * rootfs ) { int ret ; char path [ MAXPATHLEN ] ; int i ; mode_t cmask ; INFO ( ""Creatinginitialconsolesundercontainer/dev"" ) ; ret = snprintf ( path , MAXPATHLEN , ""%s/dev"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { ERROR ( ""Errorcalculatingcontainer/devlocation"" ) ; return - 1 ; } if ( ! dir_exists ( path ) ) return 0 ; INFO ( ""Populatingcontainer/dev"" ) ; cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ; for ( i = 0 ; i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ; i ++ ) { const struct lxc_devs * d = & lxc_devs [ i ] ; ret = snprintf ( path , MAXPATHLEN , ""%s/dev/%s"" , rootfs -> path ? rootfs -> mount : """" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ; if ( ret && errno != EEXIST ) { char hostpath [ MAXPATHLEN ] ; FILE * pathfile ; ret = snprintf ( hostpath , MAXPATHLEN , ""/dev/%s"" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; pathfile = fopen ( path , ""wb"" ) ; if ( ! pathfile ) { SYSERROR ( ""Failedtocreatedevicemounttarget\'%s\'"" , path ) ; return - 1 ; } fclose ( pathfile ) ;  if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) {  SYSERROR ( ""Failedbindmountingdevice%sfromhostintocontainer"" , d -> name ) ; return - 1 ; } } } umask ( cmask ) ; INFO ( ""Populatedcontainer/dev"" ) ; return 0 ; }"," ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount :  NULL ) !="
200,"CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , ""SYSV%08x"" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN ( size , huge_page_size ( hs ) ) ; if ( shmflg & SHM_NORESERVE ) acctflag = VM_NORESERVE ; file = hugetlb_file_setup ( name , hugesize , acctflag , & shp -> mlock_user , HUGETLB_SHMFS_INODE , ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; } else { if ( ( shmflg & SHM_NORESERVE ) && sysctl_overcommit_memory != OVERCOMMIT_NEVER ) acctflag = VM_NORESERVE ; file = shmem_kernel_file_setup ( name , size , acctflag ) ; } error = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) goto no_file ;  id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;  if ( id < 0 ) { error = id ; goto no_id ; }  shp -> shm_cprid = task_tgid_vnr ( current ) ;  shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist , & current -> sysvshm . shm_clist ) ; file_inode ( file ) -> i_ino = shp -> shm_perm . id ; ns -> shm_tot += numpages ; error = shp -> shm_perm . id ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; return error ; no_id : if ( is_file_hugepages ( file ) && shp -> mlock_user ) user_shm_unlock ( size , shp -> mlock_user ) ; fput ( file ) ; no_file : ipc_rcu_putref ( shp , shm_rcu_free ) ; return error ; }", goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ;  no_id ; }  list_add ( &
201,"CWE-834 static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , ""Videocompression%i"" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> nb_frames = vst -> nb_frames ; ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; if ( ast -> codecpar -> sample_rate <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Invalidsamplerate%d\\n"" , ast -> codecpar -> sample_rate ) ; return AVERROR_INVALIDDATA ; } avpriv_set_pts_info ( ast , 33 , 1 , ast -> codecpar -> sample_rate ) ; if ( set_channels ( avctx , ast , avio_rb32 ( pb ) ) < 0 ) return AVERROR_INVALIDDATA ; v = avio_rb32 ( pb ) ; if ( v == AUDIO_FORMAT_SIGNED ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audiocompression(format%i)"" , v ) ; } avio_skip ( pb , 12 ) ; var_read_metadata ( avctx , ""title"" , 0x80 ) ; var_read_metadata ( avctx , ""comment"" , 0x100 ) ; avio_skip ( pb , 0x80 ) ; timestamp = 0 ; for ( i = 0 ; i < vst -> nb_frames ; i ++ ) { uint32_t pos = avio_rb32 ( pb ) ; uint32_t asize = avio_rb32 ( pb ) ;  uint32_t vsize = avio_rb32 ( pb ) ;  avio_skip ( pb , 8 ) ; av_add_index_entry ( ast , pos , timestamp , asize , 0 , AVINDEX_KEYFRAME ) ; av_add_index_entry ( vst , pos + asize , i , vsize , 0 , AVINDEX_KEYFRAME ) ; timestamp += asize / ( ast -> codecpar -> channels * 2 ) ; } } else if ( ! version && avio_rb16 ( pb ) == 3 ) { avio_skip ( pb , 4 ) ; if ( ( ret = read_table ( avctx , NULL , parse_global_var ) ) < 0 ) return ret ; if ( mv -> nb_audio_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multipleaudiostreamssupport"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_audio_tracks ) { ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ( read_table ( avctx , ast , parse_audio_var ) ) < 0 ) return ret ; if ( mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16 ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audiocompression%i(format%i,sr%i)"" , mv -> acompression , mv -> aformat , ast -> codecpar -> bits_per_coded_sample ) ; ast -> codecpar -> codec_id = AV_CODEC_ID_NONE ; } if ( ast -> codecpar -> channels <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Novalidchannelcountfound.\\n"" ) ; return AVERROR_INVALIDDATA ; } } if ( mv -> nb_video_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiplevideostreamssupport"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_video_tracks ) { vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; if ( ( ret = read_table ( avctx , vst , parse_video_var ) ) < 0 ) return ret ; } if ( mv -> nb_audio_tracks ) read_index ( pb , ast ) ; if ( mv -> nb_video_tracks ) read_index ( pb , vst ) ; } else { avpriv_request_sample ( avctx , ""Version%i"" , version ) ; return AVERROR_PATCHWELCOME ; } return 0 ; }", ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
202,"CWE-189 static int nfs4_xdr_dec_getacl ( struct rpc_rqst * rqstp , struct xdr_stream * xdr , struct nfs_getaclres * res ) { struct compound_hdr hdr ; int status ; status = decode_compound_hdr ( xdr , & hdr ) ; if ( status ) goto out ; status = decode_sequence ( xdr , & res -> seq_res , rqstp ) ; if ( status ) goto out ; status = decode_putfh ( xdr ) ; if ( status ) goto out ;  status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ;  out : return status ; }"," , rqstp , res  ) ; out"
203,CWE-617 int pci_bus_configured ( int bus ) {  assert ( bus >= 0 && bus < MAXBUSES ) ;  return ( pci_businfo [ bus ] != NULL ) ; }, bus ) {  return ( pci_businfo
204,"CWE-125 void sctp_auth_get_cookie_params ( struct sctp_tcb * stcb , struct mbuf * m , uint32_t offset , uint32_t length ) { struct sctp_paramhdr * phdr , tmp_param ; uint16_t plen , ptype ; uint8_t random_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_random * p_random = NULL ; uint16_t random_len = 0 ; uint8_t hmacs_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_hmac_algo * hmacs = NULL ; uint16_t hmacs_len = 0 ; uint8_t chunks_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_chunk_list * chunks = NULL ; uint16_t num_chunks = 0 ; sctp_key_t * new_key ; uint32_t keylen ; length += offset ; phdr = ( struct sctp_paramhdr * ) sctp_m_getptr ( m , offset , sizeof ( struct sctp_paramhdr ) , ( uint8_t * ) & tmp_param ) ; while ( phdr != NULL ) { ptype = ntohs ( phdr -> param_type ) ; plen = ntohs ( phdr -> param_length ) ;  if ( ( plen == 0 ) || ( offset + plen > length ) )  break ; if ( ptype == SCTP_RANDOM ) { if ( plen > sizeof ( random_store ) ) break ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) random_store , plen ) ; if ( phdr == NULL ) return ; p_random = ( struct sctp_auth_random * ) phdr ; random_len = plen - sizeof ( * p_random ) ; } else if ( ptype == SCTP_HMAC_LIST ) { uint16_t num_hmacs ; uint16_t i ; if ( plen > sizeof ( hmacs_store ) ) break ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) hmacs_store , plen ) ; if ( phdr == NULL ) return ; hmacs = ( struct sctp_auth_hmac_algo * ) phdr ; hmacs_len = plen - sizeof ( * hmacs ) ; num_hmacs = hmacs_len / sizeof ( hmacs -> hmac_ids [ 0 ] ) ; if ( stcb -> asoc . local_hmacs != NULL ) sctp_free_hmaclist ( stcb -> asoc . local_hmacs ) ; stcb -> asoc . local_hmacs = sctp_alloc_hmaclist ( num_hmacs ) ; if ( stcb -> asoc . local_hmacs != NULL ) { for ( i = 0 ; i < num_hmacs ; i ++ ) { ( void ) sctp_auth_add_hmacid ( stcb -> asoc . local_hmacs , ntohs ( hmacs -> hmac_ids [ i ] ) ) ; } } } else if ( ptype == SCTP_CHUNK_LIST ) { int i ; if ( plen > sizeof ( chunks_store ) ) break ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) chunks_store , plen ) ; if ( phdr == NULL ) return ; chunks = ( struct sctp_auth_chunk_list * ) phdr ; num_chunks = plen - sizeof ( * chunks ) ; if ( stcb -> asoc . local_auth_chunks != NULL ) sctp_clear_chunklist ( stcb -> asoc . local_auth_chunks ) ; else stcb -> asoc . local_auth_chunks = sctp_alloc_chunklist ( ) ; for ( i = 0 ; i < num_chunks ; i ++ ) { ( void ) sctp_auth_add_chunk ( chunks -> chunk_types [ i ] , stcb -> asoc . local_auth_chunks ) ; } } offset += SCTP_SIZE32 ( plen ) ; if ( offset + sizeof ( struct sctp_paramhdr ) > length ) break ; phdr = ( struct sctp_paramhdr * ) sctp_m_getptr ( m , offset , sizeof ( struct sctp_paramhdr ) , ( uint8_t * ) & tmp_param ) ; } keylen = sizeof ( * p_random ) + random_len + sizeof ( * hmacs ) + hmacs_len ; if ( chunks != NULL ) { keylen += sizeof ( * chunks ) + num_chunks ; } new_key = sctp_alloc_key ( keylen ) ; if ( new_key != NULL ) { if ( p_random != NULL ) { keylen = sizeof ( * p_random ) + random_len ; memcpy ( new_key -> key , p_random , keylen ) ; } else { keylen = 0 ; } if ( chunks != NULL ) { memcpy ( new_key -> key + keylen , chunks , sizeof ( * chunks ) + num_chunks ) ; keylen += sizeof ( * chunks ) + num_chunks ; } if ( hmacs != NULL ) { memcpy ( new_key -> key + keylen , hmacs , sizeof ( * hmacs ) + hmacs_len ) ; } } if ( stcb -> asoc . authinfo . random != NULL ) sctp_free_key ( stcb -> asoc . authinfo . random ) ; stcb -> asoc . authinfo . random = new_key ; stcb -> asoc . authinfo . random_len = random_len ; sctp_clear_cachedkeys ( stcb , stcb -> asoc . authinfo . assoc_keyid ) ; sctp_clear_cachedkeys ( stcb , stcb -> asoc . authinfo . recv_keyid ) ; stcb -> asoc . peer_hmac_id = sctp_negotiate_hmacid ( stcb -> asoc . peer_hmacs , stcb -> asoc . local_hmacs ) ; stcb -> asoc . authinfo . active_keyid = stcb -> sctp_ep -> sctp_ep . default_keyid ; ( void ) sctp_copy_skeylist ( & stcb -> sctp_ep -> sctp_ep . shared_keys , & stcb -> asoc . shared_keys ) ; }", ( ( plen < sizeof ( struct sctp_paramhdr )  ) || (
205,"CWE-200 enum auth_stat gssrpc__svcauth_gss ( struct svc_req * rqst , struct rpc_msg * msg , bool_t * no_dispatch ) { enum auth_stat retstat ; XDR xdrs ; SVCAUTH * auth ; struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; struct rpc_gss_init_res gr ; int call_stat , offset ; OM_uint32 min_stat ; log_debug ( ""insvcauth_gss()"" ) ; rqst -> rq_xprt -> xp_verf = gssrpc__null_auth ; if ( rqst -> rq_xprt -> xp_auth == NULL || rqst -> rq_xprt -> xp_auth == & svc_auth_none ) { if ( ( auth = calloc ( sizeof ( * auth ) , 1 ) ) == NULL ) { fprintf ( stderr , ""svcauth_gss:out_of_memory\\n"" ) ; return ( AUTH_FAILED ) ; } if ( ( gd = calloc ( sizeof ( * gd ) , 1 ) ) == NULL ) { fprintf ( stderr , ""svcauth_gss:out_of_memory\\n"" ) ; return ( AUTH_FAILED ) ; } auth -> svc_ah_ops = & svc_auth_gss_ops ; SVCAUTH_PRIVATE ( auth ) = gd ; rqst -> rq_xprt -> xp_auth = auth ; } else gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; log_debug ( ""xp_auth=%p,gd=%p"" , rqst -> rq_xprt -> xp_auth , gd ) ; if ( rqst -> rq_cred . oa_length <= 0 ) return ( AUTH_BADCRED ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gc , 0 , sizeof ( * gc ) ) ; log_debug ( ""callingxdrmem_create()"" ) ; log_debug ( ""oa_base=%p,oa_length=%u"" , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length ) ; xdrmem_create ( & xdrs , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length , XDR_DECODE ) ; log_debug ( ""xdrmem_create()returned"" ) ; if ( ! xdr_rpc_gss_cred ( & xdrs , gc ) ) { log_debug ( ""xdr_rpc_gss_cred()failed"" ) ; XDR_DESTROY ( & xdrs ) ; return ( AUTH_BADCRED ) ; } XDR_DESTROY ( & xdrs ) ; retstat = AUTH_FAILED ; # define ret_freegc ( code ) do { retstat = code ; goto freegc ; } while ( 0 ) if ( gc -> gc_v != RPCSEC_GSS_VERSION ) ret_freegc ( AUTH_BADCRED ) ; if ( gc -> gc_svc != RPCSEC_GSS_SVC_NONE && gc -> gc_svc != RPCSEC_GSS_SVC_INTEGRITY && gc -> gc_svc != RPCSEC_GSS_SVC_PRIVACY ) ret_freegc ( AUTH_BADCRED ) ; if ( gd -> established ) { if ( gc -> gc_seq > MAXSEQ ) ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; if ( ( offset = gd -> seqlast - gc -> gc_seq ) < 0 ) { gd -> seqlast = gc -> gc_seq ; offset = 0 - offset ; gd -> seqmask <<= offset ; offset = 0 ; } else if ( ( u_int ) offset >= gd -> win || ( gd -> seqmask & ( 1 << offset ) ) ) { * no_dispatch = 1 ; ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; } gd -> seq = gc -> gc_seq ; gd -> seqmask |= ( 1 << offset ) ; } if ( gd -> established ) { rqst -> rq_clntname = ( char * ) gd -> client_name ; rqst -> rq_svccred = ( char * ) gd -> ctx ; } switch ( gc -> gc_proc ) { case RPCSEC_GSS_INIT : case RPCSEC_GSS_CONTINUE_INIT : if ( rqst -> rq_proc != NULLPROC ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_acquire_cred ( ) ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_accept_sec_context ( rqst , & gr ) ) ret_freegc ( AUTH_REJECTEDCRED ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gr . gr_win ) ) ) { gss_release_buffer ( & min_stat , & gr . gr_token ) ;  mem_free ( gr . gr_ctx . value ,  sizeof ( gss_union_ctx_id_desc ) ) ; ret_freegc ( AUTH_FAILED ) ; } * no_dispatch = TRUE ; call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_rpc_gss_init_res , ( caddr_t ) & gr ) ; gss_release_buffer ( & min_stat , & gr . gr_token ) ;  gss_release_buffer ( & min_stat , & gd -> checksum ) ;  mem_free ( gr . gr_ctx . value , sizeof ( gss_union_ctx_id_desc ) ) ; if ( ! call_stat ) ret_freegc ( AUTH_FAILED ) ; if ( gr . gr_major == GSS_S_COMPLETE ) gd -> established = TRUE ; break ; case RPCSEC_GSS_DATA : if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) ret_freegc ( AUTH_FAILED ) ; break ; case RPCSEC_GSS_DESTROY : if ( rqst -> rq_proc != NULLPROC ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) ret_freegc ( AUTH_FAILED ) ; * no_dispatch = TRUE ; call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_void , ( caddr_t ) NULL ) ; log_debug ( ""sendreplyindestroy:%d"" , call_stat ) ; if ( ! svcauth_gss_release_cred ( ) ) ret_freegc ( AUTH_FAILED ) ; SVCAUTH_DESTROY ( rqst -> rq_xprt -> xp_auth ) ; rqst -> rq_xprt -> xp_auth = & svc_auth_none ; break ; default : ret_freegc ( AUTH_REJECTEDCRED ) ; break ; } retstat = AUTH_OK ; freegc : xdr_free ( xdr_rpc_gss_cred , gc ) ; log_debug ( ""returning%dfromsvcauth_gss()"" , retstat ) ; return ( retstat ) ; }", gr_token ) ;  ret_freegc ( AUTH_FAILED  gd -> checksum  ) ; if
206,"CWE-787 static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) {  int v , i ;  if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) ||  ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) )  return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }"," , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , ""trnsbeforeIHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , ""trnsafterIDAT\\n"" ) ; return AVERROR_INVALIDDATA ; }  != 6 ) || s -> bit_depth == 1"
207,"CWE-19  struct mb_cache *   ext4_xattr_create_cache ( char * name )  {  return mb_cache_create ( name , HASH_BUCKET_BITS ) ;  }",   struct mb2_cache  * ext4_xattr_create_cache (  * ext4_xattr_create_cache ( void  ) { return  ) { return mb2_cache_create (  HASH_BUCKET_BITS ) ;
208,"CWE-189 static int sgi_clock_set ( clockid_t clockid , struct timespec * tp ) { u64 nsec ;  u64 rem ;  nsec = rtc_time ( ) * sgi_clock_period ;  sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;  if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ; else { sgi_clock_offset . tv_nsec = tp -> tv_sec + NSEC_PER_SEC - rem ; sgi_clock_offset . tv_sec -- ; } return 0 ; }"," u64 nsec ; u32  rem ; nsec  -> tv_sec - div_u64_rem  ( nsec ,"
209,"CWE-362 int main ( int argc , char * argv [ ] ) {  p_fm_config_conx_hdlt hdl ;  int instance = 0 ; fm_mgr_config_errno_t res ; char * rem_addr = NULL ; char * community = ""public"" ; char Opts [ 256 ] ; int arg ; char * command ; int i ; strcpy ( Opts , ""i:d:h-"" ) ; while ( ( arg = getopt ( argc , argv , Opts ) ) != EOF ) { switch ( arg ) { case 'h' : case '-' : usage ( argv [ 0 ] ) ; return ( 0 ) ; case 'i' : instance = atol ( optarg ) ; break ; case 'd' : rem_addr = optarg ; break ; default : usage ( argv [ 0 ] ) ; return ( - 1 ) ; } } if ( optind >= argc ) { fprintf ( stderr , ""Commandrequired\\n"" ) ; usage ( argv [ 0 ] ) ; return - 1 ; } command = argv [ optind ++ ] ; printf ( ""Connectingto%sFMinstance%d\\n"" , ( rem_addr == NULL ) ? ""LOCAL"" : rem_addr , instance ) ; if ( ( res = fm_mgr_config_init ( & hdl , instance , rem_addr , community ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failedtoinitializetheclienthandle:%d\\n"" , res ) ;  goto die_clean ;  } if ( ( res = fm_mgr_config_connect ( hdl ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failedtoconnect:(%d)%s\\n"" , res , fm_mgr_get_error_str ( res ) ) ;  goto die_clean ;  } for ( i = 0 ; i < commandListLen ; i ++ ) { if ( strcmp ( command , commandList [ i ] . name ) == 0 ) {  return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;   }  } fprintf ( stderr , ""Command(%s)isnotvalid\\n"" , command ) ; usage ( argv [ 0 ] ) ; res = - 1 ;  die_clean :  if ( hdl ) free ( hdl ) ;  return res ;  }", { p_fm_config_conx_hdlt hdl = NULL  ) ; goto cleanup  ; } if  ) ; goto cleanup  ; } for  0 ) { res =  commandList [ i  ] ) ; goto cleanup ;  - 1 ; cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; }  free ( hdl  hdl ) ; }
210,"CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ;  next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ;  if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ;  calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ;  al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }"," . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ;  ( ip , ( len > max_chunk_size ) ? max_chunk_size : len ,  & max_bytes ,"
211,"CWE-125 static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , ""CCIDoption%uoptlentooshort"" , * option ) ) ; else ND_PRINT ( ( ndo , ""%soptlentooshort"" , tok2str ( dccp_option_values , ""Option%u"" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , ""CCIDoption%uoptlengoespastheaderlength"" , * option ) ) ; else ND_PRINT ( ( ndo , ""%soptlengoespastheaderlength"" , tok2str ( dccp_option_values , ""Option%u"" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , ""CCIDoption%d"" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break ; } } else { ND_PRINT ( ( ndo , ""%s"" , tok2str ( dccp_option_values , ""Option%u"" , * option ) ) ) ; switch ( * option ) { case 32 : case 33 : case 34 : case 35 : if ( optlen < 3 ) { ND_PRINT ( ( ndo , ""optlentooshort"" ) ) ; return optlen ; } if ( * ( option + 2 ) < 10 ) { ND_PRINT ( ( ndo , ""%s"" , dccp_feature_nums [ * ( option + 2 ) ] ) ) ; for ( i = 0 ; i < optlen - 3 ; i ++ ) ND_PRINT ( ( ndo , ""%d"" , * ( option + 3 + i ) ) ) ; } break ; case 36 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 37 : for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%d"" , * ( option + 2 + i ) ) ) ; break ; case 38 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 39 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 40 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , ""0x"" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; case 41 :  if ( optlen == 4 )  ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else  ND_PRINT ( ( ndo , ""optlen!=4"" ) ) ;  break ; case 42 :  if ( optlen == 4 )   ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ;  else  ND_PRINT ( ( ndo , ""optlen!=4"" ) ) ;  break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else if ( optlen == 4 ) ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ; else ND_PRINT ( ( ndo , ""optlen!=4or6"" ) ) ; break ; case 44 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , """" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , * ( option + 2 + i ) ) ) ; } break ; } } return optlen ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return 0 ; }"," ( optlen == 6  ) ND_PRINT (  ( ndo , ""[optlen!=6]""  ) ) ;  case 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""(elapsedtime%u)"" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""(elapsedtime%u)"" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""[optlen!=6or8or10]"" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else  , ""%u"" , EXTRACT_16BITS  ( option +  ( ndo , ""[optlen!=4or6]""  ) ) ;"
212,"CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s>%s:[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , ""%s>%s:[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s>%s.%s:"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s>%s:"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s>%s.%s:"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s>%s:"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,length%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""0x%02x%02x%02x%02x%02x%02x"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPMseq%utrail%ulead%unla%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLLseq%uround%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLRseq%uround%unla%sivl%urnd0x%08x"" ""mask0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATAtrail%useq%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATAtrail%useq%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( EXTRACT_16BITS ( bp ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s->%s),seq%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACKseq%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWNtype0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[Firstoptionbad,shouldbePGM_OPT_LENGTH,is%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_LENGTHoption,length%u!=4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Badtotaloptionlength%u<4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""OPTSLEN%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Totaloptionlengthleavesnoroomforfinaloption]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Badoption,length%u<%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Totaloptionlengthleavesnoroomforfinaloption]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH :  if ( opt_len != 4 ) {  ND_PRINT ( ( ndo , ""[BadOPT_LENGTHoption,length%u!=4]"" , opt_len ) ) ; return ; }  ND_PRINT ( ( ndo , ""OPTSLEN(extra?)%d"" , EXTRACT_16BITS ( bp ) ) ) ;  bp += sizeof ( uint16_t ) ; opts_len -= 4 ;  break ;  case PGM_OPT_FRAGMENT :  if ( opt_len != 16 ) {  ND_PRINT ( ( ndo , ""[BadOPT_FRAGMENToption,length%u!=16]"" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ;  bp += sizeof ( uint32_t ) ;  offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""FRAGseq%uoff%ulen%u"" , seq , offset , len ) ) ;  opts_len -= 16 ;  break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""NAKLIST"" ) ) ; while ( opt_len ) {  if ( opt_len < sizeof ( uint32_t ) ) {  ND_PRINT ( ( ndo , ""[Optionlengthnotamultipleof4]"" ) ) ; return ; }  ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ;   ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( bp ) ) ) ;  bp += sizeof ( uint32_t ) ; opt_len -= sizeof ( uint32_t ) ;  opts_len -= sizeof ( uint32_t ) ;  } break ; case PGM_OPT_JOIN :  if ( opt_len != 8 ) {  ND_PRINT ( ( ndo , ""[BadOPT_JOINoption,length%u!=8]"" , opt_len ) ) ; return ; } bp += 2 ;  seq = EXTRACT_32BITS ( bp ) ;   bp += sizeof ( uint32_t ) ;  ND_PRINT ( ( ndo , ""JOIN%u"" , seq ) ) ;  opts_len -= 8 ;  break ; case PGM_OPT_NAK_BO_IVL :  if ( opt_len != 12 ) {  ND_PRINT ( ( ndo , ""[BadOPT_NAK_BO_IVLoption,length%u!=12]"" , opt_len ) ) ; return ; }  bp += 2 ;  offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""BACKOFFivl%uivlseq%u"" , offset , seq ) ) ;  opts_len -= 12 ;  break ; case PGM_OPT_NAK_BO_RNG :  if ( opt_len != 12 ) {  ND_PRINT ( ( ndo , ""[BadOPT_NAK_BO_RNGoption,length%u!=12]"" , opt_len ) ) ; return ; }  bp += 2 ;  offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""BACKOFFmax%umin%u"" , offset , seq ) ) ;  opts_len -= 12 ;  break ; case PGM_OPT_REDIRECT : bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET :  if ( opt_len != 4 + sizeof ( struct in_addr ) ) {  ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u!=4+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ;  opts_len -= 4 + sizeof ( struct in_addr ) ;  break ; case AFNUM_INET6 :  if ( opt_len != 4 + sizeof ( struct in6_addr ) ) {  ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u!=4+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ;  opts_len -= 4 + sizeof ( struct in6_addr ) ;  break ; default : goto trunc ; break ; }  ND_PRINT ( ( ndo , ""REDIRECT%s"" , nla_buf ) ) ;  break ;  case PGM_OPT_PARITY_PRM :   if ( opt_len != 8 ) {  ND_PRINT ( ( ndo , ""[BadOPT_PARITY_PRMoption,length%u!=8]"" , opt_len ) ) ; return ; }  bp += 2 ;  len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""PARITYMAXTGS%u"" , len ) ) ;  opts_len -= 8 ;  break ; case PGM_OPT_PARITY_GRP :  if ( opt_len != 8 ) {  ND_PRINT ( ( ndo , ""[BadOPT_PARITY_GRPoption,length%u!=8]"" , opt_len ) ) ; return ; }  bp += 2 ;  seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""PARITYGROUP%u"" , seq ) ) ;  opts_len -= 8 ;  break ; case PGM_OPT_CURR_TGSIZE : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[BadOPT_CURR_TGSIZEoption,length%u!=8]"" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""PARITYATGS%u"" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NBR_UNREACH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_NBR_UNREACHoption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""NBR_UNREACH"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""PATH_NLA[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_SYNoption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""SYN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_FIN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_FINoption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""FIN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_RST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_RSToption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""RST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_CRQSToption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""CRQST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PGMCC_DATA : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""PGMCCDATA%u%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""PGMCCFEEDBACK%u%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""OPT_%02X[%d]"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }"," case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 )  ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_LENGTHoption,length%u!=%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""OPTSLEN(extra?)%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_FRAGMENToption,length%u!=%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN  ) ) ;  return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""FRAGseq%uoff%ulen%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""NAKLIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Optionlengthnotamultipleof4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4  ; opts_len -=  -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 )  if ( opt_len  ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_JOINoption,length%u!=%u]"" , opt_len , PGM_OPT_JOIN_LEN  ) ) ;  ; bp += 4 ; ND_PRINT ( ( ndo , ""JOIN%u"" , seq  ) ) ;  ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 )  if ( opt_len  if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_NAK_BO_IVLoption,length%u!=%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN  ) ) ;  return ; } bp += 2 ; offset =  EXTRACT_32BITS ( bp  ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""BACKOFFivl%uivlseq%u"" , offset , seq )  ) ; opts_len  ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 )  if ( opt_len  ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_NAK_BO_RNGoption,length%u!=%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN  ) ) ;  += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ;  ; bp += 4 ; ND_PRINT ( ( ndo , ""BACKOFFmax%umin%u"" , offset  , seq )  ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 )  if ( opt_len  if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u<%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u!=%u+addresssize]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN  ) ) ;  return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr  ) ; opts_len  ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6  : if (  ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u!=%u+addresssize]"" , PGM_OPT_REDIRECT_FIXED_LEN  , opt_len )  return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr  ) ; opts_len  ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""REDIRECT%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 )  if ( opt_len  ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_PARITY_PRMoption,length%u!=%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""PARITYMAXTGS%u"" , len )  ) ; opts_len  ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 )  if ( opt_len  ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_PARITY_GRPoption,length%u!=%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""PARITYGROUP%u"" , seq )  ) ; opts_len  ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_CURR_TGSIZEoption,length%u!=%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""PARITYATGS%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_NBR_UNREACHoption,length%u!=%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""PATH_NLA[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_SYNoption,length%u!=%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_FINoption,length%u!=%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_RSToption,length%u!=%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_CRQSToption,length%u!=%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u<%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=%u+addresssize]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=%u+addresssize]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN  + sizeof (  ( ndo , ""PGMCCDATA%u%s"" , offset  , nla_buf )  break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 )  if ( opt_len  if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[BadPGM_OPT_PGMCC_FEEDBACKoption,length%u<%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_FEEDBACKoption,length%u!=%u+addresssize]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN  ) ) ;  return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr  ) ; opts_len  ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6  : if (  ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_FEEDBACKoption,length%u!=%u+addresssize]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN  ) ) ;  return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr  ) ; opts_len  ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN  + sizeof ("
213,CWE-415  static void cancel_att_send_op ( struct att_send_op * op )  { if ( op -> destroy ) op -> destroy ( op -> user_data ) ; op -> user_data = NULL ; op -> callback = NULL ; op -> destroy = NULL ; }, void cancel_att_send_op ( void * data ) {  att_send_op * op = data ;  if ( op
214,"CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) {  for ( i = 0 ; i < sec -> size ; i += 4 ) {  ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else {  for ( i = 0 ; i < sec -> size ; i += 8 ) {  ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }", = 0 ; ( i + 3 )  < sec ->  = 0 ; ( i + 7 )  < sec ->
215,"CWE-190 void nw_cache_free ( nw_cache * cache , void * obj ) { if ( cache -> free < cache -> free_total ) { cache -> free_arr [ cache -> free ++ ] = obj ;  } else {  uint32_t new_free_total = cache -> free_total * 2 ; void * new_arr = realloc ( cache -> free_arr , new_free_total * sizeof ( void * ) ) ; if ( new_arr ) { cache -> free_total = new_free_total ; cache -> free_arr = new_arr ; cache -> free_arr [ cache -> free ++ ] = obj ; } else { free ( obj ) ; }  }  }", ; } else if ( cache -> free_total < NW_CACHE_MAX_SIZE )  ; } } else { free ( obj ) ; }
216,"CWE-787 static int jpc_dec_tileinit ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { jpc_dec_tcomp_t * tcomp ; int compno ; int rlvlno ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; jpc_dec_prc_t * prc ; int bndno ; jpc_tsfb_band_t * bnd ; int bandno ; jpc_dec_ccp_t * ccp ; int prccnt ; jpc_dec_cblk_t * cblk ; int cblkcnt ; uint_fast32_t tlprcxstart ; uint_fast32_t tlprcystart ; uint_fast32_t brprcxend ; uint_fast32_t brprcyend ; uint_fast32_t tlcbgxstart ; uint_fast32_t tlcbgystart ; uint_fast32_t brcbgxend ; uint_fast32_t brcbgyend ; uint_fast32_t cbgxstart ; uint_fast32_t cbgystart ; uint_fast32_t cbgxend ; uint_fast32_t cbgyend ; uint_fast32_t tlcblkxstart ; uint_fast32_t tlcblkystart ; uint_fast32_t brcblkxend ; uint_fast32_t brcblkyend ; uint_fast32_t cblkxstart ; uint_fast32_t cblkystart ; uint_fast32_t cblkxend ; uint_fast32_t cblkyend ; uint_fast32_t tmpxstart ; uint_fast32_t tmpystart ; uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ;  jpc_tsfb_band_t bnds [ 64 ] ;  jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ; cp = tile -> cp ; tile -> realmode = 0 ; if ( cp -> mctid == JPC_MCT_ICT ) { tile -> realmode = 1 ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { ccp = & tile -> cp -> ccps [ compno ] ; if ( ccp -> qmfbid == JPC_COX_INS ) { tile -> realmode = 1 ; } tcomp -> numrlvls = ccp -> numrlvls ; if ( ! ( tcomp -> rlvls = jas_alloc2 ( tcomp -> numrlvls , sizeof ( jpc_dec_rlvl_t ) ) ) ) { return - 1 ; } if ( ! ( tcomp -> data = jas_seq2d_create ( JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) , JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) , JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) , JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ) ) ) { return - 1 ; } if ( ! ( tcomp -> tsfb = jpc_cod_gettsfb ( ccp -> qmfbid , tcomp -> numrlvls - 1 ) ) ) { return - 1 ; } { jpc_tsfb_getbands ( tcomp -> tsfb , jas_seq2d_xstart ( tcomp -> data ) , jas_seq2d_ystart ( tcomp -> data ) , jas_seq2d_xend ( tcomp -> data ) , jas_seq2d_yend ( tcomp -> data ) , bnds ) ; } for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { rlvl -> bands = 0 ; rlvl -> xstart = JPC_CEILDIVPOW2 ( tcomp -> xstart , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> ystart = JPC_CEILDIVPOW2 ( tcomp -> ystart , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> xend = JPC_CEILDIVPOW2 ( tcomp -> xend , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> yend = JPC_CEILDIVPOW2 ( tcomp -> yend , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> prcwidthexpn = ccp -> prcwidthexpns [ rlvlno ] ; rlvl -> prcheightexpn = ccp -> prcheightexpns [ rlvlno ] ; tlprcxstart = JPC_FLOORDIVPOW2 ( rlvl -> xstart , rlvl -> prcwidthexpn ) << rlvl -> prcwidthexpn ; tlprcystart = JPC_FLOORDIVPOW2 ( rlvl -> ystart , rlvl -> prcheightexpn ) << rlvl -> prcheightexpn ; brprcxend = JPC_CEILDIVPOW2 ( rlvl -> xend , rlvl -> prcwidthexpn ) << rlvl -> prcwidthexpn ; brprcyend = JPC_CEILDIVPOW2 ( rlvl -> yend , rlvl -> prcheightexpn ) << rlvl -> prcheightexpn ; rlvl -> numhprcs = ( brprcxend - tlprcxstart ) >> rlvl -> prcwidthexpn ; rlvl -> numvprcs = ( brprcyend - tlprcystart ) >> rlvl -> prcheightexpn ; rlvl -> numprcs = rlvl -> numhprcs * rlvl -> numvprcs ; if ( rlvl -> xstart >= rlvl -> xend || rlvl -> ystart >= rlvl -> yend ) { rlvl -> bands = 0 ; rlvl -> numprcs = 0 ; rlvl -> numhprcs = 0 ; rlvl -> numvprcs = 0 ; continue ; } if ( ! rlvlno ) { tlcbgxstart = tlprcxstart ; tlcbgystart = tlprcystart ; brcbgxend = brprcxend ; brcbgyend = brprcyend ; rlvl -> cbgwidthexpn = rlvl -> prcwidthexpn ; rlvl -> cbgheightexpn = rlvl -> prcheightexpn ; } else { tlcbgxstart = JPC_CEILDIVPOW2 ( tlprcxstart , 1 ) ; tlcbgystart = JPC_CEILDIVPOW2 ( tlprcystart , 1 ) ; brcbgxend = JPC_CEILDIVPOW2 ( brprcxend , 1 ) ; brcbgyend = JPC_CEILDIVPOW2 ( brprcyend , 1 ) ; rlvl -> cbgwidthexpn = rlvl -> prcwidthexpn - 1 ; rlvl -> cbgheightexpn = rlvl -> prcheightexpn - 1 ; } rlvl -> cblkwidthexpn = JAS_MIN ( ccp -> cblkwidthexpn , rlvl -> cbgwidthexpn ) ; rlvl -> cblkheightexpn = JAS_MIN ( ccp -> cblkheightexpn , rlvl -> cbgheightexpn ) ; rlvl -> numbands = ( ! rlvlno ) ? 1 : 3 ; if ( ! ( rlvl -> bands = jas_alloc2 ( rlvl -> numbands , sizeof ( jpc_dec_band_t ) ) ) ) { return - 1 ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { bndno = ( ! rlvlno ) ? 0 : ( 3 * ( rlvlno - 1 ) + bandno + 1 ) ; bnd = & bnds [ bndno ] ; band -> orient = bnd -> orient ; band -> stepsize = ccp -> stepsizes [ bndno ] ; band -> analgain = JPC_NOMINALGAIN ( ccp -> qmfbid , tcomp -> numrlvls - 1 , rlvlno , band -> orient ) ; band -> absstepsize = jpc_calcabsstepsize ( band -> stepsize , cmpt -> prec + band -> analgain ) ; band -> numbps = ccp -> numguardbits + JPC_QCX_GETEXPN ( band -> stepsize ) - 1 ; band -> roishift = ( ccp -> roishift + band -> numbps >= JPC_PREC ) ? ( JPC_PREC - 1 - band -> numbps ) : ccp -> roishift ; band -> data = 0 ; band -> prcs = 0 ; if ( bnd -> xstart == bnd -> xend || bnd -> ystart == bnd -> yend ) { continue ; } if ( ! ( band -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) { return - 1 ; } jas_seq2d_bindsub ( band -> data , tcomp -> data , bnd -> locxstart , bnd -> locystart , bnd -> locxend , bnd -> locyend ) ; jas_seq2d_setshift ( band -> data , bnd -> xstart , bnd -> ystart ) ; assert ( rlvl -> numprcs ) ; if ( ! ( band -> prcs = jas_alloc2 ( rlvl -> numprcs , sizeof ( jpc_dec_prc_t ) ) ) ) { return - 1 ; } cbgxstart = tlcbgxstart ; cbgystart = tlcbgystart ; for ( prccnt = rlvl -> numprcs , prc = band -> prcs ; prccnt > 0 ; -- prccnt , ++ prc ) { cbgxend = cbgxstart + ( 1 << rlvl -> cbgwidthexpn ) ; cbgyend = cbgystart + ( 1 << rlvl -> cbgheightexpn ) ; prc -> xstart = JAS_MAX ( cbgxstart , JAS_CAST ( uint_fast32_t , jas_seq2d_xstart ( band -> data ) ) ) ; prc -> ystart = JAS_MAX ( cbgystart , JAS_CAST ( uint_fast32_t , jas_seq2d_ystart ( band -> data ) ) ) ; prc -> xend = JAS_MIN ( cbgxend , JAS_CAST ( uint_fast32_t , jas_seq2d_xend ( band -> data ) ) ) ; prc -> yend = JAS_MIN ( cbgyend , JAS_CAST ( uint_fast32_t , jas_seq2d_yend ( band -> data ) ) ) ; if ( prc -> xend > prc -> xstart && prc -> yend > prc -> ystart ) { tlcblkxstart = JPC_FLOORDIVPOW2 ( prc -> xstart , rlvl -> cblkwidthexpn ) << rlvl -> cblkwidthexpn ; tlcblkystart = JPC_FLOORDIVPOW2 ( prc -> ystart , rlvl -> cblkheightexpn ) << rlvl -> cblkheightexpn ; brcblkxend = JPC_CEILDIVPOW2 ( prc -> xend , rlvl -> cblkwidthexpn ) << rlvl -> cblkwidthexpn ; brcblkyend = JPC_CEILDIVPOW2 ( prc -> yend , rlvl -> cblkheightexpn ) << rlvl -> cblkheightexpn ; prc -> numhcblks = ( brcblkxend - tlcblkxstart ) >> rlvl -> cblkwidthexpn ; prc -> numvcblks = ( brcblkyend - tlcblkystart ) >> rlvl -> cblkheightexpn ; prc -> numcblks = prc -> numhcblks * prc -> numvcblks ; assert ( prc -> numcblks > 0 ) ; if ( ! ( prc -> incltagtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) { return - 1 ; } if ( ! ( prc -> numimsbstagtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) { return - 1 ; } if ( ! ( prc -> cblks = jas_alloc2 ( prc -> numcblks , sizeof ( jpc_dec_cblk_t ) ) ) ) { return - 1 ; } cblkxstart = cbgxstart ; cblkystart = cbgystart ; for ( cblkcnt = prc -> numcblks , cblk = prc -> cblks ; cblkcnt > 0 ; ) { cblkxend = cblkxstart + ( 1 << rlvl -> cblkwidthexpn ) ; cblkyend = cblkystart + ( 1 << rlvl -> cblkheightexpn ) ; tmpxstart = JAS_MAX ( cblkxstart , prc -> xstart ) ; tmpystart = JAS_MAX ( cblkystart , prc -> ystart ) ; tmpxend = JAS_MIN ( cblkxend , prc -> xend ) ; tmpyend = JAS_MIN ( cblkyend , prc -> yend ) ; if ( tmpxend > tmpxstart && tmpyend > tmpystart ) { cblk -> firstpassno = - 1 ; cblk -> mqdec = 0 ; cblk -> nulldec = 0 ; cblk -> flags = 0 ; cblk -> numpasses = 0 ; cblk -> segs . head = 0 ; cblk -> segs . tail = 0 ; cblk -> curseg = 0 ; cblk -> numimsbs = 0 ; cblk -> numlenbits = 3 ; cblk -> flags = 0 ; if ( ! ( cblk -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) { return - 1 ; } jas_seq2d_bindsub ( cblk -> data , band -> data , tmpxstart , tmpystart , tmpxend , tmpyend ) ; ++ cblk ; -- cblkcnt ; } cblkxstart += 1 << rlvl -> cblkwidthexpn ; if ( cblkxstart >= cbgxend ) { cblkxstart = cbgxstart ; cblkystart += 1 << rlvl -> cblkheightexpn ; } } } else { prc -> cblks = 0 ; prc -> incltagtree = 0 ; prc -> numimsbstagtree = 0 ; } cbgxstart += 1 << rlvl -> cbgwidthexpn ; if ( cbgxstart >= brcbgxend ) { cbgxstart = tlcbgxstart ; cbgystart += 1 << rlvl -> cbgheightexpn ; } } } } } if ( ! ( tile -> pi = jpc_dec_pi_create ( dec , tile ) ) ) { return - 1 ; } for ( pchgno = 0 ; pchgno < jpc_pchglist_numpchgs ( tile -> cp -> pchglist ) ; ++ pchgno ) { pchg = jpc_pchg_copy ( jpc_pchglist_get ( tile -> cp -> pchglist , pchgno ) ) ; assert ( pchg ) ; jpc_pi_addpchg ( tile -> pi , pchg ) ; } jpc_pi_init ( tile -> pi ) ; return 0 ; }", jpc_tsfb_band_t bnds [ JPC_MAXBANDS  ] ; jpc_pchg_t
217,"CWE-399 static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ;  xen_netbk_idx_release ( netbk , pending_idx ) ;  } }"," netbk , pending_idx , XEN_NETIF_RSP_OKAY"
218,"CWE-436 static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ;  g_clear_object ( & client -> proxy ) ;  g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }"," client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE"
219,"CWE-119 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannotopenCSRfile!\\n"" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""couldnotreadfilelength!\\n"" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) {  if ( sscanf ( l_line , ""%u%u%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {  * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""couldnotallocatespdata!\\n"" ) ; return - 1 ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""couldnotcsrdescription!\\n"" ) ; return - 1 ; } } else { unsigned int l_row , l_column ; REALTYPE l_value ; if ( sscanf ( l_line , ""%u%u%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""couldnotreadelement!\\n"" ) ; return - 1 ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""wewerenotabletoreadallelements!\\n"" ) ; return - 1 ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } return 0 ; }"," { if ( 3 ==  , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count )  { * o_column_idx"
220,"CWE-476 int jp2_box_put ( jp2_box_t * box , jas_stream_t * out ) { jas_stream_t * tmpstream ; bool extlen ; bool dataflag ; tmpstream = 0 ; dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box , tmpstream ) ) { goto error ; } } box -> len = jas_stream_tell ( tmpstream ) + JP2_BOX_HDRLEN ( false ) ; jas_stream_rewind ( tmpstream ) ; } extlen = ( box -> len >= ( ( ( uint_fast64_t ) 1 ) << 32 ) ) != 0 ; if ( jp2_putuint32 ( out , extlen ? 1 : box -> len ) ) { goto error ; } if ( jp2_putuint32 ( out , box -> type ) ) { goto error ; } if ( extlen ) { if ( jp2_putuint64 ( out , box -> len ) ) { goto error ; } } if ( dataflag ) {  if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) {  goto error ; } jas_stream_close ( tmpstream ) ; } return 0 ; error : if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }"," ) ) { jas_eprintf ( ""cannotcopyboxdata\\n"" ) ;"
221,"CWE-119 int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , const uint8_t * source , int64_t time_stamp ) {  # if HAVE_NEON  int64_t dx_store_reg [ 8 ] ; # endif VP8_COMMON * cm = & pbi -> common ; int retcode = - 1 ;  pbi -> common . error . error_code = VPX_CODEC_OK ;  retcode = check_fragments_for_errors ( pbi ) ; if ( retcode <= 0 ) return retcode ;  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( dx_store_reg ) ; } # endif cm -> new_fb_idx = get_free_fb ( cm ) ; pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; if ( setjmp ( pbi -> common . error . jmp ) ) { cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; goto decode_exit ; } pbi -> common . error . setjmp = 1 ; retcode = vp8_decode_frame ( pbi ) ; if ( retcode < 0 ) { if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } if ( swap_frame_buffers ( cm ) ) { pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } vp8_clear_system_state ( ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; cm -> show_frame_mi = cm -> mi ; } # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_enabled && pbi -> common . prev_mi ) { MODE_INFO * tmp = pbi -> common . prev_mi ; int row , col ; pbi -> common . prev_mi = pbi -> common . mi ; pbi -> common . mi = tmp ; for ( row = 0 ; row < pbi -> common . mb_rows ; ++ row ) { for ( col = 0 ; col < pbi -> common . mb_cols ; ++ col ) { const int i = row * pbi -> common . mode_info_stride + col ; pbi -> common . mi [ i ] . mbmi . segment_id = pbi -> common . prev_mi [ i ] . mbmi . segment_id ; } } } # endif pbi -> ready_for_new_data = 0 ; pbi -> last_time_stamp = time_stamp ; decode_exit :  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( dx_store_reg ) ; } # endif pbi -> common . error . setjmp = 0 ;  return retcode ;  }", time_stamp ) {  VP8_COMMON * cm  - 1 ; ( void ) size ; ( void ) source ;  return retcode ;  cm -> new_fb_idx  ; decode_exit :  pbi -> common  = 0 ; vp8_clear_system_state ( ) ;
222,"CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; }  truncate_pagecache ( inode , ioffset ) ;   ext4_inode_block_unlocked_dio ( inode ) ;  inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ;  goto out_dio ;  } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ;  out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }", out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  ioffset ) ;  credits = ext4_writepage_trans_blocks  ) ; goto out_mmap  ; } inode  handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  ext4_inode_resume_unlocked_dio ( inode
223,"CWE-755 void AcpiNsTerminate ( void ) { ACPI_STATUS Status ;  ACPI_FUNCTION_TRACE ( NsTerminate ) ;  # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ;  ACPI_OPERAND_OBJECT * Next ;  Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; }  }  # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespacefreed\\n"" ) ) ; return_VOID ; }", ACPI_STATUS Status ;  ACPI_OPERAND_OBJECT * Prev  ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate )  ) ; }  AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode
224,"CWE-125 PyObject * ast2obj_withitem ( void * _o ) { withitem_ty o = ( withitem_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) {  Py_INCREF ( Py_None ) ;  return Py_None ; } result = PyType_GenericNew ( withitem_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> context_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_context_expr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> optional_vars ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_optional_vars , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }", o ) { Py_RETURN_NONE  ; } result
225,"CWE-20 void LineTo ( double x1 , double y1 ) {  outpos +=  sprintf ( outpos , ""\\n%12.3f%12.3fl"" , x1 , y1 ) ;  } "," y1 ) { sprintf ( outputbuffer  , ""\\n%12.3f%12.3fl"" ,  y1 ) ; sendClean ( outputbuffer ) ;"
226,"CWE-20 error_t dm9000UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint8_t hashTable [ 8 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""UpdatingMACfilter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; hashTable [ 7 ] = 0x80 ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = dm9000CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = crc & 0x3F ; hashTable [ k / 8 ] |= ( 1 << ( k % 8 ) ) ; } } for ( i = 0 ; i < 8 ; i ++ ) {  dm9000WriteReg ( DM9000_REG_MAR0 + i , hashTable [ i ] ) ;  } TRACE_DEBUG ( ""MAR=%02"" PRIX8 ""%02"" PRIX8 ""%02"" PRIX8 ""%02"" PRIX8 """" ""%02"" PRIX8 ""%02"" PRIX8 ""%02"" PRIX8 ""%02"" PRIX8 ""\\r\\n"" ,  dm9000ReadReg ( DM9000_REG_MAR0 ) , dm9000ReadReg ( DM9000_REG_MAR1 ) ,  dm9000ReadReg ( DM9000_REG_MAR2 ) , dm9000ReadReg ( DM9000_REG_MAR3 ) , dm9000ReadReg ( DM9000_REG_MAR4 ) , dm9000ReadReg ( DM9000_REG_MAR5 ) , dm9000ReadReg ( DM9000_REG_MAR6 ) , dm9000ReadReg ( DM9000_REG_MAR7 ) ) ; return NO_ERROR ; }"," { dm9000WriteReg ( DM9000_MAR0  + i ,  , dm9000ReadReg ( DM9000_MAR0 ) , dm9000ReadReg ( DM9000_MAR1 ) , dm9000ReadReg ( DM9000_MAR2 ) , dm9000ReadReg ( DM9000_MAR3 ) , dm9000ReadReg ( DM9000_MAR4 ) , dm9000ReadReg ( DM9000_MAR5 ) , dm9000ReadReg ( DM9000_MAR6 ) , dm9000ReadReg ( DM9000_MAR7  ) ) ;"
227,"CWE-19 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ;  }  retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ;  if ( args -> rmtblkno ) {  error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }", -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ;  -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
228,"CWE-125 static const char *  parse_field ( netdissect_options * ndo , const char * * pptr , int * len )  { const char * s ;  if ( * len <= 0 || ! pptr || ! * pptr )  return NULL ; if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ; s = * pptr ;  while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {  ( * pptr ) ++ ; ( * len ) -- ; } ( * pptr ) ++ ; ( * len ) -- ;  if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend )  return NULL ; return s ; }"," int * len , int * truncated  * s ;  s = *  * pptr ; for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST (  * * pptr  * pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; }  ( * pptr  ) -- ;  return s ;"
229,"CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ;  size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE ,  CORE_MMU_USER_PARAM_SIZE ) ;  if ( ADD_OVERFLOW ( uaddr , len , & a ) )  return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ;  for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) {  uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }"," uaddr_t a ; uaddr_t end_addr = 0 ;  len , & end_addr  ) ) return  ( a = ROUNDDOWN ( uaddr , addr_incr )  ; a <  ; a < end_addr  ; a +="
230,"CWE-119 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( ""%s:metadataisnull!"" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = ""camera_metadata"" , . alignment = METADATA_ALIGNMENT } , { . name = ""camera_metadata_buffer_entry"" , . alignment = ENTRY_ALIGNMENT } , { . name = ""camera_metadata_data"" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( ""%s:Metadatapointerisnotaligned(actual%p,"" ""expected%p)totype%s"" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( ""%s:Metadatasize(%"" PRIu32 "")shouldbe<=expectedsize(%zu)"" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( ""%s:Entrycount(%"" PRIu32 "")shouldbe<=entrycapacity"" ""(%"" PRIu32 "")"" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; } const metadata_uptrdiff_t entries_end = metadata -> entries_start + metadata -> entry_capacity ; if ( entries_end < metadata -> entries_start || entries_end > metadata -> data_start ) { ALOGE ( ""%s:Entrystart+capacity(%"" PRIu32 "")shouldbe<=datastart"" ""(%"" PRIu32 "")"" , __FUNCTION__ , ( metadata -> entries_start + metadata -> entry_capacity ) , metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = metadata -> data_start + metadata -> data_capacity ; if ( data_end < metadata -> data_start || data_end > metadata -> size ) { ALOGE ( ""%s:Datastart+capacity(%"" PRIu32 "")shouldbe<=totalsize"" ""(%"" PRIu32 "")"" , __FUNCTION__ , ( metadata -> data_start + metadata -> data_capacity ) , metadata -> size ) ; return ERROR ; } const metadata_size_t entry_count = metadata -> entry_count ; camera_metadata_buffer_entry_t * entries = get_entries ( metadata ) ; for ( size_t i = 0 ; i < entry_count ; ++ i ) { if ( ( uintptr_t ) & entries [ i ] != ALIGN_TO ( & entries [ i ] , ENTRY_ALIGNMENT ) ) { ALOGE ( ""%s:Entryindex%zuhadbadalignment(address%p),"" ""expectedalignment%zu"" , __FUNCTION__ , i , & entries [ i ] , ENTRY_ALIGNMENT ) ; return ERROR ; } camera_metadata_buffer_entry_t entry = entries [ i ] ; if ( entry . type >= NUM_TYPES ) { ALOGE ( ""%s:Entryindex%zuhadabadtype%d"" , __FUNCTION__ , i , entry . type ) ; return ERROR ; } uint32_t tag_section = entry . tag >> 16 ; int tag_type = get_camera_metadata_tag_type ( entry . tag ) ; if ( tag_type != ( int ) entry . type && tag_section < VENDOR_SECTION ) { ALOGE ( ""%s:Entryindex%zuhadtagtype%d,butthetypewas%d"" , __FUNCTION__ , i , tag_type , entry . type ) ; return ERROR ; }  size_t data_size =  calculate_camera_metadata_entry_data_size ( entry . type ,  entry . count ) ;  if ( data_size != 0 ) { camera_metadata_data_t * data = ( camera_metadata_data_t * ) ( get_data ( metadata ) + entry . data . offset ) ; if ( ( uintptr_t ) data != ALIGN_TO ( data , DATA_ALIGNMENT ) ) { ALOGE ( ""%s:Entryindex%zuhadbaddataalignment(address%p),"" ""expectedalign%zu,(tagname%s,datasize%zu)"" , __FUNCTION__ , i , data , DATA_ALIGNMENT , get_camera_metadata_tag_name ( entry . tag ) ? : ""unknown"" , data_size ) ; return ERROR ; } size_t data_entry_end = entry . data . offset + data_size ; if ( data_entry_end < entry . data . offset || data_entry_end > metadata -> data_capacity ) { ALOGE ( ""%s:Entryindex%zudataends(%zu)beyondthecapacity"" ""%"" PRIu32 , __FUNCTION__ , i , data_entry_end , metadata -> data_capacity ) ; return ERROR ; } } else if ( entry . count == 0 ) { if ( entry . data . offset != 0 ) { ALOGE ( ""%s:Entryindex%zuhad0items,butoffsetwasnon-0"" ""(%"" PRIu32 ""),tagname:%s"" , __FUNCTION__ , i , entry . data . offset , get_camera_metadata_tag_name ( entry . tag ) ? : ""unknown"" ) ; return ERROR ; } } } return OK ; }"," } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size ,  entry . type  . count ) != OK ) { ALOGE ( ""%s:Entrydatasizeisinvalid.type:%ucount:%u"" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; }  if ( data_size"
231,"CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , ""ubikcall%s"" , tok2str ( ubik_req , ""op#%d"" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , ""syncsite%s"" , temp ? ""yes"" : ""no"" ) ) ; ND_PRINT ( ( ndo , ""votestart"" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , ""dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , ""site"" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , ""tid"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , ""tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""pos"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""length"" ) ) ; INTOUT ( ) ;  temp = EXTRACT_32BITS ( bp ) ;  bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , ""type%d"" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , ""tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""pos"" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , ""file"" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , ""file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""length"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""dbversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , ""tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""file"" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , ""length"" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , ""tid"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""oldversion"" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , ""newversion"" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , ""[|ubik]"" ) ) ; }", ( ) ; ND_TCHECK_32BITS ( bp ) ;
232,"CWE-190  static char * mongo_data_append ( char * start , const void * data , int len ) {  memcpy ( start , data , len ) ; return start + len ; }"," * data , size_t  len ) {"
233,"CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ;  mmu_notifier_mm_init ( mm ) ;  init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }"," p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;"
234,"CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) {  * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ;  if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ; } if ( nc >= 'A' && nc <= 'F' ) { ec |= nc - ( 'A' - 10 ) ; continue ; } return - EINVAL ; } * op ++ = ec & 0xFF ; * op ++ = ec >> 8 ; ip += 5 ; i += 5 ; } else { if ( ( charlen = nls -> char2uni ( ip , len - i , ( wchar_t * ) op ) ) < 0 ) return - EINVAL ; ip += charlen ; i += charlen ; op += 2 ; } } if ( i < len ) return - ENAMETOOLONG ; } else { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; i ++ , * outlen += 1 ) { * op ++ = * ip ++ ; * op ++ = 0 ; } if ( i < len ) return - ENAMETOOLONG ; } } * longlen = * outlen ; if ( * outlen % 13 ) { * op ++ = 0 ; * op ++ = 0 ; * outlen += 1 ; if ( * outlen % 13 ) { fill = 13 - ( * outlen % 13 ) ; for ( i = 0 ; i < fill ; i ++ ) { * op ++ = 0xff ; * op ++ = 0xff ; } * outlen += fill ; } } return 0 ; }"," , len , UTF16_HOST_ENDIAN ,  * ) outname , FAT_LFN_LEN + 2"
235,"CWE-119 vpx_codec_err_t vpx_svc_init ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * enc_cfg ) {  int max_intra_size_pct ;  vpx_codec_err_t res ;  SvcInternal * const si = get_svc_internal ( svc_ctx ) ;  if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || enc_cfg == NULL ) { return VPX_CODEC_INVALID_PARAM ; } if ( si == NULL ) return VPX_CODEC_MEM_ERROR ; si -> codec_ctx = codec_ctx ; si -> width = enc_cfg -> g_w ; si -> height = enc_cfg -> g_h ; if ( enc_cfg -> kf_max_dist < 2 ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""keyframedistancetoosmall:%d\\n"" , enc_cfg -> kf_max_dist ) ; return VPX_CODEC_INVALID_PARAM ; } si -> kf_dist = enc_cfg -> kf_max_dist ; if ( svc_ctx -> spatial_layers == 0 ) svc_ctx -> spatial_layers = VPX_SS_DEFAULT_LAYERS ; if ( svc_ctx -> spatial_layers < 1 || svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""spatiallayers:invalidvalue:%d\\n"" , svc_ctx -> spatial_layers ) ; return VPX_CODEC_INVALID_PARAM ; }  res = parse_quantizer_values ( svc_ctx , si -> quantizers , 0 ) ;  if ( res != VPX_CODEC_OK ) return res ;  res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ;  if ( res != VPX_CODEC_OK )  memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ;  res = parse_scale_factors ( svc_ctx , si -> scale_factors ) ; if ( res != VPX_CODEC_OK ) return res ;  res = parse_options ( svc_ctx , si -> options ) ;  if ( res != VPX_CODEC_OK ) return res ; si -> layers = svc_ctx -> spatial_layers ; if ( si -> layers > 1 ) { int i ; float total = 0 ; float alloc_ratio [ VPX_SS_MAX_LAYERS ] = { 0 } ; assert ( si -> layers <= VPX_SS_MAX_LAYERS ) ; for ( i = 0 ; i < si -> layers ; ++ i ) { int pos = i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ; if ( pos < VPX_SS_MAX_LAYERS && si -> scaling_factor_den [ pos ] > 0 ) { alloc_ratio [ i ] = ( float ) ( si -> scaling_factor_num [ pos ] * 1.0 / si -> scaling_factor_den [ pos ] ) ; alloc_ratio [ i ] *= alloc_ratio [ i ] ; total += alloc_ratio [ i ] ; } } for ( i = 0 ; i < si -> layers ; ++ i ) { if ( total > 0 ) { enc_cfg -> ss_target_bitrate [ i ] = ( unsigned int ) ( enc_cfg -> rc_target_bitrate * alloc_ratio [ i ] / total ) ; } } } enc_cfg -> ss_number_layers = si -> layers ; enc_cfg -> ts_number_layers = 1 ; enc_cfg -> kf_mode = VPX_KF_DISABLED ; enc_cfg -> g_lag_in_frames = 0 ; enc_cfg -> rc_dropframe_thresh = 0 ; enc_cfg -> rc_end_usage = VPX_CBR ; enc_cfg -> rc_resize_allowed = 0 ; if ( enc_cfg -> g_pass == VPX_RC_ONE_PASS ) { enc_cfg -> rc_min_quantizer = 33 ; enc_cfg -> rc_max_quantizer = 33 ; } enc_cfg -> rc_undershoot_pct = 100 ; enc_cfg -> rc_overshoot_pct = 15 ; enc_cfg -> rc_buf_initial_sz = 500 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; enc_cfg -> g_error_resilient = 1 ;  res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ;  if ( res != VPX_CODEC_OK ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc_enc_initerror\\n"" ) ; return res ; }  vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ;  vpx_codec_control ( codec_ctx , VP8E_SET_CPUUSED , 1 ) ; vpx_codec_control ( codec_ctx , VP8E_SET_STATIC_THRESHOLD , 1 ) ; vpx_codec_control ( codec_ctx , VP8E_SET_NOISE_SENSITIVITY , 1 ) ; vpx_codec_control ( codec_ctx , VP8E_SET_TOKEN_PARTITIONS , 1 ) ; max_intra_size_pct = ( int ) ( ( ( double ) enc_cfg -> rc_buf_optimal_sz * 0.5 ) * ( ( double ) enc_cfg -> g_timebase . den / enc_cfg -> g_timebase . num ) / 10.0 ) ; vpx_codec_control ( codec_ctx , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct ) ; return VPX_CODEC_OK ; }"," enc_cfg ) {  vpx_codec_err_t res ;  vpx_codec_err_t res ; int i ; SvcInternal_t  * const si  VPX_CODEC_INVALID_PARAM ; } if ( svc_ctx -> temporal_layering_mode == 3 ) { svc_ctx -> temporal_layers = 3 ; } else if ( svc_ctx -> temporal_layering_mode == 2 ) { svc_ctx -> temporal_layers = 2 ; } for ( i = 0 ; i < VPX_SS_MAX_LAYERS ; ++ i ) { si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ; si -> svc_params . min_quantizers [ i ] = 0 ; si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ; si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ; } res = parse_options ( svc_ctx , si -> options  ) ; if  return res ; if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ; if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ; if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""spatiallayers*temporallayersexceedsthemaximumnumberof"" ""allowedlayersof%d\\n"" , svc_ctx -> spatial_layers * svc_ctx -> temporal_layers , ( int ) VPX_MAX_LAYERS ) ; return VPX_CODEC_INVALID_PARAM ; } assign_layer_bitrates ( svc_ctx , enc_cfg ) ; # if CONFIG_SPATIAL_SVC for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ; # endif if ( svc_ctx -> temporal_layers > 1 ) { int i ; for ( i = 0 ; i < svc_ctx -> temporal_layers ; ++ i ) { enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ; enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ; } } if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ; enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ; enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ; if ( enc_cfg -> rc_end_usage == VPX_CBR ) { enc_cfg -> rc_resize_allowed = 0 ; enc_cfg -> rc_min_quantizer = 2 ; enc_cfg -> rc_max_quantizer = 63 ; enc_cfg -> rc_undershoot_pct = 50 ; enc_cfg -> rc_overshoot_pct = 50 ; enc_cfg -> rc_buf_initial_sz = 20 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; } if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ; res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR  ) ; if  != VPX_CODEC_OK ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc_enc_initerror\\n"" ) ;  return res ;  return res ; } vpx_codec_control  ( codec_ctx ,  ( codec_ctx , VP9E_SET_SVC , 1 ) ;  vpx_codec_control ( codec_ctx  ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & si -> svc_params  ) ; return"
236,"CWE-125 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t )  ldblk , sizeof ( * BImgBuff ) ) ;  if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }", size_t ) ldblk + 1
237,"CWE-264 int _mkp_stage_30 ( struct plugin * p , struct client_session * cs , struct session_request * sr ) { mk_ptr_t referer ; ( void ) p ; ( void ) cs ; PLUGIN_TRACE ( ""[FD%i]MandrilvalidatingURL"" , cs -> socket ) ;  if ( mk_security_check_url ( sr -> uri ) < 0 ) {  PLUGIN_TRACE ( ""[FD%i]Closeconnection,blockedURL"" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } PLUGIN_TRACE ( ""[FD%d]Mandrilvalidatinghotlinking"" , cs -> socket ) ; referer = mk_api -> header_get ( & sr -> headers_toc , ""Referer"" , strlen ( ""Referer"" ) ) ; if ( mk_security_check_hotlink ( sr -> uri_processed , sr -> host , referer ) < 0 ) { PLUGIN_TRACE ( ""[FD%i]Closeconnection,denyhotlinking."" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } return MK_PLUGIN_RET_NOT_ME ; }", ( sr -> uri_processed  ) < 0
238,"CWE-400 static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof ) {  char * ksep , * vsep , * val ;  size_t klen , vlen ; size_t new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; }  vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ;  if ( ! vsep ) {  if ( ! eof ) {  return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = """" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ;  return 1 ;  }"," { char * start , *  0 ; } start = var -> ptr + var -> already_scanned ;  = memchr ( start  , '&' ,  -> end - start  ) ; if  eof ) { var -> already_scanned = var -> end - var -> ptr ;  end ) ; var -> already_scanned = 0 ;"
239,"CWE-22 void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = """" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , ""/"" ) ) { if ( access ( ""WikiHome"" , R_OK ) != 0 ) wiki_redirect ( res , ""/WikiHome?create"" ) ; page = ""/WikiHome"" ; } if ( ! strcmp ( page , ""/styles.css"" ) ) { http_response_set_content_type ( res , ""text/css"" ) ; http_response_printf ( res , ""%s"" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , ""/favicon.ico"" ) ) { http_response_set_content_type ( res , ""image/ico"" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , ""api/"" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; }  if ( strchr ( page , '/' ) )  { http_response_set_status ( res , 404 , ""NotFound"" ) ; http_response_printf ( res , ""<html><body>404NotFound</body></html>\\n"" ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , ""Changes"" ) ) { wiki_show_changes_page ( res ) ; } else if ( ! strcmp ( page , ""ChangesRss"" ) ) { wiki_show_changes_page_rss ( res ) ; } else if ( ! strcmp ( page , ""Search"" ) ) { wiki_show_search_results_page ( res , http_request_param_get ( req , ""expr"" ) ) ; } else if ( ! strcmp ( page , ""Create"" ) ) { if ( ( wikitext = http_request_param_get ( req , ""title"" ) ) != NULL ) { wiki_redirect ( res , http_request_param_get ( req , ""title"" ) ) ; } else { wiki_show_create_page ( res ) ; } } else { if ( ( wikitext = http_request_param_get ( req , ""wikitext"" ) ) != NULL ) { file_write ( page , wikitext ) ; } if ( access ( page , R_OK ) == 0 ) { wikitext = file_read ( page ) ; if ( ! strcmp ( command , ""edit"" ) ) { wiki_show_edit_page ( res , wikitext , page ) ; } else { wiki_show_page ( res , wikitext , page ) ; } } else { if ( ! strcmp ( command , ""create"" ) ) { wiki_show_edit_page ( res , NULL , page ) ; } else { char buf [ 1024 ] ; snprintf ( buf , 1024 , ""%s?create"" , page ) ; wiki_redirect ( res , buf ) ; } } } }", } if ( ! page_name_is_good ( page  ) ) {
240,"CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ;  entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ;  if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }"," ; entries = kmalloc_array ( cmap -> len ,  sizeof ( *  * entries ) ,  GFP_KERNEL ) ;"
241,CWE-119 const char * vpx_svc_get_message ( const SvcContext * svc_ctx ) {  const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;  if ( svc_ctx == NULL || si == NULL ) return NULL ; return si -> message_buffer ; }, ) { const SvcInternal_t  * const si
242,"CWE-264 static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ;  int procfd = payload -> procfd ;  lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ;  uid_t new_uid ;  gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""errorusingIPCtoreceivenotificationfrominitialprocess(0)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""couldnotensurecorrectarchitecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""couldnotdropprivileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""couldnotsetinitialenvironmentforattachedprocess"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unabletosetsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unabletoTIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switchingtocontainergid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switchingtocontaineruid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) {  ERROR ( ""errorusingIPCtonotifyinitialprocessforinitialization(1)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) {  ERROR ( ""errorusingIPCtoreceivefinalnotificationfrominitialprocess(2)"" ) ;  shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVScouldnotbeset."" ""Processcanuseexecve()gainable"" ""privileges."" ) ;  rexit ( - 1 ) ;  } INFO ( ""PR_SET_NO_NEW_PRIVSisset.Processcannotuseexecve()""  ""gainableprivileges."" ) ;  } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ;  on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;   if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {   rexit ( - 1 ) ;  } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loadingseccomppolicy"" ) ;  rexit ( - 1 ) ;  } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""UnabletoclearCLOEXECfromfd"" ) ; }  close ( procfd ) ;  rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }"," -> ipc_socket ;  lxc_attach_options_t * options  int fd ; int lsm_labelfd ;  { ERROR ( ""ErrorusingIPCtoreceivenotificationfrominitialprocess(0):%s."" , strerror ( errno )  ) ; shutdown  { ERROR ( ""ErrorusingIPCtonotifyinitialprocessforinitialization(1):%s."" , strerror ( errno )  ) ; shutdown  { ERROR ( ""ErrorusingIPCtoreceivemessagefrominitialprocess"" ""thatitisdonepre-initializing(2):%s"" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; }  if ( (  ""privileges."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ;  ( ""PR_SET_NO_NEW_PRIVSisset.Processcannotuseexecve()"" ""gainableprivileges."" ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""ErrorusingIPCtotellparenttosetupLSMlabels(3):%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1  int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""ErrorusingIPCforparenttotellusLSMlabelfd(4):%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; }  ( lsm_set_label_at ( lsm_labelfd  , on_exec ,  0 ) { SYSERROR ( ""FailedtosetLSMlabel."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ;  } if (  ""Loadingseccomppolicy"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ;  lxc_proc_put_context_info ( init_ctx  ) ; }  rexit ( payload"
243,"CWE-119  int64_t vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x ,   const TileInfo * const tile ,  int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize ) { MACROBLOCKD * xd = & x -> e_mbd ;  MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;  struct macroblock_plane * const p = & x -> plane [ 0 ] ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;  MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ;   MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ;  INTERP_FILTER best_pred_filter = EIGHTTAP ; int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , VP9_ALT_FLAG } ;  int64_t best_rd = INT64_MAX ;  int64_t this_rd = INT64_MAX ; int rate = INT_MAX ; int64_t dist = INT64_MAX ; VP9_COMMON * cm = & cpi -> common ;  int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ;  const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv ,  intra_cost_penalty , 0 ) ;  const int64_t intra_mode_cost = 50 ; unsigned char segment_id = mbmi -> segment_id ;  const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ;   const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ;  int mode_idx [ MB_MODE_COUNT ] = { 0 } ;  INTERP_FILTER filter_ref = SWITCHABLE ;  x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; x -> skip = 0 ; if ( ! x -> in_active_map ) x -> skip = 1 ; * returnrate = INT_MAX ; * returndistortion = INT64_MAX ; vpx_memset ( mbmi , 0 , sizeof ( MB_MODE_INFO ) ) ; mbmi -> sb_type = bsize ; mbmi -> ref_frame [ 0 ] = NONE ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; mbmi -> interp_filter = cpi -> common . interp_filter == SWITCHABLE ?  EIGHTTAP : cpi -> common . interp_filter ;  mbmi -> skip = 0 ;  mbmi -> segment_id = segment_id ;  for ( ref_frame = LAST_FRAME ; ref_frame <= LAST_FRAME ; ++ ref_frame ) { x -> pred_mv_sad [ ref_frame ] = INT_MAX ; if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { vp9_setup_buffer_inter ( cpi , x , tile , ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ; } frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; } if ( xd -> up_available ) filter_ref = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; else if ( xd -> left_available ) filter_ref = xd -> mi [ - 1 ] -> mbmi . interp_filter ;  for ( ref_frame = LAST_FRAME ; ref_frame <= LAST_FRAME ; ++ ref_frame ) {   if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) )  continue ;  xd -> plane [ 0 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 0 ] ;  clamp_mv2 ( & frame_mv [ NEARESTMV ] [ ref_frame ] . as_mv , xd ) ; clamp_mv2 ( & frame_mv [ NEARMV ] [ ref_frame ] . as_mv , xd ) ; mbmi -> ref_frame [ 0 ] = ref_frame ;  if ( ref_frame == LAST_FRAME ) {  mode_idx [ NEARESTMV ] = THR_NEARESTMV ; mode_idx [ NEARMV ] = THR_NEARMV ; mode_idx [ ZEROMV ] = THR_ZEROMV ; mode_idx [ NEWMV ] = THR_NEWMV ; } for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { int rate_mv = 0 ; if ( cpi -> sf . disable_inter_mode_mask [ bsize ] &  ( 1 << INTER_OFFSET ( this_mode ) ) )  continue ; if ( best_rd < ( ( int64_t ) rd_threshes [ mode_idx [ this_mode ] ] * rd_thresh_freq_fact [ this_mode ] >> 5 ) || rd_threshes [ mode_idx [ this_mode ] ] == INT_MAX ) continue ; if ( this_mode == NEWMV ) {  int rate_mode = 0 ;   if ( this_rd < ( int64_t ) ( 1 << num_pels_log2_lookup [ bsize ] ) )  continue ; full_pixel_motion_search ( cpi , x , tile , bsize , mi_row , mi_col ,  & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv ) ;   if ( frame_mv [ NEWMV ] [ ref_frame ] . as_int == INVALID_MV )  continue ; rate_mode = x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ; if ( RDCOST ( x -> rdmult , x -> rddiv , rate_mv + rate_mode , 0 ) > best_rd ) continue ; sub_pixel_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv ) ; }  if ( this_mode != NEARESTMV )  if ( frame_mv [ this_mode ] [ ref_frame ] . as_int == frame_mv [ NEARESTMV ] [ ref_frame ] . as_int ) continue ; mbmi -> mode = this_mode ;  mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ;  if ( ( this_mode == NEWMV || filter_ref == SWITCHABLE ) &&  ( ( mbmi -> mv [ 0 ] . as_mv . row & 0x07 ) != 0 ||  ( mbmi -> mv [ 0 ] . as_mv . col & 0x07 ) != 0 ) ) { int64_t tmp_rdcost1 = INT64_MAX ; int64_t tmp_rdcost2 = INT64_MAX ; int64_t tmp_rdcost3 = INT64_MAX ; int pf_rate [ 3 ] ; int64_t pf_dist [ 3 ] ;  mbmi -> interp_filter = EIGHTTAP ;  vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ;  model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP ] ,   & pf_dist [ EIGHTTAP ] ) ;  tmp_rdcost1 = RDCOST ( x -> rdmult , x -> rddiv ,  vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP ] ,  pf_dist [ EIGHTTAP ] ) ; mbmi -> interp_filter = EIGHTTAP_SHARP ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SHARP ] , & pf_dist [ EIGHTTAP_SHARP ] ) ; tmp_rdcost2 = RDCOST ( x -> rdmult , x -> rddiv , vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP_SHARP ] , pf_dist [ EIGHTTAP_SHARP ] ) ; mbmi -> interp_filter = EIGHTTAP_SMOOTH ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SMOOTH ] , & pf_dist [ EIGHTTAP_SMOOTH ] ) ; tmp_rdcost3 = RDCOST ( x -> rdmult , x -> rddiv , vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP_SMOOTH ] , pf_dist [ EIGHTTAP_SMOOTH ] ) ; if ( tmp_rdcost2 < tmp_rdcost1 ) { if ( tmp_rdcost2 < tmp_rdcost3 ) mbmi -> interp_filter = EIGHTTAP_SHARP ; else mbmi -> interp_filter = EIGHTTAP_SMOOTH ; } else { if ( tmp_rdcost1 < tmp_rdcost3 ) mbmi -> interp_filter = EIGHTTAP ; else mbmi -> interp_filter = EIGHTTAP_SMOOTH ; } rate = pf_rate [ mbmi -> interp_filter ] ; dist = pf_dist [ mbmi -> interp_filter ] ; } else { mbmi -> interp_filter = ( filter_ref == SWITCHABLE ) ? EIGHTTAP : filter_ref ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ;  model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ;  } rate += rate_mv ;  rate += x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ]  [ INTER_OFFSET ( this_mode ) ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ; if ( this_rd < best_rd ) { best_rd = this_rd ; * returnrate = rate ; * returndistortion = dist ; best_mode = this_mode ; best_pred_filter = mbmi -> interp_filter ;  best_ref_frame = ref_frame ;   }  } } mbmi -> mode = best_mode ; mbmi -> interp_filter = best_pred_filter ;  mbmi -> ref_frame [ 0 ] = best_ref_frame ;  mbmi -> mv [ 0 ] . as_int = frame_mv [ best_mode ] [ best_ref_frame ] . as_int ; xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = mbmi -> mv [ 0 ] . as_int ;  if ( best_rd > inter_mode_thresh ) {  for ( this_mode = DC_PRED ; this_mode <= DC_PRED ; ++ this_mode ) {  vp9_predict_intra_block ( xd , 0 , b_width_log2 ( bsize ) ,  mbmi -> tx_size , this_mode , & p -> src . buf [ 0 ] , p -> src . stride , & pd -> dst . buf [ 0 ] , pd -> dst . stride , 0 , 0 , 0 ) ; model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ; rate += x -> mbmode_cost [ this_mode ] ;  rate += intra_cost_penalty ;   this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;   if ( this_rd + intra_mode_cost < best_rd ) {  best_rd = this_rd ; * returnrate = rate ; * returndistortion = dist ; mbmi -> mode = this_mode ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> uv_mode = this_mode ; mbmi -> mv [ 0 ] . as_int = INVALID_MV ; } } } return INT64_MAX ; }","    void  vp9_pick_inter_mode ( VP9_COMP  * x , TileDataEnc * tile_data , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; SPEED_FEATURES * const sf = & cpi -> sf ;  TileInfo * const  TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCKD * const  xd = &  ; MB_MODE_INFO * const  ] -> mbmi  ; struct macroblockd_plane  0 ] ; PREDICTION_MODE  best_mode = ZEROMV  best_ref_frame = LAST_FRAME ; MV_REFERENCE_FRAME usable_ref_frame ; TX_SIZE best_tx_size = TX_SIZES  VP9_ALT_FLAG } ; RD_COST this_rdc , best_rdc ; uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ; unsigned int var_y = UINT_MAX ; unsigned int sse_y = UINT_MAX ; const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ; const  int intra_cost_penalty =  int intra_cost_penalty = vp9_get_intra_cost_penalty (  cm -> base_qindex  cm -> y_dc_delta_q , cm -> bit_depth ) >> reduction_fac  ; const int64_t  , 0 )  ; const int  = cpi -> rd . threshes [ mbmi ->  segment_id ] [  const rd_thresh_freq_fact = tile_data -> thresh_freq_fact  [ bsize ]  [ bsize ]  ; INTERP_FILTER filter_ref  ; INTERP_FILTER filter_ref ; const int bsl = mi_width_log2_lookup [ bsize ] ; const int pred_filter_search = cm ->  interp_filter == SWITCHABLE  == SWITCHABLE ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int const_motion [ MAX_REF_FRAMES ] = { 0 } ; const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ; const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ; PRED_BUFFER tmp [ 4 ] ; DECLARE_ALIGNED ( 16 , uint8_t , pred_buf [ 3 * 64 * 64 ] ) ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , pred_buf_16 [ 3 * 64 * 64 ] ) ; # endif struct buf_2d orig_dst = pd -> dst ; PRED_BUFFER * best_pred = NULL ; PRED_BUFFER * this_mode_pred = NULL ; const int pixels_in_block = bh * bw ; int reuse_inter_pred = cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ; int ref_frame_skip_mask = 0 ; int idx ; int best_pred_sad = INT_MAX ; int best_early_term = 0 ; int ref_frame_cost [ MAX_REF_FRAMES ] ; init_ref_frame_cost ( cm , xd , ref_frame_cost ) ; if ( reuse_inter_pred ) { int i ; for ( i = 0 ; i < 3 ; i ++ ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) tmp [ i ] . data = CONVERT_TO_BYTEPTR ( & pred_buf_16 [ pixels_in_block * i ] ) ; else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # endif tmp [ i ] . stride = bw ; tmp [ i ] . in_use = 0 ; } tmp [ 3 ] . data = pd -> dst . buf ; tmp [ 3 ] . stride = pd -> dst . stride ; tmp [ 3 ] . in_use = 0 ; } x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; x  -> skip =  = 0 ;  if ( xd  . interp_filter ; else filter_ref = cm -> interp_filter ; vp9_rd_cost_reset ( & best_rdc ) ; vp9_rd_cost_reset ( rd_cost ) ; mbmi -> sb_type = bsize ; mbmi -> ref_frame [ 0 ] = NONE ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ; # if CONFIG_VP9_TEMPORAL_DENOISING vp9_denoiser_reset_frame_stats ( ctx ) ; # endif if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) { usable_ref_frame = LAST_FRAME ; } else { usable_ref_frame = GOLDEN_FRAME ; }  ; ref_frame <= usable_ref_frame  ; ++ ref_frame  ref_frame ) { const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ; x -> pred_mv_sad [ ref_frame ] = INT_MAX ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) { int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ; const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ; vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ; if ( cm -> use_prev_frame_mvs ) vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col , NULL , NULL , x -> mbmi_ext -> mode_context ) ; else const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col ) ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ;  if ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ; } else { ref_frame_skip_mask |= ( 1 << ref_frame ) ; } } for ( idx = 0 ; idx < RT_INTER_MODES ; ++ idx ) { int rate_mv = 0 ; int mode_rd_thresh ; int mode_index ; int i ; int64_t this_sse ; int is_skippable ; int this_early_term = 0 ; PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ; if ( cpi -> use_svc ) this_mode = ref_mode_set_svc [ idx ] . pred_mode ; if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ; ref_frame = ref_mode_set [ idx ] . ref_frame ; if ( cpi -> use_svc ) ref_frame = ref_mode_set_svc [ idx ] . ref_frame ; if ( !  ) continue ; if ( const_motion [ ref_frame ] && this_mode == NEARMV ) continue ; i =  ( ref_frame ==  == LAST_FRAME ) ? GOLDEN_FRAME : LAST_FRAME ; if ( ( cpi -> ref_frame_flags & flag_list [ i ] ) && sf -> reference_masking ) if ( x -> pred_mv_sad [ ref_frame ] > ( x -> pred_mv_sad [ i ] << 1 ) ) ref_frame_skip_mask |=  ( 1 <<  ( 1 << ref_frame ) ; if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) continue ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; mbmi -> ref_frame [ 0 ] = ref_frame ; set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; mode_index = mode_idx [ ref_frame ] [  ( this_mode ) ] ; mode_rd_thresh = best_mode_skip_txfm ? rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] )  ) continue ;  NEWMV ) { if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) { int tmp_sad ; int dis , cost_list [ 5 ] ; if ( bsize < BLOCK_16X16 ) continue ; tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) continue ; if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] << 4 ) > best_pred_sad ) continue ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = mbmi -> mv [ 0 ] . as_int ; rate_mv = vp9_mv_bit_cost ( & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . row >>= 3 ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . col >>= 3 ; cpi -> find_fractional_mv_step ( x , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr  [ bsize ]  [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ; } else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rdc . rdcost ) ) { continue ; } } if ( this_mode == NEWMV && ref_frame == LAST_FRAME && frame_mv [ NEWMV ] [ LAST_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ; } if ( cpi -> use_svc ) { if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME &&  frame_mv [ NEWMV  NEWMV ] [ GOLDEN_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf +  ( frame_mv [  NEWMV ] [ GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ; }  } if (  this_mode != NEARESTMV &&  frame_mv [ this_mode  . as_int ; if ( reuse_inter_pred ) { if ( ! this_mode_pred ) { this_mode_pred = & tmp [ 3 ] ; } else { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = bw ; } }  SWITCHABLE ) && pred_filter_search && ( ref_frame == LAST_FRAME || ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) && (  as_mv . row | mbmi -> mv [ 0 ] . as_mv . col )  ) != 0 ) ) {  int pf_rate [  3 ] ; unsigned int pf_var [ 3 ] ; unsigned int pf_sse [ 3 ] ; TX_SIZE pf_tx_size [ 3 ] ; int64_t best_cost = INT64_MAX ; INTERP_FILTER best_filter = SWITCHABLE , filter ; PRED_BUFFER * current_pred = this_mode_pred ; for ( filter = EIGHTTAP ; filter <= EIGHTTAP_SMOOTH ; ++ filter ) { int64_t cost ;  -> interp_filter = filter  ; vp9_build_inter_predictors_sby (  & pf_rate [ filter ] ,  & pf_dist [  & pf_dist [ filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ; pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ; cost  = RDCOST (  -> rddiv , pf_rate [ filter ] , pf_dist [ filter ] ) ; pf_tx_size [ filter ] = mbmi -> tx_size ; if ( cost < best_cost ) { best_filter = filter ; best_cost = cost ; skip_txfm = x -> skip_txfm [ 0 ] ; if ( reuse_inter_pred ) { if ( this_mode_pred != current_pred ) { free_pred_buffer ( this_mode_pred ) ; this_mode_pred = current_pred ; } if ( filter < EIGHTTAP_SHARP ) { current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = current_pred -> data ; pd -> dst . stride = bw ; } } } } if ( reuse_inter_pred && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ; mbmi -> interp_filter = best_filter ; mbmi -> tx_size = pf_tx_size [ best_filter ] ; this_rdc . rate = pf_rate [ best_filter ] ; this_rdc . dist = pf_dist [ best_filter ] ; var_y = pf_var [ best_filter ] ; sse_y = pf_sse [ best_filter ] ; x -> skip_txfm [ 0 ] = skip_txfm ; if ( reuse_inter_pred ) { pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = this_mode_pred -> stride ; }  } else {  bsize ) ; if ( bsize > BLOCK_32X32 && ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && cm -> base_qindex ) { model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . rate , & this_rdc . dist , & var_y , & sse_y , mi_row , mi_col , & this_early_term ) ; } else {  xd , & this_rdc .  rate , & this_rdc . dist , & var_y , & sse_y ) ; } } if ( ! this_early_term ) { this_sse = ( int64_t ) sse_y ; block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ; x -> skip_txfm [ 0 ] = is_skippable ; if ( is_skippable ) { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } else { if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) { this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } else { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; this_rdc . dist = this_sse ; x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } } if ( cm -> interp_filter == SWITCHABLE ) { if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ; } } else { this_rdc . rate += cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ; this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) { int uv_rate = 0 ; int64_t uv_dist = 0 ; if ( x -> color_sensitivity [ 0 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ; if ( x -> color_sensitivity [ 1 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ; model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , & var_y , & sse_y ) ; this_rdc . rate += uv_rate ; this_rdc . dist += uv_dist ; } this_rdc .  rate += rate_mv  += rate_mv ; this_rdc . rate += cpi  -> inter_mode_cost [  -> inter_mode_cost [ x -> mbmi_ext -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ; this_rdc . rate += ref_frame_cost [ ref_frame ] ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( cpi -> allow_encode_breakout ) { encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , var_y , sse_y , yv12_mb , & this_rdc . rate , & this_rdc . dist ) ; if ( x -> skip ) { this_rdc . rate += rate_mv ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; } } # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ; # else ( void ) ctx ; # endif if ( this_rdc . rdcost < best_rdc . rdcost || x -> skip ) { best_rdc = this_rdc  ; best_mode =  -> interp_filter ; best_tx_size = mbmi -> tx_size ;  = ref_frame ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; best_early_term = this_early_term ; if ( reuse_inter_pred ) { free_pred_buffer ( best_pred ) ; best_pred = this_mode_pred ; } } else { if ( reuse_inter_pred ) free_pred_buffer ( this_mode_pred ) ; } if ( x -> skip ) break ; if ( best_early_term && idx > 0 ) { x -> skip = 1 ; break ;  } } mbmi  ; mbmi -> tx_size = best_tx_size ; mbmi ->  . as_int ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( best_rdc . rdcost == INT64_MAX || ( ! x -> skip && best_rdc . rdcost > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) ) { struct estimate_block_intra_args args = { cpi , x , DC_PRED , 0 , 0 } ; const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; int i ; TX_SIZE best_intra_tx_size = TX_SIZES ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data == orig_dst . buf ) { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif best_pred = this_mode_pred ; } } pd -> dst = orig_dst ; for ( i = 0 ; i < 4 ; ++ i ) { const PREDICTION_MODE this_mode = intra_mode_list [ i ] ; THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ; int mode_rd_thresh = rd_threshes [ mode_index ] ; if ( ! ( ( 1 << this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) continue ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ; mbmi -> mode = this_mode ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; args . mode = this_mode ; args . rate = 0 ; args . dist = 0 ; mbmi -> tx_size = intra_tx_size ; vp9_foreach_transformed_block_in_plane  ( xd ,  ( xd , bsize , 0 , estimate_block_intra , & args ) ; this_rdc . rate = args . rate ; this_rdc . dist = args . dist ; this_rdc . rate += cpi  -> mbmode_cost [  this_mode ] ; this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ; this_rdc .  += intra_cost_penalty ; this_rdc . rdcost  = RDCOST (  -> rddiv , this_rdc . rate , this_rdc .  dist ) ;  ; if ( this_rdc . rdcost < best_rdc . rdcost ) { best_rdc = this_rdc ; best_mode = this_mode ; best_intra_tx_size = mbmi -> tx_size ; best_ref_frame = INTRA_FRAME ; mbmi -> uv_mode = this_mode ; mbmi -> mv [ 0 ] . as_int = INVALID_MV ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; } } if ( best_ref_frame != INTRA_FRAME ) { mbmi -> tx_size = best_tx_size ; } else { mbmi -> tx_size = best_intra_tx_size ; } } pd -> dst = orig_dst ; mbmi -> mode = best_mode ; mbmi -> ref_frame [ 0 ] = best_ref_frame ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif } } if ( cpi -> sf . adaptive_rd_thresh ) { THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ; if ( best_ref_frame == INTRA_FRAME ) { int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ; int i ; for ( i = 0 ; i < intra_modes ; i ++ ) { update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , best_mode_idx , intra_mode_list [ i ] ) ; } } else { for ( ref_frame = LAST_FRAME ; ref_frame <= GOLDEN_FRAME ; ++ ref_frame ) { PREDICTION_MODE this_mode ; if ( best_ref_frame != ref_frame ) continue ; for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , best_mode_idx , this_mode ) ; } } } } * rd_cost = best_rdc  ; } "
244,"CWE-320 int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ;  int r ;  if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ;  for ( ; ; ) {  if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }"," ; int r , dontmax = 0  return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;"
245,"CWE-190 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) )  timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ;  remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }", -> it_overrun +=  kc -> timer_forward
246,"CWE-254 void impeg2d_flush_ext_and_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ;  while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE )  { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ;  while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }", ; while ( (  u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )  ) != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
247,"CWE-119 static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else {  return rold -> umin_value == 0 &&  rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range > rcur -> range ) return false ; if ( rold -> off != rcur -> off ) return false ; if ( rold -> id && ! check_ids ( rold -> id , rcur -> id , idmap ) ) return false ; return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_CTX : case CONST_PTR_TO_MAP : case PTR_TO_STACK : case PTR_TO_PACKET_END : default : return false ; } WARN_ON_ONCE ( 1 ) ; return false ; }", else { return false  ; } case
248,"CWE-200 static void copy_to_user_state ( struct xfrm_state * x , struct xfrm_usersa_info * p ) {  memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ;  memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & x -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & x -> curlft , sizeof ( p -> curlft ) ) ; memcpy ( & p -> stats , & x -> stats , sizeof ( p -> stats ) ) ; memcpy ( & p -> saddr , & x -> props . saddr , sizeof ( p -> saddr ) ) ; p -> mode = x -> props . mode ; p -> replay_window = x -> props . replay_window ; p -> reqid = x -> props . reqid ; p -> family = x -> props . family ; p -> flags = x -> props . flags ; p -> seq = x -> km . seq ; }"," p ) { memset ( p , 0 , sizeof ( * p ) ) ;"
249,"CWE-000 int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < hlen ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; return - ENOMEM ; } __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ;  ipv6_select_ident ( fh ) ;  fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; frag_id = fh -> identification ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next != NULL ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; dst_release ( & rt -> dst ) ; return 0 ; } while ( frag ) { skb = frag -> next ; kfree_skb ( frag ) ; frag = skb ; } IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; dst_release ( & rt -> dst ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; * prevhdr = NEXTHDR_FRAGMENT ; while ( left > 0 ) { len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } if ( ( frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + LL_ALLOCATED_SPACE ( rt -> dst . dev ) , GFP_ATOMIC ) ) == NULL ) { NETDEBUG ( KERN_INFO ""IPv6:frag:nomemoryfornewfragment!\\n"" ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , LL_RESERVED_SPACE ( rt -> dst . dev ) ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) {  ipv6_select_ident ( fh ) ;  frag_id = fh -> identification ; } else fh -> identification = frag_id ; if ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) BUG ( ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; kfree_skb ( skb ) ; return err ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }"," ipv6_select_ident ( fh , rt  ipv6_select_ident ( fh , rt"
250,"CWE-287 CMD_FUNC ( m_authenticate ) { aClient * agent_p = NULL ; if ( ! SASL_SERVER || ! MyConnect ( sptr ) || BadPtr ( parv [ 1 ] ) || ! CHECKPROTO ( sptr , PROTO_SASL ) ) return 0 ; if ( sptr -> local -> sasl_complete ) { sendto_one ( sptr , err_str ( ERR_SASLALREADY ) , me . name , BadPtr ( sptr -> name ) ? ""*"" : sptr -> name ) ; return 0 ; }  if ( strlen ( parv [ 1 ] ) > 400 )  { sendto_one ( sptr , err_str ( ERR_SASLTOOLONG ) , me . name , BadPtr ( sptr -> name ) ? ""*"" : sptr -> name ) ; return 0 ; } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent , NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip ) ? ""0"" : sptr -> ip ; char * certfp = moddata_client_get ( sptr , ""certfp"" ) ; sendto_server ( NULL , 0 , 0 , "":%sSASL%s%sH%s%s"" , me . name , SASL_SERVER , encode_puid ( sptr ) , addr , addr ) ; if ( certfp ) sendto_server ( NULL , 0 , 0 , "":%sSASL%s%sS%s%s"" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] , certfp ) ; else sendto_server ( NULL , 0 , 0 , "":%sSASL%s%sS%s"" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] ) ; } else sendto_server ( NULL , 0 , 0 , "":%sSASL%s%sC%s"" , me . name , AGENT_SID ( agent_p ) , encode_puid ( sptr ) , parv [ 1 ] ) ; sptr -> local -> sasl_out ++ ; return 0 ; }"," } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalidparameter"" ) ; return 0 ; } if ("
251,"CWE-399  void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }"," perf_event * bp  , struct perf_sample_data"
252,"CWE-74 gboolean flatpak_run_add_environment_args ( FlatpakBwrap * bwrap , const char * app_info_path , FlatpakRunFlags flags , const char * app_id , FlatpakContext * context , GFile * app_id_dir , GPtrArray * previous_app_id_dirs , FlatpakExports * * exports_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autoptr ( FlatpakBwrap ) proxy_arg_bwrap = flatpak_bwrap_new ( flatpak_bwrap_empty_env ) ; gboolean has_wayland = FALSE ; gboolean allow_x11 = FALSE ; if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_IPC ) == 0 ) { g_debug ( ""Disallowingipcaccess"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-ipc"" , NULL ) ; } if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) == 0 ) { g_debug ( ""Disallowingnetworkaccess"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-net"" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_ALL ) { flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev"" , ""/dev"" , NULL ) ; if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_DIR ) ) { if ( ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) == 0 ) flatpak_bwrap_add_args ( bwrap , ""--tmpfs"" , ""/dev/shm"" , NULL ) ; } else if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_SYMLINK ) ) { g_autofree char * link = flatpak_readlink ( ""/dev/shm"" , NULL ) ; if ( g_strcmp0 ( link , ""/run/shm"" ) == 0 ) { if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM && g_file_test ( ""/run/shm"" , G_FILE_TEST_IS_DIR ) ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , ""/run/shm"" , ""/run/shm"" , NULL ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/run/shm"" , NULL ) ; } else g_warning ( ""Unexpected/dev/shmsymlink%s"" , link ) ; } } else { flatpak_bwrap_add_args ( bwrap , ""--dev"" , ""/dev"" , NULL ) ; if ( context -> devices & FLATPAK_CONTEXT_DEVICE_DRI ) { g_debug ( ""Allowingdriaccess"" ) ; int i ; char * dri_devices [ ] = { ""/dev/dri"" , ""/dev/mali"" , ""/dev/mali0"" , ""/dev/umplock"" , ""/dev/nvidiactl"" , ""/dev/nvidia-modeset"" , ""/dev/nvidia-uvm"" , ""/dev/nvidia-uvm-tools"" , } ; for ( i = 0 ; i < G_N_ELEMENTS ( dri_devices ) ; i ++ ) { if ( g_file_test ( dri_devices [ i ] , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , dri_devices [ i ] , dri_devices [ i ] , NULL ) ; } char nvidia_dev [ 14 ] ; for ( i = 0 ; i < 20 ; i ++ ) { g_snprintf ( nvidia_dev , sizeof ( nvidia_dev ) , ""/dev/nvidia%d"" , i ) ; if ( g_file_test ( nvidia_dev , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , nvidia_dev , nvidia_dev , NULL ) ; } } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_KVM ) { g_debug ( ""Allowingkvmaccess"" ) ; if ( g_file_test ( ""/dev/kvm"" , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev/kvm"" , ""/dev/kvm"" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) { g_autofree char * real_dev_shm = realpath ( ""/dev/shm"" , NULL ) ; g_debug ( ""Allowing/dev/shmaccess(as%s)"" , real_dev_shm ) ; if ( real_dev_shm != NULL ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , real_dev_shm , ""/dev/shm"" , NULL ) ; } } flatpak_context_append_bwrap_filesystem ( context , bwrap , app_id , app_id_dir , previous_app_id_dirs , & exports ) ; if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND ) { g_debug ( ""Allowingwaylandaccess"" ) ; has_wayland = flatpak_run_add_wayland_args ( bwrap ) ; } if ( ( context -> sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11 ) != 0 ) allow_x11 = ! has_wayland ; else allow_x11 = ( context -> sockets & FLATPAK_CONTEXT_SOCKET_X11 ) != 0 ; flatpak_run_add_x11_args ( bwrap , allow_x11 ) ; if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH ) { flatpak_run_add_ssh_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO ) { g_debug ( ""Allowingpulseaudioaccess"" ) ; flatpak_run_add_pulseaudio_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PCSC ) { flatpak_run_add_pcsc_args ( bwrap ) ; } if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_CUPS ) { flatpak_run_add_cups_args ( bwrap ) ; } flatpak_run_add_session_dbus_args ( bwrap , proxy_arg_bwrap , context , flags , app_id ) ; flatpak_run_add_system_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; flatpak_run_add_a11y_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ;  if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL )  { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""LD_LIBRARY_PATH"" , g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) , NULL ) ; flatpak_bwrap_unset_env ( bwrap , ""LD_LIBRARY_PATH"" ) ; } if ( g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) != NULL ) { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""TMPDIR"" , g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) , NULL ) ; flatpak_bwrap_unset_env ( bwrap , ""TMPDIR"" ) ; } if ( ! flatpak_run_in_transient_unit ( app_id , & my_error ) ) { g_debug ( ""Failedtorunintransientscope:%s"" , my_error -> message ) ; g_clear_error ( & my_error ) ; } if ( ! flatpak_bwrap_is_empty ( proxy_arg_bwrap ) && ! start_dbus_proxy ( bwrap , proxy_arg_bwrap , app_info_path , error ) ) return FALSE ; if ( exports_out ) * exports_out = g_steal_pointer ( & exports ) ; return TRUE ; }", ; if (  ! flatpak_run_in_transient_unit (
253,"CWE-200 static mode_t set_umask ( const char * optarg ) { long umask_long ; mode_t umask_val ; char * endptr ; umask_long = strtoll ( optarg , & endptr , 0 ) ; if ( * endptr || umask_long < 0 || umask_long & ~ 0777L ) { fprintf ( stderr , ""Invalid--umaskoption%s"" , optarg ) ;  return ;  } umask_val = umask_long & 0777 ; umask ( umask_val ) ; umask_cmdline = true ; return umask_val ; }", ) ; return 0
254,"CWE-617 krb5_error_code kdc_process_s4u2self_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_const_principal client_princ , krb5_const_principal header_srv_princ , krb5_boolean issuing_referral , const krb5_db_entry * server , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_timestamp kdc_time , krb5_pa_s4u_x509_user * * s4u_x509_user , krb5_db_entry * * princ_ptr , const char * * status ) { krb5_error_code code ; krb5_boolean is_local_tgt ; krb5_pa_data * pa_data ; int flags ; krb5_db_entry * princ ; * princ_ptr = NULL ; pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) ; if ( pa_data != NULL ) { code = kdc_process_s4u_x509_user ( kdc_context , request , pa_data , tgs_subkey , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else { pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_FOR_USER ) ; if ( pa_data != NULL ) { code = kdc_process_for_user ( kdc_active_realm , pa_data , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else return 0 ; } flags = 0 ; switch ( krb5_princ_type ( kdc_context , request -> server ) ) { case KRB5_NT_SRV_HST : if ( krb5_princ_size ( kdc_context , request -> server ) == 2 ) flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM ; break ; case KRB5_NT_ENTERPRISE_PRINCIPAL : flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE ; break ; default : break ; } if ( ! krb5_principal_compare_flags ( kdc_context , request -> server , client_princ , flags ) ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALIDASOPTIONS"" ; return KRB5KDC_ERR_BADOPTION ; } is_local_tgt = ! is_cross_tgs_principal ( header_srv_princ ) ; if ( is_local_tgt && issuing_referral ) { * status = ""LOOKING_UP_SERVER"" ; return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; } if ( is_local_principal ( kdc_active_realm , ( * s4u_x509_user ) -> user_id . user ) ) { krb5_db_entry no_server ; krb5_pa_data * * e_data = NULL ; if ( ! is_local_tgt && ! issuing_referral ) { * status = ""NOT_CROSS_REALM_REQUEST"" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } code = krb5_db_get_principal ( kdc_context , ( * s4u_x509_user ) -> user_id . user , KRB5_KDB_FLAG_INCLUDE_PAC , & princ ) ; if ( code == KRB5_KDB_NOENTRY ) { * status = ""UNKNOWN_S4U2SELF_PRINCIPAL"" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } else if ( code ) { * status = ""LOOKING_UP_S4U2SELF_PRINCIPAL"" ; return code ; } memset ( & no_server , 0 , sizeof ( no_server ) ) ;  code = validate_as_request ( kdc_active_realm , request , * princ ,  no_server , kdc_time , status , & e_data ) ; if ( code ) { krb5_db_free_principal ( kdc_context , princ ) ; krb5_free_pa_data ( kdc_context , e_data ) ; return code ; } * princ_ptr = princ ; } else if ( is_local_tgt ) { * status = ""S4U2SELF_CLIENT_NOT_OURS"" ; return KRB5KDC_ERR_POLICY ; } return 0 ; }"," ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;"
255,"CWE-119  static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) {   FRAME_CONTEXT * const fc = & cm -> fc ;  int i ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) for ( i = 0 ; i < COMP_INTER_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_inter_prob [ i ] ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) { vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 0 ] ) ; vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 1 ] ) ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_ref_prob [ i ] ) ; }"," * cm , vpx_reader  * r )  const fc =  cm -> fc"
256,"CWE-476 static int rfcomm_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) {  struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ;  struct sock * sk = sock -> sk ;  int chan = sa -> rc_channel ;   int err = 0 ;  BT_DBG ( ""sk%p%pMR"" , sk , & sa -> rc_bdaddr ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ;  lock_sock ( sk ) ;  if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_STREAM ) { err = - EINVAL ; goto done ; } write_lock ( & rfcomm_sk_list . lock ) ;  if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {  err = - EADDRINUSE ; } else {  bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;   rfcomm_pi ( sk ) -> channel = chan ;  sk -> sk_state = BT_BOUND ; } write_unlock ( & rfcomm_sk_list . lock ) ; done : release_sock ( sk ) ; return err ; }"," { struct sockaddr_rc sa  ; struct sock  sk ; int len ,  err = 0  err = 0  ; if (  - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( ""sk%p%pMR"" , sk , & sa . rc_bdaddr ) ;  ; if ( sa . rc_channel  && __rfcomm_get_listen_sock_by_addr (  && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa .  rc_bdaddr ) )  , & sa .  rc_bdaddr ) ;  -> channel = sa . rc_channel  ; sk ->"
257,"CWE-284 static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; ssize_t bit ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ;  switch ( quantum_info -> depth )  { case 1 : { register Quantum black , white ; black = 0 ; white = QuantumRange ; if ( quantum_info -> min_is_white != MagickFalse ) { black = QuantumRange ; white = 0 ; } for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 8 ) ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } case 4 : { register unsigned char pixel ; range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 1 ) ; x += 2 ) { pixel = ( unsigned char ) ( ( * p >> 4 ) & 0xf ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; pixel = ( unsigned char ) ( ( * p ) & 0xf ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) { pixel = ( unsigned char ) ( * p ++ >> 4 ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } case 8 : { unsigned char pixel ; if ( quantum_info -> min_is_white != MagickFalse ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushCharPixel ( p , & pixel ) ; SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushCharPixel ( p , & pixel ) ; SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 10 : { range = GetQuantumRange ( quantum_info -> depth ) ; if ( quantum_info -> pack == MagickFalse ) { if ( image -> endian == LSBEndian ) { for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x ++ < ( ssize_t ) number_pixels ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x ++ < ( ssize_t ) number_pixels ) { SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 12 : { range = GetQuantumRange ( quantum_info -> depth ) ; if ( quantum_info -> pack == MagickFalse ) { unsigned short pixel ; for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 1 ) ; x += 2 ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; q += GetPixelChannels ( image ) ; p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 16 : { unsigned short pixel ; if ( quantum_info -> min_is_white != MagickFalse ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } if ( quantum_info -> format == FloatingPointQuantumFormat ) { for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 32 : { unsigned int pixel ; if ( quantum_info -> format == FloatingPointQuantumFormat ) { float pixel ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushFloatPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; SetPixelGray ( image , ScaleLongToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } case 64 : { if ( quantum_info -> format == FloatingPointQuantumFormat ) { double pixel ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushDoublePixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } } default : { range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; } break ; } } }", MagickCoreSignature ) ; pixel = 0 ;
258,"CWE-20 key_ref_t lookup_user_key ( key_serial_t id , unsigned long lflags , key_perm_t perm ) { struct keyring_search_context ctx = { . match_data . cmp = lookup_user_key_possessed , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_NO_STATE_CHECK , } ; struct request_key_auth * rka ; struct key * key ; key_ref_t key_ref , skey_ref ; int ret ; try_again : ctx . cred = get_current_cred ( ) ; key_ref = ERR_PTR ( - ENOKEY ) ; switch ( id ) { case KEY_SPEC_THREAD_KEYRING : if ( ! ctx . cred -> thread_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_thread_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> thread_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_PROCESS_KEYRING : if ( ! ctx . cred -> process_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_process_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> process_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_SESSION_KEYRING : if ( ! ctx . cred -> session_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; if ( lflags & KEY_LOOKUP_CREATE ) ret = join_session_keyring ( NULL ) ; else ret = install_session_keyring ( ctx . cred -> user -> session_keyring ) ; if ( ret < 0 ) goto error ; goto reget_creds ; } else if ( ctx . cred -> session_keyring == ctx . cred -> user -> session_keyring && lflags & KEY_LOOKUP_CREATE ) { ret = join_session_keyring ( NULL ) ; if ( ret < 0 ) goto error ; goto reget_creds ; } rcu_read_lock ( ) ; key = rcu_dereference ( ctx . cred -> session_keyring ) ; __key_get ( key ) ; rcu_read_unlock ( ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_USER_KEYRING : if ( ! ctx . cred -> user -> uid_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; } key = ctx . cred -> user -> uid_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_USER_SESSION_KEYRING : if ( ! ctx . cred -> user -> session_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; } key = ctx . cred -> user -> session_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_GROUP_KEYRING : key_ref = ERR_PTR ( - EINVAL ) ; goto error ; case KEY_SPEC_REQKEY_AUTH_KEY : key = ctx . cred -> request_key_auth ; if ( ! key ) goto error ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_REQUESTOR_KEYRING : if ( ! ctx . cred -> request_key_auth ) goto error ; down_read ( & ctx . cred -> request_key_auth -> sem ) ; if ( test_bit ( KEY_FLAG_REVOKED , & ctx . cred -> request_key_auth -> flags ) ) { key_ref = ERR_PTR ( - EKEYREVOKED ) ; key = NULL ; } else { rka = ctx . cred -> request_key_auth -> payload . data [ 0 ] ; key = rka -> dest_keyring ; __key_get ( key ) ; } up_read ( & ctx . cred -> request_key_auth -> sem ) ; if ( ! key ) goto error ; key_ref = make_key_ref ( key , 1 ) ; break ; default : key_ref = ERR_PTR ( - EINVAL ) ; if ( id < 1 ) goto error ; key = key_lookup ( id ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error ; } key_ref = make_key_ref ( key , 0 ) ; ctx . index_key . type = key -> type ; ctx . index_key . description = key -> description ; ctx . index_key . desc_len = strlen ( key -> description ) ; ctx . match_data . raw_data = key ; kdebug ( ""checkpossessed"" ) ; skey_ref = search_process_keyrings ( & ctx ) ; kdebug ( ""possessed=%p"" , skey_ref ) ; if ( ! IS_ERR ( skey_ref ) ) { key_put ( key ) ; key_ref = skey_ref ; } break ; } if ( lflags & KEY_LOOKUP_FOR_UNLINK ) { ret = 0 ; goto error ; } if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) ) { ret = wait_for_key_construction ( key , true ) ; switch ( ret ) { case - ERESTARTSYS : goto invalid_key ; default : if ( perm ) goto invalid_key ; case 0 : break ; } } else if ( perm ) { ret = key_validate ( key ) ; if ( ret < 0 ) goto invalid_key ; } ret = - EIO ; if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) &&  ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  goto invalid_key ; ret = key_task_permission ( key_ref , ctx . cred , perm ) ; if ( ret < 0 ) goto invalid_key ; key -> last_used_at = current_kernel_time ( ) . tv_sec ; error : put_cred ( ctx . cred ) ; return key_ref ; invalid_key : key_ref_put ( key_ref ) ; key_ref = ERR_PTR ( ret ) ; goto error ; reget_creds : put_cred ( ctx . cred ) ; goto try_again ; }", KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED  ) goto invalid_key
259,"CWE-125 PyObject * ast2obj_expr ( void * _o ) { expr_ty o = ( expr_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) {  Py_INCREF ( Py_None ) ;  return Py_None ; } switch ( o -> kind ) { case BoolOp_kind : result = PyType_GenericNew ( BoolOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_boolop ( o -> v . BoolOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . BoolOp . values , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_values , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case BinOp_kind : result = PyType_GenericNew ( BinOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . BinOp . left ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_left , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . BinOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . BinOp . right ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_right , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case UnaryOp_kind : result = PyType_GenericNew ( UnaryOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_unaryop ( o -> v . UnaryOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . UnaryOp . operand ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_operand , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Lambda_kind : result = PyType_GenericNew ( Lambda_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_arguments ( o -> v . Lambda . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Lambda . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case IfExp_kind : result = PyType_GenericNew ( IfExp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . IfExp . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . IfExp . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . IfExp . orelse ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Dict_kind : result = PyType_GenericNew ( Dict_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Dict . keys , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keys , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Dict . values , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_values , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Set_kind : result = PyType_GenericNew ( Set_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Set . elts , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_elts , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ListComp_kind : result = PyType_GenericNew ( ListComp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . ListComp . elt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_elt , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ListComp . generators , ast2obj_comprehension ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_generators , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case SetComp_kind : result = PyType_GenericNew ( SetComp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . SetComp . elt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_elt , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . SetComp . generators , ast2obj_comprehension ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_generators , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case DictComp_kind : result = PyType_GenericNew ( DictComp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . DictComp . key ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_key , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . DictComp . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . DictComp . generators , ast2obj_comprehension ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_generators , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case GeneratorExp_kind : result = PyType_GenericNew ( GeneratorExp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . GeneratorExp . elt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_elt , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . GeneratorExp . generators , ast2obj_comprehension ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_generators , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Await_kind : result = PyType_GenericNew ( Await_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Await . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Yield_kind : result = PyType_GenericNew ( Yield_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Yield . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case YieldFrom_kind : result = PyType_GenericNew ( YieldFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . YieldFrom . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Compare_kind : result = PyType_GenericNew ( Compare_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Compare . left ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_left , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; { Py_ssize_t i , n = asdl_seq_LEN ( o -> v . Compare . ops ) ; value = PyList_New ( n ) ; if ( ! value ) goto failed ; for ( i = 0 ; i < n ; i ++ ) PyList_SET_ITEM ( value , i , ast2obj_cmpop ( ( cmpop_ty ) asdl_seq_GET ( o -> v . Compare . ops , i ) ) ) ; } if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ops , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Compare . comparators , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_comparators , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Call_kind : result = PyType_GenericNew ( Call_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Call . func ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_func , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Call . args , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Call . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Num_kind : result = PyType_GenericNew ( Num_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_object ( o -> v . Num . n ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_n , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Str_kind : result = PyType_GenericNew ( Str_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_string ( o -> v . Str . s ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_s , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . Str . kind ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_kind , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FormattedValue_kind : result = PyType_GenericNew ( FormattedValue_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . FormattedValue . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . FormattedValue . conversion ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_conversion , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FormattedValue . format_spec ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_format_spec , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case JoinedStr_kind : result = PyType_GenericNew ( JoinedStr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . JoinedStr . values , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_values , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Bytes_kind : result = PyType_GenericNew ( Bytes_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_bytes ( o -> v . Bytes . s ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_s , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case NameConstant_kind : result = PyType_GenericNew ( NameConstant_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_singleton ( o -> v . NameConstant . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Ellipsis_kind : result = PyType_GenericNew ( Ellipsis_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Constant_kind : result = PyType_GenericNew ( Constant_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_constant ( o -> v . Constant . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Attribute_kind : result = PyType_GenericNew ( Attribute_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Attribute . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> v . Attribute . attr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_attr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr_context ( o -> v . Attribute . ctx ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ctx , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Subscript_kind : result = PyType_GenericNew ( Subscript_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Subscript . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_slice ( o -> v . Subscript . slice ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_slice , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr_context ( o -> v . Subscript . ctx ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ctx , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Starred_kind : result = PyType_GenericNew ( Starred_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Starred . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr_context ( o -> v . Starred . ctx ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ctx , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Name_kind : result = PyType_GenericNew ( Name_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . Name . id ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_id , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr_context ( o -> v . Name . ctx ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ctx , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case List_kind : result = PyType_GenericNew ( List_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . List . elts , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_elts , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr_context ( o -> v . List . ctx ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ctx , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Tuple_kind : result = PyType_GenericNew ( Tuple_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Tuple . elts , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_elts , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr_context ( o -> v . Tuple . ctx ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_ctx , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }", o ) { Py_RETURN_NONE  ; } switch
260,"CWE-119 static vpx_codec_err_t vp8_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; unsigned int resolution_change = 0 ; unsigned int w , h ;  if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 )  return res ; w = ctx -> si . w ; h = ctx -> si . h ; res = vp8_peek_si_internal ( ctx -> fragments . ptrs [ 0 ] , ctx -> fragments . sizes [ 0 ] , & ctx -> si , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( ( res == VPX_CODEC_UNSUP_BITSTREAM ) && ! ctx -> si . is_kf ) { res = VPX_CODEC_OK ; } if ( ! ctx -> decoder_init && ! ctx -> si . is_kf ) res = VPX_CODEC_UNSUP_BITSTREAM ; if ( ( ctx -> si . h != h ) || ( ctx -> si . w != w ) ) resolution_change = 1 ;  if ( ! res && ctx -> defer_alloc )  { int i ; for ( i = 1 ; ! res && i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { vpx_codec_dec_cfg_t cfg ; cfg . w = ctx -> si . w ; cfg . h = ctx -> si . h ; ctx -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; ctx -> mmaps [ i ] . sz = vp8_mem_req_segs [ i ] . sz ; ctx -> mmaps [ i ] . align = vp8_mem_req_segs [ i ] . align ; ctx -> mmaps [ i ] . flags = vp8_mem_req_segs [ i ] . flags ; if ( ! ctx -> mmaps [ i ] . sz ) ctx -> mmaps [ i ] . sz = vp8_mem_req_segs [ i ] . calc_sz ( & cfg , ctx -> base . init_flags ) ; res = vpx_mmap_alloc ( & ctx -> mmaps [ i ] ) ; } if ( ! res ) vp8_finalize_mmaps ( ctx ) ; ctx -> defer_alloc = 0 ; }  if ( ! res && ! ctx -> decoder_init )  { res = vpx_validate_mmaps ( & ctx -> si , ctx -> mmaps , vp8_mem_req_segs , NELEMENTS ( vp8_mem_req_segs ) , ctx -> base . init_flags ) ; if ( ! res ) { VP8D_CONFIG oxcf ; oxcf . Width = ctx -> si . w ; oxcf . Height = ctx -> si . h ; oxcf . Version = 9 ; oxcf . postprocess = 0 ; oxcf . max_threads = ctx -> cfg . threads ; oxcf . error_concealment = ( ctx -> base . init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) ; if ( ! ctx -> postproc_cfg_set && ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) ) { ctx -> postproc_cfg . post_proc_flag = VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE ; ctx -> postproc_cfg . deblocking_level = 4 ; ctx -> postproc_cfg . noise_level = 0 ; } res = vp8_create_decoder_instances ( & ctx -> yv12_frame_buffers , & oxcf ) ;  ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ;   ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ;  } ctx -> decoder_init = 1 ; } if ( ! res ) { VP8D_COMP * pbi = ctx -> yv12_frame_buffers . pbi [ 0 ] ; if ( resolution_change ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; # if CONFIG_MULTITHREAD int i ; # endif pc -> Width = ctx -> si . w ; pc -> Height = ctx -> si . h ; { int prev_mb_rows = pc -> mb_rows ; if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ;  return - 1 ;  } pbi -> common . error . setjmp = 1 ; if ( pc -> Width <= 0 ) { pc -> Width = w ; vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalidframewidth"" ) ; } if ( pc -> Height <= 0 ) { pc -> Height = h ; vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalidframeheight"" ) ; } if ( vp8_alloc_frame_buffers ( pc , pc -> Width , pc -> Height ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , ""Failedtoallocateframebuffers"" ) ; xd -> pre = pc -> yv12_fb [ pc -> lst_fb_idx ] ; xd -> dst = pc -> yv12_fb [ pc -> new_fb_idx ] ; # if CONFIG_MULTITHREAD for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) { pbi -> mb_row_di [ i ] . mbd . dst = pc -> yv12_fb [ pc -> new_fb_idx ] ; vp8_build_block_doffsets ( & pbi -> mb_row_di [ i ] . mbd ) ; } # endif vp8_build_block_doffsets ( & pbi -> mb ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_enabled ) { pc -> prev_mip = vpx_calloc ( ( pc -> mb_cols + 1 ) * ( pc -> mb_rows + 1 ) , sizeof ( MODE_INFO ) ) ; if ( ! pc -> prev_mip ) { vp8_de_alloc_frame_buffers ( pc ) ; vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , ""Failedtoallocate"" ""lastframeMODE_INFOarray"" ) ; } pc -> prev_mi = pc -> prev_mip + pc -> mode_info_stride + 1 ; if ( vp8_alloc_overlap_lists ( pbi ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , ""Failedtoallocateoverlaplists"" ""forerrorconcealment"" ) ; } # endif # if CONFIG_MULTITHREAD if ( pbi -> b_multithreaded_rd ) vp8mt_alloc_temp_buffers ( pbi , pc -> Width , prev_mb_rows ) ; # else ( void ) prev_mb_rows ; # endif } pbi -> common . error . setjmp = 0 ; pbi -> common . fb_idx_ref_cnt [ 0 ] = 0 ; } pbi -> fragments = ctx -> fragments ; ctx -> user_priv = user_priv ; if ( vp8dx_receive_compressed_data ( pbi , data_sz , data , deadline ) ) { res = update_error_state ( ctx , & pbi -> common . error ) ; } ctx -> fragments . count = 0 ; } return res ; }", ; if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if (  ! res && !  ctx -> decoder_init  ctx -> decoder_init  ) { VP8D_CONFIG  ; ctx -> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx ->  ctx -> decrypt_state  ; } if  = 0 ; vp8_clear_system_state ( ) ;
261,"CWE-287 static void start_auth_request ( PgSocket * client , const char * username ) { int res ; PktBuf * buf ;  client -> auth_user = client -> db -> auth_user ;  client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ; if ( ! find_server ( client ) ) { client -> wait_for_user_conn = true ; return ; } slog_noise ( client , ""Doingauth_connquery"" ) ; client -> wait_for_user_conn = false ; client -> wait_for_user = true ; if ( ! sbuf_pause ( & client -> sbuf ) ) { release_server ( client -> link ) ; disconnect_client ( client , true , ""pausefailed"" ) ; return ; } client -> link -> ready = 0 ; res = 0 ; buf = pktbuf_dynamic ( 512 ) ; if ( buf ) { pktbuf_write_ExtQuery ( buf , cf_auth_query , 1 , username ) ; res = pktbuf_send_immediate ( buf , client -> link ) ; pktbuf_free ( buf ) ; } if ( ! res ) disconnect_server ( client -> link , false , ""unabletosendloginquery"" ) ; }", ; client ->  pool = get_pool
262,"CWE-119 int vp8_refining_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ;  thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;  if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row << 3 ; this_mv . as_mv . col = ref_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }"," best_address , in_what_stride  ) + mvsad_err_cost  check_here , in_what_stride  ) ; if"
263,"CWE-20 error_t enc28j60Init ( NetInterface * interface ) { uint8_t revisionId ; Enc28j60Context * context ; TRACE_INFO ( ""InitializingENC28J60Ethernetcontroller...\\r\\n"" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; enc28j60SoftReset ( interface ) ; sleep ( 10 ) ; context = ( Enc28j60Context * ) interface -> nicContext ; context -> currentBank = UINT16_MAX ; context -> nextPacket = ENC28J60_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; }  revisionId = enc28j60ReadReg ( interface , ENC28J60_REG_EREVID ) ;  TRACE_INFO ( ""ENC28J60revisionID:0x%02X\\r\\n"" , revisionId ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_ECOCON , 0x00 ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_MAADR1 , interface -> macAddr . b [ 0 ] ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_MAADR2 , interface -> macAddr . b [ 1 ] ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_MAADR3 , interface -> macAddr . b [ 2 ] ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_MAADR4 , interface -> macAddr . b [ 3 ] ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_MAADR5 , interface -> macAddr . b [ 4 ] ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_MAADR6 , interface -> macAddr . b [ 5 ] ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;   enc28j60WriteReg ( interface , ENC28J60_REG_ERXFCON , ERXFCON_UCEN |  ERXFCON_CRCEN | ERXFCON_HTEN | ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_MACON1 , MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN ) ; # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED )  enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) |  MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX ) ; # else  enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) |  MACON3_TXCRCEN | MACON3_FRMLNEN ) ; # endif  enc28j60WriteReg ( interface , ENC28J60_REG_MACON4 , MACON4_DEFER ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLL , LSB ( ETH_MAX_FRAME_SIZE ) ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLH , MSB ( ETH_MAX_FRAME_SIZE ) ) ;  # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED )  enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x15 ) ;  # else  enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x12 ) ;  # endif  enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGL , 0x12 ) ;  enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGH , 0x0C ) ; enc28j60WriteReg ( interface , ENC28J60_REG_MACLCON2 , 63 ) ; # if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED )  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , PHCON1_PDPXMD ) ;  # else  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , 0x0000 ) ;  # endif  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON2 , PHCON2_HDLDIS ) ;   enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHLCON ,  PHLCON_LACFG ( 4 ) | PHLCON_LBCFG ( 7 ) | PHLCON_LFRQ ( 0 ) | PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_REG_EIE , EIE_INTIE | EIE_PKTIE | EIE_LINKIE | EIE_TXIE | EIE_TXERIE ) ;  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHIE ,  PHIE_PLNKIE | PHIE_PGEIE ) ;  enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_RXEN ) ;  enc28j60DumpReg ( interface ) ; enc28j60DumpPhyReg ( interface ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }"," ( interface , ENC28J60_EREVID  ) ; TRACE_INFO  ( interface , ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ; enc28j60WriteReg ( interface , ENC28J60_MAADR5  , interface ->  ( interface , ENC28J60_MAADR4  , interface ->  ( interface , ENC28J60_MAADR3  , interface ->  ( interface , ENC28J60_MAADR2  , interface ->  ( interface , ENC28J60_MAADR1  , interface ->  ( interface , ENC28J60_MAADR0  , interface ->  ( interface , ENC28J60_ERXSTL  , LSB (  ( interface , ENC28J60_ERXSTH  , MSB (  ( interface , ENC28J60_ERXNDL  , LSB (  ( interface , ENC28J60_ERXNDH  , MSB (  ( interface , ENC28J60_ERXRDPTL  , LSB (  ( interface , ENC28J60_ERXRDPTH  , MSB (  ( interface , ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN  ) ; #  ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX  ) ; #  ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN  ) ; #  ( interface , ENC28J60_MACON4 , ENC28J60_MACON4_DEFER ) ; enc28j60WriteReg ( interface , ENC28J60_MAMXFLL  , LSB (  ( interface , ENC28J60_MAMXFLH  , MSB (  ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD  ) ; #  ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD  ) ; #  ( interface , ENC28J60_MAIPGL , ENC28J60_MAIPGL_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MAIPGH , ENC28J60_MAIPGH_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MACLCON2 , ENC28J60_MACLCON2_COLWIN_DEFAULT  ) ; #  ( interface , ENC28J60_PHCON1 , ENC28J60_PHCON1_PDPXMD  ) ; #  ( interface , ENC28J60_PHCON1  , 0x0000 )  ( interface , ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS  ) ; enc28j60WritePhyReg  ( interface , ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE  ) ; enc28j60WritePhyReg  ( interface , ENC28J60_PHIE , ENC28J60_PHIE_PLNKIE | ENC28J60_PHIE_PGEIE  ) ; enc28j60SetBit  ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_RXEN  ) ; enc28j60DumpReg"
264,"CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo%s,id%u,seq%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%sprotocol%dunreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%stcpport%sunreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%sudpport%sunreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%sprotocol%uport%uunreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%sunreachable-needtofrag(mtu%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%sunreachable-needtofrag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d%%sunreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d%%stonet%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""routeradvertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""lifetime"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""[size%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""{%s%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""timeexceededin-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ipreassemblytimeexceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""timeexceeded-#%u"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameterproblem-code%u"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameterproblem-octet%u"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""addressmaskis0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""timestampqueryid%useq%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""timestampreplyid%useq%u:org%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",recv%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",xmit%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP%s,length%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { if ( ND_TTEST2 ( * bp , plen ) ) { uint16_t sum ; vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ;  if ( sum != 0 ) {  uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""(wrongicmpcksum%x(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; ndo -> ndo_snaplen = ndo -> ndo_snapend - bp ; snapend_save = ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len ) ; ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLSextensionv%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""packetnotsupported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",checksum0x%04x(%scorrect),length%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t%sObject(%u),Class-Type:%u,length%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\tlabel%u,exp%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",[S]"" ) ) ; ND_PRINT ( ( ndo , "",ttl%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }", 0 ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;
265,"CWE-129 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) {  if ( * ( unsigned char * ) data > 1 )  return - ENOTSUPP ; return 1 ; }", { if ( datalen != 1 ) return - EINVAL ; if (
266,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; if ( ! npages && ! old . npages ) goto out_free ; r = - EEXIST ; kvm_for_each_memslot ( slot , kvm -> memslots ) { if ( slot -> id >= KVM_MEMORY_SLOTS || slot == memslot ) continue ; if ( ! ( ( base_gfn + npages <= slot -> base_gfn ) || ( base_gfn >= slot -> base_gfn + slot -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } else if ( npages && mem -> userspace_addr != old . userspace_addr ) { r = - EINVAL ; goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ;  kvm_arch_flush_shadow_memslot ( kvm , slot ) ;  kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r )  goto out_free ;  if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ;  if ( ! npages ) {  new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ;  out_free :  kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }"," srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ;  ) goto out_free  ; r =  ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if (  return 0 ; out_slots : kfree ( slots ) ;"
267,"CWE-20 void sctp_association_free ( struct sctp_association * asoc ) { struct sock * sk = asoc -> base . sk ; struct sctp_transport * transport ; struct list_head * pos , * temp ; int i ;  if ( ! asoc -> temp ) {  list_del ( & asoc -> asocs ) ; if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) sk -> sk_ack_backlog -- ; } asoc -> base . dead = true ; sctp_outq_free ( & asoc -> outqueue ) ; sctp_ulpq_free ( & asoc -> ulpq ) ; sctp_inq_free ( & asoc -> base . inqueue ) ; sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; sctp_ssnmap_free ( asoc -> ssnmap ) ; sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { if ( del_timer ( & asoc -> timers [ i ] ) ) sctp_association_put ( asoc ) ; } kfree ( asoc -> peer . cookie ) ; kfree ( asoc -> peer . peer_random ) ; kfree ( asoc -> peer . peer_chunks ) ; kfree ( asoc -> peer . peer_hmacs ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { transport = list_entry ( pos , struct sctp_transport , transports ) ; list_del_rcu ( pos ) ; sctp_transport_free ( transport ) ; } asoc -> peer . transport_count = 0 ; sctp_asconf_queue_teardown ( asoc ) ; if ( asoc -> asconf_addr_del_pending != NULL ) kfree ( asoc -> asconf_addr_del_pending ) ; sctp_auth_destroy_keys ( & asoc -> endpoint_shared_keys ) ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_association_put ( asoc ) ; }", if ( ! list_empty ( & asoc -> asocs )  ) { list_del
268,"CWE-000 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; }  ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ;  ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ;  if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }"," , VCPU_SREG_LDTR , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if  , cpl , true , NULL  ) ; if"
269,"CWE-125 static int dhcpv4_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint8_t type , optlen ; i = 0 ; while ( i < length ) {  tlv = cp + i ;  type = ( uint8_t ) tlv [ 0 ] ; optlen = ( uint8_t ) tlv [ 1 ] ; value = tlv + 2 ; ND_PRINT ( ( ndo , ""\\n"" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , ""\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( dh4opt_str , ""Unknown"" , type ) ) ) ;  ND_PRINT ( ( ndo , ""(%u)"" , optlen + 2 ) ) ;  switch ( type ) { case DH4OPT_DNS_SERVERS : case DH4OPT_NTP_SERVERS : { if ( optlen < 4 || optlen % 4 != 0 ) { return - 1 ; } for ( t = 0 ; t < optlen ; t += 4 ) ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , value + t ) ) ) ; } break ; case DH4OPT_DOMAIN_SEARCH : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 2 + optlen ; } return 0 ; }", length ) { if ( i + 2 > length ) return - 1 ;  2 ) ) ; if ( i + 2 + optlen > length ) return - 1
270,"CWE-617 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( ""QMP4"" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , ""frameskip%d\\n"" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""startcode:%3X"" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectStart"" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectLayerStart"" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FGSbpstart"" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqStart"" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqEnd"" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""UserData"" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""GroupofVOPstart"" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoSessionError"" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectStart"" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectPlanestart"" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""slicestart"" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""extensionstart"" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""fgsstart"" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectstart"" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectPlanestart"" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectstart"" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectPlanestart"" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , ""StillTextureObjectstart"" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSpatialLayerstart"" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSNRLayerstart"" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureTilestart"" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureShapeLayerstart"" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""stuffingstart"" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""reserved"" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Systemstart"" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , ""at%d\\n"" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , ""IgnoringmultipleVOLheaders\\n"" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { int profile , level ; mpeg4_decode_profile_level ( s , gb , & profile , & level ) ; if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( level > 0 && level < 9 ) ) { s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixesstudioandnonstudioprofile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) {  av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;  if ( ! s -> avctx -> bits_per_raw_sample ) { av_log ( s -> avctx , AV_LOG_ERROR , ""MissingVOLheader\\n"" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }", studio_profile ) {  if ( !
271,"CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;  ea_idebug ( inode , ""buffer=%p,buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""readingblock%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , ""badblock%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }", error ; struct mb2_cache  * ext4_mb_cache =
272,"CWE-125 static inline signed int ReadPropertySignedLong ( const EndianType endian , const unsigned char * buffer ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; unsigned int value ; if ( endian == LSBEndian ) {  value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }  value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }", unsigned int )  buffer [ 3  ] << 24 ; value |= ( unsigned int )  buffer [ 2  ] << 16 ; value |= ( unsigned int )  buffer [ 1  ] << 8 ; value |= ( unsigned int )  buffer [ 0  [ 0 ]  ; quantum .  . unsigned_value =  value & 0xffffffff  value & 0xffffffff  ; return (  unsigned int )  buffer [ 0  ] << 24 ; value |= ( unsigned int )  buffer [ 1  ] << 16 ; value |= ( unsigned int )  buffer [ 2  ] << 8 ; value |= ( unsigned int )  buffer [ 3  [ 3 ]  ; quantum .  . unsigned_value =  value & 0xffffffff  value & 0xffffffff  ; return (
273,"CWE-119  static void  fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  assert ( ( cc % ( bps * stride ) ) == 0 ) ;  if ( ! tmp )  return ;  while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ;  } ","   static int  fpAcc ( TIFF  cc ) ; if  ( cc %  * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; }  if ( !  tmp ) return 0  tmp ) ; return 1 ;"
274,"CWE-125 static int ast_type_init ( PyObject * self , PyObject * args , PyObject * kw ) {  _Py_IDENTIFIER ( _fields ) ;  Py_ssize_t i , numfields = 0 ; int res = - 1 ; PyObject * key , * value , * fields ;  fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ;  if ( ! fields ) PyErr_Clear ( ) ; if ( fields ) { numfields = PySequence_Size ( fields ) ; if ( numfields == - 1 ) goto cleanup ; } res = 0 ;  if ( PyTuple_GET_SIZE ( args ) > 0 ) {  if ( numfields != PyTuple_GET_SIZE ( args ) ) {  PyErr_Format ( PyExc_TypeError , ""%.400sconstructortakes%s""  ""%zdpositionalargument%s"" ,  Py_TYPE ( self ) -> tp_name ,  numfields == 0 ? """" : ""either0or"" , numfields , numfields == 1 ? """" : ""s"" ) ; res = - 1 ; goto cleanup ; } for ( i = 0 ; i < PyTuple_GET_SIZE ( args ) ; i ++ ) { PyObject * name = PySequence_GetItem ( fields , i ) ; if ( ! name ) { res = - 1 ; goto cleanup ; } res = PyObject_SetAttr ( self , name , PyTuple_GET_ITEM ( args , i ) ) ; Py_DECREF ( name ) ; if ( res < 0 ) goto cleanup ; }  }  if ( kw ) { i = 0 ; while ( PyDict_Next ( kw , & i , & key , & value ) ) { res = PyObject_SetAttr ( self , key , value ) ; if ( res < 0 ) goto cleanup ; } } cleanup : Py_XDECREF ( fields ) ; return res ; }"," kw ) {  Py_ssize_t i ,  * fields ; if ( lookup_attr_id  ( ( PyObject  , & PyId__fields , & fields ) < 0 ) { goto cleanup ; }  if ( fields  ; if ( numfields <  ( args )  ) { PyErr_Format  ( PyExc_TypeError , ""%.400sconstructortakesatmost""  ""%zdpositionalargument%s"" , Py_TYPE  ) -> tp_name  , numfields ,  cleanup ; }  if ( kw"
275,"CWE-119  static void encode_frame ( vpx_codec_ctx_t * codec ,  vpx_image_t * img , int frame_index ,  VpxVideoWriter * writer ) {  vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , 0 , VPX_DL_GOOD_QUALITY ) ; if ( res != VPX_CODEC_OK ) die_codec ( codec , ""Failedtoencodeframe"" ) ;  while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {  if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) { die_codec ( codec , ""Failedtowritecompressedframe"" ) ; } printf ( keyframe ? ""K"" : ""."" ) ; fflush ( stdout ) ; } }  } ",   static int  encode_frame ( vpx_codec_ctx_t  writer ) { int got_pkts = 0 ;  NULL ) { got_pkts = 1 ;  ; } } return got_pkts ;
276,"CWE-125 static inline signed int ReadPropertySignedLong ( const EndianType endian , const unsigned char * buffer ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; unsigned int value ; if ( endian == LSBEndian ) {  value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }  value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;   quantum . unsigned_value = ( value & 0xffffffff ) ;  return ( quantum . signed_value ) ; }", unsigned int )  buffer [ 3  ] << 24 ; value |= ( unsigned int )  buffer [ 2  ] << 16 ; value |= ( unsigned int )  buffer [ 1  ] << 8 ; value |= ( unsigned int )  buffer [ 0  [ 0 ]  ; quantum .  . unsigned_value =  value & 0xffffffff  value & 0xffffffff  ; return (  unsigned int )  buffer [ 0  ] << 24 ; value |= ( unsigned int )  buffer [ 1  ] << 16 ; value |= ( unsigned int )  buffer [ 2  ] << 8 ; value |= ( unsigned int )  buffer [ 3  [ 3 ]  ; quantum .  . unsigned_value =  value & 0xffffffff  value & 0xffffffff  ; return (
277,"CWE-20 int mpi_powm ( MPI res , MPI base , MPI exp , MPI mod ) { mpi_ptr_t mp_marker = NULL , bp_marker = NULL , ep_marker = NULL ; mpi_ptr_t xp_marker = NULL ; mpi_ptr_t tspace = NULL ; mpi_ptr_t rp , ep , mp , bp ; mpi_size_t esize , msize , bsize , rsize ; int esign , msign , bsign , rsign ; mpi_size_t size ; int mod_shift_cnt ; int negative_result ; int assign_rp = 0 ; mpi_size_t tsize = 0 ; int rc = - ENOMEM ; esize = exp -> nlimbs ; msize = mod -> nlimbs ; size = 2 * msize ; esign = exp -> sign ; msign = mod -> sign ; rp = res -> d ; ep = exp -> d ; if ( ! msize ) return - EINVAL ; if ( ! esize ) {  rp [ 0 ] = 1 ;   res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ;  res -> sign = 0 ; goto leave ; } mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; mod_shift_cnt = count_leading_zeros ( mod -> d [ msize - 1 ] ) ; if ( mod_shift_cnt ) mpihelp_lshift ( mp , mod -> d , msize , mod_shift_cnt ) ; else MPN_COPY ( mp , mod -> d , msize ) ; bsize = base -> nlimbs ; bsign = base -> sign ; if ( bsize > msize ) { bp = bp_marker = mpi_alloc_limb_space ( bsize + 1 ) ; if ( ! bp ) goto enomem ; MPN_COPY ( bp , base -> d , bsize ) ; mpihelp_divrem ( bp + msize , 0 , bp , bsize , mp , msize ) ; bsize = msize ; MPN_NORMALIZE ( bp , bsize ) ; } else bp = base -> d ; if ( ! bsize ) { res -> nlimbs = 0 ; res -> sign = 0 ; goto leave ; } if ( res -> alloced < size ) { if ( rp == ep || rp == mp || rp == bp ) { rp = mpi_alloc_limb_space ( size ) ; if ( ! rp ) goto enomem ; assign_rp = 1 ; } else { if ( mpi_resize ( res , size ) < 0 ) goto enomem ; rp = res -> d ; } } else { if ( rp == bp ) { BUG_ON ( bp_marker ) ; bp = bp_marker = mpi_alloc_limb_space ( bsize ) ; if ( ! bp ) goto enomem ; MPN_COPY ( bp , rp , bsize ) ; } if ( rp == ep ) { ep = ep_marker = mpi_alloc_limb_space ( esize ) ; if ( ! ep ) goto enomem ; MPN_COPY ( ep , rp , esize ) ; } if ( rp == mp ) { BUG_ON ( mp_marker ) ; mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; MPN_COPY ( mp , rp , msize ) ; } } MPN_COPY ( rp , bp , bsize ) ; rsize = bsize ; rsign = bsign ; { mpi_size_t i ; mpi_ptr_t xp ; int c ; mpi_limb_t e ; mpi_limb_t carry_limb ; struct karatsuba_ctx karactx ; xp = xp_marker = mpi_alloc_limb_space ( 2 * ( msize + 1 ) ) ; if ( ! xp ) goto enomem ; memset ( & karactx , 0 , sizeof karactx ) ; negative_result = ( ep [ 0 ] & 1 ) && base -> sign ; i = esize - 1 ; e = ep [ i ] ; c = count_leading_zeros ( e ) ; e = ( e << c ) << 1 ; c = BITS_PER_MPI_LIMB - 1 - c ; for ( ; ; ) { while ( c ) { mpi_ptr_t tp ; mpi_size_t xsize ; if ( rsize < KARATSUBA_THRESHOLD ) mpih_sqr_n_basecase ( xp , rp , rsize ) ; else { if ( ! tspace ) { tsize = 2 * rsize ; tspace = mpi_alloc_limb_space ( tsize ) ; if ( ! tspace ) goto enomem ; } else if ( tsize < ( 2 * rsize ) ) { mpi_free_limb_space ( tspace ) ; tsize = 2 * rsize ; tspace = mpi_alloc_limb_space ( tsize ) ; if ( ! tspace ) goto enomem ; } mpih_sqr_n ( xp , rp , rsize , tspace ) ; } xsize = 2 * rsize ; if ( xsize > msize ) { mpihelp_divrem ( xp + msize , 0 , xp , xsize , mp , msize ) ; xsize = msize ; } tp = rp ; rp = xp ; xp = tp ; rsize = xsize ; if ( ( mpi_limb_signed_t ) e < 0 ) { if ( bsize < KARATSUBA_THRESHOLD ) { mpi_limb_t tmp ; if ( mpihelp_mul ( xp , rp , rsize , bp , bsize , & tmp ) < 0 ) goto enomem ; } else { if ( mpihelp_mul_karatsuba_case ( xp , rp , rsize , bp , bsize , & karactx ) < 0 ) goto enomem ; } xsize = rsize + bsize ; if ( xsize > msize ) { mpihelp_divrem ( xp + msize , 0 , xp , xsize , mp , msize ) ; xsize = msize ; } tp = rp ; rp = xp ; xp = tp ; rsize = xsize ; } e <<= 1 ; c -- ; } i -- ; if ( i < 0 ) break ; e = ep [ i ] ; c = BITS_PER_MPI_LIMB ; } if ( mod_shift_cnt ) { carry_limb = mpihelp_lshift ( res -> d , rp , rsize , mod_shift_cnt ) ; rp = res -> d ; if ( carry_limb ) { rp [ rsize ] = carry_limb ; rsize ++ ; } } else { MPN_COPY ( res -> d , rp , rsize ) ; rp = res -> d ; } if ( rsize >= msize ) { mpihelp_divrem ( rp + msize , 0 , rp , rsize , mp , msize ) ; rsize = msize ; } if ( mod_shift_cnt ) mpihelp_rshift ( rp , rp , rsize , mod_shift_cnt ) ; MPN_NORMALIZE ( rp , rsize ) ; mpihelp_release_karatsuba_ctx ( & karactx ) ; } if ( negative_result && rsize ) { if ( mod_shift_cnt ) mpihelp_rshift ( mp , mp , msize , mod_shift_cnt ) ; mpihelp_sub ( rp , mp , msize , rp , rsize ) ; rsize = msize ; rsign = msign ; MPN_NORMALIZE ( rp , rsize ) ; } res -> nlimbs = rsize ; res -> sign = rsign ; leave : rc = 0 ; enomem : if ( assign_rp ) mpi_assign_limb_space ( res , rp , size ) ; if ( mp_marker ) mpi_free_limb_space ( mp_marker ) ; if ( bp_marker ) mpi_free_limb_space ( bp_marker ) ; if ( ep_marker ) mpi_free_limb_space ( ep_marker ) ; if ( xp_marker ) mpi_free_limb_space ( xp_marker ) ; if ( tspace ) mpi_free_limb_space ( tspace ) ; return rc ; }"," esize ) {  res -> nlimbs  : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }"
278,"CWE-88 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowedsubmodulename:%s"" , name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowedsubmoduleurl:%s"" , value ) ;  free ( name ) ;  return 0 ; }"," value ) ; if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowedsubmodulepath:%s"" , value ) ;"
279,"CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList ,  sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ;  if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }", ( 2 * ( sqlite3_int64 )
280,"CWE-119 static int rd_pick_intra4x4mby_modes ( MACROBLOCK * mb , int * Rate , int * rate_y , int * Distortion , int best_rd ) { MACROBLOCKD * const xd = & mb -> e_mbd ; int i ; int cost = mb -> mbmode_cost [ xd -> frame_type ] [ B_PRED ] ; int distortion = 0 ; int tot_rate_y = 0 ; int64_t total_rd = 0 ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; const int * bmode_costs ;  vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;   vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;  ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; intra_prediction_down_copy ( xd , xd -> dst . y_buffer - xd -> dst . y_stride + 16 ) ; bmode_costs = mb -> inter_bmode_costs ; for ( i = 0 ; i < 16 ; i ++ ) { MODE_INFO * const mic = xd -> mode_info_context ; const int mis = xd -> mode_info_stride ; B_PREDICTION_MODE UNINITIALIZED_IS_SAFE ( best_mode ) ; int UNINITIALIZED_IS_SAFE ( r ) , UNINITIALIZED_IS_SAFE ( ry ) , UNINITIALIZED_IS_SAFE ( d ) ; if ( mb -> e_mbd . frame_type == KEY_FRAME ) { const B_PREDICTION_MODE A = above_block_mode ( mic , i , mis ) ; const B_PREDICTION_MODE L = left_block_mode ( mic , i ) ; bmode_costs = mb -> bmode_costs [ A ] [ L ] ; } total_rd += rd_pick_intra4x4block ( mb , mb -> block + i , xd -> block + i , & best_mode , bmode_costs , ta + vp8_block2above [ i ] , tl + vp8_block2left [ i ] , & r , & ry , & d ) ; cost += r ; distortion += d ; tot_rate_y += ry ; mic -> bmi [ i ] . as_mode = best_mode ; if ( total_rd >= ( int64_t ) best_rd ) break ; } if ( total_rd >= ( int64_t ) best_rd ) return INT_MAX ; * Rate = cost ; * rate_y = tot_rate_y ; * Distortion = distortion ; return RDCOST ( mb -> rdmult , mb -> rddiv , cost , distortion ) ; }", * bmode_costs ; memcpy  ( & t_above  ) ) ; memcpy  ( & t_left
281,"CWE-416 static struct ucma_multicast * ucma_alloc_multicast ( struct ucma_context * ctx ) { struct ucma_multicast * mc ; mc = kzalloc ( sizeof ( * mc ) , GFP_KERNEL ) ; if ( ! mc ) return NULL ; mutex_lock ( & mut ) ;  mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ;  mutex_unlock ( & mut ) ; if ( mc -> id < 0 ) goto error ; mc -> ctx = ctx ; list_add_tail ( & mc -> list , & ctx -> mc_list ) ; return mc ; error : kfree ( mc ) ; return NULL ; }"," & multicast_idr , NULL  , 0 ,"
282,"CWE-119  void vp9_cond_prob_diff_update ( vp9_writer * w , vp9_prob * oldp ,  const unsigned int ct [ 2 ] ) {  const vp9_prob upd = DIFF_UPDATE_PROB ;   vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ;  const int savings = vp9_prob_diff_update_savings_search ( ct , * oldp , & newp , upd ) ; assert ( newp >= 1 ) ; if ( savings > 0 ) {  vp9_write ( w , 1 , upd ) ;  vp9_write_prob_diff_update ( w , newp , * oldp ) ; * oldp = newp ; } else {  vp9_write ( w , 0 , upd ) ;  } }"," void vp9_cond_prob_diff_update ( vpx_writer  * w ,  * w , vpx_prob  * oldp ,  ) { const vpx_prob  upd = DIFF_UPDATE_PROB  = DIFF_UPDATE_PROB ; vpx_prob  newp = get_binary_prob  0 ) { vpx_write  ( w ,  } else { vpx_write  ( w ,"
283,"CWE-326 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) {  static u32 ip6_proxy_idents_hashrnd __read_mostly ;  struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ;  net_get_random_once ( & ip6_proxy_idents_hashrnd ,  sizeof ( ip6_proxy_idents_hashrnd ) ) ;  id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd ,  & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }"," skb ) {  struct in6_addr buf  return 0 ;  id = __ipv6_select_ident  ( net ,  & addrs ["
284,"CWE-476  static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb )  { s -> avctx -> profile = get_bits ( gb , 4 ) ;  s -> avctx -> level = get_bits ( gb , 4 ) ;   if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) {   s -> avctx -> level = 0 ;  } return 0 ; }"," GetBitContext * gb , int * profile , int * level ) { *  profile = get_bits  4 ) ; *  level = get_bits  ; if ( *  profile == 0  == 0 && *  level == 8  8 ) { *  level = 0"
285,"CWE-264 const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ;  # undef _  default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = ""<unknownvariable>"" ; break ; } break ; } return str ; }", NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
286,CWE-119 static MV_REFERENCE_FRAME get_frame_type ( const VP9_COMP * cpi ) { if ( frame_is_intra_only ( & cpi -> common ) ) return INTRA_FRAME ; else if ( cpi -> rc . is_src_frame_alt_ref && cpi -> refresh_golden_frame ) return ALTREF_FRAME ; else if ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame )  return LAST_FRAME ;  else  return GOLDEN_FRAME ;  }, refresh_alt_ref_frame ) return GOLDEN_FRAME  ; else return  ; else return LAST_FRAME  ; } 
287,"CWE-134 static void zend_throw_or_error ( int fetch_type , zend_class_entry * exception_ce , const char * format , ... ) { va_list va ; char * message = NULL ; va_start ( va , format ) ; zend_vspprintf ( & message , 0 , format , va ) ; if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) {  zend_throw_error ( exception_ce , message ) ;  } else { zend_error ( E_ERROR , ""%s"" , message ) ; } efree ( message ) ; va_end ( va ) ; }"," ( exception_ce , ""%s"" ,"
288,"CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len &&  ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) )  put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }", -> len && SKB_EXT_ERR ( skb ) -> opt_stats  ) put_cmsg (
289,"CWE-125 PHPAPI int php_var_unserialize ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && cursor [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ;  # line 496 ""ext/standard/var_unserializer.c""  { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; if ( ( YYLIMIT - YYCURSOR ) < 7 ) YYFILL ( 7 ) ; yych = * YYCURSOR ; switch ( yych ) { case 'C' : case 'O' : goto yy13 ; case 'N' : goto yy5 ; case 'R' : goto yy2 ; case 'S' : goto yy10 ; case 'a' : goto yy11 ; case 'b' : goto yy6 ; case 'd' : goto yy8 ; case 'i' : goto yy7 ; case 'o' : goto yy12 ; case 'r' : goto yy4 ; case 's' : goto yy9 ; case '}' : goto yy14 ; default : goto yy16 ; } yy2 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy95 ; yy3 :  # line 861 ""ext/standard/var_unserializer.re""  { return 0 ; }  # line 558 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy89 ; goto yy3 ; yy5 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy87 ; goto yy3 ; yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy83 ; goto yy3 ; yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy77 ; goto yy3 ; yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy53 ; goto yy3 ; yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy46 ; goto yy3 ; yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy39 ; goto yy3 ; yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy32 ; goto yy3 ; yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy25 ; goto yy3 ; yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy17 ; goto yy3 ; yy14 : ++ YYCURSOR ;  # line 855 ""ext/standard/var_unserializer.re""  { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Unexpectedendofserializeddata"" ) ; return 0 ; }  # line 607 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ; goto yy3 ; yy17 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych == '+' ) goto yy19 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } goto yy18 ; yy20 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ;  # line 708 ""ext/standard/var_unserializer.re""  { size_t len , len2 , len3 , maxlen ; long elements ; char * class_name ; zend_class_entry * ce ; zend_class_entry * * pce ; int incomplete_class = 0 ; int custom_object = 0 ; zval * user_func ; zval * retval_ptr ; zval * * args [ 1 ] ; zval * arg_func_name ; if ( ! var_hash ) return 0 ; if ( * start == 'C' ) { custom_object = 1 ; } INIT_PZVAL ( * rval ) ; len2 = len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { * p = start + 2 ; return 0 ; } class_name = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( class_name , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = estrndup ( class_name , len ) ; do { BG ( serialize_lock ) ++ ; if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } ce = * pce ; break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } MAKE_STD_ZVAL ( user_func ) ; ZVAL_STRING ( user_func , PG ( unserialize_callback_func ) , 1 ) ; args [ 0 ] = & arg_func_name ; MAKE_STD_ZVAL ( arg_func_name ) ; ZVAL_STRING ( arg_func_name , class_name , 1 ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , user_func , & retval_ptr , 1 , args , 0 , NULL TSRMLS_CC ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""defined(%s)butnotfound"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } BG ( serialize_lock ) -- ; if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { ce = * pce ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Function%s()hasn\'tdefinedtheclassitwascalledfor"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ;  if ( incomplete_class ) {  php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; }  # line 785 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy26 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; goto yy18 ; } yy26 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy27 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ;  # line 699 ""ext/standard/var_unserializer.re""  { if ( ! var_hash ) return 0 ; INIT_PZVAL ( * rval ) ;  return object_common2 ( UNSERIALIZE_PASSTHRU ,   object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ;  }  # line 819 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != '{' ) goto yy18 ; ++ YYCURSOR ;  # line 678 ""ext/standard/var_unserializer.re""  { long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 ) { return 0 ; } INIT_PZVAL ( * rval ) ; array_init_size ( * rval , elements ) ; if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_PP ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }  # line 861 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy40 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; goto yy18 ; yy40 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy41 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ;  # line 643 ""ext/standard/var_unserializer.re""  { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , & len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { efree ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 0 ) ; return 1 ; }  # line 917 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy47 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; goto yy18 ; yy47 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy48 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ;  # line 610 ""ext/standard/var_unserializer.re""  { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 1 ) ; return 1 ; }  # line 971 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy57 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy55 ; if ( yych <= '.' ) goto yy60 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy58 ; if ( yych <= 'H' ) goto yy18 ; goto yy56 ; } else { if ( yych != 'N' ) goto yy18 ; } } yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy76 ; goto yy18 ; yy55 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych == '.' ) goto yy60 ; goto yy18 ; } else { if ( yych <= '9' ) goto yy58 ; if ( yych != 'I' ) goto yy18 ; } yy56 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy72 ; goto yy18 ; yy57 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy60 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy58 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy70 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy58 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy63 ; if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy60 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy61 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy61 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy63 : ++ YYCURSOR ;  # line 600 ""ext/standard/var_unserializer.re""  { # if SIZEOF_LONG == 4 use_double : # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; }  # line 1069 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy66 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; } yy66 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy69 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy69 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy67 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; if ( yych == ';' ) goto yy63 ; goto yy18 ; yy69 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; yy70 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy70 ; if ( yych <= ':' ) goto yy18 ; goto yy63 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy72 : yych = * ++ YYCURSOR ; if ( yych != 'F' ) goto yy18 ; yy73 : yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ;  # line 585 ""ext/standard/var_unserializer.re""  { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; if ( ! strncmp ( start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( * rval , - php_get_inf ( ) ) ; } return 1 ; }  # line 1143 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ; goto yy18 ; yy77 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy78 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; goto yy18 ; } yy78 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy79 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ;  # line 558 ""ext/standard/var_unserializer.re""  { # if SIZEOF_LONG == 4 int digits = YYCURSOR - start - 3 ; if ( start [ 2 ] == '-' || start [ 2 ] == '+' ) { digits -- ; } if ( digits >= MAX_LENGTH_OF_LONG - 1 ) { if ( digits == MAX_LENGTH_OF_LONG - 1 ) { int cmp = strncmp ( YYCURSOR - MAX_LENGTH_OF_LONG , long_min_digits , MAX_LENGTH_OF_LONG - 1 ) ; if ( ! ( cmp < 0 || ( cmp == 0 && start [ 2 ] == '-' ) ) ) { goto use_double ; } } else { goto use_double ; } } # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_LONG ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; }  # line 1197 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= '2' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ;  # line 551 ""ext/standard/var_unserializer.re""  { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_BOOL ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; }  # line 1212 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;  # line 544 ""ext/standard/var_unserializer.re""  { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_NULL ( * rval ) ; return 1 ; }  # line 1222 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy90 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; goto yy18 ; } yy90 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy91 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ;  # line 521 ""ext/standard/var_unserializer.re""  { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval == * rval_ref ) return 0 ; if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_UNSET_ISREF_PP ( rval ) ; return 1 ; }  # line 1268 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; goto yy18 ; } yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy97 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ;  # line 500 ""ext/standard/var_unserializer.re""  { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_SET_ISREF_PP ( rval ) ; return 1 ; }  # line 1312 ""ext/standard/var_unserializer.c""  }  # line 863 ""ext/standard/var_unserializer.re""  return 0 ; }"," ; # line 501  ""ext/standard/var_unserializer.c"" { YYCTYPE  : # line 875  ""ext/standard/var_unserializer.re"" { return  } # line 563  ""ext/standard/var_unserializer.c"" yy4 :  ; # line 869  ""ext/standard/var_unserializer.re"" { php_error_docref  } # line 612  ""ext/standard/var_unserializer.c"" yy16 :  ; # line 717  ""ext/standard/var_unserializer.re"" { size_t  ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if (  } # line 795  ""ext/standard/var_unserializer.c"" yy25 :  ; # line 704 ""ext/standard/var_unserializer.re"" { long elements ;  if ( !  rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; }  ( UNSERIALIZE_PASSTHRU , elements  ) ; }  } # line 833  ""ext/standard/var_unserializer.c"" yy32 :  ; # line 683  ""ext/standard/var_unserializer.re"" { long  } # line 875  ""ext/standard/var_unserializer.c"" yy39 :  ; # line 648  ""ext/standard/var_unserializer.re"" { size_t  } # line 931  ""ext/standard/var_unserializer.c"" yy46 :  ; # line 615  ""ext/standard/var_unserializer.re"" { size_t  } # line 985  ""ext/standard/var_unserializer.c"" yy53 :  ; # line 605  ""ext/standard/var_unserializer.re"" { #  } # line 1083  ""ext/standard/var_unserializer.c"" yy65 :  ; # line 590  ""ext/standard/var_unserializer.re"" { *  } # line 1157  ""ext/standard/var_unserializer.c"" yy76 :  ; # line 563  ""ext/standard/var_unserializer.re"" { #  } # line 1211  ""ext/standard/var_unserializer.c"" yy83 :  ; # line 556  ""ext/standard/var_unserializer.re"" { *  } # line 1226  ""ext/standard/var_unserializer.c"" yy87 :  ; # line 549  ""ext/standard/var_unserializer.re"" { *  } # line 1236  ""ext/standard/var_unserializer.c"" yy89 :  ; # line 526  ""ext/standard/var_unserializer.re"" { long  } # line 1282  ""ext/standard/var_unserializer.c"" yy95 :  ; # line 505  ""ext/standard/var_unserializer.re"" { long  } # line 1326  ""ext/standard/var_unserializer.c"" } #  } # line 877  ""ext/standard/var_unserializer.re"" return 0"
290,"CWE-787 static void Np_toString ( js_State * J ) {  char buf [ 32 ] ;  js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , ""notanumber"" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , ""invalidradix"" ) ; { static const char digits [ ] = ""0123456789abcdefghijklmnopqrstuvwxyz"" ;  char buf [ 100 ] ;  double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , ""0"" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , ""NaN"" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? ""-Infinity"" : ""Infinity"" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number * pow ( radix , exp + 1 ) < limit ) ++ exp ; u = number * pow ( radix , exp ) + 0.5 ; while ( u > 0 && ( u % radix ) == 0 ) { u /= radix ; -- exp ; } ndigits = 0 ; while ( u > 0 ) { buf [ ndigits ++ ] = digits [ u % radix ] ; u /= radix ; } point = ndigits - exp ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } if ( sign ) js_putc ( J , & sb , '-' ) ; if ( point <= 0 ) { js_putc ( J , & sb , '0' ) ; js_putc ( J , & sb , '.' ) ; while ( point ++ < 0 ) js_putc ( J , & sb , '0' ) ; while ( ndigits -- > 0 ) js_putc ( J , & sb , buf [ ndigits ] ) ; } else { while ( ndigits -- > 0 ) { js_putc ( J , & sb , buf [ ndigits ] ) ; if ( -- point == 0 && ndigits > 0 ) js_putc ( J , & sb , '.' ) ; } while ( point -- > 0 ) js_putc ( J , & sb , '0' ) ; } js_putc ( J , & sb , 0 ) ; js_pushstring ( J , sb -> s ) ; js_endtry ( J ) ; js_free ( J , sb ) ; } }"," char buf [ 100  ] ; js_Object  = ""0123456789abcdefghijklmnopqrstuvwxyz"" ;  double number ="
291,"CWE-189 int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { register unsigned int bit_buffer ; register int bits_left , i = 0 ; unsigned char * i_ptr , * i_end ; register unsigned short sym ; int match_length , length_footer , extra , verbatim_bits , bytes_todo ; int this_run , main_element , aligned_bits , j ; unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; unsigned int R0 , R1 , R2 ; if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; if ( lzx -> error ) return lzx -> error ; i = lzx -> o_end - lzx -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return MSPACK_ERR_OK ; RESTORE_BITS ; window = lzx -> window ; window_posn = lzx -> window_posn ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; while ( lzx -> frame < end_frame ) { if ( lzx -> reset_interval && ( ( lzx -> frame % lzx -> reset_interval ) == 0 ) ) { if ( lzx -> block_remaining ) { D ( ( ""%dbytesremainingatresetinterval"" , lzx -> block_remaining ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } lzxd_reset_state ( lzx ) ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; } if ( lzx -> is_delta ) { ENSURE_BITS ( 16 ) ; REMOVE_BITS ( 16 ) ; } if ( ! lzx -> header_read ) { j = 0 ; READ_BITS ( i , 1 ) ; if ( i ) { READ_BITS ( i , 16 ) ; READ_BITS ( j , 16 ) ; } lzx -> intel_filesize = ( i << 16 ) | j ; lzx -> header_read = 1 ; } frame_size = LZX_FRAME_SIZE ; if ( lzx -> length && ( lzx -> length - lzx -> offset ) < ( off_t ) frame_size ) { frame_size = lzx -> length - lzx -> offset ; } bytes_todo = lzx -> frame_posn + frame_size - window_posn ; while ( bytes_todo > 0 ) { if ( lzx -> block_remaining == 0 ) { if ( ( lzx -> block_type == LZX_BLOCKTYPE_UNCOMPRESSED ) && ( lzx -> block_length & 1 ) ) { READ_IF_NEEDED ; i_ptr ++ ; } READ_BITS ( lzx -> block_type , 3 ) ; READ_BITS ( i , 16 ) ; READ_BITS ( j , 8 ) ; lzx -> block_remaining = lzx -> block_length = ( i << 8 ) | j ; switch ( lzx -> block_type ) { case LZX_BLOCKTYPE_ALIGNED : for ( i = 0 ; i < 8 ; i ++ ) { READ_BITS ( j , 3 ) ; lzx -> ALIGNED_len [ i ] = j ; } BUILD_TABLE ( ALIGNED ) ; case LZX_BLOCKTYPE_VERBATIM : READ_LENGTHS ( MAINTREE , 0 , 256 ) ; READ_LENGTHS ( MAINTREE , 256 , LZX_NUM_CHARS + lzx -> num_offsets ) ; BUILD_TABLE ( MAINTREE ) ; if ( lzx -> MAINTREE_len [ 0xE8 ] != 0 ) lzx -> intel_started = 1 ; READ_LENGTHS ( LENGTH , 0 , LZX_NUM_SECONDARY_LENGTHS ) ; BUILD_TABLE_MAYBE_EMPTY ( LENGTH ) ; break ; case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ;  ENSURE_BITS ( 16 ) ;  if ( bits_left > 16 ) i_ptr -= 2 ; bits_left = 0 ; bit_buffer = 0 ; for ( rundest = & buf [ 0 ] , i = 0 ; i < 12 ; i ++ ) { READ_IF_NEEDED ; * rundest ++ = * i_ptr ++ ; } R0 = buf [ 0 ] | ( buf [ 1 ] << 8 ) | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; R1 = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; R2 = buf [ 8 ] | ( buf [ 9 ] << 8 ) | ( buf [ 10 ] << 16 ) | ( buf [ 11 ] << 24 ) ; break ; default : D ( ( ""badblocktype"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } } this_run = lzx -> block_remaining ; if ( this_run > bytes_todo ) this_run = bytes_todo ; bytes_todo -= this_run ; lzx -> block_remaining -= this_run ; switch ( lzx -> block_type ) { case LZX_BLOCKTYPE_VERBATIM : while ( this_run > 0 ) { READ_HUFFSYM ( MAINTREE , main_element ) ; if ( main_element < LZX_NUM_CHARS ) { window [ window_posn ++ ] = main_element ; this_run -- ; } else { main_element -= LZX_NUM_CHARS ; match_length = main_element & LZX_NUM_PRIMARY_LENGTHS ; if ( match_length == LZX_NUM_PRIMARY_LENGTHS ) { if ( lzx -> LENGTH_empty ) { D ( ( ""LENGTHsymbolneededbuttreeisempty"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } READ_HUFFSYM ( LENGTH , length_footer ) ; match_length += length_footer ; } match_length += LZX_MIN_MATCH ; switch ( ( match_offset = ( main_element >> 3 ) ) ) { case 0 : match_offset = R0 ; break ; case 1 : match_offset = R1 ; R1 = R0 ; R0 = match_offset ; break ; case 2 : match_offset = R2 ; R2 = R0 ; R0 = match_offset ; break ; case 3 : match_offset = 1 ; R2 = R1 ; R1 = R0 ; R0 = match_offset ; break ; default : extra = ( match_offset >= 36 ) ? 17 : extra_bits [ match_offset ] ; READ_BITS ( verbatim_bits , extra ) ; match_offset = position_base [ match_offset ] - 2 + verbatim_bits ; R2 = R1 ; R1 = R0 ; R0 = match_offset ; } if ( match_length == LZX_MAX_MATCH && lzx -> is_delta ) { int extra_len = 0 ; ENSURE_BITS ( 3 ) ; if ( PEEK_BITS ( 1 ) == 0 ) { REMOVE_BITS ( 1 ) ; READ_BITS ( extra_len , 8 ) ; } else if ( PEEK_BITS ( 2 ) == 2 ) { REMOVE_BITS ( 2 ) ; READ_BITS ( extra_len , 10 ) ; extra_len += 0x100 ; } else if ( PEEK_BITS ( 3 ) == 6 ) { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 12 ) ; extra_len += 0x500 ; } else { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 15 ) ; } match_length += extra_len ; } if ( ( window_posn + match_length ) > lzx -> window_size ) { D ( ( ""matchranoverwindowwrap"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } rundest = & window [ window_posn ] ; i = match_length ; if ( match_offset > window_posn ) { if ( match_offset > lzx -> offset && ( match_offset - window_posn ) > lzx -> ref_data_size ) { D ( ( ""matchoffsetbeyondLZXstream"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } j = match_offset - window_posn ; if ( j > ( int ) lzx -> window_size ) { D ( ( ""matchoffsetbeyondwindowboundaries"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } runsrc = & window [ lzx -> window_size - j ] ; if ( j < i ) { i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; runsrc = window ; } while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } else { runsrc = rundest - match_offset ; while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } this_run -= match_length ; window_posn += match_length ; } } break ; case LZX_BLOCKTYPE_ALIGNED : while ( this_run > 0 ) { READ_HUFFSYM ( MAINTREE , main_element ) ; if ( main_element < LZX_NUM_CHARS ) { window [ window_posn ++ ] = main_element ; this_run -- ; } else { main_element -= LZX_NUM_CHARS ; match_length = main_element & LZX_NUM_PRIMARY_LENGTHS ; if ( match_length == LZX_NUM_PRIMARY_LENGTHS ) { if ( lzx -> LENGTH_empty ) { D ( ( ""LENGTHsymbolneededbuttreeisempty"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } READ_HUFFSYM ( LENGTH , length_footer ) ; match_length += length_footer ; } match_length += LZX_MIN_MATCH ; switch ( ( match_offset = ( main_element >> 3 ) ) ) { case 0 : match_offset = R0 ; break ; case 1 : match_offset = R1 ; R1 = R0 ; R0 = match_offset ; break ; case 2 : match_offset = R2 ; R2 = R0 ; R0 = match_offset ; break ; default : extra = ( match_offset >= 36 ) ? 17 : extra_bits [ match_offset ] ; match_offset = position_base [ match_offset ] - 2 ; if ( extra > 3 ) { extra -= 3 ; READ_BITS ( verbatim_bits , extra ) ; match_offset += ( verbatim_bits << 3 ) ; READ_HUFFSYM ( ALIGNED , aligned_bits ) ; match_offset += aligned_bits ; } else if ( extra == 3 ) { READ_HUFFSYM ( ALIGNED , aligned_bits ) ; match_offset += aligned_bits ; } else if ( extra > 0 ) { READ_BITS ( verbatim_bits , extra ) ; match_offset += verbatim_bits ; } else { match_offset = 1 ; } R2 = R1 ; R1 = R0 ; R0 = match_offset ; } if ( match_length == LZX_MAX_MATCH && lzx -> is_delta ) { int extra_len = 0 ; ENSURE_BITS ( 3 ) ; if ( PEEK_BITS ( 1 ) == 0 ) { REMOVE_BITS ( 1 ) ; READ_BITS ( extra_len , 8 ) ; } else if ( PEEK_BITS ( 2 ) == 2 ) { REMOVE_BITS ( 2 ) ; READ_BITS ( extra_len , 10 ) ; extra_len += 0x100 ; } else if ( PEEK_BITS ( 3 ) == 6 ) { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 12 ) ; extra_len += 0x500 ; } else { REMOVE_BITS ( 3 ) ; READ_BITS ( extra_len , 15 ) ; } match_length += extra_len ; } if ( ( window_posn + match_length ) > lzx -> window_size ) { D ( ( ""matchranoverwindowwrap"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } rundest = & window [ window_posn ] ; i = match_length ; if ( match_offset > window_posn ) { if ( match_offset > lzx -> offset && ( match_offset - window_posn ) > lzx -> ref_data_size ) { D ( ( ""matchoffsetbeyondLZXstream"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } j = match_offset - window_posn ; if ( j > ( int ) lzx -> window_size ) { D ( ( ""matchoffsetbeyondwindowboundaries"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } runsrc = & window [ lzx -> window_size - j ] ; if ( j < i ) { i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; runsrc = window ; } while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } else { runsrc = rundest - match_offset ; while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; } this_run -= match_length ; window_posn += match_length ; } } break ; case LZX_BLOCKTYPE_UNCOMPRESSED : rundest = & window [ window_posn ] ; window_posn += this_run ; while ( this_run > 0 ) { if ( ( i = i_end - i_ptr ) == 0 ) { READ_IF_NEEDED ; } else { if ( i > this_run ) i = this_run ; lzx -> sys -> copy ( i_ptr , rundest , ( size_t ) i ) ; rundest += i ; i_ptr += i ; this_run -= i ; } } break ; default : return lzx -> error = MSPACK_ERR_DECRUNCH ; } if ( this_run < 0 ) { if ( ( unsigned int ) ( - this_run ) > lzx -> block_remaining ) { D ( ( ""overrunwentpastendofblockby%d(%dremaining)"" , - this_run , lzx -> block_remaining ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } lzx -> block_remaining -= - this_run ; } } if ( ( window_posn - lzx -> frame_posn ) != frame_size ) { D ( ( ""decodebeyondoutputframelimits!%d!=%d"" , window_posn - lzx -> frame_posn , frame_size ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } if ( bits_left > 0 ) ENSURE_BITS ( 16 ) ; if ( bits_left & 15 ) REMOVE_BITS ( bits_left & 15 ) ; if ( lzx -> o_ptr != lzx -> o_end ) { D ( ( ""%ldavailbytes,new%dframe"" , ( long ) ( lzx -> o_end - lzx -> o_ptr ) , frame_size ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } if ( lzx -> intel_started && lzx -> intel_filesize && ( lzx -> frame <= 32768 ) && ( frame_size > 10 ) ) { unsigned char * data = & lzx -> e8_buf [ 0 ] ; unsigned char * dataend = & lzx -> e8_buf [ frame_size - 10 ] ; signed int curpos = lzx -> intel_curpos ; signed int filesize = lzx -> intel_filesize ; signed int abs_off , rel_off ; lzx -> o_ptr = data ; lzx -> sys -> copy ( & lzx -> window [ lzx -> frame_posn ] , data , frame_size ) ; while ( data < dataend ) { if ( * data ++ != 0xE8 ) { curpos ++ ; continue ; } abs_off = data [ 0 ] | ( data [ 1 ] << 8 ) | ( data [ 2 ] << 16 ) | ( data [ 3 ] << 24 ) ; if ( ( abs_off >= - curpos ) && ( abs_off < filesize ) ) { rel_off = ( abs_off >= 0 ) ? abs_off - curpos : abs_off + filesize ; data [ 0 ] = ( unsigned char ) rel_off ; data [ 1 ] = ( unsigned char ) ( rel_off >> 8 ) ; data [ 2 ] = ( unsigned char ) ( rel_off >> 16 ) ; data [ 3 ] = ( unsigned char ) ( rel_off >> 24 ) ; } data += 4 ; curpos += 5 ; } lzx -> intel_curpos += frame_size ; } else { lzx -> o_ptr = & lzx -> window [ lzx -> frame_posn ] ; if ( lzx -> intel_filesize ) lzx -> intel_curpos += frame_size ; } lzx -> o_end = & lzx -> o_ptr [ frame_size ] ; i = ( out_bytes < ( off_t ) frame_size ) ? ( unsigned int ) out_bytes : frame_size ; if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; lzx -> frame_posn += frame_size ; lzx -> frame ++ ; if ( window_posn == lzx -> window_size ) window_posn = 0 ; if ( lzx -> frame_posn == lzx -> window_size ) lzx -> frame_posn = 0 ; } if ( out_bytes ) { D ( ( ""byteslefttooutput"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } STORE_BITS ; lzx -> window_posn = window_posn ; lzx -> R0 = R0 ; lzx -> R1 = R1 ; lzx -> R2 = R2 ; return MSPACK_ERR_OK ; }", = 1 ; if ( bits_left == 0 )  ( 16 )  ; bits_left =
292,"CWE-20 error_t httpCheckCharset ( const char_t * s , size_t length , uint_t charset ) { error_t error ; size_t i ; uint8_t c ; uint_t m ; error = NO_ERROR ; for ( i = 0 ; i < length ; i ++ ) { c = ( uint8_t ) s [ i ] ; m = HTTP_CHARSET_OCTET ; if ( iscntrl ( c ) ) m |= HTTP_CHARSET_CTL ; if ( isprint ( c ) && c <= 126 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR ; if ( c == '' || c == '\\t' ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS ; if ( isalpha ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA ; if ( osIsdigit ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT ; if ( isxdigit ( c ) ) m |= HTTP_CHARSET_HEX ; if ( c >= 128 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT ;  if ( strchr ( ""!#$%&\'*+-.^_`|~"" , c ) )  m |= HTTP_CHARSET_TCHAR ; if ( ( m & charset ) == 0 ) error = ERROR_INVALID_SYNTAX ; } return error ; }"," ; if ( osStrchr  ( ""!#$%&\'*+-.^_`|~"" ,"
293,"CWE-190 static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ;  bh -> b_size = map . m_len << inode -> i_blkbits ;  } return err ; }", -> b_size = ( u64 )
294,"CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) {  gint64 offset ;  int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ;  pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ;  if ( pkt_len == - 1 ) return FALSE ;  return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len ,   wth -> frame_buffer , err , err_info ) ;  }"," { gint64 offset  ; char line  = offset ; return parse_cosine_packet  ( wth ->  -> phdr ,  wth -> frame_buffer  wth -> frame_buffer , line"
295,"CWE-119 static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ;  char buf [ DN_BUF_LEN ] ;  unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ;  X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;  md -> subject_dn = strdup ( buf ) ;  if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; }  X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;  md -> issuer_dn = strdup ( buf ) ;  if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = pkinit_sans [ i ] ; free ( pkinit_sans ) ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = upn_sans [ i ] ; free ( upn_sans ) ; } md -> sans [ j ] = NULL ; } else md -> sans = NULL ; ret = crypto_retrieve_X509_key_usage ( context , plg_cryptoctx , req_cryptoctx , cert , & md -> ku_bits , & md -> eku_bits ) ; if ( ret ) goto cleanup ; * md_out = md ; md = NULL ; cleanup : crypto_cert_free_matching_data ( context , md ) ; return ret ; }"," , j ; * md_out = NULL ; md = calloc ( 1 , sizeof (  * md )  goto cleanup ; ret = rfc2253_name  ( X509_get_subject_name (  cert ) , &  md -> subject_dn  md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name  ( X509_get_issuer_name (  cert ) , &  md -> issuer_dn  md -> issuer_dn ) ; if ( ret ) goto cleanup ;  ret = crypto_retrieve_X509_sans"
296,"CWE-20 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ;  align_get_bits ( gb ) ;  if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( ""QMP4"" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , ""frameskip%d\\n"" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""startcode:%3X"" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectStart"" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectLayerStart"" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FGSbpstart"" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Reserved"" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqStart"" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectSeqEnd"" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""UserData"" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""GroupofVOPstart"" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoSessionError"" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VisualObjectStart"" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectPlanestart"" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""slicestart"" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""extensionstart"" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""fgsstart"" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectstart"" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , ""FBAObjectPlanestart"" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectstart"" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , ""MeshObjectPlanestart"" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , ""StillTextureObjectstart"" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSpatialLayerstart"" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureSNRLayerstart"" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureTilestart"" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""TextureShapeLayerstart"" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""stuffingstart"" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , ""reserved"" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Systemstart"" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , ""at%d\\n"" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , ""IgnoringmultipleVOLheaders\\n"" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { mpeg4_decode_profile_level ( s , gb ) ; if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; } } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { if ( ! s -> avctx -> bits_per_raw_sample ) { av_log ( s -> avctx , AV_LOG_ERROR , ""MissingVOLheader\\n"" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }", ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
297,"CWE-000 static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) {  int ret ;  if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;  ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;   usbnet_link_change ( dev , 0 , 0 ) ;  return ret ; }", intf ) {  if ( cdc_ncm_select_altsetting  - ENODEV ; return  cdc_ncm_bind_common ( dev  0 ) ;  }  
298,"CWE-125 static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( ""Warning:malformeddwarfattributecapacitydoesn\'tmatchlength\\n"" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , & da -> decls [ abbr_code - 1 ] . specs [ i ] , & cu -> dies [ cu -> length ] . attr_values [ i ] , & cu -> hdr , debug_str , debug_str_len ) ; if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ; sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; } cu -> dies [ cu -> length ] . length ++ ; } cu -> length ++ ; } return buf ; }","
"
299,"CWE-119 int vp8_calc_ss_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; for ( i = 0 ; i < source -> y_height ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ;  Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ;  } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }", ; Total += vpx_mse16x16  ( src +
300,"CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ;  } else if ( event -> type == et_char ) {  if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( ""scripting.html"" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }"," -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type =="
301,"CWE-119 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""Startingprocesscall\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ;  buflen = MIN ( buflen , buf_size ) ;  bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; header_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; WORD32 ht_in_mbs ; ht_in_mbs = ps_dec -> u2_pic_ht >> ( 4 + ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ; num_mb_skipped = ( ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret1 == ERROR_INV_SPS_PPS_T ) ) { ret = ret1 ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbsleftfordeblocking=%d\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) && ( ps_dec -> u4_pic_buf_got == 1 ) ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'tcomehere\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""Thenumbytesconsumed:%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }"," buflen , buf_size - 8"
302,"CWE-000 static int crossOriginDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; tok = sclone ( value ) ; while ( ( option = maGetNextArg ( tok , & tok ) ) != 0 ) {  option = stok ( option , ""=\\t,"" , & ovalue ) ;  ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( scaselessmatch ( option , ""origin"" ) ) { route -> corsOrigin = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , ""credentials"" ) ) { route -> corsCredentials = httpGetBoolToken ( ovalue ) ; } else if ( scaselessmatch ( option , ""headers"" ) ) { route -> corsHeaders = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , ""age"" ) ) { route -> corsAge = atoi ( ovalue ) ; } else { mprLog ( ""errorappwebconfig"" , 0 , ""UnknownCrossOriginoption%s"" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } # if KEEP if ( smatch ( route -> corsOrigin , ""*"" ) && route -> corsCredentials ) { mprLog ( ""errorappwebconfig"" , 0 , ""CrossOrigin:CannotusewildcardOriginifallowingcredentials"" ) ; return MPR_ERR_BAD_STATE ; } # endif httpAddRouteMethods ( route , ""OPTIONS"" ) ; route -> flags |= HTTP_ROUTE_CORS ; return 0 ; }"," { option = ssplit  ( option ,"
303,"CWE-369 tmsize_t TIFFReadEncodedStrip ( TIFF * tif , uint32 strip , void * buf , tmsize_t size ) { static const char module [ ] = ""TIFFReadEncodedStrip"" ; TIFFDirectory * td = & tif -> tif_dir ; uint32 rowsperstrip ; uint32 stripsperplane ; uint32 stripinplane ; uint16 plane ; uint32 rows ; tmsize_t stripsize ; if ( ! TIFFCheckRead ( tif , 0 ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( strip >= td -> td_nstrips ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""%lu:Stripoutofrange,max%lu"" , ( unsigned long ) strip , ( unsigned long ) td -> td_nstrips ) ; return ( ( tmsize_t ) ( - 1 ) ) ; } rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip > td -> td_imagelength ) rowsperstrip = td -> td_imagelength ;  stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;  stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( strip / stripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ; if ( rows > rowsperstrip ) rows = rowsperstrip ; stripsize = TIFFVStripSize ( tif , rows ) ; if ( stripsize == 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( td -> td_compression == COMPRESSION_NONE && size != ( tmsize_t ) ( - 1 ) && size >= stripsize && ! isMapped ( tif ) && ( ( tif -> tif_flags & TIFF_NOREADRAW ) == 0 ) ) { if ( TIFFReadRawStrip1 ( tif , strip , buf , stripsize , module ) != stripsize ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ! isFillOrder ( tif , td -> td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( buf , stripsize ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; } if ( ( size != ( tmsize_t ) ( - 1 ) ) && ( size < stripsize ) ) stripsize = size ; if ( ! TIFFFillStrip ( tif , strip ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ( * tif -> tif_decodestrip ) ( tif , buf , stripsize , plane ) <= 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; }"," ; stripsperplane = TIFFhowmany_32_maxuint_compat  ( td ->  td -> td_imagelength ,  rowsperstrip ) ;"
304,"CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ;  int hstartcol ;  if ( bufsize > QMFB_SPLITBUFSIZE ) {  if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {  abort ( ) ; } } if ( numrows >= 2 ) {  hstartcol = ( numrows + 1 - parity ) >> 1 ;   m = numrows - hstartcol ;  n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; }  dstptr = & a [ hstartcol * stride ] ;  srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }"," m ; int hstartrow  ; if (  ( buf = jas_alloc3  ( bufsize ,  ( bufsize , JPC_QMFB_COLGRPSIZE ,  2 ) { hstartrow  = ( numrows  = numrows - hstartrow  ; n =  & a [ hstartrow  * stride ]"
305,"CWE-190 bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ;  int x , y , i ;  old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ;  if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) )  return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0 ; s_map -> height = 0 ; for ( i = 0 ; i < s_map -> num_layers ; ++ i ) { if ( ! s_map -> layers [ i ] . is_parallax ) { s_map -> width = fmax ( s_map -> width , s_map -> layers [ i ] . width * tile_width ) ; s_map -> height = fmax ( s_map -> height , s_map -> layers [ i ] . height * tile_height ) ; } } for ( i = ( int ) vector_len ( s_map -> zones ) - 1 ; i >= 0 ; -- i ) { zone = vector_get ( s_map -> zones , i ) ; if ( zone -> bounds . x1 >= s_map -> width || zone -> bounds . y1 >= s_map -> height ) vector_remove ( s_map -> zones , i ) ; else { if ( zone -> bounds . x2 > s_map -> width ) zone -> bounds . x2 = s_map -> width ; if ( zone -> bounds . y2 > s_map -> height ) zone -> bounds . y2 = s_map -> height ; } } for ( i = ( int ) vector_len ( s_map -> triggers ) - 1 ; i >= 0 ; -- i ) { trigger = vector_get ( s_map -> triggers , i ) ; if ( trigger -> x >= s_map -> width || trigger -> y >= s_map -> height ) vector_remove ( s_map -> triggers , i ) ; } return true ; }", * zone ; size_t tilemap_size ;  . height ; tilemap_size =  x_size * y_size  struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
306,"CWE-119 static unsigned int help ( struct sk_buff * skb , enum ip_conntrack_info ctinfo , unsigned int protoff , unsigned int matchoff , unsigned int matchlen , struct nf_conntrack_expect * exp ) { char buffer [ sizeof ( ""429496729665635"" ) ] ;  u_int16_t port ;   unsigned int ret ;  exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ; exp -> dir = IP_CT_DIR_REPLY ; exp -> expectfn = nf_nat_follow_master ; for ( port = ntohs ( exp -> saved_proto . tcp . port ) ; port != 0 ; port ++ ) { int ret ; exp -> tuple . dst . u . tcp . port = htons ( port ) ; ret = nf_ct_expect_related ( exp ) ; if ( ret == 0 ) break ; else if ( ret != - EBUSY ) { port = 0 ; break ; } } if ( port == 0 ) {  nf_ct_helper_log ( skb , exp -> master , ""allportsinuse"" ) ;  return NF_DROP ; }  ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo ,  protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ; if ( ret != NF_ACCEPT ) {  nf_ct_helper_log ( skb , exp -> master , ""cannotmanglepacket"" ) ;  nf_ct_unexpect_related ( exp ) ; } return ret ; }"," ) ] ; struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ;  unsigned int ret ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3  ( skb , ct  , ""allportsinuse"" )  NF_DROP ; } snprintf ( buffer , sizeof ( buffer ) , ""%u%u"" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( ""nf_nat_irc:inserting\'%s\'==%pI4,port%u\\n"" , buffer , & newaddr . ip , port ) ;  ( skb , ct  , ctinfo ,  ( skb , ct  , ""cannotmanglepacket"" )"
307,"CWE-404 int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ;  args -> count = ntohl ( * p ++ ) ;  len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ;  return xdr_argsize_check ( rqstp , p ) ;  }"," p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0  v ; return 1  ; } "
308,"CWE-400 static void perf_swevent_overflow ( struct perf_event * event , u64 overflow ,  int nmi , struct perf_sample_data * data ,  struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ; int throttle = 0 ; data -> period = event -> hw . last_period ; if ( ! overflow ) overflow = perf_swevent_set_period ( event ) ; if ( hwc -> interrupts == MAX_INTERRUPTS ) return ; for ( ; overflow ; overflow -- ) {  if ( __perf_event_overflow ( event , nmi , throttle ,  data , regs ) ) { break ; } throttle = 1 ; } }"," u64 overflow ,  struct perf_sample_data *  ( event ,  throttle , data"
309,"CWE-119  static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) {  const __m128i kOne = _mm_set1_epi16 ( 1 ) ; __m128i in01 = _mm_unpacklo_epi64 ( res [ 0 ] , res [ 1 ] ) ; __m128i in23 = _mm_unpacklo_epi64 ( res [ 2 ] , res [ 3 ] ) ; __m128i out01 = _mm_add_epi16 ( in01 , kOne ) ; __m128i out23 = _mm_add_epi16 ( in23 , kOne ) ; out01 = _mm_srai_epi16 ( out01 , 2 ) ; out23 = _mm_srai_epi16 ( out23 , 2 ) ;  _mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ;   _mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ;  }"," void write_buffer_4x4 ( tran_low_t  * output ,  2 ) ; store_output ( & out01 ,  ( output +  * 8 ) ) ; store_output ( & out23 ,  ( output +  * 8 )  ) ; }"
310,"CWE-119 void color_cmyk_to_rgb ( opj_image_t * image ) { float C , M , Y , K ; float sC , sM , sY , sK ; unsigned int w , h , max , i ; w = image -> comps [ 0 ] . w ; h = image -> comps [ 0 ] . h ;  if ( image -> numcomps < 4 ) return ;  max = w * h ; sC = 1.0F / ( float ) ( ( 1 << image -> comps [ 0 ] . prec ) - 1 ) ; sM = 1.0F / ( float ) ( ( 1 << image -> comps [ 1 ] . prec ) - 1 ) ; sY = 1.0F / ( float ) ( ( 1 << image -> comps [ 2 ] . prec ) - 1 ) ; sK = 1.0F / ( float ) ( ( 1 << image -> comps [ 3 ] . prec ) - 1 ) ; for ( i = 0 ; i < max ; ++ i ) { C = ( float ) ( image -> comps [ 0 ] . data [ i ] ) * sC ; M = ( float ) ( image -> comps [ 1 ] . data [ i ] ) * sM ; Y = ( float ) ( image -> comps [ 2 ] . data [ i ] ) * sY ; K = ( float ) ( image -> comps [ 3 ] . data [ i ] ) * sK ; C = 1.0F - C ; M = 1.0F - M ; Y = 1.0F - Y ; K = 1.0F - K ; image -> comps [ 0 ] . data [ i ] = ( int ) ( 255.0F * C * K ) ; image -> comps [ 1 ] . data [ i ] = ( int ) ( 255.0F * M * K ) ; image -> comps [ 2 ] . data [ i ] = ( int ) ( 255.0F * Y * K ) ; } free ( image -> comps [ 3 ] . data ) ; image -> comps [ 3 ] . data = NULL ; image -> comps [ 0 ] . prec = 8 ; image -> comps [ 1 ] . prec = 8 ; image -> comps [ 2 ] . prec = 8 ; image -> numcomps -= 1 ; image -> color_space = OPJ_CLRSPC_SRGB ; for ( i = 3 ; i < image -> numcomps ; ++ i ) { memcpy ( & ( image -> comps [ i ] ) , & ( image -> comps [ i + 1 ] ) , sizeof ( image -> comps [ i ] ) ) ; } }"," ; if ( (  < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , ""%s:%d:color_cmyk_to_rgb\\n\\tCANNOTCONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; }  max = w"
311,"CWE-494 LONG ValidateSignature ( HWND hDlg , const char * path ) { LONG r ; WINTRUST_DATA trust_data = { 0 } ; WINTRUST_FILE_INFO trust_file = { 0 } ; GUID guid_generic_verify = { 0xaac56b , 0xcd44 , 0x11d0 , { 0x8c , 0xc2 , 0x0 , 0xc0 , 0x4f , 0xc2 , 0x95 , 0xee } } ; char * signature_name ; size_t i , len ; signature_name = GetSignatureName ( path ) ; if ( signature_name == NULL ) { uprintf ( ""PKI:Couldnotgetsignaturename"" ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; return TRUST_E_NOSIGNATURE ; } for ( i = 0 ; i < ARRAYSIZE ( cert_name ) ; i ++ ) { len = strlen ( cert_name [ i ] ) ; if ( strncmp ( signature_name , cert_name [ i ] , len ) == 0 ) { if ( ( len >= strlen ( signature_name ) ) || isspace ( signature_name [ len ] ) ) break ; } } if ( i >= ARRAYSIZE ( cert_name ) ) { uprintf ( ""PKI:Signature\'%s\'isunexpected..."" , signature_name ) ; if ( MessageBoxExU ( hDlg , lmprintf ( MSG_285 , signature_name ) , lmprintf ( MSG_283 ) , MB_YESNO | MB_ICONWARNING | MB_IS_RTL , selected_langid ) != IDYES ) return TRUST_E_EXPLICIT_DISTRUST ; } trust_file . cbStruct = sizeof ( trust_file ) ; trust_file . pcwszFilePath = utf8_to_wchar ( path ) ; if ( trust_file . pcwszFilePath == NULL ) { uprintf ( ""PKI:Unabletoconvert\'%s\'toUTF16"" , path ) ; return ERROR_SEVERITY_ERROR | FAC ( FACILITY_CERT ) | ERROR_NOT_ENOUGH_MEMORY ; } trust_data . cbStruct = sizeof ( trust_data ) ;  trust_data . dwUIChoice = WTD_UI_ALL ;  trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ; trust_data . dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400 ; trust_data . dwUnionChoice = WTD_CHOICE_FILE ; trust_data . pFile = & trust_file ; r = WinVerifyTrust ( NULL , & guid_generic_verify , & trust_data ) ; safe_free ( trust_file . pcwszFilePath ) ;  return r ;  }"," . dwUIChoice = WTD_UI_NONE  ; trust_data .  pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:Filedoesnotappeartobesigned:%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( ""PKI:Failedtovalidatesignature:%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }"
312,"CWE-787 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ;  for ( col = 0 ; col < imagewidth ; col += tw ) {  if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,can\'treadtileat%lu%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }", col < imagewidth && colb < imagew
313,"CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%sfailedvmentry%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  return 1 ;  case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }", case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
314,"CWE-119 static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 ) return 0 ; st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_rb32 ( pb ) ; entries = avio_rb32 ( pb ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) return AVERROR_INVALIDDATA ; av_free ( sc -> drefs ) ;  sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;  if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ; sc -> drefs_count = entries ; for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 ) return AVERROR_INVALIDDATA ; dref -> type = avio_rl32 ( pb ) ; avio_rb32 ( pb ) ; av_dlog ( c -> fc , ""type%.4ssize%d\\n"" , ( char * ) & dref -> type , size ) ; if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { uint16_t volume_len , len ; int16_t type ; avio_skip ( pb , 10 ) ; volume_len = avio_r8 ( pb ) ; volume_len = FFMIN ( volume_len , 27 ) ; avio_read ( pb , dref -> volume , 27 ) ; dref -> volume [ volume_len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , ""volume%s,len%d\\n"" , dref -> volume , volume_len ) ; avio_skip ( pb , 12 ) ; len = avio_r8 ( pb ) ; len = FFMIN ( len , 63 ) ; avio_read ( pb , dref -> filename , 63 ) ; dref -> filename [ len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , ""filename%s,len%d\\n"" , dref -> filename , len ) ; avio_skip ( pb , 16 ) ; dref -> nlvl_from = avio_rb16 ( pb ) ; dref -> nlvl_to = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , ""nlvlfrom%d,nlvlto%d\\n"" , dref -> nlvl_from , dref -> nlvl_to ) ; avio_skip ( pb , 16 ) ; for ( type = 0 ; type != - 1 && avio_tell ( pb ) < next ; ) { if ( url_feof ( pb ) ) return AVERROR_EOF ; type = avio_rb16 ( pb ) ; len = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , ""type%d,len%d\\n"" , type , len ) ; if ( len & 1 ) len += 1 ; if ( type == 2 ) { av_free ( dref -> path ) ; dref -> path = av_mallocz ( len + 1 ) ; if ( ! dref -> path ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> path , len ) ; if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) ) { len -= volume_len ; memmove ( dref -> path , dref -> path + volume_len , len ) ; dref -> path [ len ] = 0 ; } for ( j = 0 ; j < len ; j ++ ) if ( dref -> path [ j ] == ':' ) dref -> path [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , ""path%s\\n"" , dref -> path ) ; } else if ( type == 0 ) { av_free ( dref -> dir ) ; dref -> dir = av_malloc ( len + 1 ) ; if ( ! dref -> dir ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> dir , len ) ; dref -> dir [ len ] = 0 ; for ( j = 0 ; j < len ; j ++ ) if ( dref -> dir [ j ] == ':' ) dref -> dir [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , ""dir%s\\n"" , dref -> dir ) ; } else avio_skip ( pb , len ) ; } } avio_seek ( pb , next , SEEK_SET ) ; } return 0 ; }", ; sc -> drefs_count = 0 ; sc ->
315,"CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ;  }  ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , ""__wakeup"" , sizeof ( ""__wakeup"" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , ""__wakeup"" , sizeof ( ""__wakeup"" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }", ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
316,"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } }  ( void ) ReadBlobString ( image , text ) ;  if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }"
317,"CWE-476 static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ;  struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;  unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ;  write_lock ( & cluster -> cl_nodes_lock ) ;  if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ;  if ( ret )  return ret ; return count ; }", o2nm_cluster * cluster  ; unsigned long  - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; }  cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
318,CWE-119 void vp9_init_mv_probs ( VP9_COMMON * cm ) {  cm -> fc . nmvc = default_nmv_context ;  }, cm -> fc ->  nmvc = default_nmv_context
319,"CWE-476 static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ;  if ( ! * passwd || ! * user -> passwd )  return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }"," if ( ! user ) { slog_error ( client , ""Passwordpacketbeforeauthpacket?"" ) ; return false ; } if ( !"
320,"CWE-20 static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , * header ; size_t cb1_len , cb2_len , alloc_len ; unsigned char * cb1 , * cb2 ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = json_array_string ( val , 5 ) ; nbit = json_array_string ( val , 6 ) ; ntime = json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( prev_hash ) free ( prev_hash ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; if ( bbversion ) free ( bbversion ) ; if ( nbit ) free ( nbit ) ; if ( ntime ) free ( ntime ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; free ( pool -> swork . prev_hash ) ; free ( pool -> swork . bbversion ) ; free ( pool -> swork . nbit ) ; free ( pool -> swork . ntime ) ; pool -> swork . job_id = job_id ; pool -> swork . prev_hash = prev_hash ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; pool -> swork . bbversion = bbversion ; pool -> swork . nbit = nbit ; pool -> swork . ntime = ntime ; pool -> swork . clean = clean ; alloc_len = pool -> swork . cb_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; pool -> nonce2_offset = cb1_len + pool -> n1_len ; for ( i = 0 ; i < pool -> swork . merkles ; i ++ ) free ( pool -> swork . merkle_bin [ i ] ) ; if ( merkles ) { pool -> swork . merkle_bin = ( unsigned char * * ) realloc ( pool -> swork . merkle_bin , sizeof ( char * ) * merkles + 1 ) ; for ( i = 0 ; i < merkles ; i ++ ) { char * merkle = json_array_string ( arr , i ) ; pool -> swork . merkle_bin [ i ] = ( unsigned char * ) malloc ( 32 ) ; if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) quit ( 1 , ""Failedtomallocpoolsworkmerkle_bin"" ) ; hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; free ( merkle ) ; } } pool -> swork . merkles = merkles ; if ( clean ) pool -> nonce2 = 0 ; pool -> merkle_offset = strlen ( pool -> swork . bbversion ) + strlen ( pool -> swork . prev_hash ) ; pool -> swork . header_len = pool -> merkle_offset + 32 + strlen ( pool -> swork . ntime ) + strlen ( pool -> swork . nbit ) + 8 + 96 ; pool -> merkle_offset /= 2 ; pool -> swork . header_len = pool -> swork . header_len * 2 + 1 ; align_len ( & pool -> swork . header_len ) ; header = ( char * ) alloca ( pool -> swork . header_len ) ; snprintf ( header , pool -> swork . header_len , ""%s%s%s%s%s%s%s"" , pool -> swork . bbversion , pool -> swork . prev_hash , blank_merkel , pool -> swork . ntime , pool -> swork . nbit , ""00000000"" , workpadding ) ; if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) )  quit ( 1 , ""Failedtoconvertheadertoheader_bininparse_notify"" ) ;  cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ; if ( unlikely ( ! cb1 ) ) quithere ( 1 , ""Failedtocalloccb1inparse_notify"" ) ; hex2bin ( cb1 , coinbase1 , cb1_len ) ; cb2 = ( unsigned char * ) calloc ( cb2_len , 1 ) ; if ( unlikely ( ! cb2 ) ) quithere ( 1 , ""Failedtocalloccb2inparse_notify"" ) ; hex2bin ( cb2 , coinbase2 , cb2_len ) ; free ( pool -> coinbase ) ; align_len ( & alloc_len ) ; pool -> coinbase = ( unsigned char * ) calloc ( alloc_len , 1 ) ; if ( unlikely ( ! pool -> coinbase ) ) quit ( 1 , ""Failedtocallocpoolcoinbaseinparse_notify"" ) ; memcpy ( pool -> coinbase , cb1 , cb1_len ) ; memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; cg_wunlock ( & pool -> data_lock ) ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""job_id:%s"" , job_id ) ; applog ( LOG_DEBUG , ""prev_hash:%s"" , prev_hash ) ; applog ( LOG_DEBUG , ""coinbase1:%s"" , coinbase1 ) ; applog ( LOG_DEBUG , ""coinbase2:%s"" , coinbase2 ) ; applog ( LOG_DEBUG , ""bbversion:%s"" , bbversion ) ; applog ( LOG_DEBUG , ""nbit:%s"" , nbit ) ; applog ( LOG_DEBUG , ""ntime:%s"" , ntime ) ; applog ( LOG_DEBUG , ""clean:%s"" , clean ? ""yes"" : ""no"" ) ; } free ( coinbase1 ) ; free ( coinbase2 ) ; free ( cb1 ) ; free ( cb2 ) ; pool -> getwork_requested ++ ; total_getworks ++ ; ret = true ; if ( pool == current_pool ( ) ) opt_work_update = true ; out : return ret ; }"," ) ) ) { applog ( LOG_WARNING , ""%s:Failedtoconvertheadertoheader_bin,got%s"" , __func__ , header ) ; pool_failed ( pool ) ; return false ; }  cb1 = ("
321,"CWE-476 int build_ntlmssp_auth_blob ( unsigned char * * pbuffer , u16 * buflen , struct cifs_ses * ses , const struct nls_table * nls_cp ) { int rc ; AUTHENTICATE_MESSAGE * sec_blob ; __u32 flags ; unsigned char * tmp ; rc = setup_ntlmv2_rsp ( ses , nls_cp ) ; if ( rc ) { cifs_dbg ( VFS , ""Error%dduringNTLMSSPauthentication\\n"" , rc ) ; * buflen = 0 ; goto setup_ntlmv2_ret ; } * pbuffer = kmalloc ( size_of_ntlmssp_blob ( ses ) , GFP_KERNEL ) ; sec_blob = ( AUTHENTICATE_MESSAGE * ) * pbuffer ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmAuthenticate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |  NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ;   if ( ses -> server -> sign ) {  flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ;  }  tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ; sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> LmChallengeResponse . BufferOffset = cpu_to_le32 ( sizeof ( AUTHENTICATE_MESSAGE ) ) ; sec_blob -> LmChallengeResponse . Length = 0 ; sec_blob -> LmChallengeResponse . MaximumLength = 0 ; sec_blob -> NtChallengeResponse . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; if ( ses -> user_name != NULL ) { memcpy ( tmp , ses -> auth_key . response + CIFS_SESS_KEY_SIZE , ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; tmp += ses -> auth_key . len - CIFS_SESS_KEY_SIZE ; sec_blob -> NtChallengeResponse . Length = cpu_to_le16 ( ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; sec_blob -> NtChallengeResponse . MaximumLength = cpu_to_le16 ( ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; } else { sec_blob -> NtChallengeResponse . Length = 0 ; sec_blob -> NtChallengeResponse . MaximumLength = 0 ; } if ( ses -> domainName == NULL ) { sec_blob -> DomainName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; tmp += 2 ; } else { int len ; len = cifs_strtoUTF16 ( ( __le16 * ) tmp , ses -> domainName , CIFS_MAX_DOMAINNAME_LEN , nls_cp ) ; len *= 2 ; sec_blob -> DomainName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> DomainName . Length = cpu_to_le16 ( len ) ; sec_blob -> DomainName . MaximumLength = cpu_to_le16 ( len ) ; tmp += len ; } if ( ses -> user_name == NULL ) { sec_blob -> UserName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> UserName . Length = 0 ; sec_blob -> UserName . MaximumLength = 0 ; tmp += 2 ; } else { int len ; len = cifs_strtoUTF16 ( ( __le16 * ) tmp , ses -> user_name , CIFS_MAX_USERNAME_LEN , nls_cp ) ; len *= 2 ; sec_blob -> UserName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> UserName . Length = cpu_to_le16 ( len ) ; sec_blob -> UserName . MaximumLength = cpu_to_le16 ( len ) ; tmp += len ; } sec_blob -> WorkstationName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; tmp += 2 ; if ( ( ( ses -> ntlmssp -> server_flags & NTLMSSP_NEGOTIATE_KEY_XCH ) || ( ses -> ntlmssp -> server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC ) ) && ! calc_seckey ( ses ) ) { memcpy ( tmp , ses -> ntlmssp -> ciphertext , CIFS_CPHTXT_SIZE ) ; sec_blob -> SessionKey . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> SessionKey . Length = cpu_to_le16 ( CIFS_CPHTXT_SIZE ) ; sec_blob -> SessionKey . MaximumLength = cpu_to_le16 ( CIFS_CPHTXT_SIZE ) ; tmp += CIFS_CPHTXT_SIZE ; } else { sec_blob -> SessionKey . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> SessionKey . Length = 0 ; sec_blob -> SessionKey . MaximumLength = 0 ; } * buflen = tmp - * pbuffer ; setup_ntlmv2_ret : return rc ; }", NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL  -> sign )  flags |= NTLMSSP_NEGOTIATE_SIGN  |= NTLMSSP_NEGOTIATE_KEY_XCH ;  tmp = *
322,"CWE-354 void next_character ( void )  {  strlcpy ( cipher , english_alphabet , ENGLISH_ALPHABET_BUF ) ; random_permute_char ( cipher , strlen ( cipher ) ) ; static char CONFIDENTIAL current_word [ CURRENT_WORD_BUF ] ; get_current_word ( current_word ) ; if ( strlen ( current_word ) > 4 ) { memzero ( current_word , sizeof ( current_word ) ) ; recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError , ""Wordswerenotenteredcorrectly.Makesureyouareusingthesubstitioncipher."" ) ; layoutHome ( ) ; return ; } CharacterRequest resp ; memset ( & resp , 0 , sizeof ( CharacterRequest ) ) ; resp . word_pos = get_current_word_pos ( ) ; resp . character_pos = strlen ( current_word ) ; msg_write ( MessageType_MessageType_CharacterRequest , & resp ) ; bool auto_completed = false ; if ( strlen ( current_word ) >= 3 ) { auto_completed = attempt_auto_complete ( current_word ) ; } # if DEBUG_LINK if ( auto_completed ) { strlcpy ( auto_completed_word , current_word , CURRENT_WORD_BUF ) ; } else { auto_completed_word [ 0 ] = '\\0' ; } # endif format_current_word ( current_word , auto_completed ) ; layout_cipher ( current_word , cipher ) ; memzero ( current_word , sizeof ( current_word ) ) ; }"," void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""NotinRecoverymode"" ) ; layoutHome ( ) ; return ; }"
323,"CWE-125 struct _mdi * _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; uint32_t mus_song_ofs = 0 ; uint32_t mus_song_len = 0 ; uint16_t mus_ch_cnt1 = 0 ; uint16_t mus_ch_cnt2 = 0 ; uint16_t mus_no_instr = 0 ; uint32_t mus_data_ofs = 0 ; uint16_t * mus_mid_instr = NULL ; uint16_t mus_instr_cnt = 0 ; struct _mdi * mus_mdi ; uint32_t mus_divisions = 60 ; float tempo_f = 0.0 ; uint16_t mus_freq = 0 ; float samples_per_tick_f = 0.0 ;  uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ;  uint8_t mus_event_size = 0 ; uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; uint32_t setup_ret = 0 ; uint32_t mus_ticks = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint16_t pitchbend_tmp = 0 ; if ( mus_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""Filetooshort"" , 0 ) ; return NULL ; } if ( memcmp ( mus_data , mus_hdr , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; return NULL ; } mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; mus_song_ofs = ( mus_data [ 7 ] << 8 ) | mus_data [ 6 ] ; mus_ch_cnt1 = ( mus_data [ 9 ] << 8 ) | mus_data [ 8 ] ; mus_ch_cnt2 = ( mus_data [ 11 ] << 8 ) | mus_data [ 10 ] ; UNUSED ( mus_ch_cnt1 ) ; UNUSED ( mus_ch_cnt2 ) ; mus_no_instr = ( mus_data [ 13 ] << 8 ) | mus_data [ 12 ] ; mus_data_ofs = 16 ; if ( mus_size < ( mus_data_ofs + ( mus_no_instr << 1 ) + mus_song_len ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , ""Filetooshort"" , 0 ) ; return NULL ; } mus_mid_instr = malloc ( mus_no_instr * sizeof ( uint16_t ) ) ; for ( mus_instr_cnt = 0 ; mus_instr_cnt < mus_no_instr ; mus_instr_cnt ++ ) { mus_mid_instr [ mus_instr_cnt ] = ( mus_data [ mus_data_ofs + 1 ] << 8 ) | mus_data [ mus_data_ofs ] ; mus_data_ofs += 2 ; } mus_data_ofs = mus_song_ofs ; mus_freq = _cvt_get_option ( WM_CO_FREQUENCY ) ; if ( mus_freq == 0 ) mus_freq = 140 ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / mus_freq ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / mus_freq ) ; } samples_per_tick_f = _WM_GetSamplesPerTick ( mus_divisions , ( uint32_t ) tempo_f ) ; mus_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mus_mdi , mus_divisions ) ; _WM_midi_setup_tempo ( mus_mdi , ( uint32_t ) tempo_f ) ; do { _mus_build_event : # if 1 MUS_EVENT_DEBUG ( ""Before"" , mus_data [ mus_data_ofs ] , 0 ) ; if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x0f ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x09 ; } else if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x09 ) { mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x0f ; } MUS_EVENT_DEBUG ( ""After"" , mus_data [ mus_data_ofs ] , 0 ) ; # endif switch ( ( mus_data [ mus_data_ofs ] >> 4 ) & 0x07 ) { case 0 : mus_event_size = 2 ; mus_event [ 0 ] = 0x80 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : if ( mus_data [ mus_data_ofs + 1 ] & 0x80 ) { mus_event_size = 3 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] & 0x7f ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] = mus_event [ 2 ] ; } else { mus_event_size = 2 ; mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; mus_event [ 2 ] = mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] ; mus_event [ 3 ] = 0 ; } break ; case 2 : mus_event_size = 2 ; mus_event [ 0 ] = 0xe0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; pitchbend_tmp = mus_data [ mus_data_ofs + 1 ] << 6 ; mus_event [ 1 ] = pitchbend_tmp & 0x7f ; mus_event [ 2 ] = ( pitchbend_tmp >> 7 ) & 0x7f ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event_size = 2 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 10 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 120 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 11 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 123 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 12 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 126 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 13 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 127 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 14 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 121 ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 4 : mus_event_size = 3 ; switch ( mus_data [ mus_data_ofs + 1 ] ) { case 0 : mus_event [ 0 ] = 0xc0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 2 ] = 0 ; mus_event [ 3 ] = 0 ; break ; case 1 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 0 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 2 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 1 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 3 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 7 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 4 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 10 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 5 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 11 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 6 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 91 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 7 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 93 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 8 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 64 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 9 : mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; mus_event [ 1 ] = 67 ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; default : goto _mus_next_data ; } break ; case 5 : mus_event_size = 1 ; goto _mus_next_data ; break ; case 6 : goto _mus_end_of_song ; break ; case 7 : mus_event_size = 1 ; goto _mus_next_data ; break ; }  setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ;  if ( setup_ret == 0 ) { goto _mus_end ; } _mus_next_data : if ( ! ( mus_data [ mus_data_ofs ] & 0x80 ) ) { mus_data_ofs += mus_event_size ; goto _mus_build_event ; } mus_data_ofs += mus_event_size ; mus_ticks = 0 ; do { mus_ticks = ( mus_ticks << 7 ) | ( mus_data [ mus_data_ofs ++ ] & 0x7f ) ; } while ( mus_data [ mus_data_ofs - 1 ] & 0x80 ) ; sample_count_f = ( ( float ) mus_ticks * samples_per_tick_f ) + sample_remainder ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mus_mdi -> events [ mus_mdi -> event_count - 1 ] . samples_to_next = sample_count ; mus_mdi -> extra_info . approx_total_samples += sample_count ; } while ( mus_data_ofs < mus_size ) ; _mus_end_of_song : if ( ( mus_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""toinitreverb"" , 0 ) ; goto _mus_end ; } _WM_midi_setup_endoftrack ( mus_mdi ) ; mus_mdi -> extra_info . current_sample = 0 ; mus_mdi -> current_event = & mus_mdi -> events [ 0 ] ; mus_mdi -> samples_to_mix = 0 ; mus_mdi -> note = NULL ; _WM_ResetToStart ( mus_mdi ) ; _mus_end : free ( mus_mid_instr ) ; if ( mus_mdi -> reverb ) return ( mus_mdi ) ; _WM_freeMDI ( mus_mdi ) ; return NULL ; }"," = 0.0 ; # define MUS_SZ 4  uint8_t mus_event [ MUS_SZ  * ) mus_event , MUS_SZ"
324,"CWE-269 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) {  void * dllhandle ;  if ( useSystemLib ) Com_Printf ( ""Tryingtoload\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading\\""%s\\""failed\\n"" , name ) ; } } return dllhandle ; }"," * dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""RejectingDLLnamed\\""%s\\"""" , name ) ; return NULL ; }"
325,"CWE-476 static int f2fs_set_data_page_dirty ( struct page * page ) {  struct address_space * mapping = page -> mapping ;   struct inode * inode = mapping -> host ;  trace_f2fs_set_page_dirty ( page , DATA ) ; if ( ! PageUptodate ( page ) )  SetPageUptodate ( page ) ;  if ( f2fs_is_atomic_file ( inode ) && ! f2fs_is_commit_atomic_write ( inode ) ) { if ( ! IS_ATOMIC_WRITTEN_PAGE ( page ) ) { f2fs_register_inmem_page ( inode , page ) ; return 1 ; } return 0 ; } if ( ! PageDirty ( page ) ) { __set_page_dirty_nobuffers ( page ) ; f2fs_update_dirty_page ( inode , page ) ; return 1 ; } return 0 ; }", ) { struct  inode * inode  * inode = page_file_mapping ( page )  -> host ;  ) ) SetPageUptodate ( page ) ; if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers
326,"CWE-119 static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ;  if ( count < DJREPORT_SHORT_LENGTH - 2 )  count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }", if ( count >  DJREPORT_SHORT_LENGTH - 2
327,"CWE-119 static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;  if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {  pr_err ( ""set_ctl:len%u!=%u\\n"" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user * ) arg ; udest_compat = ( struct ip_vs_dest_user * ) ( usvc_compat + 1 ) ; ip_vs_copy_usvc_compat ( & usvc , usvc_compat ) ; ip_vs_copy_udest_compat ( & udest , udest_compat ) ; if ( cmd == IP_VS_SO_SET_ZERO ) { if ( ! usvc . fwmark && ! usvc . addr . ip && ! usvc . port ) { ret = ip_vs_zero_all ( ) ; goto out_unlock ; } } if ( usvc . protocol != IPPROTO_TCP && usvc . protocol != IPPROTO_UDP ) { pr_err ( ""set_ctl:invalidprotocol:%d%pI4:%d%s\\n"" , usvc . protocol , & usvc . addr . ip , ntohs ( usvc . port ) , usvc . sched_name ) ; ret = - EFAULT ; goto out_unlock ; } if ( usvc . fwmark == 0 ) svc = __ip_vs_service_get ( usvc . af , usvc . protocol , & usvc . addr , usvc . port ) ; else svc = __ip_vs_svc_fwm_get ( usvc . af , usvc . fwmark ) ; if ( cmd != IP_VS_SO_SET_ADD && ( svc == NULL || svc -> protocol != usvc . protocol ) ) { ret = - ESRCH ; goto out_unlock ; } switch ( cmd ) { case IP_VS_SO_SET_ADD : if ( svc != NULL ) ret = - EEXIST ; else ret = ip_vs_add_service ( & usvc , & svc ) ; break ; case IP_VS_SO_SET_EDIT : ret = ip_vs_edit_service ( svc , & usvc ) ; break ; case IP_VS_SO_SET_DEL : ret = ip_vs_del_service ( svc ) ; if ( ! ret ) goto out_unlock ; break ; case IP_VS_SO_SET_ZERO : ret = ip_vs_zero_service ( svc ) ; break ; case IP_VS_SO_SET_ADDDEST : ret = ip_vs_add_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_EDITDEST : ret = ip_vs_edit_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_DELDEST : ret = ip_vs_del_dest ( svc , & udest ) ; break ; default : ret = - EINVAL ; } if ( svc ) ip_vs_service_put ( svc ) ; out_unlock : mutex_unlock ( & __ip_vs_mutex ) ; out_dec : ip_vs_use_count_dec ( ) ; return ret ; }", ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (
328,"CWE-189 static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ;  while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END )  { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , ""stacktooshort"" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case CLOSE : while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; break ; case ERR : default : ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntaxerror"" ) ) ) ; return ERR ; } } while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; }", = 0 ; check_stack_depth ( ) ;
329,"CWE-125 static expr_ty ast_for_call ( struct compiling * c , const node * n , expr_ty func ) { int i , nargs , nkeywords , ngens ; asdl_seq * args ; asdl_seq * keywords ; expr_ty vararg = NULL , kwarg = NULL ; REQ ( n , arglist ) ; nargs = 0 ; nkeywords = 0 ; ngens = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { if ( NCH ( ch ) == 1 ) nargs ++ ; else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) ngens ++ ; else nkeywords ++ ; } } if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { ast_error ( n , ""Generatorexpressionmustbeparenthesized"" ""ifnotsoleargument"" ) ; return NULL ; } if ( nargs + nkeywords + ngens > 255 ) { ast_error ( n , ""morethan255arguments"" ) ; return NULL ; } args = asdl_seq_new ( nargs + ngens , c -> c_arena ) ; if ( ! args ) return NULL ; keywords = asdl_seq_new ( nkeywords , c -> c_arena ) ; if ( ! keywords ) return NULL ; nargs = 0 ; nkeywords = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { expr_ty e ; if ( NCH ( ch ) == 1 ) { if ( nkeywords ) { ast_error ( CHILD ( ch , 0 ) , ""non-keywordargafterkeywordarg"" ) ; return NULL ; } if ( vararg ) { ast_error ( CHILD ( ch , 0 ) , ""onlynamedargumentsmayfollow*expression"" ) ; return NULL ; } e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { e = ast_for_genexp ( c , ch ) ; if ( ! e ) return NULL ; asdl_seq_SET ( args , nargs ++ , e ) ; } else { keyword_ty kw ; identifier key ; int k ;  char * tmp ;  e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ; if ( ! e ) return NULL ; if ( e -> kind == Lambda_kind ) { ast_error ( CHILD ( ch , 0 ) , ""lambdacannotcontainassignment"" ) ; return NULL ; } else if ( e -> kind != Name_kind ) { ast_error ( CHILD ( ch , 0 ) , ""keywordcan\'tbeanexpression"" ) ; return NULL ; } key = e -> v . Name . id ; if ( ! forbidden_check ( c , CHILD ( ch , 0 ) , PyUnicode_AsUTF8 ( key ) ) ) return NULL ; for ( k = 0 ; k < nkeywords ; k ++ ) { tmp = _PyUnicode_AsString ( ( ( keyword_ty ) asdl_seq_GET ( keywords , k ) ) -> arg ) ; if ( ! strcmp ( tmp , _PyUnicode_AsString ( key ) ) ) { ast_error ( CHILD ( ch , 0 ) , ""keywordargumentrepeated"" ) ; return NULL ; } } e = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! e ) return NULL ; kw = keyword ( key , e , c -> c_arena ) ; if ( ! kw ) return NULL ; asdl_seq_SET ( keywords , nkeywords ++ , kw ) ; } } else if ( TYPE ( ch ) == STAR ) { vararg = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! vararg ) return NULL ; i ++ ; } else if ( TYPE ( ch ) == DOUBLESTAR ) { kwarg = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! kwarg ) return NULL ; i ++ ; } } return Call ( func , args , keywords , vararg , kwarg , func -> lineno , func -> col_offset , c -> c_arena ) ; }", int k ; const
330,"CWE-20 SPL_METHOD ( Array , unserialize ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * buf ; int buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval * pmembers , * pflags = NULL ; HashTable * aht ; long flags ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } aht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; if ( aht -> nApplyCount > 0 ) { zend_error ( E_WARNING , ""ModificationofArrayObjectduringsortingisprohibited"" ) ; return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pflags ) ; if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) { goto outexcept ; } var_push_dtor ( & var_hash , & pflags ) ; -- p ; flags = Z_LVAL_P ( pflags ) ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' ) { if ( * p != 'a' && * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } intern -> ar_flags &= ~ SPL_ARRAY_CLONE_MASK ; intern -> ar_flags |= flags & SPL_ARRAY_CLONE_MASK ; zval_ptr_dtor ( & intern -> array ) ; ALLOC_INIT_ZVAL ( intern -> array ) ;  if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) {  goto outexcept ; } var_push_dtor ( & var_hash , & intern -> array ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pmembers ) ; if ( ! php_var_unserialize ( & pmembers , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { zval_ptr_dtor ( & pmembers ) ; goto outexcept ; } var_push_dtor ( & var_hash , & pmembers ) ; if ( ! intern -> std . properties ) { rebuild_object_properties ( & intern -> std ) ; } zend_hash_copy ( intern -> std . properties , Z_ARRVAL_P ( pmembers ) , ( copy_ctor_func_t ) zval_add_ref , ( void * ) NULL , sizeof ( zval * ) ) ; zval_ptr_dtor ( & pmembers ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , ""Erroratoffset%ldof%dbytes"" , ( long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }", var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ;  goto outexcept ;
331,"CWE-617 int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ;  assert ( idx >= 0 && idx <= PCI_BARMAX ) ;  if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ;  case PCIBAR_MEM64 :  if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default :  printf ( ""%s:invalidbartype%d\\n"" , __func__ , type ) ;   assert ( 0 ) ;  } if ( baseptr != NULL ) { error = pci_emul_alloc_resource ( baseptr , limit , size , & addr ) ; if ( error != 0 ) return error ; } pdi -> bar [ idx ] . type = type ; pdi -> bar [ idx ] . addr = addr ; pdi -> bar [ idx ] . size = size ; bar = ( addr & mask ) | lobits ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx ) , bar ) ; if ( type == PCIBAR_MEM64 ) {  assert ( idx + 1 <= PCI_BARMAX ) ;  pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ; pci_set_cfgdata32 ( pdi , PCIR_BAR ( idx + 1 ) , bar >> 32 ) ; } register_bar ( pdi , idx ) ; return 0 ; }"," , bar ;  if ( (  case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( ""%s:invalidbarnumber%dforMEM64type\\n"" , __func__ , idx ) ; return - 1 ; }  ; default : pr_err  ( ""%s:invalidbartype%d\\n"" ,  type ) ; return - 1  ; } if  PCIBAR_MEM64 ) {  pdi -> bar"
332,"CWE-667 static void * gp_worker_main ( void * pvt ) { struct gp_thread * t = ( struct gp_thread * ) pvt ; struct gp_query * q = NULL ; char dummy = 0 ; int ret ; while ( ! t -> pool -> shutdown ) { gp_debug_set_conn_id ( 0 ) ; pthread_mutex_lock ( & t -> cond_mutex ) ; while ( t -> query == NULL ) { pthread_cond_wait ( & t -> cond_wakeup , & t -> cond_mutex ) ;  if ( t -> pool -> shutdown ) {  pthread_exit ( NULL ) ; } } q = t -> query ; t -> query = NULL ; pthread_mutex_unlock ( & t -> cond_mutex ) ; gp_debug_set_conn_id ( gp_conn_get_cid ( q -> conn ) ) ; GPDEBUGN ( 3 , ""[status]Handlingqueryinput:%p(%zu)\\n"" , q -> buffer , q -> buflen ) ; gp_handle_query ( t -> pool , q ) ; GPDEBUGN ( 3 , ""[status]Handlingqueryoutput:%p(%zu)\\n"" , q -> buffer , q -> buflen ) ; pthread_mutex_lock ( & t -> pool -> lock ) ; q -> next = t -> pool -> reply_list ; t -> pool -> reply_list = q ; if ( ! t -> pool -> shutdown ) { LIST_DEL ( t -> pool -> busy_list , t ) ; LIST_ADD ( t -> pool -> free_list , t ) ; } pthread_mutex_unlock ( & t -> pool -> lock ) ; ret = write ( t -> pool -> sig_pipe [ 1 ] , & dummy , 1 ) ; if ( ret == - 1 ) { GPERROR ( ""Failedtosignaldispatcher!"" ) ; } } pthread_exit ( NULL ) ; }", shutdown ) { pthread_mutex_unlock ( & t -> cond_mutex ) ;
333,"CWE-119 int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == USBIP_STUB ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ;  ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;  if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recvxbuf,%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ;  } else {  usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }  return ret ;  }"," return 0 ; if ( size > urb -> transfer_buffer_length ) {  if ( ud  SDEV_EVENT_ERROR_TCP ) ; return 0 ;  ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recvxbuf,%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }"
334,"CWE-362 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:inode%lu,logical"" ""block%llu,max_blocks%u,flags%x,allocated%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {  ret = ext4_convert_unwritten_extents_endio ( handle , inode ,  path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { map -> m_flags |= EXT4_MAP_UNWRITTEN ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , map , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; map -> m_flags |= EXT4_MAP_NEW ; if ( allocated > map -> m_len ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + map -> m_len , allocated - map -> m_len ) ; allocated = map -> m_len ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) { unsigned int reserved_clusters ; reserved_clusters = get_reserved_cluster_alloc ( inode , map -> m_lblk , map -> m_len ) ; if ( reserved_clusters ) ext4_da_update_reserve_space ( inode , reserved_clusters , 0 ) ; } map_out : map -> m_flags |= EXT4_MAP_MAPPED ; if ( ( flags & EXT4_GET_BLOCKS_KEEP_SIZE ) == 0 ) { err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; if ( err < 0 ) goto out2 ; } out1 : if ( allocated > map -> m_len ) allocated = map -> m_len ; ext4_ext_show_leaf ( inode , path ) ; map -> m_pblk = newblock ; map -> m_len = allocated ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }"," , inode , map ,"
335,"CWE-476 av_cold void ff_mpv_idct_init ( MpegEncContext * s )  {  ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }", s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
336,"CWE-399 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ;  if ( perf_event_overflow ( event , 0 , data , regs ) )  mipspmu -> disable_event ( idx ) ; }"," ( event ,  data , regs"
337,"CWE-400 static inline int add_post_vars ( zval * arr , post_var_data_t * vars , zend_bool eof TSRMLS_DC ) { uint64_t max_vars = PG ( max_input_vars ) ; vars -> ptr = vars -> str . c ; vars -> end = vars -> str . c + vars -> str . len ; while ( add_post_var ( arr , vars , eof TSRMLS_CC ) ) { if ( ++ vars -> cnt > max_vars ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Inputvariablesexceeded%"" PRIu64 ""."" ""Toincreasethelimitchangemax_input_varsinphp.ini."" , max_vars ) ; return FAILURE ; } }  if ( ! eof ) {  memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ; }", ( ! eof && vars -> str . c != vars -> ptr
338,"CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ;  retval = generic_gss_oid_decompose ( minor_status ,  GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }", = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
339,"CWE-476 static int mailimf_group_parse ( const char * message , size_t length , size_t * indx , struct mailimf_group * * result ) { size_t cur_token ; char * display_name ; struct mailimf_mailbox_list * mailbox_list ; struct mailimf_group * group ; int r ; int res ;  cur_token = * indx ;  mailbox_list = NULL ; r = mailimf_display_name_parse ( message , length , & cur_token , & display_name ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto err ; } r = mailimf_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_display_name ; } r = mailimf_mailbox_list_parse ( message , length , & cur_token , & mailbox_list ) ; switch ( r ) { case MAILIMF_NO_ERROR : break ; case MAILIMF_ERROR_PARSE : r = mailimf_cfws_parse ( message , length , & cur_token ) ; if ( ( r != MAILIMF_NO_ERROR ) && ( r != MAILIMF_ERROR_PARSE ) ) {  res = r ;  goto free_display_name ; } break ; default : res = r ; goto free_display_name ; } r = mailimf_semi_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_mailbox_list ; } group = mailimf_group_new ( display_name , mailbox_list ) ; if ( group == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_mailbox_list ; } * indx = cur_token ; * result = group ; return MAILIMF_NO_ERROR ; free_mailbox_list : if ( mailbox_list != NULL ) { mailimf_mailbox_list_free ( mailbox_list ) ; } free_display_name : mailimf_display_name_free ( display_name ) ; err : return res ; }", int res ; clist * list ;  res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )
340,"CWE-400 void handle_ld_nf ( u32 insn , struct pt_regs * regs ) { int rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; unsigned long * reg ;  perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;  maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ; if ( from_kernel || rd < 16 ) { reg [ 0 ] = 0 ; if ( ( insn & 0x780000 ) == 0x180000 ) reg [ 1 ] = 0 ; } else if ( test_thread_flag ( TIF_32BIT ) ) { put_user ( 0 , ( int __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( ( int __user * ) reg ) + 1 ) ; } else { put_user ( 0 , ( unsigned long __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( unsigned long __user * ) reg + 1 ) ; } advance ( regs ) ; }"," , 1 ,  regs , 0"
341,"CWE-000 void ff_h264_free_tables ( H264Context * h , int free_rbsp ) { int i ; H264Context * hx ; av_freep ( & h -> intra4x4_pred_mode ) ; av_freep ( & h -> chroma_pred_mode_table ) ; av_freep ( & h -> cbp_table ) ; av_freep ( & h -> mvd_table [ 0 ] ) ; av_freep ( & h -> mvd_table [ 1 ] ) ; av_freep ( & h -> direct_table ) ; av_freep ( & h -> non_zero_count ) ; av_freep ( & h -> slice_table_base ) ; h -> slice_table = NULL ; av_freep ( & h -> list_counts ) ; av_freep ( & h -> mb2b_xy ) ; av_freep ( & h -> mb2br_xy ) ; av_buffer_pool_uninit ( & h -> qscale_table_pool ) ; av_buffer_pool_uninit ( & h -> mb_type_pool ) ; av_buffer_pool_uninit ( & h -> motion_val_pool ) ; av_buffer_pool_uninit ( & h -> ref_index_pool ) ; if ( free_rbsp && h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ;  av_freep ( & h -> DPB ) ;  } else if ( h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) h -> DPB [ i ] . needs_realloc = 1 ; } h -> cur_pic_ptr = NULL ; for ( i = 0 ; i < H264_MAX_THREADS ; i ++ ) { hx = h -> thread_context [ i ] ; if ( ! hx ) continue ; av_freep ( & hx -> top_borders [ 1 ] ) ; av_freep ( & hx -> top_borders [ 0 ] ) ; av_freep ( & hx -> bipred_scratchpad ) ; av_freep ( & hx -> edge_emu_buffer ) ; av_freep ( & hx -> dc_val_base ) ; av_freep ( & hx -> er . mb_index2xy ) ; av_freep ( & hx -> er . error_status_table ) ; av_freep ( & hx -> er . er_temp_buffer ) ; av_freep ( & hx -> er . mbintra_table ) ; av_freep ( & hx -> er . mbskip_table ) ; if ( free_rbsp ) { av_freep ( & hx -> rbsp_buffer [ 1 ] ) ; av_freep ( & hx -> rbsp_buffer [ 0 ] ) ; hx -> rbsp_buffer_size [ 0 ] = 0 ; hx -> rbsp_buffer_size [ 1 ] = 0 ; } if ( i ) av_freep ( & h -> thread_context [ i ] ) ; } }"," ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;"
342,"CWE-000 static int load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl ( ctxt ) ;  return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ;  }"," cpl , false , NULL"
343,"CWE-119 static void mark_commit ( struct commit * c , void * data ) {  mark_object ( & c -> object , NULL , NULL , data ) ;  }"," , NULL ,  data ) ;"
344,"CWE-400 static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; }  perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;  destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( ""Unexpectedwidth_shift%dinmisaligned_load,PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( ""ldlo.l%1,0,%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.l%1,3,%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; case 3 : asm ( ""ldlo.q%1,0,%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.q%1,7,%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; default : printk ( ""Unexpectedwidth_shift%dinmisaligned_load,PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }"," , 1 ,  regs , address"
345,"CWE-264 static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ;  final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;   dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ;  if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }"," ) ) ; rcu_read_lock ( ) ;  ( fl6 , rcu_dereference (  np -> opt )  final ) ; rcu_read_unlock ( ) ;"
346,"CWE-362  static struct desc_struct * get_desc ( unsigned short sel )  { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) {  struct desc_struct * desc = NULL ;  struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ;  if ( ldt && sel < ldt -> nr_entries )   desc = & ldt -> entries [ sel ] ;  mutex_unlock ( & current -> active_mm -> context . lock ) ;  return desc ;  } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size )  return NULL ;  return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ;  } ","   static bool get_desc (  struct desc_struct * out ,  unsigned short sel  SEGMENT_LDT ) { bool success = false  ; struct ldt_struct  -> nr_entries ) { * out =  ldt -> entries  sel ] ; success = true ; }  ) ; return success  ; } #  size ) return false ; * out = *  ( struct desc_struct  desc_base ) ; return true ;"
347,"CWE-200 static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ;  else if ( i > pos && i + insn -> off + 1 < pos )  insn -> off -= delta ; } }", i > pos + delta  off + 1 <= pos + delta  ) insn ->
348,"CWE-125 static int indenterror ( struct tok_state * tok )  {  if ( tok -> alterror ) { tok -> done = E_TABSPACE ; tok -> cur = tok -> inp ;  return 1 ;  } if ( tok -> altwarning ) { # ifdef PGEN PySys_WriteStderr ( ""inconsistentuseoftabsandspaces"" ""inindentation\\n"" ) ; # else PySys_FormatStderr ( ""%U:inconsistentuseoftabsandspaces"" ""inindentation\\n"" , tok -> filename ) ; # endif tok -> altwarning = 0 ; } return 0 ; }", * tok )  { tok ->  inp ; return ERRORTOKEN  ; } 
349,"CWE-287 static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ;  err = scm_send ( sock , msg , siocb -> scm ) ;  if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }"," siocb -> scm , true"
350,"CWE-310 int ssl3_get_cert_verify ( SSL * s ) { EVP_PKEY * pkey = NULL ; unsigned char * p ; int al , ok , ret = 0 ; long n ; int type = 0 , i , j ; X509 * peer ; const EVP_MD * md = NULL ; EVP_MD_CTX mctx ; EVP_MD_CTX_init ( & mctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_VRFY_A , SSL3_ST_SR_CERT_VRFY_B , - 1 , SSL3_RT_MAX_PLAIN_LENGTH , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( s -> session -> peer != NULL ) { peer = s -> session -> peer ; pkey = X509_get_pubkey ( peer ) ; type = X509_certificate_type ( peer , pkey ) ; } else { peer = NULL ; pkey = NULL ; } if ( s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s -> s3 -> tmp . reuse_message = 1 ;  if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) )  { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ; goto f_err ; } ret = 1 ; goto end ; } if ( peer == NULL ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_NO_CLIENT_CERT_RECEIVED ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } if ( ! ( type & EVP_PKT_SIGN ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE ) ; al = SSL_AD_ILLEGAL_PARAMETER ; goto f_err ; } if ( s -> s3 -> change_cipher_spec ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_CCS_RECEIVED_EARLY ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } p = ( unsigned char * ) s -> init_msg ; if ( n == 64 && ( pkey -> type == NID_id_GostR3410_94 || pkey -> type == NID_id_GostR3410_2001 ) ) { i = 64 ; } else { if ( SSL_USE_SIGALGS ( s ) ) { int rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) { al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } else if ( rv == 0 ) { al = SSL_AD_DECODE_ERROR ; goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USINGTLSv1.2HASH%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } n2s ( p , i ) ; n -= 2 ; if ( i > n ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_LENGTH_MISMATCH ) ; al = SSL_AD_DECODE_ERROR ; goto f_err ; } } j = EVP_PKEY_size ( pkey ) ; if ( ( i > j ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_WRONG_SIGNATURE_SIZE ) ; al = SSL_AD_DECODE_ERROR ; goto f_err ; } if ( SSL_USE_SIGALGS ( s ) ) { long hdatalen = 0 ; void * hdata ; hdatalen = BIO_get_mem_data ( s -> s3 -> handshake_buffer , & hdata ) ; if ( hdatalen <= 0 ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_INTERNAL_ERROR ) ; al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""UsingTLS1.2withclientverifyalg%s\\n"" , EVP_MD_name ( md ) ) ; # endif if ( ! EVP_VerifyInit_ex ( & mctx , md , NULL ) || ! EVP_VerifyUpdate ( & mctx , hdata , hdatalen ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_EVP_LIB ) ; al = SSL_AD_INTERNAL_ERROR ; goto f_err ; } if ( EVP_VerifyFinal ( & mctx , p , i , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA ) { i = RSA_verify ( NID_md5_sha1 , s -> s3 -> tmp . cert_verify_md , MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH , p , i , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_RSA_SIGNATURE ) ; goto f_err ; } } else # endif # ifndef OPENSSL_NO_DSA if ( pkey -> type == EVP_PKEY_DSA ) { j = DSA_verify ( pkey -> save_type , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) , SHA_DIGEST_LENGTH , p , i , pkey -> pkey . dsa ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_DSA_SIGNATURE ) ; goto f_err ; } } else # endif # ifndef OPENSSL_NO_ECDSA if ( pkey -> type == EVP_PKEY_EC ) { j = ECDSA_verify ( pkey -> save_type , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) , SHA_DIGEST_LENGTH , p , i , pkey -> pkey . ec ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_ECDSA_SIGNATURE ) ; goto f_err ; } } else # endif if ( pkey -> type == NID_id_GostR3410_94 || pkey -> type == NID_id_GostR3410_2001 ) { unsigned char signature [ 64 ] ; int idx ; EVP_PKEY_CTX * pctx = EVP_PKEY_CTX_new ( pkey , NULL ) ; EVP_PKEY_verify_init ( pctx ) ; if ( i != 64 ) { fprintf ( stderr , ""GOSTsignaturelengthis%d"" , i ) ; } for ( idx = 0 ; idx < 64 ; idx ++ ) { signature [ 63 - idx ] = p [ idx ] ; } j = EVP_PKEY_verify ( pctx , signature , 64 , s -> s3 -> tmp . cert_verify_md , 32 ) ; EVP_PKEY_CTX_free ( pctx ) ; if ( j <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_BAD_ECDSA_SIGNATURE ) ; goto f_err ; } } else { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , ERR_R_INTERNAL_ERROR ) ; al = SSL_AD_UNSUPPORTED_CERTIFICATE ; goto f_err ; } ret = 1 ; if ( 0 ) { f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; } end : if ( s -> s3 -> handshake_buffer ) { BIO_free ( s -> s3 -> handshake_buffer ) ; s -> s3 -> handshake_buffer = NULL ; s -> s3 -> flags &= ~ TLS1_FLAGS_KEEP_HANDSHAKE ; } EVP_MD_CTX_cleanup ( & mctx ) ; EVP_PKEY_free ( pkey ) ; return ( ret ) ; }", ; if (  peer != NULL  peer != NULL  ) { al
351,"CWE-79 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , ""INCLUDED"" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , ""text/html"" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( ! AP2 ( engine ) ) { PHPAP_INI_OFF ; return DECLINED ; } if ( r -> finfo . filetype == 0 ) { php_apache_sapi_log_message_ex ( ""script\'%s\'notfoundorunabletostat"" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( r -> finfo . filetype == APR_DIR ) { php_apache_sapi_log_message_ex ( ""attempttoinvokedirectory\'%s\'asscript"" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_FORBIDDEN ; } if ( r -> main == NULL || r -> subprocess_env != r -> main -> subprocess_env ) { ap_add_common_vars ( r ) ; ap_add_cgi_vars ( r ) ; } zend_first_try { if ( ctx == NULL ) { brigade = apr_brigade_create ( r -> pool , r -> connection -> bucket_alloc ) ; ctx = SG ( server_context ) ; ctx -> brigade = brigade ; if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } else { if ( ! parent_req ) { parent_req = ctx -> r ; } if ( parent_req && parent_req -> handler && strcmp ( parent_req -> handler , PHP_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SCRIPT ) ) { if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } if ( parent_req && parent_req -> status != HTTP_OK && parent_req -> status != 413 && strcmp ( r -> protocol , ""INCLUDED"" ) ) { parent_req = NULL ; goto normal ; } ctx -> r = r ; brigade = ctx -> brigade ; } if ( AP2 ( last_modified ) ) { ap_update_mtime ( r , r -> finfo . mtime ) ; ap_set_last_modified ( r ) ; } if ( strncmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE , sizeof ( PHP_SOURCE_MAGIC_TYPE ) - 1 ) == 0 ) { zend_syntax_highlighter_ini syntax_highlighter_ini ; php_get_highlight_struct ( & syntax_highlighter_ini ) ; highlight_file ( ( char * ) r -> filename , & syntax_highlighter_ini TSRMLS_CC ) ; } else { zend_file_handle zfd ; zfd . type = ZEND_HANDLE_FILENAME ; zfd . filename = ( char * ) r -> filename ; zfd . free_filename = 0 ; zfd . opened_path = NULL ; if ( ! parent_req ) { php_execute_script ( & zfd TSRMLS_CC ) ; } else { zend_execute_scripts ( ZEND_INCLUDE TSRMLS_CC , NULL , 1 , & zfd ) ; } apr_table_set ( r -> notes , ""mod_php_memory_usage"" , apr_psprintf ( ctx -> r -> pool , ""%"" APR_SIZE_T_FMT , zend_memory_peak_usage ( 1 TSRMLS_CC ) ) ) ; } } zend_end_try ( ) ; if ( ! parent_req ) { php_apache_request_dtor ( r TSRMLS_CC ) ; ctx -> request_processed = 1 ;  bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ;  APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ; rv = ap_pass_brigade ( r -> output_filters , brigade ) ; if ( rv != APR_SUCCESS || r -> connection -> aborted ) { zend_first_try { php_handle_aborted_connection ( ) ; } zend_end_try ( ) ; } apr_brigade_cleanup ( brigade ) ; apr_pool_cleanup_run ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup ) ; } else { ctx -> r = parent_req ; } return OK ; }", = 1 ; apr_brigade_cleanup ( brigade ) ;
352,"CWE-200 int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }", RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
353,"CWE-200 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( ""nfnetlink-subsys-%d"" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ;  if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ||  skb -> len < nlh -> nlmsg_len ) { err = - EINVAL ; goto ack ; } if ( ! ( nlh -> nlmsg_flags & NLM_F_REQUEST ) ) { err = - EINVAL ; goto ack ; } type = nlh -> nlmsg_type ; if ( type == NFNL_MSG_BATCH_BEGIN ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } else if ( type == NFNL_MSG_BATCH_END ) { status |= NFNL_BATCH_DONE ; goto done ; } else if ( type < NLMSG_MIN_TYPE ) { err = - EINVAL ; goto ack ; } if ( NFNL_SUBSYS_ID ( type ) != subsys_id ) { err = - EINVAL ; goto ack ; } nc = nfnetlink_find_client ( type , ss ) ; if ( ! nc ) { err = - EINVAL ; goto ack ; } { int min_len = nlmsg_total_size ( sizeof ( struct nfgenmsg ) ) ; u_int8_t cb_id = NFNL_MSG_TYPE ( nlh -> nlmsg_type ) ; struct nlattr * cda [ ss -> cb [ cb_id ] . attr_count + 1 ] ; struct nlattr * attr = ( void * ) nlh + min_len ; int attrlen = nlh -> nlmsg_len - min_len ; err = nla_parse ( cda , ss -> cb [ cb_id ] . attr_count , attr , attrlen , ss -> cb [ cb_id ] . policy ) ; if ( err < 0 ) goto ack ; if ( nc -> call_batch ) { err = nc -> call_batch ( net , net -> nfnl , skb , nlh , ( const struct nlattr * * ) cda ) ; } if ( err == - EAGAIN ) { status |= NFNL_BATCH_REPLAY ; goto next ; } } ack : if ( nlh -> nlmsg_flags & NLM_F_ACK || err ) { if ( nfnl_err_add ( & err_list , nlh , err ) < 0 ) { nfnl_err_reset ( & err_list ) ; netlink_ack ( oskb , nlmsg_hdr ( oskb ) , - ENOMEM ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } if ( err ) status |= NFNL_BATCH_FAILURE ; } next : msglen = NLMSG_ALIGN ( nlh -> nlmsg_len ) ; if ( msglen > skb -> len ) msglen = skb -> len ; skb_pull ( skb , msglen ) ; } done : if ( status & NFNL_BATCH_REPLAY ) { ss -> abort ( net , oskb ) ; nfnl_err_reset ( & err_list ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; goto replay ; } else if ( status == NFNL_BATCH_DONE ) { ss -> commit ( net , oskb ) ; } else { ss -> abort ( net , oskb ) ; } nfnl_err_deliver ( & err_list , oskb ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; }", ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len ||  struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done  ; } if
354,"CWE-20 error_t ssiProcessExecCommand ( HttpConnection * connection , const char_t * tag , size_t length ) { char_t * separator ; char_t * attribute ; char_t * value ; if ( connection -> settings -> cgiCallback == NULL ) return ERROR_INVALID_TAG ; if ( length < 4 || length >= HTTP_SERVER_BUFFER_SIZE ) return ERROR_INVALID_TAG ; osMemcpy ( connection -> buffer , tag + 4 , length - 4 ) ; connection -> buffer [ length - 4 ] = '\\0' ;  separator = strchr ( connection -> buffer , '=' ) ;  if ( ! separator ) return ERROR_INVALID_TAG ; * separator = '\\0' ; attribute = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; if ( value [ 0 ] == '\\'' || value [ 0 ] == \'\\""\' ) value ++ ; length = osStrlen ( value ) ; if ( length > 0 ) { if ( value [ length - 1 ] == '\\'' || value [ length - 1 ] == \'\\""\' ) value [ length - 1 ] = '\\0' ; } if ( osStrcasecmp ( attribute , ""cgi"" ) && osStrcasecmp ( attribute , ""cmd"" ) && osStrcasecmp ( attribute , ""cmd_argument"" ) ) return ERROR_INVALID_TAG ; if ( osStrlen ( value ) > HTTP_SERVER_CGI_PARAM_MAX_LEN ) return ERROR_INVALID_TAG ; osStrcpy ( connection -> cgiParam , value ) ; return connection -> settings -> cgiCallback ( connection , connection -> cgiParam ) ; }", ; separator = osStrchr  ( connection ->
355,"CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels%disinvalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; }  if ( c -> nreslevels < s -> reduction_factor )   c -> nreslevels2decode = 1 ;  else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblksizeinvalid\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblksize>64"" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extracblkstyles%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }"," c -> nreslevels <=  s -> reduction_factor  -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factortoolargeforthisbitstream,maxis%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; }  c -> nreslevels2decode"
356,"CWE-119  static void encode_segmentation ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) { int i , j ;  struct segmentation * seg = & cpi -> common . seg ;  vp9_wb_write_bit ( wb , seg -> enabled ) ; if ( ! seg -> enabled ) return ;  vp9_wb_write_bit ( wb , seg -> update_map ) ;  if ( seg -> update_map ) {  vp9_choose_segmap_coding_method ( cpi ) ;  for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob != MAX_PROB ;  vp9_wb_write_bit ( wb , update ) ;  if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; }  vp9_wb_write_bit ( wb , seg -> temporal_update ) ;  if ( seg -> temporal_update ) { for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int prob = seg -> pred_probs [ i ] ; const int update = prob != MAX_PROB ;  vp9_wb_write_bit ( wb , update ) ;  if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } } }  vp9_wb_write_bit ( wb , seg -> update_data ) ;  if ( seg -> update_data ) {  vp9_wb_write_bit ( wb , seg -> abs_delta ) ;  for ( i = 0 ; i < MAX_SEGMENTS ; i ++ ) { for ( j = 0 ; j < SEG_LVL_MAX ; j ++ ) {  const int active = vp9_segfeature_active ( seg , i , j ) ;  vp9_wb_write_bit ( wb , active ) ; if ( active ) {  const int data = vp9_get_segdata ( seg , i , j ) ;  const int data_max = vp9_seg_feature_data_max ( j ) ; if ( vp9_is_segfeature_signed ( j ) ) { encode_unsigned_max ( wb , abs ( data ) , data_max ) ;  vp9_wb_write_bit ( wb , data < 0 ) ;  } else { encode_unsigned_max ( wb , data , data_max ) ; } } } } } }"," void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer  * wb )  , j ; const  seg = & cm -> seg ; vpx_wb_write_bit  ( wb ,  ) return ; vpx_wb_write_bit  ( wb ,  { vp9_choose_segmap_coding_method ( cm , xd  ) ; for  != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal  ( wb ,  ) ; } vpx_wb_write_bit  ( wb ,  != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal  ( wb ,  } } } vpx_wb_write_bit  ( wb ,  update_data ) { vpx_wb_write_bit  ( wb ,  int active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit  ( wb ,  int data = get_segdata  ( seg ,  data_max ) ; vpx_wb_write_bit  ( wb ,"
357,CWE-400  void exit_io_context ( void )  { struct io_context * ioc ;  task_lock ( current ) ;   ioc = current -> io_context ;   current -> io_context = NULL ;   task_unlock ( current ) ;  if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }, void exit_io_context ( struct task_struct * task  ) { struct  ; task_lock ( task  ) ; ioc  ; ioc = task  -> io_context ;  -> io_context ; task  -> io_context =  ; task_unlock ( task  ) ; if
358,"CWE-77 int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n***pulseDTR***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""***FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n***DTR:%s***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n***baud:%d(%d)***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n***baud:%d***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n***flow:%s(%s)***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n***flow:%s***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n***parity:%s(%s)***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n***parity:%s***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n***databits:%d(%d)***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n***databits:%d***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n***localecho:%s***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n***commanddisabled***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""***cannotreadfilename***\\r\\n"" ) ; break ; }  run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;  free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n***breaksent***\\r\\n"" ) ; break ; default : break ; } return 0 ; }"," xfr_cmd , fname  ) ; free"
359,"CWE-119 static void rd_check_segment ( VP8_COMP * cpi , MACROBLOCK * x , BEST_SEG_INFO * bsi , unsigned int segmentation ) { int i ; int const * labels ; int br = 0 ; int bd = 0 ; B_PREDICTION_MODE this_mode ; int label_count ; int this_segment_rd = 0 ; int label_mv_thresh ; int rate = 0 ; int sbr = 0 ; int sbd = 0 ; int segmentyrate = 0 ; vp8_variance_fn_ptr_t * v_fn_ptr ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; ENTROPY_CONTEXT_PLANES t_above_b , t_left_b ; ENTROPY_CONTEXT * ta_b ; ENTROPY_CONTEXT * tl_b ;  vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;   vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;  ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; ta_b = ( ENTROPY_CONTEXT * ) & t_above_b ; tl_b = ( ENTROPY_CONTEXT * ) & t_left_b ; br = 0 ; bd = 0 ; v_fn_ptr = & cpi -> fn_ptr [ segmentation ] ; labels = vp8_mbsplits [ segmentation ] ; label_count = vp8_mbsplit_count [ segmentation ] ; label_mv_thresh = 1 * bsi -> mvthresh / label_count ; rate = vp8_cost_token ( vp8_mbsplit_tree , vp8_mbsplit_probs , vp8_mbsplit_encodings + segmentation ) ; rate += vp8_cost_mv_ref ( SPLITMV , bsi -> mdcounts ) ; this_segment_rd += RDCOST ( x -> rdmult , x -> rddiv , rate , 0 ) ; br += rate ; for ( i = 0 ; i < label_count ; i ++ ) { int_mv mode_mv [ B_MODE_COUNT ] ; int best_label_rd = INT_MAX ; B_PREDICTION_MODE mode_selected = ZERO4X4 ; int bestlabelyrate = 0 ; for ( this_mode = LEFT4X4 ; this_mode <= NEW4X4 ; this_mode ++ ) { int this_rd ; int distortion ; int labelyrate ; ENTROPY_CONTEXT_PLANES t_above_s , t_left_s ; ENTROPY_CONTEXT * ta_s ; ENTROPY_CONTEXT * tl_s ;  vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;   vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;  ta_s = ( ENTROPY_CONTEXT * ) & t_above_s ; tl_s = ( ENTROPY_CONTEXT * ) & t_left_s ; if ( this_mode == NEW4X4 ) { int sseshift ; int num00 ; int step_param = 0 ; int further_steps ; int n ; int thissme ; int bestsme = INT_MAX ; int_mv temp_mv ; BLOCK * c ; BLOCKD * e ; if ( best_label_rd < label_mv_thresh ) break ; if ( cpi -> compressor_speed ) { if ( segmentation == BLOCK_8X16 || segmentation == BLOCK_16X8 ) { bsi -> mvp . as_int = bsi -> sv_mvp [ i ] . as_int ; if ( i == 1 && segmentation == BLOCK_16X8 ) bsi -> mvp . as_int = bsi -> sv_mvp [ 2 ] . as_int ; step_param = bsi -> sv_istep [ i ] ; } if ( segmentation == BLOCK_4X4 && i > 0 ) { bsi -> mvp . as_int = x -> e_mbd . block [ i - 1 ] . bmi . mv . as_int ; if ( i == 4 || i == 8 || i == 12 ) bsi -> mvp . as_int = x -> e_mbd . block [ i - 4 ] . bmi . mv . as_int ; step_param = 2 ; } } further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; { int sadpb = x -> sadperbit4 ; int_mv mvp_full ; mvp_full . as_mv . row = bsi -> mvp . as_mv . row >> 3 ; mvp_full . as_mv . col = bsi -> mvp . as_mv . col >> 3 ; n = vp8_mbsplit_offset [ segmentation ] [ i ] ; c = & x -> block [ n ] ; e = & x -> e_mbd . block [ n ] ; { bestsme = cpi -> diamond_search_sad ( x , c , e , & mvp_full , & mode_mv [ NEW4X4 ] , step_param , sadpb , & num00 , v_fn_ptr , x -> mvcost , bsi -> ref_mv ) ; n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { thissme = cpi -> diamond_search_sad ( x , c , e , & mvp_full , & temp_mv , step_param + n , sadpb , & num00 , v_fn_ptr , x -> mvcost , bsi -> ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEW4X4 ] . as_int = temp_mv . as_int ; } } } } sseshift = segmentation_to_sseshift [ segmentation ] ; if ( ( cpi -> compressor_speed == 0 ) && ( bestsme >> sseshift ) > 4000 ) { vp8_clamp_mv ( & mvp_full , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; thissme = cpi -> full_search_sad ( x , c , e , & mvp_full , sadpb , 16 , v_fn_ptr , x -> mvcost , bsi -> ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEW4X4 ] . as_int = e -> bmi . mv . as_int ; } else { e -> bmi . mv . as_int = mode_mv [ NEW4X4 ] . as_int ; } } } if ( bestsme < INT_MAX ) { int disto ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , c , e , & mode_mv [ NEW4X4 ] , bsi -> ref_mv , x -> errorperbit , v_fn_ptr , x -> mvcost , & disto , & sse ) ; } } rate = labels2mode ( x , labels , i , this_mode , & mode_mv [ this_mode ] , bsi -> ref_mv , x -> mvcost ) ; if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) { continue ; } distortion = vp8_encode_inter_mb_segment ( x , labels , i ) / 4 ; labelyrate = rdcost_mbsegment_y ( x , labels , i , ta_s , tl_s ) ; rate += labelyrate ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_label_rd ) { sbr = rate ; sbd = distortion ; bestlabelyrate = labelyrate ; mode_selected = this_mode ; best_label_rd = this_rd ;  vpx_memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;   vpx_memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;  } }  vpx_memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;   vpx_memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;  labels2mode ( x , labels , i , mode_selected , & mode_mv [ mode_selected ] , bsi -> ref_mv , x -> mvcost ) ; br += sbr ; bd += sbd ; segmentyrate += bestlabelyrate ; this_segment_rd += best_label_rd ; if ( this_segment_rd >= bsi -> segment_rd ) break ; } if ( this_segment_rd < bsi -> segment_rd ) { bsi -> r = br ; bsi -> d = bd ; bsi -> segment_yrate = segmentyrate ; bsi -> segment_rd = this_segment_rd ; bsi -> segment_num = segmentation ; for ( i = 0 ; i < 16 ; i ++ ) { bsi -> mvs [ i ] . as_mv = x -> partition_info -> bmi [ i ] . mv . as_mv ; bsi -> modes [ i ] = x -> partition_info -> bmi [ i ] . mode ; bsi -> eobs [ i ] = x -> e_mbd . eobs [ i ] ; } } }"," * tl_b ; memcpy  ( & t_above  ) ) ; memcpy  ( & t_left  * tl_s ; memcpy  ( & t_above_s  ) ) ; memcpy  ( & t_left_s  = this_rd ; memcpy  ( ta_b ,  ) ) ; memcpy  ( tl_b ,  ; } } memcpy  ( ta ,  ) ) ; memcpy  ( tl ,"
360,"CWE-269 static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ;  if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA )  && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ;  switch ( ctxt -> mode ) {  case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ;  break ;  case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ;  cs_sel = ( u16 ) msr_data ;  cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ;  ss_sel &= ~ SELECTOR_RPL_MASK ;   if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) {  cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_EIP , & msr_data ) ;  ctxt -> _eip = msr_data ;  ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ;  * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ;  return X86EMUL_CONTINUE ; }", ctxt -> mode != X86EMUL_MODE_PROT64  ) && (  msr_data ) ;  if ( (  0 ) ;  ctxt -> eflags  u16 ) msr_data &  ~ SELECTOR_RPL_MASK ;  + 8 ; if  ( efer &  efer & EFER_LMA  ) { cs  -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 )  VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )
361,"CWE-310 json_t * json_object ( void ) { json_object_t * object = jsonp_malloc ( sizeof ( json_object_t ) ) ; if ( ! object )  return NULL ;  json_init ( & object -> json , JSON_OBJECT ) ; if ( hashtable_init ( & object -> hashtable ) ) { jsonp_free ( object ) ; return NULL ; } object -> serial = 0 ; object -> visited = 0 ; return & object -> json ; }", return NULL ; if ( ! hashtable_seed ) { json_object_seed ( 0 ) ; }
362,"CWE-20 int mk_request_error ( int http_status , struct client_session * cs , struct session_request * sr ) { int ret , fd ; mk_ptr_t message , * page = 0 ; struct error_page * entry ; struct mk_list * head ; struct file_info finfo ; mk_header_set_http_status ( sr , http_status ) ; if ( http_status != MK_CLIENT_LENGTH_REQUIRED && http_status != MK_CLIENT_BAD_REQUEST && http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE ) { mk_list_foreach ( head , & sr -> host_conf -> error_pages ) { entry = mk_list_entry ( head , struct error_page , _head ) ; if ( entry -> status != http_status ) { continue ; } ret = mk_file_get_info ( entry -> real_path , & finfo ) ; if ( ret == - 1 ) { break ; } fd = open ( entry -> real_path , config -> open_flags ) ; if ( fd == - 1 ) { break ; } sr -> fd_file = fd ;  sr -> bytes_to_send = finfo . size ;  sr -> headers . content_length = finfo . size ; sr -> headers . real_length = finfo . size ; memcpy ( & sr -> file_info , & finfo , sizeof ( struct file_info ) ) ; mk_header_send ( cs -> socket , cs , sr ) ; return mk_http_send_file ( cs , sr ) ; } } mk_ptr_reset ( & message ) ; switch ( http_status ) { case MK_CLIENT_BAD_REQUEST : page = mk_request_set_default_page ( ""BadRequest"" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_FORBIDDEN : page = mk_request_set_default_page ( ""Forbidden"" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_NOT_FOUND : mk_string_build ( & message . data , & message . len , ""TherequestedURLwasnotfoundonthisserver."" ) ; page = mk_request_set_default_page ( ""NotFound"" , message , sr -> host_conf -> host_signature ) ; mk_ptr_free ( & message ) ; break ; case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE : mk_string_build ( & message . data , & message . len , ""Therequestentityistoolarge."" ) ; page = mk_request_set_default_page ( ""Entitytoolarge"" , message , sr -> host_conf -> host_signature ) ; mk_ptr_free ( & message ) ; break ; case MK_CLIENT_METHOD_NOT_ALLOWED : page = mk_request_set_default_page ( ""MethodNotAllowed"" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_REQUEST_TIMEOUT : case MK_CLIENT_LENGTH_REQUIRED : break ; case MK_SERVER_NOT_IMPLEMENTED : page = mk_request_set_default_page ( ""MethodNotImplemented"" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_SERVER_INTERNAL_ERROR : page = mk_request_set_default_page ( ""InternalServerError"" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_SERVER_HTTP_VERSION_UNSUP : mk_ptr_reset ( & message ) ; page = mk_request_set_default_page ( ""HTTPVersionNotSupported"" , message , sr -> host_conf -> host_signature ) ; break ; } if ( page ) { sr -> headers . content_length = page -> len ; } sr -> headers . location = NULL ; sr -> headers . cgi = SH_NOCGI ; sr -> headers . pconnections_left = 0 ; sr -> headers . last_modified = - 1 ; if ( ! page ) { mk_ptr_reset ( & sr -> headers . content_type ) ; } else { mk_ptr_set ( & sr -> headers . content_type , ""text/html\\r\\n"" ) ; } mk_header_send ( cs -> socket , cs , sr ) ; if ( page ) { if ( sr -> method != MK_HTTP_METHOD_HEAD ) mk_socket_send ( cs -> socket , page -> data , page -> len ) ; mk_ptr_free ( page ) ; mk_mem_free ( page ) ; } mk_server_cork_flag ( cs -> socket , TCP_CORK_OFF ) ; return EXIT_ERROR ; }", ; sr -> fd_is_fdt = MK_FALSE ; sr ->
363,"CWE-119 static void record_recent_object ( struct object * obj ,  struct strbuf * path ,   const char * last ,  void * data ) { sha1_array_append ( & recent_objects , obj -> oid . hash ) ; }"," * obj ,  const char *  const char * name  , void *"
364,"CWE-200 static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( ""sock%psk%p"" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ;  release_sock ( sk ) ;  return 0 ; }", -> id ; haddr -> hci_channel = 0 ;
365,"CWE-17 static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) { ret = - ENOENT ; goto out ; } block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else { offset = 0 ; } if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { ret = - EIO ; goto out ; } if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; for ( num = 0 ; i > 0 ; i -- ) { block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; tmp = udf_tgetblk ( dir -> i_sb , block ) ; if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) bha [ num ++ ] = tmp ; else brelse ( tmp ) ; } if ( num ) { ll_rw_block ( READA , num , bha ) ; for ( i = 0 ; i < num ; i ++ ) brelse ( bha [ i ] ) ; } } } while ( nf_pos < size ) { struct kernel_lb_addr tloc ; ctx -> pos = ( nf_pos >> 2 ) + 1 ; fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out ; liu = le16_to_cpu ( cfi . lengthOfImpUse ) ; lfi = cfi . lengthFileIdent ; if ( fibh . sbh == fibh . ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh . soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) { nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; } else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh . ebh -> b_data , poffset ) ; } } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( cfi . fileCharacteristics & FID_FILE_CHAR_PARENT ) { if ( ! dir_emit_dotdot ( file , ctx ) ) goto out ; continue ; }  flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;  if ( ! flen ) continue ; tloc = lelb_to_cpu ( cfi . icb . extLocation ) ; iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; if ( ! dir_emit ( ctx , fname , flen , iblock , DT_UNKNOWN ) ) goto out ; } ctx -> pos = ( nf_pos >> 2 ) + 1 ; out : if ( fibh . sbh != fibh . ebh ) brelse ( fibh . ebh ) ; brelse ( fibh . sbh ) ; brelse ( epos . bh ) ; kfree ( fname ) ; return ret ; }"," , nameptr , lfi , fname , UDF_NAME_LEN  ) ; if"
366,"CWE-119 void vp8_dequant_idct_add_uv_block_mmx ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstu , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ;  vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;  } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstu + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ;  vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;  } q += 32 ; dstu += 4 * stride ; eobs += 2 ; } for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstv , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ;  vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;  } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstv + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstv + 4 , stride , dstv + 4 , stride ) ;  vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;  } q += 32 ; dstv += 4 * stride ; eobs += 2 ; } }"," stride ) ; memset  ( q ,  stride ) ; memset  ( q +  stride ) ; memset  ( q ,  stride ) ; memset  ( q +"
367,"CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannotopenCSRfile!\\n"" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""couldnotreadfilelength!\\n"" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) {  if ( sscanf ( l_line , ""%u%u%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {  * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""couldnotallocatespdata!\\n"" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""couldnotcsrdescription!\\n"" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , ""%u%u%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""couldnotreadelement!\\n"" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""wewerenotabletoreadallelements!\\n"" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }"," { if ( 3 ==  , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count )  { * o_column_idx"
368,"CWE-125 int main ( int argc , char * * argv ) { const char command0 [ ] = { 0x00 , 0x00 } ; char command1 [ ] = ""\\x01\\x00urn:schemas-upnp-org:device:InternetGatewayDevice"" ; char command2 [ ] = ""\\x02\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice"" ; const char command3 [ ] = { 0x03 , 0x00 } ; char command3compat [ ] = ""\\x03\\x00ssdp:all"" ; char command4 [ ] = ""\\x04\\x00test:test:test"" ; const char bad_command [ ] = { 0xff , 0xff } ; const char overflow [ ] = { 0x01 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ;  const char command5 [ ] = { 0x05 , 0x00 } ;  int s ; int i ; void * tmp ; unsigned char * resp = NULL ; size_t respsize = 0 ; unsigned char buf [ 4096 ] ; ssize_t n ; int total = 0 ; const char * sockpath = ""/var/run/minissdpd.sock"" ; for ( i = 0 ; i < argc - 1 ; i ++ ) { if ( 0 == strcmp ( argv [ i ] , ""-s"" ) ) sockpath = argv [ ++ i ] ; } command1 [ 1 ] = sizeof ( command1 ) - 3 ; command2 [ 1 ] = sizeof ( command2 ) - 3 ; command3compat [ 1 ] = sizeof ( command3compat ) - 3 ; command4 [ 1 ] = sizeof ( command4 ) - 3 ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command0 , sizeof ( command0 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; if ( n > 0 ) { printversion ( buf , n ) ; } else { printf ( ""Command0(getversion)notsupported\\n"" ) ; close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command1 , sizeof ( command1 ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command2 , sizeof ( command2 ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } buf [ 0 ] = 0 ; n = SENDCOMMAND ( command3 , sizeof ( command3 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; if ( n == 0 ) { printf ( ""command3failed,testingcompatibleone\\n"" ) ; close ( s ) ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command3compat , sizeof ( command3compat ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; } printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printf ( ""Numberofdevices%d\\n"" , ( int ) buf [ 0 ] ) ; while ( n > 0 ) { tmp = realloc ( resp , respsize + n ) ; if ( tmp == NULL ) { fprintf ( stderr , ""memoryallocationerror\\n"" ) ; break ; } resp = tmp ; respsize += n ; if ( n > 0 ) { memcpy ( resp + total , buf , n ) ; total += n ; } if ( n < ( ssize_t ) sizeof ( buf ) ) { break ; } n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""responsereceived%dbytes\\n"" , ( int ) n ) ; } if ( resp != NULL ) { printresponse ( resp , total ) ; free ( resp ) ; resp = NULL ; } if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command4 , sizeof ( command4 ) ) ; n = SENDCOMMAND ( bad_command , sizeof ( bad_command ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( overflow , sizeof ( overflow ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command5 , sizeof ( command5 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ;  close ( s ) ;   return 0 ;  }"," 0x05 , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f  n ) ; if ( n == 0 ) {  s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Responsereceived%dbytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;"
369,"CWE-200 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ;  buf = g_malloc ( size ) ;  if ( object ) { g_signal_connect ( object , ""postclose"" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }", ; buf = g_malloc0  ( size )
370,"CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ;  show_object ( obj , NULL , name , data ) ;  continue ; } if ( ! path ) path = """" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object ,  NULL , path , data ) ;  continue ; } die ( ""unknownpendingobject%s(%s)"" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }"," ( obj ,  name , data  , show_object , & base  , path ,"
371,"CWE-17 static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ;  tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z ,  & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }", tf = (  luaY_parser ) (
372,"CWE-200 void update_process_times ( int user_tick ) { struct task_struct * p = current ; account_process_tick ( p , user_tick ) ; run_local_timers ( ) ; rcu_sched_clock_irq ( user_tick ) ; # ifdef CONFIG_IRQ_WORK if ( in_irq ( ) ) irq_work_tick ( ) ; # endif scheduler_tick ( ) ; if ( IS_ENABLED ( CONFIG_POSIX_TIMERS ) ) run_posix_cpu_timers ( ) ;  } "," ( ) ; this_cpu_add ( net_rand_state . s1 , rol32 ( jiffies , 24 ) + user_tick ) ;"
373,"CWE-119 int vp8_skip_fractional_mv_step ( MACROBLOCK * mb , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse ) { ( void ) b ; ( void ) d ; ( void ) ref_mv ; ( void ) error_per_bit ; ( void ) vfp ;  ( void ) mvcost ;  ( void ) distortion ; ( void ) sse ; bestmv -> as_mv . row <<= 3 ; bestmv -> as_mv . col <<= 3 ; return 0 ; }", ( void ) mb ; ( void )
374,"CWE-119 static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; int32_t len ; uint8_t command ;  uint8_t * outbuf ;  int rc ;  command = buf [ 0 ] ;  outbuf = ( uint8_t * ) r -> iov . iov_base ; DPRINTF ( ""Command:lun=%dtag=0x%xdata=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ) ; # ifdef DEBUG_SCSI { int i ; for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { printf ( ""0x%02x"" , buf [ i ] ) ; } printf ( ""\\n"" ) ; } # endif switch ( command ) { case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 :  rc = scsi_disk_emulate_command ( r , outbuf ) ;  if ( rc < 0 ) { return 0 ; } r -> iov . iov_len = rc ; break ; case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_flush_complete ( r , - EIO ) ; } return 0 ; case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( ""Read(sector%"" PRId64 "",count%d)\\n"" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case WRITE_6 : case WRITE_10 : case WRITE_12 : case WRITE_16 : case WRITE_VERIFY_10 : case WRITE_VERIFY_12 : case WRITE_VERIFY_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( ""Write%s(sector%"" PRId64 "",count%d)\\n"" , ( command & 0xe ) == 0xe ? ""AndVerify"" : """" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case MODE_SELECT : DPRINTF ( ""ModeSelect(6)(len%lu)\\n"" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 12 ) { goto fail ; } break ; case MODE_SELECT_10 : DPRINTF ( ""ModeSelect(10)(len%lu)\\n"" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 16 ) { goto fail ; } break ; case SEEK_6 : case SEEK_10 : DPRINTF ( ""Seek(%d)(sector%"" PRId64 "")\\n"" , command == SEEK_6 ? 6 : 10 , r -> req . cmd . lba ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } break ; case WRITE_SAME_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( ""WRITESAME(16)(sector%"" PRId64 "",count%d)\\n"" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } if ( ! ( buf [ 1 ] & 0x8 ) ) { goto fail ; } rc = bdrv_discard ( s -> bs , r -> req . cmd . lba * s -> cluster_size , len * s -> cluster_size ) ; if ( rc < 0 ) { goto fail ; } break ; case REQUEST_SENSE : abort ( ) ; default : DPRINTF ( ""UnknownSCSIcommand(%2.2x)\\n"" , buf [ 0 ] ) ; scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return 0 ; fail : scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; return 0 ; illegal_lba : scsi_check_condition ( r , SENSE_CODE ( LBA_OUT_OF_RANGE ) ) ; return 0 ; } if ( r -> sector_count == 0 && r -> iov . iov_len == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } len = r -> sector_count * 512 + r -> iov . iov_len ; if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { return - len ; } else { if ( ! r -> sector_count ) r -> sector_count = - 1 ; return len ; } }", uint8_t command ;  int rc ;  [ 0 ]  ; DPRINTF (  scsi_disk_emulate_command ( r  ) ; if
375,"CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""SeemsnottobeaTNEFfile\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEFKey:%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ;  if ( a -> name == MAPI_BODY_HTML )  { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; }  else if ( a -> name == MAPI_RTF_COMPRESSED )  { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , ""Invalidlvltypeonattribute:%d\\n"" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , ""all"" ) == 0 ) { all_flag = 1 ; body_pref = ""rht"" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }", ( a -> type == szMAPI_BINARY && a ->  else if ( a -> type == szMAPI_BINARY &&
376,"CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ;  int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;  int hexdump ;  int offset , subobj_type , subobj_len , total_subobj_len ;  int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMPversion%upacketnotsupported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u%sMessage,length:%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,msg-type:%s,Flags:[%s],length:%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,type:%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ;  tptr += sizeof ( const struct lmp_common_header ) ;  tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ;  if ( lmp_obj_len % 4 || lmp_obj_len < 4 )  return ; ND_PRINT ( ( ndo , ""\\n\\t%sObject(%u),Class-Type:%s(%u)Flags:[%snegotiable],length:%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" ,  lmp_obj_len ) ) ;  obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT :  ND_PRINT ( ( ndo , ""\\n\\tControlChannelID:%u(0x%08x)"" ,  EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT :  ND_PRINT ( ( ndo , ""\\n\\tIPv4LinkID:%s(0x%08x)"" ,  ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT :  ND_PRINT ( ( ndo , ""\\n\\tIPv6LinkID:%s(0x%08x)"" ,  ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC :  case LMP_CTYPE_UNMD_RMT :  ND_PRINT ( ( ndo , ""\\n\\tLinkID:%u(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\n\\tMessageID:%u(0x%08x)"" ,  EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ;  case LMP_CTYPE_2 :  ND_PRINT ( ( ndo , ""\\n\\tMessageIDAck:%u(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT :  ND_PRINT ( ( ndo , ""\\n\\tNodeID:%s(0x%08x)"" ,  ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG :  ND_PRINT ( ( ndo , ""\\n\\tHelloInterval:%u\\n\\tHelloDeadInterval:%u"" ,  EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO :  ND_PRINT ( ( ndo , ""\\n\\tTxSeq:%u,RxSeq:%u"" ,  EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK :  ND_PRINT ( ( ndo , ""\\n\\tFlags:[%s]"" ,  bittok2str ( lmp_obj_te_link_flag_values , ""none"" ,  EXTRACT_16BITS ( obj_tptr ) >> 8 ) ) ) ;  switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : ND_PRINT ( ( ndo , ""\\n\\tLocalLink-ID:%s(0x%08x)"" ""\\n\\tRemoteLink-ID:%s(0x%08x)"" ,  ipaddr_string ( ndo , obj_tptr + 4 ) ,  EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ;  case LMP_CTYPE_IPV6 :  case LMP_CTYPE_UNMD : default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK :  ND_PRINT ( ( ndo , ""\\n\\tFlags:[%s]"" ,  bittok2str ( lmp_obj_data_link_flag_values , ""none"" ,  EXTRACT_16BITS ( obj_tptr ) >> 8 ) ) ) ;  switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : case LMP_CTYPE_UNMD : ND_PRINT ( ( ndo , ""\\n\\tLocalInterfaceID:%s(0x%08x)"" ""\\n\\tRemoteInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; total_subobj_len = lmp_obj_len - 16 ; offset = 12 ; while ( total_subobj_len > 0 && hexdump == FALSE ) {  subobj_type = EXTRACT_16BITS ( obj_tptr + offset ) >> 8 ;   subobj_len = EXTRACT_16BITS ( obj_tptr + offset ) & 0x00FF ;  ND_PRINT ( ( ndo , ""\\n\\tSubobject,Type:%s(%u),Length:%u"" , tok2str ( lmp_data_link_subobj , ""Unknown"" , subobj_type ) , subobj_type , subobj_len ) ) ; switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : ND_PRINT ( ( ndo , ""\\n\\tSwitchingType:%s(%u)"" , tok2str ( gmpls_switch_cap_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + offset + 2 ) >> 8 ) , EXTRACT_16BITS ( obj_tptr + offset + 2 ) >> 8 ) ) ; ND_PRINT ( ( ndo , ""\\n\\tEncodingType:%s(%u)"" , tok2str ( gmpls_encoding_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + offset + 2 ) & 0x00FF ) , EXTRACT_16BITS ( obj_tptr + offset + 2 ) & 0x00FF ) ) ;  bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ;  ND_PRINT ( ( ndo , ""\\n\\tMinReservableBandwidth:%.3fMbps"" , bw . f * 8 / 1000000 ) ) ;  bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ;  ND_PRINT ( ( ndo , ""\\n\\tMaxReservableBandwidth:%.3fMbps"" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : ND_PRINT ( ( ndo , ""\\n\\tWavelength:%u"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ;  break ;  } total_subobj_len -= subobj_len ; offset += subobj_len ; } break ; case LMP_CTYPE_IPV6 : default : hexdump = TRUE ; } break ;  case LMP_OBJ_VERIFY_BEGIN :  switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\n\\tFlags:%s"" ,  bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tVerifyInterval:%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tDatalinks:%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tEncodingtype:%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tVerifyTransportMechanism:%u(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""(Payloadtestmessagescapable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\tTransmissionRate:%.3fMbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\tWavelength:%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ;  case LMP_OBJ_VERIFY_BEGIN_ACK :  switch ( lmp_obj_ctype ) {  case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\n\\tVerifyDeadInterval:%u"" ""\\n\\tVerifyTransportResponse:%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ;  case LMP_OBJ_VERIFY_ID :  switch ( lmp_obj_ctype ) {  case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\n\\tVerifyID:%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ;  case LMP_OBJ_CHANNEL_STATUS :  switch ( lmp_obj_ctype ) {  case LMP_CTYPE_IPV4 :  case LMP_CTYPE_UNMD : offset = 0 ; while ( offset < ( lmp_obj_len - ( int ) sizeof ( struct lmp_object_header ) ) ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tActive:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tDirection:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tChannelStatus:%s(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : default : hexdump = TRUE ; } break ;  case LMP_OBJ_CHANNEL_STATUS_REQ :  switch ( lmp_obj_ctype ) {  case LMP_CTYPE_IPV4 :  case LMP_CTYPE_UNMD : offset = 0 ; while ( offset < ( lmp_obj_len - ( int ) sizeof ( struct lmp_object_header ) ) ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : ND_PRINT ( ( ndo , ""\\n\\tErrorCode:%s"" ,  bittok2str ( lmp_obj_begin_verify_error_values ,  ""none"" ,  EXTRACT_32BITS ( obj_tptr ) ) ) ) ;  break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : ND_PRINT ( ( ndo , ""\\n\\tErrorCode:%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : ND_PRINT ( ( ndo , ""\\n\\tFlags:%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) >> 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tUNIVersion:%u"" ,  EXTRACT_16BITS ( obj_tptr ) & 0x00FF ) ) ;  break ;  case LMP_CTYPE_SERVICE_CONFIG_CPSA :   link_type = EXTRACT_16BITS ( obj_tptr ) >> 8 ;  ND_PRINT ( ( ndo , ""\\n\\tLinkType:%s(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; if ( link_type == LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH ) { ND_PRINT ( ( ndo , ""\\n\\tSignalType:%s(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr ) & 0x00FF ) , EXTRACT_16BITS ( obj_tptr ) & 0x00FF ) ) ; } if ( link_type == LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET ) { ND_PRINT ( ( ndo , ""\\n\\tSignalType:%s(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr ) & 0x00FF ) , EXTRACT_16BITS ( obj_tptr ) & 0x00FF ) ) ; } ND_PRINT ( ( ndo , ""\\n\\tTransparency:%s"" ,  bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values ,  ""none"" ,  EXTRACT_16BITS ( obj_tptr + 2 ) >> 8 ) ) ) ;  ND_PRINT ( ( ndo , ""\\n\\tContiguousConcatenationTypes:%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr + 2 ) >> 8 & 0x00FF ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMinimumNCC:%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMaximumNCC:%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMinimumNVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMaximumNVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : ND_PRINT ( ( ndo , ""\\n\\tTransparencyFlags:%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tTCMMonitoringFlags:%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr + 6 ) & 0x00FF ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : ND_PRINT ( ( ndo , ""\\n\\tDiversity:Flags:%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr + 2 ) & 0x00FF ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\tpacketexceededsnapshot"" ) ) ; }"," * obj_tptr ; u_int  tlen , lmp_obj_len  int hexdump ; u_int offset ; u_int  link_type ; union  ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""(tooshort)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""(toolong)"" ) ) ; tlen = len ; }  & 0x7f ;  ND_PRINT ( (  ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""(tooshort)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""(notamultipleof4)"" ) ) ; return ; }  case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalLink-ID:%s(0x%08x)"" ""\\n\\tRemoteLink-ID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tFlags:[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ;  ND_PRINT ( (  ""\\n\\tLocalLink-ID:%s(0x%08x)"" ""\\n\\tRemoteLink-ID:%s(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tFlags:[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalLink-ID:%u(0x%08x)"" ""\\n\\tRemoteLink-ID:%u(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS (  obj_tptr + 8  ; break ;  default : hexdump  case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; }  , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalInterfaceID:%s(0x%08x)"" ""\\n\\tRemoteInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tFlags:[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalInterfaceID:%s(0x%08x)"" ""\\n\\tRemoteInterfaceID:%s(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tFlags:[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalInterfaceID:%u(0x%08x)"" ""\\n\\tRemoteInterfaceID:%u(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tFlags:%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" ,  ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tVerifyInterval:%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tDatalinks:%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tEncodingtype:%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr +  8 ) )  ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tVerifyTransportMechanism:%u(0x%x)%s"" ,  EXTRACT_16BITS ( obj_tptr  ( obj_tptr + 10 ) ,  EXTRACT_16BITS ( obj_tptr  ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""(Payloadtestmessagescapable)"" : """"  ) ) ;  ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\tTransmissionRate:%.3fMbps"" ,  bw . f  ) ) ; ND_PRINT ( ( ndo , ""\\n\\tWavelength:%u"" , EXTRACT_32BITS ( obj_tptr + 16  ) ) )  = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tVerifyDeadInterval:%u"" ""\\n\\tVerifyTransportResponse:%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ;  default : hexdump  break ; case LMP_OBJ_VERIFY_ID  : switch (  case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tVerifyID:%u"" , EXTRACT_32BITS ( obj_tptr  ) ) )  break ; case LMP_OBJ_CHANNEL_STATUS  : switch (  ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tActive:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tDirection:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tChannelStatus:%s(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%s(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tActive:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tDirection:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tChannelStatus:%s(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%u(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tActive:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tDirection:%s(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tChannelStatus:%s(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; }  break ; default  break ; case LMP_OBJ_CHANNEL_STATUS_REQ  : switch (  ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%s(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\tInterfaceID:%u(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; }  break ; default  break ; case LMP_OBJ_ERROR_CODE  : switch (  ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tErrorCode:%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tErrorCode:%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ;  default : hexdump  break ; case LMP_OBJ_SERVICE_CONFIG  : switch (  ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tFlags:%s""  , bittok2str (  , bittok2str ( lmp_obj_service_config_sp_flag_values  , ""none"" ,  , ""none"" , EXTRACT_8BITS ( obj_tptr )  ) ) )  , ""\\n\\tUNIVersion:%u"" , EXTRACT_8BITS ( obj_tptr + 1 )  ) ) ;  case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\tLinkType:%s(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\tSignalType:%s(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\tSignalType:%s(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tTransparency:%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tContiguousConcatenationTypes:%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMinimumNCC:%u"" ,  EXTRACT_16BITS ( obj_tptr  EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMaximumNCC:%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMinimumNVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMaximumNVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tLocalInterfaceID:%s(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tTransparencyFlags:%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tTCMMonitoringFlags:%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""(notcorrectforobject)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\tDiversity:Flags:%s""  , bittok2str (  , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values  , ""none"" ,  , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 )  ) ) )"
377,"CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos )  {  if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }", pos ) { check_stack_depth ( ) ;
378,"CWE-119 int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , ""openssl"" , sizeof ( ""openssl"" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , ""opensslnotloaded"" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , ""%s.pubkey"" , fname ) ; pfp = php_stream_open_wrapper ( pfile , ""rb"" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , ""opensslpublickeycouldnotberead"" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if ( FAILURE == phar_call_openssl_signverify ( 0 , fp , end_of_phar , pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 , & sig , & tempsig ) ) { if ( pubkey ) { zend_string_release ( pubkey ) ; } if ( error ) { spprintf ( error , 0 , ""opensslsignaturecouldnotbeverified"" ) ; } return FAILURE ; } if ( pubkey ) { zend_string_release ( pubkey ) ; } sig_len = tempsig ; # else in = BIO_new_mem_buf ( pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 ) ; if ( NULL == in ) { zend_string_release ( pubkey ) ; if ( error ) { spprintf ( error , 0 , ""opensslsignaturecouldnotbeprocessed"" ) ; } return FAILURE ; } key = PEM_read_bio_PUBKEY ( in , NULL , NULL , NULL ) ; BIO_free ( in ) ; zend_string_release ( pubkey ) ; if ( NULL == key ) { if ( error ) { spprintf ( error , 0 , ""opensslsignaturecouldnotbeprocessed"" ) ; } return FAILURE ; } EVP_VerifyInit ( & md_ctx , mdtype ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; while ( read_size && ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { EVP_VerifyUpdate ( & md_ctx , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } if ( EVP_VerifyFinal ( & md_ctx , ( unsigned char * ) sig , sig_len , key ) != 1 ) { EVP_MD_CTX_cleanup ( & md_ctx ) ; if ( error ) { spprintf ( error , 0 , ""brokenopensslsignature"" ) ; } return FAILURE ; } EVP_MD_CTX_cleanup ( & md_ctx ) ; # endif * signature_len = phar_hex_str ( ( const char * ) sig , sig_len , signature ) ; } break ; # ifdef PHAR_HASH_OK case PHAR_SIG_SHA512 : { unsigned char digest [ 64 ] ; PHP_SHA512_CTX context ;  PHP_SHA512Init ( & context ) ;  read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA512Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA512Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_SHA256 : { unsigned char digest [ 32 ] ; PHP_SHA256_CTX context ;  PHP_SHA256Init ( & context ) ;  read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA256Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA256Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } # else case PHAR_SIG_SHA512 : case PHAR_SIG_SHA256 : if ( error ) { spprintf ( error , 0 , ""unsupportedsignature"" ) ; } return FAILURE ; # endif case PHAR_SIG_SHA1 : { unsigned char digest [ 20 ] ; PHP_SHA1_CTX context ;  PHP_SHA1Init ( & context ) ;  read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA1Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA1Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_MD5 : { unsigned char digest [ 16 ] ; PHP_MD5_CTX context ;  PHP_MD5Init ( & context ) ;  read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; }  * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ;  break ; } default : if ( error ) { spprintf ( error , 0 , ""brokenorunsupportedsignature"" ) ; } return FAILURE ; } return SUCCESS ; }"," PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; }  PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; }  PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; }  PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest  ) ) {  FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""brokensignature"" ) ; } return FAILURE ; }"
379,"CWE-000 static int mct_u232_port_probe ( struct usb_serial_port * port ) {  struct mct_u232_private * priv ;  priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ;  priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ;  priv -> read_urb -> context = port ; spin_lock_init ( & priv -> lock ) ; usb_set_serial_port_data ( port , priv ) ; return 0 ; }"," ) { struct usb_serial * serial = port -> serial ; struct  * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , ""expectedendpointmissing\\n"" ) ; return - ENODEV ; }  -> read_urb =  serial -> port"
380,"CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {  int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ;  int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'thandle.WAVfileslargerthan4GB(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:riffSize=%lld,dataSize=%lld,sampleCount=%lld,table_length=%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt"" , 4 ) ) {  int supported = TRUE , format ;  if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""formattagsize=%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag=%x,NumChannels=%d,BitsPerSample=%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign=%d,SampleRate=%d,BytesPerSecond=%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize=%d,ValidBitsPerSample=%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask=%x,SubFormat=%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%sisanunsupported.WAVformat!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisWAVfilealreadyhaschannelorderinformation!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""dataformat:normalized32-bitfloatingpoint"" ) ; else if ( config -> float_norm_exp ) error_line ( ""dataformat:32-bitfloatingpoint(Audition%d:%dfloattype1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""dataformat:%d-bitintegersstoredin%dbyte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this.WAVfilehasover16MBofextraRIFFdata,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this.WAVfilehasnoaudiosamples,probablyiscorrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%shastoomanysamplesforWavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }"," ) , got_ds64 = 0 , format_chunk  , format ; if ( format_chunk ++ ) { error_line ( ""%sisnotavalid.WAVfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }"
381,"CWE-264 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) {  rq = blk_mq_tag_to_rq ( tags , off + bit ) ;  fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }", { rq = tags -> rqs [  off + bit  off + bit ]  ; fn (
382,"CWE-190 static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { # ifndef SQLITE_OMIT_LOOKASIDE void * pStart ; if ( sqlite3LookasideUsed ( db , 0 ) > 0 ) { return SQLITE_BUSY ; } if ( db -> lookaside . bMalloced ) { sqlite3_free ( db -> lookaside . pStart ) ; } sz = ROUNDDOWN8 ( sz ) ; if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; if ( cnt < 0 ) cnt = 0 ; if ( sz == 0 || cnt == 0 ) { sz = 0 ; pStart = 0 ; } else if ( pBuf == 0 ) { sqlite3BeginBenignMalloc ( ) ;  pStart = sqlite3Malloc ( sz * cnt ) ;  sqlite3EndBenignMalloc ( ) ; if ( pStart ) cnt = sqlite3MallocSize ( pStart ) / sz ; } else { pStart = pBuf ; } db -> lookaside . pStart = pStart ; db -> lookaside . pInit = 0 ; db -> lookaside . pFree = 0 ; db -> lookaside . sz = ( u16 ) sz ; if ( pStart ) { int i ; LookasideSlot * p ; assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; db -> lookaside . nSlot = cnt ; p = ( LookasideSlot * ) pStart ; for ( i = cnt - 1 ; i >= 0 ; i -- ) { p -> pNext = db -> lookaside . pInit ; db -> lookaside . pInit = p ; p = ( LookasideSlot * ) & ( ( u8 * ) p ) [ sz ] ; } db -> lookaside . pEnd = p ; db -> lookaside . bDisable = 0 ; db -> lookaside . bMalloced = pBuf == 0 ? 1 : 0 ; } else { db -> lookaside . pStart = db ; db -> lookaside . pEnd = db ; db -> lookaside . bDisable = 1 ; db -> lookaside . bMalloced = 0 ; db -> lookaside . nSlot = 0 ; } # endif return SQLITE_OK ; }", ( sz * ( sqlite3_int64 )
383,"CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ; rc = - EADDRNOTAVAIL ; if ( ! ipxif ) break ; sipx -> sipx_family = AF_IPX ; sipx -> sipx_network = ipxif -> if_netnum ; memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ;  rc = - EFAULT ;   if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) )  break ;  ipxitf_put ( ipxif ) ;  rc = 0 ; break ; } case SIOCAIPXITFCRT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_auto_create_interfaces = val ; break ; case SIOCAIPXPRISLT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_set_auto_select ( val ) ; break ; } return rc ; }"," ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc =  - EFAULT ;  ipxitf_put ( ipxif  ( ipxif )  ; break ;"
384,"CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; }  if ( dst_reg -> smin_value < 0 ) {  if ( umin_val ) { dst_reg -> smin_value = 0 ; } else { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ;  }  } else { dst_reg -> smin_value = ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }", break ; }  dst_reg -> smin_value  = S64_MAX ;  if ( src_known
385,"CWE-125 static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , ""\\n\\t%sSubtype(%u)"" , tok2str ( lldp_8023_subtype_values , ""unknown"" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\tautonegotiation[%s](0x%02x)"" , bittok2str ( lldp_8023_autonegotiation_values , ""none"" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tPMDautonegcapability[%s](0x%04x)"" , bittok2str ( lldp_pmd_capability_values , ""unknown"" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\tMAUtype%s(0x%04x)"" , tok2str ( lldp_mau_types_values , ""unknown"" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\tMDIpowersupport[%s],powerpair%s,powerclass%s"" , bittok2str ( lldp_mdi_values , ""none"" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , ""unknown"" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , ""unknown"" , * ( tptr + 6 ) ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , ""\\n\\taggregationstatus[%s],aggregationportID%u"" , bittok2str ( lldp_aggregation_values , ""none"" , * ( tptr + 4 ) ) , EXTRACT_32BITS ( tptr + 5 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MTU :  ND_PRINT ( ( ndo , ""\\n\\tMTUsize%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ;  break ; default : hexdump = TRUE ; break ; } return hexdump ; }", case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
386,"CWE-119 static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ;  int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;  for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; case 2 : decode_clnpass ( s , t1 , width , height , bpno + 1 , bandpos , codsty -> cblk_style & JPEG2000_CBLK_SEGSYM , vert_causal_ctx_csty_symbol ) ; clnpass_cnt = clnpass_cnt + 1 ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; } pass_t ++ ; if ( pass_t == 3 ) { bpno -- ; pass_t = 0 ; } } return 0 ; }", cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
387,"CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) {  LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;  for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ;  LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;  } } }", inverse_db_table [ y & 255  inverse_db_table [ y & 255
388,"CWE-189 static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ;  if ( mobj )   memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ;  return mobj ; # endif }"," ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ;  , 0 , ROUNDUP ( size , granularity ) ) ; }  return mobj ;"
389,"CWE-476 int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ;  if ( text [ 1 ] == EOF )  return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ;  if ( text [ 2 ] == EOF )  return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ;  if ( text [ 3 ] == EOF )  return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }", ] == EOF || text [ 1 ] == 0  ; if ( ! isxdigit (  [ 2 ] )  ) return 0  ; if ( ! isxdigit (  [ 3 ] )  ) return 0
390,"CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:str:%d,end:%d,s:%d,range:%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) {  * low = p - reg -> dmax ;  if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc ,  ( pprev ? pprev : str ) , * low ) ;  } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_rangesuccess:low:%d,high:%d,dmin:%d,dmax:%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }"," ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else {  low ) ; }"
391,"CWE-264 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent * extent = NULL ; unsigned long page = 0 ; char * kbuf , * pos , * next_line ; ssize_t ret = - EINVAL ; mutex_lock ( & id_map_mutex ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) goto out ; ret = - ENOMEM ; page = __get_free_page ( GFP_TEMPORARY ) ; kbuf = ( char * ) page ; if ( ! page ) goto out ; ret = - EINVAL ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) goto out ; ret = - EFAULT ; if ( copy_from_user ( kbuf , buf , count ) ) goto out ; kbuf [ count ] = '\\0' ; ret = - EINVAL ; pos = kbuf ; new_map . nr_extents = 0 ; for ( ; pos ; pos = next_line ) { extent = & new_map . extent [ new_map . nr_extents ] ; next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent -> first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent -> first == ( u32 ) - 1 ) || ( extent -> lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent -> first + extent -> count ) <= extent -> first ) goto out ; if ( ( extent -> lower_first + extent -> count ) <= extent -> lower_first ) goto out ; if ( mappings_overlap ( & new_map , extent ) ) goto out ; new_map . nr_extents ++ ; if ( ( new_map . nr_extents == UID_GID_MAP_MAX_EXTENTS ) && ( next_line != NULL ) ) goto out ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ;  if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) )  goto out ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { u32 lower_first ; extent = & new_map . extent [ idx ] ; lower_first = map_id_range_down ( parent_map , extent -> lower_first , extent -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; extent -> lower_first = lower_first ; } memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : mutex_unlock ( & id_map_mutex ) ; if ( page ) free_page ( page ) ; return ret ; }"," ! new_idmap_permitted ( file ,"
392,"CWE-190 int amqp_handle_input ( amqp_connection_state_t state , amqp_bytes_t received_data , amqp_frame_t * decoded_frame ) { size_t bytes_consumed ; void * raw_frame ; decoded_frame -> frame_type = 0 ; if ( received_data . len == 0 ) { return AMQP_STATUS_OK ; } if ( state -> state == CONNECTION_STATE_IDLE ) { state -> state = CONNECTION_STATE_HEADER ; } bytes_consumed = consume_data ( state , & received_data ) ; if ( state -> inbound_offset < state -> target_size ) { return ( int ) bytes_consumed ; } raw_frame = state -> inbound_buffer . bytes ; switch ( state -> state ) { case CONNECTION_STATE_INITIAL : if ( memcmp ( raw_frame , ""AMQP"" , 4 ) == 0 ) { decoded_frame -> frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER ; decoded_frame -> channel = 0 ; decoded_frame -> payload . protocol_header . transport_high = amqp_d8 ( amqp_offset ( raw_frame , 4 ) ) ; decoded_frame -> payload . protocol_header . transport_low = amqp_d8 ( amqp_offset ( raw_frame , 5 ) ) ; decoded_frame -> payload . protocol_header . protocol_version_major = amqp_d8 ( amqp_offset ( raw_frame , 6 ) ) ; decoded_frame -> payload . protocol_header . protocol_version_minor = amqp_d8 ( amqp_offset ( raw_frame , 7 ) ) ; return_to_idle ( state ) ; return ( int ) bytes_consumed ; } case CONNECTION_STATE_HEADER : { amqp_channel_t channel ; amqp_pool_t * channel_pool ;  channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ;   state -> target_size =   amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) + HEADER_SIZE + FOOTER_SIZE ;  if ( ( size_t ) state -> frame_max < state -> target_size ) { return AMQP_STATUS_BAD_AMQP_DATA ; } channel_pool = amqp_get_or_create_channel_pool ( state , channel ) ; if ( NULL == channel_pool ) { return AMQP_STATUS_NO_MEMORY ; } amqp_pool_alloc_bytes ( channel_pool , state -> target_size , & state -> inbound_buffer ) ; if ( NULL == state -> inbound_buffer . bytes ) { return AMQP_STATUS_NO_MEMORY ; } memcpy ( state -> inbound_buffer . bytes , state -> header_buffer , HEADER_SIZE ) ; raw_frame = state -> inbound_buffer . bytes ; state -> state = CONNECTION_STATE_BODY ; bytes_consumed += consume_data ( state , & received_data ) ; if ( state -> inbound_offset < state -> target_size ) { return ( int ) bytes_consumed ; } } case CONNECTION_STATE_BODY : { amqp_bytes_t encoded ; int res ; amqp_pool_t * channel_pool ; if ( amqp_d8 ( amqp_offset ( raw_frame , state -> target_size - 1 ) ) != AMQP_FRAME_END ) { return AMQP_STATUS_BAD_AMQP_DATA ; } decoded_frame -> frame_type = amqp_d8 ( amqp_offset ( raw_frame , 0 ) ) ; decoded_frame -> channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ; channel_pool = amqp_get_or_create_channel_pool ( state , decoded_frame -> channel ) ; if ( NULL == channel_pool ) { return AMQP_STATUS_NO_MEMORY ; } switch ( decoded_frame -> frame_type ) { case AMQP_FRAME_METHOD : decoded_frame -> payload . method . id = amqp_d32 ( amqp_offset ( raw_frame , HEADER_SIZE ) ) ; encoded . bytes = amqp_offset ( raw_frame , HEADER_SIZE + 4 ) ; encoded . len = state -> target_size - HEADER_SIZE - 4 - FOOTER_SIZE ; res = amqp_decode_method ( decoded_frame -> payload . method . id , channel_pool , encoded , & decoded_frame -> payload . method . decoded ) ; if ( res < 0 ) { return res ; } break ; case AMQP_FRAME_HEADER : decoded_frame -> payload . properties . class_id = amqp_d16 ( amqp_offset ( raw_frame , HEADER_SIZE ) ) ; decoded_frame -> payload . properties . body_size = amqp_d64 ( amqp_offset ( raw_frame , HEADER_SIZE + 4 ) ) ; encoded . bytes = amqp_offset ( raw_frame , HEADER_SIZE + 12 ) ; encoded . len = state -> target_size - HEADER_SIZE - 12 - FOOTER_SIZE ; decoded_frame -> payload . properties . raw = encoded ; res = amqp_decode_properties ( decoded_frame -> payload . properties . class_id , channel_pool , encoded , & decoded_frame -> payload . properties . decoded ) ; if ( res < 0 ) { return res ; } break ; case AMQP_FRAME_BODY : decoded_frame -> payload . body_fragment . len = state -> target_size - HEADER_SIZE - FOOTER_SIZE ; decoded_frame -> payload . body_fragment . bytes = amqp_offset ( raw_frame , HEADER_SIZE ) ; break ; case AMQP_FRAME_HEARTBEAT : break ; default : decoded_frame -> frame_type = 0 ; break ; } return_to_idle ( state ) ; return ( int ) bytes_consumed ; } default : amqp_abort ( ""Internalerror:invalidamqp_connection_state_t->state%d"" , state -> state ) ; } }"," * channel_pool ; uint32_t frame_size ;  ) ) ; frame_size = amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) ; if ( frame_size >= INT32_MAX ) { return AMQP_STATUS_BAD_AMQP_DATA ; }  -> target_size = frame_size  + HEADER_SIZE +"
393,"CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME :  if ( file -> name ) XFREE ( file -> name ) ;  file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ :  file -> len = a -> values [ 0 ] . len ;  if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG :  if ( file -> mime_type ) XFREE ( file -> mime_type ) ;  file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID :  if ( file -> content_id ) XFREE ( file -> content_id ) ;  file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> content_id , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; default : break ; } } } }", case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ;  case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ;  case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ;  case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
394,"CWE-476 static bool LookupModMask ( struct xkb_context * ctx , const void * priv , xkb_atom_t field , enum expr_value_type type , xkb_mod_mask_t * val_rtrn ) { const char * str ; xkb_mod_index_t ndx ; const LookupModMaskPriv * arg = priv ; const struct xkb_mod_set * mods = arg -> mods ; enum mod_type mod_type = arg -> mod_type ; if ( type != EXPR_TYPE_INT ) return false ; str = xkb_atom_text ( ctx , field ) ;  if ( istreq ( str , ""all"" ) ) {  * val_rtrn = MOD_REAL_MASK_ALL ; return true ; } if ( istreq ( str , ""none"" ) ) { * val_rtrn = 0 ; return true ; } ndx = XkbModNameToIndex ( mods , field , mod_type ) ; if ( ndx == XKB_MOD_INVALID ) return false ; * val_rtrn = ( 1u << ndx ) ; return true ; }", ; if ( ! str ) return false ; if (
395,"CWE-770 WORD32 ihevcd_create ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) {  ihevcd_cxa_create_op_t * ps_create_op ;  WORD32 ret ; codec_t * ps_codec ;  ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ;  ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ;  ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ;   if ( ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) )  {  ihevcd_free_static_bufs ( ps_codec_obj ) ;  ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 1 << IVD_FATALERROR ; return IV_FAIL ; } ps_codec = ( codec_t * ) ps_codec_obj -> pv_codec_handle ; ret = ihevcd_init ( ps_codec ) ; TRACE_INIT ( NULL ) ; STATS_INIT ( ) ; return ret ; }"," pv_api_op ) { ihevcd_cxa_create_ip_t * ps_create_ip ;  * ps_codec ; ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ;  = 0 ; ps_codec_obj = NULL ;  ) ; if  ( IV_FAIL ==  == ret ) { if  ( NULL !=  != ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle  ps_codec_obj ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } }"
396,"CWE-20 static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {  int pkt_len ;   char line [ NETSCREEN_LINE_LENGTH ] ;  char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; }  pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;  if ( pkt_len == - 1 )  return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }"," err_info ) {  char line [  line [ NETSCREEN_LINE_LENGTH  ] ; if  FALSE ; } return parse_netscreen_packet ( wth -> random_fh , phdr , buf  , line ,  , line ,  err , err_info  err_info ) ;  }  "
397,"CWE-190 void * checked_xcalloc ( size_t num , size_t size ) {  alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ;  return xcalloc ( num , size ) ; }"," size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;  ""checked_xcalloc"" , ( res  ) ) ;"
398,"CWE-119 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( ""I1012"" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , ""Unabletoselectpublickeyfile:%s\\n"" , sc_strerror ( r ) ) ; return 2 ; }  bufsize = file -> size ;  sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , ""Unabletoreadpublickeyfile:%s\\n"" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( ""Keynumber%dnotfound.\\n"" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }"," } bufsize = MIN (  file -> size , sizeof buf )"
399,"CWE-399 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;  return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;  return simulate_sc ( regs , opcode ) ; } return - 1 ; }"," PERF_COUNT_SW_EMULATION_FAULTS , 1  , regs ,  , 1 ,  regs , 0"
400,"CWE-863 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ;  if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) )  goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; }  if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) {  memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }", & new_map )  ) goto out  lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
401,"CWE-119 static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ;  int pixel_ptr = 0 ;  int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""Firstchunkbyteis0x%02xinsteadof0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOVchunksize!=encodedchunksize;usingMOVchunksize\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) {  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ;  block_ptr = row_ptr + pixel_ptr ;  for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; }  ADVANCE_BLOCK ( ) ;  break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknownopcode%dinrpzachunk."" ""Skipremaining%dbytesofchunkdata.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }", int pixel_ptr = - 4  ; int block_ptr  -- ) { ADVANCE_BLOCK ( )  row_inc ; }  } break ;  -- ) { ADVANCE_BLOCK ( ) ;  row_inc ; }  } break ;  ) return ; ADVANCE_BLOCK ( ) ;  row_inc ; }  break ; default
402,"CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ;  * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;  if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }", : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
403,"CWE-787 static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , ""Compressiontypeincompatiblewithimagetype"" ) ;  }  if ( rctx -> topdown ) {  iw_set_error ( rctx -> ctx , ""Compressionnotallowedwithtop-downimages"" ) ;  } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }"," ""Compressiontypeincompatiblewithimagetype"" ) ; goto done ;  , ""Compressionnotallowedwithtop-downimages"" ) ; goto done"
404,"CWE-200 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ;  int err = 0 ;  if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , CB_TRGCLS_LEN , CB_TRGCLS ( skb ) ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }", ; int err = 0 ; msg -> msg_namelen
405,CWE-20 void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ;  put_io_context ( ioc ) ;  }  } , ioc ) ; }  ) ; }    
406,"CWE-284 void _modinit ( module_t * m ) { service_named_bind_command ( ""chanserv"" , & cs_flags ) ;  } "," cs_flags ) ; add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ;"
407,"CWE-000 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ;  if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC )  { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ;  if ( ! ps_dec -> u1_first_slice_in_stream )  { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { return ERROR_INV_SLICE_HDR_T ; } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbsinslice:%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }", WORD32 ret ; UNUSED ( u1_is_idr_slice ) ;  = u2_frame_num ;  { WORD32 i
408,"CWE-125  static inline struct enamemem *  lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) {  struct enamemem * tp ;  register u_int i , j , k ; if ( nlen >= 6 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = ( bs [ 4 ] << 8 ) | bs [ 5 ] ; } else if ( nlen >= 4 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = 0 ; } else i = j = k = 0 ; tp = & bytestringtable [ ( i ^ j ) & ( HASHNAMESIZE - 1 ) ] ;  while ( tp -> e_nxt )  if ( tp -> e_addr0 == i &&  tp -> e_addr1 == j &&   tp -> e_addr2 == k &&   memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 )  return tp ; else  tp = tp -> e_nxt ;  tp -> e_addr0 = i ; tp -> e_addr1 = j ; tp -> e_addr2 = k ; tp -> e_bs = ( u_char * ) calloc ( 1 , nlen + 1 ) ;  if ( tp -> e_bs == NULL )  ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:calloc"" ) ;  memcpy ( tp -> e_bs , bs , nlen ) ;   tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ;   if ( tp -> e_nxt == NULL )  ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:calloc"" ) ; return tp ; }"," static inline struct bsnamemem  * lookup_bytestring (  ) { struct bsnamemem  * tp ;  ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes  && tp ->  && tp -> bs_addr0 == i  && tp ->  && tp -> bs_addr1 == j && tp -> bs_addr2  == k &&  ( tp -> bs_bytes  ) , nlen  = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes  = ( u_char  ( tp -> bs_bytes  == NULL )  ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt  = ( struct  = ( struct bsnamemem  * ) calloc  ( tp -> bs_nxt  == NULL )"
409,"CWE-119  void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) { if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ; else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; }"," tx_type , const tran_low_t  * input ,"
410,"CWE-787 char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) { char * buffer = NULL ; int n = 0 ; FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( """" , cl , NULL ) ;  if ( length > 0 ) {   buffer = malloc ( ( uint64_t ) length + 1 ) ;  if ( buffer != NULL ) { if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( ""rfbProcessFileTransferReadBuffer:read"" ) ; rfbCloseClient ( cl ) ; if ( buffer != NULL ) free ( buffer ) ; return NULL ; } buffer [ length ] = 0 ; } } return buffer ; }"," if ( length == SIZE_MAX ) { rfbErr ( ""rfbProcessFileTransferReadBuffer:toobigfiletransferlengthrequested:%u"" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length  malloc ( ( size_t  ) length +"
411,"CWE-362  static int mptctl_do_reset ( unsigned long arg )  { struct mpt_ioctl_diag_reset __user * urinfo = ( void __user * ) arg ;  struct mpt_ioctl_diag_reset krinfo ;  MPT_ADAPTER * iocp ; if ( copy_from_user ( & krinfo , urinfo , sizeof ( struct mpt_ioctl_diag_reset ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_do_reset-"" ""Unabletocopympt_ioctl_diag_resetstruct@%p\\n"" , __FILE__ , __LINE__ , urinfo ) ;  return - EFAULT ;  } if ( mpt_verify_adapter ( krinfo . hdr . iocnum , & iocp ) < 0 ) { printk ( KERN_DEBUG MYNAM ""%s@%d::mptctl_do_reset-ioc%dnotfound!\\n"" , __FILE__ , __LINE__ , krinfo . hdr . iocnum ) ; return - ENODEV ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_resetcalled.\\n"" , iocp -> name ) ) ; if ( mpt_HardResetHandler ( iocp , CAN_SLEEP ) != 0 ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_reset-resetfailed.\\n"" , iocp -> name , __FILE__ , __LINE__ ) ; return - 1 ; } return 0 ; }"," int mptctl_do_reset ( MPT_ADAPTER * iocp ,  struct mpt_ioctl_diag_reset krinfo  ; if (  return - EFAULT  ; } dctlprintk"
412,"CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , ""failedtoapplydelta:basesizedoesnotmatchgivendata"" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , ""failedtoapplydelta:basesizedoesnotmatchgivendata"" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) {  size_t off = 0 , len = 0 ;  # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ; if ( cmd & 0x04 ) ADD_DELTA ( off , 16UL ) ; if ( cmd & 0x08 ) ADD_DELTA ( off , 24UL ) ; if ( cmd & 0x10 ) ADD_DELTA ( len , 0UL ) ; if ( cmd & 0x20 ) ADD_DELTA ( len , 8UL ) ; if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) ; if ( ! len ) len = 0x10000 ; # undef ADD_DELTA  if ( base_len < off + len || res_sz < len )  goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , ""failedtoapplydelta"" ) ; return - 1 ; }"," len = 0 , end  ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end  || res_sz <"
413,"CWE-78 static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) { static char cmd [ BUF_SIZE ] ;  char * method = manager -> method ;  int i ;  build_config ( working_dir , server ) ;  if ( server -> method ) method = server -> method ; memset ( cmd , 0 , BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE ,  ""%s-m%s--manager-address%s-f%s/.shadowsocks_%s.pid-c%s/.shadowsocks_%s.conf"" ,   executable , method , manager -> manager_address ,   working_dir , server -> port , working_dir , server -> port ) ;  if ( manager -> acl != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""--acl%s"" , manager -> acl ) ; } if ( manager -> timeout != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-t%s"" , manager -> timeout ) ; } # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-n%d"" , manager -> nofile ) ; } # endif if ( manager -> user != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-a%s"" , manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-v"" ) ; } if ( server -> mode == NULL && manager -> mode == UDP_ONLY ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-U"" ) ; } if ( server -> mode == NULL && manager -> mode == TCP_AND_UDP ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-u"" ) ; } if ( server -> fast_open [ 0 ] == 0 && manager -> fast_open ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""--fast-open"" ) ; } if ( manager -> ipv6first ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-6"" ) ; } if ( manager -> mtu ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""--mtu%d"" , manager -> mtu ) ; } if ( server -> plugin == NULL && manager -> plugin ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""--plugin\\""%s\\"""" , manager -> plugin ) ; } if ( server -> plugin_opts == NULL && manager -> plugin_opts ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""--plugin-opts\\""%s\\"""" , manager -> plugin_opts ) ; } for ( i = 0 ; i < manager -> nameserver_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-d%s"" , manager -> nameservers [ i ] ) ; } for ( i = 0 ; i < manager -> host_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""-s%s"" , manager -> hosts [ i ] ) ; } { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , ""--reuse-port"" ) ; } if ( verbose ) { LOGI ( ""cmd:%s"" , cmd ) ; } return cmd ; }"," BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port )  ; build_config (  ( working_dir , manager , server )  ; memset (  , BUF_SIZE , ""%s--manager-address%s-f%s/.shadowsocks_%d.pid-c%s/.shadowsocks_%d.conf""  , executable ,  , executable ,  manager -> manager_address  , working_dir ,  port , working_dir  , working_dir ,  port ) ;"
414,"CWE-20 static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int copied = 0 ; int target ; int err = 0 ; long timeo ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ;  msg -> msg_namelen = 0 ;  err = - EAGAIN ; if ( sk -> sk_state == CAIF_CONNECTING ) goto out ; caif_read_lock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { int chunk ; struct sk_buff * skb ; lock_sock ( sk ) ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; caif_check_flow_release ( sk ) ; if ( skb == NULL ) { if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; err = - ECONNRESET ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; err = - EPIPE ; if ( sk -> sk_state != CAIF_CONNECTED ) goto unlock ; if ( sock_flag ( sk , SOCK_DEAD ) ) goto unlock ; release_sock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; caif_read_unlock ( sk ) ; timeo = caif_stream_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } caif_read_lock ( sk ) ; continue ; unlock : release_sock ( sk ) ; break ; } release_sock ( sk ) ; chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; caif_read_unlock ( sk ) ; out : return copied ? : err ; }", goto out ;  err = -
415,"CWE-000 static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( ""REVALIDATIONDEFERREDonport%d,pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( ""REVALIDATINGDOMAINonport%d,pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( ""doneREVALIDATINGDOMAINonport%d,pid:%d,res0x%x\\n"" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ;  } ", disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
416,"CWE-416 static void ffs_user_copy_worker ( struct work_struct * work ) { struct ffs_io_data * io_data = container_of ( work , struct ffs_io_data , work ) ; int ret = io_data -> req -> status ? io_data -> req -> status : io_data -> req -> actual ;  if ( io_data -> read && ret > 0 ) {  use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd &&  ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) )  eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;  usb_ep_free_request ( io_data -> ep , io_data -> req ) ;  io_data -> kiocb -> private = NULL ; if ( io_data -> read ) kfree ( io_data -> to_free ) ; kfree ( io_data -> buf ) ; kfree ( io_data ) ; }"," -> actual ; bool kiocb_has_eventfd =  io_data -> kiocb  ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd  ) eventfd_signal (  -> req )  ; if ("
417,"CWE-119 static int virtnet_probe ( struct virtio_device * vdev ) { int i , err ; struct net_device * dev ; struct virtnet_info * vi ; u16 max_queue_pairs ; if ( ! vdev -> config -> get ) { dev_err ( & vdev -> dev , ""%sfailure:configaccessdisabled\\n"" , __func__ ) ; return - EINVAL ; } if ( ! virtnet_validate_features ( vdev ) ) return - EINVAL ; err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , struct virtio_net_config , max_virtqueue_pairs , & max_queue_pairs ) ; if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) max_queue_pairs = 1 ; dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; if ( ! dev ) return - ENOMEM ; dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; dev -> netdev_ops = & virtnet_netdev ; dev -> features = NETIF_F_HIGHDMA ; dev -> ethtool_ops = & virtnet_ethtool_ops ; SET_NETDEV_DEV ( dev , & vdev -> dev ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) {  dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;  if ( csum )  dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;  if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO | NETIF_F_TSO_ECN | NETIF_F_TSO6 ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) ) dev -> hw_features |= NETIF_F_TSO ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) ) dev -> hw_features |= NETIF_F_TSO6 ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_ECN ) ) dev -> hw_features |= NETIF_F_TSO_ECN ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_UFO ) ) dev -> hw_features |= NETIF_F_UFO ; dev -> features |= NETIF_F_GSO_ROBUST ; if ( gso ) dev -> features |= dev -> hw_features & ( NETIF_F_ALL_TSO | NETIF_F_UFO ) ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_CSUM ) ) dev -> features |= NETIF_F_RXCSUM ; dev -> vlan_features = dev -> features ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MAC ) ) virtio_cread_bytes ( vdev , offsetof ( struct virtio_net_config , mac ) , dev -> dev_addr , dev -> addr_len ) ; else eth_hw_addr_random ( dev ) ; vi = netdev_priv ( dev ) ; vi -> dev = dev ; vi -> vdev = vdev ; vdev -> priv = vi ; vi -> stats = alloc_percpu ( struct virtnet_stats ) ; err = - ENOMEM ; if ( vi -> stats == NULL ) goto free ; for_each_possible_cpu ( i ) { struct virtnet_stats * virtnet_stats ; virtnet_stats = per_cpu_ptr ( vi -> stats , i ) ; u64_stats_init ( & virtnet_stats -> tx_syncp ) ; u64_stats_init ( & virtnet_stats -> rx_syncp ) ; } INIT_WORK ( & vi -> config_work , virtnet_config_changed_work ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO4 ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO6 ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_ECN ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_UFO ) ) vi -> big_packets = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) ) vi -> mergeable_rx_bufs = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) vi -> hdr_len = sizeof ( struct virtio_net_hdr_mrg_rxbuf ) ; else vi -> hdr_len = sizeof ( struct virtio_net_hdr ) ; if ( virtio_has_feature ( vdev , VIRTIO_F_ANY_LAYOUT ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) vi -> any_header_sg = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) vi -> has_cvq = true ; if ( vi -> any_header_sg ) dev -> needed_headroom = vi -> hdr_len ; vi -> curr_queue_pairs = 1 ; vi -> max_queue_pairs = max_queue_pairs ; err = init_vqs ( vi ) ; if ( err ) goto free_stats ; # ifdef CONFIG_SYSFS if ( vi -> mergeable_rx_bufs ) dev -> sysfs_rx_queue_group = & virtio_net_mrg_rx_group ; # endif netif_set_real_num_tx_queues ( dev , vi -> curr_queue_pairs ) ; netif_set_real_num_rx_queues ( dev , vi -> curr_queue_pairs ) ; err = register_netdev ( dev ) ; if ( err ) { pr_debug ( ""virtio_net:registeringdevicefailed\\n"" ) ; goto free_vqs ; } virtio_device_ready ( vdev ) ; for ( i = 0 ; i < vi -> curr_queue_pairs ; i ++ ) { try_fill_recv ( vi , & vi -> rq [ i ] , GFP_KERNEL ) ; if ( vi -> rq [ i ] . vq -> num_free == virtqueue_get_vring_size ( vi -> rq [ i ] . vq ) ) { free_unused_bufs ( vi ) ; err = - ENOMEM ; goto free_recv_bufs ; } } vi -> nb . notifier_call = & virtnet_cpu_callback ; err = register_hotcpu_notifier ( & vi -> nb ) ; if ( err ) { pr_debug ( ""virtio_net:registeringcpunotifierfailed\\n"" ) ; goto free_recv_bufs ; } if ( virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_STATUS ) ) { netif_carrier_off ( dev ) ; schedule_work ( & vi -> config_work ) ; } else { vi -> status = VIRTIO_NET_S_LINK_UP ; netif_carrier_on ( dev ) ; } pr_debug ( ""virtnet:registereddevice%swith%dRXandTXvq\'s\\n"" , dev -> name , max_queue_pairs ) ; return 0 ; free_recv_bufs : vi -> vdev -> config -> reset ( vdev ) ; free_receive_bufs ( vi ) ; unregister_netdev ( dev ) ; free_vqs : cancel_delayed_work_sync ( & vi -> refill ) ; free_receive_page_frags ( vi ) ; virtnet_del_vqs ( vi ) ; free_stats : free_percpu ( vi -> stats ) ; free : free_netdev ( dev ) ; return err ; }", NETIF_F_HW_CSUM | NETIF_F_SG  ; if (  NETIF_F_HW_CSUM | NETIF_F_SG  ; if (
418,"CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ;  ctx -> clockid = clockid ;  if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( ""[timerfd]"" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }", wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;
419,"CWE-000 kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) { int ret , ret2 , i ; kadm5_policy_ent_rec pol ; krb5_boolean have_pol = FALSE ; krb5_db_entry * kdb ; krb5_tl_data * tl_data_orig ; osa_princ_ent_rec adb ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ;  if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;  if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;  if ( entry == ( kadm5_principal_ent_t ) NULL )  return EINVAL ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; if ( ret ) return ( ret ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ; if ( ret ) goto done ; adb . aux_attributes |= KADM5_POLICY ; if ( adb . policy ) free ( adb . policy ) ; adb . policy = strdup ( entry -> policy ) ; } if ( have_pol ) { if ( pol . pw_max_life ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( kdb -> pw_expiration ) ) ; if ( ret ) goto done ; kdb -> pw_expiration += pol . pw_max_life ; } else { kdb -> pw_expiration = 0 ; } } if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) { free ( adb . policy ) ; adb . policy = NULL ; adb . aux_attributes &= ~ KADM5_POLICY ; kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; if ( mask & KADM5_PW_EXPIRATION ) kdb -> pw_expiration = entry -> pw_expiration ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; if ( ( mask & KADM5_KVNO ) ) { for ( i = 0 ; i < kdb -> n_key_data ; i ++ ) kdb -> key_data [ i ] . key_data_kvno = entry -> kvno ; } if ( mask & KADM5_TL_DATA ) { krb5_tl_data * tl ; for ( tl = entry -> tl_data ; tl ; tl = tl -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl ) ; if ( ret ) { goto done ; } } } if ( mask & KADM5_FAIL_AUTH_COUNT ) { if ( entry -> fail_auth_count != 0 ) { ret = KADM5_BAD_SERVER_PARAMS ; goto done ; } kdb -> fail_auth_count = 0 ; } kdb -> mask = mask ; ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ; if ( ret ) goto done ; ret = kdb_put_entry ( handle , kdb , & adb ) ; if ( ret ) goto done ; ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ; ret = KADM5_OK ; done : if ( have_pol ) { ret2 = kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; ret = ret ? ret : ret2 ; } kdb_free_entry ( handle , kdb , & adb ) ; return ret ; }", ; if ( entry == NULL ) return EINVAL ; if (  KADM5_POLICY ) && entry -> policy == NULL  ) return KADM5_BAD_MASK  ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK  ; if (
420,"CWE-20 error_t coapClientWriteBody ( CoapClientRequest * request , const void * data , size_t length , size_t * written , bool_t last ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; if ( written != NULL ) * written = 0 ; while ( length > 0 || last ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapGetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> txBlockSzx ; } error = coapClientGetPayload ( requestMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( length > 0 && payloadLen < COAP_GET_BLOCK_SIZE ( blockSzx ) ) { n = MIN ( length , COAP_GET_BLOCK_SIZE ( blockSzx ) - payloadLen ) ; error = coapClientWritePayload ( requestMsg , data , n ) ; if ( error ) break ; data = ( uint8_t * ) data + n ; length -= n ; if ( written != NULL ) * written += n ; } else { if ( blockPos > 0 || length > 0 || ! last ) { COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; if ( length == 0 && last )  COAP_SET_BLOCK_M ( value , 0 ) ;   else   COAP_SET_BLOCK_M ( value , 1 ) ;  COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , value ) ; if ( error ) break ; } if ( length == 0 && last ) { if ( request -> rxBlockSzx < COAP_BLOCK_SIZE_RESERVED ) { COAP_SET_BLOCK_NUM ( value , 0 ) ; COAP_SET_BLOCK_M ( value , 0 ) ; COAP_SET_BLOCK_SZX ( value , request -> rxBlockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , value ) ; if ( error ) break ; } } error = coapClientSendRequest ( request , NULL , NULL ) ; if ( error ) break ; responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientGetResponseCode ( responseMsg , & responseCode ) ; if ( error ) break ; if ( COAP_GET_CODE_CLASS ( responseCode ) != COAP_CODE_CLASS_SUCCESS ) { error = ERROR_INVALID_STATUS ; break ; } if ( blockPos > 0 || length > 0 || ! last ) { error = coapClientGetUintOption ( responseMsg , COAP_OPT_BLOCK1 , 0 , & value ) ; if ( error ) break ; if ( COAP_GET_BLOCK_SZX ( value ) >= COAP_BLOCK_SIZE_RESERVED ) { error = ERROR_FAILURE ; break ; } if ( COAP_GET_BLOCK_POS ( value ) != blockPos ) { error = ERROR_FAILURE ; break ; } if ( blockSzx > COAP_GET_BLOCK_SZX ( value ) ) blockSzx = COAP_GET_BLOCK_SZX ( value ) ; blockPos += COAP_GET_BLOCK_SIZE ( blockSzx ) ; COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , value ) ; if ( error ) break ; } error = coapClientSetPayload ( requestMsg , NULL , 0 ) ; if ( error ) break ; if ( length == 0 && last ) { error = coapClientDeleteOption ( requestMsg , COAP_OPT_BLOCK1 , 0 ) ; break ; } } } return error ; }", && last ) {  0 ) ; } else {  COAP_SET_BLOCK_M ( value  1 ) ; }
421,"CWE-119 void ourWriteOut ( CURL * curl , struct OutStruct * outs , const char * writeinfo ) { FILE * stream = stdout ; const char * ptr = writeinfo ; char * stringp = NULL ; long longinfo ; double doubleinfo ; while ( ptr && * ptr ) {  if ( '%' == * ptr ) {  if ( '%' == ptr [ 1 ] ) { fputc ( '%' , stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '{' == ptr [ 1 ] ) { bool match = FALSE ; end = strchr ( ptr , '}' ) ; ptr += 2 ; if ( ! end ) { fputs ( ""%{"" , stream ) ; continue ; } keepit = * end ; * end = 0 ; for ( i = 0 ; replacements [ i ] . name ; i ++ ) { if ( curl_strequal ( ptr , replacements [ i ] . name ) ) { match = TRUE ; switch ( replacements [ i ] . id ) { case VAR_EFFECTIVE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_EFFECTIVE_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_HTTP_CODE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_RESPONSE_CODE , & longinfo ) ) fprintf ( stream , ""%03ld"" , longinfo ) ; break ; case VAR_HTTP_CODE_PROXY : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_CONNECTCODE , & longinfo ) ) fprintf ( stream , ""%03ld"" , longinfo ) ; break ; case VAR_HEADER_SIZE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HEADER_SIZE , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REQUEST_SIZE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REQUEST_SIZE , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_NUM_CONNECTS : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_NUM_CONNECTS , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REDIRECT_COUNT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REDIRECT_COUNT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REDIRECT_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REDIRECT_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_TOTAL_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_TOTAL_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_NAMELOOKUP_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_NAMELOOKUP_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_CONNECT_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_CONNECT_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_APPCONNECT_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_APPCONNECT_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_PRETRANSFER_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PRETRANSFER_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_STARTTRANSFER_TIME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_STARTTRANSFER_TIME , & doubleinfo ) ) fprintf ( stream , ""%.6f"" , doubleinfo ) ; break ; case VAR_SIZE_UPLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SIZE_UPLOAD , & doubleinfo ) ) fprintf ( stream , ""%.0f"" , doubleinfo ) ; break ; case VAR_SIZE_DOWNLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SIZE_DOWNLOAD , & doubleinfo ) ) fprintf ( stream , ""%.0f"" , doubleinfo ) ; break ; case VAR_SPEED_DOWNLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SPEED_DOWNLOAD , & doubleinfo ) ) fprintf ( stream , ""%.3f"" , doubleinfo ) ; break ; case VAR_SPEED_UPLOAD : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SPEED_UPLOAD , & doubleinfo ) ) fprintf ( stream , ""%.3f"" , doubleinfo ) ; break ; case VAR_CONTENT_TYPE : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_CONTENT_TYPE , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_FTP_ENTRY_PATH : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_FTP_ENTRY_PATH , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_REDIRECT_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REDIRECT_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_SSL_VERIFY_RESULT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SSL_VERIFYRESULT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_PROXY_SSL_VERIFY_RESULT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PROXY_SSL_VERIFYRESULT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_EFFECTIVE_FILENAME : if ( outs -> filename ) fprintf ( stream , ""%s"" , outs -> filename ) ; break ; case VAR_PRIMARY_IP : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PRIMARY_IP , & stringp ) ) fprintf ( stream , ""%s"" , stringp ) ; break ; case VAR_PRIMARY_PORT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_PRIMARY_PORT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_LOCAL_IP : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_LOCAL_IP , & stringp ) ) fprintf ( stream , ""%s"" , stringp ) ; break ; case VAR_LOCAL_PORT : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_LOCAL_PORT , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_HTTP_VERSION : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_VERSION , & longinfo ) ) { const char * version = ""0"" ; switch ( longinfo ) { case CURL_HTTP_VERSION_1_0 : version = ""1.0"" ; break ; case CURL_HTTP_VERSION_1_1 : version = ""1.1"" ; break ; case CURL_HTTP_VERSION_2_0 : version = ""2"" ; break ; } fprintf ( stream , version ) ; } break ; case VAR_SCHEME : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_SCHEME , & stringp ) ) fprintf ( stream , ""%s"" , stringp ) ; break ; default : break ; } break ; } } if ( ! match ) { fprintf ( stderr , ""curl:unknown--write-outvariable:\'%s\'\\n"" , ptr ) ; } ptr = end + 1 ; * end = keepit ; } else { fputc ( '%' , stream ) ; fputc ( ptr [ 1 ] , stream ) ; ptr += 2 ; } } } else if ( '\\\\' == * ptr ) { switch ( ptr [ 1 ] ) { case 'r' : fputc ( '\\r' , stream ) ; break ; case 'n' : fputc ( '\\n' , stream ) ; break ; case 't' : fputc ( '\\t' , stream ) ; break ; default : fputc ( * ptr , stream ) ; fputc ( ptr [ 1 ] , stream ) ; break ; } ptr += 2 ; } else { fputc ( * ptr , stream ) ; ptr ++ ; } } }", == * ptr && ptr [ 1 ]
422,"CWE-284 static void mntput_no_expire ( struct mount * mnt ) { rcu_read_lock ( ) ; mnt_add_count ( mnt , - 1 ) ; if ( likely ( mnt -> mnt_ns ) ) { rcu_read_unlock ( ) ; return ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } if ( unlikely ( mnt -> mnt . mnt_flags & MNT_DOOMED ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } mnt -> mnt . mnt_flags |= MNT_DOOMED ; rcu_read_unlock ( ) ; list_del ( & mnt -> mnt_instance ) ;  unlock_mount_hash ( ) ;  if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) { struct task_struct * task = current ; if ( likely ( ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & mnt -> mnt_rcu , __cleanup_mnt ) ; if ( ! task_work_add ( task , & mnt -> mnt_rcu , true ) ) return ; } if ( llist_add ( & mnt -> mnt_llist , & delayed_mntput_list ) ) schedule_delayed_work ( & delayed_mntput_work , 1 ) ; return ; } cleanup_mnt ( mnt ) ; }"," mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }"
423,"CWE-264 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * upayload , * zap ; size_t datalen = prep -> datalen ; int ret ; ret = - EINVAL ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) goto error ; ret = - ENOMEM ; upayload = kmalloc ( sizeof ( * upayload ) + datalen , GFP_KERNEL ) ; if ( ! upayload ) goto error ; upayload -> datalen = datalen ; memcpy ( upayload -> data , prep -> data , datalen ) ; zap = upayload ; ret = key_payload_reserve ( key , datalen ) ; if ( ret == 0 ) {  zap = key -> payload . data [ 0 ] ;   rcu_assign_keypointer ( key , upayload ) ;  key -> expiry = 0 ; } if ( zap ) kfree_rcu ( zap , rcu ) ; error : return ret ; }"," 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  0 ] ; else zap = NULL ;"
424,"CWE-415 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc )  return - EINVAL ;  if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }", return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
425,"CWE-617 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ;  if ( code == 0 || code == KRB5_PREAUTH_FAILED ) {  * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }", ; if ( ! code  || code ==  code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
426,"CWE-362 static int snd_ctl_elem_user_get ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { struct user_element * ue = kcontrol -> private_data ;  memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ;   return 0 ;  }", -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ;  elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
427,"CWE-264 int touch ( const char * path ) {  return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;  }"," , GID_INVALID , MODE_INVALID  ) ; }"
428,"CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ;  return SET_IVD_FATAL_ERROR ( e_error ) ;  } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }", = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error  ; } ps_dec
429,"CWE-20 static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ;  if ( ! offset ) {  return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , ""ModificationofArrayObjectduringsortingisprohibited"" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , ""Undefinedindex:%s"" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , ""Undefinedindex:%s"" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; case IS_NULL : key = """" ; len = 1 ; goto string_offest ; case IS_RESOURCE : zend_error ( E_STRICT , ""ResourceID#%ldusedasoffset,castingtointeger(%ld)"" , Z_LVAL_P ( offset ) , Z_LVAL_P ( offset ) ) ; case IS_DOUBLE : case IS_BOOL : case IS_LONG : if ( offset -> type == IS_DOUBLE ) { index = ( long ) Z_DVAL_P ( offset ) ; } else { index = Z_LVAL_P ( offset ) ; } if ( zend_hash_index_find ( ht , index , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , ""Undefinedoffset:%ld"" , index ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , ""Undefinedoffset:%ld"" , index ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_hash_index_update ( ht , index , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; default : zend_error ( E_WARNING , ""Illegaloffsettype"" ) ; return ( type == BP_VAR_W || type == BP_VAR_RW ) ? & EG ( error_zval_ptr ) : & EG ( uninitialized_zval_ptr ) ; } }", ( ! offset || ! ht
430,"CWE-772 generic_ret * create_principal_2_svc ( cprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ;  gss_buffer_desc client_name , service_name ;  OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_ADD ; log_unauth ( ""kadm5_create_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_create_principal ( ( void * ) handle , & arg -> rec , arg -> mask , arg -> passwd ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_create_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }"," ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER  ; OM_uint32 minor_stat  prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ;  free_server_handle ( handle"
431,"CWE-190 static PHP_NAMED_FUNCTION ( zif_zip_entry_read ) { zval * zip_entry ; zend_long len = 0 ; zip_read_rsrc * zr_rsrc ; zend_string * buffer ; int n = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""r|l"" , & zip_entry , & len ) == FAILURE ) { return ; } if ( ( zr_rsrc = ( zip_read_rsrc * ) zend_fetch_resource ( Z_RES_P ( zip_entry ) , le_zip_entry_name , le_zip_entry ) ) == NULL ) { RETURN_FALSE ; } if ( len <= 0 ) { len = 1024 ; } if ( zr_rsrc -> zf ) {  buffer = zend_string_alloc ( len , 0 ) ;  n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n > 0 ) { ZSTR_VAL ( buffer ) [ n ] = '\\0' ; ZSTR_LEN ( buffer ) = n ; RETURN_NEW_STR ( buffer ) ; } else { zend_string_free ( buffer ) ; RETURN_EMPTY_STRING ( ) } } else { RETURN_FALSE ; } }"," { buffer = zend_string_safe_alloc ( 1 , len , 0  , 0 )"
432,"CWE-19 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto out_free_orig ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto out_free_orig ; } sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , ""unabletosetblocksize"" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , ""unabletoreadsuperblock"" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , ""metadata_csumanduninit_bgare"" ""redundantflags;pleaserunfsck."" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , ""VFS:Foundext4filesystemwith"" ""unknownchecksumalgorithm."" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( ""crc32c"" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , ""Cannotloadcrc32cdriver."" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , ""VFS:Foundext4filesystemwith"" ""invalidsuperblockchecksum.Rune2fsck?"" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( ! parse_options ( ( char * ) sbi -> s_es -> s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , ""failedtoparseoptionsinsuperblock:%s"" , sbi -> s_es -> s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING ""EXT4-fs:Warning:mounting"" ""withdata=journaldisablesdelayed"" ""allocationandO_DIRECTsupport!\\n"" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""bothdata=journalanddelalloc"" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""bothdata=journalanddioread_nolock"" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""bothdata=journalanddax"" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , ""featureflagssetonrev0fs,"" ""runninge2fsckisrecommended"" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""TheHurdcan\'tsupport64-bitfilesystems"" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , ""mountingext2filesystem"" ""usingtheext4subsystem"" ) ; else { ext4_msg ( sb , KERN_ERR , ""couldn\'tmountasext2due"" ""tofeatureincompatibilities"" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , ""mountingext3filesystem"" ""usingtheext4subsystem"" ) ; else { ext4_msg ( sb , KERN_ERR , ""couldn\'tmountasext3due"" ""tofeatureincompatibilities"" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , ""Unsupportedfilesystemblocksize%d"" , blocksize ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { if ( blocksize != PAGE_SIZE ) { ext4_msg ( sb , KERN_ERR , ""error:unsupportedblocksizefordax"" ) ; goto failed_mount ; } if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { ext4_msg ( sb , KERN_ERR , ""error:devicedoesnotsupportdax"" ) ; goto failed_mount ; } } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , ""Unsupportedencryptionlevel%d"" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , ""badblocksize%d"" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , ""Can\'treadsuperblockon2ndtry"" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , ""Magicmismatch,veryweird!"" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , ""unsupportedinodesize:%d"" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , ""unsupporteddescriptorsize%lu"" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; if ( EXT4_INODE_SIZE ( sb ) == 0 || EXT4_INODES_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , ""clustersize(%d)smallerthan"" ""blocksize(%d)"" , clustersize , blocksize ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#clusterspergrouptoobig:%lu"" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , ""blockspergroup(%lu)and"" ""clusterspergroup(%lu)inconsistent"" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , ""fragment/clustersize(%d)!="" ""blocksize(%d)"" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#blockspergrouptoobig:%lu"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#inodespergrouptoobig:%lu"" , sbi -> s_inodes_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""filesystem"" ""toolargetomountsafelyonthissystem"" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , ""CONFIG_LBDAFnotenabled"" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , ""badgeometry:blockcount%llu"" ""exceedssizeofdevice(%llublocks)"" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , ""badgeometry:firstdata"" ""block%uisbeyondendoffilesystem(%llu)"" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , ""groupscounttoolarge:%u"" ""(blockcount%llu,firstdatablock%u,"" ""blockspergroup%lu)"" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / EXT4_DESC_PER_BLOCK ( sb ) ; sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , ""notenoughmemory"" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , ""can\'treadgroupdescriptor%d"" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , ""groupdescriptorscorrupted!"" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""requiredjournalrecovery"" ""suppressedandnotmountedread-only"" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""journal_checksum,fsmountedw/ojournal"" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""journal_async_commit,fsmountedw/ojournal"" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""commit=%lu,fsmountedw/ojournal"" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , ""can\'tmountwith"" ""data=,fsmountedw/ojournal"" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , ""Failedtoset64-bitjournalfeature"" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""Failedtosetjournalchecksum"" ""featureset"" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , ""Journaldoesnotsupport"" ""requesteddatajournalingmode"" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : if ( ext4_mballoc_ready ) {  sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ;  if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , ""Failedtocreateanmb_cache"" ) ; goto failed_mount_wq ; } } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_CACHE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Unsupportedblocksizeforfsencryption"" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( ""ext4-rsv-conversion"" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR ""EXT4-fs:failedtocreateworkqueue\\n"" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , ""getrootinodefailed"" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , ""corruptrootinode,rune2fsck"" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , ""getrootdentryfailed"" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , ""requiredextrainodespacenot"" ""available"" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""failedtoinitializesystem"" ""zone(%d)"" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""failedtoinitializemballoc(%d)"" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""insufficientmemory"" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""unabletoinitialize"" ""flex_bgmetainfo!"" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , ""recoverycomplete"" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = ""journalleddatamode"" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = ""ordereddatamode"" ; else descr = ""writebackdatamode"" ; } else descr = ""outjournal"" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , ""mountingwith\\""discard\\""option,but"" ""thedevicedoesnotsupportdiscard"" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , ""EXT4-fsmount"" ) ) ext4_msg ( sb , KERN_INFO , ""mountedfilesystemwith%s."" ""Opts:%s%s%s"" , descr , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? "";"" : """" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , ""VFS:Can\'tfindext4filesystem"" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , ""mountfailed"" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ;  failed_mount_wq :  if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; out_free_orig : kfree ( orig_data ) ; return err ? err : ret ; }", = ext4_xattr_create_cache (  ) ; if  ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }
433,"CWE-119 struct l2tp_packet_t * l2tp_packet_alloc ( int ver , int msg_type , const struct sockaddr_in * addr , int H , const char * secret , size_t secret_len ) { struct l2tp_packet_t * pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) return NULL ; memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ;  pack -> hdr . ver = ver ;  pack -> hdr . T = 1 ; pack -> hdr . L = 1 ; pack -> hdr . S = 1 ; memcpy ( & pack -> addr , addr , sizeof ( * addr ) ) ; pack -> hide_avps = H ; pack -> secret = secret ; pack -> secret_len = secret_len ; if ( msg_type ) { if ( l2tp_packet_add_int16 ( pack , Message_Type , msg_type , 1 ) ) { mempool_free ( pack ) ; return NULL ; } } return pack ; }", -> hdr . flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | ( ver & L2TP_VER_MASK )  ; memcpy (
434,"CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , ""earlyEOF"" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ;  error = 0 ;  if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , ""report-status:Errorreported:%s"" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , ""Incompletepackdatapkt-line"" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }", error = 0  ; switch (
435,"CWE-000 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_int32 now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ;  if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ;  if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;  if ( ( mask & ~ ALL_PRINC_MASK ) )   return KADM5_BAD_MASK ;  if ( entry == NULL ) return EINVAL ; ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = krb5_db_alloc ( handle -> context , NULL , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( kdb , 0 , sizeof ( * kdb ) ) ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = now + polent . pw_max_life ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }", ; if ( entry == NULL ) return EINVAL ; if (  KADM5_POLICY ) && entry -> policy == NULL  ) return KADM5_BAD_MASK  ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask &  ) return KADM5_BAD_MASK  ; ret =
436,"CWE-000 struct vfsmount * collect_mounts ( struct path * path ) { struct mount * tree ;  namespace_lock ( ) ;  tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ; namespace_unlock ( ) ; if ( IS_ERR ( tree ) ) return ERR_CAST ( tree ) ; return & tree -> mnt ; }", ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
437,"CWE-415 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc )  return - EINVAL ;  if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }", return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
438,"CWE-119 static Image * ReadFAXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> storage_class = PseudoClass ; if ( image -> columns == 0 ) image -> columns = 2592 ; if ( image -> rows == 0 ) image -> rows = 3508 ; image -> depth = 8 ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }  status = HuffmanDecodeImage ( image ) ;  if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status ="
439,"CWE-362 static int  mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size )  { hp_host_info_t __user * uarg = ( void __user * ) arg ;  MPT_ADAPTER * ioc ;  struct pci_dev * pdev ; char * pbuf = NULL ; dma_addr_t buf_dma ; hp_host_info_t karg ; CONFIGPARMS cfg ;  ConfigPageHeader_t hdr ;  int iocnum ; int rc , cim_rev ; ToolboxIstwiReadWriteRequest_t * IstwiRWRequest ; MPT_FRAME_HDR * mf = NULL ; unsigned long timeleft ; int retval ; u32 msgcontext ; if ( data_size == sizeof ( hp_host_info_t ) ) cim_rev = 1 ; else if ( data_size == sizeof ( hp_host_info_rev0_t ) ) cim_rev = 0 ; else return - EFAULT ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_host_info_t ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_hp_host_info-"" ""Unabletoreadinhp_host_infostruct@%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; }  if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_hp_hostinfo()@%d-ioc%dnotfound!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT "":mptctl_hp_hostinfocalled.\\n"" , ioc -> name ) ) ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg . vendor = pdev -> vendor ; karg . device = pdev -> device ; karg . subsystem_id = pdev -> subsystem_device ; karg . subsystem_vendor = pdev -> subsystem_vendor ; karg . devfn = pdev -> devfn ; karg . bus = pdev -> bus -> number ; if ( ioc -> sh != NULL ) karg . host_no = ioc -> sh -> host_no ; else karg . host_no = - 1 ; snprintf ( karg . fw_version , sizeof ( karg . fw_version ) , ""%.2hhu.%.2hhu.%.2hhu.%.2hhu"" , ioc -> facts . FWVersion . Struct . Major , ioc -> facts . FWVersion . Struct . Minor , ioc -> facts . FWVersion . Struct . Unit , ioc -> facts . FWVersion . Struct . Dev ) ; hdr . PageVersion = 0 ; hdr . PageLength = 0 ; hdr . PageNumber = 0 ; hdr . PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING ; cfg . cfghdr . hdr = & hdr ; cfg . physAddr = - 1 ; cfg . pageAddr = 0 ; cfg . action = MPI_CONFIG_ACTION_PAGE_HEADER ; cfg . dir = 0 ; cfg . timeout = 10 ; strncpy ( karg . serial_number , """" , 24 ) ; if ( mpt_config ( ioc , & cfg ) == 0 ) { if ( cfg . cfghdr . hdr -> PageLength > 0 ) { cfg . action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT ; pbuf = pci_alloc_consistent ( ioc -> pcidev , hdr . PageLength * 4 , & buf_dma ) ; if ( pbuf ) { cfg . physAddr = buf_dma ; if ( mpt_config ( ioc , & cfg ) == 0 ) { ManufacturingPage0_t * pdata = ( ManufacturingPage0_t * ) pbuf ; if ( strlen ( pdata -> BoardTracerNumber ) > 1 ) { strlcpy ( karg . serial_number , pdata -> BoardTracerNumber , 24 ) ; } } pci_free_consistent ( ioc -> pcidev , hdr . PageLength * 4 , pbuf , buf_dma ) ; pbuf = NULL ; } } } rc = mpt_GetIocState ( ioc , 1 ) ; switch ( rc ) { case MPI_IOC_STATE_OPERATIONAL : karg . ioc_status = HP_STATUS_OK ; break ; case MPI_IOC_STATE_FAULT : karg . ioc_status = HP_STATUS_FAILED ; break ; case MPI_IOC_STATE_RESET : case MPI_IOC_STATE_READY : default : karg . ioc_status = HP_STATUS_OTHER ; break ; } karg . base_io_addr = pci_resource_start ( pdev , 0 ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) karg . bus_phys_width = HP_BUS_WIDTH_UNK ; else karg . bus_phys_width = HP_BUS_WIDTH_16 ; karg . hard_resets = 0 ; karg . soft_resets = 0 ; karg . timeouts = 0 ; if ( ioc -> sh != NULL ) { MPT_SCSI_HOST * hd = shost_priv ( ioc -> sh ) ; if ( hd && ( cim_rev == 1 ) ) { karg . hard_resets = ioc -> hard_resets ; karg . soft_resets = ioc -> soft_resets ; karg . timeouts = ioc -> timeouts ; } } if ( ( mf = mpt_get_msg_frame ( mptctl_id , ioc ) ) == NULL ) { dfailprintk ( ioc , printk ( MYIOC_s_WARN_FMT ""%s,nomsgframes!!\\n"" , ioc -> name , __func__ ) ) ; goto out ; } IstwiRWRequest = ( ToolboxIstwiReadWriteRequest_t * ) mf ; msgcontext = IstwiRWRequest -> MsgContext ; memset ( IstwiRWRequest , 0 , sizeof ( ToolboxIstwiReadWriteRequest_t ) ) ; IstwiRWRequest -> MsgContext = msgcontext ; IstwiRWRequest -> Function = MPI_FUNCTION_TOOLBOX ; IstwiRWRequest -> Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL ; IstwiRWRequest -> Flags = MPI_TB_ISTWI_FLAGS_READ ; IstwiRWRequest -> NumAddressBytes = 0x01 ; IstwiRWRequest -> DataLength = cpu_to_le16 ( 0x04 ) ; if ( pdev -> devfn & 1 ) IstwiRWRequest -> DeviceAddr = 0xB2 ; else IstwiRWRequest -> DeviceAddr = 0xB0 ; pbuf = pci_alloc_consistent ( ioc -> pcidev , 4 , & buf_dma ) ; if ( ! pbuf ) goto out ; ioc -> add_sge ( ( char * ) & IstwiRWRequest -> SGL , ( MPT_SGE_FLAGS_SSIMPLE_READ | 4 ) , buf_dma ) ; retval = 0 ; SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , IstwiRWRequest -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( ioc -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , ioc , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & ioc -> ioctl_cmds . done , HZ * MPT_IOCTL_DEFAULT_TIMEOUT ) ; if ( ! ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { retval = - ETIME ; printk ( MYIOC_s_WARN_FMT ""%s:failed\\n"" , ioc -> name , __func__ ) ; if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( ioc , mf ) ; goto out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""HOSTINFOcommandtimeout,doorbell=0x%08x\\n"" , ioc -> name , mpt_GetIocState ( ioc , 0 ) ) ; mptctl_timeout_expired ( ioc , mf ) ; } else goto retry_wait ; goto out ; } if ( ioc -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) karg . rsvd = * ( u32 * ) pbuf ; out : CLEAR_MGMT_STATUS ( ioc -> ioctl_cmds . status ) SET_MGMT_MSG_CONTEXT ( ioc -> ioctl_cmds . msg_context , 0 ) ; if ( pbuf ) pci_free_consistent ( ioc -> pcidev , 4 , pbuf , buf_dma ) ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( hp_host_info_t ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_hpgethostinfo-"" ""Unabletowriteouthp_host_info@%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }"," int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc ,  ) arg ;  struct pci_dev *  ; ConfigPageHeader_t hdr  ; int rc  EFAULT ; }  dctlprintk ( ioc"
440,"CWE-20 asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ;  if ( COMPAT_USE_64BIT_TIME )  return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ;  if ( get_compat_timespec ( & ktspec , timeout ) )  return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ;  if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) )  datagrams = - EFAULT ; return datagrams ; }", ; if (  timeout == NULL  ; if ( compat_get_timespec  ( & ktspec  > 0 && compat_put_timespec  ( & ktspec
441,"CWE-125 static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , ""RSDS"" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( ""Warning:CannotreadPEdebuginfo\\n"" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , ""%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x"" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; rsds_hdr . free ( ( struct SCV_RSDS_HEADER * ) & rsds_hdr ) ; } else if ( strncmp ( ( const char * ) dbg_data , ""NB10"" , 4 ) == 0 ) {  SCV_NB10_HEADER nb10_hdr ;  init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( dbg_data , & nb10_hdr ) ; snprintf ( res -> guidstr , sizeof ( res -> guidstr ) ,  ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ;  strncpy ( res -> file_name , ( const char * )  nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ;  res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; nb10_hdr . free ( ( struct SCV_NB10_HEADER * ) & nb10_hdr ) ; } else { bprintf ( ""CodeViewsectionnotNB10orRSDS\\n"" ) ; return 0 ; } break ; default : return 0 ; } while ( i < 33 ) { res -> guidstr [ i ] = toupper ( ( int ) res -> guidstr [ i ] ) ; i ++ ; } return 1 ; }"," 0 ) { if ( dbg_data_len < 20 ) { eprintf ( ""TruncatedNB10entry,notenoughdatatoparse\\n"" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } }  ; init_cv_nb10_header (  age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) {  1 ) ; }"
442,"CWE-399 static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( ! nlh ) return - EMSGSIZE ; bpm = nlmsg_data ( nlh ) ;  bpm -> family = AF_BRIDGE ;  bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) goto cancel ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) goto end ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }"," nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;"
443,"CWE-400 asmlinkage void do_ade ( struct pt_regs * regs ) { unsigned int __user * pc ; mm_segment_t seg ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS ,  1 , 0 , regs , regs -> cp0_badvaddr ) ;  if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ; pc = ( unsigned int __user * ) exception_epc ( regs ) ; if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) goto sigbus ; if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) goto sigbus ; else if ( unaligned_action == UNALIGNED_ACTION_SHOW ) show_registers ( regs ) ; seg = get_fs ( ) ; if ( ! user_mode ( regs ) ) set_fs ( KERNEL_DS ) ; emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; set_fs ( seg ) ; return ; sigbus : die_if_kernel ( ""Kernelunalignedinstructionaccess"" , regs ) ; force_sig ( SIGBUS , current ) ; }"," PERF_COUNT_SW_ALIGNMENT_FAULTS , 1  , regs ,"
444,"CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""trailingnull.bson"" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""dollarquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , ""keyscannotbeginwith\\""$\\"":\\""$query\\"""" ) ; VALIDATE_TEST ( ""dotquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , ""keyscannotcontain\\"".\\"":\\""abc.def\\"""" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""overflow4.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""empty_key.bson"" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , ""emptykey"" ) ; VALIDATE_TEST ( ""test40.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test41.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test42.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test43.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test44.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test45.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test46.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test47.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test48.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test49.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test50.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corruptcode-with-scope"" ) ; VALIDATE_TEST ( ""test51.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corruptcode-with-scope"" ) ; VALIDATE_TEST ( ""test52.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test53.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test54.bson"" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ;  b = BCON_NEW ( ""my_dbref"" ,  ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keyscannotbeginwith\\""$\\"":\\""$id\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keyscannotbeginwith\\""$\\"":\\""$ref\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""extra"" , BCON_INT32 ( 2 ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""invalidkeywithinDBRefsubdocument:\\""extra\\"""" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }"," ""corruptBSON"" ) ; VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ;"
445,"CWE-119 static struct VP8D_COMP * create_decompressor ( VP8D_CONFIG * oxcf ) { VP8D_COMP * pbi = vpx_memalign ( 32 , sizeof ( VP8D_COMP ) ) ; if ( ! pbi ) return NULL ;  vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ;  if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ; remove_decompressor ( pbi ) ; return 0 ; } pbi -> common . error . setjmp = 1 ; vp8_create_common ( & pbi -> common ) ; pbi -> common . current_video_frame = 0 ; pbi -> ready_for_new_data = 1 ; vp8cx_init_de_quantizer ( pbi ) ; vp8_loop_filter_init ( & pbi -> common ) ; pbi -> common . error . setjmp = 0 ; # if CONFIG_ERROR_CONCEALMENT pbi -> ec_enabled = oxcf -> error_concealment ; pbi -> overlaps = NULL ; # else  pbi -> ec_enabled = 0 ;  # endif pbi -> ec_active = 0 ; pbi -> decoded_key_frame = 0 ; pbi -> independent_partitions = 0 ; vp8_setup_block_dptrs ( & pbi -> mb ) ; return pbi ; }"," return NULL ; memset  ( pbi ,  ; # else ( void ) oxcf ;"
446,"CWE-269 static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ;  if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {   copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ;  fs_logger ( ""clone/etc/skel/.zshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ;  if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {   copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ;  fs_logger ( ""clone/etc/skel/.cshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ;  if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {   copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ;  fs_logger ( ""clone/etc/skel/.bashrc"" ) ; } free ( fname ) ; } }"," ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:invalid%sfile\\n"" , fname ) ; exit ( 1 ) ; } if (  0 ) { copy_file_as_user  ( ""/etc/skel/.zshrc"" ,  ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:invalid%sfile\\n"" , fname ) ; exit ( 1 ) ; } if (  0 ) { copy_file_as_user  ( ""/etc/skel/.cshrc"" ,  ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:invalid%sfile\\n"" , fname ) ; exit ( 1 ) ; } if (  0 ) { copy_file_as_user  ( ""/etc/skel/.bashrc"" ,"
447,"CWE-59 rpmVerifyAttrs rpmfilesVerify ( rpmfiles fi , int ix , rpmVerifyAttrs omitMask ) { rpm_mode_t fmode = rpmfilesFMode ( fi , ix ) ; rpmfileAttrs fileAttrs = rpmfilesFFlags ( fi , ix ) ; rpmVerifyAttrs flags = rpmfilesVFlags ( fi , ix ) ; const char * fn = rpmfilesFN ( fi , ix ) ; struct stat sb ; rpmVerifyAttrs vfy = RPMVERIFY_NONE ; switch ( rpmfilesFState ( fi , ix ) ) { case RPMFILE_STATE_NETSHARED : case RPMFILE_STATE_NOTINSTALLED : goto exit ; break ; case RPMFILE_STATE_REPLACED : flags = RPMVERIFY_LSTATFAIL ; break ; case RPMFILE_STATE_WRONGCOLOR : flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV ) ; break ; case RPMFILE_STATE_NORMAL : case RPMFILE_STATE_MISSING : break ; } if ( fn == NULL || lstat ( fn , & sb ) != 0 ) { vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; }  if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) {  vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } if ( S_ISLNK ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_MODE ) ; else flags &= ~ ( RPMVERIFY_LINKTO ) ; if ( ! S_ISREG ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS ) ; if ( fileAttrs & RPMFILE_GHOST ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO ) ; flags &= ~ ( omitMask | RPMVERIFY_FAILURES ) ; if ( flags & RPMVERIFY_FILEDIGEST ) { const unsigned char * digest ; int algo ; size_t diglen ; if ( ( digest = rpmfilesFDigest ( fi , ix , & algo , & diglen ) ) ) { unsigned char fdigest [ diglen ] ; rpm_loff_t fsize ; if ( rpmDoDigest ( algo , fn , 0 , fdigest , & fsize ) ) { vfy |= ( RPMVERIFY_READFAIL | RPMVERIFY_FILEDIGEST ) ; } else { sb . st_size = fsize ; if ( memcmp ( fdigest , digest , diglen ) ) vfy |= RPMVERIFY_FILEDIGEST ; } } else { vfy |= RPMVERIFY_FILEDIGEST ; } } if ( flags & RPMVERIFY_LINKTO ) { char linkto [ 1024 + 1 ] ; int size = 0 ; if ( ( size = readlink ( fn , linkto , sizeof ( linkto ) - 1 ) ) == - 1 ) vfy |= ( RPMVERIFY_READLINKFAIL | RPMVERIFY_LINKTO ) ; else { const char * flink = rpmfilesFLink ( fi , ix ) ; linkto [ size ] = '\\0' ; if ( flink == NULL || ! rstreq ( linkto , flink ) ) vfy |= RPMVERIFY_LINKTO ; } } if ( flags & RPMVERIFY_FILESIZE ) { if ( sb . st_size != rpmfilesFSize ( fi , ix ) ) vfy |= RPMVERIFY_FILESIZE ; } if ( flags & RPMVERIFY_MODE ) { rpm_mode_t metamode = fmode ; rpm_mode_t filemode ; filemode = ( rpm_mode_t ) sb . st_mode ; if ( fileAttrs & RPMFILE_GHOST ) { metamode &= ~ 0xf000 ; filemode &= ~ 0xf000 ; } if ( metamode != filemode ) vfy |= RPMVERIFY_MODE ; # if WITH_ACL acl_t facl = acl_get_file ( fn , ACL_TYPE_ACCESS ) ; if ( facl ) { if ( acl_equiv_mode ( facl , NULL ) == 1 ) { vfy |= RPMVERIFY_MODE ; } acl_free ( facl ) ; } # endif } if ( flags & RPMVERIFY_RDEV ) { if ( S_ISCHR ( fmode ) != S_ISCHR ( sb . st_mode ) || S_ISBLK ( fmode ) != S_ISBLK ( sb . st_mode ) ) { vfy |= RPMVERIFY_RDEV ; } else if ( S_ISDEV ( fmode ) && S_ISDEV ( sb . st_mode ) ) { rpm_rdev_t st_rdev = ( sb . st_rdev & 0xffff ) ; rpm_rdev_t frdev = ( rpmfilesFRdev ( fi , ix ) & 0xffff ) ; if ( st_rdev != frdev ) vfy |= RPMVERIFY_RDEV ; } } # if WITH_CAP if ( flags & RPMVERIFY_CAPS ) { cap_t cap , fcap ; cap = cap_from_text ( rpmfilesFCaps ( fi , ix ) ) ; if ( ! cap ) { cap = cap_from_text ( ""="" ) ; } fcap = cap_get_file ( fn ) ; if ( ! fcap ) { fcap = cap_from_text ( ""="" ) ; } if ( cap_compare ( cap , fcap ) != 0 ) vfy |= RPMVERIFY_CAPS ; cap_free ( fcap ) ; cap_free ( cap ) ; } # endif if ( ( flags & RPMVERIFY_MTIME ) && ( sb . st_mtime != rpmfilesFMtime ( fi , ix ) ) ) { vfy |= RPMVERIFY_MTIME ; } if ( flags & RPMVERIFY_USER ) { const char * name = rpmugUname ( sb . st_uid ) ; const char * fuser = rpmfilesFUser ( fi , ix ) ; uid_t uid ; int namematch = 0 ; int idmatch = 0 ; if ( name && fuser ) namematch = rstreq ( name , fuser ) ; if ( fuser && rpmugUid ( fuser , & uid ) == 0 ) idmatch = ( uid == sb . st_uid ) ; if ( namematch != idmatch ) { rpmlog ( RPMLOG_WARNING , _ ( ""DuplicateusernameorUIDforuser%s\\n"" ) , fuser ) ; } if ( ! ( namematch || idmatch ) ) vfy |= RPMVERIFY_USER ; } if ( flags & RPMVERIFY_GROUP ) { const char * name = rpmugGname ( sb . st_gid ) ; const char * fgroup = rpmfilesFGroup ( fi , ix ) ; gid_t gid ; int namematch = 0 ; int idmatch = 0 ; if ( name && fgroup ) namematch = rstreq ( name , fgroup ) ; if ( fgroup && rpmugGid ( fgroup , & gid ) == 0 ) idmatch = ( gid == sb . st_gid ) ; if ( namematch != idmatch ) { rpmlog ( RPMLOG_WARNING , _ ( ""DuplicategroupnameorGIDforgroup%s\\n"" ) , fgroup ) ; } if ( ! ( namematch || idmatch ) ) vfy |= RPMVERIFY_GROUP ; } exit : return vfy ; }"," . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } }  } if ("
448,"CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) {  asdl_seq * body ;  if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromModule"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Modulefield\\""body\\""mustbealist,nota%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Modulefield\\""body\\""changedsizeduringiteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; }  * out = Module ( body , arena ) ;  if ( * out == NULL ) goto failed ; return 0 ; }  isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ;  if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) {  PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromInteractive"" ) ;  return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) {  PyErr_Format ( PyExc_TypeError , ""Interactivefield\\""body\\""mustbealist,nota%.200s"" , tmp -> ob_type -> tp_name ) ;  goto failed ; } len = PyList_GET_SIZE ( tmp ) ;  body = _Py_asdl_seq_new ( len , arena ) ;   if ( body == NULL ) goto failed ;  for ( i = 0 ; i < len ; i ++ ) {  stmt_ty val ;   res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;  if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) {  PyErr_SetString ( PyExc_RuntimeError , ""Interactivefield\\""body\\""changedsizeduringiteration"" ) ;  goto failed ; }  asdl_seq_SET ( body , i , val ) ;  } Py_CLEAR ( tmp ) ; }  * out = Interactive ( body , arena ) ;  if ( * out == NULL ) goto failed ; return 0 ; }  isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ;  if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) {  expr_ty body ;  if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) {  PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromExpression"" ) ;  return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromSuite"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) {  PyErr_Format ( PyExc_TypeError , ""Suitefield\\""body\\""mustbealist,nota%.200s"" , tmp -> ob_type -> tp_name ) ;  goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) {  PyErr_SetString ( PyExc_RuntimeError , ""Suitefield\\""body\\""changedsizeduringiteration"" ) ;  goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expectedsomesortofmod,butgot%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }"," asdl_seq * body ; asdl_seq * type_ignores  ) ; } if ( _PyObject_LookupAttrId  ( obj ,  ( obj , & PyId_type_ignores  , & tmp  ( PyExc_TypeError , ""requiredfield\\""type_ignores\\""missingfromModule""  ) ; return  ( PyExc_TypeError , ""Modulefield\\""type_ignores\\""mustbealist,nota%.200s""  , tmp ->  tmp ) ; type_ignores  = _Py_asdl_seq_new (  ; if ( type_ignores  == NULL )  ++ ) { type_ignore_ty  val ; res  ; res = obj2ast_type_ignore  ( PyList_GET_ITEM (  ( PyExc_RuntimeError , ""Modulefield\\""type_ignores\\""changedsizeduringiteration""  ) ; goto  } asdl_seq_SET ( type_ignores  , i ,  * out = Module ( body , type_ignores  , arena )  PyObject * ) Interactive_type  ) ; if  isinstance ) { asdl_seq *  body ; if  ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromInteractive""  ) ; return  ( PyExc_TypeError , ""Interactivefield\\""body\\""mustbealist,nota%.200s""  , tmp ->  ( PyExc_RuntimeError , ""Interactivefield\\""body\\""changedsizeduringiteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromExpression"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; if ( _PyObject_LookupAttrId ( obj , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""argtypes\\""missingfromFunctionType"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionTypefield\\""argtypes\\""mustbealist,nota%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Py_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionTypefield\\""argtypes\\""changedsizeduringiteration"" ) ; goto failed ; } asdl_seq_SET ( argtypes , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""returns\\""missingfromFunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromSuite"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suitefield\\""body\\""mustbealist,nota%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError ,"
449,"CWE-000 void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain ,  [ DISCE_PROBE ] = sas_probe_devices ,  [ DISCE_SUSPEND ] = sas_suspend_devices ,  [ DISCE_RESUME ] = sas_resume_devices ,  [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }"," sas_revalidate_domain , [  DISCE_SUSPEND ] =  ] = sas_resume_devices  , } ;"
450,"CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , ""CLIENT_ERRORbadcommandlineformat"" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; }  it = item_get ( key , nkey , c , DO_UPDATE ) ;  if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , ""SERVER_ERRORoutofmemorymakingCASsuffix"" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , ""VALUE"" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , ""VALUE"" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , "">%dsendingkey"" , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , ""%c"" , key [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , "">%dEND\\n"" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , ""END\\r\\n"" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , ""SERVER_ERRORoutofmemorywritinggetresponse"" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }"," } it = limited_get  ( key ,  nkey , c  ) ; if"
451,"CWE-362 static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) { long ret ; struct cros_ec_command u_cmd ; struct cros_ec_command * s_cmd ; if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) return - EFAULT ; if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) return - EINVAL ; s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ; if ( ! s_cmd ) return - ENOMEM ; if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { ret = - EFAULT ; goto exit ; }  s_cmd -> command += ec -> cmd_offset ;  ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; if ( ret < 0 ) goto exit ;  if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) )  ret = - EFAULT ; exit : kfree ( s_cmd ) ; return ret ; }", exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; }  s_cmd ) + s_cmd ->  insize ) )
452,"CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ;  proto = EXTRACT_16BITS ( & p [ 2 ] ) ;  if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , ""%s,ethertype%s(0x%04x),length%u:"" , tok2str ( chdlc_cast_values , ""0x%02x"" , p [ 0 ] ) , tok2str ( ethertype_values , ""Unknown"" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO :  if ( * ( p + 1 ) == 0x81 ||  * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""unknownCHDLCprotocol(0x%04x)"" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ;  } "," u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ;  : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if (  CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ;"
453,"CWE-264 static int userns_install ( struct nsproxy * nsproxy , void * ns ) { struct user_namespace * user_ns = ns ; struct cred * cred ; if ( user_ns == current_user_ns ( ) ) return - EINVAL ;  if ( atomic_read ( & current -> mm -> mm_users ) > 1 )  return - EINVAL ; if ( ! ns_capable ( user_ns , CAP_SYS_ADMIN ) ) return - EPERM ; cred = prepare_creds ( ) ; if ( ! cred ) return - ENOMEM ; put_user_ns ( cred -> user_ns ) ; set_cred_user_ns ( cred , get_user_ns ( user_ns ) ) ; return commit_creds ( cred ) ; }", mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
454,"CWE-476 int btrfs_scrub_dev ( struct btrfs_fs_info * fs_info , u64 devid , u64 start , u64 end , struct btrfs_scrub_progress * progress , int readonly , int is_dev_replace ) { struct scrub_ctx * sctx ; int ret ; struct btrfs_device * dev ; unsigned int nofs_flag ; if ( btrfs_fs_closing ( fs_info ) ) return - EINVAL ; if ( fs_info -> nodesize > BTRFS_STRIPE_LEN ) { btrfs_err ( fs_info , ""scrub:sizeassumptionnodesize<=BTRFS_STRIPE_LEN(%d<=%d)fails"" , fs_info -> nodesize , BTRFS_STRIPE_LEN ) ; return - EINVAL ; } if ( fs_info -> sectorsize != PAGE_SIZE ) { btrfs_err_rl ( fs_info , ""scrub:sizeassumptionsectorsize!=PAGE_SIZE(%d!=%lu)fails"" , fs_info -> sectorsize , PAGE_SIZE ) ; return - EINVAL ; } if ( fs_info -> nodesize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK || fs_info -> sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ) { btrfs_err ( fs_info , ""scrub:sizeassumptionnodesizeandsectorsize<=SCRUB_MAX_PAGES_PER_BLOCK(%d<=%d&&%d<=%d)fails"" , fs_info -> nodesize , SCRUB_MAX_PAGES_PER_BLOCK , fs_info -> sectorsize , SCRUB_MAX_PAGES_PER_BLOCK ) ; return - EINVAL ; } sctx = scrub_setup_ctx ( fs_info , is_dev_replace ) ; if ( IS_ERR ( sctx ) ) return PTR_ERR ( sctx ) ; mutex_lock ( & fs_info -> fs_devices -> device_list_mutex ) ;  dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ;  if ( ! dev || ( test_bit ( BTRFS_DEV_STATE_MISSING , & dev -> dev_state ) && ! is_dev_replace ) ) { mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = - ENODEV ; goto out_free_ctx ; } if ( ! is_dev_replace && ! readonly && ! test_bit ( BTRFS_DEV_STATE_WRITEABLE , & dev -> dev_state ) ) { mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; btrfs_err_in_rcu ( fs_info , ""scrub:device%sisnotwritable"" , rcu_str_deref ( dev -> name ) ) ; ret = - EROFS ; goto out_free_ctx ; } mutex_lock ( & fs_info -> scrub_lock ) ; if ( ! test_bit ( BTRFS_DEV_STATE_IN_FS_METADATA , & dev -> dev_state ) || test_bit ( BTRFS_DEV_STATE_REPLACE_TGT , & dev -> dev_state ) ) { mutex_unlock ( & fs_info -> scrub_lock ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = - EIO ; goto out_free_ctx ; } down_read ( & fs_info -> dev_replace . rwsem ) ; if ( dev -> scrub_ctx || ( ! is_dev_replace && btrfs_dev_replace_is_ongoing ( & fs_info -> dev_replace ) ) ) { up_read ( & fs_info -> dev_replace . rwsem ) ; mutex_unlock ( & fs_info -> scrub_lock ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = - EINPROGRESS ; goto out_free_ctx ; } up_read ( & fs_info -> dev_replace . rwsem ) ; ret = scrub_workers_get ( fs_info , is_dev_replace ) ; if ( ret ) { mutex_unlock ( & fs_info -> scrub_lock ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; goto out_free_ctx ; } sctx -> readonly = readonly ; dev -> scrub_ctx = sctx ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; __scrub_blocked_if_needed ( fs_info ) ; atomic_inc ( & fs_info -> scrubs_running ) ; mutex_unlock ( & fs_info -> scrub_lock ) ; nofs_flag = memalloc_nofs_save ( ) ; if ( ! is_dev_replace ) { mutex_lock ( & fs_info -> fs_devices -> device_list_mutex ) ; ret = scrub_supers ( sctx , dev ) ; mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex ) ; } if ( ! ret ) ret = scrub_enumerate_chunks ( sctx , dev , start , end ) ; memalloc_nofs_restore ( nofs_flag ) ; wait_event ( sctx -> list_wait , atomic_read ( & sctx -> bios_in_flight ) == 0 ) ; atomic_dec ( & fs_info -> scrubs_running ) ; wake_up ( & fs_info -> scrub_pause_wait ) ; wait_event ( sctx -> list_wait , atomic_read ( & sctx -> workers_pending ) == 0 ) ; if ( progress ) memcpy ( progress , & sctx -> stat , sizeof ( * progress ) ) ; mutex_lock ( & fs_info -> scrub_lock ) ; dev -> scrub_ctx = NULL ; scrub_workers_put ( fs_info ) ; mutex_unlock ( & fs_info -> scrub_lock ) ; scrub_put_ctx ( sctx ) ; return ret ; out_free_ctx : scrub_free_ctx ( sctx ) ; return ret ; }"," NULL , NULL , true"
455,"CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ;  for ( i = 0 ; i < len ; i ++ ) {  if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) {  szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;  j ++ ; szLine [ i ] &= 0xbf ; }  else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {   szLineConv [ j ] = szLine [ i ] ;  i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) {  szLineConv [ j ] = szLine [ i ] ;  i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) {  szLineConv [ j ] = szLine [ i ] ;  i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } }  szLineConv [ j ] = szLine [ i ] ;  j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }"," i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j  ++ ) {  0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) {  ; } else break ; } else  0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; }  } else if  0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; }  } else if  0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; }  } else {  ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else  szLineConv [ j"
456,"CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ;  if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen )  return - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; return 0 ; }", ) != ulen || replay_esn -> bmp_len != up -> bmp_len
457,"CWE-119 int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;  strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= USECS_PER_SEC ) return - 1 ; # else if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= 1 ) return - 1 ; # endif return 0 ; }", char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ]  = '\\0' ;
458,"CWE-399  int sctp_verify_asconf ( const struct sctp_association * asoc ,   struct sctp_paramhdr * param_hdr , void * chunk_end ,  struct sctp_paramhdr * * errp ) {  sctp_addip_param_t * asconf_param ;  union sctp_params param ;  int length , plen ;   param . v = ( sctp_paramhdr_t * ) param_hdr ;  while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }","    bool  sctp_verify_asconf ( const  asoc , struct sctp_chunk * chunk , bool addr_param_needed  , struct sctp_paramhdr  errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr  ; union sctp_params  sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if (  param . v  param . v != chunk -> chunk_end ) return false ; return true  ; } "
459,"CWE-362 hsm_com_errno_t unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ;  if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 )  { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) {  close ( fd ) ;  return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , ""%s"" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) {  unlink ( hdl -> c_path ) ;  close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) {  unlink ( hdl -> c_path ) ;  close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) {  unlink ( hdl -> c_path ) ;  close ( fd ) ; return HSM_COM_CONX_ERR ; } hdl -> client_fd = fd ; hdl -> client_state = HSM_COM_C_STATE_CT ; if ( unix_sck_send_conn ( hdl , 2 ) != HSM_COM_OK ) { hdl -> client_state = HSM_COM_C_STATE_IN ;  return HSM_COM_SEND_ERR ;  } return HSM_COM_OK ; }", sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ;  ) ) { res = HSM_COM_PATH_ERR ; goto cleanup  ; } snprintf  0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ;  } if (  0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup  ; } memset  0 ) { res = HSM_COM_CONX_ERR ; goto cleanup  ; } hdl  = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res  ; } 
460,"CWE-000 int luaG_traceexec ( lua_State * L , const Instruction * pc ) { CallInfo * ci = L -> ci ; lu_byte mask = L -> hookmask ;  int counthook ;  if ( ! ( mask & ( LUA_MASKLINE | LUA_MASKCOUNT ) ) ) { ci -> u . l . trap = 0 ; return 0 ; } pc ++ ; ci -> u . l . savedpc = pc ; counthook = ( -- L -> hookcount == 0 && ( mask & LUA_MASKCOUNT ) ) ; if ( counthook ) resethookcount ( L ) ; else if ( ! ( mask & LUA_MASKLINE ) ) return 1 ; if ( ci -> callstatus & CIST_HOOKYIELD ) { ci -> callstatus &= ~ CIST_HOOKYIELD ; return 1 ; } if ( ! isIT ( * ( ci -> u . l . savedpc - 1 ) ) ) L -> top = ci -> top ; if ( counthook ) luaD_hook ( L , LUA_HOOKCOUNT , - 1 , 0 , 0 ) ; if ( mask & LUA_MASKLINE ) {  const Proto * p = ci_func ( ci ) -> p ;  int npci = pcRel ( pc , p ) ; if ( npci == 0 ||  pc <= L -> oldpc ||   changedline ( p , pcRel ( L -> oldpc , p ) , npci ) ) {  int newline = luaG_getfuncline ( p , npci ) ; luaD_hook ( L , LUA_HOOKLINE , newline , 0 , 0 ) ; }  L -> oldpc = pc ;  } if ( L -> status == LUA_YIELD ) { if ( counthook ) L -> hookcount = 1 ; ci -> u . l . savedpc -- ; ci -> callstatus |= CIST_HOOKYIELD ; luaD_throw ( L , LUA_YIELD ) ; } return 1 ; }"," -> hookmask ; const Proto * p = ci_func ( ci ) -> p ; int counthook ; int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0  ; if (  LUA_MASKLINE ) {  int npci =  || pc <= invpcRel ( oldpc , p )  || changedline (  ( p , oldpc  , npci )  -> oldpc = npci  ; } if"
461,"CWE-400  static void sample_hbp_handler ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) { printk ( KERN_INFO ""%svalueischanged\\n"" , ksym_name ) ; dump_stack ( ) ; printk ( KERN_INFO ""Dumpstackfromsample_hbp_handler\\n"" ) ; }"," perf_event * bp  , struct perf_sample_data"
462,"CWE-416 static void test_modules ( ) { assert_true_rule (  ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.one+1==tests.constants.two\\\n}"" ,  NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.foo==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.empty==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.empty()==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[1].i==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[0].i==1ortrue\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[0]==0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[1]==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[0]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[2]==\\""baz\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""foo\\""]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""bar\\""]==\\""bar\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2)==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2,3)==6\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0)==3.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0,3.0)==6.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.length(\\""dummy\\"")==5\\\n}"" , NULL ) ; assert_false_rule (  ""import\\""tests\\""\\\nruletest{condition:tests.struct_array[0].i==1\\\n}"" ,  NULL ) ; assert_false_rule (  ""import\\""tests\\""\\\nruletest{condition:tests.isum(1,1)==3\\\n}"" ,  NULL ) ; assert_false_rule (  ""import\\""tests\\""\\\nruletest{condition:tests.fsum(1.0,1.0)==3.0\\\n}"" ,  NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""foo\\"")==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""bar\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")==7\\\n}"" , NULL ) ; assert_error ( ""import\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }"," { assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.one+1==tests.constants.two\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.foo==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.empty==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.empty()==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[1].i==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[0].i==1ortrue\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[0]==0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[1]==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[0]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[2]==\\""baz\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""foo\\""]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""bar\\""]==\\""bar\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2)==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.isum(1,2,3)==6\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0)==3.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.fsum(1.0,2.0,3.0)==6.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.foobar(1)==tests.foobar(1)\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.foobar(1)!=tests.foobar(2)\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.length(\\""dummy\\"")==5\\\n}""  , NULL )  ; assert_false_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.struct_array[0].i==1\\\n}""  , NULL )  ; assert_false_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.isum(1,1)==3\\\n}""  , NULL )  ; assert_false_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.fsum(1.0,1.0)==3.0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""foo\\"")==3\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo/,\\""bar\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")==-1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{condition:tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")==7\\\n}""  , NULL )"
463,"CWE-400 static int misaligned_fpu_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; }  perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;  srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } switch ( width_shift ) { case 2 : buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; break ; case 3 : if ( do_paired_load ) { buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # else buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # endif } break ; default : printk ( ""Unexpectedwidth_shift%dinmisaligned_fpu_store,PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } * ( __u32 * ) & buffer = buflo ; * ( 1 + ( __u32 * ) & buffer ) = bufhi ; if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } return 0 ; } else { die ( ""MisalignedFPUloadinsidekernel"" , regs , 0 ) ; return - 1 ; } }"," , 1 ,  regs , address"
464,"CWE-119 static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ;  u64 start = offset >> PAGE_CACHE_SHIFT ;  unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;  u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;  pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {   i_size_write ( inode , offset + to ) ;  } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += PAGE_CACHE_SIZE ; from = 0 ; }  mark_inode_dirty ( inode ) ;  brelse ( dibh ) ; out :  return error ;  }"," int error ; unsigned int nr_blks ; sector_t lblock  = offset >>  = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if  ( offset +  offset + len  > inode ->  FALLOC_FL_KEEP_SIZE ) )  i_size_write ( inode  , offset + len ) ;  mark_inode_dirty ( inode  mark_inode_dirty ( inode  ) ; out  ; out : brelse ( dibh ) ;"
465,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ;  memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;  offset += tim . length - 3 ;  length -= tim . length - 3 ;  if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)unhandledelement_id(%d)"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }"," , p + offset + 3 ,  tim . length  - 3 ) ; offset +=  tim . length  length - 3 ; length -=  tim . length  - 3 ;  if ( !"
466,"CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD"" , 4 ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%sisnotavalid.DFFfile(bytotalsize)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""fileheaderindicatedlength=%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunkheaderindicatedlength=%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdifffileversion=0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""gotPROPchunkof%dbytestotal"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""gotsamplerateof%uHz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefinedchannelID%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%dchannels,mask=0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD"" , 4 ) ) { error_line ( ""DSDIFFfilesmustbeuncompressed,not\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""gotPROP/SNDchunktype\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisDSDIFFfilealreadyhaschannelorderinformation!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""gotunknownPROPchunktype\\""%c%c%c%c\\""of%dbytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ;  char * buff = malloc ( bytes_to_copy ) ;  if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""settingconfigurationwith%lldsamples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }"," char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff"
467,"CWE-000 struct vfsmount * collect_mounts ( struct path * path ) { struct mount * tree ;  namespace_lock ( ) ;  tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ; namespace_unlock ( ) ; if ( IS_ERR ( tree ) ) return ERR_CAST ( tree ) ; return & tree -> mnt ; }", ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
468,"CWE-416 static void exif_mnote_data_olympus_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataOlympus * n = ( ExifMnoteDataOlympus * ) en ; ExifShort c ; size_t i , tcount , o , o2 , datao = 6 , base = 0 ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataOlympus"" , ""ShortMakerNote"" ) ; return ; } o2 = 6 + n -> offset ; if ( CHECKOVERFLOW ( o2 , buf_size , 10 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataOlympus"" , ""ShortMakerNote"" ) ; return ; } n -> version = exif_mnote_data_olympus_identify_variant ( buf + o2 , buf_size - o2 ) ; switch ( n -> version ) { case olympusV1 : case sanyoV1 : case epsonV1 : exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""ParsingOlympus/Sanyo/Epsonmakernotev1..."" ) ; if ( buf [ o2 + 6 ] == 1 ) n -> order = EXIF_BYTE_ORDER_INTEL ; else if ( buf [ o2 + 6 + 1 ] == 1 ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ; o2 += 8 ; c = exif_get_short ( buf + o2 , n -> order ) ; if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) { if ( n -> order == EXIF_BYTE_ORDER_INTEL ) { n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> order = EXIF_BYTE_ORDER_INTEL ; } } break ; case olympusV2 : datao = o2 ; o2 += 8 ; if ( CHECKOVERFLOW ( o2 , buf_size , 4 ) ) return ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""ParsingOlympusmakernotev2(0x%02x,%02x,%02x,%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] ) ; if ( ( buf [ o2 ] == 'I' ) && ( buf [ o2 + 1 ] == 'I' ) ) n -> order = EXIF_BYTE_ORDER_INTEL ; else if ( ( buf [ o2 ] == 'M' ) && ( buf [ o2 + 1 ] == 'M' ) ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ; o2 += 4 ; break ; case nikonV1 : o2 += 6 ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""ParsingNikonmakernotev1(0x%02x,%02x,%02x,"" ""%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] ) ; o2 += 1 ; o2 += 1 ; base = MNOTE_NIKON1_TAG_BASE ; c = exif_get_short ( buf + o2 , n -> order ) ; if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) { if ( n -> order == EXIF_BYTE_ORDER_INTEL ) { n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> order = EXIF_BYTE_ORDER_INTEL ; } } break ; case nikonV2 : o2 += 6 ; if ( CHECKOVERFLOW ( o2 , buf_size , 12 ) ) return ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""ParsingNikonmakernotev2(0x%02x,%02x,%02x,"" ""%02x,%02x,%02x,%02x,%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] , buf [ o2 + 4 ] , buf [ o2 + 5 ] , buf [ o2 + 6 ] , buf [ o2 + 7 ] ) ; o2 += 1 ; o2 += 1 ; o2 += 2 ; datao = o2 ; if ( ! strncmp ( ( char * ) & buf [ o2 ] , ""II"" , 2 ) ) n -> order = EXIF_BYTE_ORDER_INTEL ; else if ( ! strncmp ( ( char * ) & buf [ o2 ] , ""MM"" , 2 ) ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ; else { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Unknown"" ""byteorder\'%c%c\'"" , buf [ o2 ] , buf [ o2 + 1 ] ) ; return ; } o2 += 2 ; o2 += 2 ; o2 = datao + exif_get_long ( buf + o2 , n -> order ) ; break ; case nikonV0 : exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""ParsingNikonmakernotev0(0x%02x,%02x,%02x,"" ""%02x,%02x,%02x,%02x,%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] , buf [ o2 + 4 ] , buf [ o2 + 5 ] , buf [ o2 + 6 ] , buf [ o2 + 7 ] ) ; n -> order = EXIF_BYTE_ORDER_MOTOROLA ; break ; default : exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""UnknownOlympusvariant%i."" , n -> version ) ; return ; } if ( CHECKOVERFLOW ( o2 , buf_size , 2 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""ShortMakerNote"" ) ; return ; } c = exif_get_short ( buf + o2 , n -> order ) ; o2 += 2 ; exif_mnote_data_olympus_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteOlympusEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteOlympus"" , sizeof ( MnoteOlympusEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = o2 ; i ; -- i , o += 12 ) { size_t s ;  if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""ShortMakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Loadingentry0x%x(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Tagsizeoverflowdetected(%u*%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) { dataofs = exif_get_long ( buf + dataofs , n -> order ) + datao ; # ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG if ( dataofs > ( buf_size - s ) && n -> version == sanyoV1 ) { dataofs -= datao + 6 ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Inconsistentthumbnailtagoffset;attemptingtorecover"" ) ; } # endif } if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Tagdatapastendofbuffer(%u>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteOlympus"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }"," size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteOlympusEntry ) ) ;"
469,"CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) {  struct desc_struct * desc ;  unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ;  desc = get_desc ( sel ) ;   if ( ! desc )  return 0 ;  limit = get_desc_limit ( desc ) ;   if ( desc -> g )  limit = ( limit << 12 ) + 0xfff ; return limit ; }"," { struct desc_struct  desc ; unsigned  return 0 ;  if ( !  if ( ! get_desc ( & desc , sel )  ) return 0  = get_desc_limit ( &  if ( desc .  g ) limit"
470,"CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ;  struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;  ea_idebug ( inode , ""buffer=%p,buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""readingblock%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , ""badblock%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }", error ; struct mb2_cache  * ext4_mb_cache =
471,"CWE-119 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfor"" ""t2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""NosupportforOJPEGimage%swithbadtables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""NosupportforOJPEGimage%swithnoJPEGFileInterchangeoffset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%ubytesofmemoryfort2p_readwrite_pdf_image,%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer ,  & bufferoffset ,  i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tprocessJPEGdataininputfile%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Errorondecodingstrip%uof%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Errorondecodingstrip%uof%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Errorondecodingstrip%uof%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfort2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tuseTIFFReadRGBAImageOrientedtoextractRGBimagefrom%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""UnabletouseJPEGcompressionforinput%sandoutput%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""ErrorwritingencodedstriptooutputPDF%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }"," , buffer , t2p -> tiff_datasize ,"
472,"CWE-476 void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) {  if ( rows > 1 ) {  pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }", { if ( l == NULL ) break ; if (
473,"CWE-119  static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) {  vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 )  vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ;  if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) {  tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ;  for ( j = 0 ; j < TX_SIZES - 3 ; j ++ )  vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ;  } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) {  tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ;  for ( j = 0 ; j < TX_SIZES - 2 ; j ++ )  vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] ,  ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) {  tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ;  for ( j = 0 ; j < TX_SIZES - 1 ; j ++ )  vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] ,  ct_32x32p [ j ] ) ; } } }"," * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal  ( w ,  >= ALLOW_32X32 ) vpx_write_bit  ( w ,  { tx_counts_to_branch_counts_8x8 ( counts ->  tx . p8x8  cm -> fc ->  tx_probs . p8x8  { tx_counts_to_branch_counts_16x16 ( counts ->  tx . p16x16  cm -> fc ->  tx_probs . p16x16  { tx_counts_to_branch_counts_32x32 ( counts ->  tx . p32x32  cm -> fc ->  tx_probs . p32x32"
474,"CWE-362 static int netlink_dump ( struct sock * sk ) { struct netlink_sock * nlk = nlk_sk ( sk ) ; struct netlink_callback * cb ; struct sk_buff * skb = NULL ; struct nlmsghdr * nlh ;  int len , err = - ENOBUFS ;  int alloc_min_size ; int alloc_size ; mutex_lock ( nlk -> cb_mutex ) ; if ( ! nlk -> cb_running ) { err = - EINVAL ; goto errout_skb ; } if ( atomic_read ( & sk -> sk_rmem_alloc ) >= sk -> sk_rcvbuf ) goto errout_skb ; cb = & nlk -> cb ; alloc_min_size = max_t ( int , cb -> min_dump_alloc , NLMSG_GOODSIZE ) ; if ( alloc_min_size < nlk -> max_recvmsg_len ) { alloc_size = nlk -> max_recvmsg_len ; skb = alloc_skb ( alloc_size , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; } if ( ! skb ) { alloc_size = alloc_min_size ; skb = alloc_skb ( alloc_size , GFP_KERNEL ) ; } if ( ! skb ) goto errout_skb ; skb_reserve ( skb , skb_tailroom ( skb ) - alloc_size ) ; netlink_skb_set_owner_r ( skb , sk ) ; len = cb -> dump ( skb , cb ) ; if ( len > 0 ) { mutex_unlock ( nlk -> cb_mutex ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; return 0 ; } nlh = nlmsg_put_answer ( skb , cb , NLMSG_DONE , sizeof ( len ) , NLM_F_MULTI ) ; if ( ! nlh ) goto errout_skb ; nl_dump_check_consistent ( cb , nlh ) ; memcpy ( nlmsg_data ( nlh ) , & len , sizeof ( len ) ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; if ( cb -> done ) cb -> done ( cb ) ; nlk -> cb_running = false ;  mutex_unlock ( nlk -> cb_mutex ) ;   module_put ( cb -> module ) ;   consume_skb ( cb -> skb ) ;  return 0 ; errout_skb : mutex_unlock ( nlk -> cb_mutex ) ; kfree_skb ( skb ) ; return err ; }", * nlh ; struct module * module ;  = false ; module = cb -> module ; skb = cb -> skb ;  ; module_put (  module ) ;  ; consume_skb (  skb ) ;
475,"CWE-000 long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ;  assert ( n >= 0 && n < 32 ) ;  v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }", int u ; if ( n < 0 || n >= 32 ) { return - 1 ; }  v = 0
476,"CWE-772 generic_ret * chpass_principal_2_svc ( chpass_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ;  gss_buffer_desc client_name ,  service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal ( ( void * ) handle , arg -> princ , arg -> pass ) ; } else { log_unauth ( ""kadm5_chpass_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_chpass_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ;  gss_release_buffer ( & minor_stat , & client_name ) ;  gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }"," ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER  ; OM_uint32 minor_stat  prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ;  free_server_handle ( handle"
477,"CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ;  DEFINE_WAKE_Q ( wake_q ) ;  if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }", ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
478,"CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ;  if ( n <= 0 ) return ( n ) ;  if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && * p == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }", if ( n  != i )
479,"CWE-119 bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":%d,\\""method\\"":\\""mining.subscribe\\"",\\""params\\"":[\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":%d,\\""method\\"":\\""mining.subscribe\\"",\\""params\\"":[]}"" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , ""Failedtosendsininitiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , ""Timedoutwaitingforresponseininitiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSONdecodefailed(%d):%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknownreason)"" ) ; applog ( LOG_INFO , ""JSON-RPCdecodefailed:%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , ""Failedtogetsessionidininitiate_stratum"" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failedtogetnonce1ininitiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ;  if ( ! n2size ) {  applog ( LOG_INFO , ""Failedtogetn2sizeininitiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Pool%dstratumsessionid:%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool%dconfirmedmining.subscribewithextranonce1%sextran2size%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , ""Failedtoresumestratum,tryingafresh"" ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiatestratumfailed"" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }", ; if ( n2size < 1 )  { applog (
480,"CWE-354 void recovery_cipher_init ( bool passphrase_protection , bool pin_protection , const char * language , const char * label , bool _enforce_wordlist , uint32_t _auto_lock_delay_ms , uint32_t _u2f_counter , bool _dry_run ) { enforce_wordlist = _enforce_wordlist ; dry_run = _dry_run ; if ( ! dry_run ) { if ( pin_protection ) { if ( ! change_pin ( ) ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_ActionCancelled , ""PINsdonotmatch"" ) ; layoutHome ( ) ; return ; } } else { storage_setPin ( """" ) ; } storage_setPassphraseProtected ( passphrase_protection ) ; storage_setLanguage ( language ) ; storage_setLabel ( label ) ; storage_setAutoLockDelayMs ( _auto_lock_delay_ms ) ; storage_setU2FCounter ( _u2f_counter ) ; } else if ( ! pin_protect ( ""EnterYourPIN"" ) ) { layoutHome ( ) ; return ; } if ( ! confirm ( ButtonRequestType_ButtonRequest_Other , dry_run ? ""RecoveryDryRun"" : ""Recovery"" , ""Whenenteringyourrecoveryseed,usethesubstitutioncipher"" ""andcheckthateachwordshowsupcorrectlyonthescreen."" ) ) { fsm_sendFailure ( FailureType_Failure_ActionCancelled , ""Recoverycancelled"" ) ; if ( ! dry_run ) storage_reset ( ) ; layoutHome ( ) ; return ; } memset ( mnemonic , 0 , sizeof ( mnemonic ) / sizeof ( char ) ) ; awaiting_character = true ;  next_character ( ) ;  }", = true ; recovery_started = true ;
481,"CWE-264 static int kvm_iommu_unmap_memslots ( struct kvm * kvm ) { int idx ; struct kvm_memslots * slots ; struct kvm_memory_slot * memslot ; idx = srcu_read_lock ( & kvm -> srcu ) ; slots = kvm_memslots ( kvm ) ; kvm_for_each_memslot ( memslot , slots )  kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ;  srcu_read_unlock ( & kvm -> srcu , idx ) ; return 0 ; }"," , slots ) kvm_iommu_unmap_pages  ( kvm ,  kvm , memslot  ) ; srcu_read_unlock"
482,"CWE-476 INTERNAL void vterm_allocator_free ( VTerm * vt , void * ptr )  {  ( * vt -> allocator -> free ) ( ptr , vt -> allocdata ) ; }", ptr ) { if ( ptr )
483,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { GradFunContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int p , direct ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { direct = 0 ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; }  for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) {  int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ; if ( p ) { w = s -> chroma_w ; h = s -> chroma_h ; r = s -> chroma_r ; } if ( FFMIN ( w , h ) > 2 * r ) filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; else if ( out -> data [ p ] != in -> data [ p ] ) av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in -> data [ p ] , in -> linesize [ p ] , w , h ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }", [ p ] && in -> linesize [ p ]
484,"CWE-426 static void usage ( void ) { fprintf ( stderr , ""usage:ssh-agent[-c|-s][-Dd][-abind_address][-Efingerprint_hash]\\n""  ""[-tlife][command[arg...]]\\n""  ""ssh-agent[-c|-s]-k\\n"" ) ; exit ( 1 ) ; }"," stderr , ""usage:ssh-agent[-c|-s][-Dd][-abind_address][-Efingerprint_hash]\\n"" ""[-Ppkcs11_whitelist][-tlife][command[arg...]]\\n""  ""ssh-agent[-c|-s]-k\\n"" ) ;"
485,"CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ;  msg -> msg_namelen = 0 ;  lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }", |= MSG_TRUNC ;  lock_sock ( sk
486,"CWE-200 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ;  strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;  if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }", crypto_report_comp rcomp ; strncpy  ( rcomp .
487,"CWE-190 static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) {  u_int16_t offset = 22 , buf_out_len = 0 ;  if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  offset += 4 + len ;  if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  if ( client_hash ) {   offset += 4 ;  if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ;  offset += len ;  } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  if ( ! client_hash ) {   offset += 4 ;  if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ;  offset += len ;  } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  if ( client_hash ) {   offset += 4 ;  if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ;  offset += len ;  } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  if ( ! client_hash ) {   offset += 4 ;  if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ;  offset += len ;  } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  if ( client_hash ) {   offset += 4 ;  if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ;  offset += len ;  } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;  if ( ! client_hash ) {   offset += 4 ;  if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ;  offset += len ;  } else offset += 4 + len ; # ifdef SSH_DEBUG printf ( ""[SSH]%s\\n"" , buf ) ; # endif return ( buf_out_len ) ; invalid_payload : # ifdef SSH_DEBUG printf ( ""[SSH]Invalidpacketpayload\\n"" ) ; # endif return ( 0 ) ; }", client_hash ) { u_int32_t  offset = 22  ] ) ; if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ;  ] ) ; offset += 4 ;  client_hash ) {  if ( (  = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset +=  len ; if  ] ) ; offset += 4 ;  client_hash ) {  if ( (  = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset +=  len ; if  ] ) ; offset += 4 ;  client_hash ) {  if ( (  = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset +=  len ; if  ] ) ; offset += 4 ;  client_hash ) {  if ( (  = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset +=  len ; if  ] ) ; offset += 4 ;  client_hash ) {  if ( (  += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset +=  len ; if  ] ) ; offset += 4 ;  client_hash ) {  if ( (  += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset +=  len ; #
488,"CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ;  pipe_buf_get ( ipipe , ibuf ) ;  obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }"," 1 ) ; if ( !  , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; }  obuf = opipe"
489,"CWE-362 static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) {  struct snd_timer_user * tu ;  void __user * argp = ( void __user * ) arg ; int __user * p = argp ; tu = file -> private_data ;  switch ( cmd ) {  case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ; case SNDRV_TIMER_IOCTL_NEXT_DEVICE : return snd_timer_user_next_device ( argp ) ; case SNDRV_TIMER_IOCTL_TREAD : { int xarg ;  mutex_lock ( & tu -> tread_sem ) ;  if ( tu -> timeri ) { mutex_unlock ( & tu -> tread_sem ) ; return - EBUSY ; } if ( get_user ( xarg , p ) ) { mutex_unlock ( & tu -> tread_sem ) ; return - EFAULT ; } tu -> tread = xarg ? 1 : 0 ;  mutex_unlock ( & tu -> tread_sem ) ;   return 0 ;  } case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ; case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ; case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ; case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ; case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ; case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ; case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ; case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ; case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop ( file ) ; case SNDRV_TIMER_IOCTL_CONTINUE : case SNDRV_TIMER_IOCTL_CONTINUE_OLD : return snd_timer_user_continue ( file ) ; case SNDRV_TIMER_IOCTL_PAUSE : case SNDRV_TIMER_IOCTL_PAUSE_OLD : return snd_timer_user_pause ( file ) ; } return - ENOTTY ; }"," snd_timer_user * tu  = file ->  -> private_data ; long ret  ; mutex_lock (  & tu -> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg )  ; mutex_unlock (  & tu -> ioctl_lock  ) ; return  ) ; return ret  ; } "
490,"CWE-362 static int get_task_ioprio ( struct task_struct * p ) { int ret ; ret = security_task_getioprio ( p ) ; if ( ret ) goto out ; ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ;  if ( p -> io_context )  ret = p -> io_context -> ioprio ;  out :  return ret ; }", IOPRIO_NORM ) ; task_lock ( p ) ;  -> ioprio ; task_unlock ( p ) ;
491,"CWE-416 void fe_netjoin_init ( void ) { settings_add_bool ( ""misc"" , ""hide_netsplit_quits"" , TRUE ) ; settings_add_int ( ""misc"" , ""netjoin_max_nicks"" , 10 ) ; join_tag = - 1 ; printing_joins = FALSE ; read_settings ( ) ; signal_add ( ""setupchanged"" , ( SIGNAL_FUNC ) read_settings ) ;  } "," read_settings ) ; signal_add ( ""serverdisconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;"
492,"CWE-119 void vp8_bilinear_predict4x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 ; uint8x8_t d26u8 , d27u8 , d28u8 , d29u8 , d30u8 ;  uint32x2_t d28u32 , d29u32 , d30u32 ;  uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 0 ) ; src_ptr += src_pixels_per_line ; d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 1 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 0 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 1 ) ; src_ptr += src_pixels_per_line ; d30u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d30u32 , 0 ) ; d28u8 = vreinterpret_u8_u32 ( d28u32 ) ; d29u8 = vreinterpret_u8_u32 ( d29u32 ) ; d30u8 = vreinterpret_u8_u32 ( d30u32 ) ; } else { d2u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d3u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d4u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d5u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d6u8 = vld1_u8 ( src_ptr ) ; q1u8 = vcombine_u8 ( d2u8 , d3u8 ) ; q2u8 = vcombine_u8 ( d4u8 , d5u8 ) ;  d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ;   d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ;  q4u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q1u8 ) , 8 ) ; q5u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q2u8 ) , 8 ) ; d12u64 = vshr_n_u64 ( vreinterpret_u64_u8 ( d6u8 ) , 8 ) ; d0u32x2 = vzip_u32 ( vreinterpret_u32_u8 ( vget_low_u8 ( q1u8 ) ) , vreinterpret_u32_u8 ( vget_high_u8 ( q1u8 ) ) ) ; d1u32x2 = vzip_u32 ( vreinterpret_u32_u8 ( vget_low_u8 ( q2u8 ) ) , vreinterpret_u32_u8 ( vget_high_u8 ( q2u8 ) ) ) ; d2u32x2 = vzip_u32 ( vreinterpret_u32_u64 ( vget_low_u64 ( q4u64 ) ) , vreinterpret_u32_u64 ( vget_high_u64 ( q4u64 ) ) ) ; d3u32x2 = vzip_u32 ( vreinterpret_u32_u64 ( vget_low_u64 ( q5u64 ) ) , vreinterpret_u32_u64 ( vget_high_u64 ( q5u64 ) ) ) ; q7u16 = vmull_u8 ( vreinterpret_u8_u32 ( d0u32x2 . val [ 0 ] ) , d0u8 ) ; q8u16 = vmull_u8 ( vreinterpret_u8_u32 ( d1u32x2 . val [ 0 ] ) , d0u8 ) ; q9u16 = vmull_u8 ( d6u8 , d0u8 ) ; q7u16 = vmlal_u8 ( q7u16 , vreinterpret_u8_u32 ( d2u32x2 . val [ 0 ] ) , d1u8 ) ; q8u16 = vmlal_u8 ( q8u16 , vreinterpret_u8_u32 ( d3u32x2 . val [ 0 ] ) , d1u8 ) ; q9u16 = vmlal_u8 ( q9u16 , vreinterpret_u8_u64 ( d12u64 ) , d1u8 ) ; d28u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ; d29u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ; d30u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ; } if ( yoffset == 0 ) { vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d28u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d28u8 ) , 1 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d29u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d29u8 ) , 1 ) ; } else { d0u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 0 ] ) ; d1u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 1 ] ) ; q1u16 = vmull_u8 ( d28u8 , d0u8 ) ; q2u16 = vmull_u8 ( d29u8 , d0u8 ) ; d26u8 = vext_u8 ( d28u8 , d29u8 , 4 ) ; d27u8 = vext_u8 ( d29u8 , d30u8 , 4 ) ; q1u16 = vmlal_u8 ( q1u16 , d26u8 , d1u8 ) ; q2u16 = vmlal_u8 ( q2u16 , d27u8 , d1u8 ) ; d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ; d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d2u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d2u8 ) , 1 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d3u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d3u8 ) , 1 ) ; } return ; }"," , d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ;  d28u32 = vld1_lane_u32  = vdup_n_u8 (  bifilter4_coeff [ xoffset  = vdup_n_u8 (  bifilter4_coeff [ xoffset"
493,"CWE-119 static int search_old_relocation ( struct reloc_struct_t * reloc_table , ut32 addr_to_patch , int n_reloc ) { int i ; for ( i = 0 ; i < n_reloc ; i ++ ) { if ( addr_to_patch == reloc_table [ i ] . data_offset ) { return i ; } } return - 1 ; }","
"
494,"CWE-369 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , ""%s-databits=5\\n"" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , ""%s-databits=6\\n"" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , ""%s-databits=7\\n"" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , ""%s-databits=8\\n"" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , ""%s-parity=odd\\n"" , __func__ ) ; } else { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_EVENPARITY ; dev_dbg ( dev , ""%s-parity=even\\n"" , __func__ ) ; } } else { config -> bParity = UMP_UART_NOPARITY ; dev_dbg ( dev , ""%s-parity=none\\n"" , __func__ ) ; } if ( cflag & CSTOPB ) { config -> bStopBits = UMP_UART_STOPBIT2 ; dev_dbg ( dev , ""%s-stopbits=2\\n"" , __func__ ) ; } else { config -> bStopBits = UMP_UART_STOPBIT1 ; dev_dbg ( dev , ""%s-stopbits=1\\n"" , __func__ ) ; } if ( cflag & CRTSCTS ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW ; config -> wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW ; dev_dbg ( dev , ""%s-RTS/CTSisenabled\\n"" , __func__ ) ; } else { dev_dbg ( dev , ""%s-RTS/CTSisdisabled\\n"" , __func__ ) ; restart_read ( edge_port ) ; } config -> cXon = START_CHAR ( tty ) ; config -> cXoff = STOP_CHAR ( tty ) ; if ( I_IXOFF ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_IN_X ; dev_dbg ( dev , ""%s-INBOUNDXON/XOFFisenabled,XON=%2x,XOFF=%2x\\n"" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , ""%s-INBOUNDXON/XOFFisdisabled\\n"" , __func__ ) ; if ( I_IXON ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X ; dev_dbg ( dev , ""%s-OUTBOUNDXON/XOFFisenabled,XON=%2x,XOFF=%2x\\n"" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , ""%s-OUTBOUNDXON/XOFFisdisabled\\n"" , __func__ ) ; tty -> termios . c_cflag &= ~ CMSPAR ; baud = tty_get_baud_rate ( tty ) ; if ( ! baud ) { baud = 9600 ;  } else   tty_encode_baud_rate ( tty , baud , baud ) ;  edge_port -> baud_rate = baud ; config -> wBaudRate = ( __u16 ) ( ( 461550L + baud / 2 ) / baud ) ; dev_dbg ( dev , ""%s-baudrate=%d,wBaudRate=%d\\n"" , __func__ , baud , config -> wBaudRate ) ; dev_dbg ( dev , ""wBaudRate:%d\\n"" , ( int ) ( 461550L / config -> wBaudRate ) ) ; dev_dbg ( dev , ""wFlags:0x%x\\n"" , config -> wFlags ) ; dev_dbg ( dev , ""bDataBits:%d\\n"" , config -> bDataBits ) ; dev_dbg ( dev , ""bParity:%d\\n"" , config -> bParity ) ; dev_dbg ( dev , ""bStopBits:%d\\n"" , config -> bStopBits ) ; dev_dbg ( dev , ""cXon:%d\\n"" , config -> cXon ) ; dev_dbg ( dev , ""cXoff:%d\\n"" , config -> cXoff ) ; dev_dbg ( dev , ""bUartMode:%d\\n"" , config -> bUartMode ) ; cpu_to_be16s ( & config -> wFlags ) ; cpu_to_be16s ( & config -> wBaudRate ) ; status = send_cmd ( edge_port -> port -> serial -> dev , UMPC_SET_CONFIG , ( __u8 ) ( UMPM_UART1_PORT + port_number ) , 0 , ( __u8 * ) config , sizeof ( * config ) ) ; if ( status ) dev_dbg ( dev , ""%s-error%dwhentryingtowriteconfigtodevice\\n"" , __func__ , status ) ; kfree ( config ) ; }"," ; } else { baud = min ( baud , 461550 ) ;  baud ) ; }"
495,"CWE-189 struct timespec ns_to_timespec ( const s64 nsec ) {  struct timespec ts ;  if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ;  ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ;   if ( unlikely ( nsec < 0 ) )   set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ;  return ts ; }"," struct timespec ts ; s32 rem  . tv_sec = div_s64_rem  ( nsec ,  NSEC_PER_SEC , & rem  ) ; if  ( unlikely ( rem  < 0 )  0 ) ) {  ts . tv_sec  ts . tv_sec -- ; rem += NSEC_PER_SEC ; }  ts . tv_nsec  ts . tv_nsec = rem  ; return ts"
496,"CWE-119  void Huff_transmit ( huff_t * huff , int ch , byte * fout ) {  int i ; if ( huff -> loc [ ch ] == NULL ) {  Huff_transmit ( huff , NYT , fout ) ;  for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch >> i ) & 0x1 ) , fout ) ; } } else {  send ( huff -> loc [ ch ] , NULL , fout ) ;  } }"," byte * fout , int maxoffset  NYT , fout , maxoffset  NULL , fout , maxoffset"
497,"CWE-200 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ;  long timeo ;  lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( ""LLC(%s:%d):Applicationbug,raceinMSG_PEEK\\n"" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }", ; long timeo ; msg -> msg_namelen = 0
498,"CWE-119 int CIFSFindNext ( const int xid , struct cifs_tcon * tcon , __u16 searchHandle , struct cifs_search_info * psrch_inf ) { TRANSACTION2_FNEXT_REQ * pSMB = NULL ; TRANSACTION2_FNEXT_RSP * pSMBr = NULL ; T2_FNEXT_RSP_PARMS * parms ; char * response_data ; int rc = 0 ;  int bytes_returned , name_len ;  __u16 params , byte_count ; cFYI ( 1 , ""InFindNext"" ) ; if ( psrch_inf -> endOfSearch ) return - ENOENT ; rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) return rc ; params = 14 ; byte_count = 0 ; pSMB -> TotalDataCount = 0 ; pSMB -> MaxParameterCount = cpu_to_le16 ( 8 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT ) ; pSMB -> SearchHandle = searchHandle ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ; pSMB -> ResumeKey = psrch_inf -> resume_key ; pSMB -> SearchFlags = cpu_to_le16 ( CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME ) ; name_len = psrch_inf -> resume_name_len ; params += name_len ; if ( name_len < PATH_MAX ) { memcpy ( pSMB -> ResumeFileName , psrch_inf -> presume_name , name_len ) ; byte_count += name_len ; pSMB -> ResumeFileName [ name_len ] = 0 ; pSMB -> ResumeFileName [ name_len + 1 ] = 0 ; } else { rc = - EINVAL ; goto FNext2_err_exit ; } byte_count = params + 1 ; pSMB -> TotalParameterCount = cpu_to_le16 ( params ) ; pSMB -> ParameterCount = pSMB -> TotalParameterCount ; inc_rfc1001_len ( pSMB , byte_count ) ; pSMB -> ByteCount = cpu_to_le16 ( byte_count ) ; rc = SendReceive ( xid , tcon -> ses , ( struct smb_hdr * ) pSMB , ( struct smb_hdr * ) pSMBr , & bytes_returned , 0 ) ; cifs_stats_inc ( & tcon -> num_fnext ) ; if ( rc ) { if ( rc == - EBADF ) { psrch_inf -> endOfSearch = true ; cifs_buf_release ( pSMB ) ; rc = 0 ; } else cFYI ( 1 , ""FindNextreturned=%d"" , rc ) ; } else { rc = validate_t2 ( ( struct smb_t2_rsp * ) pSMBr ) ; if ( rc == 0 ) { unsigned int lnoff ; if ( pSMBr -> hdr . Flags2 & SMBFLG2_UNICODE ) psrch_inf -> unicode = true ; else psrch_inf -> unicode = false ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . ParameterOffset ) ; parms = ( T2_FNEXT_RSP_PARMS * ) response_data ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset ) ; if ( psrch_inf -> smallBuf ) cifs_small_buf_release ( psrch_inf -> ntwrk_buf_start ) ; else cifs_buf_release ( psrch_inf -> ntwrk_buf_start ) ; psrch_inf -> srch_entries_start = response_data ; psrch_inf -> ntwrk_buf_start = ( char * ) pSMB ; psrch_inf -> smallBuf = 0 ; if ( parms -> EndofSearch ) psrch_inf -> endOfSearch = true ; else psrch_inf -> endOfSearch = false ; psrch_inf -> entries_in_buffer = le16_to_cpu ( parms -> SearchCount ) ; psrch_inf -> index_of_last_entry += psrch_inf -> entries_in_buffer ; lnoff = le16_to_cpu ( parms -> LastNameOffset ) ; if ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE < lnoff ) { cERROR ( 1 , ""ignoringcorruptresumename"" ) ; psrch_inf -> last_entry = NULL ; return rc ; } else psrch_inf -> last_entry = psrch_inf -> srch_entries_start + lnoff ; } } FNext2_err_exit : if ( rc != 0 ) cifs_buf_release ( pSMB ) ; return rc ; }", ; int bytes_returned ; unsigned int  name_len ; __u16
499,"CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ;  }  read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }", ret ; } if ( pid == INT_MIN ) return - ESRCH ;
500,"CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) {  int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;  if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }", ms ) { uint32_t  nestsize = (  nestsize = ( uint32_t  ) ms ->
501,CWE-352 static HttpResponse create_HttpResponse ( Socket_T S ) { HttpResponse res = NULL ; NEW ( res ) ; res -> S = S ; res -> status = SC_OK ; res -> outputbuffer = StringBuffer_create ( 256 ) ; res -> is_committed = false ; res -> protocol = SERVER_PROTOCOL ; res -> status_msg = get_status_string ( SC_OK ) ;  return res ;  }, SC_OK ) ; Util_getToken ( res -> token ) ;
502,"CWE-119  static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode ,   BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) {  const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ; if ( allow_select && tx_mode == TX_MODE_SELECT && bsize >= BLOCK_8X8 ) return read_selected_tx_size ( cm , xd , max_tx_size , r ) ; else return MIN ( max_tx_size , tx_mode_to_biggest_tx_size [ tx_mode ] ) ; }"," * xd ,  int allow_select ,  int allow_select , vpx_reader  * r )  r ) { TX_MODE tx_mode = cm -> tx_mode ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;"
503,"CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ MNT_WRITE_HOLD ;  atomic_inc ( & sb -> s_active ) ;  mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; br_write_unlock ( & vfsmount_lock ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }", ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;
504,"CWE-59 int add_mibdir ( const char * dirname ) {  FILE * ip ;  const char * oldFile = File ; char * * filenames ; int count = 0 ; int filename_count , i ;  # if ! ( defined ( WIN32 ) || defined ( cygwin ) )  char * token ; char space ; char newline ; struct stat dir_stat , idx_stat ; char tmpstr [ 300 ] ; char tmpstr1 [ 300 ] ; # endif DEBUGMSGTL ( ( ""parse-mibs"" , ""Scanningdirectory%s\\n"" , dirname ) ) ;  # if ! ( defined ( WIN32 ) || defined ( cygwin ) )  token = netsnmp_mibindex_lookup ( dirname ) ; if ( token && stat ( token , & idx_stat ) == 0 && stat ( dirname , & dir_stat ) == 0 ) { if ( dir_stat . st_mtime < idx_stat . st_mtime ) { DEBUGMSGTL ( ( ""parse-mibs"" , ""Theindexisgood\\n"" ) ) ; if ( ( ip = fopen ( token , ""r"" ) ) != NULL ) { fgets ( tmpstr , sizeof ( tmpstr ) , ip ) ; while ( fscanf ( ip , ""%127s%c%299[^\\n]%c"" , token , & space , tmpstr , & newline ) == 4 ) { if ( space != '' || newline != '\\n' ) { snmp_log ( LOG_ERR , ""add_mibdir:stringsscannedinfrom%s/%s"" ""aretoolarge.count=%d\\n"" , dirname , "".index"" , count ) ; break ; } snprintf ( tmpstr1 , sizeof ( tmpstr1 ) , ""%s/%s"" , dirname , tmpstr ) ; tmpstr1 [ sizeof ( tmpstr1 ) - 1 ] = 0 ; new_module ( token , tmpstr1 ) ; count ++ ; } fclose ( ip ) ; return count ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Can\'treadindex\\n"" ) ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Indexoutdated\\n"" ) ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""Noindex\\n"" ) ) ; # endif filename_count = scan_directory ( & filenames , dirname ) ; if ( filename_count >= 0 ) {  ip = netsnmp_mibindex_new ( dirname ) ;  for ( i = 0 ; i < filename_count ; i ++ ) {  if ( add_mibfile ( filenames [ i ] , strrchr ( filenames [ i ] , '/' ) , ip ) == 0 )  count ++ ; free ( filenames [ i ] ) ; }  File = oldFile ;  if ( ip ) fclose ( ip ) ; free ( filenames ) ; return ( count ) ; } else DEBUGMSGTL ( ( ""parse-mibs"" , ""cannotopenMIBdirectory%s\\n"" , dirname ) ) ; return ( - 1 ) ; }"," dirname ) {  const char *  , i ;  DEBUGMSGTL ( (  ) ) ;  filename_count = scan_directory  0 ) {  for ( i  , '/' )  ) == 0  File = oldFile  ; free ("
505,"CWE-835 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ;  int just_opened = 0 ;  restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , ""Nolongerreceivingplaylist%d\\n"" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload :  if ( ! v -> finished &&  av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , ""Failedtoreloadplaylist%d\\n"" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , ""skipping%dsegmentsahead,expiredfromplaylists\\n"" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , ""Failedtoopensegmentofplaylist%d\\n"" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }", ; int just_opened = 0 ; int reload_count  ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
506,"CWE-862 static int rename_in_ns ( int pid , char * oldname , char * * newnamep ) {  int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ;  bool grab_newname = false ; ofd = lxc_preserve_ns ( getpid ( ) , ""net"" ) ; if ( ofd < 0 ) {  fprintf ( stderr , ""Failedopeningnetworknamespacepathfor\'%d\'."" , getpid ( ) ) ;   return - 1 ;  } fd = lxc_preserve_ns ( pid , ""net"" ) ; if ( fd < 0 ) {  fprintf ( stderr , ""Failedopeningnetworknamespacepathfor\'%d\'."" , pid ) ;   return - 1 ;  }  if ( setns ( fd , 0 ) < 0 ) {  fprintf ( stderr , ""setnstocontainernetworknamespace\\n"" ) ; goto out_err ; }  close ( fd ) ; fd = - 1 ;  if ( ! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ;  if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) {  fprintf ( stderr , ""failedtogetnetdevindex\\n"" ) ; goto out_err ; } }  if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) {  fprintf ( stderr , ""Error%drenamingnetdev%sto%sincontainer\\n"" , ret , oldname , * newnamep ) ; goto out_err ; } if ( grab_newname ) {  char ifname [ IFNAMSIZ ] , * namep = ifname ;  if ( ! if_indextoname ( ifindex , namep ) ) {  fprintf ( stderr , ""Failedtogetnewnetdevname\\n"" ) ;  goto out_err ; } * newnamep = strdup ( namep ) ; if ( ! * newnamep )  goto out_err ;  }  if ( setns ( ofd , 0 ) < 0 ) {  fprintf ( stderr , ""Errorreturningtooriginalnetns\\n"" ) ; close ( ofd ) ;  return - 1 ;  } close ( ofd ) ; return 0 ; out_err : if ( ofd >= 0 ) close ( ofd ) ; if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , ""Errorreturningtooriginalnetworknamespace\\n"" ) ; if ( fd >= 0 ) close ( fd ) ; return - 1 ; }"," newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex  = - 1  1 , ret  ; bool grab_newname  0 ) { usernic_error (  ""Failedopeningnetworknamespacepathfor\'%d\'."" , getpid  ) ; return fret  ; } fd  0 ) { usernic_error (  ""Failedopeningnetworknamespacepathfor\'%d\'."" , pid  pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( ""Failedtoretrievereal,effective,andsaved"" ""userIDs:%s\\n"" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret =  setns ( fd  ( fd , CLONE_NEWNET ) ;  close ( fd  fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( ""Failedtosetns()tothenetworknamespaceof"" ""thecontainerwithPID%d:%s.\\n"" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( ""Failedtodropprivilegebysettingeffective"" ""useridandrealuseridto%d,andsaveduser"" ""IDto0:%s.\\n"" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; }  if ( !  = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ;  if ( ! ifindex ) { usernic_error ( ""Failedtogetnetdevindex:%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( ""Error%drenamingnetdev%sto%sincontainer.\\n"" , ret ,  oldname , *  * newnamep ) ; goto do_full_cleanup  ; } if  [ IFNAMSIZ ] ; char  * namep =  ) ) { usernic_error ( ""Failedtogetnewnetdevname:%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup  ; } *  newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( ""Failedtorestoreprivilegebysettingeffective"" ""useridto%d,realuseridto%d,andsaveduser"" ""IDto%d:%s.\\n"" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret =  setns ( ofd  ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( ""Failedtosetns()tooriginalnetworknamespace"" ""ofPID%d:%s.\\n"" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close (  ofd ) ;  ) ; return fret  ; } "
507,"CWE-190 void silk_NLSF_stabilize ( opus_int16 * NLSF_Q15 , const opus_int16 * NDeltaMin_Q15 , const opus_int L ) { opus_int i , I = 0 , k , loops ; opus_int16 center_freq_Q15 ; opus_int32 diff_Q15 , min_diff_Q15 , min_center_Q15 , max_center_Q15 ; silk_assert ( NDeltaMin_Q15 [ L ] >= 1 ) ; for ( loops = 0 ; loops < MAX_LOOPS ; loops ++ ) { min_diff_Q15 = NLSF_Q15 [ 0 ] - NDeltaMin_Q15 [ 0 ] ; I = 0 ; for ( i = 1 ; i <= L - 1 ; i ++ ) { diff_Q15 = NLSF_Q15 [ i ] - ( NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = i ; } } diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15 [ L - 1 ] + NDeltaMin_Q15 [ L ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = L ; } if ( min_diff_Q15 >= 0 ) { return ; } if ( I == 0 ) { NLSF_Q15 [ 0 ] = NDeltaMin_Q15 [ 0 ] ; } else if ( I == L ) { NLSF_Q15 [ L - 1 ] = ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ; } else { min_center_Q15 = 0 ; for ( k = 0 ; k < I ; k ++ ) { min_center_Q15 += NDeltaMin_Q15 [ k ] ; } min_center_Q15 += silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1 ) ; max_center_Q15 = 1 << 15 ; for ( k = L ; k > I ; k -- ) { max_center_Q15 -= NDeltaMin_Q15 [ k ] ; } max_center_Q15 -= silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1 ) ; center_freq_Q15 = ( opus_int16 ) silk_LIMIT_32 ( silk_RSHIFT_ROUND ( ( opus_int32 ) NLSF_Q15 [ I - 1 ] + ( opus_int32 ) NLSF_Q15 [ I ] , 1 ) , min_center_Q15 , max_center_Q15 ) ; NLSF_Q15 [ I - 1 ] = center_freq_Q15 - silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1 ) ; NLSF_Q15 [ I ] = NLSF_Q15 [ I - 1 ] + NDeltaMin_Q15 [ I ] ; } } if ( loops == MAX_LOOPS ) { silk_insertion_sort_increasing_all_values_int16 ( & NLSF_Q15 [ 0 ] , L ) ; NLSF_Q15 [ 0 ] = silk_max_int ( NLSF_Q15 [ 0 ] , NDeltaMin_Q15 [ 0 ] ) ; for ( i = 1 ; i < L ; i ++ )  NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ;  NLSF_Q15 [ L - 1 ] = silk_min_int ( NLSF_Q15 [ L - 1 ] , ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ) ; for ( i = L - 2 ; i >= 0 ; i -- ) NLSF_Q15 [ i ] = silk_min_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i + 1 ] - NDeltaMin_Q15 [ i + 1 ] ) ; } }"," i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] )  ) ; NLSF_Q15"
508,"CWE-119 void vp8_dequant_idct_add_c ( short * input , short * dq , unsigned char * dest , int stride ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { input [ i ] = dq [ i ] * input [ i ] ; } vp8_short_idct4x4llm_c ( input , dest , stride , dest , stride ) ;  vpx_memset ( input , 0 , 32 ) ;  }"," stride ) ; memset  ( input ,"
509,"CWE-20 bool_t enc624j600IrqHandler ( NetInterface * interface ) { bool_t flag ; uint16_t status ; flag = FALSE ;  enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ;   status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ;   if ( ( status & EIR_LINKIF ) != 0 )  {  enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE ) ;  interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; }  if ( ( status & EIR_PKTIF ) != 0 )  {  enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_PKTIE ) ;  interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; }  if ( ( status & ( EIR_TXIF | EIR_TXABTIF ) ) != 0 )  {  enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ;  flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; }  enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ;  return flag ; }"," ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE  ) ; status  ( interface , ENC624J600_EIR  ) ; if  ( status & ENC624J600_EIR_LINKIF  ) != 0  ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE  ) ; interface  ( status & ENC624J600_EIR_PKTIF  ) != 0  ( interface , ENC624J600_EIE , ENC624J600_EIE_PKTIE  ) ; interface  status & ( ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF  ) ) !=  ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF  ) ; flag  ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE  ) ; return"
510,"CWE-362 hsm_com_errno_t unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ;  if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 )  { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) {  close ( fd ) ;  return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , ""%s"" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) {  unlink ( hdl -> c_path ) ;  close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) {  unlink ( hdl -> c_path ) ;  close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) {  unlink ( hdl -> c_path ) ;  close ( fd ) ; return HSM_COM_CONX_ERR ; } hdl -> client_fd = fd ; hdl -> client_state = HSM_COM_C_STATE_CT ; if ( unix_sck_send_conn ( hdl , 2 ) != HSM_COM_OK ) { hdl -> client_state = HSM_COM_C_STATE_IN ;  return HSM_COM_SEND_ERR ;  } return HSM_COM_OK ; }", sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ;  ) ) { res = HSM_COM_PATH_ERR ; goto cleanup  ; } snprintf  0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ;  } if (  0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup  ; } memset  0 ) { res = HSM_COM_CONX_ERR ; goto cleanup  ; } hdl  = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res  ; } 
511,"CWE-416 static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } }  opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ;  sk_dst_reset ( sk ) ; return opt ; }", = xchg ( ( __force struct ipv6_txoptions * * )
512,CWE-617 static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f ||  s -> cur_pic . field_picture ||  s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }, cur_pic . field_picture  ) return 0
513,"CWE-119 static int atusb_get_and_show_build ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ;  char build [ ATUSB_BUILD_SIZE + 1 ] ;   int ret ;  ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ; if ( ret >= 0 ) { build [ ret ] = 0 ; dev_info ( & usb_dev -> dev , ""Firmware:build%s\\n"" , build ) ; }  return ret ;  }"," usb_dev ; char * build  ; int ret  ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM  ) ; } kfree ( build ) ;"
514,"CWE-362 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags ) { struct mm_struct * mm = vma -> vm_mm ; struct dev_pagemap * pgmap = NULL ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ;  if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) {  pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { pgmap = get_dev_pagemap ( pte_pfn ( pte ) , NULL ) ; if ( pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) { get_page ( page ) ; if ( pgmap ) { put_dev_pagemap ( pgmap ) ; pgmap = NULL ; } } if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }"," ) && ! can_follow_write_pte ( pte , flags  ) ) {"
515,"CWE-190 void *  xmalloc ( size_t size )   {   void * ptr = malloc ( size ) ;  if ( ! ptr && ( size != 0 ) ) { perror ( ""xmalloc:Memoryallocationfailure"" ) ; abort ( ) ; } return ptr ; }"," xmalloc ( size_t num , size_t  size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;  = malloc ( res  ) ; if"
516,"CWE-189 int do_adjtimex ( struct timex * txc ) {  long mtemp , save_adjust , rem ;  s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ;  time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }"," mtemp , save_adjust  ; s64 freq_adj  ; time_offset = div_s64  ( time_offset ,  time_offset , NTP_INTERVAL_FREQ  ) ; time_offset"
517,"CWE-17 static struct super_block * alloc_super ( struct file_system_type * type , int flags ) { struct super_block * s = kzalloc ( sizeof ( struct super_block ) , GFP_USER ) ; static const struct super_operations default_op ; int i ; if ( ! s ) return NULL ; if ( security_sb_alloc ( s ) ) goto fail ;  # ifdef CONFIG_SMP  s -> s_files = alloc_percpu ( struct list_head ) ; if ( ! s -> s_files ) goto fail ;  for_each_possible_cpu ( i )  INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ; # else INIT_LIST_HEAD ( & s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 ) goto fail ;  lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] ,  & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ;  if ( list_lru_init ( & s -> s_dentry_lru ) )  goto fail ;  if ( list_lru_init ( & s -> s_inode_lru ) )  goto fail ; INIT_LIST_HEAD ( & s -> s_mounts ) ; init_rwsem ( & s -> s_umount ) ; lockdep_set_class ( & s -> s_umount , & type -> s_umount_key ) ; down_write_nested ( & s -> s_umount , SINGLE_DEPTH_NESTING ) ; s -> s_count = 1 ; atomic_set ( & s -> s_active , 1 ) ; mutex_init ( & s -> s_vfs_rename_mutex ) ; lockdep_set_class ( & s -> s_vfs_rename_mutex , & type -> s_vfs_rename_key ) ; mutex_init ( & s -> s_dquot . dqio_mutex ) ; mutex_init ( & s -> s_dquot . dqonoff_mutex ) ; init_rwsem ( & s -> s_dquot . dqptr_sem ) ; s -> s_maxbytes = MAX_NON_LFS ; s -> s_op = & default_op ; s -> s_time_gran = 1000000000 ; s -> cleancache_poolid = - 1 ; s -> s_shrink . seeks = DEFAULT_SEEKS ; s -> s_shrink . scan_objects = super_cache_scan ; s -> s_shrink . count_objects = super_cache_count ; s -> s_shrink . batch = 1024 ; s -> s_shrink . flags = SHRINKER_NUMA_AWARE ; return s ; fail : destroy_super ( s ) ; return NULL ; }"," goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0  ) goto fail  goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru )  ) goto fail  goto fail ;  if ( list_lru_init  & s -> s_inode_lru  ) ) goto  goto fail ;  INIT_LIST_HEAD ( &"
518,"CWE-264 static FILE * open_log_file ( void ) {  if ( log_fp )  return log_fp ; log_fp = fopen ( log_file , ""a+"" ) ; if ( log_fp == NULL ) {  if ( daemon_mode == FALSE ) {  printf ( ""Warning:Cannotopenlogfile\'%s\'forwriting\\n"" , log_file ) ;  }  return NULL ; } ( void ) fcntl ( fileno ( log_fp ) , F_SETFD , FD_CLOEXEC ) ; return log_fp ; }"," void ) { int fh ; struct stat st ; if ( log_fp ) return log_fp ; if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) { if ( daemon_mode == FALSE ) printf ( ""Warning:Cannotopenlogfile\'%s\'forwriting\\n"" , log_file ) ; return NULL ; } log_fp = fdopen ( fh  , ""a+"" )  == FALSE )  printf ( ""Warning:Cannotopenlogfile\'%s\'forwriting\\n""  log_file ) ; return NULL ; } if ( ( fstat ( fh , & st ) ) == - 1 ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( ""Warning:Cannotfstatlogfile\'%s\'\\n"" , log_file ) ; return NULL ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( ""Warning:logfile\'%s\'hasaninvalidmode\\n"" , log_file ) ;  return NULL ;"
519,"CWE-264 int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , ""Internalerror:directorycacheinfousedincg_write\\n"" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 )  r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ;  else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ; if ( ! r ) size = - EINVAL ; out : free_key ( k ) ; return size ; }"," -> pid , fc -> uid ,"
520,"CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; }  if ( sec_attr == NULL ) {  if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }", sec_attr == NULL || sec_attr_len
521,"CWE-89 static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ;  pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ;   if ( ! pop3c -> mailbox )  return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }"," . path ; return Curl_urldecode  ( data ,  , 0 , &  pop3c -> mailbox  pop3c -> mailbox , NULL , TRUE )  ; } "
522,"CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( ""ping_unhash(isk=%p,isk->num=%u)\\n"" , isk , isk -> inet_num ) ; if ( sk_hashed ( sk ) ) { write_lock_bh ( & ping_table . lock ) ; hlist_nulls_del ( & sk -> sk_nulls_node ) ;  sock_put ( sk ) ;  isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; write_unlock_bh ( & ping_table . lock ) ; } }", sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;
523,"CWE-476 static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( ""index"" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { print_str ( ""codec_name"" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( ""codec_long_name"" , cd -> long_name ? cd -> long_name : ""unknown"" ) ; } } else { print_str_opt ( ""codec_name"" , ""unknown"" ) ; if ( ! do_bitexact ) { print_str_opt ( ""codec_long_name"" , ""unknown"" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( ""profile"" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , ""%d"" , par -> profile ) ; print_str ( ""profile"" , profile_num ) ; } else print_str_opt ( ""profile"" , ""unknown"" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( ""codec_type"" , s ) ; else print_str_opt ( ""codec_type"" , ""unknown"" ) ; # if FF_API_LAVF_AVCTX if ( dec_ctx ) print_q ( ""codec_time_base"" , dec_ctx -> time_base , '/' ) ; # endif print_str ( ""codec_tag_string"" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( ""codec_tag"" , ""0x%04"" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , par -> width ) ; print_int ( ""height"" , par -> height ) ; if ( dec_ctx ) { print_int ( ""coded_width"" , dec_ctx -> coded_width ) ; print_int ( ""coded_height"" , dec_ctx -> coded_height ) ; } print_int ( ""has_b_frames"" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . den ) { print_q ( ""sample_aspect_ratio"" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( ""display_aspect_ratio"" , dar , ':' ) ; } else { print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ; print_str_opt ( ""display_aspect_ratio"" , ""N/A"" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( ""pix_fmt"" , s ) ; else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ; print_int ( ""level"" , par -> level ) ; if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( par -> color_range ) ) ; else print_str_opt ( ""color_range"" , ""N/A"" ) ; if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; else print_str_opt ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ;  if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; else print_str_opt ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; else print_str_opt ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( ""field_order"" , ""progressive"" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( ""field_order"" , ""tt"" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( ""field_order"" , ""bb"" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( ""field_order"" , ""tb"" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( ""field_order"" , ""bt"" ) ; else print_str_opt ( ""field_order"" , ""unknown"" ) ; # if FF_API_PRIVATE_OPT if ( dec_ctx && dec_ctx -> timecode_frame_start >= 0 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , dec_ctx -> timecode_frame_start ) ; print_str ( ""timecode"" , tcbuf ) ; } else { print_str_opt ( ""timecode"" , ""N/A"" ) ; } # endif if ( dec_ctx ) print_int ( ""refs"" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( ""sample_fmt"" , s ) ; else print_str_opt ( ""sample_fmt"" , ""unknown"" ) ; print_val ( ""sample_rate"" , par -> sample_rate , unit_hertz_str ) ; print_int ( ""channels"" , par -> channels ) ; if ( par -> channel_layout ) { av_bprint_clear ( & pbuf ) ; av_bprint_channel_layout ( & pbuf , par -> channels , par -> channel_layout ) ; print_str ( ""channel_layout"" , pbuf . str ) ; } else { print_str_opt ( ""channel_layout"" , ""unknown"" ) ; } print_int ( ""bits_per_sample"" , av_get_bits_per_sample ( par -> codec_id ) ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( ""width"" , par -> width ) ; else print_str_opt ( ""width"" , ""N/A"" ) ; if ( par -> height ) print_int ( ""height"" , par -> height ) ; else print_str_opt ( ""height"" , ""N/A"" ) ; break ; } if ( dec_ctx && dec_ctx -> codec && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) { uint8_t * str ; if ( opt -> flags ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( ""id"" , ""0x%x"" , stream -> id ) ; else print_str_opt ( ""id"" , ""N/A"" ) ; print_q ( ""r_frame_rate"" , stream -> r_frame_rate , '/' ) ; print_q ( ""avg_frame_rate"" , stream -> avg_frame_rate , '/' ) ; print_q ( ""time_base"" , stream -> time_base , '/' ) ; print_ts ( ""start_pts"" , stream -> start_time ) ; print_time ( ""start_time"" , stream -> start_time , & stream -> time_base ) ; print_ts ( ""duration_ts"" , stream -> duration ) ; print_time ( ""duration"" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( ""bit_rate"" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""bit_rate"" , ""N/A"" ) ; # if FF_API_LAVF_AVCTX if ( stream -> codec -> rc_max_rate > 0 ) print_val ( ""max_bit_rate"" , stream -> codec -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""max_bit_rate"" , ""N/A"" ) ; # endif if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( ""bits_per_raw_sample"" , ""%d"" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( ""bits_per_raw_sample"" , ""N/A"" ) ; if ( stream -> nb_frames ) print_fmt ( ""nb_frames"" , ""%"" PRId64 , stream -> nb_frames ) ; else print_str_opt ( ""nb_frames"" , ""N/A"" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( ""nb_read_frames"" , ""%"" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( ""nb_read_frames"" , ""N/A"" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( ""nb_read_packets"" , ""%"" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( ""nb_read_packets"" , ""N/A"" ) ; if ( do_show_data ) writer_print_data ( w , ""extradata"" , par -> extradata , par -> extradata_size ) ; writer_print_data_hash ( w , ""extradata_hash"" , par -> extradata , par -> extradata_size ) ; # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , ""default"" ) ; PRINT_DISPOSITION ( DUB , ""dub"" ) ; PRINT_DISPOSITION ( ORIGINAL , ""original"" ) ; PRINT_DISPOSITION ( COMMENT , ""comment"" ) ; PRINT_DISPOSITION ( LYRICS , ""lyrics"" ) ; PRINT_DISPOSITION ( KARAOKE , ""karaoke"" ) ; PRINT_DISPOSITION ( FORCED , ""forced"" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , ""hearing_impaired"" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , ""visual_impaired"" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , ""clean_effects"" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , ""attached_pic"" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , ""timed_thumbnails"" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }"," ) ) ; print_primaries ( w ,  par -> color_primaries  par -> color_primaries  ) ; if"
524,"CWE-416 static int get_task_ioprio ( struct task_struct * p ) { int ret ; ret = security_task_getioprio ( p ) ; if ( ret ) goto out ; ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ;  if ( p -> io_context )  ret = p -> io_context -> ioprio ;  out :  return ret ; }", IOPRIO_NORM ) ; task_lock ( p ) ;  -> ioprio ; task_unlock ( p ) ;
525,"CWE-119 static int privsep_preauth ( Authctxt * authctxt ) { int status , r ; pid_t pid ; struct ssh_sandbox * box = NULL ; pmonitor = monitor_init ( ) ; pmonitor -> m_pkex = & active_state -> kex ; if ( use_privsep == PRIVSEP_ON ) box = ssh_sandbox_init ( ) ; pid = fork ( ) ; if ( pid == - 1 ) { fatal ( ""forkofunprivilegedchildfailed"" ) ; } else if ( pid != 0 ) { debug2 ( ""Networkchildisonpid%ld"" , ( long ) pid ) ; pmonitor -> m_pid = pid ; if ( have_agent ) { r = ssh_get_authentication_socket ( & auth_sock ) ; if ( r != 0 ) { error ( ""Couldnotgetagentsocket:%s"" , ssh_err ( r ) ) ; have_agent = 0 ; } } if ( box != NULL ) ssh_sandbox_parent_preauth ( box , pid ) ; monitor_child_preauth ( authctxt , pmonitor ) ;  monitor_sync ( pmonitor ) ;  while ( waitpid ( pid , & status , 0 ) < 0 ) { if ( errno == EINTR ) continue ; pmonitor -> m_pid = - 1 ; fatal ( ""%s:waitpid:%s"" , __func__ , strerror ( errno ) ) ; } privsep_is_preauth = 0 ; pmonitor -> m_pid = - 1 ; if ( WIFEXITED ( status ) ) { if ( WEXITSTATUS ( status ) != 0 ) fatal ( ""%s:preauthchildexitedwithstatus%d"" , __func__ , WEXITSTATUS ( status ) ) ; } else if ( WIFSIGNALED ( status ) ) fatal ( ""%s:preauthchildterminatedbysignal%d"" , __func__ , WTERMSIG ( status ) ) ; if ( box != NULL ) ssh_sandbox_parent_finish ( box ) ; return 1 ; } else { close ( pmonitor -> m_sendfd ) ; close ( pmonitor -> m_log_recvfd ) ; set_log_handler ( mm_log_handler , pmonitor ) ; privsep_preauth_child ( ) ; setproctitle ( ""%s"" , ""[net]"" ) ; if ( box != NULL ) ssh_sandbox_child ( box ) ; return 0 ; } }", pmonitor ) ;  while ( waitpid
526,"CWE-416  void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {  get_page ( buf -> page ) ;  }",    bool  generic_pipe_buf_get ( struct  buf ) { return try_get_page  ( buf ->
527,"CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , ""bin.demangle"" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , ""arm"" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , ""bin.lang"" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , ""bin"" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""["" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fsexports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Exports]\\n"" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fssymbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Symbols]\\n"" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""NumPaddrVaddrBindTypeSizeName\\n"" ) ; } size_t count = 0 ; r_list_foreach ( symbols , iter , symbol ) { if ( ! symbol -> name ) { continue ; } char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ; ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ; int len = symbol -> size ? symbol -> size : 32 ; SymName sn = { 0 } ; if ( exponly && ! isAnExport ( symbol ) ) { free ( r_symbol_name ) ; continue ; } if ( name && strcmp ( r_symbol_name , name ) ) { free ( r_symbol_name ) ; continue ; } if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) { free ( r_symbol_name ) ; continue ; } if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) { free ( r_symbol_name ) ; continue ; } count ++ ; snInit ( r , & sn , symbol , lang ) ; if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) { } else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) { if ( is_arm ) { handle_arm_special_symbol ( r , symbol , va ) ; } } else if ( IS_MODE_SET ( mode ) ) { if ( is_arm ) { handle_arm_symbol ( r , symbol , info , va ) ; } select_flag_space ( r , symbol ) ; if ( sn . classname ) { RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ; if ( r -> bin -> prefix ) { char * prname = r_str_newf ( ""%s.%s"" , r -> bin -> prefix , sn . methflag ) ; r_name_filter ( sn . methflag , - 1 ) ; free ( sn . methflag ) ; sn . methflag = prname ; } if ( fi ) { r_flag_item_set_realname ( fi , sn . methname ) ; if ( ( fi -> offset - r -> flags -> base ) == addr ) { r_flag_unset ( r -> flags , fi ) ; } } else { fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ; char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ; if ( comment ) { r_flag_item_set_comment ( fi , comment ) ; R_FREE ( comment ) ; } } } else { const char * n = sn . demname ? sn . demname : sn . name ; const char * fn = sn . demflag ? sn . demflag : sn . nameflag ; char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( ""%s.%s"" , r -> bin -> prefix , fn ) : strdup ( fn ) ; RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ; if ( fi ) { r_flag_item_set_realname ( fi , n ) ; fi -> demangled = ( bool ) ( size_t ) sn . demname ; } else { if ( fn ) { eprintf ( ""[Warning]Can\'tfindflag(%s)\\n"" , fn ) ; } } free ( fnp ) ; } if ( sn . demname ) { r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ; } r_flag_space_pop ( r -> flags ) ; } else if ( IS_MODE_JSON ( mode ) ) { char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ; r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"","" ""\\""demname\\"":\\""%s\\"","" ""\\""flagname\\"":\\""%s\\"","" ""\\""ordinal\\"":%d,"" ""\\""bind\\"":\\""%s\\"","" ""\\""size\\"":%d,"" ""\\""type\\"":\\""%s\\"","" ""\\""vaddr\\"":%"" PFMT64d "","" ""\\""paddr\\"":%"" PFMT64d ""}"" , ( ( exponly && firstexp ) || printHere ) ? """" : ( iter -> p ? "","" : """" ) , str , sn . demname ? sn . demname : """" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ; free ( str ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( ""0x%08"" PFMT64x ""%d%s\\n"" , addr , ( int ) symbol -> size , name ) ; } else if ( IS_MODE_SIMPLEST ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( ""%s\\n"" , name ) ; } else if ( IS_MODE_RAD ( mode ) ) { if ( is_special_symbol ( symbol ) ) { goto next ; } RBinFile * binfile ; RBinPlugin * plugin ; const char * name = sn . demname ? sn . demname : r_symbol_name ; if ( ! name ) { goto next ; } if ( ! strncmp ( name , ""imp."" , 4 ) ) { if ( lastfs != 'i' ) { r_cons_printf ( ""fsimports\\n"" ) ; } lastfs = 'i' ; } else { if ( lastfs != 's' ) { const char * fs = exponly ? ""exports"" : ""symbols"" ; r_cons_printf ( ""fs%s\\n"" , fs ) ; } lastfs = 's' ; } if ( r -> bin -> prefix || * name ) { char * flagname = construct_symbol_flagname ( ""sym"" , name , MAXFLAG_LEN_DEFAULT ) ; if ( ! flagname ) { goto next ; } r_cons_printf ( ""\\""f%s%s%s%u0x%08"" PFMT64x ""\\""\\n"" , r -> bin -> prefix ? r -> bin -> prefix : """" , r -> bin -> prefix ? ""."" : """" , flagname , symbol -> size , addr ) ; free ( flagname ) ; } binfile = r_bin_cur ( r -> bin ) ; plugin = r_bin_file_cur_plugin ( binfile ) ; if ( plugin && plugin -> name ) { if ( r_str_startswith ( plugin -> name , ""pe"" ) ) { char * module = strdup ( r_symbol_name ) ; char * p = strstr ( module , "".dll_"" ) ; if ( p && strstr ( module , ""imp."" ) ) { char * symname = __filterShell ( p + 5 ) ; char * m = __filterShell ( module ) ; * p = 0 ; if ( r -> bin -> prefix ) {  r_cons_printf ( ""kbin/pe/%s/%d=%s.%s\\n"" ,  module , symbol -> ordinal , r -> bin -> prefix , symname ) ; } else {  r_cons_printf ( ""kbin/pe/%s/%d=%s\\n"" ,  module , symbol -> ordinal , symname ) ; } free ( symname ) ; free ( m ) ; } free ( module ) ; } } } else { const char * bind = symbol -> bind ? symbol -> bind : ""NONE"" ; const char * type = symbol -> type ? symbol -> type : ""NONE"" ; const char * name = r_str_get ( sn . demname ? sn . demname : r_symbol_name ) ; r_cons_printf ( ""%03u"" , symbol -> ordinal ) ; if ( symbol -> paddr == UT64_MAX ) { r_cons_printf ( ""----------"" ) ; } else { r_cons_printf ( ""0x%08"" PFMT64x , symbol -> paddr ) ; } r_cons_printf ( ""0x%08"" PFMT64x ""%6s%6s%4d%s%s\\n"" , addr , bind , type , symbol -> size , * name ? """" : """" , name ) ; } next : snFini ( & sn ) ; i ++ ; free ( r_symbol_name ) ; if ( exponly && firstexp ) { firstexp = false ; } if ( printHere ) { break ; } } if ( count == 0 && IS_MODE_JSON ( mode ) ) { r_cons_printf ( ""{}"" ) ; } if ( is_arm ) { r_list_foreach ( entries , iter , entry ) { if ( IS_MODE_SET ( mode ) ) { handle_arm_entry ( r , entry , info , va ) ; } } } if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""]"" ) ; } r_spaces_pop ( & r -> anal -> meta_spaces ) ; return true ; }"," { r_cons_printf ( ""\\""kbin/pe/%s/%d=%s.%s\\""\\n""  , module ,  { r_cons_printf ( ""\\""kbin/pe/%s/%d=%s\\""\\n""  , module ,"
528,"CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) {  ALOGE ( ""b/26366256"" ) ;  return ; } pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }"," ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"""
529,"CWE-20 size_t cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ;  cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ;  DPRINTF ( ( ""Chain:"" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( ""%d"" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( ""Countingchainlooplimit"" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; }  if ( sid > maxsector ) {  DPRINTF ( ( ""Sector%d>%d\\n"" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( ""none,sid:%d\\n"" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( ""\\n"" ) ) ; return i ; }"," ( cdf_secid_t ) (  * size ) / sizeof ( maxsector ) )  if ( sid >= maxsector ) { DPRINTF ( ( ""Sector%d>=%d\\n""  , sid ,"
530,"CWE-399 static struct kioctx * ioctx_alloc ( unsigned nr_events ) { struct mm_struct * mm = current -> mm ; struct kioctx * ctx ; int err = - ENOMEM ; nr_events = max ( nr_events , num_possible_cpus ( ) * 4 ) ; nr_events *= 2 ; if ( ( nr_events > ( 0x10000000U / sizeof ( struct io_event ) ) ) || ( nr_events > ( 0x10000000U / sizeof ( struct kiocb ) ) ) ) { pr_debug ( ""ENOMEM:nr_eventstoohigh\\n"" ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! nr_events || ( unsigned long ) nr_events > ( aio_max_nr * 2UL ) ) return ERR_PTR ( - EAGAIN ) ; ctx = kmem_cache_zalloc ( kioctx_cachep , GFP_KERNEL ) ; if ( ! ctx ) return ERR_PTR ( - ENOMEM ) ; ctx -> max_reqs = nr_events ; if ( percpu_ref_init ( & ctx -> users , free_ioctx_users ) ) goto err ; if ( percpu_ref_init ( & ctx -> reqs , free_ioctx_reqs ) ) goto err ; spin_lock_init ( & ctx -> ctx_lock ) ; spin_lock_init ( & ctx -> completion_lock ) ; mutex_init ( & ctx -> ring_lock ) ; init_waitqueue_head ( & ctx -> wait ) ; INIT_LIST_HEAD ( & ctx -> active_reqs ) ; ctx -> cpu = alloc_percpu ( struct kioctx_cpu ) ; if ( ! ctx -> cpu ) goto err ; if ( aio_setup_ring ( ctx ) < 0 ) goto err ; atomic_set ( & ctx -> reqs_available , ctx -> nr_events - 1 ) ; ctx -> req_batch = ( ctx -> nr_events - 1 ) / ( num_possible_cpus ( ) * 4 ) ; if ( ctx -> req_batch < 1 ) ctx -> req_batch = 1 ; spin_lock ( & aio_nr_lock ) ; if ( aio_nr + nr_events > ( aio_max_nr * 2UL ) || aio_nr + nr_events < aio_nr ) { spin_unlock ( & aio_nr_lock ) ; err = - EAGAIN ; goto err ; } aio_nr += ctx -> max_reqs ; spin_unlock ( & aio_nr_lock ) ; percpu_ref_get ( & ctx -> users ) ; err = ioctx_add_table ( ctx , mm ) ; if ( err ) goto err_cleanup ; pr_debug ( ""allocatedioctx%p[%ld]:mm=%pmask=0x%x\\n"" , ctx , ctx -> user_id , mm , ctx -> nr_events ) ; return ctx ; err_cleanup : aio_nr_sub ( ctx -> max_reqs ) ; err :  aio_free_ring ( ctx ) ;  free_percpu ( ctx -> cpu ) ; free_percpu ( ctx -> reqs . pcpu_count ) ; free_percpu ( ctx -> users . pcpu_count ) ; kmem_cache_free ( kioctx_cachep , ctx ) ; pr_debug ( ""errorallocatingioctx%d\\n"" , err ) ; return ERR_PTR ( err ) ; }", ; err :  free_percpu ( ctx
531,"CWE-000 static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec ,  bool compat )  { ssize_t ret ; * nr_segs = * len ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( rw , ( struct compat_iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; else # endif ret = rw_copy_check_uvector ( rw , ( struct iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; if ( ret < 0 ) return ret ; * len = ret ;  return 0 ;  }"," , bool compat , struct iov_iter * iter  = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;"
532,"CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; }  if ( IS_NOT_NULL ( Else ) ) {   len += SIZE_OP_JUMP ;  tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }", tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ;  ) ) {  tlen = compile_length_tree
533,"CWE-000 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ;  if ( vmx_set_msr ( vcpu , & msr ) != 0 ) {  trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }"," ; if ( kvm_set_msr  ( vcpu ,"
534,"CWE-74 static int smtp_open ( struct Connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; # ifdef USE_SSL enum QuadOption ans = MUTT_NO ; if ( conn -> ssf ) ans = MUTT_NO ; else if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( Capabilities & SMTP_CAP_STARTTLS ) && ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""SecureconnectionwithTLS?"" ) ) ) == MUTT_ABORT ) ) { return - 1 ; } if ( ans == MUTT_YES ) { if ( mutt_socket_send ( conn , ""STARTTLS\\r\\n"" ) < 0 ) return SMTP_ERR_WRITE ;  rc = smtp_get_resp ( conn ) ;  if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( ""CouldnotnegotiateTLSconnection"" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! ( Capabilities & SMTP_CAP_AUTH ) ) { mutt_error ( _ ( ""SMTPserverdoesnotsupportauthentication"" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }", rc = smtp_get_resp ( conn ) ; mutt_socket_empty
535,"CWE-416 void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( ""printstarting"" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( ""setupchanged"" , ( SIGNAL_FUNC ) read_settings ) ;  signal_remove ( ""messagequit"" , ( SIGNAL_FUNC ) msg_quit ) ;  signal_remove ( ""messagejoin"" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( ""messageircmode"" , ( SIGNAL_FUNC ) msg_mode ) ; }"," ; signal_remove ( ""serverdisconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove ("
536,"CWE-416  static int may_create_in_sticky ( struct dentry * const dir ,  struct inode * const inode ) { if ( ( ! sysctl_protected_fifos && S_ISFIFO ( inode -> i_mode ) ) || ( ! sysctl_protected_regular && S_ISREG ( inode -> i_mode ) ) ||  likely ( ! ( dir -> d_inode -> i_mode & S_ISVTX ) ) ||   uid_eq ( inode -> i_uid , dir -> d_inode -> i_uid ) ||  uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return 0 ;  if ( likely ( dir -> d_inode -> i_mode & 0002 ) ||   ( dir -> d_inode -> i_mode & 0020 &&  ( ( sysctl_protected_fifos >= 2 && S_ISFIFO ( inode -> i_mode ) ) || ( sysctl_protected_regular >= 2 && S_ISREG ( inode -> i_mode ) ) ) ) ) { const char * operation = S_ISFIFO ( inode -> i_mode ) ? ""sticky_create_fifo"" : ""sticky_create_regular"" ; audit_log_path_denied ( AUDIT_ANOM_CREAT , operation ) ; return - EACCES ; } return 0 ; }"," int may_create_in_sticky ( umode_t dir_mode , kuid_t dir_uid  , struct inode  ( ! ( dir_mode  & S_ISVTX )  -> i_uid , dir_uid  ) || uid_eq  ( likely ( dir_mode  & 0002 )  ) || ( dir_mode  & 0020 &&"
537,"CWE-362 static int  mptctl_fw_download ( unsigned long arg )  { struct mpt_fw_xfer __user * ufwdl = ( void __user * ) arg ; struct mpt_fw_xfer kfwdl ; if ( copy_from_user ( & kfwdl , ufwdl , sizeof ( struct mpt_fw_xfer ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::_ioctl_fwdl-"" ""Unabletocopympt_fw_xferstruct@%p\\n"" , __FILE__ , __LINE__ , ufwdl ) ; return - EFAULT ; }  return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ;  }"," int mptctl_fw_download ( MPT_ADAPTER * iocp ,  return mptctl_do_fw_download ( iocp  , kfwdl ."
538,"CWE-358 static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; }  dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;  dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }", } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
539,"CWE-119 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; }  while ( collen > 0 )  { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; }  while ( replen > 0 )  { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; }  while ( collen > 0 )  { x = CVAL ( in ) ; if ( x & 1 ) { x = x >> 1 ; x = x + 1 ; color = - x ; } else { x = x >> 1 ; color = x ; } x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; collen -- ; }  while ( replen > 0 )  { x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; replen -- ; } } } indexh ++ ; last_line = this_line ; } return ( int ) ( in - org_in ) ; }", } while ( indexw < width &&  } while ( indexw < width &&  } while ( indexw < width &&  } while ( indexw < width &&
540,"CWE-617  void  pci_populate_msicap ( struct msicap * msicap , int msgnum , int nextptr ) { int mmc ;  assert ( ( msgnum & ( msgnum - 1 ) ) == 0 && msgnum >= 1 && msgnum <= 32 ) ;  mmc = ffs ( msgnum ) - 1 ; bzero ( msicap , sizeof ( struct msicap ) ) ; msicap -> capid = PCIY_MSI ; msicap -> nextptr = nextptr ; msicap -> msgctrl = PCIM_MSICTRL_64BIT | ( mmc << 1 ) ;  } ","    int  pci_populate_msicap ( struct  int mmc ; if (  ( ( msgnum  1 ) ) != 0 ) || msgnum < 1 || msgnum > 32 ) { pr_err ( ""%s:invalidnumberofmsimessages!\\n"" , __func__ ) ; return - 1 ; }  mmc = ffs  1 ) ; return 0 ;"
541,"CWE-416 static int xc2028_set_config ( struct dvb_frontend * fe , void * priv_cfg ) { struct xc2028_data * priv = fe -> tuner_priv ; struct xc2028_ctrl * p = priv_cfg ; int rc = 0 ; tuner_dbg ( ""%scalled\\n"" , __func__ ) ; mutex_lock ( & priv -> lock ) ; kfree ( priv -> ctrl . fname ) ;  memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;  if ( p -> fname ) { priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ) ; if ( priv -> ctrl . fname == NULL )  rc = - ENOMEM ;  } if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) ) free_firmware ( priv ) ; if ( priv -> ctrl . max_len < 9 ) priv -> ctrl . max_len = 13 ; if ( priv -> state == XC2028_NO_FIRMWARE ) { if ( ! firmware_name [ 0 ] ) priv -> fname = priv -> ctrl . fname ; else priv -> fname = firmware_name ; rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ) ; if ( rc < 0 ) { tuner_err ( ""Failedtorequestfirmware%s\\n"" , priv -> fname ) ; priv -> state = XC2028_NODEV ; } else priv -> state = XC2028_WAITING_FIRMWARE ; } mutex_unlock ( & priv -> lock ) ; return rc ; }", fname ) ; priv -> ctrl . fname = NULL ;  == NULL ) return  - ENOMEM ;
542,"CWE-401 static int ca8210_probe ( struct spi_device * spi_device ) { struct ca8210_priv * priv ; struct ieee802154_hw * hw ; struct ca8210_platform_data * pdata ; int ret ; dev_info ( & spi_device -> dev , ""Insertingca8210\\n"" ) ; hw = ieee802154_alloc_hw ( sizeof ( struct ca8210_priv ) , & ca8210_phy_ops ) ; if ( ! hw ) { dev_crit ( & spi_device -> dev , ""ieee802154_alloc_hwfailed\\n"" ) ; ret = - ENOMEM ; goto error ; } priv = hw -> priv ; priv -> hw = hw ; priv -> spi = spi_device ; hw -> parent = & spi_device -> dev ; spin_lock_init ( & priv -> lock ) ; priv -> async_tx_pending = false ; priv -> hw_registered = false ; priv -> sync_up = 0 ; priv -> sync_down = 0 ; priv -> promiscuous = false ; priv -> retries = 0 ; init_completion ( & priv -> ca8210_is_awake ) ; init_completion ( & priv -> spi_transfer_complete ) ; init_completion ( & priv -> sync_exchange_complete ) ; spi_set_drvdata ( priv -> spi , priv ) ; if ( IS_ENABLED ( CONFIG_IEEE802154_CA8210_DEBUGFS ) ) { cascoda_api_upstream = ca8210_test_int_driver_write ; ca8210_test_interface_init ( priv ) ; } else { cascoda_api_upstream = NULL ; } ca8210_hw_setup ( hw ) ; ieee802154_random_extended_addr ( & hw -> phy -> perm_extended_addr ) ; pdata = kmalloc ( sizeof ( * pdata ) , GFP_KERNEL ) ; if ( ! pdata ) { ret = - ENOMEM ; goto error ; }  ret = ca8210_get_platform_data ( priv -> spi , pdata ) ;  if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_get_platform_datafailed\\n"" ) ; goto error ; } priv -> spi -> dev . platform_data = pdata ;  ret = ca8210_dev_com_init ( priv ) ;  if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_dev_com_initfailed\\n"" ) ; goto error ; } ret = ca8210_reset_init ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_reset_initfailed\\n"" ) ; goto error ; } ret = ca8210_interrupt_init ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_interrupt_initfailed\\n"" ) ; goto error ; } msleep ( 100 ) ; ca8210_reset_send ( priv -> spi , 1 ) ; ret = tdme_chipinit ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""tdme_chipinitfailed\\n"" ) ; goto error ; } if ( pdata -> extclockenable ) { ret = ca8210_config_extern_clk ( pdata , priv -> spi , 1 ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_config_extern_clkfailed\\n"" ) ; goto error ; } ret = ca8210_register_ext_clock ( priv -> spi ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_register_ext_clockfailed\\n"" ) ; goto error ; } } ret = ieee802154_register_hw ( hw ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ieee802154_register_hwfailed\\n"" ) ; goto error ; } priv -> hw_registered = true ; return 0 ; error : msleep ( 100 ) ; ca8210_remove ( spi_device ) ; return link_to_linux_err ( ret ) ; }"," error ; }  priv -> spi  ; ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_get_platform_datafailed\\n"" ) ; goto error ; } ret ="
543,"CWE-399 static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; }  while ( offset < end_offset )  offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;  return offset ;  }", while ( offset > 0 && offset  < end_offset ) {  hf_keybuffer ) ; }
544,"CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = ""libevt_record_values_read_event"" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:invalidrecordvalues."" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:invalidrecorddata."" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , ""%s:invalidrecorddatasizevalueexceedsmaximum."" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:recorddatasizevalueoutofbounds."" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ; byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ; # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:size\\t\\t\\t\\t\\t:%"" PRIu32 ""\\n"" , function , size ) ; libcnotify_printf ( ""%s:signature\\t\\t\\t\\t:%c%c%c%c\\n"" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ; libcnotify_printf ( ""%s:recordnumber\\t\\t\\t\\t:%"" PRIu32 ""\\n"" , function , record_values -> number ) ; if ( libevt_debug_print_posix_time_value ( function , ""creationtime\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:unabletoprintPOSIXtimevalue."" , function ) ; goto on_error ; } if ( libevt_debug_print_posix_time_value ( function , ""writtentime\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:unabletoprintPOSIXtimevalue."" , function ) ; goto on_error ; } libcnotify_printf ( ""%s:eventidentifier\\t\\t\\t:0x%08"" PRIx32 ""\\n"" , function , record_values -> event_identifier ) ; libcnotify_printf ( ""%s:eventidentifier:code\\t\\t\\t:%"" PRIu32 ""\\n"" , function , record_values -> event_identifier & 0x0000ffffUL ) ; libcnotify_printf ( ""%s:eventidentifier:facility\\t\\t:%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ; libcnotify_printf ( ""%s:eventidentifier:reserved\\t\\t:%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ; libcnotify_printf ( ""%s:eventidentifier:customerflags\\t:%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ; libcnotify_printf ( ""%s:eventidentifier:severity\\t\\t:%"" PRIu32 ""("" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ; libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ; libcnotify_printf ( "")\\n"" ) ; libcnotify_printf ( ""%s:eventtype\\t\\t\\t\\t:%"" PRIu16 ""("" , function , record_values -> event_type ) ; libevt_debug_print_event_type ( record_values -> event_type ) ; libcnotify_printf ( "")\\n"" ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ; libcnotify_printf ( ""%s:numberofstrings\\t\\t\\t:%"" PRIu16 ""\\n"" , function , value_16bit ) ; libcnotify_printf ( ""%s:eventcategory\\t\\t\\t\\t:%"" PRIu16 ""\\n"" , function , record_values -> event_category ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ; libcnotify_printf ( ""%s:eventflags\\t\\t\\t\\t:0x%04"" PRIx16 ""\\n"" , function , value_16bit ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ; libcnotify_printf ( ""%s:closingrecordvaluesnumber\\t\\t:%"" PRIu32 ""\\n"" , function , value_32bit ) ; libcnotify_printf ( ""%s:stringsoffset\\t\\t\\t\\t:%"" PRIu32 ""\\n"" , function , strings_offset ) ; libcnotify_printf ( ""%s:usersecurityidentifier(SID)size\\t:%"" PRIu32 ""\\n"" , function , user_sid_size ) ; libcnotify_printf ( ""%s:usersecurityidentifier(SID)offset\\t:%"" PRIu32 ""\\n"" , function , user_sid_offset ) ; libcnotify_printf ( ""%s:datasize\\t\\t\\t\\t:%"" PRIu32 ""\\n"" , function , data_size ) ; libcnotify_printf ( ""%s:dataoffset\\t\\t\\t\\t:%"" PRIu32 ""\\n"" , function , data_offset ) ; } # endif record_data_offset = sizeof ( evt_record_event_header_t ) ; if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:userSIDoffsetorsizevalueoutofbounds."" , function ) ; goto on_error ; } if ( user_sid_offset != 0 ) { if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:userSIDoffsetvalueoutofbounds."" , function ) ; goto on_error ; } if ( user_sid_size != 0 ) { if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:userSIDsizevalueoutofbounds."" , function ) ; goto on_error ; } } } if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:stringsoffsetvalueoutofbounds."" , function ) ; goto on_error ; } if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) { if ( data_size != 0 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:dataoffsetvalueoutofbounds."" , function ) ; goto on_error ; } data_offset = ( uint32_t ) record_data_size - 4 ; } if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:stringsoffsetvalueoutofbounds."" , function ) ; goto on_error ; } if ( strings_offset != 0 ) { if ( strings_offset < record_data_offset ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:stringsoffsetvalueoutofbounds."" , function ) ; goto on_error ; } } if ( user_sid_offset != 0 ) { members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ; } else if ( strings_offset != 0 ) { members_data_size = strings_offset - ( uint32_t ) record_data_offset ; } if ( strings_offset != 0 ) { strings_size = data_offset - strings_offset ; } if ( data_size != 0 ) { if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:datasizevalueoutofbounds."" , function ) ; goto on_error ; } } if ( members_data_size != 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:membersdata:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:unabletocreatesourcenamevalue."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:unabletosetdataofsourcenamevalue."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:sourcename\\t\\t\\t\\t:"" , function ) ; if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:unabletoprintsourcenamevalue."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:unabletocreatecomputernamevalue."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:unabletosetdataofcomputernamevalue."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:computername\\t\\t\\t\\t:"" , function ) ; if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:unabletoprintcomputernamevalue."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( members_data_size > 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:memberstrailingdata:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif record_data_offset += members_data_size ; } } if ( user_sid_size != 0 ) {  if ( libfvalue_value_type_initialize (  & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:unabletocreateusersecurityidentifier(SID)value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:unabletosetdataofusersecurityidentifier(SID)value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:usersecurityidentifier(SID)\\t\\t:"" , function ) ; if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:unabletoprintusersecurityidentifier(SID)value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += user_sid_size ; } if ( strings_size != 0 )  {  # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:stringsdata:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( size_copy == 0 ) { strings_data_offset = strings_offset + strings_size - 2 ; while ( strings_data_offset > strings_offset ) { if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) { strings_size += 2 ; break ; } strings_data_offset -= 2 ; strings_size -= 2 ; } } if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:unabletocreatestringsvalue."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:unabletosetdataofstringsvalue."" , function ) ; goto on_error ; } record_data_offset += strings_size ; } if ( data_size != 0 ) {  # if defined ( HAVE_DEBUG_OUTPUT )  if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:data:\\n"" , function ) ; libcnotify_print_data (  & ( record_data [ data_offset ] ) ,  ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:unabletocreatedatavalue."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:unabletosetdataofdatavalue."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ; # endif } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { if ( record_data_offset < ( record_data_size - 4 ) ) { libcnotify_printf ( ""%s:padding:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } libcnotify_printf ( ""%s:sizecopy\\t\\t\\t\\t:%"" PRIu32 ""\\n"" , function , size_copy ) ; libcnotify_printf ( ""\\n"" ) ; } # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) { size_copy = size ; } if ( size != size_copy ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:valuemismatchforsizeandsizecopy."" , function ) ; goto on_error ; } if ( record_data_size != ( size_t ) size ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:valuemismatchforrecord_valuesdatasizeandsize."" , function ) ; goto on_error ; } return ( 1 ) ; on_error : if ( record_values -> data != NULL ) { libfvalue_value_free ( & ( record_values -> data ) , NULL ) ; } if ( record_values -> strings != NULL ) { libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ; } if ( record_values -> user_security_identifier != NULL ) { libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ; } if ( record_values -> computer_name != NULL ) { libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ; } if ( record_values -> source_name != NULL ) { libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ; } return ( - 1 ) ; }"," { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:userSIDdatasizevalueoutofbounds."" , function ) ; goto on_error ; } if (  0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:stringssizevalueoutofbounds."" , function ) ; goto on_error ; }  0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:datasizevalueoutofbounds."" , function ) ; goto on_error ; }  ( record_data [ record_data_offset  ] ) ,"
545,"CWE-284 int bta_co_rfc_data_outgoing ( void * user_data , uint8_t * buf , uint16_t size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ;  int received = recv ( slot -> fd , buf , size , 0 ) ;  if ( received == size ) { ret = true ; } else { LOG_ERROR ( ""%serrorreceivingRFCOMMdatafromapp:%s"" , __func__ , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }"," int received = TEMP_FAILURE_RETRY (  size , 0 )"
546,"CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( ""check_rpcsec_auth:failed"" ""inquire_context,stat=%u"" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ;  if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0  && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( ""badserviceprincipal%.*s%s"" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }"," princ ) ; success = data_eq_string ( * realm ,  handle -> params  params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ;  fail_princ : if"
547,"CWE-119 static int put_chars ( u32 vtermno , const char * buf , int count ) { struct port * port ;  struct scatterlist sg [ 1 ] ;  if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ; port = find_port_by_vtermno ( vtermno ) ; if ( ! port ) return - EPIPE ;  sg_init_one ( sg , buf , count ) ;   return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ;   } "," [ 1 ] ; void * data ; int ret  - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ;  ( sg , data  , count )  count ) ; ret =  __send_to_port ( port  , count , data  , false )  false ) ; kfree ( data ) ; return ret ;"
548,"CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixelformat0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ;  if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) {  avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding%d,bpp%dandformat0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }", bpp <= 8 && c -> format != CHUNKY
549,"CWE-476 static int peer_recv_callback ( rdpTransport * transport , wStream * s , void * extra ) { freerdp_peer * client = ( freerdp_peer * ) extra ; rdpRdp * rdp = client -> context -> rdp ; switch ( rdp -> state ) { case CONNECTION_STATE_INITIAL : if ( ! rdp_server_accept_nego ( rdp , s ) ) return - 1 ; if ( rdp -> nego -> selected_protocol & PROTOCOL_NLA ) { sspi_CopyAuthIdentity ( & client -> identity , & ( rdp -> nego -> transport -> credssp -> identity ) ) ; IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , TRUE ) ; credssp_free ( rdp -> nego -> transport -> credssp ) ;  }  else { IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , FALSE ) ; } break ; case CONNECTION_STATE_NEGO : if ( ! rdp_server_accept_mcs_connect_initial ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CONNECT : if ( ! rdp_server_accept_mcs_erect_domain_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ERECT_DOMAIN : if ( ! rdp_server_accept_mcs_attach_user_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ATTACH_USER : if ( ! rdp_server_accept_mcs_channel_join_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CHANNEL_JOIN : if ( rdp -> settings -> DisableEncryption ) { if ( ! rdp_server_accept_client_keys ( rdp , s ) ) return - 1 ; break ; } rdp -> state = CONNECTION_STATE_ESTABLISH_KEYS ; case CONNECTION_STATE_ESTABLISH_KEYS : if ( ! rdp_server_accept_client_info ( rdp , s ) ) return - 1 ; IFCALL ( client -> Capabilities , client ) ; if ( ! rdp_send_demand_active ( rdp ) ) return - 1 ; break ; case CONNECTION_STATE_LICENSE : if ( ! rdp_server_accept_confirm_active ( rdp , s ) ) { Stream_SetPosition ( s , 0 ) ; return peer_recv_pdu ( client , s ) ; } break ; case CONNECTION_STATE_ACTIVE : if ( peer_recv_pdu ( client , s ) < 0 ) return - 1 ; break ; default : fprintf ( stderr , ""Invalidstate%d\\n"" , rdp -> state ) ; return - 1 ; } return 0 ; }", credssp ) ; rdp -> nego -> transport -> credssp = NULL ;
550,"CWE-362 static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ;  struct free_nid * i ;  struct nat_entry * ne ;  int err ;  if ( unlikely ( nid == 0 ) ) return false ;  if ( build ) {  ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) )  return false ;  } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }"," free_nid * i , * e  ; int err = - EINVAL ; bool ret = false  return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ;  NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret  ; } "
551,CWE-17 void __fput_sync ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ;  file_sb_list_del ( file ) ;  BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ; __fput ( file ) ; } }, = current ;  BUG_ON ( !
552,"CWE-415 void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;  gdImageWBMPCtx ( im , fg , out ) ;   rv = gdDPExtractData ( out , size ) ;  out -> gd_free ( out ) ; return rv ; }"," NULL ) ; if ( ! _gdImageWBMPCtx  ( im ,  , out ) ) {  rv = gdDPExtractData  size ) ; } else { rv = NULL ; }"
553,"CWE-119 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MaxTextExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register PixelPacket * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ( int ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property ) ; ( void ) ResetMagickMemory ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; profile = BlobToStringInfo ( ( const void * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ;  if ( image_info -> ping )  { ( void ) CloseBlob ( image ) ;  return ( image ) ;  } quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; pixels = GetQuantumPixels ( quantum_info ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," image_info -> ping != MagickFalse  return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )"
554,"CWE-125 unsigned char * base64decode ( const char * buf , size_t * size ) { if ( ! buf || ! size ) return NULL ; size_t len = ( * size > 0 ) ? * size : strlen ( buf ) ; if ( len <= 0 ) return NULL ; unsigned char * outbuf = ( unsigned char * ) malloc ( ( len / 4 ) * 3 + 3 ) ; const char * ptr = buf ; int p = 0 ;  size_t l = 0 ;  do {  ptr += strspn ( ptr , ""\\r\\n\\t"" ) ;  if ( * ptr == '\\0' || ptr >= buf + len ) { break ; }  l = strcspn ( ptr , ""\\r\\n\\t"" ) ;  if ( l > 3 && ptr + l <= buf + len ) { p += base64decode_block ( outbuf + p , ptr , l ) ; ptr += l ; } else { break ; } } while ( 1 ) ; outbuf [ p ] = 0 ; * size = p ; return outbuf ; }"," = 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt  = 0 ;  ; do { while ( ptr < buf + len && ( * ptr == '' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; }  if ( *  break ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; }  } } while"
555,"CWE-119 static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) {  return tmp ;  } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) {  return tmp ;  } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ;  return state -> ptr = tmp ;  }", tmp ) { goto softfail  ; } case  ) ) { goto softfail  ; } state  end ) ; softfail : state -> offset = 0 ;
556,"CWE-20 apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , ""Transfer-Encoding"" ) ; lenp = apr_table_get ( f -> r -> headers_in , ""Content-Length"" ) ; if ( tenc ) { if ( strcasecmp ( tenc , ""chunked"" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , ""chunked"" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 )  ""UnknownTransfer-Encoding:%s;""  ""usingread-until-close"" , tenc ) ; tenc = NULL ; } else { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01585 ) ""UnknownTransfer-Encoding:%s"" , tenc ) ; return APR_EGENERAL ; } lenp = NULL ; } if ( lenp ) { char * endstr ; ctx -> state = BODY_LENGTH ; if ( apr_strtoff ( & ctx -> remaining , lenp , & endstr , 10 ) || endstr == lenp || * endstr || ctx -> remaining < 0 ) { ctx -> remaining = 0 ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01587 ) ""InvalidContent-Length"" ) ;  return APR_ENOSPC ;  } if ( ctx -> limit && ctx -> limit < ctx -> remaining ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01588 ) ""Requestedcontent-lengthof%"" APR_OFF_T_FMT ""islargerthantheconfiguredlimit"" ""of%"" APR_OFF_T_FMT , ctx -> remaining , ctx -> limit ) ; return APR_ENOSPC ; } } if ( ctx -> state == BODY_NONE && f -> r -> proxyreq != PROXYREQ_RESPONSE ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; return APR_SUCCESS ; } if ( ( ctx -> state == BODY_CHUNK || ( ctx -> state == BODY_LENGTH && ctx -> remaining > 0 ) ) && f -> r -> expecting_100 && f -> r -> proto_num >= HTTP_VERSION ( 1 , 1 ) && ! ( f -> r -> eos_sent || f -> r -> bytes_sent ) ) { if ( ! ap_is_HTTP_SUCCESS ( f -> r -> status ) ) { ctx -> state = BODY_NONE ; ctx -> eos_sent = 1 ; } else { char * tmp ; int len ; apr_bucket_brigade * bb ; bb = apr_brigade_create ( f -> r -> pool , f -> c -> bucket_alloc ) ; f -> r -> expecting_100 = 0 ; tmp = apr_pstrcat ( f -> r -> pool , AP_SERVER_PROTOCOL """" , ap_get_status_line ( HTTP_CONTINUE ) , CRLF CRLF , NULL ) ; len = strlen ( tmp ) ; ap_xlate_proto_to_ascii ( tmp , len ) ; e = apr_bucket_pool_create ( tmp , len , f -> r -> pool , f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_HEAD ( bb , e ) ; e = apr_bucket_flush_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( bb , e ) ; rv = ap_pass_brigade ( f -> c -> output_filters , bb ) ;  if ( rv != APR_SUCCESS ) {  return AP_FILTER_ERROR ; } } } } if ( ctx -> eos_sent ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; return APR_SUCCESS ; } do { apr_brigade_cleanup ( b ) ; again = 0 ; switch ( ctx -> state ) { case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT :  case BODY_CHUNK_END : {  rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } e = APR_BRIGADE_FIRST ( b ) ; while ( e != APR_BRIGADE_SENTINEL ( b ) ) { const char * buffer ; apr_size_t len ; if ( ! APR_BUCKET_IS_METADATA ( e ) ) { rv = apr_bucket_read ( e , & buffer , & len , APR_BLOCK_READ ) ; if ( rv == APR_SUCCESS ) { rv = parse_chunk_size ( ctx , buffer , len , f -> r -> server -> limit_req_fieldsize ) ; } if ( rv != APR_SUCCESS ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) ""Errorreadingchunk%s"" , ( APR_ENOSPC == rv ) ? ""(overflow)"" : """" ) ; return rv ; } } apr_bucket_delete ( e ) ; e = APR_BRIGADE_FIRST ( b ) ; } again = 1 ; if ( ctx -> state == BODY_CHUNK_TRAILER ) {  int merge_trailers =  conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ; return read_chunked_trailers ( ctx , f , b , merge_trailers ) ; } break ; } case BODY_NONE : case BODY_LENGTH : case BODY_CHUNK_DATA : { if ( ctx -> state != BODY_NONE && ctx -> remaining < readbytes ) { readbytes = ctx -> remaining ; } if ( readbytes > 0 ) { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF && ctx -> state != BODY_NONE && ctx -> remaining > 0 ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } apr_brigade_length ( b , 0 , & totalread ) ; AP_DEBUG_ASSERT ( totalread >= 0 ) ; if ( ctx -> state != BODY_NONE ) { ctx -> remaining -= totalread ; if ( ctx -> remaining > 0 ) { e = APR_BRIGADE_LAST ( b ) ; if ( APR_BUCKET_IS_EOS ( e ) ) { apr_bucket_delete ( e ) ; return APR_INCOMPLETE ; } } else if ( ctx -> state == BODY_CHUNK_DATA ) { ctx -> state = BODY_CHUNK_END ; ctx -> chunk_used = 0 ; } } } if ( ctx -> state == BODY_LENGTH && ctx -> remaining == 0 ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; } if ( ctx -> limit ) { ctx -> limit_used += totalread ; if ( ctx -> limit < ctx -> limit_used ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) ""Readcontent-lengthof%"" APR_OFF_T_FMT ""islargerthantheconfiguredlimit"" ""of%"" APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; return APR_ENOSPC ; } } break ; } case BODY_CHUNK_TRAILER : { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv != APR_SUCCESS ) { return rv ; } break ; } default : {  break ;  } } } while ( again ) ; return APR_SUCCESS ; }"," ( 02555 ) ""UnknownTransfer-Encoding:%s;"" ""usingread-until-close""  , tenc )  ) ; return APR_EINVAL  ; } if  bb ) ; apr_brigade_cleanup ( bb ) ;  BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF  : { rv  BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE  ) ; }  default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpectedbodystate(%i)"" , ( int ) ctx -> state ) ; return APR_EGENERAL  ; } }"
557,"CWE-125 static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }","
"
558,"CWE-787 static void iriap_getvaluebyclass_indication ( struct iriap_cb * self , struct sk_buff * skb ) { struct ias_object * obj ; struct ias_attrib * attrib ; int name_len ; int attr_len ; char name [ IAS_MAX_CLASSNAME + 1 ] ; char attr [ IAS_MAX_ATTRIBNAME + 1 ] ; __u8 * fp ; int n ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ; IRDA_ASSERT ( self != NULL , return ; ) ; IRDA_ASSERT ( self -> magic == IAS_MAGIC , return ; ) ; IRDA_ASSERT ( skb != NULL , return ; ) ; fp = skb -> data ; n = 1 ; name_len = fp [ n ++ ] ;  memcpy ( name , fp + n , name_len ) ; n += name_len ;  name [ name_len ] = '\\0' ;  attr_len = fp [ n ++ ] ;  memcpy ( attr , fp + n , attr_len ) ; n += attr_len ; attr [ attr_len ] = '\\0' ; IRDA_DEBUG ( 4 , ""LM-IAS:Lookingup%s:%s\\n"" , name , attr ) ; obj = irias_find_object ( name ) ; if ( obj == NULL ) { IRDA_DEBUG ( 2 , ""LM-IAS:Object%snotfound\\n"" , name ) ; iriap_getvaluebyclass_response ( self , 0x1235 , IAS_CLASS_UNKNOWN , & irias_missing ) ; return ; } IRDA_DEBUG ( 4 , ""LM-IAS:found%s,id=%d\\n"" , obj -> name , obj -> id ) ; attrib = irias_find_attrib ( obj , attr ) ; if ( attrib == NULL ) { IRDA_DEBUG ( 2 , ""LM-IAS:Attribute%snotfound\\n"" , attr ) ; iriap_getvaluebyclass_response ( self , obj -> id , IAS_ATTRIB_UNKNOWN , & irias_missing ) ; return ; } iriap_getvaluebyclass_response ( self , obj -> id , IAS_SUCCESS , attrib -> value ) ; }"," ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ;  n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )"
559,"CWE-617 static void finish_process_as_req ( struct as_req_state * state , krb5_error_code errcode ) { krb5_key_data * server_key ; krb5_keyblock * as_encrypting_key = NULL ; krb5_data * response = NULL ; const char * emsg = 0 ; int did_log = 0 ; loop_respond_fn oldrespond ; void * oldarg ; kdc_realm_t * kdc_active_realm = state -> active_realm ; krb5_audit_state * au_state = state -> au_state ; assert ( state ) ; oldrespond = state -> respond ; oldarg = state -> arg ; if ( errcode ) goto egress ; au_state -> stage = ENCR_REP ; if ( ( errcode = validate_forwardable ( state -> request , * state -> client , * state -> server , state -> kdc_time , & state -> status ) ) ) { errcode += ERROR_TABLE_BASE_krb5 ; goto egress ; } errcode = check_indicators ( kdc_context , state -> server , state -> auth_indicators ) ; if ( errcode ) { state -> status = ""HIGHER_AUTHENTICATION_REQUIRED"" ; goto egress ; } state -> ticket_reply . enc_part2 = & state -> enc_tkt_reply ; if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , state -> server , - 1 , - 1 , 0 , & server_key ) ) ) { state -> status = ""FINDING_SERVER_KEY"" ; goto egress ; } if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , server_key , & state -> server_keyblock , NULL ) ) ) { state -> status = ""DECRYPT_SERVER_KEY"" ; goto egress ; } state -> reply . msg_type = KRB5_AS_REP ; state -> reply . client = state -> enc_tkt_reply . client ; state -> reply . ticket = & state -> ticket_reply ; state -> reply_encpart . session = & state -> session_key ; if ( ( errcode = fetch_last_req_info ( state -> client , & state -> reply_encpart . last_req ) ) ) { state -> status = ""FETCH_LAST_REQ"" ; goto egress ; } state -> reply_encpart . nonce = state -> request -> nonce ; state -> reply_encpart . key_exp = get_key_exp ( state -> client ) ; state -> reply_encpart . flags = state -> enc_tkt_reply . flags ; state -> reply_encpart . server = state -> ticket_reply . server ; state -> reply_encpart . times = state -> enc_tkt_reply . times ; state -> reply_encpart . times . authtime = state -> authtime = state -> kdc_time ; state -> reply_encpart . caddrs = state -> enc_tkt_reply . caddrs ; state -> reply_encpart . enc_padata = NULL ; errcode = return_padata ( kdc_context , & state -> rock , state -> req_pkt , state -> request , & state -> reply , & state -> client_keyblock , & state -> pa_context ) ; if ( errcode ) { state -> status = ""KDC_RETURN_PADATA"" ; goto egress ; } if ( state -> client_keyblock . enctype == ENCTYPE_NULL ) { state -> status = ""CANT_FIND_CLIENT_KEY"" ; errcode = KRB5KDC_ERR_ETYPE_NOSUPP ; goto egress ; } errcode = handle_authdata ( kdc_context , state -> c_flags , state -> client , state -> server , NULL , state -> local_tgt , & state -> client_keyblock , & state -> server_keyblock , NULL , state -> req_pkt , state -> request , NULL , NULL , state -> auth_indicators , & state -> enc_tkt_reply ) ; if ( errcode ) { krb5_klog_syslog ( LOG_INFO , _ ( ""AS_REQ:handle_authdata(%d)"" ) , errcode ) ; state -> status = ""HANDLE_AUTHDATA"" ; goto egress ; } errcode = krb5_encrypt_tkt_part ( kdc_context , & state -> server_keyblock , & state -> ticket_reply ) ; if ( errcode ) { state -> status = ""ENCRYPT_TICKET"" ; goto egress ; } errcode = kau_make_tkt_id ( kdc_context , & state -> ticket_reply , & au_state -> tkt_out_id ) ; if ( errcode ) { state -> status = ""GENERATE_TICKET_ID"" ; goto egress ; } state -> ticket_reply . enc_part . kvno = server_key -> key_data_kvno ; errcode = kdc_fast_response_handle_padata ( state -> rstate , state -> request , & state -> reply , state -> client_keyblock . enctype ) ; if ( errcode ) { state -> status = ""MAKE_FAST_RESPONSE"" ; goto egress ; } state -> reply . enc_part . enctype = state -> client_keyblock . enctype ; errcode = kdc_fast_handle_reply_key ( state -> rstate , & state -> client_keyblock , & as_encrypting_key ) ; if ( errcode ) { state -> status = ""MAKE_FAST_REPLY_KEY"" ; goto egress ; } errcode = return_enc_padata ( kdc_context , state -> req_pkt , state -> request , as_encrypting_key , state -> server , & state -> reply_encpart , FALSE ) ; if ( errcode ) { state -> status = ""KDC_RETURN_ENC_PADATA"" ; goto egress ; } if ( kdc_fast_hide_client ( state -> rstate ) ) state -> reply . client = ( krb5_principal ) krb5_anonymous_principal ( ) ; errcode = krb5_encode_kdc_rep ( kdc_context , KRB5_AS_REP , & state -> reply_encpart , 0 , as_encrypting_key , & state -> reply , & response ) ; if ( state -> client_key != NULL ) state -> reply . enc_part . kvno = state -> client_key -> key_data_kvno ; if ( errcode ) { state -> status = ""ENCODE_KDC_REP"" ; goto egress ; } memset ( state -> reply . enc_part . ciphertext . data , 0 , state -> reply . enc_part . ciphertext . length ) ; free ( state -> reply . enc_part . ciphertext . data ) ; log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , state -> request , & state -> reply , state -> client , state -> cname , state -> server , state -> sname , state -> authtime , 0 , 0 , 0 ) ; did_log = 1 ; egress :  if ( errcode != 0 )  assert ( state -> status != 0 ) ; au_state -> status = state -> status ; au_state -> reply = & state -> reply ; kau_as_req ( kdc_context , ( errcode || state -> preauth_err ) ? FALSE : TRUE , au_state ) ; kau_free_kdc_req ( au_state ) ; free_padata_context ( kdc_context , state -> pa_context ) ; if ( as_encrypting_key ) krb5_free_keyblock ( kdc_context , as_encrypting_key ) ; if ( errcode ) emsg = krb5_get_error_message ( kdc_context , errcode ) ; if ( state -> status ) { log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , state -> request , & state -> reply , state -> client , state -> cname , state -> server , state -> sname , state -> authtime , state -> status , errcode , emsg ) ; did_log = 1 ; } if ( errcode ) { if ( state -> status == 0 ) { state -> status = emsg ; } if ( errcode != KRB5KDC_ERR_DISCARD ) { errcode -= ERROR_TABLE_BASE_krb5 ; if ( errcode < 0 || errcode > KRB_ERR_MAX ) errcode = KRB_ERR_GENERIC ; errcode = prepare_error_as ( state -> rstate , state -> request , state -> local_tgt , errcode , state -> e_data , state -> typed_e_data , ( ( state -> client != NULL ) ? state -> client -> princ : NULL ) , & response , state -> status ) ; state -> status = 0 ; } } if ( emsg ) krb5_free_error_message ( kdc_context , emsg ) ; if ( state -> enc_tkt_reply . authorization_data != NULL ) krb5_free_authdata ( kdc_context , state -> enc_tkt_reply . authorization_data ) ; if ( state -> server_keyblock . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> server_keyblock ) ; if ( state -> client_keyblock . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> client_keyblock ) ; if ( state -> reply . padata != NULL ) krb5_free_pa_data ( kdc_context , state -> reply . padata ) ; if ( state -> reply_encpart . enc_padata ) krb5_free_pa_data ( kdc_context , state -> reply_encpart . enc_padata ) ; if ( state -> cname != NULL ) free ( state -> cname ) ; if ( state -> sname != NULL ) free ( state -> sname ) ; krb5_db_free_principal ( kdc_context , state -> client ) ; krb5_db_free_principal ( kdc_context , state -> server ) ; krb5_db_free_principal ( kdc_context , state -> local_tgt_storage ) ; if ( state -> session_key . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> session_key ) ; if ( state -> ticket_reply . enc_part . ciphertext . data != NULL ) { memset ( state -> ticket_reply . enc_part . ciphertext . data , 0 , state -> ticket_reply . enc_part . ciphertext . length ) ; free ( state -> ticket_reply . enc_part . ciphertext . data ) ; } krb5_free_pa_data ( kdc_context , state -> e_data ) ; krb5_free_data ( kdc_context , state -> inner_body ) ; kdc_free_rstate ( state -> rstate ) ; krb5_free_kdc_req ( kdc_context , state -> request ) ; k5_free_data_ptr_list ( state -> auth_indicators ) ; assert ( did_log != 0 ) ; free ( state ) ; ( * oldrespond ) ( oldarg , errcode , response ) ; }"," errcode != 0 && state -> status == NULL ) state -> status = ""UNKNOWN_REASON""  ; au_state ->"
560,"CWE-310 int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ;  if ( ret == - EEXIST )  goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len * 2 ) ; inode_inc_iversion ( parent_inode ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode ( trans , root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; return ret ; fail_dir_item : if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { u64 local_index ; int err ; err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , & local_index , name , name_len ) ; } else if ( add_backref ) { u64 local_index ; int err ; err = btrfs_del_inode_ref ( trans , root , name , name_len , ino , parent_ino , & local_index ) ; } return ret ; }", == - EEXIST || ret == - EOVERFLOW
561,"CWE-119  static void fadst8 ( const int16_t * input , int16_t * output ) {   int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;  int x0 = input [ 7 ] ;  int x1 = input [ 0 ] ;   int x2 = input [ 5 ] ;   int x3 = input [ 2 ] ;   int x4 = input [ 3 ] ;   int x5 = input [ 4 ] ;   int x6 = input [ 1 ] ;   int x7 = input [ 6 ] ;  s0 = cospi_2_64 * x0 + cospi_30_64 * x1 ; s1 = cospi_30_64 * x0 - cospi_2_64 * x1 ; s2 = cospi_10_64 * x2 + cospi_22_64 * x3 ; s3 = cospi_22_64 * x2 - cospi_10_64 * x3 ; s4 = cospi_18_64 * x4 + cospi_14_64 * x5 ; s5 = cospi_14_64 * x4 - cospi_18_64 * x5 ; s6 = cospi_26_64 * x6 + cospi_6_64 * x7 ; s7 = cospi_6_64 * x6 - cospi_26_64 * x7 ; x0 = fdct_round_shift ( s0 + s4 ) ; x1 = fdct_round_shift ( s1 + s5 ) ; x2 = fdct_round_shift ( s2 + s6 ) ; x3 = fdct_round_shift ( s3 + s7 ) ; x4 = fdct_round_shift ( s0 - s4 ) ; x5 = fdct_round_shift ( s1 - s5 ) ; x6 = fdct_round_shift ( s2 - s6 ) ; x7 = fdct_round_shift ( s3 - s7 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = cospi_8_64 * x4 + cospi_24_64 * x5 ; s5 = cospi_24_64 * x4 - cospi_8_64 * x5 ; s6 = - cospi_24_64 * x6 + cospi_8_64 * x7 ; s7 = cospi_8_64 * x6 + cospi_24_64 * x7 ; x0 = s0 + s2 ; x1 = s1 + s3 ; x2 = s0 - s2 ; x3 = s1 - s3 ; x4 = fdct_round_shift ( s4 + s6 ) ; x5 = fdct_round_shift ( s5 + s7 ) ; x6 = fdct_round_shift ( s4 - s6 ) ; x7 = fdct_round_shift ( s5 - s7 ) ; s2 = cospi_16_64 * ( x2 + x3 ) ; s3 = cospi_16_64 * ( x2 - x3 ) ; s6 = cospi_16_64 * ( x6 + x7 ) ; s7 = cospi_16_64 * ( x6 - x7 ) ; x2 = fdct_round_shift ( s2 ) ; x3 = fdct_round_shift ( s3 ) ; x6 = fdct_round_shift ( s6 ) ; x7 = fdct_round_shift ( s7 ) ;  output [ 0 ] = x0 ;   output [ 1 ] = - x4 ;   output [ 2 ] = x6 ;   output [ 3 ] = - x2 ;   output [ 4 ] = x3 ;   output [ 5 ] = - x7 ;   output [ 6 ] = x5 ;   output [ 7 ] = - x1 ;  }"," fadst8 ( const tran_low_t * input , tran_low_t  * output )  output ) { tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t  x0 = input  7 ] ; tran_high_t  x1 = input  0 ] ; tran_high_t  x2 = input  5 ] ; tran_high_t  x3 = input  2 ] ; tran_high_t  x4 = input  3 ] ; tran_high_t  x5 = input  4 ] ; tran_high_t  x6 = input  1 ] ; tran_high_t  x7 = input  0 ] = ( tran_low_t )  1 ] = ( tran_low_t )  2 ] = ( tran_low_t )  3 ] = ( tran_low_t )  4 ] = ( tran_low_t )  5 ] = ( tran_low_t )  6 ] = ( tran_low_t )  7 ] = ( tran_low_t )"
562,"CWE-119  static void  fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;  assert ( ( cc % ( bps * stride ) ) == 0 ) ;  if ( ! tmp )  return ;  _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- )  } ","   static int  fpDiff ( TIFF  cc ) ; if  ( ( cc  stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; }  if ( !  tmp ) return 0  cp -- ) return 1 ;"
563,"CWE-189 static EAS_RESULT Parse_wave ( SDLS_SYNTHESIZER_DATA * pDLSData , EAS_I32 pos , EAS_U16 waveIndex ) { EAS_RESULT result ; EAS_U32 temp ; EAS_I32 size ; EAS_I32 endChunk ; EAS_I32 chunkPos ; EAS_I32 wsmpPos = 0 ; EAS_I32 fmtPos = 0 ; EAS_I32 dataPos = 0 ; EAS_I32 dataSize = 0 ; S_WSMP_DATA * p ; void * pSample ; S_WSMP_DATA wsmp ; chunkPos = pos + 12 ; if ( ( result = EAS_HWFileSeek ( pDLSData -> hwInstData , pDLSData -> fileHandle , pos ) ) != EAS_SUCCESS ) return result ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; if ( temp != CHUNK_WAVE ) { { } return EAS_ERROR_FILE_FORMAT ; } pos = chunkPos ; endChunk = pos + size ; while ( pos < endChunk ) { chunkPos = pos ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; switch ( temp ) { case CHUNK_WSMP : wsmpPos = chunkPos + 8 ; break ; case CHUNK_FMT : fmtPos = chunkPos + 8 ; break ; case CHUNK_DATA : dataPos = chunkPos + 8 ; dataSize = size ; break ; default : break ; } }  if ( dataSize > MAX_DLS_WAVE_SIZE )  { return EAS_ERROR_SOUND_LIBRARY ; } if ( pDLSData -> pDLS == NULL ) p = & wsmp ; else p = & pDLSData -> wsmpData [ waveIndex ] ; p -> fineTune = 0 ; p -> unityNote = 60 ; p -> gain = 0 ; p -> loopStart = 0 ; p -> loopLength = 0 ; if ( ! fmtPos ) { { } return EAS_ERROR_UNRECOGNIZED_FORMAT ; } if ( ! dataPos ) { { } return EAS_ERROR_UNRECOGNIZED_FORMAT ; } if ( wsmpPos ) { if ( ( result = Parse_wsmp ( pDLSData , wsmpPos , p ) ) != EAS_SUCCESS ) return result ; } if ( ( result = Parse_fmt ( pDLSData , fmtPos , p ) ) != EAS_SUCCESS ) return result ; if ( bitDepth == 8 ) { if ( p -> bitsPerSample == 8 ) size = dataSize ; else size = dataSize >> 1 ; if ( p -> loopLength ) size ++ ; } else { if ( p -> bitsPerSample == 16 ) size = dataSize ; else size = dataSize << 1 ; if ( p -> loopLength ) size += 2 ; } if ( pDLSData -> pDLS == NULL ) { pDLSData -> wavePoolSize += ( EAS_U32 ) size ; return EAS_SUCCESS ; } pSample = pDLSData -> pDLS -> pDLSSamples + pDLSData -> wavePoolOffset ; pDLSData -> pDLS -> pDLSSampleOffsets [ waveIndex ] = pDLSData -> wavePoolOffset ; pDLSData -> pDLS -> pDLSSampleLen [ waveIndex ] = ( EAS_U32 ) size ; pDLSData -> wavePoolOffset += ( EAS_U32 ) size ; if ( pDLSData -> wavePoolOffset > pDLSData -> wavePoolSize ) { { } return EAS_ERROR_SOUND_LIBRARY ; } if ( ( result = Parse_data ( pDLSData , dataPos , dataSize , p , pSample ) ) != EAS_SUCCESS ) return result ; return EAS_SUCCESS ; }", } if ( dataSize < 0 ||
564,"CWE-120 int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ;  char * bufp , * commentp , * altp ;  mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == '' ) commentp [ - 1 ] = '\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , ""finish"" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( ""No\\""finish\\"""" ) ; return 0 ; } ++ bufp ; if ( * bufp == '' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( ""Unknownsymkeyword"" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof * tmpsp ) ; tmpsp -> next = ( struct symsetentry * ) 0 ; if ( ! lastsp ) symset_list = tmpsp ; else lastsp -> next = tmpsp ; tmpsp -> idx = symset_count ++ ; tmpsp -> name = dupstr ( bufp ) ; tmpsp -> desc = ( char * ) 0 ; tmpsp -> handling = H_UNK ; tmpsp -> nocolor = 0 ; tmpsp -> primary = 0 ; tmpsp -> rogue = 0 ; break ; case 2 : tmpsp = lastsp ; for ( i = 0 ; known_handling [ i ] ; ++ i ) if ( ! strcmpi ( known_handling [ i ] , bufp ) ) { tmpsp -> handling = i ; break ; } break ; case 3 : tmpsp = lastsp ; if ( tmpsp && ! tmpsp -> desc ) tmpsp -> desc = dupstr ( bufp ) ; break ; case 5 : tmpsp = lastsp ; for ( i = 0 ; known_restrictions [ i ] ; ++ i ) { if ( ! strcmpi ( known_restrictions [ i ] , bufp ) ) { switch ( i ) { case 0 : tmpsp -> primary = 1 ; break ; case 1 : tmpsp -> rogue = 1 ; break ; } break ; } } break ; } } return 1 ; } if ( symp -> range ) { if ( symp -> range == SYM_CONTROL ) { switch ( symp -> idx ) { case 0 : if ( ! strcmpi ( bufp , symset [ which_set ] . name ) ) { chosen_symset_start = TRUE ; if ( which_set == ROGUESET ) init_rogue_symbols ( ) ; else if ( which_set == PRIMARY ) init_primary_symbols ( ) ; } break ; case 1 : if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; break ; case 2 : if ( chosen_symset_start ) set_symhandling ( bufp , which_set ) ; break ; case 4 : if ( chosen_symset_start ) { if ( bufp ) { if ( ! strcmpi ( bufp , ""true"" ) || ! strcmpi ( bufp , ""yes"" ) || ! strcmpi ( bufp , ""on"" ) ) symset [ which_set ] . nocolor = 0 ; else if ( ! strcmpi ( bufp , ""false"" ) || ! strcmpi ( bufp , ""no"" ) || ! strcmpi ( bufp , ""off"" ) ) symset [ which_set ] . nocolor = 1 ; } } break ; case 5 : if ( chosen_symset_start ) { int n = 0 ; while ( known_restrictions [ n ] ) { if ( ! strcmpi ( known_restrictions [ n ] , bufp ) ) { switch ( n ) { case 0 : symset [ which_set ] . primary = 1 ; break ; case 1 : symset [ which_set ] . rogue = 1 ; break ; } break ; } n ++ ; } } break ; } } else { val = sym_val ( bufp ) ; if ( chosen_symset_start ) { if ( which_set == PRIMARY ) { update_primary_symset ( symp , val ) ; } else if ( which_set == ROGUESET ) { update_rogue_symset ( symp , val ) ; } } } } return 1 ; }"," , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0'"
565,"CWE-119 static vpx_codec_err_t ctrl_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {  int * corrupted = va_arg ( args , int * ) ; if ( corrupted ) {  if ( ctx -> pbi )   * corrupted = ctx -> pbi -> common . frame_to_show -> corrupted ;  else return VPX_CODEC_ERROR ; return VPX_CODEC_OK ; } else {  return VPX_CODEC_INVALID_PARAM ;  }  } "," * ctx ,  va_list args )  ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ; if ( frame_worker_data  -> pbi ->  common . frame_to_show == NULL ) return VPX_CODEC_ERROR ; if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted  ; return VPX_CODEC_OK  else { return VPX_CODEC_ERROR  ; } }  ; } } return VPX_CODEC_INVALID_PARAM ; }"
566,"CWE-362 int mi_repair ( MI_CHECK * param , register MI_INFO * info ,  char * name , int rep_quick )  { int error , got_error ; ha_rows start_records , new_header_length ; my_off_t del ; File new_file ; MYISAM_SHARE * share = info -> s ; char llbuff [ 22 ] , llbuff2 [ 22 ] ; SORT_INFO sort_info ; MI_SORT_PARAM sort_param ; DBUG_ENTER ( ""mi_repair"" ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; start_records = info -> state -> records ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0L : share -> pack . header_length ; got_error = 1 ; new_file = - 1 ; sort_param . sort_info = & sort_info ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-recovering(withkeycache)MyISAM-table\'%s\'\\n"" , name ) ; printf ( ""Datarecords:%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_ASSERT ( param -> use_buffers < SIZE_T_MAX ) ; if ( ! param -> using_global_keycache ) ( void ) init_key_cache ( dflt_key_cache , param -> key_cache_block_size , param -> use_buffers , 0 , 0 ) ; if ( init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) ) { bzero ( & info -> rec_cache , sizeof ( info -> rec_cache ) ) ; goto err ; } if ( ! rep_quick ) if ( init_io_cache ( & info -> rec_cache , - 1 , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) ) ) goto err ; info -> opt_flag |= WRITE_CACHE_USED ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) { mi_check_print_error ( param , ""Notenoughmemoryforextrarecord"" ) ; goto err ; } if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'tcreatenewtempfile:\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; info -> s -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } } sort_info . info = info ; sort_info . param = param ; sort_param . read_cache = param -> read_cache ; sort_param . pos = sort_param . max_pos = share -> pack . header_length ; sort_param . filepos = new_header_length ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( info -> dfile , 0L , MY_SEEK_END , MYF ( 0 ) ) ; sort_info . dupp = 0 ; sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param . master = 1 ; sort_info . max_records = ~ ( ha_rows ) 0 ; set_data_file_type ( & sort_info , share ) ; del = info -> state -> del ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; param -> glob_crc = 0 ; if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ; info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) mi_set_all_keys_active ( share -> state . key_map , share -> base . keys ) ; mi_drop_all_indexes ( param , info , TRUE ) ; lock_memory ( param ) ; while ( ! ( error = sort_get_next_record ( & sort_param ) ) ) { if ( writekeys ( & sort_param ) ) { if ( my_errno != HA_ERR_FOUND_DUPP_KEY ) goto err ; DBUG_DUMP ( ""record"" , ( uchar * ) sort_param . record , share -> base . pack_reclength ) ; mi_check_print_info ( param , ""Duplicatekey%2dforrecordat%10sagainstnewrecordat%10s"" , info -> errkey + 1 , llstr ( sort_param . start_recpos , llbuff ) , llstr ( info -> dupp_key_pos , llbuff2 ) ) ; if ( param -> testflag & T_VERBOSE ) { ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ; _mi_print_key ( stdout , share -> keyinfo [ info -> errkey ] . seg , info -> lastkey , USE_WHOLE_KEY ) ; } sort_info . dupp ++ ; if ( ( param -> testflag & ( T_FORCE_UNIQUENESS | T_QUICK ) ) == T_QUICK ) { param -> testflag |= T_RETRY_WITHOUT_QUICK ; param -> error_printed = 1 ; goto err ; } continue ; } if ( sort_write_record ( & sort_param ) ) goto err ; } if ( error > 0 || write_data_suffix ( & sort_info , ( my_bool ) ! rep_quick ) || flush_io_cache ( & info -> rec_cache ) || param -> read_cache . error < 0 ) goto err ; if ( param -> testflag & T_WRITE_LOOP ) { ( void ) fputs ( ""\\r"" , stdout ) ; ( void ) fflush ( stdout ) ; } if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) { mi_check_print_warning ( param , ""Can\'tchangesizeofindexfile,error:%d"" , my_errno ) ; goto err ; } if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'tfixtablewithquickrecovery:Foundwrongnumberofdeletedrecords"" ) ; mi_check_print_error ( param , ""Runrecoveryagainwithout-q"" ) ; got_error = 1 ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; got_error = 1 ; goto err ; } } if ( ! rep_quick ) { mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; info -> state -> data_file_length = sort_param . filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; } else { info -> state -> data_file_length = sort_param . max_pos ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Datarecords:%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%srecordshavebeenremoved"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : if ( ! got_error ) { if ( new_file >= 0 ) {  mysql_file_close ( new_file , MYF ( 0 ) ) ;  info -> dfile = new_file = - 1 ; if ( info -> s -> file_map ) { ( void ) my_munmap ( ( char * ) info -> s -> file_map , ( size_t ) info -> s -> mmaped_length ) ; info -> s -> file_map = NULL ; } if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; param -> retry_repair = 0 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%dforrecordatpos%s"" , my_errno , llstr ( sort_param . start_recpos , llbuff ) ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; info -> rec_cache . file = - 1 ; } mi_mark_crashed_on_repair ( info ) ; } my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; if ( ! got_error && param -> testflag & T_UNPACK ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; share -> data_file_type = sort_info . new_data_file_type ; } share -> state . changed |= ( STATE_NOT_OPTIMIZED_KEYS | STATE_NOT_SORTED_PAGES | STATE_NOT_ANALYZED ) ; DBUG_RETURN ( got_error ) ; }"," , int rep_quick , my_bool no_copy_stat  0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ;  , DATA_TMP_EXT , flags  ) || mi_open_datafile"
567,"CWE-284 static int dbConnect ( char * host , char * user , char * passwd ) { DBUG_ENTER ( ""dbConnect"" ) ; if ( verbose ) { fprintf ( stderr , ""#Connectingto%s...\\n"" , host ? host : ""localhost"" ) ; } mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ;  # ifdef HAVE_OPENSSL  if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlcheck"" ) ; if ( ! ( sock = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { DBerror ( & mysql_connection , ""whentryingtoconnect"" ) ; DBUG_RETURN ( 1 ) ; } mysql_connection . reconnect = 1 ; DBUG_RETURN ( 0 ) ; }", NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ;  if ( opt_protocol
568,"CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadatasetscount%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""nomaterialpackagefound\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""couldnotresolvematerialtrackstrongref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""couldnotresolvematerialtracksequencestrongref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""materialtrack%d:has%dcomponents\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""materialtrack%d:nocorrespondingsourcepackagefound\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""couldnotresolvesourcetrackstrongref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""materialtrack%d:nocorrespondingsourcetrackfound\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) {  av_log ( mxf , AV_LOG_TRACE , ""couldnotresolveessencecontainerdatastrongref\\n"" ) ;  continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""couldnotresolvesourcetracksequencestrongref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""materialtrack%d:DataDefinitionmismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""couldnotallocatestream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalideditrate(%d/%d)foundonstream#%d,"" ""defaultingto25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""datadefinitionul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""sourcetrack%d:stream%d,nodescriptorfound\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essencecodecul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essencecontainerul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrappingofstream%disunknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""brokenencryptedmxffile\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:UniversalLabel:"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneFieldframelayoutisn\'tcurrentlysupported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:(%d,%d),field_dominance:%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Fielddominance%dsupport"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Fielddominance%dsupport"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknownframelayouttype:%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalidsamplerate(%d/%d)"" ""foundforstream#%d,timebaseforcedto1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }", av_log ( mxf -> fc
569,"CWE-617 void deinit_pci ( struct vmctx * ctx ) { struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; int bus , slot , func ; size_t lowmem ; struct mem_range mr ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCIECFG"" ; mr . base = PCI_EMUL_ECFG_BASE ; mr . size = PCI_EMUL_ECFG_SIZE ; unregister_mem ( & mr ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCIhole(32-bit)"" ; mr . base = lowmem ; mr . size = ( 4ULL * 1024 * 1024 * 1024 ) - lowmem ; unregister_mem_fallback ( & mr ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""PCIhole(64-bit)"" ; mr . base = PCI_EMUL_MEMBASE64 ; mr . size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64 ; unregister_mem_fallback ( & mr ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ;  assert ( ops != NULL ) ;  pr_notice ( ""pcideinit%s\\n"" , fi -> fi_name ) ; pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ; } } } }"," fi_name ) ; if ( ! ops ) { pr_warn ( ""Nodriverfordevice[%s]\\n"" , fi -> fi_name ) ; continue ; }  pr_notice ( ""pcideinit%s\\n"""
570,"CWE-476 static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; if ( argReg > regsz ) { return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = ""this"" ; debug_locals [ argReg ] . descriptor = r_str_newf ( ""%s;"" , class_name ) ; debug_locals [ argReg ] . startAddress = 0 ; debug_locals [ argReg ] . signature = NULL ; debug_locals [ argReg ] . live = true ; argReg ++ ; } if ( ! ( params = dex_method_signature2 ( bin , MI ) ) ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; return ; } RListIter * iter = r_list_iterator ( params ) ; char * name ; char * type ; int reg ; r_list_foreach ( params , iter , type ) { if ( ( argReg >= regsz ) || ! type || parameters_size <= 0 ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; r_list_free ( emitted_debug_locals ) ; return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & param_type_idx ) ; param_type_idx -= 1 ; name = getstr ( bin , param_type_idx ) ; reg = argReg ; switch ( type [ 0 ] ) { case 'D' : case 'J' : argReg += 2 ; break ; default : argReg += 1 ; break ; } if ( name ) { debug_locals [ reg ] . name = name ; debug_locals [ reg ] . descriptor = type ; debug_locals [ reg ] . signature = NULL ; debug_locals [ reg ] . startAddress = address ; debug_locals [ reg ] . live = true ; } -- parameters_size ; }  ut8 opcode = * ( p4 ++ ) & 0xff ;  while ( keep ) { switch ( opcode ) { case 0x0 : keep = false ; break ; case 0x1 : { ut64 addr_diff ; p4 = r_uleb128 ( p4 , p4_end - p4 , & addr_diff ) ; address += addr_diff ; } break ; case 0x2 : { st64 line_diff = r_sleb128 ( & p4 , p4_end ) ; line += line_diff ; } break ; case 0x3 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = NULL ; debug_locals [ register_num ] . live = true ; } break ; case 0x4 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; ut64 sig_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & sig_idx ) ; sig_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = getstr ( bin , sig_idx ) ; debug_locals [ register_num ] . live = true ; } break ; case 0x5 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . live = false ; } break ; case 0x6 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( ! debug_locals [ register_num ] . live ) { debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . live = true ; } } break ; case 0x7 : break ; case 0x8 : break ; case 0x9 : { p4 = r_uleb128 ( p4 , p4_end - p4 , & source_file_idx ) ; source_file_idx -- ; } break ; default : { int adjusted_opcode = opcode - 0x0a ; address += ( adjusted_opcode / 15 ) ; line += - 4 + ( adjusted_opcode % 15 ) ; struct dex_debug_position_t * position = malloc ( sizeof ( struct dex_debug_position_t ) ) ; if ( ! position ) { keep = false ; break ; } position -> source_file_idx = source_file_idx ; position -> address = address ; position -> line = line ; r_list_append ( debug_positions , position ) ; } break ; } opcode = * ( p4 ++ ) & 0xff ; } if ( ! binfile -> sdb_addrinfo ) { binfile -> sdb_addrinfo = sdb_new0 ( ) ; } char * fileline ; char offset [ 64 ] ; char * offset_ptr ; RListIter * iter1 ; struct dex_debug_position_t * pos ; r_list_foreach ( debug_positions , iter1 , pos ) { fileline = r_str_newf ( ""%s|%"" PFMT64d , getstr ( bin , pos -> source_file_idx ) , pos -> line ) ; offset_ptr = sdb_itoa ( pos -> address + paddr , offset , 16 ) ; sdb_set ( binfile -> sdb_addrinfo , offset_ptr , fileline , 0 ) ; sdb_set ( binfile -> sdb_addrinfo , fileline , offset_ptr , 0 ) ; } if ( ! dexdump ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; return ; } RListIter * iter2 ; struct dex_debug_position_t * position ; rbin -> cb_printf ( ""positions:\\n"" ) ; r_list_foreach ( debug_positions , iter2 , position ) { rbin -> cb_printf ( ""0x%04llxline=%llu\\n"" , position -> address , position -> line ) ; } rbin -> cb_printf ( ""locals:\\n"" ) ; RListIter * iter3 ; struct dex_debug_local_t * local ; r_list_foreach ( emitted_debug_locals , iter3 , local ) { if ( local -> signature ) { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor , local -> signature ) ; } else { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor ) ; } } for ( reg = 0 ; reg < regsz ; reg ++ ) { if ( debug_locals [ reg ] . live ) { if ( debug_locals [ reg ] . signature ) { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s"" ""%s\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor , debug_locals [ reg ] . signature ) ; } else { rbin -> cb_printf ( ""0x%04x-0x%04xreg=%d%s%s"" ""\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor ) ; } } } r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; }", parameters_size ; } if ( p4 <= 0 ) { return ; }
571,"CWE-362 static int snd_ctl_elem_user_tlv ( struct snd_kcontrol * kcontrol , int op_flag , unsigned int size , unsigned int __user * tlv ) { struct user_element * ue = kcontrol -> private_data ; int change = 0 ; void * new_data ; if ( op_flag > 0 ) { if ( size > 1024 * 128 ) return - EINVAL ; new_data = memdup_user ( tlv , size ) ; if ( IS_ERR ( new_data ) ) return PTR_ERR ( new_data ) ;  change = ue -> tlv_data_size != size ;  if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ; kfree ( ue -> tlv_data ) ; ue -> tlv_data = new_data ; ue -> tlv_data_size = size ;  } else {  if ( ! ue -> tlv_data_size || ! ue -> tlv_data )  return - ENXIO ;   if ( size < ue -> tlv_data_size )   return - ENOSPC ;   if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) )   return - EFAULT ;   }  return change ; }", new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ;  = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;  } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ;  -> tlv_data ) { ret =  - ENXIO ;  - ENXIO ; goto err_unlock ; }  -> tlv_data_size ) { ret =  - ENOSPC ;  - ENOSPC ; goto err_unlock ; }  tlv_data_size ) ) ret =  - EFAULT ;  - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;
572,"CWE-476 static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ;  }  is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""USBMS"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , ""USBMassStorage"" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWDataTransferLength , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; datalen = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWFlags , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTarget , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_ms_dCBWLUN , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; lun = tvb_get_guint8 ( tvb , offset ) & 0x0f ; offset += 1 ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , lun ) ; if ( ! itl ) { itl = wmem_new ( wmem_file_scope ( ) , itl_nexus_t ) ; itl -> cmdset = 0xff ; itl -> conversation = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itl , lun , itl ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { itlq = wmem_new ( wmem_file_scope ( ) , itlq_nexus_t ) ; itlq -> lun = lun ; itlq -> scsi_opcode = 0xffff ; itlq -> task_flags = 0 ; if ( datalen ) { if ( flags & 0x80 ) { itlq -> task_flags |= SCSI_DATA_READ ; } else { itlq -> task_flags |= SCSI_DATA_WRITE ; } } itlq -> data_length = datalen ; itlq -> bidir_data_length = 0 ; itlq -> fc_time = pinfo -> abs_ts ; itlq -> first_exchange_frame = pinfo -> num ; itlq -> last_exchange_frame = 0 ; itlq -> flags = 0 ; itlq -> alloc_len = 0 ; itlq -> extra_data = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itlq , pinfo -> num , itlq ) ; } proto_tree_add_item ( tree , hf_usb_ms_dCBWCBLength , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; cdbrlen = tvb_get_guint8 ( tvb , offset ) & 0x1f ; offset += 1 ; cdblen = cdbrlen ; if ( cdblen > tvb_captured_length_remaining ( tvb , offset ) ) { cdblen = tvb_captured_length_remaining ( tvb , offset ) ; } if ( cdblen ) { cdb_tvb = tvb_new_subset ( tvb , offset , cdblen , cdbrlen ) ; dissect_scsi_cdb ( cdb_tvb , pinfo , parent_tree , SCSI_DEV_UNKNOWN , itlq , itl ) ; } return tvb_captured_length ( tvb ) ; } if ( ( ! is_request ) && ( signature == 0x53425355 ) && ( tvb_reported_length ( tvb ) == 13 ) ) { guint8 status ; proto_tree_add_item ( tree , hf_usb_ms_dCSWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWDataResidue , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWStatus , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; status = tvb_get_guint8 ( tvb , offset ) ; itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itlq -> last_exchange_frame = pinfo -> num ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } if ( ! status ) { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0 ) ; } else { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0x02 ) ; } return tvb_captured_length ( tvb ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } dissect_scsi_payload ( tvb , pinfo , parent_tree , is_request , itlq , itl , 0 ) ; return tvb_captured_length ( tvb ) ; }", = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
573,"CWE-125 static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ;  ND_TCHECK2 ( dp [ 0 ] , 0 ) ;  astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , ""%s"" , tok2str ( sunrpc_str , ""ar_stat%d"" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }", uint32_t ) ; ND_TCHECK  ( dp [  [ 0 ]  ) ; astat
574,"CWE-119  static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {   MACROBLOCK * const x = & cpi -> mb ;   if ( bsize < BLOCK_8X8 ) {  if ( x -> ab_index > 0 ) return ; }  set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;   update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ,  output_enabled ) ;  encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ;  if ( output_enabled ) {  update_stats ( cpi ) ;  ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }"," * const tile , ThreadData * td  , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx  x = & td  -> mb ;  -> mb ;  set_offsets ( cpi  cpi , tile , x  ( cpi , td , ctx  , mi_row ,  encode_superblock ( cpi , td  mi_col , bsize , ctx  { update_stats ( & cpi -> common , td  ) ; ("
575,"CWE-416 static void exif_mnote_data_pentax_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataPentax * n = ( ExifMnoteDataPentax * ) en ; size_t i , tcount , o , datao , base = 0 ; ExifShort c ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 8 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ; return ; } if ( ! memcmp ( buf + datao , ""AOC"" , 4 ) ) { if ( ( buf [ datao + 4 ] == 'I' ) && ( buf [ datao + 5 ] == 'I' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_INTEL ; } else if ( ( buf [ datao + 4 ] == 'M' ) && ( buf [ datao + 5 ] == 'M' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> version = pentaxV2 ; } exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""ParsingPentaxmakernotev%d..."" , ( int ) n -> version ) ; datao += 4 + 2 ; base = MNOTE_PENTAX2_TAG_BASE ; } else if ( ! memcmp ( buf + datao , ""QVC"" , 4 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""ParsingCasiomakernotev2..."" ) ; n -> version = casioV2 ; base = MNOTE_CASIO2_TAG_BASE ; datao += 4 + 2 ; } else { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""ParsingPentaxmakernotev1..."" ) ; n -> version = pentaxV1 ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_pentax_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnotePentaxEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , sizeof ( MnotePentaxEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ;  if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {  exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""ShortMakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnotePentax"" , ""Loadingentry0x%x(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_pentax_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Tagsizeoverflowdetected(%u*%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; break ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""Tagdatapastend"" ""ofbuffer(%u>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }"," size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnotePentaxEntry ) ) ;"
576,"CWE-476 RCMS * r_pkcs7_parse_cms ( const ut8 * buffer , ut32 length ) { RASN1Object * object ; RCMS * container ; if ( ! buffer || ! length ) { return NULL ; } container = R_NEW0 ( RCMS ) ; if ( ! container ) { return NULL ; } object = r_asn1_create_object ( buffer , length ) ;  if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) {  r_asn1_free_object ( object ) ; free ( container ) ; return NULL ; } container -> contentType = r_asn1_stringify_oid ( object -> list . objects [ 0 ] -> sector , object -> list . objects [ 0 ] -> length ) ; r_pkcs7_parse_signeddata ( & container -> signedData , object -> list . objects [ 1 ] -> list . objects [ 0 ] ) ; r_asn1_free_object ( object ) ; return container ; }", list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] ||  object -> list
577,"CWE-17 void fput ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) {  struct task_struct * task = current ;  file_sb_list_del ( file ) ; if ( likely ( ! in_interrupt ( ) && ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & file -> f_u . fu_rcuhead , ____fput ) ; if ( ! task_work_add ( task , & file -> f_u . fu_rcuhead , true ) ) return ; } if ( llist_add ( & file -> f_u . fu_llist , & delayed_fput_list ) ) schedule_work ( & delayed_fput_work ) ; } }", task = current  ; if (
578,"CWE-400 static void exif_data_load_data_content ( ExifData * data , ExifIfd ifd , const unsigned char * d ,  unsigned int ds , unsigned int offset , unsigned int recursion_depth )  { ExifLong o , thumbnail_offset = 0 , thumbnail_length = 0 ; ExifShort n ; ExifEntry * entry ; unsigned int i ; ExifTag tag ; if ( ! data || ! data -> priv ) return ; if ( ( ( ( int ) ifd ) < 0 ) || ( ( ( int ) ifd ) >= EXIF_IFD_COUNT ) ) return ;  if ( recursion_depth > 12 ) {  exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" ,  ""Deeprecursiondetected!"" ) ;  return ; } if ( ( offset + 2 < offset ) || ( offset + 2 < 2 ) || ( offset + 2 > ds ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Tagdatapastendofbuffer(%u>%u)"" , offset + 2 , ds ) ; return ; } n = exif_get_short ( d + offset , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Loading%huentries..."" , n ) ; offset += 2 ; if ( offset + 12 * n > ds ) { n = ( ds - offset ) / 12 ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Shortdata;onlyloading%huentries..."" , n ) ; } for ( i = 0 ; i < n ; i ++ ) { tag = exif_get_short ( d + offset + 12 * i , data -> priv -> order ) ; switch ( tag ) { case EXIF_TAG_EXIF_IFD_POINTER : case EXIF_TAG_GPS_INFO_IFD_POINTER : case EXIF_TAG_INTEROPERABILITY_IFD_POINTER : case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH : case EXIF_TAG_JPEG_INTERCHANGE_FORMAT : o = exif_get_long ( d + offset + 12 * i + 8 , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Sub-IFDentry0x%x(\'%s\')at%u."" , tag , exif_tag_get_name ( tag ) , o ) ; switch ( tag ) { case EXIF_TAG_EXIF_IFD_POINTER : CHECK_REC ( EXIF_IFD_EXIF ) ;  exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_depth + 1 ) ;  break ; case EXIF_TAG_GPS_INFO_IFD_POINTER : CHECK_REC ( EXIF_IFD_GPS ) ;  exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_depth + 1 ) ;  break ; case EXIF_TAG_INTEROPERABILITY_IFD_POINTER : CHECK_REC ( EXIF_IFD_INTEROPERABILITY ) ;  exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_depth + 1 ) ;  break ; case EXIF_TAG_JPEG_INTERCHANGE_FORMAT : thumbnail_offset = o ; if ( thumbnail_offset && thumbnail_length ) exif_data_load_data_thumbnail ( data , d , ds , thumbnail_offset , thumbnail_length ) ; break ; case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH : thumbnail_length = o ; if ( thumbnail_offset && thumbnail_length ) exif_data_load_data_thumbnail ( data , d , ds , thumbnail_offset , thumbnail_length ) ; break ; default : return ; } break ; default : if ( ! exif_tag_get_name_in_ifd ( tag , ifd ) ) { if ( ! memcmp ( d + offset + 12 * i , ""\\0\\0\\0\\0"" , 4 ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Skippingemptyentryatposition%uin\'%s\'."" , i , exif_ifd_get_name ( ifd ) ) ; break ; } exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Unknowntag0x%04x(entry%uin\'%s\').Pleasereportthistag"" ""to<libexif-devel@lists.sourceforge.net>."" , tag , i , exif_ifd_get_name ( ifd ) ) ; if ( data -> priv -> options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS ) break ; } entry = exif_entry_new_mem ( data -> priv -> mem ) ; if ( ! entry ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_NO_MEMORY , ""ExifData"" , ""Couldnotallocatememory"" ) ; return ; } if ( exif_data_load_data_entry ( data , entry , d , ds , offset + 12 * i ) ) exif_content_add_entry ( data -> ifd [ ifd ] , entry ) ; exif_entry_unref ( entry ) ; break ; } } }"," , unsigned int recursion_cost  ) { ExifLong  ; if ( recursion_cost > 170  ) { exif_log  , ""ExifData"" , ""Deep/expensiverecursiondetected!""  ) ; return  , o , recursion_cost + level_cost ( n )  ) ; break  , o , recursion_cost + level_cost ( n )  ) ; break  , o , recursion_cost + level_cost ( n )  ) ; break"
579,"CWE-190 static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) {  int n ;  int ret ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ;  long newbufsize ;  long newpos ; assert ( buf ) ; assert ( cnt >= 0 ) ; JAS_DBGLOG ( 100 , ( ""mem_write(%p,%p,%d)\\n"" , obj , buf , cnt ) ) ; newpos = m -> pos_ + cnt ; if ( newpos > m -> bufsize_ && m -> growable_ ) { newbufsize = m -> bufsize_ ; while ( newbufsize < newpos ) {  newbufsize <<= 1 ;  assert ( newbufsize >= 0 ) ; }  JAS_DBGLOG ( 100 , ( ""mem_writeresizingfrom%dto%z\\n"" , m -> bufsize_ ,  newbufsize ) ) ; JAS_DBGLOG ( 100 , ( ""mem_writeresizingfrom%dto%ul\\n"" , m -> bufsize_ , JAS_CAST ( unsigned long , newbufsize ) ) ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }  if ( m -> pos_ > m -> len_ ) {  n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ; if ( n > 0 ) { memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ; m -> len_ += n ; } if ( m -> pos_ != m -> len_ ) { return 0 ; } } n = m -> bufsize_ - m -> pos_ ; ret = JAS_MIN ( n , cnt ) ; if ( ret > 0 ) { memcpy ( & m -> buf_ [ m -> pos_ ] , buf , ret ) ; m -> pos_ += ret ; } if ( m -> pos_ > m -> len_ ) { m -> len_ = m -> pos_ ; } assert ( ret == cnt ) ; return ret ; }"," cnt ) { size_t  n ; int  ) obj ; size_t newbufsize ; size_t  newpos ; assert  newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) {  JAS_DBGLOG ( 100  100 , ( ""newbuffersizewouldcauseoverflow\\n"" ) ) ;  return - 1  ; } } JAS_DBGLOG ( 100 , ( ""mem_writeresizingfrom%dto%zu\\n"" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }"
580,"CWE-310 static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) goto out_unlock ; error = - EEXIST ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ;  down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;  if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }"," goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;"
581,"CWE-119 static int decompress_i ( AVCodecContext * avctx , uint32_t * dst , int linesize ) { SCPRContext * s = avctx -> priv_data ; GetByteContext * gb = & s -> gb ; int cx = 0 , cx1 = 0 , k = 0 , clr = 0 ; int run , r , g , b , off , y = 0 , x = 0 , z , ret ; unsigned backstep = linesize - avctx -> width ; const int cxshift = s -> cxshift ; unsigned lx , ly , ptype ; reinit_tables ( s ) ; bytestream2_skip ( gb , 2 ) ; init_rangecoder ( & s -> rc , gb ) ; while ( k < avctx -> width + 1 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = b >> cxshift ; ret = decode_value ( s , s -> run_model [ 0 ] , 256 , 400 , & run ) ; if ( ret < 0 ) return ret ; clr = ( b << 16 ) + ( g << 8 ) + r ; k += run ; while ( run -- > 0 ) {  dst [ y * linesize + x ] = clr ;  lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } } off = - linesize - 1 ; ptype = 0 ; while ( x < avctx -> width && y < avctx -> height ) { ret = decode_value ( s , s -> op_model [ ptype ] , 6 , 1000 , & ptype ) ; if ( ret < 0 ) return ret ; if ( ptype == 0 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; clr = ( b << 16 ) + ( g << 8 ) + r ; } if ( ptype > 5 ) return AVERROR_INVALIDDATA ; ret = decode_value ( s , s -> run_model [ ptype ] , 256 , 400 , & run ) ; if ( ret < 0 ) return ret ; switch ( ptype ) { case 0 : while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 1 : while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; dst [ y * linesize + x ] = dst [ ly * linesize + lx ] ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } clr = dst [ ly * linesize + lx ] ; break ; case 2 : while ( run -- > 0 ) { if ( y < 1 || y >= avctx -> height ) return AVERROR_INVALIDDATA ; clr = dst [ y * linesize + x + off + 1 ] ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 4 : while ( run -- > 0 ) { uint8_t * odst = ( uint8_t * ) dst ; if ( y < 1 || y >= avctx -> height || ( y == 1 && x == 0 ) ) return AVERROR_INVALIDDATA ; if ( x == 0 ) { z = backstep ; } else { z = 0 ; } r = odst [ ( ly * linesize + lx ) * 4 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 4 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 ] ; g = odst [ ( ly * linesize + lx ) * 4 + 1 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 5 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 + 1 ] ; b = odst [ ( ly * linesize + lx ) * 4 + 2 ] + odst [ ( ( y * linesize + x ) + off - z ) * 4 + 6 ] - odst [ ( ( y * linesize + x ) + off - z ) * 4 + 2 ] ; clr = ( ( b & 0xFF ) << 16 ) + ( ( g & 0xFF ) << 8 ) + ( r & 0xFF ) ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; case 5 : while ( run -- > 0 ) { if ( y < 1 || y >= avctx -> height || ( y == 1 && x == 0 ) ) return AVERROR_INVALIDDATA ; if ( x == 0 ) { z = backstep ; } else { z = 0 ; } clr = dst [ y * linesize + x + off - z ] ; dst [ y * linesize + x ] = clr ; lx = x ; ly = y ; x ++ ; if ( x >= avctx -> width ) { x = 0 ; y ++ ; } } break ; } if ( avctx -> bits_per_coded_sample == 16 ) { cx1 = ( clr & 0x3F00 ) >> 2 ; cx = ( clr & 0xFFFFFF ) >> 16 ; } else { cx1 = ( clr & 0xFC00 ) >> 4 ; cx = ( clr & 0xFFFFFF ) >> 18 ; } } return 0 ; }", 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
582,"CWE-295  int bind_ports ( void ) {  SERVICE_OPTIONS * opt ; int listening_section ; # ifdef USE_LIBWRAP libwrap_init ( ) ; # endif s_poll_init ( fds , 1 ) ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { unsigned i ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) opt -> local_fd [ i ] = INVALID_SOCKET ; } listening_section = 0 ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { opt -> bound_ports = 0 ; if ( opt -> local_addr . num ) { unsigned i ; s_log ( LOG_DEBUG , ""Bindingservice[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) { SOCKET fd ; fd = bind_port ( opt , listening_section , i ) ; opt -> local_fd [ i ] = fd ; if ( fd != INVALID_SOCKET ) { s_poll_add ( fds , fd , 1 , 0 ) ; ++ opt -> bound_ports ; } } if ( ! opt -> bound_ports ) { s_log ( LOG_ERR , ""Bindingservice[%s]failed"" , opt -> servname ) ; return 1 ; } ++ listening_section ; } else if ( opt -> exec_name && opt -> connect_addr . names ) { s_log ( LOG_DEBUG , ""Skippedexec+connectservice[%s]"" , opt -> servname ) ; # ifndef OPENSSL_NO_TLSEXT } else if ( ! opt -> option . client && opt -> sni ) { s_log ( LOG_DEBUG , ""SkippedSNIslaveservice[%s]"" , opt -> servname ) ; # endif } else { s_log ( LOG_ERR , ""Invalidservice[%s]"" , opt -> servname ) ; return 1 ; } } if ( listening_section < systemd_fds ) { s_log ( LOG_ERR , ""Toomanylisteningfiledescriptorsreceivedfromsystemd,got%d"" , systemd_fds ) ; return 1 ; } return 0 ; }",    NOEXPORT
583,"CWE-787 void sec_decrypt ( uint8 * data , int length )  {  if ( g_sec_decrypt_use_count == 4096 ) { sec_update ( g_sec_decrypt_key , g_sec_decrypt_update_key ) ; rdssl_rc4_set_key ( & g_rc4_decrypt_key , g_sec_decrypt_key , g_rc4_key_len ) ; g_sec_decrypt_use_count = 0 ; } rdssl_rc4_crypt ( & g_rc4_decrypt_key , data , data , length ) ; g_sec_decrypt_use_count ++ ; }", length ) { if ( length <= 0 ) return ;
584,"CWE-190 bool copyaudiodata ( AFfilehandle infile , AFfilehandle outfile , int trackid ) { int frameSize = afGetVirtualFrameSize ( infile , trackid , 1 ) ;  const int kBufferFrameCount = 65536 ;   void * buffer = malloc ( kBufferFrameCount * frameSize ) ;  AFframecount totalFrames = afGetFrameCount ( infile , AF_DEFAULT_TRACK ) ; AFframecount totalFramesWritten = 0 ; bool success = true ; while ( totalFramesWritten < totalFrames ) { AFframecount framesToRead = totalFrames - totalFramesWritten ; if ( framesToRead > kBufferFrameCount ) framesToRead = kBufferFrameCount ; AFframecount framesRead = afReadFrames ( infile , trackid , buffer , framesToRead ) ; if ( framesRead < framesToRead ) { fprintf ( stderr , ""Badreadofaudiotrackdata.\\n"" ) ; success = false ; break ; } AFframecount framesWritten = afWriteFrames ( outfile , trackid , buffer , framesRead ) ; if ( framesWritten < framesRead ) { fprintf ( stderr , ""Badwriteofaudiotrackdata.\\n"" ) ; success = false ; break ; } totalFramesWritten += framesWritten ; } free ( buffer ) ; return success ; }"," 1 ) ;  int kBufferFrameCount =  kBufferFrameCount = 65536 ; int bufferSize ; while ( multiplyCheckOverflow ( kBufferFrameCount , frameSize , & bufferSize ) ) kBufferFrameCount /= 2  = malloc ( bufferSize  ) ; AFframecount"
585,"CWE-399 struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return NULL ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , GFP_KERNEL ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ;  }  return new_fpl ; }", -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;
586,"CWE-119 void vpx_scale_frame ( YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst , unsigned char * temp_area , unsigned char temp_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i ; int dw = ( hscale - 1 + src -> y_width * hratio ) / hscale ; int dh = ( vscale - 1 + src -> y_height * vratio ) / vscale ; Scale2D ( ( unsigned char * ) src -> y_buffer , src -> y_stride , src -> y_width , src -> y_height , ( unsigned char * ) dst -> y_buffer , dst -> y_stride , dw , dh , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw < ( int ) dst -> y_width ) for ( i = 0 ; i < dh ; i ++ )  vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ;  if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ; i < ( int ) dst -> y_height ; i ++ )  vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ;  Scale2D ( ( unsigned char * ) src -> u_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> u_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw / 2 < ( int ) dst -> uv_width ) for ( i = 0 ; i < dst -> uv_height ; i ++ )  vpx_memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ;  if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ; i < ( int ) dst -> y_height / 2 ; i ++ )  vpx_memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ;  Scale2D ( ( unsigned char * ) src -> v_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> v_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw / 2 < ( int ) dst -> uv_width ) for ( i = 0 ; i < dst -> uv_height ; i ++ )  vpx_memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ;  if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ; i < ( int ) dst -> y_height / 2 ; i ++ )  vpx_memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ;  }", i ++ ) memset  ( dst ->  i ++ ) memcpy  ( dst ->  i ++ ) memset  ( dst ->  i ++ ) memcpy  ( dst ->  i ++ ) memset  ( dst ->  i ++ ) memcpy  ( dst ->
587,"CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { ""date-time-at-completed"" , ""date-time-at-creation"" , ""date-time-at-processing"" , ""job-detailed-status-messages"" , ""job-document-access-errors"" , ""job-id"" , ""job-impressions-completed"" , ""job-k-octets-completed"" , ""job-media-sheets-completed"" , ""job-pages-completed"" , ""job-printer-up-time"" , ""job-printer-uri"" , ""job-state"" , ""job-state-message"" , ""job-state-reasons"" , ""job-uri"" , ""number-of-documents"" , ""number-of-intervening-jobs"" , ""output-device-assigned"" , ""time-at-completed"" , ""time-at-creation"" , ""time-at-processing"" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , ""add_job(%p[%d],%p(%s),%p(%s/%s))"" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : ""none"" , filetype ? filetype -> type : ""none"" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , ""localhost"" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""Theprinterorclassisnotshared."" ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , ""auth-info"" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return ( NULL ) ; } else if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , ""negotiate"" ) && ! con -> username [ 0 ] ) { send_http_error ( con , HTTP_UNAUTHORIZED , printer ) ; return ( NULL ) ; } # ifdef HAVE_SSL else if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) ) { send_http_error ( con , HTTP_UPGRADE_REQUIRED , printer ) ; return ( NULL ) ; } # endif if ( ! printer -> accepting ) { send_ipp_status ( con , IPP_NOT_ACCEPTING , _ ( ""Destination\\""%s\\""isnotacceptingjobs."" ) , printer -> name ) ; return ( NULL ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( readonly ) / sizeof ( readonly [ 0 ] ) ) ; i ++ ) { if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL ) { ippDeleteAttribute ( con -> request , attr ) ; if ( StrictConformance ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""The\'%s\'JobStatusattributecannotbesuppliedinajobcreationrequest."" ) , readonly [ i ] ) ; return ( NULL ) ; } cupsdLogMessage ( CUPSD_LOG_INFO , ""Unexpected\'%s\'JobStatusattributeinajobcreationrequest."" , readonly [ i ] ) ; } } if ( printer -> pc ) { for ( mandatory = ( char * ) cupsArrayFirst ( printer -> pc -> mandatory ) ; mandatory ; mandatory = ( char * ) cupsArrayNext ( printer -> pc -> mandatory ) ) { if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) ) { send_ipp_status ( con , IPP_CONFLICT , _ ( ""The\\""%s\\""attributeisrequiredforprintjobs."" ) , mandatory ) ; return ( NULL ) ; } } } if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) ) { char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; snprintf ( mimetype , sizeof ( mimetype ) , ""%s/%s"" , filetype -> super , filetype -> type ) ; send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( ""Unsupportedformat\\""%s\\""."" ) , mimetype ) ; ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , ""document-format"" , NULL , mimetype ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""copies"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badcopiesvalue%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""copies"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Badjob-sheetsvaluetype."" ) ) ; return ( NULL ) ; } if ( attr -> num_values > 2 ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Toomanyjob-sheetsvalues(%d>2)."" ) , attr -> num_values ) ; return ( NULL ) ; } for ( i = 0 ; i < attr -> num_values ; i ++ ) if ( strcmp ( attr -> values [ i ] . string . text , ""none"" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Badjob-sheetsvalue\\""%s\\""."" ) , attr -> values [ i ] . string . text ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""number-up"" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badnumber-upvalue%d."" ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , ""number-up"" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , ""page-ranges"" , IPP_TAG_RANGE ) ) != NULL ) { for ( i = 0 , lowerpagerange = 1 ; i < attr -> num_values ; i ++ ) { if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( ""Badpage-rangesvalues%d-%d."" ) , attr -> values [ i ] . range . lower , attr -> values [ i ] . range . upper ) ; return ( NULL ) ; } lowerpagerange = attr -> values [ i ] . range . upper + 1 ; } } if ( ! ippFindAttribute ( con -> request , ""PageRegion"" , IPP_TAG_ZERO ) && ! ippFindAttribute ( con -> request , ""PageSize"" , IPP_TAG_ZERO ) && _ppdCacheGetPageSize ( printer -> pc , con -> request , NULL , & exact ) ) { if ( ! exact && ( media_col = ippFindAttribute ( con -> request , ""media-col"" , IPP_TAG_BEGIN_COLLECTION ) ) != NULL ) { send_ipp_status ( con , IPP_OK_SUBST , _ ( ""Unsupportedmargins."" ) ) ; unsup_col = ippNew ( ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-bottom-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-bottom-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-left-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-left-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-right-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-right-margin"" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , ""media-top-margin"" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , ""media-top-margin"" , media_margin -> values [ 0 ] . integer ) ; ippAddCollection ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , ""media-col"" , unsup_col ) ; ippDelete ( unsup_col ) ; } } if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) cupsdCleanJobs ( ) ; if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Toomanyactivejobs."" ) ) ; return ( NULL ) ; } if ( ( i = check_quotas ( con , printer ) ) < 0 ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( ""Quotalimitreached."" ) ) ; return ( NULL ) ; } else if ( i == 0 ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( ""Notallowedtoprint."" ) ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-priority"" , IPP_TAG_INTEGER ) ) != NULL ) priority = attr -> values [ 0 ] . integer ; else { if ( ( val = cupsGetOption ( ""job-priority"" , printer -> num_options , printer -> options ) ) != NULL ) priority = atoi ( val ) ; else priority = 50 ; ippAddInteger ( con -> request , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-priority"" , priority ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_ZERO ) ) == NULL ) ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_NAME , ""job-name"" , NULL , ""Untitled"" ) ; else if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badjob-namevalue:Wrongtypeorcount."" ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } else if ( ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badjob-namevalue:%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; }  if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  { send_ipp_status ( con , IPP_INTERNAL_ERROR , _ ( ""Unabletoaddjobfordestination\\""%s\\""."" ) , printer -> name ) ; return ( NULL ) ; } job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ) ; job -> attrs = con -> request ; job -> dirty = 1 ; con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ) ; cupsdMarkDirty ( CUPSD_DIRTY_JOBS ) ; add_job_uuid ( job ) ;  apply_printer_defaults ( printer , job ) ;  attr = ippFindAttribute ( job -> attrs , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( con -> username [ 0 ] ) { cupsdSetString ( & job -> username , con -> username ) ; if ( attr ) ippSetString ( job -> attrs , & attr , 0 , con -> username ) ; } else if ( attr ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""add_job:requesting-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text ) ; cupsdSetString ( & job -> username , attr -> values [ 0 ] . string . text ) ; } else cupsdSetString ( & job -> username , ""anonymous"" ) ; if ( ! attr ) ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-user-name"" , NULL , job -> username ) ; else { ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; ippSetName ( job -> attrs , & attr , ""job-originating-user-name"" ) ; } if ( con -> username [ 0 ] || auth_info ) { save_auth_info ( con , job , auth_info ) ; if ( auth_info ) ippDeleteAttribute ( job -> attrs , auth_info ) ; } if ( ( attr = ippFindAttribute ( con -> request , ""job-name"" , IPP_TAG_NAME ) ) != NULL ) cupsdSetString ( & ( job -> name ) , attr -> values [ 0 ] . string . text ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-originating-host-name"" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , ""localhost"" ) ) { ippDeleteAttribute ( job -> attrs , attr ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } else ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; } else { ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-originating-host-name"" , NULL , con -> http -> hostname ) ; } ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-completed"" ) ; ippAddDate ( job -> attrs , IPP_TAG_JOB , ""date-time-at-creation"" , ippTimeToDate ( time ( NULL ) ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""date-time-at-processing"" ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-completed"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""time-at-creation"" , time ( NULL ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , ""time-at-processing"" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , IPP_JOB_STOPPED ) ; job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer ; job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , ""job-incoming"" ) ; job -> impressions = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-impressions-completed"" , 0 ) ; job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-media-sheets-completed"" , 0 ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_URI , ""job-printer-uri"" , NULL , printer -> uri ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-k-octets"" , IPP_TAG_INTEGER ) ) != NULL ) attr -> values [ 0 ] . integer = 0 ; else ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-k-octets"" , 0 ) ; if ( ( attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_KEYWORD ) ) == NULL ) attr = ippFindAttribute ( job -> attrs , ""job-hold-until"" , IPP_TAG_NAME ) ; if ( ! attr ) { if ( ( val = cupsGetOption ( ""job-hold-until"" , printer -> num_options , printer -> options ) ) == NULL ) val = ""no-hold"" ; attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-hold-until"" , NULL , val ) ; } if ( printer -> holding_new_jobs ) { if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) cupsdSetJobHoldUntil ( job , ippGetString ( attr , 0 , NULL ) , 0 ) ; else cupsdSetJobHoldUntil ( job , ""indefinite"" , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-held-on-create"" ) ; } else if ( attr && strcmp ( attr -> values [ 0 ] . string . text , ""no-hold"" ) ) { cupsdSetJobHoldUntil ( job , attr -> values [ 0 ] . string . text , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""job-hold-until-specified"" ) ; } else if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB ) { job -> hold_until = time ( NULL ) + MultipleOperationTimeout ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; } else { job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING ; job -> state_value = IPP_JOB_PENDING ; ippSetString ( job -> attrs , & job -> reasons , 0 , ""none"" ) ; } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification ) { if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) == NULL ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , ""Addingdefaultjob-sheetsvalues\\""%s,%s\\""..."" , printer -> job_sheets [ 0 ] , printer -> job_sheets [ 1 ] ) ; attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , ""job-sheets"" , 2 , NULL , NULL ) ; ippSetString ( job -> attrs , & attr , 0 , printer -> job_sheets [ 0 ] ) ; ippSetString ( job -> attrs , & attr , 1 , printer -> job_sheets [ 1 ] ) ; } job -> job_sheets = attr ; if ( Classification ) { cupsdLogMessage ( CUPSD_LOG_INFO , ""Classification=\\""%s\\"",ClassifyOverride=%d"" , Classification ? Classification : ""(null)"" , ClassifyOverride ) ; if ( ClassifyOverride ) { if ( ! strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s,none\\"","" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } else if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) { ippSetString ( job -> attrs , & attr , 1 , attr -> values [ 0 ] . string . text ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s,%s\\"","" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ) ) { if ( attr -> num_values == 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONOVERRIDDEN"" ""job-sheets=\\""%s\\"","" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONOVERRIDDEN"" ""job-sheets=\\""%s,%s\\"",fffff"" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) ) { if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } else { if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 0 , Classification ) ; if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , ""none"" ) ) ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } if ( attr -> num_values > 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s,%s\\"","" ""job-originating-user-name=\\""%s\\"""" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , ""CLASSIFICATIONFORCED"" ""job-sheets=\\""%s\\"","" ""job-originating-user-name=\\""%s\\"""" , Classification , job -> username ) ; } } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) ) { cupsdLogJob ( job , CUPSD_LOG_INFO , ""Addingstartbannerpage\\""%s\\""."" , attr -> values [ 0 ] . string . text ) ; if ( ( kbytes = copy_banner ( con , job , attr -> values [ 0 ] . string . text ) ) < 0 ) { cupsdSetJobState ( job , IPP_JOB_ABORTED , CUPSD_JOB_PURGE , ""Abortingjobbecausethestartbannercouldnotbe"" ""copied."" ) ; return ( NULL ) ; } cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ) ; } } else if ( ( attr = ippFindAttribute ( job -> attrs , ""job-sheets"" , IPP_TAG_ZERO ) ) != NULL ) job -> job_sheets = attr ; httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , ""ipp"" , NULL , con -> clientname , con -> clientport , ""/jobs/%d"" , job -> id ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , ""job-uri"" , NULL , job_uri ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , ""job-id"" , job -> id ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , ""job-state"" , job -> state_value ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_TEXT , ""job-state-message"" , NULL , """" ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , ""job-state-reasons"" , NULL , job -> reasons -> values [ 0 ] . string . text ) ; con -> response -> request . status . status_code = IPP_OK ; add_job_subscriptions ( con , job ) ; for ( attr = job -> attrs -> attrs -> next -> next ; attr ; attr = attr -> next ) attr -> group_tag = IPP_TAG_JOB ; cupsdAddEvent ( CUPSD_EVENT_JOB_CREATED , printer , job , ""Jobcreated."" ) ; return ( job ) ; }"," ) ; } attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Badrequesting-user-namevalue:%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; }  printer , job  ) ; if"
588,"CWE-284 int vfs_open ( const struct path * path , struct file * file , const struct cred * cred ) {  struct dentry * dentry = path -> dentry ;   struct inode * inode = dentry -> d_inode ;  file -> f_path = * path ; if ( dentry -> d_flags & DCACHE_OP_SELECT_INODE ) { inode = dentry -> d_op -> d_select_inode ( dentry , file -> f_flags ) ; if ( IS_ERR ( inode ) ) return PTR_ERR ( inode ) ;  }  return do_dentry_open ( file , inode , NULL , cred ) ; }"," ) { struct  inode * inode  * inode = vfs_select_inode ( path ->  dentry , file  inode ) ; file -> f_path = * path ;  return do_dentry_open ("
589,"CWE-119  static inline bool unconditional ( const struct ip6t_ip6 * ipv6 )  { static const struct ip6t_ip6 uncond ;  return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ;  }"," ( const struct ip6t_entry * e  ) { static  uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e ->  ipv6 , &"
590,"CWE-401 int htc_connect_service ( struct htc_target * target , struct htc_service_connreq * service_connreq , enum htc_endpoint_id * conn_rsp_epid ) { struct sk_buff * skb ; struct htc_endpoint * endpoint ; struct htc_conn_svc_msg * conn_msg ; int ret ; unsigned long time_left ; endpoint = get_next_avail_ep ( target -> endpoint ) ; if ( ! endpoint ) { dev_err ( target -> dev , ""Endpointisnotavailableforservice%d\\n"" , service_connreq -> service_id ) ; return - EINVAL ; } endpoint -> service_id = service_connreq -> service_id ; endpoint -> max_txqdepth = service_connreq -> max_send_qdepth ; endpoint -> ul_pipeid = service_to_ulpipe ( service_connreq -> service_id ) ; endpoint -> dl_pipeid = service_to_dlpipe ( service_connreq -> service_id ) ; endpoint -> ep_callbacks = service_connreq -> ep_callbacks ; skb = alloc_skb ( sizeof ( struct htc_conn_svc_msg ) + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , ""Failedtoallocatebuftosend"" ""serviceconnectreq\\n"" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; conn_msg = skb_put ( skb , sizeof ( struct htc_conn_svc_msg ) ) ; conn_msg -> service_id = cpu_to_be16 ( service_connreq -> service_id ) ; conn_msg -> msg_id = cpu_to_be16 ( HTC_MSG_CONNECT_SERVICE_ID ) ; conn_msg -> con_flags = cpu_to_be16 ( service_connreq -> con_flags ) ; conn_msg -> dl_pipeid = endpoint -> dl_pipeid ; conn_msg -> ul_pipeid = endpoint -> ul_pipeid ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret ) goto err ; time_left = wait_for_completion_timeout ( & target -> cmd_wait , HZ ) ; if ( ! time_left ) { dev_err ( target -> dev , ""Serviceconnectiontimeoutfor:%d\\n"" , service_connreq -> service_id ) ;  return - ETIMEDOUT ;  } * conn_rsp_epid = target -> conn_rsp_epid ; return 0 ; err : kfree_skb ( skb ) ; return ret ; }", service_id ) ; kfree_skb ( skb ) ;
591,"CWE-119 static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) {  int ret ;  ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data ,  indx , & data , 1 , 1000 ) ;  if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%sreturned%d\\n"" , __func__ , ret ) ;  return ret ;  }"," data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM  ; ret =  , indx , buf  , 1 ,  ret ) ; kfree ( buf ) ;"
592,"CWE-835 G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ;  static gboolean  accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( ""GsmXsmpServer:accept_ice_connection()"" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( ""GsmXsmpServer:IceAcceptConnectionreturned%d"" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ;  ice_conn -> context = client ;  gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }"," } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection  ( ice_conn )  ice_conn ) ;  }  "
593,"CWE-189 static void tcp_cwnd_reduction ( struct sock * sk , const int prior_unsacked , int fast_rexmit , int flag ) { struct tcp_sock * tp = tcp_sk ( sk ) ; int sndcnt = 0 ; int delta = tp -> snd_ssthresh - tcp_packets_in_flight ( tp ) ; int newly_acked_sacked = prior_unsacked - ( tp -> packets_out - tp -> sacked_out ) ;  tp -> prr_delivered += newly_acked_sacked ;  if ( delta < 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend , tp -> prior_cwnd ) - tp -> prr_out ; } else if ( ( flag & FLAG_RETRANS_DATA_ACKED ) && ! ( flag & FLAG_LOST_RETRANS ) ) { sndcnt = min_t ( int , delta , max_t ( int , tp -> prr_delivered - tp -> prr_out , newly_acked_sacked ) + 1 ) ; } else { sndcnt = min ( delta , newly_acked_sacked ) ; } sndcnt = max ( sndcnt , ( fast_rexmit ? 1 : 0 ) ) ; tp -> snd_cwnd = tcp_packets_in_flight ( tp ) + sndcnt ; }", sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
594,"CWE-125 void cisco_autorp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) { int type ; int numrps ; int hold ;  ND_TCHECK ( bp [ 0 ] ) ;  ND_PRINT ( ( ndo , ""auto-rp"" ) ) ; type = bp [ 0 ] ; switch ( type ) { case 0x11 : ND_PRINT ( ( ndo , ""candidate-advert"" ) ) ; break ; case 0x12 : ND_PRINT ( ( ndo , ""mapping"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""type-0x%02x"" , type ) ) ; break ; } ND_TCHECK ( bp [ 1 ] ) ; numrps = bp [ 1 ] ; ND_TCHECK2 ( bp [ 2 ] , 2 ) ; ND_PRINT ( ( ndo , ""Hold"" ) ) ; hold = EXTRACT_16BITS ( & bp [ 2 ] ) ; if ( hold ) unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; else ND_PRINT ( ( ndo , ""FOREVER"" ) ) ; bp += 8 ; len -= 8 ; while ( numrps -- ) { int nentries ; char s ;  ND_TCHECK2 ( bp [ 0 ] , 4 ) ;  ND_PRINT ( ( ndo , ""RP%s"" , ipaddr_string ( ndo , bp ) ) ) ;  ND_TCHECK ( bp [ 4 ] ) ;   switch ( bp [ 4 ] & 0x3 ) {  case 0 : ND_PRINT ( ( ndo , ""PIMv?"" ) ) ; break ; case 1 : ND_PRINT ( ( ndo , ""PIMv1"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""PIMv2"" ) ) ; break ; case 3 : ND_PRINT ( ( ndo , ""PIMv1+2"" ) ) ; break ; }  if ( bp [ 4 ] & 0xfc )   ND_PRINT ( ( ndo , ""[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ;   ND_TCHECK ( bp [ 5 ] ) ;   nentries = bp [ 5 ] ;   bp += 6 ; len -= 6 ;  s = '' ; for ( ; nentries ; nentries -- ) {  ND_TCHECK2 ( bp [ 0 ] , 6 ) ;  ND_PRINT ( ( ndo , ""%c%s%s/%d"" , s , bp [ 0 ] & 1 ? ""!"" : """" , ipaddr_string ( ndo , & bp [ 2 ] ) , bp [ 1 ] ) ) ; if ( bp [ 0 ] & 0x02 ) { ND_PRINT ( ( ndo , ""bidir"" ) ) ; } if ( bp [ 0 ] & 0xfc ) { ND_PRINT ( ( ndo , ""[rsvd=0x%02x]"" , bp [ 0 ] & 0xfc ) ) ; } s = ',' ; bp += 6 ; len -= 6 ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|autorp]"" ) ) ; return ; }"," int hold ; if ( len < 8 ) goto trunc ;  char s ; if ( len < 4 ) goto trunc ;  ) ) ; bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ;  ( bp [ 0  ] ) ;  ( bp [ 0  ] & 0x3  ( bp [ 0  ] & 0xfc  , bp [ 0  ] & 0xfc  ) ) ; bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ;  ( bp [ 0  ] ) ;  = bp [ 0  ] ; bp  ; bp += 1 ; len -= 1  ; s =  -- ) { if ( len < 6 ) goto trunc ;"
595,"CWE-787 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; greedy_check : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_NON_GREEDY ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 0 ; tok -> u . repeat . possessive = 0 ; } else { possessive_check : if ( ! PEND && PPEEK_IS ( '+' ) && ( ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT ) && tok -> type != TK_INTERVAL ) || ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL ) && tok -> type == TK_INTERVAL ) ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 1 ; } else { tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 0 ; } } break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case 'w' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 0 ; break ; case 'W' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 1 ; break ; case 'b' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_BOUND ; break ; case 'B' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_NOT_WORD_BOUND ; break ; # ifdef USE_WORD_BEGIN_END case '<' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_BEGIN ; break ; case '>' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_END ; break ; # endif case 's' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 0 ; break ; case 'S' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 1 ; break ; case 'd' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 0 ; break ; case 'D' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 1 ; break ; case 'h' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 0 ; break ; case 'H' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 1 ; break ; case 'A' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; begin_buf : tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_BEGIN_BUF ; break ; case 'Z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_SEMI_END_BUF ; break ; case 'z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; end_buf : tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_END_BUF ; break ; case 'G' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_BEGIN_POSITION ; break ; case '`' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto begin_buf ; break ; case '\\'' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto end_buf ; break ; case 'x' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { PINC ; num = scan_unsigned_hexadecimal_number ( & p , end , 8 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { if ( ONIGENC_IS_CODE_XDIGIT ( enc , PPEEK ) ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 2 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 16 ; tok -> u . c = num ; } break ; case 'u' : if ( PEND ) break ; prev = p ; if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 4 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : PUNFETCH ; prev = p ; num = onig_scan_unsigned_number ( & p , end , enc ) ; if ( num < 0 || num > ONIG_MAX_BACKREF_NUM ) { goto skip_backref ; } if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DECIMAL_BACKREF ) && ( num <= env -> num_mem || num <= 9 ) ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = num ; tok -> u . backref . by_name = 0 ; # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level = 0 ; # endif break ; } skip_backref : if ( c == '8' || c == '9' ) { p = prev ; PINC ; break ; } p = prev ; case '0' : if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ;  if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;  if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 8 ; tok -> u . c = num ; } else if ( c != '0' ) { PINC ; } break ; # ifdef USE_NAMED_GROUP case 'k' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_K_NAMED_BACKREF ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { UChar * name_end ; int * backs ; int back_num ; prev = p ; # ifdef USE_BACKREF_WITH_LEVEL name_end = NULL_UCHARP ; r = fetch_name_with_level ( ( OnigCodePoint ) c , & p , end , & name_end , env , & back_num , & tok -> u . backref . level ) ; if ( r == 1 ) tok -> u . backref . exist_level = 1 ; else tok -> u . backref . exist_level = 0 ; # else r = fetch_name ( & p , end , & name_end , env , & back_num , 1 ) ; # endif if ( r < 0 ) return r ; if ( back_num != 0 ) { if ( back_num < 0 ) { back_num = BACKREF_REL_TO_ABS ( back_num , env ) ; if ( back_num <= 0 ) return ONIGERR_INVALID_BACKREF ; } if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( back_num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ back_num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . by_name = 0 ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = back_num ; } else { num = onig_name_to_group_numbers ( env -> reg , prev , name_end , & backs ) ; if ( num <= 0 ) { onig_scan_env_set_error_string ( env , ONIGERR_UNDEFINED_NAME_REFERENCE , prev , name_end ) ; return ONIGERR_UNDEFINED_NAME_REFERENCE ; } if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { int i ; for ( i = 0 ; i < num ; i ++ ) { if ( backs [ i ] > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ backs [ i ] ] ) ) return ONIGERR_INVALID_BACKREF ; } } tok -> type = TK_BACKREF ; tok -> u . backref . by_name = 1 ; if ( num == 1 ) { tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = backs [ 0 ] ; } else { tok -> u . backref . num = num ; tok -> u . backref . refs = backs ; } } } else PUNFETCH ; } break ; # endif # ifdef USE_SUBEXP_CALL case 'g' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_SUBEXP_CALL ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { int gnum ; UChar * name_end ; prev = p ; r = fetch_name ( ( OnigCodePoint ) c , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = prev ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; } else PUNFETCH ; } break ; # endif case 'Q' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE ) ) { tok -> type = TK_QUOTE_OPEN ; } break ; case 'p' : case 'P' : if ( ! PEND && PPEEK_IS ( '{' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { PINC ; tok -> type = TK_CHAR_PROPERTY ; tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { PFETCH ( c ) ; if ( c == '^' ) { tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; } else PUNFETCH ; } } break ; default : { OnigCodePoint c2 ; PUNFETCH ; num = fetch_escaped_value ( & p , end , env , & c2 ) ; if ( num < 0 ) return num ; if ( tok -> u . c != c2 ) { tok -> type = TK_CODE_POINT ; tok -> u . code = c2 ; } else { p = tok -> backp + enclen ( enc , tok -> backp ) ; } } break ; } } else { tok -> u . c = c ; tok -> escaped = 0 ; # ifdef USE_VARIABLE_META_CHARS if ( ( c != ONIG_INEFFECTIVE_META_CHAR ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VARIABLE_META_CHARACTERS ) ) { if ( c == MC_ANYCHAR ( syn ) ) goto any_char ; else if ( c == MC_ANYTIME ( syn ) ) goto anytime ; else if ( c == MC_ZERO_OR_ONE_TIME ( syn ) ) goto zero_or_one_time ; else if ( c == MC_ONE_OR_MORE_TIME ( syn ) ) goto one_or_more_time ; else if ( c == MC_ANYCHAR_ANYTIME ( syn ) ) { tok -> type = TK_ANYCHAR_ANYTIME ; goto out ; } } # endif switch ( c ) { case '.' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DOT_ANYCHAR ) ) break ; # ifdef USE_VARIABLE_META_CHARS any_char : # endif tok -> type = TK_ANYCHAR ; break ; case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ASTERISK_ZERO_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS anytime : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_PLUS_ONE_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS one_or_more_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_ZERO_ONE ) ) break ; # ifdef USE_VARIABLE_META_CHARS zero_or_one_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; goto greedy_check ; break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_QMARK_GROUP_EFFECT ) ) { PINC ; if ( ! PEND && PPEEK_IS ( '#' ) ) { PFETCH ( c ) ; while ( 1 ) { if ( PEND ) return ONIGERR_END_PATTERN_IN_GROUP ; PFETCH ( c ) ; if ( c == MC_ESC ( syn ) ) { if ( ! PEND ) PFETCH ( c ) ; } else { if ( c == ')' ) break ; } } goto start ; } PUNFETCH ; } if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case '^' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE ) ; break ; case '$' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE ) ; break ; case '[' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACKET_CC ) ) break ; tok -> type = TK_CC_OPEN ; break ; case ']' : if ( * src > env -> pattern ) CLOSE_BRACKET_WITHOUT_ESC_WARN ( env , ( UChar * ) ""]"" ) ; break ; case '#' : if ( IS_EXTEND ( env -> option ) ) { while ( ! PEND ) { PFETCH ( c ) ; if ( ONIGENC_IS_CODE_NEWLINE ( enc , c ) ) break ; } goto start ; break ; } break ; case '' : case '\\t' : case '\\n' : case '\\r' : case '\\f' : if ( IS_EXTEND ( env -> option ) ) goto start ; break ; default : break ; } } # ifdef USE_VARIABLE_META_CHARS out : # endif * src = p ; return tok -> type ; }", num < 0 || num >= 256
596,"CWE-264 static int em_call ( struct x86_emulate_ctxt * ctxt )  {  long rel = ctxt -> src . val ; ctxt -> src . val = ( unsigned long ) ctxt -> _eip ;  jmp_rel ( ctxt , rel ) ;  return em_push ( ctxt ) ; }"," ctxt ) { int rc ;  -> _eip ; rc =  , rel ) ; if ( rc != X86EMUL_CONTINUE ) return rc"
597,"CWE-000 static void nfs4_close_prepare ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; int clear_rd , clear_wr , clear_rdwr ; if ( nfs_wait_on_sequence ( calldata -> arg . seqid , task ) != 0 ) return ; clear_rd = clear_wr = clear_rdwr = 0 ; spin_lock ( & state -> owner -> so_lock ) ; if ( state -> n_rdwr == 0 ) { if ( state -> n_rdonly == 0 ) { clear_rd |= test_and_clear_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ; clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( state -> n_wronly == 0 ) { clear_wr |= test_and_clear_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ; clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } } spin_unlock ( & state -> owner -> so_lock ) ; if ( ! clear_rd && ! clear_wr && ! clear_rdwr ) { task -> tk_action = NULL ; return ; } nfs_fattr_init ( calldata -> res . fattr ) ; if ( test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ;  calldata -> arg . open_flags = FMODE_READ ;  } else if ( test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) != 0 ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ;  calldata -> arg . open_flags = FMODE_WRITE ;  } calldata -> timestamp = jiffies ; rpc_call_start ( task ) ; }", -> arg . fmode  = FMODE_READ ;  -> arg . fmode  = FMODE_WRITE ;
598,"CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ;  int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ;  aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }", * aVTrans ; sqlite3_int64  nBytes = sizeof  ) * ( ( sqlite3_int64 )
599,CWE-254  static void follow_dotdot ( struct nameidata * nd )  { if ( ! nd -> root . mnt ) set_root ( nd ) ; while ( 1 ) { struct dentry * old = nd -> path . dentry ; if ( nd -> path . dentry == nd -> root . dentry && nd -> path . mnt == nd -> root . mnt ) { break ; } if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { nd -> path . dentry = dget_parent ( nd -> path . dentry ) ; dput ( old ) ;  break ;  } if ( ! follow_up ( & nd -> path ) ) break ; } follow_mount ( & nd -> path ) ; nd -> inode = nd -> path . dentry -> d_inode ;  } ,   static int  follow_dotdot ( struct  old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;  -> d_inode ; return 0 ;
600,CWE-399 static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ;  update_db_bp_intercept ( vcpu ) ;  }, X86_EFLAGS_RF ) ;  }  
601,"CWE-416 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ;  nd -> last_type = LAST_BIND ;  out : return ERR_PTR ( error ) ; }", path ) ;  out : return
602,"CWE-400 int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; } used = recv_actor ( desc , skb , offset , len ) ; if ( used < 0 ) { if ( ! copied ) copied = used ; break ; } else if ( used <= len ) { seq += used ; copied += used ; offset += used ; } skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ; if ( ! skb || ( offset + 1 != skb -> len ) ) break ; } if ( tcp_hdr ( skb ) -> fin ) { sk_eat_skb ( sk , skb , 0 ) ; ++ seq ; break ; } sk_eat_skb ( sk , skb , 0 ) ; if ( ! desc -> count ) break ;  }  tp -> copied_seq = seq ;  tcp_rcv_space_adjust ( sk ) ;  if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ; return copied ; }", ) break ;  tp -> copied_seq  = seq ; } tp -> copied_seq = seq ;
603,"CWE-125 static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; }  if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {  pr_devel ( ""replaceinslot%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()=ok[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insertinfreeslot%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()=ok[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( ""nospareslots\\n"" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( ""havemeta\\n"" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( ""onlyleaves;dissimilarity=%lx\\n"" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; goto present_leaves_cluster_but_not_new_leaf ; } split_node : pr_devel ( ""splitnode\\n"" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( ""do_split_node\\n"" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( ""sameslot:%x%x[%02x]\\n"" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( ""filtered:f=%xn=%x\\n"" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()=ok[splitnode]\\n"" , __func__ ) ; return true ; present_leaves_cluster_but_not_new_leaf : pr_devel ( ""presentleavesclusterbutnotnewleaf\\n"" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()=ok[insertnodebefore]\\n"" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( ""allleavesclustertogether\\n"" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( ""skip_to_level=%d[diff%d]\\n"" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( ""blankoff[%zu]%d:%lx\\n"" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }", } if ( assoc_array_ptr_is_leaf ( ptr ) &&
604,CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ;  if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {  } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }, b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;
605,"CWE-416 static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , ""plain"" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) {  conn -> sasl_username = ircnet -> sasl_username ;  conn -> sasl_password = ircnet -> sasl_password ; } else g_warning ( ""Thefieldssasl_usernameandsasl_passwordareeithermissingorempty"" ) ; } else if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , ""external"" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_EXTERNAL ; } else g_warning ( ""UnsupportedSASLmechanism\\""%s\\""selected"" , ircnet -> sasl_mechanism ) ; } }", -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password )  ; } else
606,"CWE-119 enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) { gss_buffer_desc request_buf , send_token ; gss_buffer_t sec_token ; gss_name_t target_name ; gss_ctx_id_t context ; gss_OID mech_name ; char server_conf_flags ; gss_qop_t quality ; int cflags ; OM_uint32 maj_stat , min_stat ; char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ; unsigned long buf_size ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ; if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; snprintf ( buf1 , sizeof ( buf1 ) , ""imap@%s"" , idata -> conn -> account . host ) ; request_buf . value = buf1 ; request_buf . length = strlen ( buf1 ) ; maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , ""Couldn\'tgetservicenamefor[%s]\\n"" , buf1 ) ; return IMAP_AUTH_UNAVAIL ; } else if ( DebugLevel >= 2 ) { gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ; mutt_debug ( 2 , ""Usingservicename[%s]\\n"" , ( char * ) request_buf . value ) ; gss_release_buffer ( & min_stat , & request_buf ) ; } sec_token = GSS_C_NO_BUFFER ; context = GSS_C_NO_CONTEXT ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , ""Erroracquiringcredentials-noTGT?\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; return IMAP_AUTH_UNAVAIL ; } mutt_message ( _ ( ""Authenticating(GSSAPI)..."" ) ) ; imap_cmd_start ( idata , ""AUTHENTICATEGSSAPI"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 2 , ""Invalidresponsefromserver:%s\\n"" , buf1 ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; } mutt_debug ( 2 , ""Sendingcredentials\\n"" ) ; mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; while ( maj_stat == GSS_S_CONTINUE_NEEDED ) { do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""#1Errorreceivingserverresponse.\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; }  request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;  request_buf . value = buf2 ; sec_token = & request_buf ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , ""Errorexchangingcredentials\\n"" ) ; gss_release_name ( & min_stat , & target_name ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; } gss_release_name ( & min_stat , & target_name ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""#2Errorreceivingserverresponse.\\n"" ) ; goto bail ; }  request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;  request_buf . value = buf2 ; maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ; if ( maj_stat != GSS_S_COMPLETE ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 2 , ""Couldn\'tunwrapsecurityleveldata\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } mutt_debug ( 2 , ""Credentialexchangecomplete\\n"" ) ; server_conf_flags = ( ( char * ) send_token . value ) [ 0 ] ; if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) { mutt_debug ( 2 , ""Serverrequiresintegrityorprivacy\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } ( ( char * ) send_token . value ) [ 0 ] = '\\0' ; buf_size = ntohl ( * ( ( long * ) send_token . value ) ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_debug ( 2 , ""Unwrappedsecuritylevelflags:%c%c%c\\n"" , ( server_conf_flags & GSS_AUTH_P_NONE ) ? 'N' : '-' , ( server_conf_flags & GSS_AUTH_P_INTEGRITY ) ? 'I' : '-' , ( server_conf_flags & GSS_AUTH_P_PRIVACY ) ? 'P' : '-' ) ; mutt_debug ( 2 , ""MaximumGSStokensizeis%ld\\n"" , buf_size ) ; buf_size = htonl ( buf_size ) ; memcpy ( buf1 , & buf_size , 4 ) ; buf1 [ 0 ] = GSS_AUTH_P_NONE ; strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ; request_buf . value = buf1 ; request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ; maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , ""Errorcreatingloginrequest\\n"" ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; mutt_debug ( 2 , ""Requestingauthorisationas%s\\n"" , idata -> conn -> account . user ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc == IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Unexpectedservercontinuationrequest.\\n"" ) ; goto err_abort_cmd ; } if ( imap_code ( idata -> buf ) ) { mutt_debug ( 2 , ""ReleasingGSScredentials\\n"" ) ; maj_stat = gss_delete_sec_context ( & min_stat , & context , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) mutt_debug ( 1 , ""Errorreleasingcredentials\\n"" ) ; gss_release_buffer ( & min_stat , & send_token ) ; return IMAP_AUTH_SUCCESS ; } else goto bail ; err_abort_cmd : mutt_socket_send ( idata -> conn , ""*\\r\\n"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; bail : mutt_error ( _ ( ""GSSAPIauthenticationfailed."" ) ) ; return IMAP_AUTH_FAILURE ; }"," buf + 2 , sizeof ( buf2 )  buf + 2 , sizeof ( buf2 )"
607,"CWE-269 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) {  void * dllhandle ;  if ( useSystemLib ) Com_Printf ( ""Tryingtoload\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading\\""%s\\""failed\\n"" , name ) ; } } return dllhandle ; }"," * dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""RejectingDLLnamed\\""%s\\"""" , name ) ; return NULL ; }"
608,"CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ;  int ret = 0 ;  if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }"," ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY"
609,"CWE-125 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD"" , 4 ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%sisnotavalid.DFFfile(bytotalsize)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""fileheaderindicatedlength=%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunkheaderindicatedlength=%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdifffileversion=0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) {  char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ;  if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""gotsamplerateof%uHz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefinedchannelID%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%dchannels,mask=0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD"" , 4 ) ) { error_line ( ""DSDIFFfilesmustbeuncompressed,not\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""gotPROP/SNDchunktype\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisDSDIFFfilealreadyhaschannelorderinformation!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""gotunknownPROPchunktype\\""%c%c%c%c\\""of%dbytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""settingconfigurationwith%lldsamples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }"," { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""gotPROPchunkof%dbytestotal"" , ( int ) dff_chunk_header . ckDataSize ) ;"
610,"CWE-119 static void filter_selectively_horiz ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; int count ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= count ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; count = 1 ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { if ( ( mask_16x16 & 3 ) == 3 ) {  vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , 2 ) ; count = 2 ; } else {  vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , 1 ) ; } } else if ( mask_8x8 & 1 ) { if ( ( mask_8x8 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ;  vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) {  vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim ,  lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; else if ( mask_4x4_int & 2 )  vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim ,  lfin -> lim , lfin -> hev_thr , 1 ) ; } count = 2 ; } else {  vp9_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;  if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4 & 1 ) { if ( ( mask_4x4 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ;  vp9_lpf_horizontal_4_dual ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) {  vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim ,  lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; else if ( mask_4x4_int & 2 )  vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim ,  lfin -> lim , lfin -> hev_thr , 1 ) ; } count = 2 ; } else {  vp9_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;  if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } s += 8 * count ; lfl += count ; mask_16x16 >>= count ; mask_8x8 >>= count ; mask_4x4 >>= count ; mask_4x4_int >>= count ; } }"," 3 ) { vpx_lpf_horizontal_16  ( s ,  } else { vpx_lpf_horizontal_16  ( s ,  1 ) ; vpx_lpf_horizontal_8_dual  ( s ,  3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4  ( s +  & 2 ) vpx_lpf_horizontal_4  ( s +  } else { vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4  ( s +  1 ) ; vpx_lpf_horizontal_4_dual  ( s ,  3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4  ( s +  & 2 ) vpx_lpf_horizontal_4  ( s +  } else { vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4  ( s +"
611,"CWE-264 static ssize_t perf_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct perf_event * event = file -> private_data ;  return perf_read_hw ( event , buf , count ) ;   } "," -> private_data ; struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret =  perf_read_hw ( event  count ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret ;"
612,"CWE-755 int sqlite3WindowRewrite ( Parse * pParse , Select * p ) { int rc = SQLITE_OK ; if ( p -> pWin && p -> pPrior == 0 && ( p -> selFlags & SF_WinRewrite ) == 0 ) { Vdbe * v = sqlite3GetVdbe ( pParse ) ; sqlite3 * db = pParse -> db ; Select * pSub = 0 ; SrcList * pSrc = p -> pSrc ; Expr * pWhere = p -> pWhere ; ExprList * pGroupBy = p -> pGroupBy ; Expr * pHaving = p -> pHaving ; ExprList * pSort = 0 ; ExprList * pSublist = 0 ; Window * pMWin = p -> pWin ; Window * pWin ; Table * pTab ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) {  return SQLITE_NOMEM ;  } p -> pSrc = 0 ; p -> pWhere = 0 ; p -> pGroupBy = 0 ; p -> pHaving = 0 ; p -> selFlags &= ~ SF_Aggregate ; p -> selFlags |= SF_WinRewrite ; pSort = sqlite3ExprListDup ( db , pMWin -> pPartition , 0 ) ; pSort = exprListAppendList ( pParse , pSort , pMWin -> pOrderBy , 1 ) ; if ( pSort && p -> pOrderBy && p -> pOrderBy -> nExpr <= pSort -> nExpr ) { int nSave = pSort -> nExpr ; pSort -> nExpr = p -> pOrderBy -> nExpr ; if ( sqlite3ExprListCompare ( pSort , p -> pOrderBy , - 1 ) == 0 ) { sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; } pSort -> nExpr = nSave ; } pMWin -> iEphCsr = pParse -> nTab ++ ; pParse -> nTab += 3 ; selectWindowRewriteEList ( pParse , pMWin , pSrc , p -> pEList , pTab , & pSublist ) ; selectWindowRewriteEList ( pParse , pMWin , pSrc , p -> pOrderBy , pTab , & pSublist ) ; pMWin -> nBufferCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pMWin -> pPartition , 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pMWin -> pOrderBy , 0 ) ; for ( pWin = pMWin ; pWin ; pWin = pWin -> pNextWin ) { ExprList * pArgs = pWin -> pOwner -> x . pList ; if ( pWin -> pFunc -> funcFlags & SQLITE_FUNC_SUBTYPE ) { selectWindowRewriteEList ( pParse , pMWin , pSrc , pArgs , pTab , & pSublist ) ; pWin -> iArgCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pWin -> bExprArgs = 1 ; } else { pWin -> iArgCol = ( pSublist ? pSublist -> nExpr : 0 ) ; pSublist = exprListAppendList ( pParse , pSublist , pArgs , 0 ) ; } if ( pWin -> pFilter ) { Expr * pFilter = sqlite3ExprDup ( db , pWin -> pFilter , 0 ) ; pSublist = sqlite3ExprListAppend ( pParse , pSublist , pFilter ) ; } pWin -> regAccum = ++ pParse -> nMem ; pWin -> regResult = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Null , 0 , pWin -> regAccum ) ; } if ( pSublist == 0 ) { pSublist = sqlite3ExprListAppend ( pParse , 0 , sqlite3Expr ( db , TK_INTEGER , ""0"" ) ) ; } pSub = sqlite3SelectNew ( pParse , pSublist , pSrc , pWhere , pGroupBy , pHaving , pSort , 0 , 0 ) ; p -> pSrc = sqlite3SrcListAppend ( pParse , 0 , 0 , 0 ) ; if ( p -> pSrc ) { Table * pTab2 ; p -> pSrc -> a [ 0 ] . pSelect = pSub ; sqlite3SrcListAssignCursors ( pParse , p -> pSrc ) ; pSub -> selFlags |= SF_Expanded ; pTab2 = sqlite3ResultSetOfSelect ( pParse , pSub , SQLITE_AFF_NONE ) ; if ( pTab2 == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pTab , pTab2 , sizeof ( Table ) ) ; pTab -> tabFlags |= TF_Ephemeral ; p -> pSrc -> a [ 0 ] . pTab = pTab ; pTab = pTab2 ; } sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pMWin -> iEphCsr , pSublist -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 1 , pMWin -> iEphCsr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 2 , pMWin -> iEphCsr ) ; sqlite3VdbeAddOp2 ( v , OP_OpenDup , pMWin -> iEphCsr + 3 , pMWin -> iEphCsr ) ; } else { sqlite3SelectDelete ( db , pSub ) ; } if ( db -> mallocFailed ) rc = SQLITE_NOMEM ; sqlite3DbFree ( db , pTab ) ; }  return rc ;  }"," ) { return sqlite3ErrorToParser ( db , SQLITE_NOMEM )  ; } p  ) ; } if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; }"
613,"CWE-119 int main ( int argc , char * * argv ) { FILE * infile , * outfile [ NUM_ENCODERS ] ;  vpx_codec_ctx_t codec [ NUM_ENCODERS ] ;  vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ;  vpx_codec_pts_t frame_cnt = 0 ;  vpx_image_t raw [ NUM_ENCODERS ] ; vpx_codec_err_t res [ NUM_ENCODERS ] ; int i ; long width ; long height ;  int frame_avail ;  int got_data ; int flags = 0 ;  int arg_deadline = VPX_DL_REALTIME ;  int show_psnr = 0 ;  uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ;  uint64_t psnr_samples_total [ NUM_ENCODERS ] = { 0 } ; double psnr_totals [ NUM_ENCODERS ] [ 4 ] = { { 0 , 0 } } ;  int psnr_count [ NUM_ENCODERS ] = { 0 } ;  unsigned int target_bitrate [ NUM_ENCODERS ] = { 1000 , 500 , 100 } ; int framerate = 30 ; vpx_rational_t dsf [ NUM_ENCODERS ] = { { 2 , 1 } , { 2 , 1 } , { 1 , 1 } } ;  if ( argc != ( 5 + NUM_ENCODERS ) )   die ( ""Usage:%s<width><height><infile><outfile(s)><outputpsnr?>\\n"" ,  argv [ 0 ] ) ; printf ( ""Using%s\\n"" , vpx_codec_iface_name ( interface ) ) ; width = strtol ( argv [ 1 ] , NULL , 0 ) ;  height = strtol ( argv [ 2 ] , NULL , 0 ) ;  if ( width < 16 || width % 2 || height < 16 || height % 2 ) die ( ""Invalidresolution:%ldx%ld"" , width , height ) ;  if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) )   die ( ""Failedtoopen%sforreading"" , argv [ 3 ] ) ;  for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( ! target_bitrate [ i ] ) { outfile [ i ] = NULL ; continue ; }  if ( ! ( outfile [ i ] = fopen ( argv [ i + 4 ] , ""wb"" ) ) )  die ( ""Failedtoopen%sforwriting"" , argv [ i + 4 ] ) ; }  show_psnr = strtol ( argv [ NUM_ENCODERS + 4 ] , NULL , 0 ) ;   for ( i = 0 ; i < NUM_ENCODERS ; i ++ )  {  res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ;  if ( res [ i ] ) { printf ( ""Failedtogetconfig:%s\\n"" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; }  }  cfg [ 0 ] . g_w = width ; cfg [ 0 ] . g_h = height ;  cfg [ 0 ] . g_threads = 1 ;  cfg [ 0 ] . rc_dropframe_thresh = 30 ; cfg [ 0 ] . rc_end_usage = VPX_CBR ; cfg [ 0 ] . rc_resize_allowed = 0 ;  cfg [ 0 ] . rc_min_quantizer = 4 ;  cfg [ 0 ] . rc_max_quantizer = 56 ;  cfg [ 0 ] . rc_undershoot_pct = 98 ;   cfg [ 0 ] . rc_overshoot_pct = 100 ;  cfg [ 0 ] . rc_buf_initial_sz = 500 ; cfg [ 0 ] . rc_buf_optimal_sz = 600 ; cfg [ 0 ] . rc_buf_sz = 1000 ; cfg [ 0 ] . g_error_resilient = 1 ; cfg [ 0 ] . g_lag_in_frames = 0 ; cfg [ 0 ] . kf_mode = VPX_KF_AUTO ; cfg [ 0 ] . kf_min_dist = 3000 ; cfg [ 0 ] . kf_max_dist = 3000 ; cfg [ 0 ] . rc_target_bitrate = target_bitrate [ 0 ] ; cfg [ 0 ] . g_timebase . num = 1 ; cfg [ 0 ] . g_timebase . den = framerate ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) {  memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ;  cfg [ i ] . g_threads = 1 ; cfg [ i ] . rc_target_bitrate = target_bitrate [ i ] ; { unsigned int iw = cfg [ i - 1 ] . g_w * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; unsigned int ih = cfg [ i - 1 ] . g_h * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; cfg [ i ] . g_w = iw / dsf [ i - 1 ] . num ; cfg [ i ] . g_h = ih / dsf [ i - 1 ] . num ; } if ( ( cfg [ i ] . g_w ) % 2 ) cfg [ i ] . g_w ++ ; if ( ( cfg [ i ] . g_h ) % 2 ) cfg [ i ] . g_h ++ ; }  for ( i = 0 ; i < NUM_ENCODERS ; i ++ )  if ( ! vpx_img_alloc ( & raw [ i ] , VPX_IMG_FMT_I420 , cfg [ i ] . g_w , cfg [ i ] . g_h , 32 ) ) die ( ""Failedtoallocateimage"" , cfg [ i ] . g_w , cfg [ i ] . g_h ) ; if ( raw [ 0 ] . stride [ VPX_PLANE_Y ] == raw [ 0 ] . d_w ) read_frame_p = read_frame ; else read_frame_p = read_frame_by_row ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) if ( outfile [ i ] )  write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , 0 ) ;  if ( vpx_codec_enc_init_multi ( & codec [ 0 ] , interface , & cfg [ 0 ] , NUM_ENCODERS , ( show_psnr ? VPX_CODEC_USE_PSNR : 0 ) , & dsf [ 0 ] ) ) die_codec ( & codec [ 0 ] , ""Failedtoinitializeencoder"" ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { int speed = - 6 ;  if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) )   die_codec ( & codec [ i ] , ""Failedtosetcpu_used"" ) ;  } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) {  unsigned int static_thresh = 1 ;   if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , static_thresh ) )   die_codec ( & codec [ i ] , ""Failedtosetstaticthreshold"" ) ;  } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , ""Failedtosetnoise_sensitivity"" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , ""Failedtosetnoise_sensitivity"" ) ; } frame_avail = 1 ; got_data = 0 ; while ( frame_avail || got_data ) { vpx_codec_iter_t iter [ NUM_ENCODERS ] = { NULL } ; const vpx_codec_cx_pkt_t * pkt [ NUM_ENCODERS ] ; flags = 0 ; frame_avail = read_frame_p ( infile , & raw [ 0 ] ) ; if ( frame_avail ) { for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { I420Scale ( raw [ i - 1 ] . planes [ VPX_PLANE_Y ] , raw [ i - 1 ] . stride [ VPX_PLANE_Y ] , raw [ i - 1 ] . planes [ VPX_PLANE_U ] , raw [ i - 1 ] . stride [ VPX_PLANE_U ] , raw [ i - 1 ] . planes [ VPX_PLANE_V ] , raw [ i - 1 ] . stride [ VPX_PLANE_V ] , raw [ i - 1 ] . d_w , raw [ i - 1 ] . d_h , raw [ i ] . planes [ VPX_PLANE_Y ] , raw [ i ] . stride [ VPX_PLANE_Y ] , raw [ i ] . planes [ VPX_PLANE_U ] , raw [ i ] . stride [ VPX_PLANE_U ] , raw [ i ] . planes [ VPX_PLANE_V ] , raw [ i ] . stride [ VPX_PLANE_V ] , raw [ i ] . d_w , raw [ i ] . d_h , 1 ) ;  }  } if ( vpx_codec_encode ( & codec [ 0 ] , frame_avail ? & raw [ 0 ] : NULL ,  frame_cnt , 1 , flags , arg_deadline ) )   die_codec ( & codec [ 0 ] , ""Failedtoencodeframe"" ) ;  for ( i = NUM_ENCODERS - 1 ; i >= 0 ; i -- ) { got_data = 0 ; while ( ( pkt [ i ] = vpx_codec_get_cx_data ( & codec [ i ] , & iter [ i ] ) ) ) { got_data = 1 ; switch ( pkt [ i ] -> kind ) { case VPX_CODEC_CX_FRAME_PKT : write_ivf_frame_header ( outfile [ i ] , pkt [ i ] ) ; ( void ) fwrite ( pkt [ i ] -> data . frame . buf , 1 , pkt [ i ] -> data . frame . sz , outfile [ i ] ) ; break ; case VPX_CODEC_PSNR_PKT : if ( show_psnr ) { int j ; psnr_sse_total [ i ] += pkt [ i ] -> data . psnr . sse [ 0 ] ; psnr_samples_total [ i ] += pkt [ i ] -> data . psnr . samples [ 0 ] ; for ( j = 0 ; j < 4 ; j ++ ) { psnr_totals [ i ] [ j ] += pkt [ i ] -> data . psnr . psnr [ j ] ; } psnr_count [ i ] ++ ; } break ; default : break ; } printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT  && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? ""K"" : ""."" ) ;  fflush ( stdout ) ; } } frame_cnt ++ ; }  printf ( ""\\n"" ) ;  fclose ( infile ) ; printf ( ""Processed%ldframes.\\n"" , ( long int ) frame_cnt - 1 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( ( show_psnr ) && ( psnr_count [ i ] > 0 ) ) { int j ; double ovpsnr = sse_to_psnr ( psnr_samples_total [ i ] , 255.0 , psnr_sse_total [ i ] ) ; fprintf ( stderr , ""\\nENC%dPSNR(Overall/Avg/Y/U/V)"" , i ) ; fprintf ( stderr , ""%.3lf"" , ovpsnr ) ; for ( j = 0 ; j < 4 ; j ++ ) { fprintf ( stderr , ""%.3lf"" , psnr_totals [ i ] [ j ] / psnr_count [ i ] ) ; } } if ( vpx_codec_destroy ( & codec [ i ] ) ) die_codec ( & codec [ i ] , ""Failedtodestroycodec"" ) ; vpx_img_free ( & raw [ i ] ) ; if ( ! outfile [ i ] ) continue ; if ( ! fseek ( outfile [ i ] , 0 , SEEK_SET ) ) write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , frame_cnt - 1 ) ; fclose ( outfile [ i ] ) ; } printf ( ""\\n"" ) ; return EXIT_SUCCESS ; }"," NUM_ENCODERS ] ; FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; char filename [ 50 ] ;  NUM_ENCODERS ] ; int  frame_cnt = 0  height ; int length_frame ; int  0 ; int layer_id = 0 ; int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = { 0 } ; int flag_periodicity ; int  = 0 ; int key_frame_insert = 0 ;  { 0 } ; double cx_time = 0 ; struct timeval tv1 , tv2 , difftv  } } ; unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ;  argc != ( 7 + 3 *  NUM_ENCODERS ) )  ) die ( ""Usage:%s<width><height><frame_rate><infile><outfile(s)>"" ""<rate_encoder(s)><temporal_layer(s)><key_frame_insert><outputpsnr?>\\n""  , argv [  argv [ 2 ] , NULL , 0 ) ; framerate = strtol ( argv [ 3  ( argv [ 4  ] , ""rb""  , argv [ 4  ] ) ;  [ i + 5  ] , ""wb""  ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { target_bitrate [ i ]  = strtol (  [ NUM_ENCODERS + 5 + i  ] , NULL  0 ) ; }  ++ ) { num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( ""Invalidtemporallayers:%d,Mustbe1,2,or3.\\n"" , num_temporal_layers ) ; } for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) { if ( sprintf ( filename , ""ds%d.yuv"" , NUM_ENCODERS - i ) < 0 ) {  return EXIT_FAILURE ;  EXIT_FAILURE ; } downsampled_input [ i ] = fopen ( filename , ""wb"" ) ; } key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; if ( res [ i ] ) { printf ( ""Failedtogetconfig:%s\\n"" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; }  0 ] . rc_dropframe_thresh = 0  ; cfg [  . rc_min_quantizer = 2  ; cfg [  . rc_undershoot_pct = 100  ; cfg [  . rc_overshoot_pct = 15  ; cfg [  vpx_codec_enc_cfg_t ) )  ; cfg [  ++ ; } cfg [ 0 ] . g_threads = 2 ; cfg [ 1 ] . g_threads = 1 ; cfg [ 2 ] . g_threads = 1 ;  0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { set_temporal_layer_pattern ( num_temporal_layers [ i ] , & cfg [ i ] , cfg [ i ] . rc_target_bitrate , & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; }  ; if ( i == NUM_ENCODERS - 1 ) speed = - 4 ; if (  ] , ""Failedtosetcpu_used"" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , ""Failedtosetstaticthreshold"" ) ; } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , ""Failedtosetnoise_sensitivity"" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , ""Failedtosetnoise_sensitivity"" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , ""Failedtosetstaticthreshold""  { unsigned int max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 )  ; if (  i ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct  ) ) die_codec  ] , ""Failedtosetstaticthreshold""  ) ; }  1 ) ; length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , downsampled_input [ NUM_ENCODERS - i - 1 ] ) != length_frame ) { return EXIT_FAILURE ; } } } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; flags = 0 ; flag_periodicity = periodicity_to_num_layers [ num_temporal_layers [ i ] - 1 ] ; flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + frame_cnt % flag_periodicity ] ; if ( frame_cnt == 0 ) { flags |= VPX_EFLAG_FORCE_KF ; } if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) { flags = VPX_EFLAG_FORCE_KF ; } vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; } gettimeofday ( & tv1 , NULL ) ;  if ( vpx_codec_encode  , 1 , 0  , arg_deadline )  arg_deadline ) ) {  ] , ""Failedtoencodeframe"" ) ; } gettimeofday ( & tv2 , NULL ) ; timersub ( & tv2 , & tv1 , & difftv ) ; cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec  ? ""K"" : """"  ) ; fflush  printf ( ""\\n"" ) ; printf ( ""FPSforencoding%d%f%f\\n"" , frame_cnt , ( float ) cx_time / 1000000 , 1000000 * ( double ) frame_cnt / ( double ) cx_time"
614,"CWE-254 void test_parser ( void ) {  int i , retval ;  bzrtpPacket_t * zrtpPacket ; bzrtpContext_t * context87654321 = bzrtp_createBzrtpContext ( 0x87654321 ) ; bzrtpContext_t * context12345678 = bzrtp_createBzrtpContext ( 0x12345678 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 0 ] , H12345678 [ 0 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 1 ] , H12345678 [ 1 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 2 ] , H12345678 [ 2 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 3 ] , H12345678 [ 3 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 0 ] , H87654321 [ 0 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 1 ] , H87654321 [ 1 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 2 ] , H87654321 [ 2 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 3 ] , H87654321 [ 3 ] , 32 ) ; context87654321 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context12345678 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context87654321 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context12345678 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context87654321 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ; context12345678 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ; updateCryptoFunctionPointers ( context87654321 -> channelContext [ 0 ] ) ; updateCryptoFunctionPointers ( context12345678 -> channelContext [ 0 ] ) ; context87654321 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ; context12345678 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ; context87654321 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ; context12345678 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ; context87654321 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ; context12345678 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ; context87654321 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ; context12345678 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ; context12345678 -> channelContext [ 0 ] -> role = RESPONDER ; for ( i = 0 ; i < TEST_PACKET_NUMBER ; i ++ ) { uint8_t freePacketFlag = 1 ; zrtpPacket = bzrtp_packetCheck ( patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , ( patternZRTPMetaData [ i ] [ 1 ] ) - 1 , & retval ) ; retval += bzrtp_packetParser ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , zrtpPacket ) ; if ( zrtpPacket -> messageType == MSGTYPE_HELLO ) { if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) { context12345678 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ; } else { context87654321 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ; } freePacketFlag = 0 ; } if ( zrtpPacket -> messageType == MSGTYPE_COMMIT ) { if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) { context12345678 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ; } else { context87654321 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ; } freePacketFlag = 0 ; } if ( zrtpPacket -> messageType == MSGTYPE_DHPART1 || zrtpPacket -> messageType == MSGTYPE_DHPART2 ) { if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) { context12345678 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ; } else { context87654321 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ; } freePacketFlag = 0 ; } free ( zrtpPacket -> packetString ) ; retval = bzrtp_packetBuild ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , zrtpPacket , patternZRTPMetaData [ i ] [ 1 ] ) ; if ( zrtpPacket -> packetString != NULL ) { CU_ASSERT_TRUE ( memcmp ( zrtpPacket -> packetString , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] ) == 0 ) ;  } else {  CU_FAIL ( ""Unabletobuildpacket"" ) ; } if ( freePacketFlag == 1 ) { bzrtp_freeZrtpPacket ( zrtpPacket ) ; } } bzrtp_destroyBzrtpContext ( context87654321 , 0x87654321 ) ; bzrtp_destroyBzrtpContext ( context12345678 , 0x12345678 ) ; }", void ) { test_parser_param (  0 ) ;  ) ; }    
615,"CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ;  in_uint16_le ( s , length ) ;  in_uint16_le ( s , flags ) ;  in_uint8 ( s , type ) ;  next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , ""process_secondary_order(),unhandledsecondaryorder%d"" , type ) ; } s -> p = next_order ; }"," * next_order ; struct stream packet = * s ;  type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),nextorderpointerwouldoverrunstream"" , & packet ) ; }"
616,"CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns ,  number_threads ;   number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;   pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ;  ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;  columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;  for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ )  { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }"," size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) ,  ( size_t )  ( ThreadResource ) )  ) AcquireQuantumMemory ( rows ,  sizeof ( *  NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0  ; i <  ( ssize_t ) rows  ; i ++"
617,"CWE-000 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; struct rds_transport * otrans = trans ; if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) goto new_conn ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; new_conn : conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } }  conn -> c_trans = trans ;  ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( ""allocatedconn%pfor%pI4->%pI4over%s%s\\n"" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : ""[unknown]"" , is_outgoing ? ""(outgoing)"" : """" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) found = NULL ; else found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { if ( ( is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) || ( otrans -> t_type != RDS_TRANS_TCP ) ) { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; } rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }"," ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }"
618,"CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""who-are-yourequest"" ) ) ; break ; } ND_PRINT ( ( ndo , ""nodeinformationquery"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supportedqtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNSname"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""nodeaddresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" ) ) ; break ; default : ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",invalidlen"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , "",03draft"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",invalidsubjectlen"" ) ) ; break ; } ND_PRINT ( ( ndo , "",subject=%s"" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , "",subject=DNSname"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",03draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",invalidsubjectlen"" ) ) ; break ; } ND_PRINT ( ( ndo , "",subject=%s"" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",unknownsubject"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , ""[|icmp6:nodeinformationreply]"" ) ) ; break ; } needcomma = 0 ;  ni6 = ( const struct icmp6_nodeinfo * ) dp ;  ND_PRINT ( ( ndo , ""nodeinformationreply"" ) ) ; ND_PRINT ( ( ndo , ""("" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""success"" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , ""refused"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",invalidlength"" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , ""unknown"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",invalidlength"" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , "","" ) ) ; ND_PRINT ( ( ndo , ""noop"" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",invalidlength"" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , "","" ) ) ; ND_PRINT ( ( ndo , ""supportedqtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , "","" ) ) ; ND_PRINT ( ( ndo , ""DNSname"" ) ) ;  cp = ( const u_char * ) ( ni6 + 1 ) + 4 ;  if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",03draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , ""[TTL=%u]"" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , "","" ) ) ; ND_PRINT ( ( ndo , ""nodeaddresses"" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""(%d)"" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""[%s%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? ""T"" : """" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , "","" ) ) ; ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }"," = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ;  ) + 4 ; ND_TCHECK ( cp [ 0 ] )"
619,"CWE-190 static int Unpickler_set_memo ( UnpicklerObject * self , PyObject * obj ) { PyObject * * new_memo ;  Py_ssize_t new_memo_size = 0 ;  Py_ssize_t i ; if ( obj == NULL ) { PyErr_SetString ( PyExc_TypeError , ""attributedeletionisnotsupported"" ) ; return - 1 ; } if ( Py_TYPE ( obj ) == & UnpicklerMemoProxyType ) { UnpicklerObject * unpickler = ( ( UnpicklerMemoProxyObject * ) obj ) -> unpickler ; new_memo_size = unpickler -> memo_size ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ;  for ( i = 0 ; i < new_memo_size ; i ++ ) {  Py_XINCREF ( unpickler -> memo [ i ] ) ; new_memo [ i ] = unpickler -> memo [ i ] ; } } else if ( PyDict_Check ( obj ) ) { Py_ssize_t i = 0 ; PyObject * key , * value ; new_memo_size = PyDict_GET_SIZE ( obj ) ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; while ( PyDict_Next ( obj , & i , & key , & value ) ) { Py_ssize_t idx ; if ( ! PyLong_Check ( key ) ) { PyErr_SetString ( PyExc_TypeError , ""memokeymustbeintegers"" ) ; goto error ; } idx = PyLong_AsSsize_t ( key ) ; if ( idx == - 1 && PyErr_Occurred ( ) ) goto error ; if ( idx < 0 ) { PyErr_SetString ( PyExc_ValueError , ""memokeymustbepositiveintegers."" ) ; goto error ; } if ( _Unpickler_MemoPut ( self , idx , value ) < 0 ) goto error ; } } else { PyErr_Format ( PyExc_TypeError , ""\'memo\'attributemustbeanUnpicklerMemoProxyobject"" ""ordict,not%.200s"" , Py_TYPE ( obj ) -> tp_name ) ; return - 1 ; } _Unpickler_MemoCleanup ( self ) ; self -> memo_size = new_memo_size ; self -> memo = new_memo ; return 0 ; error : if ( new_memo_size ) {  i = new_memo_size ;  while ( -- i >= 0 ) { Py_XDECREF ( new_memo [ i ] ) ; } PyMem_FREE ( new_memo ) ; } return - 1 ; }", * new_memo ; size_t new_memo_size = 0  ; if (  ; for ( size_t  new_memo_size ) { for ( size_t i = new_memo_size - 1 ; i != SIZE_MAX ; i --  ) { Py_XDECREF
620,"CWE-119 static int send_parameters ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; j = cJSON_CreateObject ( ) ; if ( j == NULL ) { i_errno = IESENDPARAMS ; r = - 1 ; } else { if ( test -> protocol -> id == Ptcp ) cJSON_AddTrueToObject ( j , ""tcp"" ) ; else if ( test -> protocol -> id == Pudp ) cJSON_AddTrueToObject ( j , ""udp"" ) ;  cJSON_AddIntToObject ( j , ""omit"" , test -> omit ) ;  if ( test -> server_affinity != - 1 )  cJSON_AddIntToObject ( j , ""server_affinity"" , test -> server_affinity ) ;  if ( test -> duration ) cJSON_AddIntToObject ( j , ""time"" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddIntToObject ( j , ""num"" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddIntToObject ( j , ""blockcount"" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddIntToObject ( j , ""MSS"" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , ""nodelay"" ) ; cJSON_AddIntToObject ( j , ""parallel"" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , ""reverse"" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddIntToObject ( j , ""window"" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddIntToObject ( j , ""len"" , test -> settings -> blksize ) ; if ( test -> settings -> rate ) cJSON_AddIntToObject ( j , ""bandwidth"" , test -> settings -> rate ) ; if ( test -> settings -> burst ) cJSON_AddIntToObject ( j , ""burst"" , test -> settings -> burst ) ; if ( test -> settings -> tos ) cJSON_AddIntToObject ( j , ""TOS"" , test -> settings -> tos ) ; if ( test -> settings -> flowlabel ) cJSON_AddIntToObject ( j , ""flowlabel"" , test -> settings -> flowlabel ) ; if ( test -> title )  cJSON_AddStringToObject ( j , ""title"" , test -> title ) ;  if ( test -> congestion ) cJSON_AddStringToObject ( j , ""congestion"" , test -> congestion ) ; if ( test -> get_server_output ) cJSON_AddIntToObject ( j , ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ; if ( test -> debug ) { printf ( ""send_parameters:\\n%s\\n"" , cJSON_Print ( j ) ) ; } if ( JSON_write ( test -> ctrl_sck , j ) < 0 ) { i_errno = IESENDPARAMS ; r = - 1 ; } cJSON_Delete ( j ) ; } return r ; }"," ""udp"" ) ; cJSON_AddNumberToObject  ( j ,  - 1 ) cJSON_AddNumberToObject ( j , ""server_affinity"" , test -> server_affinity ) ; if ( test -> duration ) cJSON_AddNumberToObject ( j , ""time"" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddNumberToObject ( j , ""num"" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddNumberToObject ( j , ""blockcount"" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddNumberToObject ( j , ""MSS"" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , ""nodelay"" ) ; cJSON_AddNumberToObject ( j , ""parallel"" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , ""reverse"" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddNumberToObject ( j , ""window"" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddNumberToObject ( j , ""len"" , test -> settings -> blksize ) ; if ( test -> settings -> rate ) cJSON_AddNumberToObject ( j , ""bandwidth"" , test -> settings -> rate ) ; if ( test -> settings -> burst ) cJSON_AddNumberToObject ( j , ""burst"" , test -> settings -> burst ) ; if ( test -> settings -> tos ) cJSON_AddNumberToObject ( j , ""TOS"" , test -> settings -> tos ) ; if ( test -> settings -> flowlabel ) cJSON_AddNumberToObject ( j , ""flowlabel"" , test -> settings -> flowlabel ) ; if ( test -> title ) cJSON_AddStringToObject ( j , ""title"" , test -> title ) ; if ( test -> congestion ) cJSON_AddStringToObject ( j , ""congestion"" , test -> congestion ) ; if ( test -> get_server_output ) << << << < HEAD  ( j , ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ; == == == = cJSON_AddNumberToObject ( j , ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ; if ( test -> udp_counters_64bit ) cJSON_AddNumberToObject ( j , ""udp_counters_64bit"" , iperf_get_test_udp_counters_64bit ( test ) ) ; if ( test -> no_fq_socket_pacing ) cJSON_AddNumberToObject ( j , ""no_fq_socket_pacing"" , iperf_get_no_fq_socket_pacing ( test ) ) ;  cJSON_AddStringToObject ( j  ( j , ""client_version"" , IPERF_VERSION ) ; >> >> >> > ed94082 ... Fix a buffer overflow / heap corruption issue that could occur if a  if ( test"
621,"CWE-20 static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= SNDRV_TIMER_IFLG_RUNNING ;  if ( timeri -> master )  list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;  spin_unlock_irqrestore ( & slave_active_lock , flags ) ;  return 1 ; }", timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ;  list_add_tail ( &  slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
622,"CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ;  spin_lock_irq ( & tu -> qlock ) ;  while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ;  schedule ( ) ;  spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ;  mutex_lock ( & tu -> ioctl_lock ) ;  if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; }  mutex_unlock ( & tu -> ioctl_lock ) ;  spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ;  return result > 0 ? result : err ;  }", snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ;  qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock  ) ; spin_lock_irq  qlock ) ;  if ( tu  EFAULT ; }  spin_lock_irq ( &  qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
623,"CWE-399 xmlAttrPtr xsltAttrTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attr ) { const xmlChar * value ; xmlAttrPtr ret ; if ( ( ctxt == NULL ) || ( attr == NULL ) || ( target == NULL ) ) return ( NULL ) ; if ( attr -> type != XML_ATTRIBUTE_NODE ) return ( NULL ) ; # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) return ( NULL ) ; # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) return ( NULL ) ; # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:Thechildrenofanattributenodeofa"" ""literalresultelementarenotintheexpectedform.\\n"" ) ; return ( NULL ) ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; ret = target -> properties ; while ( ret != NULL ) { if ( ( ( attr -> ns != NULL ) == ( ret -> ns != NULL ) ) && xmlStrEqual ( ret -> name , attr -> name ) && ( ( attr -> ns == NULL ) || xmlStrEqual ( ret -> ns -> href , attr -> ns -> href ) ) ) { break ; } ret = ret -> next ; } if ( ret != NULL ) { xmlFreeNodeList ( ret -> children ) ; ret -> children = ret -> last = NULL ; if ( ( ret -> ns != NULL ) && ( ! xmlStrEqual ( ret -> ns -> prefix , attr -> ns -> prefix ) ) ) { ret -> ns = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; } } else { if ( attr -> ns != NULL ) ret = xmlNewNsProp ( target , xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) , attr -> name , NULL ) ; else ret = xmlNewNsProp ( target , NULL , attr -> name , NULL ) ; } if ( ret != NULL ) { xmlNodePtr text ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { ret -> last = ret -> children = text ; text -> parent = ( xmlNodePtr ) ret ; text -> doc = ret -> doc ; if ( attr -> psvi != NULL ) { xmlChar * val ; val = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( val == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:FailedtoevaluatetheAVT"" ""ofattribute\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:FailedtoevaluatetheAVT"" ""ofattribute\'%s\'.\\n"" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST """" ) ; } else { text -> content = val ; } } else if ( ( ctxt -> internalized ) && ( target != NULL ) && ( target -> doc != NULL ) &&  ( target -> doc -> dict == ctxt -> dict ) ) {  text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } } } else { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:Failedtocreateattribute\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:Failedtocreateattribute\'%s\'.\\n"" , attr -> name ) ; } } return ( ret ) ; }"," -> dict ) && xmlDictOwns ( ctxt -> dict , value )"
624,"CWE-284 bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd ) { if ( thread_handle < 0 || thread_handle >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""%sinvalidthreadhandle:%d"" , __func__ , thread_handle ) ; return false ; } if ( fd == - 1 ) { APPL_TRACE_ERROR ( ""%sinvalidfiledescriptor."" , __func__ ) ; return false ; } sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ;  return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ;  }"," } ; return TEMP_FAILURE_RETRY (  , 0 ) )"
625,"CWE-362 void sock_release ( struct socket * sock ) {  if ( sock -> ops ) {  struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; }  if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list )  pr_err ( ""%s:fasynclistnotempty!\\n"" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }"," sock ) { __sock_release ( sock , NULL  ) ; }  ) ; }    "
626,"CWE-264 static NPError g_NPN_GetValue ( NPP instance , NPNVariable variable , void * value ) { D ( bug ( ""NPN_GetValueinstance=%p,variable=%d[%s]\\n"" , instance , variable , string_of_NPNVariable ( variable ) ) ) ; if ( ! thread_check ( ) ) { npw_printf ( ""WARNING:NPN_GetValuenotcalledfromthemainthread\\n"" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } PluginInstance * plugin = NULL ; if ( instance ) plugin = PLUGIN_INSTANCE ( instance ) ; switch ( variable ) { case NPNVxDisplay : * ( void * * ) value = x_display ; break ; case NPNVxtAppContext : * ( void * * ) value = XtDisplayToApplicationContext ( x_display ) ; break ; case NPNVToolkit : * ( NPNToolkitType * ) value = NPW_TOOLKIT ; break ; # if USE_XPCOM case NPNVserviceManager : { nsIServiceManager * sm ; int ret = NS_GetServiceManager ( & sm ) ; if ( NS_FAILED ( ret ) ) { npw_printf ( ""WARNING:NS_GetServiceManagerfailed\\n"" ) ; return NPERR_GENERIC_ERROR ; } * ( nsIServiceManager * * ) value = sm ; break ; } case NPNVDOMWindow : case NPNVDOMElement : npw_printf ( ""WARNING:%sisnotsupportedbyNPN_GetValue()\\n"" , string_of_NPNVariable ( variable ) ) ; return NPERR_INVALID_PARAM ; # endif case NPNVnetscapeWindow : if ( plugin == NULL ) { npw_printf ( ""ERROR:NPNVnetscapeWindowrequiresanonNULLinstance\\n"" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } if ( plugin -> browser_toplevel == NULL ) { GdkNativeWindow netscape_xid = None ; NPError error = g_NPN_GetValue_real ( instance , variable , & netscape_xid ) ; if ( error != NPERR_NO_ERROR ) return error ; if ( netscape_xid == None ) return NPERR_GENERIC_ERROR ; plugin -> browser_toplevel = gdk_window_foreign_new ( netscape_xid ) ; if ( plugin -> browser_toplevel == NULL ) return NPERR_GENERIC_ERROR ; } * ( ( GdkNativeWindow * ) value ) = GDK_WINDOW_XWINDOW ( plugin -> browser_toplevel ) ; break ; # if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject :  return g_NPN_GetValue_real ( instance , variable , value ) ;  default : switch ( variable & 0xff ) { case 13 : if ( NPW_TOOLKIT == NPNVGtk2 ) { * ( NPNToolkitType * ) value = NPW_TOOLKIT ; return NPERR_NO_ERROR ; } break ; } D ( bug ( ""WARNING:unhandledvariable%d(%s)inNPN_GetValue()\\n"" , variable , string_of_NPNVariable ( variable ) ) ) ; return NPERR_INVALID_PARAM ; } return NPERR_NO_ERROR ; }", case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :
627,"CWE-119 WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( ""u1_mb_type"" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs ++ ;  ps_dec -> u2_total_mbs_coded ++ ;  u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; }  if ( u1_tfr_n_mb )  u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }", u1_num_mbs ++ ;  u1_num_mbs_next = i2_pic_wdin_mbs  ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
628,"CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ;  memcpy ( new , ours , sizeof ( * new ) ) ;  len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , ""X.25:rejectingreversechargingrequest\\n"" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , ""X.25:inboundthroughputnegotiated\\n"" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , ""X.25:outboundthroughputnegotiated\\n"" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs . pacsize_in && theirs . pacsize_out ) { if ( theirs . pacsize_in < ours -> pacsize_in ) { SOCK_DEBUG ( sk , ""X.25:packetsizeinwardsnegotiateddown\\n"" ) ; new -> pacsize_in = theirs . pacsize_in ; } if ( theirs . pacsize_out < ours -> pacsize_out ) { SOCK_DEBUG ( sk , ""X.25:packetsizeoutwardsnegotiateddown\\n"" ) ; new -> pacsize_out = theirs . pacsize_out ; } } if ( theirs . winsize_in && theirs . winsize_out ) { if ( theirs . winsize_in < ours -> winsize_in ) { SOCK_DEBUG ( sk , ""X.25:windowsizeinwardsnegotiateddown\\n"" ) ; new -> winsize_in = theirs . winsize_in ; } if ( theirs . winsize_out < ours -> winsize_out ) { SOCK_DEBUG ( sk , ""X.25:windowsizeoutwardsnegotiateddown\\n"" ) ; new -> winsize_out = theirs . winsize_out ; } } return len ; }"," ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte"
629,"CWE-189 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) {  c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ;  aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }"," c -> tile_width  , 16 )  , 16 ) * 3"
630,"CWE-000 int sqlite3Select ( Parse * pParse , Select * p , SelectDest * pDest ) { int i , j ; WhereInfo * pWInfo ; Vdbe * v ; int isAgg ; ExprList * pEList = 0 ; SrcList * pTabList ; Expr * pWhere ; ExprList * pGroupBy ; Expr * pHaving ; int rc = 1 ; DistinctCtx sDistinct ; SortCtx sSort ; AggInfo sAggInfo ; int iEnd ; sqlite3 * db ; ExprList * pMinMaxOrderBy = 0 ; u8 minMaxFlag ; db = pParse -> db ; v = sqlite3GetVdbe ( pParse ) ; if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { return 1 ; } if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 1 , pParse , p , ( ""beginprocessing:\\n"" , pParse -> addrExplain ) ) ; if ( sqlite3SelectTrace & 0x100 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ) ; if ( IgnorableOrderby ( pDest ) ) { assert ( pDest -> eDest == SRT_Exists || pDest -> eDest == SRT_Union || pDest -> eDest == SRT_Except || pDest -> eDest == SRT_Discard || pDest -> eDest == SRT_Queue || pDest -> eDest == SRT_DistFifo || pDest -> eDest == SRT_DistQueue || pDest -> eDest == SRT_Fifo ) ; sqlite3ExprListDelete ( db , p -> pOrderBy ) ; p -> pOrderBy = 0 ; p -> selFlags &= ~ SF_Distinct ; } sqlite3SelectPrep ( pParse , p , 0 ) ; if ( pParse -> nErr || db -> mallocFailed ) { goto select_end ; } assert ( p -> pEList != 0 ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x104 ) { SELECTTRACE ( 0x104 , pParse , p , ( ""afternameresolution:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( pDest -> eDest == SRT_Output ) { generateColumnNames ( pParse , p ) ; } # ifndef SQLITE_OMIT_WINDOWFUNC if ( sqlite3WindowRewrite ( pParse , p ) ) { goto select_end ; } # if SELECTTRACE_ENABLED if ( p -> pWin && ( sqlite3SelectTrace & 0x108 ) != 0 ) { SELECTTRACE ( 0x104 , pParse , p , ( ""afterwindowrewrite:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif # endif pTabList = p -> pSrc ; isAgg = ( p -> selFlags & SF_Aggregate ) != 0 ; memset ( & sSort , 0 , sizeof ( sSort ) ) ; sSort . pOrderBy = p -> pOrderBy ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) for ( i = 0 ; ! p -> pPrior && i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; Select * pSub = pItem -> pSelect ; Table * pTab = pItem -> pTab ; if ( ( pItem -> fg . jointype & JT_LEFT ) != 0 && sqlite3ExprImpliesNonNullRow ( p -> pWhere , pItem -> iCursor ) && OptimizationEnabled ( db , SQLITE_SimplifyJoin ) ) { SELECTTRACE ( 0x100 , pParse , p , ( ""LEFT-JOINsimplifiestoJOINonterm%d\\n"" , i ) ) ; pItem -> fg . jointype &= ~ ( JT_LEFT | JT_OUTER ) ; unsetJoinExpr ( p -> pWhere , pItem -> iCursor ) ; } if ( pSub == 0 ) continue ; if ( pTab -> nCol != pSub -> pEList -> nExpr ) { sqlite3ErrorMsg ( pParse , ""expected%dcolumnsfor\'%s\'butgot%d"" , pTab -> nCol , pTab -> zName , pSub -> pEList -> nExpr ) ; goto select_end ; } if ( ( pSub -> selFlags & SF_Aggregate ) != 0 ) continue ; assert ( pSub -> pGroupBy == 0 ) ; if ( pSub -> pOrderBy != 0 && i == 0 && ( p -> selFlags & SF_ComplexResult ) != 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { continue ; } if ( flattenSubquery ( pParse , p , i , isAgg ) ) { if ( pParse -> nErr ) goto select_end ; i = - 1 ; } pTabList = p -> pSrc ; if ( db -> mallocFailed ) goto select_end ; if ( ! IgnorableOrderby ( pDest ) ) { sSort . pOrderBy = p -> pOrderBy ; } } # endif # ifndef SQLITE_OMIT_COMPOUND_SELECT if ( p -> pPrior ) { rc = multiSelect ( pParse , p , pDest ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( ""endcompound-selectprocessing\\n"" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( p -> pNext == 0 ) ExplainQueryPlanPop ( pParse ) ; return rc ; } # endif if ( pTabList -> nSrc > 1 && OptimizationEnabled ( db , SQLITE_PropagateConst ) && propagateConstants ( pParse , p ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( ""Afterconstantpropagation:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( ""Constantpropagationnothelpful\\n"" ) ) ; } # ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION if ( OptimizationEnabled ( db , SQLITE_QueryFlattener | SQLITE_CountOfView ) && countOfViewOptimization ( pParse , p ) ) { if ( db -> mallocFailed ) goto select_end ; pEList = p -> pEList ; pTabList = p -> pSrc ; } # endif for ( i = 0 ; i < pTabList -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pTabList -> a [ i ] ; SelectDest dest ; Select * pSub ; # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) const char * zSavedAuthContext ; # endif if ( pItem -> colUsed == 0 && pItem -> zName != 0 ) { sqlite3AuthCheck ( pParse , SQLITE_READ , pItem -> zName , """" , pItem -> zDatabase ) ; } # if ! defined ( SQLITE_OMIT_SUBQUERY ) || ! defined ( SQLITE_OMIT_VIEW ) pSub = pItem -> pSelect ; if ( pSub == 0 ) continue ; testcase ( pItem -> addrFillSub != 0 ) ; pParse -> nHeight += sqlite3SelectExprHeight ( p ) ; if ( OptimizationEnabled ( db , SQLITE_PushDown ) && pushDownWhereTerms ( pParse , pSub , p -> pWhere , pItem -> iCursor , ( pItem -> fg . jointype & JT_OUTER ) != 0 ) ) { # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x100 ) { SELECTTRACE ( 0x100 , pParse , p , ( ""AfterWHERE-clausepush-downintosubquery%d:\\n"" , pSub -> selId ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } else { SELECTTRACE ( 0x100 , pParse , p , ( ""Push-downnotpossible\\n"" ) ) ; } zSavedAuthContext = pParse -> zAuthContext ; pParse -> zAuthContext = pItem -> zName ; if ( i == 0 && ( pTabList -> nSrc == 1 || ( pTabList -> a [ 1 ] . fg . jointype & ( JT_LEFT | JT_CROSS ) ) != 0 ) ) { int addrTop = sqlite3VdbeCurrentAddr ( v ) + 1 ; pItem -> regReturn = ++ pParse -> nMem ; sqlite3VdbeAddOp3 ( v , OP_InitCoroutine , pItem -> regReturn , 0 , addrTop ) ; VdbeComment ( ( v , ""%s"" , pItem -> pTab -> zName ) ) ; pItem -> addrFillSub = addrTop ; sqlite3SelectDestInit ( & dest , SRT_Coroutine , pItem -> regReturn ) ; ExplainQueryPlan ( ( pParse , 1 , ""CO-ROUTINE%u"" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; pItem -> fg . viaCoroutine = 1 ; pItem -> regResult = dest . iSdst ; sqlite3VdbeEndCoroutine ( v , pItem -> regReturn ) ; sqlite3VdbeJumpHere ( v , addrTop - 1 ) ; sqlite3ClearTempRegCache ( pParse ) ; } else { int topAddr ; int onceAddr = 0 ; int retAddr ; struct SrcList_item * pPrior ; testcase ( pItem -> addrFillSub == 0 ) ; pItem -> regReturn = ++ pParse -> nMem ; topAddr = sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , pItem -> regReturn ) ; pItem -> addrFillSub = topAddr + 1 ; if ( pItem -> fg . isCorrelated == 0 ) { onceAddr = sqlite3VdbeAddOp0 ( v , OP_Once ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""materialize\\""%s\\"""" , pItem -> pTab -> zName ) ) ; } else { VdbeNoopComment ( ( v , ""materialize\\""%s\\"""" , pItem -> pTab -> zName ) ) ; } pPrior = isSelfJoinView ( pTabList , pItem ) ; if ( pPrior ) { sqlite3VdbeAddOp2 ( v , OP_OpenDup , pItem -> iCursor , pPrior -> iCursor ) ; assert ( pPrior -> pSelect != 0 ) ; pSub -> nSelectRow = pPrior -> pSelect -> nSelectRow ; } else { sqlite3SelectDestInit ( & dest , SRT_EphemTab , pItem -> iCursor ) ; ExplainQueryPlan ( ( pParse , 1 , ""MATERIALIZE%u"" , pSub -> selId ) ) ; sqlite3Select ( pParse , pSub , & dest ) ; } pItem -> pTab -> nRowLogEst = pSub -> nSelectRow ; if ( onceAddr ) sqlite3VdbeJumpHere ( v , onceAddr ) ; retAddr = sqlite3VdbeAddOp1 ( v , OP_Return , pItem -> regReturn ) ; VdbeComment ( ( v , ""end%s"" , pItem -> pTab -> zName ) ) ; sqlite3VdbeChangeP1 ( v , topAddr , retAddr ) ; sqlite3ClearTempRegCache ( pParse ) ; } if ( db -> mallocFailed ) goto select_end ; pParse -> nHeight -= sqlite3SelectExprHeight ( p ) ; pParse -> zAuthContext = zSavedAuthContext ; # endif } pEList = p -> pEList ; pWhere = p -> pWhere ; pGroupBy = p -> pGroupBy ; pHaving = p -> pHaving ; sDistinct . isTnct = ( p -> selFlags & SF_Distinct ) != 0 ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( ""AfterallFROM-clauseanalysis:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0  ) {  p -> selFlags &= ~ SF_Distinct ; pGroupBy = p -> pGroupBy = sqlite3ExprListDup ( db , pEList , 0 ) ; assert ( sDistinct . isTnct ) ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { SELECTTRACE ( 0x400 , pParse , p , ( ""TransformDISTINCTintoGROUPBY:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif } if ( sSort . pOrderBy ) { KeyInfo * pKeyInfo ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , sSort . pOrderBy , 0 , pEList -> nExpr ) ; sSort . iECursor = pParse -> nTab ++ ; sSort . addrSortIndex = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sSort . iECursor , sSort . pOrderBy -> nExpr + 1 + pEList -> nExpr , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } else { sSort . addrSortIndex = - 1 ; } if ( pDest -> eDest == SRT_EphemTab ) { sqlite3VdbeAddOp2 ( v , OP_OpenEphemeral , pDest -> iSDParm , pEList -> nExpr ) ; } iEnd = sqlite3VdbeMakeLabel ( pParse ) ; if ( ( p -> selFlags & SF_FixedLimit ) == 0 ) { p -> nSelectRow = 320 ; } computeLimitRegisters ( pParse , p , iEnd ) ; if ( p -> iLimit == 0 && sSort . addrSortIndex >= 0 ) { sqlite3VdbeChangeOpcode ( v , sSort . addrSortIndex , OP_SorterOpen ) ; sSort . sortFlags |= SORTFLAG_UseSorter ; } if ( p -> selFlags & SF_Distinct ) { sDistinct . tabTnct = pParse -> nTab ++ ; sDistinct . addrTnct = sqlite3VdbeAddOp4 ( v , OP_OpenEphemeral , sDistinct . tabTnct , 0 , 0 , ( char * ) sqlite3KeyInfoFromExprList ( pParse , p -> pEList , 0 , 0 ) , P4_KEYINFO ) ; sqlite3VdbeChangeP5 ( v , BTREE_UNORDERED ) ; sDistinct . eTnctType = WHERE_DISTINCT_UNORDERED ; } else { sDistinct . eTnctType = WHERE_DISTINCT_NOOP ; } if ( ! isAgg && pGroupBy == 0 ) { u16 wctrlFlags = ( sDistinct . isTnct ? WHERE_WANT_DISTINCT : 0 ) | ( p -> selFlags & SF_FixedLimit ) ; # ifndef SQLITE_OMIT_WINDOWFUNC Window * pWin = p -> pWin ; if ( pWin ) { sqlite3WindowCodeInit ( pParse , pWin ) ; } # endif assert ( WHERE_USE_LIMIT == SF_FixedLimit ) ; SELECTTRACE ( 1 , pParse , p , ( ""WhereBegin\\n"" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , sSort . pOrderBy , p -> pEList , wctrlFlags , p -> nSelectRow ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereOutputRowCount ( pWInfo ) < p -> nSelectRow ) { p -> nSelectRow = sqlite3WhereOutputRowCount ( pWInfo ) ; } if ( sDistinct . isTnct && sqlite3WhereIsDistinct ( pWInfo ) ) { sDistinct . eTnctType = sqlite3WhereIsDistinct ( pWInfo ) ; } if ( sSort . pOrderBy ) { sSort . nOBSat = sqlite3WhereIsOrdered ( pWInfo ) ; sSort . labelOBLopt = sqlite3WhereOrderByLimitOptLabel ( pWInfo ) ; if ( sSort . nOBSat == sSort . pOrderBy -> nExpr ) { sSort . pOrderBy = 0 ; } } if ( sSort . addrSortIndex >= 0 && sSort . pOrderBy == 0 ) { sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } assert ( p -> pEList == pEList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC if ( pWin ) { int addrGosub = sqlite3VdbeMakeLabel ( pParse ) ; int iCont = sqlite3VdbeMakeLabel ( pParse ) ; int iBreak = sqlite3VdbeMakeLabel ( pParse ) ; int regGosub = ++ pParse -> nMem ; sqlite3WindowCodeStep ( pParse , p , pWInfo , regGosub , addrGosub ) ; sqlite3VdbeAddOp2 ( v , OP_Goto , 0 , iBreak ) ; sqlite3VdbeResolveLabel ( v , addrGosub ) ; VdbeNoopComment ( ( v , ""inner-loopsubroutine"" ) ) ; sSort . labelOBLopt = 0 ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , iCont , iBreak ) ; sqlite3VdbeResolveLabel ( v , iCont ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regGosub ) ; VdbeComment ( ( v , ""endinner-loopsubroutine"" ) ) ; sqlite3VdbeResolveLabel ( v , iBreak ) ; } else # endif { selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , sqlite3WhereContinueLabel ( pWInfo ) , sqlite3WhereBreakLabel ( pWInfo ) ) ; sqlite3WhereEnd ( pWInfo ) ; } } else { NameContext sNC ; int iAMem ; int iBMem ; int iUseFlag ; int iAbortFlag ; int groupBySort ; int addrEnd ; int sortPTab = 0 ; int sortOut = 0 ; int orderByGrp = 0 ; if ( pGroupBy ) { int k ; struct ExprList_item * pItem ; for ( k = p -> pEList -> nExpr , pItem = p -> pEList -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } for ( k = pGroupBy -> nExpr , pItem = pGroupBy -> a ; k > 0 ; k -- , pItem ++ ) { pItem -> u . x . iAlias = 0 ; } assert ( 66 == sqlite3LogEst ( 100 ) ) ; if ( p -> nSelectRow > 66 ) p -> nSelectRow = 66 ; if ( sSort . pOrderBy && pGroupBy -> nExpr == sSort . pOrderBy -> nExpr ) { int ii ; for ( ii = 0 ; ii < pGroupBy -> nExpr ; ii ++ ) { u8 sortFlags = sSort . pOrderBy -> a [ ii ] . sortFlags & KEYINFO_ORDER_DESC ; pGroupBy -> a [ ii ] . sortFlags = sortFlags ; } if ( sqlite3ExprListCompare ( pGroupBy , sSort . pOrderBy , - 1 ) == 0 ) { orderByGrp = 1 ; } } } else { assert ( 0 == sqlite3LogEst ( 1 ) ) ; p -> nSelectRow = 0 ; } addrEnd = sqlite3VdbeMakeLabel ( pParse ) ; memset ( & sNC , 0 , sizeof ( sNC ) ) ; sNC . pParse = pParse ; sNC . pSrcList = pTabList ; sNC . uNC . pAggInfo = & sAggInfo ; VVA_ONLY ( sNC . ncFlags = NC_UAggInfo ; ) sAggInfo . mnReg = pParse -> nMem + 1 ; sAggInfo . nSortingColumn = pGroupBy ? pGroupBy -> nExpr : 0 ; sAggInfo . pGroupBy = pGroupBy ; sqlite3ExprAnalyzeAggList ( & sNC , pEList ) ; sqlite3ExprAnalyzeAggList ( & sNC , sSort . pOrderBy ) ; if ( pHaving ) { if ( pGroupBy ) { assert ( pWhere == p -> pWhere ) ; assert ( pHaving == p -> pHaving ) ; assert ( pGroupBy == p -> pGroupBy ) ; havingToWhere ( pParse , p ) ; pWhere = p -> pWhere ; } sqlite3ExprAnalyzeAggregates ( & sNC , pHaving ) ; } sAggInfo . nAccumulator = sAggInfo . nColumn ; if ( p -> pGroupBy == 0 && p -> pHaving == 0 && sAggInfo . nFunc == 1 ) { minMaxFlag = minMaxQuery ( db , sAggInfo . aFunc [ 0 ] . pExpr , & pMinMaxOrderBy ) ; } else { minMaxFlag = WHERE_ORDERBY_NORMAL ; } for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { Expr * pExpr = sAggInfo . aFunc [ i ] . pExpr ; assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; sNC . ncFlags |= NC_InAggFunc ; sqlite3ExprAnalyzeAggList ( & sNC , pExpr -> x . pList ) ; # ifndef SQLITE_OMIT_WINDOWFUNC assert ( ! IsWindowFunc ( pExpr ) ) ; if ( ExprHasProperty ( pExpr , EP_WinFunc ) ) { sqlite3ExprAnalyzeAggregates ( & sNC , pExpr -> y . pWin -> pFilter ) ; } # endif sNC . ncFlags &= ~ NC_InAggFunc ; } sAggInfo . mxReg = pParse -> nMem ; if ( db -> mallocFailed ) goto select_end ; # if SELECTTRACE_ENABLED if ( sqlite3SelectTrace & 0x400 ) { int ii ; SELECTTRACE ( 0x400 , pParse , p , ( ""Afteraggregateanalysis:\\n"" ) ) ; sqlite3TreeViewSelect ( 0 , p , 0 ) ; for ( ii = 0 ; ii < sAggInfo . nColumn ; ii ++ ) { sqlite3DebugPrintf ( ""agg-column[%d]iMem=%d\\n"" , ii , sAggInfo . aCol [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aCol [ ii ] . pExpr , 0 ) ; } for ( ii = 0 ; ii < sAggInfo . nFunc ; ii ++ ) { sqlite3DebugPrintf ( ""agg-func[%d]:iMem=%d\\n"" , ii , sAggInfo . aFunc [ ii ] . iMem ) ; sqlite3TreeViewExpr ( 0 , sAggInfo . aFunc [ ii ] . pExpr , 0 ) ; } } # endif if ( pGroupBy ) { KeyInfo * pKeyInfo ; int addr1 ; int addrOutputRow ; int regOutputRow ; int addrSetAbort ; int addrTopOfLoop ; int addrSortingIdx ; int addrReset ; int regReset ; sAggInfo . sortingIdx = pParse -> nTab ++ ; pKeyInfo = sqlite3KeyInfoFromExprList ( pParse , pGroupBy , 0 , sAggInfo . nColumn ) ; addrSortingIdx = sqlite3VdbeAddOp4 ( v , OP_SorterOpen , sAggInfo . sortingIdx , sAggInfo . nSortingColumn , 0 , ( char * ) pKeyInfo , P4_KEYINFO ) ; iUseFlag = ++ pParse -> nMem ; iAbortFlag = ++ pParse -> nMem ; regOutputRow = ++ pParse -> nMem ; addrOutputRow = sqlite3VdbeMakeLabel ( pParse ) ; regReset = ++ pParse -> nMem ; addrReset = sqlite3VdbeMakeLabel ( pParse ) ; iAMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; iBMem = pParse -> nMem + 1 ; pParse -> nMem += pGroupBy -> nExpr ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iAbortFlag ) ; VdbeComment ( ( v , ""clearabortflag"" ) ) ; sqlite3VdbeAddOp3 ( v , OP_Null , 0 , iAMem , iAMem + pGroupBy -> nExpr - 1 ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; SELECTTRACE ( 1 , pParse , p , ( ""WhereBegin\\n"" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pGroupBy , 0 , WHERE_GROUPBY | ( orderByGrp ? WHERE_SORTBYGROUP : 0 ) , 0 ) ; if ( pWInfo == 0 ) goto select_end ; if ( sqlite3WhereIsOrdered ( pWInfo ) == pGroupBy -> nExpr ) { groupBySort = 0 ; } else { int regBase ; int regRecord ; int nCol ; int nGroupBy ; explainTempTable ( pParse , ( sDistinct . isTnct && ( p -> selFlags & SF_Distinct ) == 0 ) ? ""DISTINCT"" : ""GROUPBY"" ) ; groupBySort = 1 ; nGroupBy = pGroupBy -> nExpr ; nCol = nGroupBy ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { if ( sAggInfo . aCol [ i ] . iSorterColumn >= j ) { nCol ++ ; j ++ ; } } regBase = sqlite3GetTempRange ( pParse , nCol ) ; sqlite3ExprCodeExprList ( pParse , pGroupBy , regBase , 0 , 0 ) ; j = nGroupBy ; for ( i = 0 ; i < sAggInfo . nColumn ; i ++ ) { struct AggInfo_col * pCol = & sAggInfo . aCol [ i ] ; if ( pCol -> iSorterColumn >= j ) { int r1 = j + regBase ; sqlite3ExprCodeGetColumnOfTable ( v , pCol -> pTab , pCol -> iTable , pCol -> iColumn , r1 ) ; j ++ ; } } regRecord = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_MakeRecord , regBase , nCol , regRecord ) ; sqlite3VdbeAddOp2 ( v , OP_SorterInsert , sAggInfo . sortingIdx , regRecord ) ; sqlite3ReleaseTempReg ( pParse , regRecord ) ; sqlite3ReleaseTempRange ( pParse , regBase , nCol ) ; sqlite3WhereEnd ( pWInfo ) ; sAggInfo . sortingIdxPTab = sortPTab = pParse -> nTab ++ ; sortOut = sqlite3GetTempReg ( pParse ) ; sqlite3VdbeAddOp3 ( v , OP_OpenPseudo , sortPTab , sortOut , nCol ) ; sqlite3VdbeAddOp2 ( v , OP_SorterSort , sAggInfo . sortingIdx , addrEnd ) ; VdbeComment ( ( v , ""GROUPBYsort"" ) ) ; VdbeCoverage ( v ) ; sAggInfo . useSortingIdx = 1 ; } if ( orderByGrp && OptimizationEnabled ( db , SQLITE_GroupByOrder ) && ( groupBySort || sqlite3WhereIsSorted ( pWInfo ) ) ) { sSort . pOrderBy = 0 ; sqlite3VdbeChangeToNoop ( v , sSort . addrSortIndex ) ; } addrTopOfLoop = sqlite3VdbeCurrentAddr ( v ) ; if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_SorterData , sAggInfo . sortingIdx , sortOut , sortPTab ) ; } for ( j = 0 ; j < pGroupBy -> nExpr ; j ++ ) { if ( groupBySort ) { sqlite3VdbeAddOp3 ( v , OP_Column , sortPTab , j , iBMem + j ) ; } else { sAggInfo . directMode = 1 ; sqlite3ExprCode ( pParse , pGroupBy -> a [ j ] . pExpr , iBMem + j ) ; } } sqlite3VdbeAddOp4 ( v , OP_Compare , iAMem , iBMem , pGroupBy -> nExpr , ( char * ) sqlite3KeyInfoRef ( pKeyInfo ) , P4_KEYINFO ) ; addr1 = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp3 ( v , OP_Jump , addr1 + 1 , 0 , addr1 + 1 ) ; VdbeCoverage ( v ) ; sqlite3ExprCodeMove ( pParse , iBMem , iAMem , pGroupBy -> nExpr ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , ""outputonerow"" ) ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iAbortFlag , addrEnd ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""checkabortflag"" ) ) ; sqlite3VdbeAddOp2 ( v , OP_Gosub , regReset , addrReset ) ; VdbeComment ( ( v , ""resetaccumulator"" ) ) ; sqlite3VdbeJumpHere ( v , addr1 ) ; updateAccumulator ( pParse , iUseFlag , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iUseFlag ) ; VdbeComment ( ( v , ""indicatedatainaccumulator"" ) ) ; if ( groupBySort ) { sqlite3VdbeAddOp2 ( v , OP_SorterNext , sAggInfo . sortingIdx , addrTopOfLoop ) ; VdbeCoverage ( v ) ; } else { sqlite3WhereEnd ( pWInfo ) ; sqlite3VdbeChangeToNoop ( v , addrSortingIdx ) ; } sqlite3VdbeAddOp2 ( v , OP_Gosub , regOutputRow , addrOutputRow ) ; VdbeComment ( ( v , ""outputfinalrow"" ) ) ; sqlite3VdbeGoto ( v , addrEnd ) ; addrSetAbort = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , iAbortFlag ) ; VdbeComment ( ( v , ""setabortflag"" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; sqlite3VdbeResolveLabel ( v , addrOutputRow ) ; addrOutputRow = sqlite3VdbeCurrentAddr ( v ) ; sqlite3VdbeAddOp2 ( v , OP_IfPos , iUseFlag , addrOutputRow + 2 ) ; VdbeCoverage ( v ) ; VdbeComment ( ( v , ""Groupbyresultgeneratorentrypoint"" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; sqlite3ExprIfFalse ( pParse , pHaving , addrOutputRow + 1 , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , & sSort , & sDistinct , pDest , addrOutputRow + 1 , addrSetAbort ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regOutputRow ) ; VdbeComment ( ( v , ""endgroupbyresultgenerator"" ) ) ; sqlite3VdbeResolveLabel ( v , addrReset ) ; resetAccumulator ( pParse , & sAggInfo ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , iUseFlag ) ; VdbeComment ( ( v , ""indicateaccumulatorempty"" ) ) ; sqlite3VdbeAddOp1 ( v , OP_Return , regReset ) ; } else { # ifndef SQLITE_OMIT_BTREECOUNT Table * pTab ; if ( ( pTab = isSimpleCount ( p , & sAggInfo ) ) != 0 ) { const int iDb = sqlite3SchemaToIndex ( pParse -> db , pTab -> pSchema ) ; const int iCsr = pParse -> nTab ++ ; Index * pIdx ; KeyInfo * pKeyInfo = 0 ; Index * pBest = 0 ; int iRoot = pTab -> tnum ; sqlite3CodeVerifySchema ( pParse , iDb ) ; sqlite3TableLock ( pParse , iDb , pTab -> tnum , 0 , pTab -> zName ) ; if ( ! HasRowid ( pTab ) ) pBest = sqlite3PrimaryKeyIndex ( pTab ) ; for ( pIdx = pTab -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { if ( pIdx -> bUnordered == 0 && pIdx -> szIdxRow < pTab -> szTabRow && pIdx -> pPartIdxWhere == 0 && ( ! pBest || pIdx -> szIdxRow < pBest -> szIdxRow ) ) { pBest = pIdx ; } } if ( pBest ) { iRoot = pBest -> tnum ; pKeyInfo = sqlite3KeyInfoOfIndex ( pParse , pBest ) ; } sqlite3VdbeAddOp4Int ( v , OP_OpenRead , iCsr , iRoot , iDb , 1 ) ; if ( pKeyInfo ) { sqlite3VdbeChangeP4 ( v , - 1 , ( char * ) pKeyInfo , P4_KEYINFO ) ; } sqlite3VdbeAddOp2 ( v , OP_Count , iCsr , sAggInfo . aFunc [ 0 ] . iMem ) ; sqlite3VdbeAddOp1 ( v , OP_Close , iCsr ) ; explainSimpleCount ( pParse , pTab , pBest ) ; } else # endif { int regAcc = 0 ; if ( sAggInfo . nAccumulator ) { for ( i = 0 ; i < sAggInfo . nFunc ; i ++ ) { if ( ExprHasProperty ( sAggInfo . aFunc [ i ] . pExpr , EP_WinFunc ) ) continue ; if ( sAggInfo . aFunc [ i ] . pFunc -> funcFlags & SQLITE_FUNC_NEEDCOLL ) break ; } if ( i == sAggInfo . nFunc ) { regAcc = ++ pParse -> nMem ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , regAcc ) ; } } assert ( p -> pGroupBy == 0 ) ; resetAccumulator ( pParse , & sAggInfo ) ; assert ( minMaxFlag == WHERE_ORDERBY_NORMAL || pMinMaxOrderBy != 0 ) ; assert ( pMinMaxOrderBy == 0 || pMinMaxOrderBy -> nExpr == 1 ) ; SELECTTRACE ( 1 , pParse , p , ( ""WhereBegin\\n"" ) ) ; pWInfo = sqlite3WhereBegin ( pParse , pTabList , pWhere , pMinMaxOrderBy , 0 , minMaxFlag , 0 ) ; if ( pWInfo == 0 ) { goto select_end ; } updateAccumulator ( pParse , regAcc , & sAggInfo ) ; if ( regAcc ) sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , regAcc ) ; if ( sqlite3WhereIsOrdered ( pWInfo ) > 0 ) { sqlite3VdbeGoto ( v , sqlite3WhereBreakLabel ( pWInfo ) ) ; VdbeComment ( ( v , ""%s()byindex"" , ( minMaxFlag == WHERE_ORDERBY_MIN ? ""min"" : ""max"" ) ) ) ; } sqlite3WhereEnd ( pWInfo ) ; finalizeAggFunctions ( pParse , & sAggInfo ) ; } sSort . pOrderBy = 0 ; sqlite3ExprIfFalse ( pParse , pHaving , addrEnd , SQLITE_JUMPIFNULL ) ; selectInnerLoop ( pParse , p , - 1 , 0 , 0 , pDest , addrEnd , addrEnd ) ; } sqlite3VdbeResolveLabel ( v , addrEnd ) ; } if ( sDistinct . eTnctType == WHERE_DISTINCT_UNORDERED ) { explainTempTable ( pParse , ""DISTINCT"" ) ; } if ( sSort . pOrderBy ) { explainTempTable ( pParse , sSort . nOBSat > 0 ? ""RIGHTPARTOFORDERBY"" : ""ORDERBY"" ) ; assert ( p -> pEList == pEList ) ; generateSortTail ( pParse , p , & sSort , pEList -> nExpr , pDest ) ; } sqlite3VdbeResolveLabel ( v , iEnd ) ; rc = ( pParse -> nErr > 0 ) ; select_end : sqlite3ExprListDelete ( db , pMinMaxOrderBy ) ; sqlite3DbFree ( db , sAggInfo . aCol ) ; sqlite3DbFree ( db , sAggInfo . aFunc ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 0x1 , pParse , p , ( ""endprocessing\\n"" ) ) ; if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif ExplainQueryPlanPop ( pParse ) ; return rc ; }", ) == 0 && p -> pWin == 0
631,"CWE-119 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels%disinvalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblksizeinvalid\\n"" ) ; return AVERROR_INVALIDDATA ; }  c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;  if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extracblkstyles%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }"," AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblksize>64"" ) ; return AVERROR_PATCHWELCOME ; }"
632,CWE-399 void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ;  kfree ( fpl ) ;  } }, ] ) ; free_uid ( fpl -> user ) ;
633,"CWE-119 void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , MB_MODE_INFO * const mbmi , int mi_row , int mi_col ,  BLOCK_SIZE bsize , int use_rd ) {  const VP9_COMMON * const cm = & cpi -> common ; CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; const int block_index = mi_row * cm -> mi_cols + mi_col ;  const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ;  int new_map_value = cr -> map [ block_index ] ; int x = 0 ; int y = 0 ;  if ( mbmi -> segment_id > 0 && ! refresh_this_block )  mbmi -> segment_id = 0 ;  if ( mbmi -> segment_id == 1 ) {  new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] == 1 ) new_map_value = 0 ; } else { new_map_value = 1 ; } for ( y = 0 ; y < ymis ; y ++ ) for ( x = 0 ; x < xmis ; x ++ ) {  cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ;   cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] =  mbmi -> segment_id ; } if ( mbmi -> segment_id ) cr -> num_seg_blocks += xmis * ymis ; }"," BLOCK_SIZE bsize , int64_t rate , int64_t dist , int skip  ) { const  , mbmi , rate , dist , bsize  ) ; int  ; if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ]  == 1 )  == 1 )  new_map_value = 0  ++ ) { int map_offset =  block_index + y  mi_cols + x ; cr -> map [ map_offset  -> segmentation_map [ map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; }  }  "
634,"CWE-22  static char * create_output_name ( unsigned char * fname , unsigned char * dir ,  int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ;  if ( utf8 ) x *= 3 ;  if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) {  fprintf ( stderr , ""outofmemory!\\n"" ) ;  return NULL ; } * name = '\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , ""/"" ) ; }  while ( * fname == sep ) fname ++ ;   p = & name [ strlen ( ( char * ) name ) ] ;  fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do {  if ( fname >= fe ) {  free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) {  x = ( c & 0x1F ) << 6 ;  x |= * fname ++ & 0x3F ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= * fname ++ & 0x3F ; } else x = '?' ; } if ( x == sep ) x = '/' ; else if ( x == slash ) x = '\\\\' ; else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ; if ( x < 0x80 ) { * p ++ = ( unsigned char ) x ; } else if ( x < 0x800 ) { * p ++ = 0xC0 | ( x >> 6 ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } else { * p ++ = 0xE0 | ( x >> 12 ) ; * p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ; * p ++ = 0x80 | ( x & 0x3F ) ; }  } while ( x ) ;  } else { do { c = * fname ++ ; if ( c == sep ) c = '/' ; else if ( c == slash ) c = '\\\\' ; else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ; } while ( ( * p ++ = c ) ) ; } return ( char * ) name ; }","     char * create_output_name  * create_output_name (  char * fname  char * fname ) { char * out , * p  ; if (  ; if ( ( out = malloc ( strlen ( fname ) + 1  ) ) )  ) ) {  while ( *  * fname == '/' || * fname == '\\\\'  ) fname ++  fname ++ ; strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ )  { if (  { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\'  ) ) {  ) ) { p [ 0 ] = p [ 1 ] = 'x'  ; } }  ; } } } return out  ; } "
635,"CWE-264 struct tcp_sock_t * tcp_open ( uint16_t port ) { struct tcp_sock_t * this = calloc ( 1 , sizeof * this ) ; if ( this == NULL ) {  ERR ( ""callocingthisfailed"" ) ;  goto error ; } this -> sd = - 1 ;  this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ;  if ( this -> sd < 0 ) {  ERR ( ""sockectopenfailed"" ) ;  goto error ; } struct sockaddr_in6 addr ; memset ( & addr , 0 , sizeof addr ) ;  addr . sin6_family = AF_INET6 ;  addr . sin6_port = htons ( port ) ;  addr . sin6_addr = in6addr_any ;  if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) { if ( g_options . only_desired_port == 1 )  ERR ( ""Bindonportfailed.""  ""Requestedportmaybetakenorrequirerootpermissions."" ) ; goto error ; } if ( listen ( this -> sd , HTTP_MAX_PENDING_CONNS ) < 0 ) {  ERR ( ""listenfailedonsocket"" ) ;  goto error ; } return this ; error : if ( this != NULL ) { if ( this -> sd != - 1 ) { close ( this -> sd ) ; } free ( this ) ; } return NULL ; }"," { ERR ( ""IPv4:callocingthisfailed""  ) ; goto  = socket ( AF_INET  , SOCK_STREAM ,  { ERR ( ""IPv4socketopenfailed"" ) ; goto error ; } struct sockaddr_in  addr ; memset  ; addr . sin_family = AF_INET ; addr . sin_port  = htons (  ; addr . sin_addr . s_addr = htonl ( 0x7F000001 )  ; if (  ) ERR ( ""IPv4bindonportfailed.""  ""Requestedportmaybetakenorrequirerootpermissions."" ) ;  { ERR ( ""IPv4listenfailedonsocket""  ) ; goto"
636,"CWE-20 void freeClient ( redisClient * c ) { listNode * ln ; sdsfree ( c -> querybuf ) ; c -> querybuf = NULL ; if ( c -> flags & REDIS_BLOCKED ) unblockClientWaitingData ( c ) ; unwatchAllKeys ( c ) ; listRelease ( c -> watched_keys ) ; pubsubUnsubscribeAllChannels ( c , 0 ) ; pubsubUnsubscribeAllPatterns ( c , 0 ) ; dictRelease ( c -> pubsub_channels ) ; listRelease ( c -> pubsub_patterns ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_READABLE ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_WRITABLE ) ; listRelease ( c -> reply ) ; freeClientArgv ( c ) ; close ( c -> fd ) ; ln = listSearchKey ( server . clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . clients , ln ) ; if ( c -> flags & REDIS_IO_WAIT ) {  redisAssert ( server . vm_enabled ) ;  if ( listLength ( c -> io_keys ) == 0 ) { ln = listSearchKey ( server . io_ready_clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . io_ready_clients , ln ) ; } else { while ( listLength ( c -> io_keys ) ) { ln = listFirst ( c -> io_keys ) ; dontWaitForSwappedKey ( c , ln -> value ) ; } }  server . vm_blocked_clients -- ;  } listRelease ( c -> io_keys ) ; if ( c -> flags & REDIS_SLAVE ) { if ( c -> replstate == REDIS_REPL_SEND_BULK && c -> repldbfd != - 1 ) close ( c -> repldbfd ) ; list * l = ( c -> flags & REDIS_MONITOR ) ? server . monitors : server . slaves ; ln = listSearchKey ( l , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( l , ln ) ; } if ( c -> flags & REDIS_MASTER ) { server . master = NULL ; server . replstate = REDIS_REPL_CONNECT ; while ( listLength ( server . slaves ) ) { ln = listFirst ( server . slaves ) ; freeClient ( ( redisClient * ) ln -> value ) ; } } zfree ( c -> argv ) ; freeClientMultiState ( c ) ; zfree ( c ) ; }", ( server . ds_enabled  ) ; if  } server . cache_blocked_clients  -- ; }
637,"CWE-189  void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc ,   int length , int offset , int total_size )  { struct oz_port * port = hport ; struct urb * urb ; int err = 0 ; oz_dbg ( ON , ""oz_hcd_get_desc_cnflength=%doffs=%dtot_size=%d\\n"" , length , offset , total_size ) ; urb = oz_find_urb_by_id ( port , 0 , req_id ) ; if ( ! urb ) return ; if ( status == 0 ) {  int copy_len ;   int required_size = urb -> transfer_buffer_length ;  if ( required_size > total_size ) required_size = total_size ; copy_len = required_size - offset ; if ( length <= copy_len ) copy_len = length ; memcpy ( urb -> transfer_buffer + offset , desc , copy_len ) ; offset += copy_len ; if ( offset < required_size ) { struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) ) err = - ENOMEM ; else if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) ) { oz_dequeue_ep_urb ( port , 0 , 0 , urb ) ; err = - ENOMEM ; } if ( err == 0 ) return ; } } urb -> actual_length = total_size ; oz_complete_urb ( port -> ozhcd -> hcd , urb , 0 ) ; }"," u8 req_id , u8  status , const  * desc , u8 length , u16 offset , u16  total_size ) {  0 ) { unsigned  int copy_len ; unsigned"
638,"CWE-190 static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { info . flags = 0 ; break ; } info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; if ( vdev -> bar_mmap_supported [ info . index ] ) { info . flags |= VFIO_REGION_INFO_FLAG_MMAP ; if ( info . index == vdev -> msix_bar ) { ret = msix_sparse_mmap_cap ( vdev , & caps ) ; if ( ret ) return ret ; } } break ; case VFIO_PCI_ROM_REGION_INDEX : { void __iomem * io ; size_t size ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . flags = 0 ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ; else break ; } io = pci_map_rom ( pdev , & size ) ; if ( ! io || ! size ) { info . size = 0 ; break ; } pci_unmap_rom ( pdev , io ) ; info . flags = VFIO_REGION_INFO_FLAG_READ ; break ; } case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = 0xc0000 ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ; i = info . index - VFIO_PCI_NUM_REGIONS ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = vdev -> region [ i ] . size ; info . flags = vdev -> region [ i ] . flags ; ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ; if ( ret ) return ret ; } if ( caps . size ) { info . flags |= VFIO_REGION_INFO_FLAG_CAPS ; if ( info . argsz < sizeof ( info ) + caps . size ) { info . argsz = sizeof ( info ) + caps . size ; info . cap_offset = 0 ; } else { vfio_info_cap_shift ( & caps , sizeof ( info ) ) ; if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) { kfree ( caps . buf ) ; return - EFAULT ; } info . cap_offset = sizeof ( info ) ; } kfree ( caps . buf ) ; } return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) { struct vfio_irq_info info ; minsz = offsetofend ( struct vfio_irq_info , count ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ; case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ; default : return - EINVAL ; } info . flags = VFIO_IRQ_INFO_EVENTFD ; info . count = vfio_pci_get_irq_count ( vdev , info . index ) ; if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ; else info . flags |= VFIO_IRQ_INFO_NORESIZE ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_SET_IRQS ) { struct vfio_irq_set hdr ;  u8 * data = NULL ;   int ret = 0 ;  minsz = offsetofend ( struct vfio_irq_set , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS ||  hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK |  VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ;  if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) {  size_t size ; int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;  if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL )  size = sizeof ( uint8_t ) ; else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ; else return - EINVAL ; if ( hdr . argsz - minsz < hdr . count * size ||  hdr . start >= max || hdr . start + hdr . count > max )  return - EINVAL ; data = memdup_user ( ( void __user * ) ( arg + minsz ) , hdr . count * size ) ; if ( IS_ERR ( data ) ) return PTR_ERR ( data ) ; } mutex_lock ( & vdev -> igate ) ; ret = vfio_pci_set_irqs_ioctl ( vdev , hdr . flags , hdr . index , hdr . start , hdr . count , data ) ; mutex_unlock ( & vdev -> igate ) ; kfree ( data ) ; return ret ; } else if ( cmd == VFIO_DEVICE_RESET ) { return vdev -> reset_works ? pci_try_reset_function ( vdev -> pdev ) : - EINVAL ; } else if ( cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO ) { struct vfio_pci_hot_reset_info hdr ; struct vfio_pci_fill_info fill = { 0 } ; struct vfio_pci_dependent_device * devices = NULL ; bool slot = false ; int ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset_info , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz ) return - EINVAL ; hdr . flags = 0 ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & fill . max , slot ) ; if ( ret ) return ret ; WARN_ON ( ! fill . max ) ; if ( hdr . argsz < sizeof ( hdr ) + ( fill . max * sizeof ( * devices ) ) ) { ret = - ENOSPC ; hdr . count = fill . max ; goto reset_info_exit ; } devices = kcalloc ( fill . max , sizeof ( * devices ) , GFP_KERNEL ) ; if ( ! devices ) return - ENOMEM ; fill . devices = devices ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_fill_devs , & fill , slot ) ; if ( ! ret ) hdr . count = fill . cur ; reset_info_exit : if ( copy_to_user ( ( void __user * ) arg , & hdr , minsz ) ) ret = - EFAULT ; if ( ! ret ) { if ( copy_to_user ( ( void __user * ) ( arg + minsz ) , devices , hdr . count * sizeof ( * devices ) ) ) ret = - EFAULT ; } kfree ( devices ) ; return ret ; } else if ( cmd == VFIO_DEVICE_PCI_HOT_RESET ) { struct vfio_pci_hot_reset hdr ; int32_t * group_fds ; struct vfio_pci_group_entry * groups ; struct vfio_pci_group_info info ; bool slot = false ; int i , count = 0 , ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . flags ) return - EINVAL ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & count , slot ) ; if ( ret ) return ret ; if ( ! hdr . count || hdr . count > count ) return - EINVAL ; group_fds = kcalloc ( hdr . count , sizeof ( * group_fds ) , GFP_KERNEL ) ; groups = kcalloc ( hdr . count , sizeof ( * groups ) , GFP_KERNEL ) ; if ( ! group_fds || ! groups ) { kfree ( group_fds ) ; kfree ( groups ) ; return - ENOMEM ; } if ( copy_from_user ( group_fds , ( void __user * ) ( arg + minsz ) , hdr . count * sizeof ( * group_fds ) ) ) { kfree ( group_fds ) ; kfree ( groups ) ; return - EFAULT ; } for ( i = 0 ; i < hdr . count ; i ++ ) { struct vfio_group * group ; struct fd f = fdget ( group_fds [ i ] ) ; if ( ! f . file ) { ret = - EBADF ; break ; } group = vfio_group_get_external_user ( f . file ) ; fdput ( f ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; break ; } groups [ i ] . group = group ; groups [ i ] . id = vfio_external_user_iommu_id ( group ) ; } kfree ( group_fds ) ; if ( ret ) goto hot_reset_release ; info . count = hdr . count ; info . groups = groups ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_validate_devs , & info , slot ) ; if ( ! ret ) ret = slot ? pci_try_reset_slot ( vdev -> pdev -> slot ) : pci_try_reset_bus ( vdev -> pdev -> bus ) ; hot_reset_release : for ( i -- ; i >= 0 ; i -- ) vfio_group_put_external_user ( groups [ i ] . group ) ; kfree ( groups ) ; return ret ; } return - ENOTTY ; }"," vfio_irq_set hdr ; size_t size ;  NULL ; int max ,  || hdr . count >= ( U32_MAX - hdr . start ) || hdr .  - EINVAL ;  max = vfio_pci_get_irq_count  ; if (  hdr . start  count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size"
639,"CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ; } return 1 ; case HTML_U : obuf -> in_under ++ ; if ( obuf -> in_under > 1 ) return 1 ; return 0 ; case HTML_N_U : if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) { obuf -> in_under -- ; if ( obuf -> in_under == 0 ) return 0 ; } return 1 ; case HTML_EM : HTMLlineproc1 ( ""<i>"" , h_env ) ; return 1 ; case HTML_N_EM : HTMLlineproc1 ( ""</i>"" , h_env ) ; return 1 ; case HTML_STRONG : HTMLlineproc1 ( ""<b>"" , h_env ) ; return 1 ; case HTML_N_STRONG : HTMLlineproc1 ( ""</b>"" , h_env ) ; return 1 ; case HTML_Q : HTMLlineproc1 ( ""`"" , h_env ) ; return 1 ; case HTML_N_Q : HTMLlineproc1 ( ""\'"" , h_env ) ; return 1 ; case HTML_P : case HTML_N_P : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; if ( cmd == HTML_P ) { set_alignment ( obuf , tag ) ; obuf -> flag |= RB_P ; } return 1 ; case HTML_BR : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; h_env -> blank_lines = 0 ; return 1 ; case HTML_H : if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } HTMLlineproc1 ( ""<b>"" , h_env ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_H : HTMLlineproc1 ( ""</b>"" , h_env ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; close_anchor ( h_env , obuf ) ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_UL : case HTML_OL : case HTML_BLQ : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( cmd == HTML_UL || cmd == HTML_OL ) { if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { envs [ h_env -> envc ] . count = count - 1 ; } } if ( cmd == HTML_OL ) { envs [ h_env -> envc ] . type = '1' ; if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { envs [ h_env -> envc ] . type = ( int ) * p ; } } if ( cmd == HTML_UL ) envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_N_UL : case HTML_N_OL : case HTML_N_DL : case HTML_N_BLQ : CLOSE_DT ; CLOSE_A ; if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; POP_ENV ; if ( ! ( obuf -> flag & RB_PREMODE ) && ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , INDENT_INCR , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } } close_anchor ( h_env , obuf ) ; return 1 ; case HTML_DL : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_PREMODE ) ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } PUSH_ENV ( cmd ) ; if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_LI : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc > 0 ) { Str num ; flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; envs [ h_env -> envc ] . count ++ ; if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { count = atoi ( p ) ; if ( count > 0 ) envs [ h_env -> envc ] . count = count ; else envs [ h_env -> envc ] . count = 0 ; } switch ( envs [ h_env -> envc ] . env ) { case HTML_UL : envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; tmp = Strnew ( ) ; switch ( envs [ h_env -> envc ] . type ) { case 'd' : push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; break ; case 'c' : push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; break ; case 's' : push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; break ; default : push_symbol ( tmp , UL_SYMBOL ( ( h_env -> envc_real - 1 ) % MAX_UL_LEVEL ) , symbol_width , 1 ) ; break ; } if ( symbol_width == 1 ) push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; set_space_to_prevchar ( obuf -> prevchar ) ; break ; case HTML_OL : if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) envs [ h_env -> envc ] . type = ( int ) * p ; switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { case 'i' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; break ; case 'I' : num = romanNumeral ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; case 'a' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; break ; case 'A' : num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; Strupper ( num ) ; break ; default : num = Sprintf ( ""%d"" , envs [ h_env -> envc ] . count ) ; break ; } if ( INDENT_INCR >= 4 ) Strcat_charp ( num , ""."" ) ; else Strcat_char ( num , '.' ) ; push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; push_str ( obuf , num -> length , num , PC_ASCII ) ; if ( INDENT_INCR >= 4 ) set_space_to_prevchar ( obuf -> prevchar ) ; break ; default : push_spaces ( obuf , 1 , INDENT_INCR ) ; break ; } } else { flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DT : CLOSE_A ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( h_env -> envc > 0 ) { flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; } if ( ! ( obuf -> flag & RB_IN_DT ) ) { HTMLlineproc1 ( ""<b>"" , h_env ) ; obuf -> flag |= RB_IN_DT ; } obuf -> flag |= RB_IGNORE_P ; return 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ;  if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) {  if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; else push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; } else flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 1 ; case HTML_TITLE : close_anchor ( h_env , obuf ) ; process_title ( tag ) ; obuf -> flag |= RB_TITLE ; obuf -> end_tag = HTML_N_TITLE ; return 1 ; case HTML_N_TITLE : if ( ! ( obuf -> flag & RB_TITLE ) ) return 1 ; obuf -> flag &= ~ RB_TITLE ; obuf -> end_tag = 0 ; tmp = process_n_title ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_TITLE_ALT : if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) h_env -> title = html_unquote ( p ) ; return 0 ; case HTML_FRAMESET : PUSH_ENV ( cmd ) ; push_charp ( obuf , 9 , ""--FRAME--"" , PC_ASCII ) ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_N_FRAMESET : if ( h_env -> envc > 0 ) { POP_ENV ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } return 0 ; case HTML_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; return 1 ; case HTML_N_NOFRAMES : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag &= ~ RB_NOFRAMES ; return 1 ; case HTML_FRAME : q = r = NULL ; parsedtag_get_value ( tag , ATTR_SRC , & q ) ; parsedtag_get_value ( tag , ATTR_NAME , & r ) ; if ( q ) { q = html_quote ( q ) ; push_tag ( obuf , Sprintf ( ""<ahseq=\\""%d\\""href=\\""%s\\"">"" , cur_hseq ++ , q ) -> ptr , HTML_A ) ; if ( r ) q = html_quote ( r ) ; push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; push_tag ( obuf , ""</a>"" , HTML_N_A ) ; } flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; return 0 ; case HTML_HR : close_anchor ( h_env , obuf ) ; tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; set_space_to_prevchar ( obuf -> prevchar ) ; return 1 ; case HTML_PRE : x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! x ) do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } else fillline ( obuf , envs [ h_env -> envc ] . indent ) ; obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE : flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; h_env -> blank_lines ++ ; } obuf -> flag &= ~ RB_PRE ; close_anchor ( h_env , obuf ) ; return 1 ; case HTML_PRE_INT : i = obuf -> line -> length ; append_tags ( obuf ) ; if ( ! ( obuf -> flag & RB_SPECIAL ) ) { set_breakpoint ( obuf , obuf -> line -> length - i ) ; } obuf -> flag |= RB_PRE_INT ; return 0 ; case HTML_N_PRE_INT : push_tag ( obuf , ""</pre_int>"" , HTML_N_PRE_INT ) ; obuf -> flag &= ~ RB_PRE_INT ; if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { set_prevchar ( obuf -> prevchar , """" , 0 ) ; obuf -> prev_ctype = PC_CTRL ; } return 1 ; case HTML_NOBR : obuf -> flag |= RB_NOBR ; obuf -> nobr_level ++ ; return 0 ; case HTML_N_NOBR : if ( obuf -> nobr_level > 0 ) obuf -> nobr_level -- ; if ( obuf -> nobr_level == 0 ) obuf -> flag &= ~ RB_NOBR ; return 0 ; case HTML_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; return 1 ; case HTML_N_PRE_PLAIN : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PRE ; return 1 ; case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; } obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; switch ( cmd ) { case HTML_LISTING : obuf -> end_tag = HTML_N_LISTING ; break ; case HTML_XMP : obuf -> end_tag = HTML_N_XMP ; break ; case HTML_PLAINTEXT : obuf -> end_tag = MAX_HTMLTAG ; break ; } return 1 ; case HTML_N_LISTING : case HTML_N_XMP : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; } obuf -> flag &= ~ RB_PLAIN ; obuf -> end_tag = 0 ; return 1 ; case HTML_SCRIPT : obuf -> flag |= RB_SCRIPT ; obuf -> end_tag = HTML_N_SCRIPT ; return 1 ; case HTML_STYLE : obuf -> flag |= RB_STYLE ; obuf -> end_tag = HTML_N_STYLE ; return 1 ; case HTML_N_SCRIPT : obuf -> flag &= ~ RB_SCRIPT ; obuf -> end_tag = 0 ; return 1 ; case HTML_N_STYLE : obuf -> flag &= ~ RB_STYLE ; obuf -> end_tag = 0 ; return 1 ; case HTML_A : if ( obuf -> anchor . url ) close_anchor ( h_env , obuf ) ; hseq = 0 ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) obuf -> anchor . accesskey = ( unsigned char ) * p ; if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) obuf -> anchor . hseq = hseq ; if ( hseq == 0 && obuf -> anchor . url ) { obuf -> anchor . hseq = cur_hseq ; tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; push_tag ( obuf , tmp -> ptr , HTML_A ) ; if ( displayLinkNumber ) HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; return 1 ; } return 0 ; case HTML_N_A : close_anchor ( h_env , obuf ) ; return 1 ; case HTML_IMG : tmp = process_img ( tag , h_env -> limit ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_IMG_ALT : if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) obuf -> img_alt = Strnew_charp ( p ) ; # ifdef USE_IMAGE i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } # endif return 0 ; case HTML_N_IMG_ALT : if ( obuf -> img_alt ) { if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) push_tag ( obuf , ""</img_alt>"" , HTML_N_IMG_ALT ) ; obuf -> img_alt = NULL ; } return 1 ; case HTML_INPUT_ALT : i = 0 ; if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { if ( i > obuf -> top_margin ) obuf -> top_margin = i ; } i = 0 ; if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { if ( i > obuf -> bottom_margin ) obuf -> bottom_margin = i ; } if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { obuf -> input_alt . hseq = hseq ; } if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { obuf -> input_alt . fid = i ; } if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { obuf -> input_alt . type = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { obuf -> input_alt . value = Strnew_charp ( p ) ; } if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { obuf -> input_alt . name = Strnew_charp ( p ) ; } obuf -> input_alt . in = 1 ; return 0 ; case HTML_N_INPUT_ALT : if ( obuf -> input_alt . in ) { if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) push_tag ( obuf , ""</input_alt>"" , HTML_N_INPUT_ALT ) ; obuf -> input_alt . hseq = 0 ; obuf -> input_alt . fid = - 1 ; obuf -> input_alt . in = 0 ; obuf -> input_alt . type = NULL ; obuf -> input_alt . name = NULL ; obuf -> input_alt . value = NULL ; } return 1 ; case HTML_TABLE : close_anchor ( h_env , obuf ) ; obuf -> table_level ++ ; if ( obuf -> table_level >= MAX_TABLE ) break ; w = BORDER_NONE ; x = 2 ; y = 1 ; z = 0 ; width = 0 ; if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { if ( w > 2 ) w = BORDER_THICK ; else if ( w < 0 ) { w = BORDER_THIN ; } } else w = BORDER_THIN ; } if ( DisplayBorders && w == BORDER_NONE ) w = BORDER_THIN ; if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { if ( obuf -> table_level == 0 ) width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; else width = RELATIVE_WIDTH ( i ) ; } if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) w = BORDER_NOWIN ; # define MAX_CELLSPACING 1000 # define MAX_CELLPADDING 1000 # define MAX_VSPACE 1000 parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; if ( x > MAX_CELLSPACING ) x = MAX_CELLSPACING ; if ( y > MAX_CELLPADDING ) y = MAX_CELLPADDING ; if ( z > MAX_VSPACE ) z = MAX_VSPACE ; # ifdef ID_EXT parsedtag_get_value ( tag , ATTR_ID , & id ) ; # endif tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; # ifdef ID_EXT if ( id != NULL ) tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; # endif table_mode [ obuf -> table_level ] . pre_mode = 0 ; table_mode [ obuf -> table_level ] . indent_level = 0 ; table_mode [ obuf -> table_level ] . nobr_level = 0 ; table_mode [ obuf -> table_level ] . caption = 0 ; table_mode [ obuf -> table_level ] . end_tag = 0 ; # ifndef TABLE_EXPAND tables [ obuf -> table_level ] -> total_width = width ; # else tables [ obuf -> table_level ] -> real_width = width ; tables [ obuf -> table_level ] -> total_width = 0 ; # endif return 1 ; case HTML_N_TABLE : return 1 ; case HTML_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_SAVE_FLAG ( obuf ) ; RB_SET_ALIGN ( obuf , RB_CENTER ) ; return 1 ; case HTML_N_CENTER : CLOSE_A ; if ( ! ( obuf -> flag & RB_PREMODE ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_DIV_INT : CLOSE_P ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; set_alignment ( obuf , tag ) ; return 1 ; case HTML_N_DIV_INT : CLOSE_P ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; RB_RESTORE_FLAG ( obuf ) ; return 1 ; case HTML_FORM : CLOSE_A ; if ( ! ( obuf -> flag & RB_IGNORE_P ) ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; tmp = process_form ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_FORM : CLOSE_A ; flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; obuf -> flag |= RB_IGNORE_P ; process_n_form ( ) ; return 1 ; case HTML_INPUT : close_anchor ( h_env , obuf ) ; tmp = process_input ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_BUTTON : tmp = process_button ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_N_BUTTON : tmp = process_n_button ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_SELECT : close_anchor ( h_env , obuf ) ; tmp = process_select ( tag ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INSELECT ; obuf -> end_tag = HTML_N_SELECT ; return 1 ; case HTML_N_SELECT : obuf -> flag &= ~ RB_INSELECT ; obuf -> end_tag = 0 ; tmp = process_n_select ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_OPTION : return 1 ; case HTML_TEXTAREA : close_anchor ( h_env , obuf ) ; tmp = process_textarea ( tag , h_env -> limit ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; obuf -> flag |= RB_INTXTA ; obuf -> end_tag = HTML_N_TEXTAREA ; return 1 ; case HTML_N_TEXTAREA : obuf -> flag &= ~ RB_INTXTA ; obuf -> end_tag = 0 ; tmp = process_n_textarea ( ) ; if ( tmp ) HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_ISINDEX : p = """" ; q = ""!CURRENT_URL!"" ; parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; tmp = Strnew_m_charp ( ""<formmethod=getaction=\\"""" , html_quote ( q ) , ""\\"">"" , html_quote ( p ) , ""<inputtype=textname=\\""\\""accept></form>"" , NULL ) ; HTMLlineproc1 ( tmp -> ptr , h_env ) ; return 1 ; case HTML_META : p = q = r = NULL ; parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; # ifdef USE_M17N parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; if ( r ) { SKIP_BLANKS ( r ) ; meta_charset = wc_guess_charset ( r , 0 ) ; } else if ( p && q && ! strcasecmp ( p , ""Content-Type"" ) && ( q = strcasestr ( q , ""charset"" ) ) != NULL ) { q += 7 ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { q ++ ; SKIP_BLANKS ( q ) ; meta_charset = wc_guess_charset ( q , 0 ) ; } } else # endif if ( p && q && ! strcasecmp ( p , ""refresh"" ) ) { int refresh_interval ; tmp = NULL ; refresh_interval = getMetaRefreshParam ( q , & tmp ) ; if ( tmp ) { q = html_quote ( tmp -> ptr ) ; tmp = Sprintf ( ""Refresh(%dsec)<ahref=\\""%s\\"">%s</a>"" , refresh_interval , q , q ) ; } else if ( refresh_interval > 0 ) tmp = Sprintf ( ""Refresh(%dsec)"" , refresh_interval ) ; if ( tmp ) { HTMLlineproc1 ( tmp -> ptr , h_env ) ; do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; if ( ! is_redisplay && ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { tag -> need_reconstruct = TRUE ; return 0 ; } } } return 1 ; case HTML_BASE : # if defined ( USE_M17N ) || defined ( USE_IMAGE ) p = NULL ; if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { cur_baseURL = New ( ParsedURL ) ; parseURL ( p , cur_baseURL , NULL ) ; } # endif case HTML_MAP : case HTML_N_MAP : case HTML_AREA : return 0 ; case HTML_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[DEL:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , ""<s>"" , HTML_S ) ; } break ; } return 1 ; case HTML_N_DEL : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_DEL ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:DEL]</U>"" , h_env ) ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , ""</s>"" , HTML_N_S ) ; } } break ; } return 1 ; case HTML_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag |= RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[S:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_strike ++ ; if ( obuf -> in_strike == 1 ) { push_tag ( obuf , ""<s>"" , HTML_S ) ; } break ; } return 1 ; case HTML_N_S : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : obuf -> flag &= ~ RB_S ; break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:S]</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_strike == 0 ) return 1 ; if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) obuf -> in_strike = 0 ; if ( obuf -> in_strike > 0 ) { obuf -> in_strike -- ; if ( obuf -> in_strike == 0 ) { push_tag ( obuf , ""</s>"" , HTML_N_S ) ; } } } return 1 ; case HTML_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>[INS:</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : obuf -> in_ins ++ ; if ( obuf -> in_ins == 1 ) { push_tag ( obuf , ""<ins>"" , HTML_INS ) ; } break ; } return 1 ; case HTML_N_INS : switch ( displayInsDel ) { case DISPLAY_INS_DEL_SIMPLE : break ; case DISPLAY_INS_DEL_NORMAL : HTMLlineproc1 ( ""<U>:INS]</U>"" , h_env ) ; break ; case DISPLAY_INS_DEL_FONTIFY : if ( obuf -> in_ins == 0 ) return 1 ; if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) obuf -> in_ins = 0 ; if ( obuf -> in_ins > 0 ) { obuf -> in_ins -- ; if ( obuf -> in_ins == 0 ) { push_tag ( obuf , ""</ins>"" , HTML_N_INS ) ; } } break ; } return 1 ; case HTML_SUP : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""^"" , h_env ) ; return 1 ; case HTML_N_SUP : return 1 ; case HTML_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""["" , h_env ) ; return 1 ; case HTML_N_SUB : if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) HTMLlineproc1 ( ""]"" , h_env ) ; return 1 ; case HTML_FONT : case HTML_N_FONT : case HTML_NOP : return 1 ; case HTML_BGSOUND : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<AHREF=\\""%s\\"">bgsound(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_EMBED : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<AHREF=\\""%s\\"">embed(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_APPLET : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<AHREF=\\""%s\\"">appletarchive(%s)</A>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } return 1 ; case HTML_BODY : if ( view_unseenobject ) { if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { Str s ; q = html_quote ( p ) ; s = Sprintf ( ""<IMGSRC=\\""%s\\""ALT=\\""bgimage(%s)\\""><BR>"" , q , q ) ; HTMLlineproc1 ( s -> ptr , h_env ) ; } } case HTML_N_HEAD : if ( obuf -> flag & RB_TITLE ) HTMLlineproc1 ( ""</title>"" , h_env ) ; case HTML_HEAD : case HTML_N_BODY : return 1 ; default : return 0 ; } return 0 ; }", ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
640,"CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , ""Missingdescriptordata\\n"" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , ""Zerolengthdescriptor\\n"" ) ; return NULL ; }  while ( buflen > 0 ) {  union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , ""Foundunionheader\\n"" ) ;  return union_desc ;  } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , ""MissingCDCuniondescriptor\\n"" ) ; return NULL ; }"," while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Toolargedescriptor\\n"" ) ; return NULL ; }  if ( union_desc  ""Foundunionheader\\n"" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Uniondescriptortoshort(%dvs%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL  ; } buflen"
641,CWE-476 static int sd_isoc_init ( struct gspca_dev * gspca_dev )  {  struct usb_host_interface * alt ; int max_packet_size ; switch ( gspca_dev -> pixfmt . width ) { case 160 : max_packet_size = 450 ; break ; case 176 : max_packet_size = 600 ; break ; default : max_packet_size = 1022 ; break ; }  alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ;  alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( max_packet_size ) ; return 0 ; }, gspca_dev ) { struct usb_interface_cache * intfc ;  break ; } intfc =  gspca_dev -> dev  [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc  [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV
642,"CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ;  head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;  track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }", * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
643,"CWE-20 static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ;  if ( copy_from_user ( & sas , optval , len ) )  return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min ;  len = min_t ( size_t , len , sizeof ( sas ) ) ;  if ( put_user ( len , optlen ) ) return - EFAULT ; SCTP_DEBUG_PRINTK ( ""sctp_getsockopt_assoc_stat(%d):%d\\n"" , len , sas . sas_assoc_id ) ; if ( copy_to_user ( optval , & sas , len ) ) return - EFAULT ; return 0 ; }"," - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ;  -> rto_min ;  if ( put_user"
644,"CWE-119 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; int ret = - ENOMEM , i ; if ( npages == 0 ) npages = 1 ; if ( npages > ARRAY_SIZE ( pages ) ) return - ERANGE ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; dprintk ( ""%sbuf%pbuflen%zunpages%dargs.acl_len%zu\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; if ( res . acl_flags & NFS4_ACL_TRUNC ) { if ( buf == NULL ) goto out_ok ; ret = - ERANGE ; goto out_free ; } nfs4_write_cached_acl ( inode , pages , res . acl_data_offset , res . acl_len ) ;  if ( buf )   _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;  out_ok : ret = res . acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }", ( buf ) { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; }  acl_len ) ; }
645,"CWE-269 static void copy_xauthority ( void ) { char * src = RUN_XAUTHORITY_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:%sisasymboliclink\\n"" , dest ) ; exit ( 1 ) ; }  pid_t child = fork ( ) ;  if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ;  if ( rv )  fprintf ( stderr , ""Warning:cannottransfer.Xauthorityinprivatehomedirectory\\n"" ) ; else {  fs_logger2 ( ""clone"" , dest ) ;  } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }"," ) ; } copy_file_as_user  ( src ,  S_IWUSR ) ;  fs_logger2 ( ""clone""  ""clone"" , dest  ) ; unlink"
646,"CWE-362 static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ;  if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) {  ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req , buf ) ; if ( ret ) goto out ; returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; if ( returned_size > size ) { vbg_debug ( ""%s:toomuchoutputdata%zu>%zu\\n"" , __func__ , returned_size , size ) ; returned_size = size ; } if ( copy_to_user ( ( void * ) arg , buf , returned_size ) != 0 ) ret = - EFAULT ; out : if ( is_vmmdev_req ) vbg_req_free ( buf , size ) ; else kfree ( buf ) ; return ret ; }"," - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ;  copy_from_user ( buf + sizeof ( hdr )  * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr )  ) ) {"
647,"CWE-190  static int bson_string_is_db_ref ( const unsigned char * string , const int length ) {  int result = 0 ; if ( length >= 4 ) { if ( string [ 1 ] == 'r' && string [ 2 ] == 'e' && string [ 3 ] == 'f' ) result = 1 ; } else if ( length >= 3 ) { if ( string [ 1 ] == 'i' && string [ 2 ] == 'd' ) result = 1 ; else if ( string [ 1 ] == 'd' && string [ 2 ] == 'b' ) result = 1 ; } return result ; }"," string , const size_t  length ) {"
648,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {  # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; }  char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX%4ld%s-%s(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%dquantum=%d"" ""length=%dgroup=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corruptedimage-tryingexplicitformat\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , """" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }  ( void ) fputc ( c , file ) ;  } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }"," , message ) \\\n{  if ( info  ) ) ; \\\n}  char explicit_vr [  break ; } if (  fputc ( c  , file ) != c ) break"
649,"CWE-119  static int detect_flash ( const struct twopass_rc * twopass , int offset ) {   FIRSTPASS_STATS next_frame ;  int flash_detected = 0 ;  if ( read_frame_stats ( twopass , & next_frame , offset ) != EOF ) {   if ( next_frame . pcnt_second_ref > next_frame . pcnt_inter &&   next_frame . pcnt_second_ref >= 0.5 )  flash_detected = 1 ; } return flash_detected ; }"," detect_flash ( const TWO_PASS  * twopass ,  offset ) { const FIRSTPASS_STATS * const next_frame =  read_frame_stats ( twopass  ( twopass , offset ) ; return next_frame != NULL && next_frame ->  pcnt_second_ref > next_frame  pcnt_second_ref > next_frame ->  pcnt_inter && next_frame  pcnt_inter && next_frame ->  pcnt_second_ref >= 0.5  pcnt_second_ref >= 0.5  ; } "
650,"CWE-269 void inode_init_owner ( struct inode * inode , const struct inode * dir , umode_t mode ) { inode -> i_uid = current_fsuid ( ) ; if ( dir && dir -> i_mode & S_ISGID ) { inode -> i_gid = dir -> i_gid ; if ( S_ISDIR ( mode ) ) mode |= S_ISGID ;  } else  inode -> i_gid = current_fsgid ( ) ; inode -> i_mode = mode ; }"," |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;"
651,"CWE-787 static rfbBool webSocketsHandshake ( rfbClientPtr cl , char * scheme ) { char * buf , * response , * line ; int n , linestart = 0 , len = 0 , llen , base64 = TRUE ; char prefix [ 5 ] , trailer [ 17 ] ; char * path = NULL , * host = NULL , * origin = NULL , * protocol = NULL ; char * key1 = NULL , * key2 = NULL , * key3 = NULL ; char * sec_ws_origin = NULL ; char * sec_ws_key = NULL ; char sec_ws_version = 0 ; ws_ctx_t * wsctx = NULL ; buf = ( char * ) malloc ( WEBSOCKETS_MAX_HANDSHAKE_LEN ) ; if ( ! buf ) { rfbLogPerror ( ""webSocketsHandshake:malloc"" ) ; return FALSE ; } response = ( char * ) malloc ( WEBSOCKETS_MAX_HANDSHAKE_LEN ) ; if ( ! response ) { free ( buf ) ; rfbLogPerror ( ""webSocketsHandshake:malloc"" ) ; return FALSE ; } while ( len < WEBSOCKETS_MAX_HANDSHAKE_LEN - 1 ) { if ( ( n = rfbReadExactTimeout ( cl , buf + len , 1 , WEBSOCKETS_CLIENT_SEND_WAIT_MS ) ) <= 0 ) { if ( ( n < 0 ) && ( errno == ETIMEDOUT ) ) { break ; } if ( n == 0 ) rfbLog ( ""webSocketsHandshake:clientgone\\n"" ) ; else rfbLogPerror ( ""webSocketsHandshake:read"" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } len += 1 ; llen = len - linestart ; if ( ( ( llen >= 2 ) ) && ( buf [ len - 1 ] == '\\n' ) ) { line = buf + linestart ; if ( ( llen == 2 ) && ( strncmp ( ""\\r\\n"" , line , 2 ) == 0 ) ) { if ( key1 && key2 ) { if ( ( n = rfbReadExact ( cl , buf + len , 8 ) ) <= 0 ) { if ( ( n < 0 ) && ( errno == ETIMEDOUT ) ) { break ; } if ( n == 0 ) rfbLog ( ""webSocketsHandshake:clientgone\\n"" ) ; else rfbLogPerror ( ""webSocketsHandshake:read"" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } rfbLog ( ""Gotkey3\\n"" ) ; key3 = buf + len ; len += 8 ; } else { buf [ len ] = '\\0' ; } break ; } else if ( ( llen >= 16 ) && ( ( strncmp ( ""GET"" , line , min ( llen , 4 ) ) ) == 0 ) ) { path = line + 4 ; buf [ len - 11 ] = '\\0' ; cl -> wspath = strdup ( path ) ; } else if ( ( strncasecmp ( ""host:"" , line , min ( llen , 6 ) ) ) == 0 ) { host = line + 6 ; buf [ len - 2 ] = '\\0' ; } else if ( ( strncasecmp ( ""origin:"" , line , min ( llen , 8 ) ) ) == 0 ) { origin = line + 8 ; buf [ len - 2 ] = '\\0' ; } else if ( ( strncasecmp ( ""sec-websocket-key1:"" , line , min ( llen , 20 ) ) ) == 0 ) { key1 = line + 20 ; buf [ len - 2 ] = '\\0' ; } else if ( ( strncasecmp ( ""sec-websocket-key2:"" , line , min ( llen , 20 ) ) ) == 0 ) { key2 = line + 20 ; buf [ len - 2 ] = '\\0' ; } else if ( ( strncasecmp ( ""sec-websocket-protocol:"" , line , min ( llen , 24 ) ) ) == 0 ) { protocol = line + 24 ; buf [ len - 2 ] = '\\0' ; rfbLog ( ""Gotprotocol:%s\\n"" , protocol ) ; } else if ( ( strncasecmp ( ""sec-websocket-origin:"" , line , min ( llen , 22 ) ) ) == 0 ) { sec_ws_origin = line + 22 ; buf [ len - 2 ] = '\\0' ; } else if ( ( strncasecmp ( ""sec-websocket-key:"" , line , min ( llen , 19 ) ) ) == 0 ) { sec_ws_key = line + 19 ; buf [ len - 2 ] = '\\0' ; } else if ( ( strncasecmp ( ""sec-websocket-version:"" , line , min ( llen , 23 ) ) ) == 0 ) { sec_ws_version = strtol ( line + 23 , NULL , 10 ) ; buf [ len - 2 ] = '\\0' ; } linestart = len ; } } if ( ! ( path && host && ( origin || sec_ws_origin ) ) ) { rfbErr ( ""webSocketsHandshake:incompleteclienthandshake\\n"" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } if ( ( protocol ) && ( strstr ( protocol , ""binary"" ) ) ) { if ( ! sec_ws_version ) { rfbErr ( ""webSocketsHandshake:\'binary\'protocolnotsupportedwithHixie\\n"" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } rfbLog ( ""-webSocketsHandshake:usingbinary/rawencoding\\n"" ) ; base64 = FALSE ; protocol = ""binary"" ; } else { rfbLog ( ""-webSocketsHandshake:usingbase64encoding\\n"" ) ; base64 = TRUE ; if ( ( protocol ) && ( strstr ( protocol , ""base64"" ) ) ) { protocol = ""base64"" ; } else { protocol = """" ; } } if ( sec_ws_version ) { char accept [ B64LEN ( SHA1_HASH_SIZE ) + 1 ] ; rfbLog ( ""-WebSocketsclientversionhybi-%02d\\n"" , sec_ws_version ) ; webSocketsGenSha1Key ( accept , sizeof ( accept ) , sec_ws_key ) ; if ( strlen ( protocol ) > 0 ) len = snprintf ( response , WEBSOCKETS_MAX_HANDSHAKE_LEN , SERVER_HANDSHAKE_HYBI , accept , protocol ) ; else len = snprintf ( response , WEBSOCKETS_MAX_HANDSHAKE_LEN , SERVER_HANDSHAKE_HYBI_NO_PROTOCOL , accept ) ; } else { if ( ! ( key1 && key2 && key3 ) ) { rfbLog ( ""-WebSocketsclientversionhixie-75\\n"" ) ; prefix [ 0 ] = '\\0' ; trailer [ 0 ] = '\\0' ; } else { rfbLog ( ""-WebSocketsclientversionhixie-76\\n"" ) ; snprintf ( prefix , 5 , ""Sec-"" ) ; webSocketsGenMd5 ( trailer , key1 , key2 , key3 ) ; } len = snprintf ( response , WEBSOCKETS_MAX_HANDSHAKE_LEN , SERVER_HANDSHAKE_HIXIE , prefix , origin , prefix , scheme , host , path , prefix , protocol , trailer ) ; } if ( rfbWriteExact ( cl , response , len ) < 0 ) { rfbErr ( ""webSocketsHandshake:failedsendingWebSocketsresponse\\n"" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } free ( response ) ; free ( buf ) ; wsctx = calloc ( 1 , sizeof ( ws_ctx_t ) ) ; if ( sec_ws_version ) { wsctx -> version = WEBSOCKETS_VERSION_HYBI ; wsctx -> encode = webSocketsEncodeHybi ; wsctx -> decode = webSocketsDecodeHybi ; } else { wsctx -> version = WEBSOCKETS_VERSION_HIXIE ; wsctx -> encode = webSocketsEncodeHixie ; wsctx -> decode = webSocketsDecodeHixie ; } wsctx -> base64 = base64 ;  cl -> wsctx = ( wsCtx * ) wsctx ;  return TRUE ; }", = base64 ; hybiDecodeCleanup ( wsctx ) ;
652,"CWE-000 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { int vm_shared = dst_vma -> vm_flags & VM_SHARED ; struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; if ( vm_shared ) { struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; spin_lock ( ptl ) ; ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ;  out_release_nounlock :  if ( vm_shared ) unlock_page ( page ) ; put_page ( page ) ; goto out ; }", ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock :  put_page ( page
653,"CWE-415 static int csnmp_read_table ( host_definition_t * host , data_definition_t * data ) { struct snmp_pdu * req ; struct snmp_pdu * res = NULL ; struct variable_list * vb ; const data_set_t * ds ; size_t oid_list_len = data -> values_len + 1 ; oid_t oid_list [ oid_list_len ] ; _Bool oid_list_todo [ oid_list_len ] ; int status ; size_t i ; csnmp_list_instances_t * instance_list_head ; csnmp_list_instances_t * instance_list_tail ; csnmp_table_values_t * * value_list_head ; csnmp_table_values_t * * value_list_tail ; DEBUG ( ""snmpplugin:csnmp_read_table(host=%s,data=%s)"" , host -> name , data -> name ) ; if ( host -> sess_handle == NULL ) { DEBUG ( ""snmpplugin:csnmp_read_table:host->sess_handle==NULL"" ) ; return ( - 1 ) ; } ds = plugin_get_ds ( data -> type ) ; if ( ! ds ) { ERROR ( ""snmpplugin:DataSet`%s\'notdefined."" , data -> type ) ; return ( - 1 ) ; } if ( ds -> ds_num != data -> values_len ) { ERROR ( ""snmpplugin:DataSet`%s\'requires%zuvalues,butconfigtalks"" ""about%zu"" , data -> type , ds -> ds_num , data -> values_len ) ; return ( - 1 ) ; } assert ( data -> values_len > 0 ) ; memcpy ( oid_list , data -> values , data -> values_len * sizeof ( oid_t ) ) ; if ( data -> instance . oid . oid_len > 0 ) memcpy ( oid_list + data -> values_len , & data -> instance . oid , sizeof ( oid_t ) ) ; else oid_list_len -- ; for ( i = 0 ; i < oid_list_len ; i ++ ) oid_list_todo [ i ] = 1 ; value_list_head = calloc ( data -> values_len , sizeof ( * value_list_head ) ) ; value_list_tail = calloc ( data -> values_len , sizeof ( * value_list_tail ) ) ; if ( ( value_list_head == NULL ) || ( value_list_tail == NULL ) ) { ERROR ( ""snmpplugin:csnmp_read_table:callocfailed."" ) ; sfree ( value_list_head ) ; sfree ( value_list_tail ) ; return ( - 1 ) ; } instance_list_head = NULL ; instance_list_tail = NULL ; status = 0 ; while ( status == 0 ) { int oid_list_todo_num ; req = snmp_pdu_create ( SNMP_MSG_GETNEXT ) ; if ( req == NULL ) { ERROR ( ""snmpplugin:snmp_pdu_createfailed."" ) ; status = - 1 ; break ; } oid_list_todo_num = 0 ; for ( i = 0 ; i < oid_list_len ; i ++ ) { if ( ! oid_list_todo [ i ] ) continue ; oid_list_todo_num ++ ; snmp_add_null_var ( req , oid_list [ i ] . oid , oid_list [ i ] . oid_len ) ; } if ( oid_list_todo_num == 0 ) {  DEBUG ( ""snmpplugin:allvariableshavelefttheirsubtree"" ) ;  status = 0 ; break ; } res = NULL ; status = snmp_sess_synch_response ( host -> sess_handle , req , & res ) ; if ( ( status != STAT_SUCCESS ) || ( res == NULL ) ) { char * errstr = NULL ; snmp_sess_error ( host -> sess_handle , NULL , NULL , & errstr ) ; c_complain ( LOG_ERR , & host -> complaint , ""snmpplugin:host%s:snmp_sess_synch_responsefailed:%s"" , host -> name , ( errstr == NULL ) ? ""Unknownproblem"" : errstr ) ; if ( res != NULL ) snmp_free_pdu ( res ) ; res = NULL ;  req = NULL ;  sfree ( errstr ) ; csnmp_host_close_session ( host ) ; status = - 1 ; break ; } status = 0 ; assert ( res != NULL ) ; c_release ( LOG_INFO , & host -> complaint , ""snmpplugin:host%s:snmp_sess_synch_responsesuccessful."" , host -> name ) ; vb = res -> variables ; if ( vb == NULL ) { status = - 1 ; break ; } for ( vb = res -> variables , i = 0 ; ( vb != NULL ) ; vb = vb -> next_variable , i ++ ) { while ( ( i < oid_list_len ) && ! oid_list_todo [ i ] ) i ++ ; if ( ( data -> instance . oid . oid_len > 0 ) && ( i == data -> values_len ) ) { if ( ( vb -> type == SNMP_ENDOFMIBVIEW ) || ( snmp_oid_ncompare ( data -> instance . oid . oid , data -> instance . oid . oid_len , vb -> name , vb -> name_length , data -> instance . oid . oid_len ) != 0 ) ) { DEBUG ( ""snmpplugin:host=%s;data=%s;Instanceleftitssubtree."" , host -> name , data -> name ) ; oid_list_todo [ i ] = 0 ; continue ; } if ( csnmp_instance_list_add ( & instance_list_head , & instance_list_tail , res , host , data ) != 0 ) { ERROR ( ""snmpplugin:host%s:csnmp_instance_list_addfailed."" , host -> name ) ; status = - 1 ; break ; } } else { csnmp_table_values_t * vt ; oid_t vb_name ; oid_t suffix ; int ret ; csnmp_oid_init ( & vb_name , vb -> name , vb -> name_length ) ; ret = csnmp_oid_suffix ( & suffix , & vb_name , data -> values + i ) ; if ( ret != 0 ) { DEBUG ( ""snmpplugin:host=%s;data=%s;i=%zu;"" ""Valueprobablyleftitssubtree."" , host -> name , data -> name , i ) ; oid_list_todo [ i ] = 0 ; continue ; } if ( ( value_list_tail [ i ] != NULL ) && ( csnmp_oid_compare ( & suffix , & value_list_tail [ i ] -> suffix ) <= 0 ) ) { DEBUG ( ""snmpplugin:host=%s;data=%s;i=%zu;"" ""Suffixisnotincreasing."" , host -> name , data -> name , i ) ; oid_list_todo [ i ] = 0 ; continue ; } vt = calloc ( 1 , sizeof ( * vt ) ) ; if ( vt == NULL ) { ERROR ( ""snmpplugin:callocfailed."" ) ; status = - 1 ; break ; } vt -> value = csnmp_value_list_to_value ( vb , ds -> ds [ i ] . type , data -> scale , data -> shift , host -> name , data -> name ) ; memcpy ( & vt -> suffix , & suffix , sizeof ( vt -> suffix ) ) ; vt -> next = NULL ; if ( value_list_tail [ i ] == NULL ) value_list_head [ i ] = vt ; else value_list_tail [ i ] -> next = vt ; value_list_tail [ i ] = vt ; } memcpy ( oid_list [ i ] . oid , vb -> name , sizeof ( oid ) * vb -> name_length ) ; oid_list [ i ] . oid_len = vb -> name_length ; } if ( res != NULL ) snmp_free_pdu ( res ) ; res = NULL ; } if ( res != NULL ) snmp_free_pdu ( res ) ; res = NULL ;  if ( req != NULL )  snmp_free_pdu ( req ) ; req = NULL ; if ( status == 0 ) csnmp_dispatch_table ( host , data , instance_list_head , value_list_head ) ; while ( instance_list_head != NULL ) { csnmp_list_instances_t * next = instance_list_head -> next ; sfree ( instance_list_head ) ; instance_list_head = next ; } for ( i = 0 ; i < data -> values_len ; i ++ ) { while ( value_list_head [ i ] != NULL ) { csnmp_table_values_t * next = value_list_head [ i ] -> next ; sfree ( value_list_head [ i ] ) ; value_list_head [ i ] = next ; } } sfree ( value_list_head ) ; sfree ( value_list_tail ) ; return ( 0 ) ; }"," DEBUG ( ""snmpplugin:allvariableshavelefttheirsubtree"" ) ; snmp_free_pdu ( req  = NULL ;  sfree ( errstr  ; if (  status == 0"
654,"CWE-190 int jas_stream_pad ( jas_stream_t * stream , int n , int c ) {  int m ;  m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }"," int m ; if ( n < 0 ) { jas_deprecated ( ""negativecountforjas_stream_pad"" ) ; }"
655,"CWE-295 int context_init ( SERVICE_OPTIONS * section ) { # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> option . client ) section -> ctx = SSL_CTX_new ( TLS_client_method ( ) ) ; else section -> ctx = SSL_CTX_new ( TLS_server_method ( ) ) ; if ( ! SSL_CTX_set_min_proto_version ( section -> ctx , section -> min_proto_version ) ) { s_log ( LOG_ERR , ""Failedtosettheminimumprotocolversion0x%X"" , section -> min_proto_version ) ; return 1 ; } if ( ! SSL_CTX_set_max_proto_version ( section -> ctx , section -> max_proto_version ) ) { s_log ( LOG_ERR , ""Failedtosetthemaximumprotocolversion0x%X"" , section -> max_proto_version ) ; return 1 ; } # else if ( section -> option . client ) section -> ctx = SSL_CTX_new ( section -> client_method ) ; else section -> ctx = SSL_CTX_new ( section -> server_method ) ; # endif if ( ! section -> ctx ) { sslerror ( ""SSL_CTX_new"" ) ; return 1 ; } if ( ! SSL_CTX_set_ex_data ( section -> ctx , index_ssl_ctx_opt , section ) ) { sslerror ( ""SSL_CTX_set_ex_data"" ) ; return 1 ; } current_section = section ;  if ( section -> cipher_list ) {  s_log ( LOG_DEBUG , ""Ciphers:%s"" , section -> cipher_list ) ; if ( ! SSL_CTX_set_cipher_list ( section -> ctx , section -> cipher_list ) ) { sslerror ( ""SSL_CTX_set_cipher_list"" ) ; return 1 ; } } # ifndef OPENSSL_NO_TLS1_3 if ( section -> ciphersuites ) { s_log ( LOG_DEBUG , ""TLSv1.3ciphersuites:%s"" , section -> ciphersuites ) ; if ( ! SSL_CTX_set_ciphersuites ( section -> ctx , section -> ciphersuites ) ) { sslerror ( ""SSL_CTX_set_ciphersuites"" ) ; return 1 ; } } # endif SSL_CTX_set_options ( section -> ctx , SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 ) ; # ifdef SSL_OP_NO_COMPRESSION SSL_CTX_clear_options ( section -> ctx , SSL_OP_NO_COMPRESSION ) ; # endif SSL_CTX_set_options ( section -> ctx , ( SSL_OPTIONS_TYPE ) ( section -> ssl_options_set ) ) ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL SSL_CTX_clear_options ( section -> ctx , ( SSL_OPTIONS_TYPE ) ( section -> ssl_options_clear ) ) ; # endif # if OPENSSL_VERSION_NUMBER >= 0x009080dfL s_log ( LOG_DEBUG , ""TLSoptions:0x%08lX(+0x%08lX,-0x%08lX)"" , SSL_CTX_get_options ( section -> ctx ) , section -> ssl_options_set , section -> ssl_options_clear ) ; # else s_log ( LOG_DEBUG , ""TLSoptions:0x%08lX(+0x%08lX)"" , SSL_CTX_get_options ( section -> ctx ) , section -> ssl_options_set ) ; # endif if ( conf_init ( section ) ) return 1 ; # ifdef SSL_MODE_RELEASE_BUFFERS SSL_CTX_set_mode ( section -> ctx , SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_RELEASE_BUFFERS ) ; # else SSL_CTX_set_mode ( section -> ctx , SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER ) ; # endif # if OPENSSL_VERSION_NUMBER >= 0x10101000L SSL_CTX_set_session_ticket_cb ( section -> ctx , generate_session_ticket_cb , decrypt_session_ticket_cb , NULL ) ; # endif # if OPENSSL_VERSION_NUMBER >= 0x10000000L if ( ( section -> ticket_key ) && ( section -> ticket_mac ) ) SSL_CTX_set_tlsext_ticket_key_cb ( section -> ctx , ssl_tlsext_ticket_key_cb ) ; # endif if ( ! section -> option . client ) { unsigned servname_len = ( unsigned ) strlen ( section -> servname ) ; if ( servname_len > SSL_MAX_SSL_SESSION_ID_LENGTH ) servname_len = SSL_MAX_SSL_SESSION_ID_LENGTH ; if ( ! SSL_CTX_set_session_id_context ( section -> ctx , ( unsigned char * ) section -> servname , servname_len ) ) { sslerror ( ""SSL_CTX_set_session_id_context"" ) ; return 1 ; } } SSL_CTX_set_session_cache_mode ( section -> ctx , SSL_SESS_CACHE_BOTH | SSL_SESS_CACHE_NO_INTERNAL_STORE ) ; SSL_CTX_sess_set_cache_size ( section -> ctx , section -> session_size ) ; SSL_CTX_set_timeout ( section -> ctx , section -> session_timeout ) ; SSL_CTX_sess_set_new_cb ( section -> ctx , sess_new_cb ) ; SSL_CTX_sess_set_get_cb ( section -> ctx , sess_get_cb ) ; SSL_CTX_sess_set_remove_cb ( section -> ctx , sess_remove_cb ) ; SSL_CTX_set_info_callback ( section -> ctx , info_callback ) ; if ( auth_init ( section ) ) return 1 ; if ( verify_init ( section ) ) return 1 ;  if ( ! section -> option . client ) {  # ifndef OPENSSL_NO_TLSEXT SSL_CTX_set_tlsext_servername_callback ( section -> ctx , servername_cb ) ; # endif # ifndef OPENSSL_NO_DH dh_init ( section ) ; # endif # ifndef OPENSSL_NO_ECDH ecdh_init ( section ) ; # endif  }  return 0 ; }"," = section ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , ""User-specifiedsecuritylevelset:%d"" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , ""stunneldefaultsecuritylevelset:%d"" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , ""OpenSSLsecuritylevelisused:%d"" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif  return 1 ; # ifndef OPENSSL_NO_TLSEXT  . client )  SSL_CTX_set_tlsext_servername_callback ( section  ; # endif  return 0 ;"
656,"CWE-125  static void  ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , ""[badlength%u]"" , length ) ) ;  return ;  } if ( ( length + 1 ) & 3 )  ND_PRINT ( ( ndo , ""[badlength%u]"" , length ) ) ;  ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""[badptr%u]"" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) {  ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ;  if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ;  }  }","   static int  ip_printroute ( netdissect_options  ) ; return ( 0 )  , length ) ) ; ND_TCHECK ( cp [ 2 ]  4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ;  ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;"
657,"CWE-119 static void calc_pframe_target_size ( VP8_COMP * cpi ) { int min_frame_target ; int old_per_frame_bandwidth = cpi -> per_frame_bandwidth ; if ( cpi -> current_layer > 0 ) cpi -> per_frame_bandwidth = cpi -> layer_context [ cpi -> current_layer ] . avg_frame_size_for_layer ; min_frame_target = 0 ; if ( cpi -> pass == 2 ) { min_frame_target = cpi -> min_frame_bandwidth ; if ( min_frame_target < ( cpi -> av_per_frame_bandwidth >> 5 ) ) min_frame_target = cpi -> av_per_frame_bandwidth >> 5 ; } else if ( min_frame_target < cpi -> per_frame_bandwidth / 4 ) min_frame_target = cpi -> per_frame_bandwidth / 4 ; if ( ( cpi -> common . refresh_alt_ref_frame ) && ( cpi -> oxcf . number_of_layers == 1 ) ) { if ( cpi -> pass == 2 ) { cpi -> per_frame_bandwidth = cpi -> twopass . gf_bits ; cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } } else { if ( cpi -> pass == 2 ) { cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } else { int Adjustment ; if ( cpi -> kf_overspend_bits > 0 ) { Adjustment = ( cpi -> kf_bitrate_adjustment <= cpi -> kf_overspend_bits ) ? cpi -> kf_bitrate_adjustment : cpi -> kf_overspend_bits ; if ( Adjustment > ( cpi -> per_frame_bandwidth - min_frame_target ) ) Adjustment = ( cpi -> per_frame_bandwidth - min_frame_target ) ; cpi -> kf_overspend_bits -= Adjustment ; cpi -> this_frame_target = cpi -> per_frame_bandwidth - Adjustment ; if ( cpi -> this_frame_target < min_frame_target ) cpi -> this_frame_target = min_frame_target ; } else cpi -> this_frame_target = cpi -> per_frame_bandwidth ; if ( ( cpi -> gf_overspend_bits > 0 ) && ( cpi -> this_frame_target > min_frame_target ) ) { Adjustment = ( cpi -> non_gf_bitrate_adjustment <= cpi -> gf_overspend_bits ) ? cpi -> non_gf_bitrate_adjustment : cpi -> gf_overspend_bits ; if ( Adjustment > ( cpi -> this_frame_target - min_frame_target ) ) Adjustment = ( cpi -> this_frame_target - min_frame_target ) ; cpi -> gf_overspend_bits -= Adjustment ; cpi -> this_frame_target -= Adjustment ; } if ( ( cpi -> last_boost > 150 ) && ( cpi -> frames_till_gf_update_due > 0 ) && ( cpi -> current_gf_interval >= ( MIN_GF_INTERVAL << 1 ) ) ) { Adjustment = ( cpi -> last_boost - 100 ) >> 5 ; if ( Adjustment < 1 ) Adjustment = 1 ; else if ( Adjustment > 10 ) Adjustment = 10 ; Adjustment = ( cpi -> this_frame_target * Adjustment ) / 100 ; if ( Adjustment > ( cpi -> this_frame_target - min_frame_target ) ) Adjustment = ( cpi -> this_frame_target - min_frame_target ) ; if ( cpi -> frames_since_golden == ( cpi -> current_gf_interval >> 1 ) )  cpi -> this_frame_target += ( ( cpi -> current_gf_interval - 1 ) * Adjustment ) ;  else cpi -> this_frame_target -= Adjustment ; } } } if ( cpi -> this_frame_target < min_frame_target ) cpi -> this_frame_target = min_frame_target ; if ( ! cpi -> common . refresh_alt_ref_frame ) cpi -> inter_frame_target = cpi -> this_frame_target ; if ( cpi -> pass == 0 ) { if ( cpi -> buffered_mode ) { int one_percent_bits = ( int ) ( 1 + cpi -> oxcf . optimal_buffer_level / 100 ) ; if ( ( cpi -> buffer_level < cpi -> oxcf . optimal_buffer_level ) || ( cpi -> bits_off_target < cpi -> oxcf . optimal_buffer_level ) ) { int percent_low = 0 ; if ( ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) && ( cpi -> buffer_level < cpi -> oxcf . optimal_buffer_level ) ) { percent_low = ( int ) ( ( cpi -> oxcf . optimal_buffer_level - cpi -> buffer_level ) / one_percent_bits ) ; } else if ( cpi -> bits_off_target < 0 ) { percent_low = ( int ) ( 100 * - cpi -> bits_off_target / ( cpi -> total_byte_count * 8 ) ) ; } if ( percent_low > cpi -> oxcf . under_shoot_pct ) percent_low = cpi -> oxcf . under_shoot_pct ; else if ( percent_low < 0 ) percent_low = 0 ; cpi -> this_frame_target -= ( cpi -> this_frame_target * percent_low ) / 200 ; if ( cpi -> auto_worst_q && cpi -> ni_frames > 150 ) { int64_t critical_buffer_level ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { critical_buffer_level = ( cpi -> buffer_level < cpi -> bits_off_target ) ? cpi -> buffer_level : cpi -> bits_off_target ; } else { critical_buffer_level = cpi -> bits_off_target ; } if ( critical_buffer_level < cpi -> oxcf . optimal_buffer_level ) { if ( critical_buffer_level > ( cpi -> oxcf . optimal_buffer_level >> 2 ) ) { int64_t qadjustment_range = cpi -> worst_quality - cpi -> ni_av_qi ; int64_t above_base = ( critical_buffer_level - ( cpi -> oxcf . optimal_buffer_level >> 2 ) ) ; cpi -> active_worst_quality = cpi -> worst_quality - ( int ) ( ( qadjustment_range * above_base ) / ( cpi -> oxcf . optimal_buffer_level * 3 >> 2 ) ) ; } else { cpi -> active_worst_quality = cpi -> worst_quality ; } } else { cpi -> active_worst_quality = cpi -> ni_av_qi ; } } else { cpi -> active_worst_quality = cpi -> worst_quality ; } } else { int percent_high = 0 ; if ( ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) && ( cpi -> buffer_level > cpi -> oxcf . optimal_buffer_level ) ) { percent_high = ( int ) ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) / one_percent_bits ) ; } else if ( cpi -> bits_off_target > cpi -> oxcf . optimal_buffer_level ) { percent_high = ( int ) ( ( 100 * cpi -> bits_off_target ) / ( cpi -> total_byte_count * 8 ) ) ; } if ( percent_high > cpi -> oxcf . over_shoot_pct ) percent_high = cpi -> oxcf . over_shoot_pct ; else if ( percent_high < 0 ) percent_high = 0 ; cpi -> this_frame_target += ( cpi -> this_frame_target * percent_high ) / 200 ; if ( cpi -> auto_worst_q && cpi -> ni_frames > 150 ) { cpi -> active_worst_quality = cpi -> ni_av_qi ; } else { cpi -> active_worst_quality = cpi -> worst_quality ; } } cpi -> active_best_quality = cpi -> best_quality ; if ( cpi -> active_worst_quality <= cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality + 1 ; if ( cpi -> active_worst_quality > 127 ) cpi -> active_worst_quality = 127 ; } else { cpi -> active_worst_quality = cpi -> worst_quality ; } if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY && cpi -> active_worst_quality < cpi -> cq_target_quality ) { cpi -> active_worst_quality = cpi -> cq_target_quality ; } } if ( cpi -> drop_frames_allowed && ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) && ( ( cpi -> common . frame_type != KEY_FRAME ) ) ) { if ( ( cpi -> buffer_level < 0 ) ) { # if 0 FILE * f = fopen ( ""dec.stt"" , ""a"" ) ; fprintf ( f , ""%10d%10d%10d%10d*****BUFFEREMPTY\\n"" , ( int ) cpi -> common . current_video_frame , cpi -> decimation_factor , cpi -> common . horiz_scale , ( cpi -> buffer_level * 100 ) / cpi -> oxcf . optimal_buffer_level ) ; fclose ( f ) ; # endif cpi -> drop_frame = 1 ; cpi -> bits_off_target += cpi -> av_per_frame_bandwidth ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = ( int ) cpi -> oxcf . maximum_buffer_size ; cpi -> buffer_level = cpi -> bits_off_target ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target += ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; if ( lc -> bits_off_target > lc -> maximum_buffer_size ) lc -> bits_off_target = lc -> maximum_buffer_size ; lc -> buffer_level = lc -> bits_off_target ; } } } } if ( cpi -> oxcf . error_resilient_mode == 0 && ( cpi -> frames_till_gf_update_due == 0 ) && ! cpi -> drop_frame ) { int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int gf_frame_useage = 0 ; int tot_mbs = cpi -> recent_ref_frame_usage [ INTRA_FRAME ] + cpi -> recent_ref_frame_usage [ LAST_FRAME ] + cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] + cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] ; int pct_gf_active = ( 100 * cpi -> gf_active_count ) / ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ; if ( tot_mbs ) gf_frame_useage = ( cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] + cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] ) * 100 / tot_mbs ; if ( pct_gf_active > gf_frame_useage ) gf_frame_useage = pct_gf_active ; if ( cpi -> auto_gold ) { if ( ( cpi -> pass == 0 ) && ( cpi -> this_frame_percent_intra < 15 || gf_frame_useage >= 5 ) ) cpi -> common . refresh_golden_frame = 1 ; else if ( cpi -> pass == 2 ) cpi -> common . refresh_golden_frame = 1 ; } # if 0 if ( 0 ) { FILE * f ; f = fopen ( ""gf_useaget.stt"" , ""a"" ) ; fprintf ( f , ""%8ld%10ld%10ld%10ld%10ld\\n"" , cpi -> common . current_video_frame , cpi -> gfu_boost , GFQ_ADJUSTMENT , cpi -> gfu_boost , gf_frame_useage ) ; fclose ( f ) ; } # endif if ( cpi -> common . refresh_golden_frame == 1 ) { # if 0 if ( 0 ) { FILE * f ; f = fopen ( ""GFexit.stt"" , ""a"" ) ; fprintf ( f , ""%8ldGFcoded\\n"" , cpi -> common . current_video_frame ) ; fclose ( f ) ; } # endif if ( cpi -> auto_adjust_gold_quantizer ) { calc_gf_params ( cpi ) ; } if ( ! cpi -> source_alt_ref_active ) { if ( cpi -> oxcf . fixed_q < 0 ) { if ( cpi -> pass == 2 ) { cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } else { int Boost = cpi -> last_boost ; int frames_in_section = cpi -> frames_till_gf_update_due + 1 ; int allocation_chunks = ( frames_in_section * 100 ) + ( Boost - 100 ) ; int bits_in_section = cpi -> inter_frame_target * frames_in_section ; while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } if ( ( bits_in_section >> 7 ) > allocation_chunks ) cpi -> this_frame_target = Boost * ( bits_in_section / allocation_chunks ) ; else cpi -> this_frame_target = ( Boost * bits_in_section ) / allocation_chunks ; } } else cpi -> this_frame_target = ( estimate_bits_at_q ( 1 , Q , cpi -> common . MBs , 1.0 ) * cpi -> last_boost ) / 100 ; } else { cpi -> this_frame_target = 0 ; } cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; } } cpi -> per_frame_bandwidth = old_per_frame_bandwidth ; }", 1 ) ) { Adjustment =  ( cpi ->  ) * Adjustment ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; }  else cpi ->
658,"CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALIDASOPTIONS"" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = ""CLIENTEXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""CLIENTKEYEXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = ""SERVICEEXPIRED"" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""REQUIREDPWCHANGE"" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = ""POSTDATENOTALLOWED"" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = ""PROXIABLENOTALLOWED"" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""CLIENTLOCKEDOUT"" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""SERVICELOCKEDOUT"" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = ""SERVICENOTALLOWED"" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; }  if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) {  * status = ""ANONYMOUSNOTALLOWED"" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }"," ( kdc_active_realm , client . princ  , request ->"
659,"CWE-20 int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ;  facilities_len -= len + 1 ;  p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ;  facilities_len -= len + 1 ;  p += len + 1 ; break ; default : printk ( KERN_DEBUG ""ROSE:rose_parse_facilities-unknownfacilitiesfamily%02X\\n"" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }", 1 ) ; if ( len < 0 ) return 0 ;  1 ) ; if ( len < 0 ) return 0 ;
660,"CWE-119 static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ;  if ( ! capable ( CAP_NET_ADMIN ) )   return - EPERM ;  if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( ""get_ctl:len%u<%u\\n"" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; }  if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 )  return - EFAULT ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , ""IPVirtualServerversion%d.%d.%d(size=%d)"" , NVERSION ( IP_VS_VERSION_CODE ) , IP_VS_CONN_TAB_SIZE ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = IP_VS_CONN_TAB_SIZE ; info . num_services = ip_vs_num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get = ( struct ip_vs_get_services * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_service_entry ) * get -> num_services ; if ( * len != size ) { pr_err ( ""length:%u!=%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_service_entries ( get , user ) ; } break ; case IP_VS_SO_GET_SERVICE : { struct ip_vs_service_entry * entry ; struct ip_vs_service * svc ; union nf_inet_addr addr ; entry = ( struct ip_vs_service_entry * ) arg ; addr . ip = entry -> addr ; if ( entry -> fwmark ) svc = __ip_vs_svc_fwm_get ( AF_INET , entry -> fwmark ) ; else svc = __ip_vs_service_get ( AF_INET , entry -> protocol , & addr , entry -> port ) ; if ( svc ) { ip_vs_copy_service ( entry , svc ) ; if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) ret = - EFAULT ; ip_vs_service_put ( svc ) ; } else ret = - ESRCH ; } break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_get_dests * get ; int size ; get = ( struct ip_vs_get_dests * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; if ( * len != size ) { pr_err ( ""length:%u!=%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_dest_entries ( get , user ) ; } break ; case IP_VS_SO_GET_TIMEOUT : { struct ip_vs_timeout_user t ; __ip_vs_get_timeouts ( & t ) ; if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_DAEMON : { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( ip_vs_sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ip_vs_master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ip_vs_master_syncid ; } if ( ip_vs_sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ip_vs_backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] . syncid = ip_vs_backup_syncid ; } if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) ret = - EFAULT ; } break ; default : ret = - EINVAL ; } out : mutex_unlock ( & __ip_vs_mutex ) ; return ret ; }"," = 0 ; unsigned int copylen ;  return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL  EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ;  , user , copylen  ) != 0"
661,"CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s>%s:[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , ""%s>%s:[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s>%s.%s:"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s>%s:"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s>%s.%s:"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s>%s:"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,length%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""0x%02x%02x%02x%02x%02x%02x"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPMseq%utrail%ulead%unla%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLLseq%uround%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLRseq%uround%unla%sivl%urnd0x%08x"" ""mask0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATAtrail%useq%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATAtrail%useq%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( EXTRACT_16BITS ( bp ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s->%s),seq%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACKseq%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWNtype0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[Firstoptionbad,shouldbePGM_OPT_LENGTH,is%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_LENGTHoption,length%u!=4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Badtotaloptionlength%u<4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""OPTSLEN%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Totaloptionlengthleavesnoroomforfinaloption]"" ) ) ; return ; }  opt_type = * bp ++ ;  opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Badoption,length%u<%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Totaloptionlengthleavesnoroomforfinaloption]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_LENGTHoption,length%u!=4]"" , opt_len ) ) ; return ; } ND_PRINT ( ( ndo , ""OPTSLEN(extra?)%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += sizeof ( uint16_t ) ; opts_len -= 4 ; break ; case PGM_OPT_FRAGMENT : if ( opt_len != 16 ) { ND_PRINT ( ( ndo , ""[BadOPT_FRAGMENToption,length%u!=16]"" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""FRAGseq%uoff%ulen%u"" , seq , offset , len ) ) ; opts_len -= 16 ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""NAKLIST"" ) ) ; while ( opt_len ) { if ( opt_len < sizeof ( uint32_t ) ) { ND_PRINT ( ( ndo , ""[Optionlengthnotamultipleof4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += sizeof ( uint32_t ) ; opt_len -= sizeof ( uint32_t ) ; opts_len -= sizeof ( uint32_t ) ; } break ; case PGM_OPT_JOIN : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[BadOPT_JOINoption,length%u!=8]"" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""JOIN%u"" , seq ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NAK_BO_IVL : if ( opt_len != 12 ) { ND_PRINT ( ( ndo , ""[BadOPT_NAK_BO_IVLoption,length%u!=12]"" , opt_len ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""BACKOFFivl%uivlseq%u"" , offset , seq ) ) ; opts_len -= 12 ; break ; case PGM_OPT_NAK_BO_RNG : if ( opt_len != 12 ) { ND_PRINT ( ( ndo , ""[BadOPT_NAK_BO_RNGoption,length%u!=12]"" , opt_len ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""BACKOFFmax%umin%u"" , offset , seq ) ) ; opts_len -= 12 ; break ; case PGM_OPT_REDIRECT : bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 4 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u!=4+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 4 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_REDIRECToption,length%u!=4+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 4 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""REDIRECT%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[BadOPT_PARITY_PRMoption,length%u!=8]"" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""PARITYMAXTGS%u"" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_PARITY_GRP : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[BadOPT_PARITY_GRPoption,length%u!=8]"" , opt_len ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""PARITYGROUP%u"" , seq ) ) ; opts_len -= 8 ; break ; case PGM_OPT_CURR_TGSIZE : if ( opt_len != 8 ) { ND_PRINT ( ( ndo , ""[BadOPT_CURR_TGSIZEoption,length%u!=8]"" , opt_len ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""PARITYATGS%u"" , len ) ) ; opts_len -= 8 ; break ; case PGM_OPT_NBR_UNREACH : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_NBR_UNREACHoption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""NBR_UNREACH"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""PATH_NLA[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_SYNoption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""SYN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_FIN : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_FINoption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""FIN"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_RST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_RSToption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""RST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[BadOPT_CRQSToption,length%u!=4]"" , opt_len ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""CRQST"" ) ) ; opts_len -= 4 ; break ; case PGM_OPT_PGMCC_DATA : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""PGMCCDATA%u%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[BadOPT_PGMCC_DATAoption,length%u!=12+addresssize]"" , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""PGMCCFEEDBACK%u%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""OPT_%02X[%d]"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }"," return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; }"
662,"CWE-119 void vp9_rd_pick_intra_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x ,  int * returnrate , int64_t * returndist ,  BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ;  int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ;  int y_skip = 0 , uv_skip = 0 ;  int64_t dist_y = 0 , dist_uv = 0 , tx_cache [ TX_MODES ] = { 0 } ;  TX_SIZE max_uv_tx_size ; x -> skip_encode = 0 ; ctx -> skip = 0 ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ;  if ( bsize >= BLOCK_8X8 ) {  if ( rd_pick_intra_sby_mode ( cpi , x , & rate_y , & rate_y_tokenonly ,  & dist_y , & y_skip , bsize , tx_cache ,  best_rd ) >= best_rd ) {  * returnrate = INT_MAX ;   return ;  }  max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize ) ;  rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly ,  & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ;   } else {  y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { * returnrate = INT_MAX ; return ; } max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize ) ; rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , & dist_uv , & uv_skip , BLOCK_8X8 , max_uv_tx_size ) ; } if ( y_skip && uv_skip ) {  * returnrate = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly +  vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;  * returndist = dist_y + dist_uv ;   vp9_zero ( ctx -> tx_rd_diff ) ;  } else { int i ; * returnrate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; * returndist = dist_y + dist_uv ; if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ; i < TX_MODES ; i ++ ) { if ( tx_cache [ i ] < INT64_MAX && tx_cache [ cm -> tx_mode ] < INT64_MAX ) ctx -> tx_rd_diff [ i ] = tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ; else ctx -> tx_rd_diff [ i ] = 0 ; } } ctx -> mic = * xd -> mi [ 0 ] ; }"," * x , RD_COST * rd_cost ,  BLOCK_SIZE bsize ,  -> e_mbd ; struct macroblockd_plane * const pd = xd -> plane ;  dist_uv = 0  ; TX_SIZE max_uv_tx_size  = INTRA_FRAME ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ;  , bsize ,  best_rd ) >=  best_rd ) { rd_cost -> rate  = INT_MAX ;  ; return ; } } else { y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; }  tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y  & uv_skip , MAX ( BLOCK_8X8 , bsize ) ,  max_uv_tx_size ) ;  max_uv_tx_size ) ;  if ( y_skip  uv_skip ) { rd_cost -> rate  = rate_y +  1 ) ; rd_cost -> dist  = dist_y +  + dist_uv ; } else { rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; rd_cost -> dist = dist_y + dist_uv ; } ctx -> mic = * xd -> mi [ 0 ] ; ctx -> mbmi_ext = * x -> mbmi_ext ; rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist )  ; } "
663,"CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; }  kern_msg -> msg_name = kern_address ;  } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }", err ; } if ( kern_msg -> msg_name )
664,"CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , ""rdensty:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu"" , & density ) ; break ; } if ( LocaleNCompare ( header , ""rpelcnt:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , ""rorient:"" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , ""%lu,%lu"" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , ""rtype:"" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , ""%lu"" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF )  ( void ) fputc ( c , file ) ;  ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""group4:%s"" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lux%lu"" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , ""%lu"" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , ""CALS"" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }"," != EOF ) if (  fputc ( c  , file ) != c ) break"
665,"CWE-264 void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) {  pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ;  void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , false , __builtin_return_address ( 0 ) ) ; }"," ( attrs , PAGE_KERNEL  ) ; void"
666,"CWE-617 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ;  assert ( bidx <= PCI_BARMAX ) ;   assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 ||   pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ;  assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi << 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }"," ) arg2 ; if ( addr + size >  pdi -> bar  bidx ] . addr +  pdi -> bar  bidx ] . size ) { printf ( ""%s,Outofemulatedmemoryrange.\\n"" , __func__ ) ; return - ESRCH ; }  offset = addr"
667,"CWE-415 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( ""%s:asoc:%p,timeo:%ld,msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ;  if ( sk != asoc -> base . sk )  goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }", current_timeo ) ;  lock_sock ( sk
668,"CWE-119 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ;  if ( image_info -> ping ) goto Finish ;  if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , "".PAL"" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , "".pal"" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , ""AH"" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; offset = SeekBlob ( image , 6 , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( depth , BImgBuff , i , image ) ; } ( void ) SyncImage ( image ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( IsGrayImage ( image , & image -> exception ) != MagickFalse ) ) { if ( GetCutColors ( image ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( q , QuantumRange ) ; SetPixelGreen ( q , QuantumRange ) ; SetPixelBlue ( q , QuantumRange ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," image_info -> ping != MagickFalse  goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
669,"CWE-119 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ;  for ( col = 0 ; col < imagewidth ; col += tw ) {  if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,can\'treadtileat%lu%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }", col < imagewidth && colb < imagew
670,"CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows *  number_planes_filled * sizeof ( * pixels ) ) ;  if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;  pixel_info_length = image -> columns * image -> rows * number_planes_filled ;  pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }"," -> rows * MagickMax ( number_planes_filled , 4 )  * sizeof (  -> rows * MagickMax ( number_planes_filled , 4 )  ; pixels ="
671,"CWE-20 int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; }  m -> msg_name = address ;  } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }", err ; } if ( m -> msg_name )
672,"CWE-362 static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ;  * sent = 0 ;  if ( ssocket == NULL ) return - ENOTSOCK ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , ""sendsonsock%pstuckfor15"" ""seconds"" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if ( rc < 0 ) break ; * sent += rc ; if ( rc == remaining ) { remaining = 0 ; break ; } if ( rc > remaining ) { cERROR ( 1 , ""sent%drequested%d"" , rc , remaining ) ; break ; } if ( rc == 0 ) { cERROR ( 1 , ""tcpsentnodata"" ) ; msleep ( 500 ) ; continue ; } remaining -= rc ; for ( i = first_vec ; i < n_vec ; i ++ ) { if ( iov [ i ] . iov_len ) { if ( rc > iov [ i ] . iov_len ) { rc -= iov [ i ] . iov_len ; iov [ i ] . iov_len = 0 ; } else { iov [ i ] . iov_base += rc ; iov [ i ] . iov_len -= rc ; first_vec = i ; break ; } } } i = 0 ; rc = 0 ; } return rc ; }", sent = 0  ; smb_msg .
673,"CWE-125 static int parsestr ( struct compiling * c , const node * n , int * bytesmode , int * rawmode , PyObject * * result , const char * * fstr , Py_ssize_t * fstrlen ) { size_t len ; const char * s = STR ( n ) ; int quote = Py_CHARMASK ( * s ) ; int fmode = 0 ; * bytesmode = 0 ; * rawmode = 0 ; * result = NULL ; * fstr = NULL ; if ( Py_ISALPHA ( quote ) ) { while ( ! * bytesmode || ! * rawmode ) { if ( quote == 'b' || quote == 'B' ) { quote = * ++ s ; * bytesmode = 1 ; } else if ( quote == 'u' || quote == 'U' ) { quote = * ++ s ; } else if ( quote == 'r' || quote == 'R' ) { quote = * ++ s ; * rawmode = 1 ; } else if ( quote == 'f' || quote == 'F' ) { quote = * ++ s ; fmode = 1 ; } else { break ; } } } if ( fmode && * bytesmode ) { PyErr_BadInternalCall ( ) ; return - 1 ; } if ( quote != '\\'' && quote != \'\\""\' ) { PyErr_BadInternalCall ( ) ; return - 1 ; } s ++ ; len = strlen ( s ) ; if ( len > INT_MAX ) { PyErr_SetString ( PyExc_OverflowError , ""stringtoparseistoolong"" ) ; return - 1 ; } if ( s [ -- len ] != quote ) { PyErr_BadInternalCall ( ) ; return - 1 ; } if ( len >= 4 && s [ 0 ] == quote && s [ 1 ] == quote ) { s += 2 ; len -= 2 ; if ( s [ -- len ] != quote || s [ -- len ] != quote ) { PyErr_BadInternalCall ( ) ; return - 1 ; } } if ( fmode ) { * fstr = s ; * fstrlen = len ; return 0 ; } * rawmode = * rawmode || strchr ( s , '\\\\' ) == NULL ; if ( * bytesmode ) { const char * ch ; for ( ch = s ; * ch ; ch ++ ) { if ( Py_CHARMASK ( * ch ) >= 0x80 ) { ast_error ( c , n , ""bytescanonlycontainASCII"" ""literalcharacters."" ) ; return - 1 ; } } if ( * rawmode ) * result = PyBytes_FromStringAndSize ( s , len ) ; else * result = decode_bytes_with_escapes ( c , n , s , len ) ; } else { if ( * rawmode ) * result = PyUnicode_DecodeUTF8Stateful ( s , len , NULL , NULL ) ; else * result = decode_unicode_with_escapes ( c , n , s , len ) ; } return * result == NULL ? - 1 : 0 ; }","
"
674,"CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ;  u8 smac [ ETH_ALEN ] ;  u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ;  if ( is_iboe ) {  if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; }  mutex_lock ( & lock ) ;  if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }"," , ret ;  listen_id = cm_id  goto err3 ;  mutex_lock ( &  ( & lock  ) ; if"
675,"CWE-119  static int t220_frontend_attach ( struct dvb_usb_adapter * d )  { u8 obuf [ 3 ] = { 0xe , 0x87 , 0 } ; u8 ibuf [ ] = { 0 } ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x86 ;   obuf [ 2 ] = 1 ;   if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x80 ;   obuf [ 2 ] = 0 ;   if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ;  msleep ( 50 ) ;  obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x80 ; obuf [ 2 ] = 1 ;  if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command0x0etransferfailed."" ) ;  obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command0x51transferfailed."" ) ;  d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config ,   & d -> dev -> i2c_adap , NULL ) ;   if ( d -> fe_adap [ 0 ] . fe != NULL ) {   if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 ,   & d -> dev -> i2c_adap , & tda18271_config ) ) {  info ( ""AttachedTDA18271HD/CXD2820R!"" ) ; return 0 ; } } info ( ""FailedtoattachTDA18271HD/CXD2820R!"" ) ; return - EIO ; }"," struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1  ; if (  dvb_usb_generic_rw ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  ""command0x0etransferfailed."" ) ; state -> data  [ 0 ]  = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data  [ 2 ]  2 ] = 0  ; if (  dvb_usb_generic_rw ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  ""command0x0etransferfailed."" ) ; msleep ( 50 ) ; state -> data  [ 0 ]  = 0xe ; state -> data  [ 1 ]  = 0x80 ; state -> data  [ 2 ]  2 ] = 1  ; if (  dvb_usb_generic_rw ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  ""command0x0etransferfailed."" ) ; state -> data [ 0 ] = 0x51  ; if (  dvb_usb_generic_rw ( d , state -> data , 1 , state -> data  , 1 ,  ) err (  ""command0x51transferfailed."" ) ;  ""command0x51transferfailed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap  -> fe_adap [  & d ->  i2c_adap , NULL  ; if ( adap  -> fe_adap [  ( tda18271_attach , adap  -> fe_adap [  , & d  -> i2c_adap ,"
676,"CWE-190 int ring_buffer_resize ( struct ring_buffer * buffer , unsigned long size , int cpu_id ) { struct ring_buffer_per_cpu * cpu_buffer ; unsigned long nr_pages ; int cpu , err = 0 ; if ( ! buffer ) return size ; if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ;  size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;  size *= BUF_PAGE_SIZE ; if ( size < BUF_PAGE_SIZE * 2 ) size = BUF_PAGE_SIZE * 2 ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( atomic_read ( & buffer -> resize_disabled ) ) return - EBUSY ; mutex_lock ( & buffer -> mutex ) ; if ( cpu_id == RING_BUFFER_ALL_CPUS ) { for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; cpu_buffer -> nr_pages_to_update = nr_pages - cpu_buffer -> nr_pages ; if ( cpu_buffer -> nr_pages_to_update <= 0 ) continue ; INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; if ( __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , & cpu_buffer -> new_pages , cpu ) ) { err = - ENOMEM ; goto out_err ; } } get_online_cpus ( ) ; for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; if ( ! cpu_buffer -> nr_pages_to_update ) continue ; if ( ! cpu_online ( cpu ) ) { rb_update_pages ( cpu_buffer ) ; cpu_buffer -> nr_pages_to_update = 0 ; } else { schedule_work_on ( cpu , & cpu_buffer -> update_pages_work ) ; } } for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; if ( ! cpu_buffer -> nr_pages_to_update ) continue ; if ( cpu_online ( cpu ) ) wait_for_completion ( & cpu_buffer -> update_done ) ; cpu_buffer -> nr_pages_to_update = 0 ; } put_online_cpus ( ) ; } else { if ( ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) goto out ; cpu_buffer = buffer -> buffers [ cpu_id ] ; if ( nr_pages == cpu_buffer -> nr_pages ) goto out ; cpu_buffer -> nr_pages_to_update = nr_pages - cpu_buffer -> nr_pages ; INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; if ( cpu_buffer -> nr_pages_to_update > 0 && __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , & cpu_buffer -> new_pages , cpu_id ) ) { err = - ENOMEM ; goto out_err ; } get_online_cpus ( ) ; if ( ! cpu_online ( cpu_id ) ) rb_update_pages ( cpu_buffer ) ; else { schedule_work_on ( cpu_id , & cpu_buffer -> update_pages_work ) ; wait_for_completion ( & cpu_buffer -> update_done ) ; } cpu_buffer -> nr_pages_to_update = 0 ; put_online_cpus ( ) ; } out : if ( atomic_read ( & buffer -> record_disabled ) ) { atomic_inc ( & buffer -> record_disabled ) ; synchronize_sched ( ) ; for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; rb_check_pages ( cpu_buffer ) ; } atomic_dec ( & buffer -> record_disabled ) ; } mutex_unlock ( & buffer -> mutex ) ; return size ; out_err : for_each_buffer_cpu ( buffer , cpu ) { struct buffer_page * bpage , * tmp ; cpu_buffer = buffer -> buffers [ cpu ] ; cpu_buffer -> nr_pages_to_update = 0 ; if ( list_empty ( & cpu_buffer -> new_pages ) ) continue ; list_for_each_entry_safe ( bpage , tmp , & cpu_buffer -> new_pages , list ) { list_del_init ( & bpage -> list ) ; free_buffer_page ( bpage ) ; } } mutex_unlock ( & buffer -> mutex ) ; return err ; }"," return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE  ; if ("
677,"CWE-119  static void  horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ;  assert ( ( cc % ( 2 * stride ) ) == 0 ) ;  if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; }  } ","   static int  horAcc16 ( TIFF  / 2 ; if  ( ( cc  stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ; return 0 ; }  if ( wc  ) ; } return 1 ;"
678,"CWE-476 static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ;  if ( ! * passwd || ! * user -> passwd )  return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }"," if ( ! user ) { slog_error ( client , ""Passwordpacketbeforeauthpacket?"" ) ; return false ; } if ( !"
679,"CWE-119 static void lspci_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ;  char * buf ;  pkglen = s -> end - s -> p ; buf = xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , lspci_process_line , NULL ) ; xfree ( buf ) ; }"," * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""lspci_process(),streamisinunstablestate"" , & packet ) ; }"
680,"CWE-119 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ;  for ( col = 0 ; col < imagewidth ; col += tw ) {  if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,can\'twritetileat%lu%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; _TIFFfree ( obuf ) ; return 0 ; } colb += tilew ; } bufp += nrow * imagew ; } _TIFFfree ( obuf ) ; return 1 ; }", col < imagewidth && colb < imagew
681,"CWE-119 static void close_output_file ( struct stream_state * stream , unsigned int fourcc ) { const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) {  write_webm_file_footer ( & stream -> ebml , stream -> hash ) ;  free ( stream -> ebml . cue_list ) ; stream -> ebml . cue_list = NULL ; } # endif if ( ! stream -> config . write_webm ) { if ( ! fseek ( stream -> file , 0 , SEEK_SET ) ) ivf_write_file_header ( stream -> file , & stream -> config . cfg , fourcc , stream -> frames_out ) ; } fclose ( stream -> file ) ; }", stream -> ebml )  ; } #
682,"CWE-119  static void encode_uniform ( vp9_writer * w , int v ) {  const int l = 8 ; const int m = ( 1 << l ) - 191 ; if ( v < m ) {  vp9_write_literal ( w , v , l - 1 ) ;  } else {  vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ;   vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ;  } }"," void encode_uniform ( vpx_writer  * w ,  m ) { vpx_write_literal  ( w ,  } else { vpx_write_literal  ( w ,  1 ) ; vpx_write_literal  ( w ,"
683,"CWE-269 uint32_t virtio_config_readw ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint16_t val ;  k -> get_config ( vdev , vdev -> config ) ;  if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = lduw_p ( vdev -> config + addr ) ; return val ; }", uint16_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; }  -> config )  ; val =
684,"CWE-200 static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ;  strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ;  return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }"," ) ) ; nla_strlcpy  ( link_info .  TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME"
685,"CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , ""Failedtogetgpioioresource.\\n"" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , ""FailedtogetgpioIRQ.\\n"" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ; # if defined ( CONFIG_OF_GPIO ) gpio_dev -> gc . of_node = pdev -> dev . of_node ; # endif gpio_dev -> groups = kerncz_groups ; gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ;  gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc ,   & pdev -> dev , gpio_dev ) ;  if ( IS_ERR ( gpio_dev -> pctrl ) ) { dev_err ( & pdev -> dev , ""Couldn\'tregisterpinctrldriver\\n"" ) ; return PTR_ERR ( gpio_dev -> pctrl ) ; } ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret )  goto out1 ;  ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; if ( ret ) { dev_err ( & pdev -> dev , ""Failedtoaddpinrange\\n"" ) ; goto out2 ; } ret = gpiochip_irqchip_add ( & gpio_dev -> gc , & amd_gpio_irqchip , 0 , handle_simple_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( & pdev -> dev , ""couldnotaddirqchip\\n"" ) ; ret = - ENODEV ; goto out2 ; } gpiochip_set_chained_irqchip ( & gpio_dev -> gc , & amd_gpio_irqchip , irq_base , amd_gpio_irq_handler ) ; platform_set_drvdata ( pdev , gpio_dev ) ; dev_dbg ( & pdev -> dev , ""amdgpiodriverloaded\\n"" ) ; return ret ; out2 : gpiochip_remove ( & gpio_dev -> gc ) ;  out1 :  pinctrl_unregister ( gpio_dev -> pctrl ) ; return ret ; }"," -> pctrl = devm_pinctrl_register ( & pdev -> dev ,  & amd_pinctrl_desc ,  & amd_pinctrl_desc ,  gpio_dev ) ;  ( ret ) return ret  ; ret =  gc ) ;  return ret ;"
686,"CWE-59 static int setup_ttydir_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console , char * ttydir ) { char path [ MAXPATHLEN ] , lxcpath [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/dev/%s"" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( path ) ) return - 1 ; ret = mkdir ( path , 0755 ) ; if ( ret && errno != EEXIST ) { SYSERROR ( ""failedwitherrno%dtocreate%s"" , errno , path ) ; return - 1 ; } INFO ( ""created%s"" , path ) ; ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/dev/%s/console"" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""consolepathtoolong"" ) ; return - 1 ; } snprintf ( path , sizeof ( path ) , ""%s/dev/console"" , rootfs -> mount ) ; ret = unlink ( path ) ; if ( ret && errno != ENOENT ) { SYSERROR ( ""errorunlinking%s"" , path ) ; return - 1 ; } ret = creat ( lxcpath , 0660 ) ; if ( ret == - 1 && errno != EEXIST ) { SYSERROR ( ""error%dcreating%s"" , errno , lxcpath ) ; return - 1 ; } if ( ret >= 0 ) close ( ret ) ; if ( console -> master < 0 ) { INFO ( ""noconsole"" ) ; return 0 ; }  if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) {  ERROR ( ""failedtomount\'%s\'on\'%s\'"" , console -> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/consolepathtoolong"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failedtocreatesymlinkforconsole"" ) ; return - 1 ; } INFO ( ""consolehasbeensetupon%s"" , lxcpath ) ; return 0 ; }"," } if ( safe_mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( ""failedtomount\'%s\'on\'%s\'"" ,  console -> name  name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/consolepathtoolong"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failedtocreatesymlinkforconsole"" ) ; return - 1 ; } INFO ( ""consolehasbeensetupon%s"" , lxcpath ) ; return 0  ; } "
687,"CWE-787  static void nsc_decode ( NSC_CONTEXT * context )  { UINT16 x ; UINT16 y ;  UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ;   BYTE shift = context -> ColorLossLevel - 1 ;   BYTE * bmpdata = context -> BitmapData ;  for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift ) ; INT16 cg_val = ( INT16 ) ( INT8 ) ( * cgplane << shift ) ; INT16 r_val = y_val + co_val - cg_val ; INT16 g_val = y_val + cg_val ; INT16 b_val = y_val - co_val - cg_val ;  * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ;  * bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ; * bmpdata ++ = MINMAX ( r_val , 0 , 0xFF ) ; * bmpdata ++ = * aplane ; yplane ++ ; coplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; cgplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; aplane ++ ; } }  } ",   static BOOL  nsc_decode ( NSC_CONTEXT  ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw  8 ) ;  shift = context  - 1 ;  bmpdata = context  context -> BitmapData ; if ( ! bmpdata ) return FALSE  - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ;  ; } } return TRUE ;
688,"CWE-763  static void atomic2gen ( lua_State * L , global_State * g ) {  sweep2old ( L , & g -> allgc ) ; g -> reallyold = g -> old = g -> survival = g -> allgc ; sweep2old ( L , & g -> finobj ) ; g -> finobjrold = g -> finobjold = g -> finobjsur = g -> finobj ; sweep2old ( L , & g -> tobefnz ) ; g -> gckind = KGC_GEN ; g -> lastatomic = 0 ; g -> GCestimate = gettotalbytes ( g ) ; finishgencycle ( L , g ) ; }", g ) { g -> gcstate = GCSswpallgc ;
689,"CWE-119 int vp8dx_start_decode ( BOOL_DECODER * br , const unsigned char * source , unsigned int source_sz ,  vp8_decrypt_cb * decrypt_cb ,  void * decrypt_state ) { br -> user_buffer_end = source + source_sz ; br -> user_buffer = source ; br -> value = 0 ; br -> count = - 8 ; br -> range = 255 ; br -> decrypt_cb = decrypt_cb ; br -> decrypt_state = decrypt_state ; if ( source_sz && ! source ) return 1 ; vp8dx_bool_decoder_fill ( br ) ; return 0 ; }"," int source_sz , vpx_decrypt_cb  decrypt_cb , void"
690,"CWE-476 static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) )  if ( REMAIN > INT_MAX )  return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup : if ( supportedMech != GSS_C_NO_OID ) { generic_gss_release_oid ( & tmpmin , & supportedMech ) ; } return ret ; # undef REMAIN }", if ( REMAIN == 0 || REMAIN
691,"CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , ""BPF_NEGusesreservedfields\\n"" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , ""BPF_ENDusesreservedfields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%dpointerarithmeticprohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOVusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOVusesreservedfields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%dpartialcopyofpointer\\n"" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ;  regs [ insn -> dst_reg ] . var_off = tnum_cast (  regs [ insn -> dst_reg ] . var_off , 4 ) ;  __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;  } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } } } else if ( opcode > BPF_END ) { verbose ( env , ""invalidBPF_ALUopcode%x\\n"" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALUusesreservedfields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALUusesreservedfields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , ""divbyzero\\n"" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , ""invalidshift%d\\n"" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }"," dst_reg ) ; coerce_reg_to_size  ( & regs  -> dst_reg ] , 4"
692,"CWE-000  WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec ,  UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ;  WORD32 ret ;  ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ;  ps_dec -> u2_total_mbs_coded = 0 ;  { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } } H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }", dec_struct_t * ps_dec  ) { dec_slice_params_t  ; WORD32 ret  ; { dec_err_status_t  return ret ;  H264_MUTEX_UNLOCK ( &
693,"CWE-552 static ssize_t _consolefs_write ( oe_fd_t * file_ , const void * buf , size_t count ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( file_ ) ;  if ( ! file )  OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_write_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ;  done :  return ret ; }", ( ! file || count > OE_SSIZE_MAX  OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
694,"CWE-189 static int i915_gem_do_execbuffer ( struct drm_device * dev , void * data , struct drm_file * file , struct drm_i915_gem_execbuffer2 * args , struct drm_i915_gem_exec_object2 * exec ) { drm_i915_private_t * dev_priv = dev -> dev_private ; struct list_head objects ; struct eb_objects * eb ; struct drm_i915_gem_object * batch_obj ; struct drm_clip_rect * cliprects = NULL ; struct intel_ring_buffer * ring ; u32 exec_start , exec_len ; u32 seqno ; u32 mask ; int ret , mode , i ; if ( ! i915_gem_check_execbuffer ( args ) ) { DRM_DEBUG ( ""execbufwithinvalidoffset/length\\n"" ) ; return - EINVAL ; } ret = validate_exec_list ( exec , args -> buffer_count ) ; if ( ret ) return ret ; switch ( args -> flags & I915_EXEC_RING_MASK ) { case I915_EXEC_DEFAULT : case I915_EXEC_RENDER : ring = & dev_priv -> ring [ RCS ] ; break ; case I915_EXEC_BSD : if ( ! HAS_BSD ( dev ) ) { DRM_DEBUG ( ""execbufwithinvalidring(BSD)\\n"" ) ; return - EINVAL ; } ring = & dev_priv -> ring [ VCS ] ; break ; case I915_EXEC_BLT : if ( ! HAS_BLT ( dev ) ) { DRM_DEBUG ( ""execbufwithinvalidring(BLT)\\n"" ) ; return - EINVAL ; } ring = & dev_priv -> ring [ BCS ] ; break ; default : DRM_DEBUG ( ""execbufwithunknownring:%d\\n"" , ( int ) ( args -> flags & I915_EXEC_RING_MASK ) ) ; return - EINVAL ; } mode = args -> flags & I915_EXEC_CONSTANTS_MASK ; mask = I915_EXEC_CONSTANTS_MASK ; switch ( mode ) { case I915_EXEC_CONSTANTS_REL_GENERAL : case I915_EXEC_CONSTANTS_ABSOLUTE : case I915_EXEC_CONSTANTS_REL_SURFACE : if ( ring == & dev_priv -> ring [ RCS ] && mode != dev_priv -> relative_constants_mode ) { if ( INTEL_INFO ( dev ) -> gen < 4 ) return - EINVAL ; if ( INTEL_INFO ( dev ) -> gen > 5 && mode == I915_EXEC_CONSTANTS_REL_SURFACE ) return - EINVAL ; if ( INTEL_INFO ( dev ) -> gen >= 6 ) mask &= ~ I915_EXEC_CONSTANTS_REL_SURFACE ; } break ; default : DRM_DEBUG ( ""execbufwithunknownconstants:%d\\n"" , mode ) ; return - EINVAL ; } if ( args -> buffer_count < 1 ) { DRM_DEBUG ( ""execbufwith%dbuffers\\n"" , args -> buffer_count ) ; return - EINVAL ; } if ( args -> num_cliprects != 0 ) { if ( ring != & dev_priv -> ring [ RCS ] ) {  DRM_DEBUG ( ""cliprectanglesareonlyvalidwiththerenderring\\n"" ) ;  return - EINVAL ; } cliprects = kmalloc ( args -> num_cliprects * sizeof ( * cliprects ) , GFP_KERNEL ) ; if ( cliprects == NULL ) { ret = - ENOMEM ; goto pre_mutex_err ; } if ( copy_from_user ( cliprects , ( struct drm_clip_rect __user * ) ( uintptr_t ) args -> cliprects_ptr , sizeof ( * cliprects ) * args -> num_cliprects ) ) { ret = - EFAULT ; goto pre_mutex_err ; } } ret = i915_mutex_lock_interruptible ( dev ) ; if ( ret ) goto pre_mutex_err ; if ( dev_priv -> mm . suspended ) { mutex_unlock ( & dev -> struct_mutex ) ; ret = - EBUSY ; goto pre_mutex_err ; } eb = eb_create ( args -> buffer_count ) ; if ( eb == NULL ) { mutex_unlock ( & dev -> struct_mutex ) ; ret = - ENOMEM ; goto pre_mutex_err ; } INIT_LIST_HEAD ( & objects ) ; for ( i = 0 ; i < args -> buffer_count ; i ++ ) { struct drm_i915_gem_object * obj ; obj = to_intel_bo ( drm_gem_object_lookup ( dev , file , exec [ i ] . handle ) ) ; if ( & obj -> base == NULL ) { DRM_DEBUG ( ""Invalidobjecthandle%datindex%d\\n"" , exec [ i ] . handle , i ) ; ret = - ENOENT ; goto err ; } if ( ! list_empty ( & obj -> exec_list ) ) { DRM_DEBUG ( ""Object%p[handle%d,index%d]appearsmorethanonceinobjectlist\\n"" , obj , exec [ i ] . handle , i ) ; ret = - EINVAL ; goto err ; } list_add_tail ( & obj -> exec_list , & objects ) ; obj -> exec_handle = exec [ i ] . handle ; obj -> exec_entry = & exec [ i ] ; eb_add_object ( eb , obj ) ; } batch_obj = list_entry ( objects . prev , struct drm_i915_gem_object , exec_list ) ; ret = i915_gem_execbuffer_reserve ( ring , file , & objects ) ; if ( ret ) goto err ; ret = i915_gem_execbuffer_relocate ( dev , eb , & objects ) ; if ( ret ) { if ( ret == - EFAULT ) { ret = i915_gem_execbuffer_relocate_slow ( dev , file , ring , & objects , eb , exec , args -> buffer_count ) ; BUG_ON ( ! mutex_is_locked ( & dev -> struct_mutex ) ) ; } if ( ret ) goto err ; } if ( batch_obj -> base . pending_write_domain ) { DRM_DEBUG ( ""Attemptingtouseself-modifyingbatchbuffer\\n"" ) ; ret = - EINVAL ; goto err ; } batch_obj -> base . pending_read_domains |= I915_GEM_DOMAIN_COMMAND ; ret = i915_gem_execbuffer_move_to_gpu ( ring , & objects ) ; if ( ret ) goto err ; seqno = i915_gem_next_request_seqno ( ring ) ; for ( i = 0 ; i < ARRAY_SIZE ( ring -> sync_seqno ) ; i ++ ) { if ( seqno < ring -> sync_seqno [ i ] ) { ret = i915_gpu_idle ( dev , true ) ; if ( ret ) goto err ; BUG_ON ( ring -> sync_seqno [ i ] ) ; } } if ( ring == & dev_priv -> ring [ RCS ] && mode != dev_priv -> relative_constants_mode ) { ret = intel_ring_begin ( ring , 4 ) ; if ( ret ) goto err ; intel_ring_emit ( ring , MI_NOOP ) ; intel_ring_emit ( ring , MI_LOAD_REGISTER_IMM ( 1 ) ) ; intel_ring_emit ( ring , INSTPM ) ; intel_ring_emit ( ring , mask << 16 | mode ) ; intel_ring_advance ( ring ) ; dev_priv -> relative_constants_mode = mode ; } if ( args -> flags & I915_EXEC_GEN7_SOL_RESET ) { ret = i915_reset_gen7_sol_offsets ( dev , ring ) ; if ( ret ) goto err ; } trace_i915_gem_ring_dispatch ( ring , seqno ) ; exec_start = batch_obj -> gtt_offset + args -> batch_start_offset ; exec_len = args -> batch_len ; if ( cliprects ) { for ( i = 0 ; i < args -> num_cliprects ; i ++ ) { ret = i915_emit_box ( dev , & cliprects [ i ] , args -> DR1 , args -> DR4 ) ; if ( ret ) goto err ; ret = ring -> dispatch_execbuffer ( ring , exec_start , exec_len ) ; if ( ret ) goto err ; } } else { ret = ring -> dispatch_execbuffer ( ring , exec_start , exec_len ) ; if ( ret ) goto err ; } i915_gem_execbuffer_move_to_active ( & objects , ring , seqno ) ; i915_gem_execbuffer_retire_commands ( dev , file , ring ) ; err : eb_destroy ( eb ) ; while ( ! list_empty ( & objects ) ) { struct drm_i915_gem_object * obj ; obj = list_first_entry ( & objects , struct drm_i915_gem_object , exec_list ) ; list_del_init ( & obj -> exec_list ) ; drm_gem_object_unreference ( & obj -> base ) ; } mutex_unlock ( & dev -> struct_mutex ) ; pre_mutex_err : kfree ( cliprects ) ; return ret ; }"," DRM_DEBUG ( ""cliprectanglesareonlyvalidwiththerenderring\\n"" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( ""execbufwith%ucliprects\\n"" , args -> num_cliprects"
695,"CWE-362 static inline int ldsem_cmpxchg ( long * old , long new , struct ld_semaphore * sem ) {  long tmp = * old ;  * old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;  return * old == tmp ;  }", long tmp =  atomic_long_cmpxchg ( &  new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; }  }  
696,"CWE-787 static void numtostr ( js_State * J , const char * fmt , int w , double n ) {  char buf [ 32 ] , * e ;  sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , ""e%+d"" , exp ) ; } js_pushstring ( J , buf ) ; }"," char buf [ 50  ] , *"
697,"CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ;  nfcf_poll -> sensf_res_len = * data ++ ;  pr_debug ( ""bit_rate%d,sensf_res_len%d\\n"" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }"," -> sensf_res_len = min_t ( __u8 ,  * data ++ , NFC_SENSF_RES_MAXSIZE )"
698,"CWE-416 static ssize_t ucma_process_join ( struct ucma_file * file , struct rdma_ucm_join_mcast * cmd , int out_len ) { struct rdma_ucm_create_id_resp resp ; struct ucma_context * ctx ; struct ucma_multicast * mc ; struct sockaddr * addr ; int ret ; u8 join_state ; if ( out_len < sizeof ( resp ) ) return - ENOSPC ; addr = ( struct sockaddr * ) & cmd -> addr ; if ( cmd -> addr_size != rdma_addr_size ( addr ) ) return - EINVAL ; if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER ) join_state = BIT ( FULLMEMBER_JOIN ) ; else if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER ) join_state = BIT ( SENDONLY_FULLMEMBER_JOIN ) ; else return - EINVAL ; ctx = ucma_get_ctx_dev ( file , cmd -> id ) ; if ( IS_ERR ( ctx ) ) return PTR_ERR ( ctx ) ; mutex_lock ( & file -> mut ) ; mc = ucma_alloc_multicast ( ctx ) ; if ( ! mc ) { ret = - ENOMEM ; goto err1 ; } mc -> join_state = join_state ; mc -> uid = cmd -> uid ; memcpy ( & mc -> addr , addr , cmd -> addr_size ) ; ret = rdma_join_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr , join_state , mc ) ; if ( ret ) goto err2 ; resp . id = mc -> id ; if ( copy_to_user ( u64_to_user_ptr ( cmd -> response ) , & resp , sizeof ( resp ) ) ) { ret = - EFAULT ; goto err3 ; }  mutex_unlock ( & file -> mut ) ;  ucma_put_ctx ( ctx ) ; return 0 ; err3 : rdma_leave_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr ) ; ucma_cleanup_mc_events ( mc ) ; err2 : mutex_lock ( & mut ) ; idr_remove ( & multicast_idr , mc -> id ) ; mutex_unlock ( & mut ) ; list_del ( & mc -> list ) ; kfree ( mc ) ; err1 : mutex_unlock ( & file -> mut ) ; ucma_put_ctx ( ctx ) ; return ret ; }"," err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;"
699,"CWE-000 static int selectExpander ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i , j , k ; SrcList * pTabList ; ExprList * pEList ; struct SrcList_item * pFrom ; sqlite3 * db = pParse -> db ; Expr * pE , * pRight , * pExpr ; u16 selFlags = p -> selFlags ; u32 elistFlags = 0 ; p -> selFlags |= SF_Expanded ; if ( db -> mallocFailed ) { return WRC_Abort ; } assert ( p -> pSrc != 0 ) ; if ( ( selFlags & SF_Expanded ) != 0 ) { return WRC_Prune ; } if ( pWalker -> eCode ) { p -> selId = ++ pParse -> nSelect ; } pTabList = p -> pSrc ; pEList = p -> pEList ; sqlite3WithPush ( pParse , p -> pWith , 0 ) ; sqlite3SrcListAssignCursors ( pParse , pTabList ) ; for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab ; assert ( pFrom -> fg . isRecursive == 0 || pFrom -> pTab != 0 ) ; if ( pFrom -> fg . isRecursive ) continue ; assert ( pFrom -> pTab == 0 ) ; # ifndef SQLITE_OMIT_CTE if ( withExpand ( pWalker , pFrom ) ) return WRC_Abort ; if ( pFrom -> pTab ) { } else # endif if ( pFrom -> zName == 0 ) { # ifndef SQLITE_OMIT_SUBQUERY Select * pSel = pFrom -> pSelect ; assert ( pSel != 0 ) ; assert ( pFrom -> pTab == 0 ) ; if ( sqlite3WalkSelect ( pWalker , pSel ) ) return WRC_Abort ; if ( sqlite3ExpandSubquery ( pParse , pFrom ) ) return WRC_Abort ; # endif } else { assert ( pFrom -> pTab == 0 ) ; pFrom -> pTab = pTab = sqlite3LocateTableItem ( pParse , 0 , pFrom ) ; if ( pTab == 0 ) return WRC_Abort ; if ( pTab -> nTabRef >= 0xffff ) { sqlite3ErrorMsg ( pParse , ""toomanyreferencesto\\""%s\\"":max65535"" , pTab -> zName ) ; pFrom -> pTab = 0 ; return WRC_Abort ; } pTab -> nTabRef ++ ; if ( ! IsVirtual ( pTab ) && cannotBeFunction ( pParse , pFrom ) ) { return WRC_Abort ; } # if ! defined ( SQLITE_OMIT_VIEW ) || ! defined ( SQLITE_OMIT_VIRTUALTABLE ) if ( IsVirtual ( pTab ) || pTab -> pSelect ) { i16 nCol ; u8 eCodeOrig = pWalker -> eCode ; if ( sqlite3ViewGetColumnNames ( pParse , pTab ) ) return WRC_Abort ; assert ( pFrom -> pSelect == 0 ) ; if ( pTab -> pSelect && ( db -> flags & SQLITE_EnableView ) == 0 ) { sqlite3ErrorMsg ( pParse , ""accesstoview\\""%s\\""prohibited"" , pTab -> zName ) ; } pFrom -> pSelect = sqlite3SelectDup ( db , pTab -> pSelect , 0 ) ; nCol = pTab -> nCol ; pTab -> nCol = - 1 ; pWalker -> eCode = 1 ; sqlite3WalkSelect ( pWalker , pFrom -> pSelect ) ; pWalker -> eCode = eCodeOrig ; pTab -> nCol = nCol ; } # endif } if ( sqlite3IndexedByLookup ( pParse , pFrom ) ) { return WRC_Abort ; } }  if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) {  return WRC_Abort ; } for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { pE = pEList -> a [ k ] . pExpr ; if ( pE -> op == TK_ASTERISK ) break ; assert ( pE -> op != TK_DOT || pE -> pRight != 0 ) ; assert ( pE -> op != TK_DOT || ( pE -> pLeft != 0 && pE -> pLeft -> op == TK_ID ) ) ; if ( pE -> op == TK_DOT && pE -> pRight -> op == TK_ASTERISK ) break ; elistFlags |= pE -> flags ; } if ( k < pEList -> nExpr ) { struct ExprList_item * a = pEList -> a ; ExprList * pNew = 0 ; int flags = pParse -> db -> flags ; int longNames = ( flags & SQLITE_FullColNames ) != 0 && ( flags & SQLITE_ShortColNames ) == 0 ; for ( k = 0 ; k < pEList -> nExpr ; k ++ ) { pE = a [ k ] . pExpr ; elistFlags |= pE -> flags ; pRight = pE -> pRight ; assert ( pE -> op != TK_DOT || pRight != 0 ) ; if ( pE -> op != TK_ASTERISK && ( pE -> op != TK_DOT || pRight -> op != TK_ASTERISK ) ) { pNew = sqlite3ExprListAppend ( pParse , pNew , a [ k ] . pExpr ) ; if ( pNew ) { pNew -> a [ pNew -> nExpr - 1 ] . zName = a [ k ] . zName ; pNew -> a [ pNew -> nExpr - 1 ] . zSpan = a [ k ] . zSpan ; a [ k ] . zName = 0 ; a [ k ] . zSpan = 0 ; } a [ k ] . pExpr = 0 ; } else { int tableSeen = 0 ; char * zTName = 0 ; if ( pE -> op == TK_DOT ) { assert ( pE -> pLeft != 0 ) ; assert ( ! ExprHasProperty ( pE -> pLeft , EP_IntValue ) ) ; zTName = pE -> pLeft -> u . zToken ; } for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab = pFrom -> pTab ; Select * pSub = pFrom -> pSelect ; char * zTabName = pFrom -> zAlias ; const char * zSchemaName = 0 ; int iDb ; if ( zTabName == 0 ) { zTabName = pTab -> zName ; } if ( db -> mallocFailed ) break ; if ( pSub == 0 || ( pSub -> selFlags & SF_NestedFrom ) == 0 ) { pSub = 0 ; if ( zTName && sqlite3StrICmp ( zTName , zTabName ) != 0 ) { continue ; } iDb = sqlite3SchemaToIndex ( db , pTab -> pSchema ) ; zSchemaName = iDb >= 0 ? db -> aDb [ iDb ] . zDbSName : ""*"" ; } for ( j = 0 ; j < pTab -> nCol ; j ++ ) { char * zName = pTab -> aCol [ j ] . zName ; char * zColname ; char * zToFree ; Token sColname ; assert ( zName ) ; if ( zTName && pSub && sqlite3MatchSpanName ( pSub -> pEList -> a [ j ] . zSpan , 0 , zTName , 0 ) == 0 ) { continue ; } if ( ( p -> selFlags & SF_IncludeHidden ) == 0 && IsHiddenColumn ( & pTab -> aCol [ j ] ) ) { continue ; } tableSeen = 1 ; if ( i > 0 && zTName == 0 ) { if ( ( pFrom -> fg . jointype & JT_NATURAL ) != 0 && tableAndColumnIndex ( pTabList , i , zName , 0 , 0 ) ) { continue ; } if ( sqlite3IdListIndex ( pFrom -> pUsing , zName ) >= 0 ) { continue ; } } pRight = sqlite3Expr ( db , TK_ID , zName ) ; zColname = zName ; zToFree = 0 ; if ( longNames || pTabList -> nSrc > 1 ) { Expr * pLeft ; pLeft = sqlite3Expr ( db , TK_ID , zTabName ) ; pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pRight ) ; if ( zSchemaName ) { pLeft = sqlite3Expr ( db , TK_ID , zSchemaName ) ; pExpr = sqlite3PExpr ( pParse , TK_DOT , pLeft , pExpr ) ; } if ( longNames ) { zColname = sqlite3MPrintf ( db , ""%s.%s"" , zTabName , zName ) ; zToFree = zColname ; } } else { pExpr = pRight ; } pNew = sqlite3ExprListAppend ( pParse , pNew , pExpr ) ; sqlite3TokenInit ( & sColname , zColname ) ; sqlite3ExprListSetName ( pParse , pNew , & sColname , 0 ) ; if ( pNew && ( p -> selFlags & SF_NestedFrom ) != 0 ) { struct ExprList_item * pX = & pNew -> a [ pNew -> nExpr - 1 ] ; if ( pSub ) { pX -> zSpan = sqlite3DbStrDup ( db , pSub -> pEList -> a [ j ] . zSpan ) ; testcase ( pX -> zSpan == 0 ) ; } else { pX -> zSpan = sqlite3MPrintf ( db , ""%s.%s.%s"" , zSchemaName , zTabName , zColname ) ; testcase ( pX -> zSpan == 0 ) ; } pX -> bSpanIsTab = 1 ; } sqlite3DbFree ( db , zToFree ) ; } } if ( ! tableSeen ) { if ( zTName ) { sqlite3ErrorMsg ( pParse , ""nosuchtable:%s"" , zTName ) ; } else { sqlite3ErrorMsg ( pParse , ""notablesspecified"" ) ; } } } } sqlite3ExprListDelete ( db , pEList ) ; p -> pEList = pNew ; } if ( p -> pEList ) { if ( p -> pEList -> nExpr > db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , ""toomanycolumnsinresultset"" ) ; return WRC_Abort ; } if ( ( elistFlags & ( EP_HasFunc | EP_Subquery ) ) != 0 ) { p -> selFlags |= SF_ComplexResult ; } } return WRC_Continue ; }", } if ( pParse -> nErr ||
700,"CWE-000 static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ;  u64 msr_data ;  int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ;  cs . dpl = 3 ;  ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ;  break ;  } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ;  ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;   * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;  return X86EMUL_CONTINUE ; }"," ; u64 msr_data , rcx , rdx  = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ;  = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ;  -> _eip = rdx  ; * reg_write  VCPU_REGS_RSP ) = rcx  ; return X86EMUL_CONTINUE"
701,"CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) {  struct packet_sock * po = pkt_sk ( sk ) ;  struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; }  if ( ! po -> running )   return - EINVAL ;  if ( po -> fanout )  return - EALREADY ;  if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {  po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;   if ( ! po -> rollover )  return - ENOMEM ;  atomic_long_set ( & po -> rollover -> num , 0 ) ;   atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;   atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;   }  mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out :  mutex_unlock ( & fanout_mutex ) ;   if ( err ) {  kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }"," ) { struct packet_rollover * rollover = NULL ; struct  EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ;  -> running ) goto out ; err = - EALREADY  ; if (  -> fanout ) goto out  ; if (  ) ) { err = - ENOMEM ;  rollover = kzalloc  sizeof ( *  rollover ) ,  if ( ! rollover ) goto out  ; atomic_long_set (  atomic_long_set ( &  rollover -> num  atomic_long_set ( &  rollover -> num_huge  atomic_long_set ( &  rollover -> num_failed  0 ) ; po -> rollover = rollover ; }  match = NULL  } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; }  fanout_mutex ) ;  return err ;"
702,"CWE-20 static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ;  return fd ;  } } return - 1 ; }", = hash ; sr -> fd_is_fdt = MK_TRUE ;
703,"CWE-119  int vp8_denoiser_allocate ( VP8_DENOISER * denoiser , int width , int height )  { int i ;  assert ( denoiser ) ;  for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { denoiser -> yv12_running_avg [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & ( denoiser -> yv12_running_avg [ i ] ) , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; }  vpx_memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 ,  denoiser -> yv12_running_avg [ i ] . frame_size ) ; } denoiser -> yv12_mc_running_avg . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & ( denoiser -> yv12_mc_running_avg ) , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; }  vpx_memset ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 ,  denoiser -> yv12_mc_running_avg . frame_size ) ;  return 0 ;  }"," , int height , int num_mb_rows , int num_mb_cols , int mode  ( denoiser ) ; denoiser -> num_mb_cols = num_mb_cols  1 ; } memset  ( denoiser ->  1 ; } memset  ( denoiser ->  frame_size ) ; if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ; denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ; memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ; vp8_denoiser_set_parameters ( denoiser , mode ) ; denoiser -> nmse_source_diff = 0 ; denoiser -> nmse_source_diff_count = 0 ; denoiser -> qp_avg = 0 ; denoiser -> qp_threshold_up = 80 ; denoiser -> qp_threshold_down = 128 ; denoiser -> bitrate_threshold = 400000 ; denoiser -> threshold_aggressive_mode = 80 ; if ( width * height > 1280 * 720 ) { denoiser -> bitrate_threshold = 3000000 ; denoiser -> threshold_aggressive_mode = 200 ; } else if ( width * height > 960 * 540 ) { denoiser -> bitrate_threshold = 1200000 ; denoiser -> threshold_aggressive_mode = 120 ; } else if ( width * height > 640 * 480 ) { denoiser -> bitrate_threshold = 600000 ; denoiser -> threshold_aggressive_mode = 100 ; } return  0 ; }"
704,"CWE-000 static int mct_u232_port_probe ( struct usb_serial_port * port ) {  struct mct_u232_private * priv ;  priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ;  priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ;  priv -> read_urb -> context = port ; spin_lock_init ( & priv -> lock ) ; usb_set_serial_port_data ( port , priv ) ; return 0 ; }"," ) { struct usb_serial * serial = port -> serial ; struct  * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , ""expectedendpointmissing\\n"" ) ; return - ENODEV ; }  -> read_urb =  serial -> port"
705,"CWE-399 int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( ""SSH2_MSG_KEXINITreceived"" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ;  ptr = sshpkt_ptr ( ssh , & dlen ) ;  if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }"," return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;"
706,"CWE-476 static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ;  if ( ( temp_buffer & 0xffffff00 ) != 0x100 )  continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;  else if ( temp_buffer < 0x120 )  VO ++ ;  else if ( temp_buffer < 0x130 )  VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }", ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2  ) continue ;  if ( temp_buffer >= 0x100 && temp_buffer  else if ( temp_buffer >= 0x120 &&
707,"CWE-264 static int em_jmp_far ( struct x86_emulate_ctxt * ctxt ) { int rc ;  unsigned short sel ;  memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;  rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ;  if ( rc != X86EMUL_CONTINUE ) return rc ;  ctxt -> _eip = 0 ;   memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;   return X86EMUL_CONTINUE ;  }"," unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS )  ; rc = __load_segment_descriptor  ( ctxt ,  sel , VCPU_SREG_CS , cpl , false , & new_desc  return rc ; rc = assign_eip_far ( ctxt  , ctxt ->  -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS  ) ; return  ) ; return rc ; } return rc  ; } "
708,CWE-682 static int find_low_bit ( unsigned int x ) { int i ; for ( i = 0 ; i <= 31 ; i ++ ) {  if ( x & ( 1 << i ) ) return i ;  } return 0 ; }, x & ( 1U << ( unsigned int )  i ) )
709,"CWE-617 int connection_exit_begin_conn ( cell_t * cell , circuit_t * circ ) { edge_connection_t * n_stream ; relay_header_t rh ; char * address = NULL ; uint16_t port = 0 ;  or_circuit_t * or_circ = NULL ;  const or_options_t * options = get_options ( ) ; begin_cell_t bcell ; int rv ; uint8_t end_reason = 0 ; assert_circuit_ok ( circ ) ;  if ( ! CIRCUIT_IS_ORIGIN ( circ ) )   or_circ = TO_OR_CIRCUIT ( circ ) ;  relay_header_unpack ( & rh , cell -> payload ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) return - END_CIRC_REASON_TORPROTOCOL ; if ( ! server_mode ( options ) && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relaybegincellatnon-server.Closing."" ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , NULL ) ; return 0 ; } rv = begin_cell_parse ( cell , & bcell , & end_reason ) ; if ( rv < - 1 ) { return - END_CIRC_REASON_TORPROTOCOL ; } else if ( rv == - 1 ) { tor_free ( bcell . address ) ;  relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ;  return 0 ; } if ( ! bcell . is_begindir ) { address = bcell . address ; port = bcell . port ; if ( or_circ && or_circ -> p_chan ) { if ( ! options -> AllowSingleHopExits && ( or_circ -> is_first_hop || ( ! connection_or_digest_is_known_relay ( or_circ -> p_chan -> identity_digest ) && should_refuse_unknown_exits ( options ) ) ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Attemptby%stoopenastream%s.Closing."" , safe_str ( channel_get_canonical_remote_descr ( or_circ -> p_chan ) ) , or_circ -> is_first_hop ? ""onfirsthopofcircuit"" : ""fromunknownrelay"" ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , or_circ -> is_first_hop ? END_STREAM_REASON_TORPROTOCOL : END_STREAM_REASON_MISC , NULL ) ; tor_free ( address ) ; return 0 ; } } } else if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { if ( ! directory_permits_begindir_requests ( options ) || circ -> purpose != CIRCUIT_PURPOSE_OR ) { relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_NOTDIRECTORY , NULL ) ;  return 0 ; } if ( or_circ && or_circ -> p_chan ) address = tor_strdup ( channel_get_actual_remote_address ( or_circ -> p_chan ) ) ; else address = tor_strdup ( ""127.0.0.1"" ) ; port = 1 ; } else { log_warn ( LD_BUG , ""Gotanunexpectedcommand%d"" , ( int ) rh . command ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_INTERNAL , NULL ) ;  return 0 ; } if ( ! options -> IPv6Exit ) { bcell . flags &= ~ BEGIN_FLAG_IPV6_PREFERRED ; if ( bcell . flags & BEGIN_FLAG_IPV4_NOT_OK ) { tor_free ( address ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_EXITPOLICY , NULL ) ;  return 0 ; } } log_debug ( LD_EXIT , ""Creatingnewexitconnection."" ) ; n_stream = edge_connection_new ( CONN_TYPE_EXIT , AF_INET ) ; n_stream -> dirreq_id = circ -> dirreq_id ; n_stream -> base_ . purpose = EXIT_PURPOSE_CONNECT ; n_stream -> begincell_flags = bcell . flags ; n_stream -> stream_id = rh . stream_id ; n_stream -> base_ . port = port ; n_stream -> package_window = STREAMWINDOW_START ; n_stream -> deliver_window = STREAMWINDOW_START ; if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) {  origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;  log_info ( LD_REND , ""beginisforrendezvous.configuringstream."" ) ; n_stream -> base_ . address = tor_strdup ( ""(rendezvous)"" ) ; n_stream -> base_ . state = EXIT_CONN_STATE_CONNECTING ; n_stream -> rend_data = rend_data_dup ( origin_circ -> rend_data ) ; tor_assert ( connection_edge_is_rendezvous_stream ( n_stream ) ) ; assert_circuit_ok ( circ ) ; const int r = rend_service_set_connection_addr_port ( n_stream , origin_circ ) ; if ( r < 0 ) { log_info ( LD_REND , ""Didn\'tfindrendezvousservice(port%d)"" , n_stream -> base_ . port ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE ,  origin_circ -> cpath -> prev ) ;  connection_free ( TO_CONN ( n_stream ) ) ; tor_free ( address ) ; if ( r < - 1 ) return END_CIRC_AT_ORIGIN ; else return 0 ; } assert_circuit_ok ( circ ) ; log_debug ( LD_REND , ""Finishedassigningaddr/port"" ) ; n_stream -> cpath_layer = origin_circ -> cpath -> prev ; n_stream -> next_stream = origin_circ -> p_streams ; n_stream -> on_circuit = circ ; origin_circ -> p_streams = n_stream ; assert_circuit_ok ( circ ) ; origin_circ -> rend_data -> nr_streams ++ ; connection_exit_connect ( n_stream ) ; pathbias_mark_use_success ( origin_circ ) ; tor_free ( address ) ; return 0 ; } tor_strlower ( address ) ; n_stream -> base_ . address = address ; n_stream -> base_ . state = EXIT_CONN_STATE_RESOLVEFAILED ; if ( we_are_hibernating ( ) ) { relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_HIBERNATING , NULL ) ; connection_free ( TO_CONN ( n_stream ) ) ; return 0 ; } n_stream -> on_circuit = circ ; if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { tor_addr_t tmp_addr ; tor_assert ( or_circ ) ; if ( or_circ -> p_chan && channel_get_addr_if_possible ( or_circ -> p_chan , & tmp_addr ) ) { tor_addr_copy ( & n_stream -> base_ . addr , & tmp_addr ) ; } return connection_exit_connect_dir ( n_stream ) ; } log_debug ( LD_EXIT , ""abouttostartthedns_resolve()."" ) ; switch ( dns_resolve ( n_stream ) ) { case 1 : assert_circuit_ok ( circ ) ; log_debug ( LD_EXIT , ""abouttocallconnection_exit_connect()."" ) ; connection_exit_connect ( n_stream ) ; return 0 ; case - 1 : relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_RESOLVEFAILED , NULL ) ; break ; case 0 : assert_circuit_ok ( circ ) ; break ; } return 0 ; }"," or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint  circ ) ) {  circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; }  , end_reason , layer_hint  ) ; return  , END_STREAM_REASON_NOTDIRECTORY , layer_hint  ) ; return  , END_STREAM_REASON_INTERNAL , layer_hint  ) ; return  , END_STREAM_REASON_EXITPOLICY , layer_hint  ) ; return  CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ  ) ; log_info  , END_STREAM_REASON_DONE , layer_hint  ) ; connection_free"
710,"CWE-20 static void unix_copy_addr ( struct msghdr * msg , struct sock * sk ) {  struct unix_sock * u = unix_sk ( sk ) ;  msg -> msg_namelen = 0 ; if ( u -> addr ) { msg -> msg_namelen = u -> addr -> len ; memcpy ( msg -> msg_name , u -> addr -> name , u -> addr -> len ) ; } }", ( sk )  ; if (
711,"CWE-200 int xstateregs_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct fpu * fpu = & target -> thread . fpu ; struct xregs_state * xsave ; int ret ; if ( ! boot_cpu_has ( X86_FEATURE_XSAVE ) ) return - ENODEV ; if ( ( pos != 0 ) || ( count < fpu_user_xstate_size ) ) return - EFAULT ; xsave = & fpu -> state . xsave ; fpu__activate_fpstate_write ( fpu ) ; if ( boot_cpu_has ( X86_FEATURE_XSAVES ) ) { if ( kbuf ) ret = copy_kernel_to_xstate ( xsave , kbuf ) ; else ret = copy_user_to_xstate ( xsave , ubuf ) ; } else { ret = user_regset_copyin ( & pos , & count , & kbuf , & ubuf , xsave , 0 , - 1 ) ;  }  if ( ret ) fpstate_init ( & fpu -> state ) ; xsave -> i387 . mxcsr &= mxcsr_feature_mask ; xsave -> header . xfeatures &= xfeatures_mask ; memset ( & xsave -> header . reserved , 0 , 48 ) ; return ret ; }", 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
712,"CWE-285 static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) {  umode_t mode = inode -> i_mode ;  retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ;  else {  struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ; iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ;  }  } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { retval = acl ? - EINVAL : 0 ; goto err_out ; } break ; default : BUG ( ) ; } retval = v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( ! retval ) set_cached_acl ( inode , handler -> flags , acl ) ; err_out : posix_acl_release ( acl ) ; return retval ; }"," acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval  ) goto err_out  goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; }  iattr . ia_valid  iattr ) ;  } break ;"
713,"CWE-290 static int valid_host ( cupsd_client_t * con ) { cupsd_alias_t * a ; cupsd_netif_t * netif ; const char * end ; char * ptr ; strlcpy ( con -> clientname , httpGetField ( con -> http , HTTP_FIELD_HOST ) , sizeof ( con -> clientname ) ) ; if ( ( ptr = strrchr ( con -> clientname , ':' ) ) != NULL && ! strchr ( ptr , ']' ) ) { * ptr ++ = '\\0' ; con -> clientport = atoi ( ptr ) ; } else con -> clientport = con -> serverport ; if ( httpAddrLocalhost ( httpGetAddress ( con -> http ) ) ) { return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) ||  # ifdef __linux  ! _cups_strcasecmp ( con -> clientname , ""localhost.localdomain"" ) || # endif ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ; } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) if ( ( end = strrchr ( con -> clientname , '.' ) ) != NULL && end > con -> clientname && ! end [ 1 ] ) { for ( end -- ; end > con -> clientname && * end != '.' ; end -- ) ; } if ( end && ( ! _cups_strcasecmp ( end , "".local"" ) || ! _cups_strcasecmp ( end , "".local."" ) ) ) return ( 1 ) ; # endif if ( isdigit ( con -> clientname [ 0 ] & 255 ) || con -> clientname [ 0 ] == '[' ) { http_addrlist_t * addrlist ; if ( ( addrlist = httpAddrGetList ( con -> clientname , AF_UNSPEC , NULL ) ) != NULL ) { httpAddrFreeList ( addrlist ) ; return ( 1 ) ; } } for ( a = ( cupsd_alias_t * ) cupsArrayFirst ( ServerAlias ) ; a ; a = ( cupsd_alias_t * ) cupsArrayNext ( ServerAlias ) ) { if ( ! strcmp ( a -> name , ""*"" ) ) return ( 1 ) ; if ( ! _cups_strncasecmp ( con -> clientname , a -> name , a -> namelen ) ) { end = con -> clientname + a -> namelen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) for ( a = ( cupsd_alias_t * ) cupsArrayFirst ( DNSSDAlias ) ; a ; a = ( cupsd_alias_t * ) cupsArrayNext ( DNSSDAlias ) ) { if ( ! strcmp ( a -> name , ""*"" ) ) return ( 1 ) ; if ( ! _cups_strncasecmp ( con -> clientname , a -> name , a -> namelen ) ) { end = con -> clientname + a -> namelen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } # endif for ( netif = ( cupsd_netif_t * ) cupsArrayFirst ( NetIFList ) ; netif ; netif = ( cupsd_netif_t * ) cupsArrayNext ( NetIFList ) ) { if ( ! _cups_strncasecmp ( con -> clientname , netif -> hostname , netif -> hostlen ) ) { end = con -> clientname + netif -> hostlen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } return ( 0 ) ; }"," ""localhost."" ) ||  ! strcmp ("
714,"CWE-787 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; greedy_check : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_NON_GREEDY ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 0 ; tok -> u . repeat . possessive = 0 ; } else { possessive_check : if ( ! PEND && PPEEK_IS ( '+' ) && ( ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT ) && tok -> type != TK_INTERVAL ) || ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL ) && tok -> type == TK_INTERVAL ) ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 1 ; } else { tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 0 ; } } break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case 'w' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 0 ; break ; case 'W' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 1 ; break ; case 'b' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_BOUND ; break ; case 'B' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_NOT_WORD_BOUND ; break ; # ifdef USE_WORD_BEGIN_END case '<' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_BEGIN ; break ; case '>' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_END ; break ; # endif case 's' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 0 ; break ; case 'S' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 1 ; break ; case 'd' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 0 ; break ; case 'D' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 1 ; break ; case 'h' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 0 ; break ; case 'H' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 1 ; break ; case 'A' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; begin_buf : tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_BEGIN_BUF ; break ; case 'Z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_SEMI_END_BUF ; break ; case 'z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; end_buf : tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_END_BUF ; break ; case 'G' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_BEGIN_POSITION ; break ; case '`' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto begin_buf ; break ; case '\\'' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto end_buf ; break ; case 'x' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { PINC ; num = scan_unsigned_hexadecimal_number ( & p , end , 8 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { if ( ONIGENC_IS_CODE_XDIGIT ( enc , PPEEK ) ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 2 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 16 ; tok -> u . c = num ; } break ; case 'u' : if ( PEND ) break ; prev = p ; if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 4 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : PUNFETCH ; prev = p ; num = onig_scan_unsigned_number ( & p , end , enc ) ; if ( num < 0 || num > ONIG_MAX_BACKREF_NUM ) { goto skip_backref ; } if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DECIMAL_BACKREF ) && ( num <= env -> num_mem || num <= 9 ) ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = num ; tok -> u . backref . by_name = 0 ; # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level = 0 ; # endif break ; } skip_backref : if ( c == '8' || c == '9' ) { p = prev ; PINC ; break ; } p = prev ; case '0' : if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ;  if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;  if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 8 ; tok -> u . c = num ; } else if ( c != '0' ) { PINC ; } break ; # ifdef USE_NAMED_GROUP case 'k' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_K_NAMED_BACKREF ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { UChar * name_end ; int * backs ; int back_num ; prev = p ; # ifdef USE_BACKREF_WITH_LEVEL name_end = NULL_UCHARP ; r = fetch_name_with_level ( ( OnigCodePoint ) c , & p , end , & name_end , env , & back_num , & tok -> u . backref . level ) ; if ( r == 1 ) tok -> u . backref . exist_level = 1 ; else tok -> u . backref . exist_level = 0 ; # else r = fetch_name ( & p , end , & name_end , env , & back_num , 1 ) ; # endif if ( r < 0 ) return r ; if ( back_num != 0 ) { if ( back_num < 0 ) { back_num = BACKREF_REL_TO_ABS ( back_num , env ) ; if ( back_num <= 0 ) return ONIGERR_INVALID_BACKREF ; } if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( back_num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ back_num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . by_name = 0 ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = back_num ; } else { num = onig_name_to_group_numbers ( env -> reg , prev , name_end , & backs ) ; if ( num <= 0 ) { onig_scan_env_set_error_string ( env , ONIGERR_UNDEFINED_NAME_REFERENCE , prev , name_end ) ; return ONIGERR_UNDEFINED_NAME_REFERENCE ; } if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { int i ; for ( i = 0 ; i < num ; i ++ ) { if ( backs [ i ] > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ backs [ i ] ] ) ) return ONIGERR_INVALID_BACKREF ; } } tok -> type = TK_BACKREF ; tok -> u . backref . by_name = 1 ; if ( num == 1 ) { tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = backs [ 0 ] ; } else { tok -> u . backref . num = num ; tok -> u . backref . refs = backs ; } } } else PUNFETCH ; } break ; # endif # ifdef USE_SUBEXP_CALL case 'g' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_SUBEXP_CALL ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { int gnum ; UChar * name_end ; prev = p ; r = fetch_name ( ( OnigCodePoint ) c , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = prev ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; } else PUNFETCH ; } break ; # endif case 'Q' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE ) ) { tok -> type = TK_QUOTE_OPEN ; } break ; case 'p' : case 'P' : if ( ! PEND && PPEEK_IS ( '{' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { PINC ; tok -> type = TK_CHAR_PROPERTY ; tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { PFETCH ( c ) ; if ( c == '^' ) { tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; } else PUNFETCH ; } } break ; default : { OnigCodePoint c2 ; PUNFETCH ; num = fetch_escaped_value ( & p , end , env , & c2 ) ; if ( num < 0 ) return num ; if ( tok -> u . c != c2 ) { tok -> type = TK_CODE_POINT ; tok -> u . code = c2 ; } else { p = tok -> backp + enclen ( enc , tok -> backp ) ; } } break ; } } else { tok -> u . c = c ; tok -> escaped = 0 ; # ifdef USE_VARIABLE_META_CHARS if ( ( c != ONIG_INEFFECTIVE_META_CHAR ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VARIABLE_META_CHARACTERS ) ) { if ( c == MC_ANYCHAR ( syn ) ) goto any_char ; else if ( c == MC_ANYTIME ( syn ) ) goto anytime ; else if ( c == MC_ZERO_OR_ONE_TIME ( syn ) ) goto zero_or_one_time ; else if ( c == MC_ONE_OR_MORE_TIME ( syn ) ) goto one_or_more_time ; else if ( c == MC_ANYCHAR_ANYTIME ( syn ) ) { tok -> type = TK_ANYCHAR_ANYTIME ; goto out ; } } # endif switch ( c ) { case '.' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DOT_ANYCHAR ) ) break ; # ifdef USE_VARIABLE_META_CHARS any_char : # endif tok -> type = TK_ANYCHAR ; break ; case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ASTERISK_ZERO_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS anytime : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_PLUS_ONE_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS one_or_more_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_ZERO_ONE ) ) break ; # ifdef USE_VARIABLE_META_CHARS zero_or_one_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; goto greedy_check ; break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_QMARK_GROUP_EFFECT ) ) { PINC ; if ( ! PEND && PPEEK_IS ( '#' ) ) { PFETCH ( c ) ; while ( 1 ) { if ( PEND ) return ONIGERR_END_PATTERN_IN_GROUP ; PFETCH ( c ) ; if ( c == MC_ESC ( syn ) ) { if ( ! PEND ) PFETCH ( c ) ; } else { if ( c == ')' ) break ; } } goto start ; } PUNFETCH ; } if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case '^' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE ) ; break ; case '$' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE ) ; break ; case '[' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACKET_CC ) ) break ; tok -> type = TK_CC_OPEN ; break ; case ']' : if ( * src > env -> pattern ) CLOSE_BRACKET_WITHOUT_ESC_WARN ( env , ( UChar * ) ""]"" ) ; break ; case '#' : if ( IS_EXTEND ( env -> option ) ) { while ( ! PEND ) { PFETCH ( c ) ; if ( ONIGENC_IS_CODE_NEWLINE ( enc , c ) ) break ; } goto start ; break ; } break ; case '' : case '\\t' : case '\\n' : case '\\r' : case '\\f' : if ( IS_EXTEND ( env -> option ) ) goto start ; break ; default : break ; } } # ifdef USE_VARIABLE_META_CHARS out : # endif * src = p ; return tok -> type ; }", num < 0 || num >= 256
715,"CWE-125  INST_HANDLER ( lds ) {  int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , ""ram"" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( ""r%d,=,"" , d ) ; }", lds ) { if ( len < 4 ) { return ; }
716,"CWE-787 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ;  for ( col = 0 ; col < imagewidth ; col += tw ) {  if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,can\'twritetileat%lu%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; _TIFFfree ( obuf ) ; return 0 ; } colb += tilew ; } bufp += nrow * imagew ; } _TIFFfree ( obuf ) ; return 1 ; }", col < imagewidth && colb < imagew
717,"CWE-191 int rad_packet_recv ( int fd , struct rad_packet_t * * p , struct sockaddr_in * addr ) { struct rad_packet_t * pack ; struct rad_attr_t * attr ; struct rad_dict_attr_t * da ; struct rad_dict_vendor_t * vendor ; uint8_t * ptr ; int n , id , len , vendor_id ; socklen_t addr_len = sizeof ( * addr ) ; * p = NULL ; pack = rad_packet_alloc ( 0 ) ; if ( ! pack ) return 0 ; ptr = mempool_alloc ( buf_pool ) ; if ( ptr == MAP_FAILED ) { log_emerg ( ""radius:packet:outofmemory\\n"" ) ; goto out_err ; } pack -> buf = ptr ; clock_gettime ( CLOCK_MONOTONIC , & pack -> tv ) ; while ( 1 ) { if ( addr ) n = recvfrom ( fd , pack -> buf , REQ_LENGTH_MAX , 0 , addr , & addr_len ) ; else n = read ( fd , pack -> buf , REQ_LENGTH_MAX ) ; if ( n < 0 ) { rad_packet_free ( pack ) ; if ( errno == EAGAIN ) return 1 ; if ( errno != ECONNREFUSED ) log_ppp_error ( ""radius:packet:read:%s\\n"" , strerror ( errno ) ) ; return - 1 ; } break ; } if ( n < 20 ) { log_ppp_warn ( ""radius:packet:shortpackedreceived(%i)\\n"" , n ) ; goto out_err ; } pack -> code = * ptr ; ptr ++ ; pack -> id = * ptr ; ptr ++ ; pack -> len = ntohs ( * ( uint16_t * ) ptr ) ; ptr += 2 ; if ( pack -> len > n ) { log_ppp_warn ( ""radius:packet:shortpacketreceived%i,expected%i\\n"" , pack -> len , n ) ; goto out_err ; } ptr += 16 ; n -= 20 ; while ( n > 0 ) { id = * ptr ; ptr ++ ; len = * ptr - 2 ; ptr ++ ; if ( len < 0 ) { log_ppp_warn ( ""radius:packetshortattributelenreceived\\n"" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( ""radius:packet:toolongattributereceived(%i,%i)\\n"" , id , len ) ; goto out_err ; } if ( id == 26 ) { vendor_id = ntohl ( * ( uint32_t * ) ptr ) ; vendor = rad_dict_find_vendor_id ( vendor_id ) ; if ( vendor ) { ptr += 4 ; if ( vendor -> tag == 2 ) id = ( uint16_t ) ntohs ( * ( uint16_t * ) ptr ) ; else id = * ptr ; ptr += vendor -> tag ; if ( vendor -> len == 2 ) len = ( uint16_t ) ntohs ( * ( uint16_t * ) ptr ) ; else len = * ptr ; ptr += vendor -> len ; len -= vendor -> tag + vendor -> len ; n -= 4 + vendor -> tag + vendor -> len ;  } else  log_ppp_warn ( ""radius:packet:vendor%inotfound\\n"" , id ) ; } else vendor = NULL ; da = rad_dict_find_attr_id ( vendor , id ) ; if ( da ) { attr = mempool_alloc ( attr_pool ) ; if ( ! attr ) { log_emerg ( ""radius:packet:outofmemory\\n"" ) ; goto out_err ; } memset ( attr , 0 , sizeof ( * attr ) ) ; attr -> vendor = vendor ; attr -> attr = da ; attr -> len = len ; attr -> raw = ptr ; if ( ! da -> array ) { switch ( da -> type ) { case ATTR_TYPE_STRING : attr -> alloc = 1 ; attr -> val . string = _malloc ( len + 1 ) ; memcpy ( attr -> val . string , ptr , len ) ; attr -> val . string [ len ] = 0 ; break ; case ATTR_TYPE_OCTETS : case ATTR_TYPE_ETHER : case ATTR_TYPE_TLV : attr -> val . octets = ptr ; break ; case ATTR_TYPE_INTEGER : if ( len != da -> size ) log_ppp_warn ( ""radius:packet:attribute%shasinvalidlength%i(mustbe%i)\\n"" , da -> name , len , da -> size ) ; case ATTR_TYPE_DATE : if ( len == 4 ) attr -> val . integer = ntohl ( * ( uint32_t * ) ptr ) ; else if ( len == 2 ) attr -> val . integer = ntohs ( * ( uint16_t * ) ptr ) ; else if ( len == 1 ) attr -> val . integer = * ptr ; break ; case ATTR_TYPE_IPADDR : case ATTR_TYPE_IFID : case ATTR_TYPE_IPV6ADDR : memcpy ( & attr -> val . integer , ptr , len ) ; break ; case ATTR_TYPE_IPV6PREFIX : attr -> val . ipv6prefix . len = ptr [ 1 ] ; memset ( & attr -> val . ipv6prefix . prefix , 0 , sizeof ( attr -> val . ipv6prefix . prefix ) ) ; memcpy ( & attr -> val . ipv6prefix . prefix , ptr + 2 , len - 2 ) ; break ; } } list_add_tail ( & attr -> entry , & pack -> attrs ) ; } else log_ppp_warn ( ""radius:packet:unknownattributereceived(%i,%i)\\n"" , vendor ? vendor -> id : 0 , id ) ; ptr += len ; n -= 2 + len ; } * p = pack ; return 0 ; out_err : rad_packet_free ( pack ) ; return 1 ; }"," -> len ; if ( len < 0 ) { log_ppp_warn ( ""radius:packetinvalidvendorattributelenreceived\\n"" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( ""radius:packet:toolongvendorattributereceived(%i,%i)\\n"" , id , len ) ; goto out_err ; }"
718,"CWE-000 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( ""cmd%xarg%p"" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ;  }  err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }", err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
719,"CWE-20 static int unix_dgram_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( iocb ) ; struct scm_cookie tmp_scm ; struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; struct sk_buff * skb ; int err ; int peeked , skip ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB )  goto out ;  msg -> msg_namelen = 0 ; err = mutex_lock_interruptible ( & u -> readlock ) ; if ( err ) { err = sock_intr_errno ( sock_rcvtimeo ( sk , noblock ) ) ; goto out ; } skip = sk_peek_offset ( sk , flags ) ; skb = __skb_recv_datagram ( sk , flags , & peeked , & skip , & err ) ; if ( ! skb ) { unix_state_lock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && err == - EAGAIN && ( sk -> sk_shutdown & RCV_SHUTDOWN ) ) err = 0 ; unix_state_unlock ( sk ) ; goto out_unlock ; } wake_up_interruptible_sync_poll ( & u -> peer_wait , POLLOUT | POLLWRNORM | POLLWRBAND ) ; if ( msg -> msg_name ) unix_copy_addr ( msg , skb -> sk ) ; if ( size > skb -> len - skip ) size = skb -> len - skip ; else if ( size < skb -> len - skip ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , skip , msg -> msg_iov , size ) ; if ( err ) goto out_free ; if ( sock_flag ( sk , SOCK_RCVTSTAMP ) ) __sock_recv_timestamp ( msg , sk , skb ) ; if ( ! siocb -> scm ) { siocb -> scm = & tmp_scm ; memset ( & tmp_scm , 0 , sizeof ( tmp_scm ) ) ; } scm_set_cred ( siocb -> scm , UNIXCB ( skb ) . pid , UNIXCB ( skb ) . uid , UNIXCB ( skb ) . gid ) ; unix_set_secdata ( siocb -> scm , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { if ( UNIXCB ( skb ) . fp ) unix_detach_fds ( siocb -> scm , skb ) ; sk_peek_offset_bwd ( sk , skb -> len ) ; } else { sk_peek_offset_fwd ( sk , size ) ; if ( UNIXCB ( skb ) . fp ) siocb -> scm -> fp = scm_fp_dup ( UNIXCB ( skb ) . fp ) ; } err = ( flags & MSG_TRUNC ) ? skb -> len - skip : size ; scm_recv ( sock , msg , siocb -> scm , flags ) ; out_free : skb_free_datagram ( sk , skb ) ; out_unlock : mutex_unlock ( & u -> readlock ) ; out : return err ; }", ) goto out  ; err =
720,CWE-000 struct bpf_prog * bpf_prog_get ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_prog * prog ; prog = __bpf_prog_get ( f ) ; if ( IS_ERR ( prog ) ) return prog ;  atomic_inc ( & prog -> aux -> refcnt ) ;  fdput ( f ) ; return prog ; }, return prog ; prog = bpf_prog_inc ( prog  ) ; fdput
721,"CWE-416 static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ;  if ( len < tcp_hdrlen )  return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknownorinvalidpath-MTU(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ;  if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {  if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }", len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr )  ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
722,"CWE-416 static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) {  up_read ( & card -> controls_rwsem ) ;  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE ,  & control -> id ) ;  return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }"," 0 ) { struct snd_ctl_elem_id id = control -> id ;  , SNDRV_CTL_EVENT_MASK_VALUE , &  id ) ;"
723,"CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) {  memmove ( s + j , s + qs , blen - qs ) ;   j += blen - qs ;  } buffer_string_set_length ( b , j ) ; return qs ; }"," 0 ) { const int qslen = blen - qs ;  + qs , ( size_t ) qslen ) ; qs = j  ; j +=  ; j += qslen  ; } buffer_string_set_length"
724,"CWE-400 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , ""Foundconstantoftype%swherebooleanwasexpected\\n"" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , ""true"" ) || istreq ( ident , ""yes"" ) || istreq ( ident , ""on"" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , ""false"" ) || istreq ( ident , ""no"" ) || istreq ( ident , ""off"" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , ""Identifier\\""%s\\""oftypebooleanisunknown\\n"" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , ""Default\\""%s.%s\\""oftypebooleanisunknown\\n"" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT :  ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;  if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , ""%sofbooleanvaluesnotpermitted\\n"" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , ""Unknownoperator%dinResolveBoolean\\n"" , expr -> expr . op ) ; break ; } return false ; }"," ctx , expr -> unary . child"
725,"CWE-416 static zend_always_inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , zend_long elements , int objprops ) { while ( elements -- > 0 ) { zval key , * data , d , * old_data ; zend_ulong idx ; ZVAL_UNDEF ( & key ) ; if ( ! php_var_unserialize_internal ( & key , p , max , NULL , classes ) ) { zval_dtor ( & key ) ; return 0 ; } data = NULL ; ZVAL_UNDEF ( & d ) ; if ( ! objprops ) { if ( Z_TYPE ( key ) == IS_LONG ) { idx = Z_LVAL ( key ) ; numeric_key : if ( UNEXPECTED ( ( old_data = zend_hash_index_find ( ht , idx ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_index_update ( ht , idx , & d ) ; } else { data = zend_hash_index_add_new ( ht , idx , & d ) ; } } else if ( Z_TYPE ( key ) == IS_STRING ) { if ( UNEXPECTED ( ZEND_HANDLE_NUMERIC ( Z_STR ( key ) , idx ) ) ) { goto numeric_key ; } if ( UNEXPECTED ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else { zval_dtor ( & key ) ; return 0 ; } } else { if ( EXPECTED ( Z_TYPE ( key ) == IS_STRING ) ) { string_key : if ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) { if ( Z_TYPE_P ( old_data ) == IS_INDIRECT ) { old_data = Z_INDIRECT_P ( old_data ) ; } var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update_ind ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else if ( Z_TYPE ( key ) == IS_LONG ) { convert_to_string ( & key ) ; goto string_key ; } else { zval_dtor ( & key ) ; return 0 ; } } if ( ! php_var_unserialize_internal ( data , p , max , var_hash , classes ) ) { zval_dtor ( & key ) ; return 0 ; }  if ( UNEXPECTED ( Z_ISUNDEF_P ( data ) ) ) {  if ( Z_TYPE ( key ) == IS_LONG ) { zend_hash_index_del ( ht , Z_LVAL ( key ) ) ; } else { zend_hash_del_ind ( ht , Z_STR ( key ) ) ; } } else { var_push_dtor ( var_hash , data ) ;  }  zval_dtor ( & key ) ; if ( elements && * ( * p - 1 ) != ';' && * ( * p - 1 ) != '}' ) { ( * p ) -- ; return 0 ; } } return 1 ; }", 0 ; }  var_push_dtor ( var_hash  data ) ;  zval_dtor ( &
726,"CWE-404 int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> process_keyring )  return - EEXIST ;  keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> process_keyring = keyring ; return 0 ; }", process_keyring ) return 0  ; keyring =
727,"CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ;  memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;  state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }", 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
728,"CWE-119  void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride ,  int eob ) { if ( eob == 1 )  vp9_idct32x32_1_add ( input , dest , stride ) ;  else if ( eob <= 34 )  vp9_idct32x32_34_add ( input , dest , stride ) ;  else  vp9_idct32x32_1024_add ( input , dest , stride ) ;  }"," vp9_idct32x32_add ( const tran_low_t  * input ,  == 1 ) vpx_idct32x32_1_add  ( input ,  <= 34 ) vpx_idct32x32_34_add  ( input ,  ) ; else vpx_idct32x32_1024_add  ( input ,"
729,"CWE-264  static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst )  {  switch ( ctxt -> op_bytes ) {  case 2 : ctxt -> _eip = ( u16 ) dst ; break ; case 4 : ctxt -> _eip = ( u32 ) dst ; break ; case 8 : ctxt -> _eip = dst ; break ; default : WARN ( 1 , ""unsupportedeipassignmentsize\\n"" ) ; }  } ","  static inline int  assign_eip_near ( struct  dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64  ) ; }  ) ; }    "
730,"CWE-476 smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } if ( sr -> smb_fid != 0xffff ) { smbsr_lookup_file ( sr ) ; if ( sr -> fid_ofile == NULL ) { smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; }  smb_flush_file ( sr , sr -> fid_ofile ) ;  } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ;  smb_flush_file ( sr , file ) ;  mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }"," ) ; } smb_ofile_flush  ( sr ,  f_mutex ) ; smb_ofile_flush  ( sr ,"
731,"CWE-200  static void print_bpf_insn ( struct bpf_insn * insn )  { u8 class = BPF_CLASS ( insn -> code ) ; if ( class == BPF_ALU || class == BPF_ALU64 ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) verbose ( ""(%02x)%sr%d%s%sr%d\\n"" , insn -> code , class == BPF_ALU ? ""(u32)"" : """" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? ""(u32)"" : """" , insn -> src_reg ) ; else verbose ( ""(%02x)%sr%d%s%s%d\\n"" , insn -> code , class == BPF_ALU ? ""(u32)"" : """" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? ""(u32)"" : """" , insn -> imm ) ; } else if ( class == BPF_STX ) { if ( BPF_MODE ( insn -> code ) == BPF_MEM ) verbose ( ""(%02x)*(%s*)(r%d%+d)=r%d\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) verbose ( ""(%02x)lock*(%s*)(r%d%+d)+=r%d\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else verbose ( ""BUG_%02x\\n"" , insn -> code ) ; } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( ""BUG_st_%02x\\n"" , insn -> code ) ; return ; } verbose ( ""(%02x)*(%s*)(r%d%+d)=%d\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> imm ) ; } else if ( class == BPF_LDX ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( ""BUG_ldx_%02x\\n"" , insn -> code ) ; return ; } verbose ( ""(%02x)r%d=*(%s*)(r%d%+d)\\n"" , insn -> code , insn -> dst_reg , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> off ) ; } else if ( class == BPF_LD ) { if ( BPF_MODE ( insn -> code ) == BPF_ABS ) { verbose ( ""(%02x)r0=*(%s*)skb[%d]\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> imm ) ; } else if ( BPF_MODE ( insn -> code ) == BPF_IND ) { verbose ( ""(%02x)r0=*(%s*)skb[r%d+%d]\\n"" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> imm ) ;  } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) {  verbose ( ""(%02x)r%d=0x%x\\n"" ,  insn -> code , insn -> dst_reg , insn -> imm ) ;  } else { verbose ( ""BUG_ld_%02x\\n"" , insn -> code ) ; return ; } } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { verbose ( ""(%02x)call%s#%d\\n"" , insn -> code , func_id_name ( insn -> imm ) , insn -> imm ) ; } else if ( insn -> code == ( BPF_JMP | BPF_JA ) ) { verbose ( ""(%02x)gotopc%+d\\n"" , insn -> code , insn -> off ) ; } else if ( insn -> code == ( BPF_JMP | BPF_EXIT ) ) { verbose ( ""(%02x)exit\\n"" , insn -> code ) ; } else if ( BPF_SRC ( insn -> code ) == BPF_X ) { verbose ( ""(%02x)ifr%d%sr%dgotopc%+d\\n"" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> src_reg , insn -> off ) ; } else { verbose ( ""(%02x)ifr%d%s0x%xgotopc%+d\\n"" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> imm , insn -> off ) ; } } else { verbose ( ""(%02x)%s\\n"" , insn -> code , bpf_class_string [ class ] ) ; } }"," void print_bpf_insn ( const struct bpf_verifier_env * env , const  ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( ""(%02x)r%d=0x%llx\\n"" , insn -> code ,  insn -> dst_reg  -> dst_reg , ( unsigned long long )  imm ) ;"
732,"CWE-000 static int irda_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct irda_sock * self ;  if ( net != & init_net )  return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_STREAM : case SOCK_SEQPACKET : case SOCK_DGRAM : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_IRDA , GFP_KERNEL , & irda_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; self = irda_sk ( sk ) ; pr_debug ( ""%s():selfis%p\\n"" , __func__ , self ) ; init_waitqueue_head ( & self -> query_wait ) ; switch ( sock -> type ) { case SOCK_STREAM : sock -> ops = & irda_stream_ops ; self -> max_sdu_size_rx = TTP_SAR_DISABLE ; break ; case SOCK_SEQPACKET : sock -> ops = & irda_seqpacket_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; case SOCK_DGRAM : switch ( protocol ) { # ifdef CONFIG_IRDA_ULTRA case IRDAPROTO_ULTRA : sock -> ops = & irda_ultra_ops ; self -> max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER ; self -> max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER ; break ; # endif case IRDAPROTO_UNITDATA : sock -> ops = & irda_dgram_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } sock_init_data ( sock , sk ) ; sk -> sk_family = PF_IRDA ; sk -> sk_protocol = protocol ; self -> ckey = irlmp_register_client ( 0 , NULL , NULL , NULL ) ; self -> mask . word = 0xffff ; self -> rx_flow = self -> tx_flow = FLOW_START ; self -> nslots = DISCOVERY_DEFAULT_SLOTS ; self -> daddr = DEV_ADDR_ANY ; self -> saddr = 0x0 ; return 0 ; }", ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
733,"CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ;  uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ;  uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFFscanlinesizeiszero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip%d:read%lubytes,stripsize%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Errorreadingstrip%luafter%lurows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }"," = 0 ; uint32  strip , nstrips"
734,"CWE-787 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ;  s = tcp_recv ( NULL , 4 ) ;  if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , ""cssp_read_tsrequest(),expectedBER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,got%x"" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ;  if ( ! ber_in_header ( s , & tagval , & length ) ||  tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;  in_uint8s ( s , length ) ;  if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ;  token -> end = token -> p = token -> data ;  out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }"," int tagval ; struct stream packet ;  length ) ; packet = * s ;  return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),consumeofversionfromstreamwouldoverrun"" , & packet ) ; }  return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),consumeoftokenfromstreamwouldoverrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token )  ; out_uint8p ("
735,"CWE-284 int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ;  addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;  addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }", = htonl ( INADDR_LOOPBACK  ) ; addr
736,"CWE-772 int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = NULL ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , GFP_KERNEL ) ; if ( bo == NULL ) return - ENOMEM ; size = roundup ( size , PAGE_SIZE ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 )  return ret ;  bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , NULL , acc_size , NULL , NULL , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }", != 0 ) { kfree ( bo ) ; return ret ; }  bo -> dumb
737,"CWE-264 int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ;  char * fpath = NULL , * path1 , * cgdir = NULL , * controller ;  const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = ""/"" ; else path1 = cgdir ;  if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {   ret = - EACCES ;  goto out ; }  if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {  ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( ""cgfs_createreturned%dfor%s%s\\n"" , ret , controller , cgroup ) ; out : free ( cgdir ) ;  return ret ;  }"," , * controller , * next = NULL  if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next  ) ) {  ) ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT  ; goto out  if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( !  cgdir ) ; free ( next ) ;"
738,"CWE-20 error_t nicSendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { error_t error ;  bool_t status ;  netContext . entropy += netGetSystemTickCount ( ) ;  # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG )  size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( ""Sendingpacket(%"" PRIuSIZE ""bytes)...\\r\\n"" , length ) ; TRACE_DEBUG_NET_BUFFER ( """" , buffer , offset , length ) ; # endif if ( interface -> configured && interface -> nicDriver != NULL ) { if ( interface -> nicDriver -> type == NIC_TYPE_LOOPBACK ) { status = TRUE ; } else { status = osWaitForEvent ( & interface -> nicTxEvent , NIC_MAX_BLOCKING_TIME ) ; } if ( status ) { interface -> nicDriver -> disableIrq ( interface ) ; error = interface -> nicDriver -> sendPacket ( interface , buffer , offset , ancillary ) ; if ( interface -> configured ) { interface -> nicDriver -> enableIrq ( interface ) ; } } else { error = NO_ERROR ; } } else { error = ERROR_INVALID_INTERFACE ; } return error ; }"," bool_t status ; # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( ""Sendingpacket(%"" PRIuSIZE ""bytes)...\\r\\n"" , length ) ; TRACE_DEBUG_NET_BUFFER ( """" , buffer , offset , length ) ; # endif  ( ) ;  if ( interface"
739,"CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , ""enteringCDROM_DRIVE_STATUS\\n"" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ;  if ( ( ( int ) arg >= cdi -> capacity ) )  return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }", ; if (  arg >= cdi  cdi -> capacity  ) return -
740,CWE-264 static unsigned long randomize_stack_top ( unsigned long stack_top ) {  unsigned int random_variable = 0 ;  if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {  random_variable = get_random_int ( ) & STACK_RND_MASK ;  random_variable <<= PAGE_SHIFT ; } # ifdef CONFIG_STACK_GROWSUP return PAGE_ALIGN ( stack_top ) + random_variable ; # else return PAGE_ALIGN ( stack_top ) - random_variable ; # endif }, ) { unsigned long  random_variable = 0  { random_variable = ( unsigned long )  get_random_int ( ) ; random_variable &=  STACK_RND_MASK ; random_variable
741,"CWE-119 static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ;  SCSIDiskReq * r ;  req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;  r = DO_UPCAST ( SCSIDiskReq , req , req ) ;  r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }", * req ;  req = scsi_req_alloc  hba_private ) ;  return req ;
742,"CWE-119 void configSetCommand ( client * c ) { robj * o ; long long ll ; int err ; serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; o = c -> argv [ 3 ] ; if ( 0 ) { config_set_special_field ( ""dbfilename"" ) { if ( ! pathIsBaseName ( o -> ptr ) ) { addReplyError ( c , ""dbfilenamecan\'tbeapath,justafilename"" ) ; return ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( o -> ptr ) ; } config_set_special_field ( ""requirepass"" ) { if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; zfree ( server . requirepass ) ; server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""masterauth"" ) { zfree ( server . masterauth ) ; server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""cluster-announce-ip"" ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""maxclients"" ) { int orig_value = server . maxclients ; if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ; server . maxclients = ll ; if ( ll > orig_value ) { adjustOpenFilesLimit ( ) ; if ( server . maxclients != ll ) { addReplyErrorFormat ( c , ""Theoperatingsystemisnotabletohandlethespecifiednumberofclients,trywith%d"" , server . maxclients ) ; server . maxclients = orig_value ; return ; } if ( ( unsigned int ) aeGetSetSize ( server . el ) < server . maxclients + CONFIG_FDSET_INCR ) { if ( aeResizeSetSize ( server . el , server . maxclients + CONFIG_FDSET_INCR ) == AE_ERR ) { addReplyError ( c , ""TheeventloopAPIusedbyRedisisnotabletohandlethespecifiednumberofclients"" ) ; server . maxclients = orig_value ; return ; } } } } config_set_special_field ( ""appendonly"" ) { int enable = yesnotoi ( o -> ptr ) ; if ( enable == - 1 ) goto badfmt ; if ( enable == 0 && server . aof_state != AOF_OFF ) { stopAppendOnly ( ) ; } else if ( enable && server . aof_state == AOF_OFF ) { if ( startAppendOnly ( ) == C_ERR ) { addReplyError ( c , ""UnabletoturnonAOF.Checkserverlogs."" ) ; return ; } } } config_set_special_field ( ""save"" ) { int vlen , j ; sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , """" , 1 , & vlen ) ; if ( vlen & 1 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } for ( j = 0 ; j < vlen ; j ++ ) { char * eptr ; long val ; val = strtoll ( v [ j ] , & eptr , 10 ) ; if ( eptr [ 0 ] != '\\0' || ( ( j & 1 ) == 0 && val < 1 ) || ( ( j & 1 ) == 1 && val < 0 ) ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } resetServerSaveParams ( ) ; for ( j = 0 ; j < vlen ; j += 2 ) { time_t seconds ; int changes ; seconds = strtoll ( v [ j ] , NULL , 10 ) ; changes = strtoll ( v [ j + 1 ] , NULL , 10 ) ; appendServerSaveParams ( seconds , changes ) ; } sdsfreesplitres ( v , vlen ) ; } config_set_special_field ( ""dir"" ) { if ( chdir ( ( char * ) o -> ptr ) == - 1 ) { addReplyErrorFormat ( c , ""Changingdirectory:%s"" , strerror ( errno ) ) ; return ; } } config_set_special_field ( ""client-output-buffer-limit"" ) { int vlen , j ; sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , """" , 1 , & vlen ) ; if ( vlen % 4 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } for ( j = 0 ; j < vlen ; j ++ ) { long val ; if ( ( j % 4 ) == 0 ) {  if ( getClientTypeByName ( v [ j ] ) == - 1 ) {  sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } else { val = memtoll ( v [ j ] , & err ) ; if ( err || val < 0 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } } for ( j = 0 ; j < vlen ; j += 4 ) { int class ; unsigned long long hard , soft ; int soft_seconds ; class = getClientTypeByName ( v [ j ] ) ; hard = strtoll ( v [ j + 1 ] , NULL , 10 ) ; soft = strtoll ( v [ j + 2 ] , NULL , 10 ) ; soft_seconds = strtoll ( v [ j + 3 ] , NULL , 10 ) ; server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; } sdsfreesplitres ( v , vlen ) ; } config_set_special_field ( ""notify-keyspace-events"" ) { int flags = keyspaceEventsStringToFlags ( o -> ptr ) ; if ( flags == - 1 ) goto badfmt ; server . notify_keyspace_events = flags ; } config_set_special_field ( ""slave-announce-ip"" ) { zfree ( server . slave_announce_ip ) ; server . slave_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_bool_field ( ""rdbcompression"" , server . rdb_compression ) { } config_set_bool_field ( ""repl-disable-tcp-nodelay"" , server . repl_disable_tcp_nodelay ) { } config_set_bool_field ( ""repl-diskless-sync"" , server . repl_diskless_sync ) { } config_set_bool_field ( ""cluster-require-full-coverage"" , server . cluster_require_full_coverage ) { } config_set_bool_field ( ""aof-rewrite-incremental-fsync"" , server . aof_rewrite_incremental_fsync ) { } config_set_bool_field ( ""aof-load-truncated"" , server . aof_load_truncated ) { } config_set_bool_field ( ""aof-use-rdb-preamble"" , server . aof_use_rdb_preamble ) { } config_set_bool_field ( ""slave-serve-stale-data"" , server . repl_serve_stale_data ) { } config_set_bool_field ( ""slave-read-only"" , server . repl_slave_ro ) { } config_set_bool_field ( ""activerehashing"" , server . activerehashing ) { } config_set_bool_field ( ""protected-mode"" , server . protected_mode ) { } config_set_bool_field ( ""stop-writes-on-bgsave-error"" , server . stop_writes_on_bgsave_err ) { } config_set_bool_field ( ""lazyfree-lazy-eviction"" , server . lazyfree_lazy_eviction ) { } config_set_bool_field ( ""lazyfree-lazy-expire"" , server . lazyfree_lazy_expire ) { } config_set_bool_field ( ""lazyfree-lazy-server-del"" , server . lazyfree_lazy_server_del ) { } config_set_bool_field ( ""slave-lazy-flush"" , server . repl_slave_lazy_flush ) { } config_set_bool_field ( ""no-appendfsync-on-rewrite"" , server . aof_no_fsync_on_rewrite ) { } config_set_numerical_field ( ""tcp-keepalive"" , server . tcpkeepalive , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""maxmemory-samples"" , server . maxmemory_samples , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""lfu-log-factor"" , server . lfu_log_factor , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""lfu-decay-time"" , server . lfu_decay_time , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""timeout"" , server . maxidletime , 0 , LONG_MAX ) { } config_set_numerical_field ( ""auto-aof-rewrite-percentage"" , server . aof_rewrite_perc , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""auto-aof-rewrite-min-size"" , server . aof_rewrite_min_size , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hash-max-ziplist-entries"" , server . hash_max_ziplist_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hash-max-ziplist-value"" , server . hash_max_ziplist_value , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""list-max-ziplist-size"" , server . list_max_ziplist_size , INT_MIN , INT_MAX ) { } config_set_numerical_field ( ""list-compress-depth"" , server . list_compress_depth , 0 , INT_MAX ) { } config_set_numerical_field ( ""set-max-intset-entries"" , server . set_max_intset_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""zset-max-ziplist-entries"" , server . zset_max_ziplist_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""zset-max-ziplist-value"" , server . zset_max_ziplist_value , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hll-sparse-max-bytes"" , server . hll_sparse_max_bytes , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""lua-time-limit"" , server . lua_time_limit , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slowlog-log-slower-than"" , server . slowlog_log_slower_than , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slowlog-max-len"" , ll , 0 , LLONG_MAX ) { server . slowlog_max_len = ( unsigned ) ll ; } config_set_numerical_field ( ""latency-monitor-threshold"" , server . latency_monitor_threshold , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-ping-slave-period"" , server . repl_ping_slave_period , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-timeout"" , server . repl_timeout , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-backlog-ttl"" , server . repl_backlog_time_limit , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-diskless-sync-delay"" , server . repl_diskless_sync_delay , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slave-priority"" , server . slave_priority , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slave-announce-port"" , server . slave_announce_port , 0 , 65535 ) { } config_set_numerical_field ( ""min-slaves-to-write"" , server . repl_min_slaves_to_write , 0 , LLONG_MAX ) { refreshGoodSlavesCount ( ) ; } config_set_numerical_field ( ""min-slaves-max-lag"" , server . repl_min_slaves_max_lag , 0 , LLONG_MAX ) { refreshGoodSlavesCount ( ) ; } config_set_numerical_field ( ""cluster-node-timeout"" , server . cluster_node_timeout , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""cluster-announce-port"" , server . cluster_announce_port , 0 , 65535 ) { } config_set_numerical_field ( ""cluster-announce-bus-port"" , server . cluster_announce_bus_port , 0 , 65535 ) { } config_set_numerical_field ( ""cluster-migration-barrier"" , server . cluster_migration_barrier , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""cluster-slave-validity-factor"" , server . cluster_slave_validity_factor , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hz"" , server . hz , 0 , LLONG_MAX ) { if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; } config_set_numerical_field ( ""watchdog-period"" , ll , 0 , LLONG_MAX ) { if ( ll ) enableWatchdog ( ll ) ; else disableWatchdog ( ) ; } config_set_memory_field ( ""maxmemory"" , server . maxmemory ) { if ( server . maxmemory ) { if ( server . maxmemory < zmalloc_used_memory ( ) ) { serverLog ( LL_WARNING , ""WARNING:thenewmaxmemoryvaluesetviaCONFIGSETissmallerthanthecurrentmemoryusage.Thiswillresultinkeysevictionand/orinabilitytoacceptnewwritecommandsdependingonthemaxmemory-policy."" ) ; } freeMemoryIfNeeded ( ) ; } } config_set_memory_field ( ""repl-backlog-size"" , ll ) { resizeReplicationBacklog ( ll ) ; } config_set_enum_field ( ""loglevel"" , server . verbosity , loglevel_enum ) { } config_set_enum_field ( ""maxmemory-policy"" , server . maxmemory_policy , maxmemory_policy_enum ) { } config_set_enum_field ( ""appendfsync"" , server . aof_fsync , aof_fsync_enum ) { } config_set_else { addReplyErrorFormat ( c , ""UnsupportedCONFIGparameter:%s"" , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } addReply ( c , shared . ok ) ; return ; badfmt : addReplyErrorFormat ( c , ""Invalidargument\'%s\'forCONFIGSET\'%s\'"" , ( char * ) o -> ptr , ( char * ) c -> argv [ 2 ] -> ptr ) ; }", 0 ) { int class =  getClientTypeByName ( v  j ] ) ; if ( class  == - 1 || class == CLIENT_TYPE_MASTER
743,"CWE-284 int btsock_thread_wakeup ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalidbtthreadhandle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""threadhandle:%d,cmdsocketisnotcreated"" , h ) ; return FALSE ; } sock_cmd_t cmd = { CMD_WAKEUP , 0 , 0 , 0 , 0 } ;  return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ;  }"," } ; return TEMP_FAILURE_RETRY (  , 0 ) )"
744,"CWE-264 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( ""%s:metadataisnull!"" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = ""camera_metadata"" , . alignment = METADATA_ALIGNMENT } , { . name = ""camera_metadata_buffer_entry"" , . alignment = ENTRY_ALIGNMENT } , { . name = ""camera_metadata_data"" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( ""%s:Metadatapointerisnotaligned(actual%p,"" ""expected%p)totype%s"" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( ""%s:Metadatasize(%"" PRIu32 "")shouldbe<=expectedsize(%zu)"" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( ""%s:Entrycount(%"" PRIu32 "")shouldbe<=entrycapacity"" ""(%"" PRIu32 "")"" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; }  const metadata_uptrdiff_t entries_end =  metadata -> entries_start + metadata -> entry_capacity ; if ( entries_end < metadata -> entries_start || entries_end > metadata -> data_start ) { ALOGE ( ""%s:Entrystart+capacity(%"" PRIu32 "")shouldbe<=datastart"" ""(%"" PRIu32 "")"" , __FUNCTION__ , ( metadata -> entries_start + metadata -> entry_capacity ) , metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = metadata -> data_start + metadata -> data_capacity ; if ( data_end < metadata -> data_start || data_end > metadata -> size ) { ALOGE ( ""%s:Datastart+capacity(%"" PRIu32 "")shouldbe<=totalsize"" ""(%"" PRIu32 "")"" , __FUNCTION__ , ( metadata -> data_start + metadata -> data_capacity ) , metadata -> size ) ; return ERROR ; } const metadata_size_t entry_count = metadata -> entry_count ; camera_metadata_buffer_entry_t * entries = get_entries ( metadata ) ; for ( size_t i = 0 ; i < entry_count ; ++ i ) { if ( ( uintptr_t ) & entries [ i ] != ALIGN_TO ( & entries [ i ] , ENTRY_ALIGNMENT ) ) { ALOGE ( ""%s:Entryindex%zuhadbadalignment(address%p),"" ""expectedalignment%zu"" , __FUNCTION__ , i , & entries [ i ] , ENTRY_ALIGNMENT ) ; return ERROR ; } camera_metadata_buffer_entry_t entry = entries [ i ] ; if ( entry . type >= NUM_TYPES ) { ALOGE ( ""%s:Entryindex%zuhadabadtype%d"" , __FUNCTION__ , i , entry . type ) ; return ERROR ; } uint32_t tag_section = entry . tag >> 16 ; int tag_type = get_camera_metadata_tag_type ( entry . tag ) ; if ( tag_type != ( int ) entry . type && tag_section < VENDOR_SECTION ) { ALOGE ( ""%s:Entryindex%zuhadtagtype%d,butthetypewas%d"" , __FUNCTION__ , i , tag_type , entry . type ) ; return ERROR ; } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , entry . type , entry . count ) != OK ) { ALOGE ( ""%s:Entrydatasizeisinvalid.type:%ucount:%u"" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } if ( data_size != 0 ) { camera_metadata_data_t * data = ( camera_metadata_data_t * ) ( get_data ( metadata ) + entry . data . offset ) ; if ( ( uintptr_t ) data != ALIGN_TO ( data , DATA_ALIGNMENT ) ) { ALOGE ( ""%s:Entryindex%zuhadbaddataalignment(address%p),"" ""expectedalign%zu,(tagname%s,datasize%zu)"" , __FUNCTION__ , i , data , DATA_ALIGNMENT , get_camera_metadata_tag_name ( entry . tag ) ? : ""unknown"" , data_size ) ; return ERROR ; } size_t data_entry_end = entry . data . offset + data_size ; if ( data_entry_end < entry . data . offset || data_entry_end > metadata -> data_capacity ) { ALOGE ( ""%s:Entryindex%zudataends(%zu)beyondthecapacity"" ""%"" PRIu32 , __FUNCTION__ , i , data_entry_end , metadata -> data_capacity ) ; return ERROR ; } } else if ( entry . count == 0 ) { if ( entry . data . offset != 0 ) { ALOGE ( ""%s:Entryindex%zuhad0items,butoffsetwasnon-0"" ""(%"" PRIu32 ""),tagname:%s"" , __FUNCTION__ , i , entry . data . offset , get_camera_metadata_tag_name ( entry . tag ) ? : ""unknown"" ) ; return ERROR ; } } } return OK ; }"," ERROR ; } if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( ""%s:Datacount(%"" PRIu32 "")shouldbe<=datacapacity"" ""(%"" PRIu32 "")"" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , ""30591838"" ) ; return ERROR ; }"
745,"CWE-119 static void videobuf_vm_close ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; struct videobuf_queue * q = map -> q ; int i ;  dprintk ( 2 , ""vm_close%p[count=%d,vma=%08lx-%08lx]\\n"" , map ,  map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count -- ; if ( 0 == map -> count ) { dprintk ( 1 , ""munmap%pq=%p\\n"" , map , q ) ; mutex_lock ( & q -> lock ) ; for ( i = 0 ; i < VIDEO_MAX_FRAME ; i ++ ) { if ( NULL == q -> bufs [ i ] ) continue ; if ( q -> bufs [ i ] -> map != map ) continue ; q -> ops -> buf_release ( q , q -> bufs [ i ] ) ; q -> bufs [ i ] -> map = NULL ; q -> bufs [ i ] -> baddr = 0 ; } mutex_unlock ( & q -> lock ) ; kfree ( map ) ; } return ; }"," ( 2 , ""vm_close%p[count=%u,vma=%08lx-%08lx]\\n""  , map ,"
746,"CWE-119 static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) {  const uint32_t c_w =  ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ; uint32_t i ; int match = 1 ; match &= ( img1 -> fmt == img2 -> fmt ) ; match &= ( img1 -> d_w == img2 -> d_w ) ; match &= ( img1 -> d_h == img2 -> d_h ) ;  for ( i = 0 ; i < img1 -> d_h ; ++ i )  match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] ,  img1 -> d_w ) == 0 ) ;  for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride [ VPX_PLANE_V ] , c_w ) == 0 ) ; return match ; }"," img2 ) { uint32_t l_w = img1 -> d_w ;  uint32_t c_w =  d_h ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif  VPX_PLANE_Y ] , l_w  ) == 0"
747,"CWE-189 static int sysMapBlockFile ( FILE * mapf , MemMapping * pMap ) { char block_dev [ PATH_MAX + 1 ] ; size_t size ; unsigned int blksize ;  unsigned int blocks ;  unsigned int range_count ; unsigned int i ; if ( fgets ( block_dev , sizeof ( block_dev ) , mapf ) == NULL ) { LOGW ( ""failedtoreadblockdevicefromheader\\n"" ) ; return - 1 ; } for ( i = 0 ; i < sizeof ( block_dev ) ; ++ i ) { if ( block_dev [ i ] == '\\n' ) { block_dev [ i ] = 0 ; break ; } } if ( fscanf ( mapf , ""%zu%u\\n%u\\n"" , & size , & blksize , & range_count ) != 3 ) { LOGW ( ""failedtoparseblockmapheader\\n"" ) ; return - 1 ; }  blocks = ( ( size - 1 ) / blksize ) + 1 ;   pMap -> range_count = range_count ;   pMap -> ranges = malloc ( range_count * sizeof ( MappedRange ) ) ;   memset ( pMap -> ranges , 0 , range_count * sizeof ( MappedRange ) ) ;  unsigned char * reserve ; reserve = mmap64 ( NULL , blocks * blksize , PROT_NONE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; if ( reserve == MAP_FAILED ) { LOGW ( ""failedtoreserveaddressspace:%s\\n"" , strerror ( errno ) ) ;  return - 1 ;  }  pMap -> ranges [ range_count - 1 ] . addr = reserve ;   pMap -> ranges [ range_count - 1 ] . length = blocks * blksize ;  int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( ""failedtoopenblockdevice%s:%s\\n"" , block_dev , strerror ( errno ) ) ; return - 1 ; } unsigned char * next = reserve ; for ( i = 0 ; i < range_count ; ++ i ) { int start , end ; if ( fscanf ( mapf , ""%d%d\\n"" , & start , & end ) != 2 ) { LOGW ( ""failedtoparserange%dinblockmap\\n"" , i ) ; return - 1 ; } void * addr = mmap64 ( next , ( end - start ) * blksize , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( ""failedtomapblock%d:%s\\n"" , i , strerror ( errno ) ) ; return - 1 ; } pMap -> ranges [ i ] . addr = addr ; pMap -> ranges [ i ] . length = ( end - start ) * blksize ;  next += pMap -> ranges [ i ] . length ;  } pMap -> addr = reserve ; pMap -> length = size ; LOGI ( ""mmapped%dranges\\n"" , range_count ) ; return 0 ; }"," int blksize ; size_t  blocks ; unsigned  1 ; } if ( blksize != 0 ) {  + 1 ; } if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { LOGE ( ""invaliddatainblockmapfile:size%zu,blksize%u,range_count%u\\n"" , size , blksize , range_count ) ; return - 1 ; }  -> ranges = calloc ( range_count ,  sizeof ( MappedRange  ) ) ; if  ( pMap ->  pMap -> ranges == NULL ) { LOGE ( ""calloc(%u,%zu)failed:%s\\n"" , range_count ,  sizeof ( MappedRange  ( MappedRange ) , strerror ( errno ) ) ; return - 1 ; }  unsigned char *  ) ) ; free ( pMap -> ranges ) ;  return - 1 ; } int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( ""failedtoopenblockdevice%s:%s\\n"" , block_dev , strerror ( errno ) ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } unsigned char * next = reserve ; size_t remaining_size = blocks * blksize ; bool success = true ; for ( i = 0 ; i < range_count ; ++ i ) { size_t start , end ; if ( fscanf ( mapf , ""%zu%zu\\n"" , & start , & end ) != 2 ) { LOGW ( ""failedtoparserange%dinblockmap\\n"" , i ) ; success = false ; break ; } size_t length = ( end - start ) * blksize ; if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { LOGE ( ""unexpectedrangeinblockmap:%zu%zu\\n"" , start , end ) ; success = false ; break ; } void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( ""failedtomapblock%d:%s\\n"" , i , strerror ( errno ) ) ; success = false ; break  -> ranges [ i  ] . addr  . addr = addr  ; pMap ->  -> ranges [ i  ] . length  . length = length  ; next +=  ; next += length ; remaining_size -= length ; } if ( success && remaining_size != 0 ) { LOGE ( ""rangesinblockmapareinvalid:remaining_size=%zu\\n"" , remaining_size ) ; success = false ; } if ( ! success ) { close ( fd ) ; munmap ( reserve , blocks * blksize ) ; free (  pMap -> ranges ) ; return - 1 ; } close ( fd ) ; pMap -> addr = reserve ; pMap -> length  = size ;"
748,"CWE-119 bool extract_sockaddr ( struct pool * pool , char * url ) { char * url_begin , * url_end , * ipv6_begin , * ipv6_end , * port_start = NULL ; char url_address [ 256 ] , port [ 6 ] ; int url_len , port_len = 0 ; url_begin = strstr ( url , ""//"" ) ; if ( ! url_begin ) url_begin = url ; else url_begin += 2 ; ipv6_begin = strstr ( url_begin , ""["" ) ; ipv6_end = strstr ( url_begin , ""]"" ) ; if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin ) url_end = strstr ( ipv6_end , "":"" ) ; else url_end = strstr ( url_begin , "":"" ) ; if ( url_end ) { url_len = url_end - url_begin ; port_len = strlen ( url_begin ) - url_len - 1 ; if ( port_len < 1 ) return false ; port_start = url_end + 1 ; } else url_len = strlen ( url_begin ) ; if ( url_len < 1 ) return false ;  sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;  if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ; else strcpy ( port , ""80"" ) ; free ( pool -> stratum_port ) ; pool -> stratum_port = strdup ( port ) ; free ( pool -> sockaddr_url ) ; pool -> sockaddr_url = strdup ( url_address ) ; return true ; }"," return false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , ""%s:Truncatingoverflowedaddress\'%.*s\'"" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }"
749,"CWE-269 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:%sisasymboliclink\\n"" , dest ) ; exit ( 1 ) ; }  pid_t child = fork ( ) ;  if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ;  if ( rv )  fprintf ( stderr , ""Warning:cannottransfer.asoundrcinprivatehomedirectory\\n"" ) ; else {  fs_logger2 ( ""clone"" , dest ) ;  } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }"," ) ; } copy_file_as_user  ( src ,  S_IWUSR ) ;  fs_logger2 ( ""clone""  ""clone"" , dest  ) ; unlink"
750,"CWE-125 int yr_re_match ( RE * re , const char * target ) { return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) ,  re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) ; }"," target ) , 0 ,"
751,"CWE-119  void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run ,  BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ;  MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;   MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;  TOKENEXTRA * t_backup = * t ; const int ctx = vp9_get_skip_context ( xd ) ;  const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id ,  SEG_LVL_SKIP ) ;  struct tokenize_b_args arg = { cpi , xd , t } ;  if ( mbmi -> skip ) { if ( ! dry_run )  cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ;  reset_skip_context ( xd , bsize ) ;  if ( dry_run )  * t = t_backup ; return ; } if ( ! dry_run ) {  cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ;  vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ; } else { vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ;  * t = t_backup ;  } }"," * cpi , ThreadData * td ,  -> common ; MACROBLOCK * const x = & td -> mb ;  xd = & x ->  e_mbd ; MB_MODE_INFO  ] -> mbmi  ; const int  skip_inc = ! segfeature_active  ( & cm  { cpi , td  , t }  ! dry_run ) td -> counts ->  skip [ ctx  bsize ) ;  return ; }  dry_run ) { td -> counts ->  skip [ ctx  arg ) ;  } } "
752,"CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , ""failedtoapplydelta:basesizedoesnotmatchgivendata"" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , ""failedtoapplydelta:basesizedoesnotmatchgivendata"" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; if ( cmd & 0x04 ) off |= * delta ++ << 16UL ;  if ( cmd & 0x08 ) off |= * delta ++ << 24UL ;  if ( cmd & 0x10 ) len = * delta ++ ; if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; if ( ! len ) len = 0x10000 ; if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , ""failedtoapplydelta"" ) ; return - 1 ; }", ) off |= ( ( unsigned )  ++ << 24UL )
753,"CWE-125 struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XDIRINFO"" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_size -- ; xmi_tmpdata -= 13 ; xmi_data += xmi_tmpdata ; xmi_size -= xmi_tmpdata ; if ( memcmp ( xmi_data , ""CAT"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_catlen = * xmi_data ++ << 24 ; xmi_catlen |= * xmi_data ++ << 16 ; xmi_catlen |= * xmi_data ++ << 8 ; xmi_catlen |= * xmi_data ++ ; xmi_size -= 4 ; UNUSED ( xmi_catlen ) ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( xmi_mdi , xmi_divisions ) ; _WM_midi_setup_tempo ( xmi_mdi , xmi_tempo ) ; xmi_samples_per_delta_f = _WM_GetSamplesPerTick ( xmi_divisions , xmi_tempo ) ; xmi_notelen = malloc ( sizeof ( uint32_t ) * 16 * 128 ) ; memset ( xmi_notelen , 0 , ( sizeof ( uint32_t ) * 16 * 128 ) ) ; for ( i = 0 ; i < xmi_formcnt ; i ++ ) { if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen = * xmi_data ++ << 24 ; xmi_subformlen |= * xmi_data ++ << 16 ; xmi_subformlen |= * xmi_data ++ << 8 ; xmi_subformlen |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen -= 4 ; do { if ( ! memcmp ( xmi_data , ""TIMB"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""RBRN"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""EVNT"" , 4 ) ) { xmi_data += 4 ; xmi_evnt_cnt ++ ; xmi_evntlen = * xmi_data ++ << 24 ; xmi_evntlen |= * xmi_data ++ << 16 ; xmi_evntlen |= * xmi_data ++ << 8 ; xmi_evntlen |= * xmi_data ++ ; xmi_size -= 8 ; xmi_subformlen -= 8 ; do { if ( * xmi_data < 0x80 ) { xmi_delta = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; do { if ( ( xmi_lowestdelta != 0 ) && ( xmi_lowestdelta <= xmi_delta ) ) { xmi_tmpdata = xmi_lowestdelta ; } else { xmi_tmpdata = xmi_delta ; } xmi_sample_count_f = ( ( ( float ) xmi_tmpdata * xmi_samples_per_delta_f ) + xmi_sample_remainder ) ; xmi_sample_count = ( uint32_t ) xmi_sample_count_f ; xmi_sample_remainder = xmi_sample_count_f - ( float ) xmi_sample_count ; xmi_mdi -> events [ xmi_mdi -> event_count - 1 ] . samples_to_next += xmi_sample_count ; xmi_mdi -> extra_info . approx_total_samples += xmi_sample_count ; xmi_lowestdelta = 0 ; for ( j = 0 ; j < ( 16 * 128 ) ; j ++ ) { if ( xmi_notelen [ j ] == 0 ) continue ; xmi_notelen [ j ] -= xmi_tmpdata ; if ( xmi_notelen [ j ] == 0 ) { xmi_ch = j / 128 ; xmi_note = j - ( xmi_ch * 128 ) ; _WM_midi_setup_noteoff ( xmi_mdi , xmi_ch , xmi_note , 0 ) ; } else { if ( ( xmi_lowestdelta == 0 ) || ( xmi_lowestdelta > xmi_notelen [ j ] ) ) { xmi_lowestdelta = xmi_notelen [ j ] ; } } } xmi_delta -= xmi_tmpdata ; } while ( xmi_delta ) ; } else { if ( ( xmi_data [ 0 ] == 0xff ) && ( xmi_data [ 1 ] == 0x51 ) && ( xmi_data [ 2 ] == 0x03 ) ) { setup_ret = 6 ; goto _XMI_Next_Event ; }  if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) {  goto _xmi_end ; } if ( ( * xmi_data & 0xf0 ) == 0x90 ) { xmi_ch = * xmi_data & 0x0f ; xmi_note = xmi_data [ 1 ] ; xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; xmi_tmpdata = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; xmi_notelen [ 128 * xmi_ch + xmi_note ] = xmi_tmpdata ; if ( ( xmi_tmpdata > 0 ) && ( ( xmi_lowestdelta == 0 ) || ( xmi_tmpdata < xmi_lowestdelta ) ) ) { xmi_lowestdelta = xmi_tmpdata ; } } else { _XMI_Next_Event : xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; } } } while ( xmi_evntlen ) ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } } while ( xmi_subformlen ) ; } if ( ( xmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""toinitreverb"" , 0 ) ; goto _xmi_end ; } xmi_mdi -> extra_info . current_sample = 0 ; xmi_mdi -> current_event = & xmi_mdi -> events [ 0 ] ; xmi_mdi -> samples_to_mix = 0 ; xmi_mdi -> note = NULL ; if ( xmi_evnt_cnt > 1 ) { xmi_mdi -> is_type2 = 1 ; } _WM_ResetToStart ( xmi_mdi ) ; _xmi_end : if ( xmi_notelen != NULL ) free ( xmi_notelen ) ; if ( xmi_mdi -> reverb ) return ( xmi_mdi ) ; _WM_freeMDI ( xmi_mdi ) ; return NULL ; }"," , xmi_data , xmi_size ,"
754,"CWE-617 krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) {  return KRB5KDC_ERR_BADOPTION ;  } if ( ! krb5_principal_compare ( kdc_context , server -> princ ,  server_princ ) ) {  return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = ""EVIDENCE_TKT_NOT_FORWARDABLE"" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = ""NOT_ALLOWED_TO_DELEGATE"" ; return errcode ; } return 0 ; }"," ) ) { * status = ""INVALID_S4U2PROXY_OPTIONS"" ;  ) ) { * status = ""EVIDENCE_TICKET_MISMATCH"" ;"
755,"CWE-400 static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ;  if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ; } }"," pt_regs * regs  ) { u64  ( event ,  & data ,"
756,"CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""iframe"" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , ""Custompalette"" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s -> image_height / s -> block_height ; v_part = s -> image_height % s -> block_height ; if ( s -> block_size < s -> block_width * s -> block_height ) { int tmpblock_size = 3 * s -> block_width * s -> block_height ; s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; if ( ! s -> tmpblock ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'tallocatedecompressionbuffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } if ( s -> ver == 2 ) { s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; if ( s -> deflate_block_size <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'tdeterminedeflatebuffersize.\\n"" ) ; return - 1 ; } s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; if ( ! s -> deflate_block ) { av_log ( avctx , AV_LOG_ERROR , ""Can\'tallocatedeflatebuffer.\\n"" ) ; return AVERROR ( ENOMEM ) ; } } } s -> block_size = s -> block_width * s -> block_height ; if ( avctx -> width == 0 && avctx -> height == 0 ) { avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; } if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { av_log ( avctx , AV_LOG_ERROR , ""Framewidthorheightdiffersfromfirstframe!\\n"" ) ; av_log ( avctx , AV_LOG_ERROR , ""fh=%d,fv%dvsch=%d,cv=%d\\n"" , avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; return AVERROR_INVALIDDATA ; } s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; if ( s -> is_keyframe ) { s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; } if ( s -> ver == 2 && ! s -> blocks ) s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) * sizeof ( s -> blocks [ 0 ] ) ) ; av_dlog ( avctx , ""image:%dx%dblock:%dx%dnum:%dx%dpart:%dx%d\\n"" , s -> image_width , s -> image_height , s -> block_width , s -> block_height , h_blocks , v_blocks , h_part , v_part ) ; if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) return ret ; for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { int y_pos = j * s -> block_height ; int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { int x_pos = i * s -> block_width ; int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; int has_diff = 0 ; int size = get_bits ( & gb , 16 ) ; s -> color_depth = 0 ; s -> zlibprime_curr = 0 ; s -> zlibprime_prev = 0 ; s -> diff_start = 0 ; s -> diff_height = cur_blk_height ; if ( 8 * size > get_bits_left ( & gb ) ) { av_frame_unref ( & s -> frame ) ; return AVERROR_INVALIDDATA ; } if ( s -> ver == 2 && size ) { skip_bits ( & gb , 3 ) ; s -> color_depth = get_bits ( & gb , 2 ) ; has_diff = get_bits1 ( & gb ) ; s -> zlibprime_curr = get_bits1 ( & gb ) ; s -> zlibprime_prev = get_bits1 ( & gb ) ; if ( s -> color_depth != 0 && s -> color_depth != 2 ) { av_log ( avctx , AV_LOG_ERROR , ""%dx%dinvalidcolordepth%d\\n"" , i , j , s -> color_depth ) ; return AVERROR_INVALIDDATA ; } if ( has_diff ) { if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""interframewithoutkeyframe\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> diff_start = get_bits ( & gb , 8 ) ; s -> diff_height = get_bits ( & gb , 8 ) ;  av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%ddiffstart%dheight%d\\n"" , i , j , s -> diff_start , s -> diff_height ) ; size -= 2 ; } if ( s -> zlibprime_prev ) av_log ( avctx , AV_LOG_DEBUG , ""%dx%dzlibprime_prev\\n"" , i , j ) ; if ( s -> zlibprime_curr ) { int col = get_bits ( & gb , 8 ) ; int row = get_bits ( & gb , 8 ) ; av_log ( avctx , AV_LOG_DEBUG , ""%dx%dzlibprime_curr%dx%d\\n"" , i , j , col , row ) ; size -= 2 ; avpriv_request_sample ( avctx , ""zlibprime_curr"" ) ; return AVERROR_PATCHWELCOME ; } if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { av_log ( avctx , AV_LOG_ERROR , ""nodataavailableforzlib"" ""priming\\n"" ) ; return AVERROR_INVALIDDATA ; } size -- ; } if ( has_diff ) { int k ; int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; for ( k = 0 ; k < cur_blk_height ; k ++ ) memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , cur_blk_width * 3 ) ; } if ( size ) { if ( flashsv_decode_block ( avctx , avpkt , & gb , size , cur_blk_width , cur_blk_height , x_pos , y_pos , i + j * ( h_blocks + ! ! h_part ) ) ) av_log ( avctx , AV_LOG_ERROR , ""errorindecompressionofblock%dx%d\\n"" , i , j ) ; } } } if ( s -> is_keyframe && s -> ver == 2 ) { if ( ! s -> keyframe ) { s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; if ( ! s -> keyframe ) { av_log ( avctx , AV_LOG_ERROR , ""Cannotallocateimagedata\\n"" ) ; return AVERROR ( ENOMEM ) ; } } memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; } if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ; * got_frame = 1 ; if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) av_log ( avctx , AV_LOG_ERROR , ""buffernotfullyconsumed(%d!=%d)\\n"" , buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; return buf_size ; }"," 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , ""Blockparametersinvalid\\n"" ) ; return AVERROR_INVALIDDATA ; }"
757,"CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; }  ret = vfs_dedupe_file_range ( file , same ) ;  if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }", out ; } same -> dest_count = count ;
758,"CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""#%utype=%sid=%s"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , ""#%utype=%sid=%u"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) {  cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }"," , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if  < ep2 )  ND_PRINT ( ("
759,"CWE-264 static int msr_open ( struct inode * inode , struct file * file ) { unsigned int cpu ;  struct cpuinfo_x86 * c ;  cpu = iminor ( file -> f_path . dentry -> d_inode ) ; if ( cpu >= nr_cpu_ids || ! cpu_online ( cpu ) ) return - ENXIO ; c = & cpu_data ( cpu ) ; if ( ! cpu_has ( c , X86_FEATURE_MSR ) ) return - EIO ; return 0 ; }", cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM
760,"CWE-264 static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ;  bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;  bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }", priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING )  ; bond_dev ->
761,"CWE-119 int vp9_receive_compressed_data ( VP9Decoder * pbi ,  size_t size , const uint8_t * * psource ,  int64_t time_stamp ) {  VP9_COMMON * const cm = & pbi -> common ;  const uint8_t * source = * psource ; int retcode = 0 ; cm -> error . error_code = VPX_CODEC_OK ; if ( size == 0 ) {  if ( cm -> frame_refs [ 0 ] . idx != INT_MAX )  cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; }  if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 )   cm -> release_fb_cb ( cm -> cb_priv ,   & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ;  cm -> new_fb_idx = get_free_fb ( cm ) ;  if ( setjmp ( cm -> error . jmp ) ) {   cm -> error . setjmp = 0 ;   if ( cm -> frame_refs [ 0 ] . idx != INT_MAX )  cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; return - 1 ; } cm -> error . setjmp = 1 ;  retcode = vp9_decode_frame ( pbi , source , source + size , psource ) ;   if ( retcode < 0 ) {   cm -> error . error_code = VPX_CODEC_ERROR ;   cm -> error . setjmp = 0 ;  if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; return retcode ; }  swap_frame_buffers ( pbi ) ;  # if WRITE_RECON_BUFFER == 2 if ( cm -> show_frame ) write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame ) ; else write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame + 1000 ) ; # endif if ( ! pbi -> do_loopfilter_inline ) { if ( pbi -> num_tile_workers ) { vp9_loop_filter_frame_mt ( pbi , cm , & pbi -> mb , cm -> lf . filter_level , 0 , 0 ) ; } else { vp9_loop_filter_frame ( cm , & pbi -> mb , cm -> lf . filter_level , 0 , 0 ) ; } } # if WRITE_RECON_BUFFER == 2 if ( cm -> show_frame ) write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame + 2000 ) ; else write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame + 3000 ) ; # endif # if WRITE_RECON_BUFFER == 1 if ( cm -> show_frame ) recon_write_yuv_frame ( ""recon.yuv"" , cm -> frame_to_show , cm -> width , cm -> height ) ; # endif vp9_clear_system_state ( ) ; cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( ! cm -> show_existing_frame ) cm -> last_show_frame = cm -> show_frame ; if ( cm -> show_frame ) { if ( ! cm -> show_existing_frame ) vp9_swap_mi_and_prev_mi ( cm ) ; cm -> current_video_frame ++ ; } pbi -> ready_for_new_data = 0 ; pbi -> last_time_stamp = time_stamp ; cm -> error . setjmp = 0 ; return retcode ; }"," * * psource  ) { VP9_COMMON  { VP9_COMMON * volatile  pbi -> common ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs  ] . idx > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ;  cm -> frame_refs  1 ; } } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode &&  cm -> new_fb_idx  >= 0 &&  frame_bufs [ cm  == 0 ) pool  -> release_fb_cb (  -> release_fb_cb ( pool  -> cb_priv ,  cb_priv , &  frame_bufs [ cm  ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if (  ) ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ;  = 0 ; pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( )  ; return -  = 1 ;  vp9_decode_frame ( pbi  psource ) ; swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } }  cm -> error  -> error .  setjmp = 0  setjmp = 0  ; return retcode  retcode ; }    "
762,"CWE-125 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif break ; case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) { r1 . o = function -> return_obj ; push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length ,  r2 . re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } yr_modules_unload_all ( context ) ; yr_free ( stack ) ; return result ; }"," -> length , 0 ,"
763,"CWE-119 static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref ,  int_mv * prev_golden_ref_mv ,  YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) {  MACROBLOCK * const x = & cpi -> mb ;  MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error ; } else { stats -> ref [ GOLDEN_FRAME ] . err = INT_MAX ; stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int = 0 ; } if ( alt_ref ) { int a_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = alt_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = alt_ref -> y_stride ; a_motion_error = do_16x16_zerozero_search ( cpi , & stats -> ref [ ALTREF_FRAME ] . m . mv ) ; stats -> ref [ ALTREF_FRAME ] . err = a_motion_error ; } else { stats -> ref [ ALTREF_FRAME ] . err = INT_MAX ; stats -> ref [ ALTREF_FRAME ] . m . mv . as_int = 0 ; } }"," * golden_ref , const MV  * prev_golden_ref_mv ,  & cpi -> td ."
764,"CWE-401 static ssize_t rpmsg_eptdev_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct rpmsg_eptdev * eptdev = filp -> private_data ; size_t len = iov_iter_count ( from ) ; void * kbuf ; int ret ; kbuf = kzalloc ( len , GFP_KERNEL ) ; if ( ! kbuf ) return - ENOMEM ; if ( ! copy_from_iter_full ( kbuf , len , from ) )  return - EFAULT ;  if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) { ret = - ERESTARTSYS ; goto free_kbuf ; } if ( ! eptdev -> ept ) { ret = - EPIPE ; goto unlock_eptdev ; } if ( filp -> f_flags & O_NONBLOCK ) ret = rpmsg_trysend ( eptdev -> ept , kbuf , len ) ; else ret = rpmsg_send ( eptdev -> ept , kbuf , len ) ; unlock_eptdev : mutex_unlock ( & eptdev -> ept_lock ) ; free_kbuf : kfree ( kbuf ) ; return ret < 0 ? ret : len ; }", from ) ) { ret =  - EFAULT ;  - EFAULT ; goto free_kbuf ; }
765,"CWE-125  void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }",    static
766,CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ;  return TRUE ;  } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }, current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
767,"CWE-125 int imagetobmp ( opj_image_t * image , const char * outfile ) { int w , h ; int i , pad ; FILE * fdest = NULL ; int adjustR , adjustG , adjustB ; if ( image -> comps [ 0 ] . prec < 8 ) { fprintf ( stderr , ""Unsupportednumberofcomponents:%d\\n"" , image -> comps [ 0 ] . prec ) ; return 1 ; } if ( image -> numcomps >= 3 && image -> comps [ 0 ] . dx == image -> comps [ 1 ] . dx && image -> comps [ 1 ] . dx == image -> comps [ 2 ] . dx && image -> comps [ 0 ] . dy == image -> comps [ 1 ] . dy && image -> comps [ 1 ] . dy == image -> comps [ 2 ] . dy && image -> comps [ 0 ] . prec == image -> comps [ 1 ] . prec && image -> comps [ 1 ] . prec == image -> comps [ 2 ] . prec ) { fdest = fopen ( outfile , ""wb"" ) ; if ( ! fdest ) { fprintf ( stderr , ""ERROR->failedtoopen%sforwriting\\n"" , outfile ) ; return 1 ; } w = ( int ) image -> comps [ 0 ] . w ; h = ( int ) image -> comps [ 0 ] . h ; fprintf ( fdest , ""BM"" ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) + 54 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 54 ) & 0xff , ( ( 54 ) >> 8 ) & 0xff , ( ( 54 ) >> 16 ) & 0xff , ( ( 54 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 24 ) & 0xff , ( ( 24 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( 3 * h * w + 3 * h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w * 3 + 3 * h * ( w % 2 ) ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; if ( image -> comps [ 0 ] . prec > 8 ) { adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ; printf ( ""BMPCONVERSION:Truncatingcomponent0from%dbitsto8bits\\n"" , image -> comps [ 0 ] . prec ) ; } else adjustR = 0 ; if ( image -> comps [ 1 ] . prec > 8 ) { adjustG = ( int ) image -> comps [ 1 ] . prec - 8 ; printf ( ""BMPCONVERSION:Truncatingcomponent1from%dbitsto8bits\\n"" , image -> comps [ 1 ] . prec ) ; } else adjustG = 0 ; if ( image -> comps [ 2 ] . prec > 8 ) { adjustB = ( int ) image -> comps [ 2 ] . prec - 8 ; printf ( ""BMPCONVERSION:Truncatingcomponent2from%dbitsto8bits\\n"" , image -> comps [ 2 ] . prec ) ; } else adjustB = 0 ; for ( i = 0 ; i < w * h ; i ++ ) { OPJ_UINT8 rc , gc , bc ; int r , g , b ; r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ; r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ; if ( r > 255 ) r = 255 ; else if ( r < 0 ) r = 0 ; rc = ( OPJ_UINT8 ) r ; g = image -> comps [ 1 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; g += ( image -> comps [ 1 ] . sgnd ? 1 << ( image -> comps [ 1 ] . prec - 1 ) : 0 ) ; g = ( ( g >> adjustG ) + ( ( g >> ( adjustG - 1 ) ) % 2 ) ) ; if ( g > 255 ) g = 255 ; else if ( g < 0 ) g = 0 ; gc = ( OPJ_UINT8 ) g ; b = image -> comps [ 2 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; b += ( image -> comps [ 2 ] . sgnd ? 1 << ( image -> comps [ 2 ] . prec - 1 ) : 0 ) ; b = ( ( b >> adjustB ) + ( ( b >> ( adjustB - 1 ) ) % 2 ) ) ; if ( b > 255 ) b = 255 ; else if ( b < 0 ) b = 0 ; bc = ( OPJ_UINT8 ) b ; fprintf ( fdest , ""%c%c%c"" , bc , gc , rc ) ; if ( ( i + 1 ) % w == 0 ) { for ( pad = ( ( 3 * w ) % 4 ) ? ( 4 - ( 3 * w ) % 4 ) : 0 ; pad > 0 ; pad -- ) fprintf ( fdest , ""%c"" , 0 ) ; } } fclose ( fdest ) ; } else { fdest = fopen ( outfile , ""wb"" ) ; if ( ! fdest ) { fprintf ( stderr , ""ERROR->failedtoopen%sforwriting\\n"" , outfile ) ; return 1 ; } w = ( int ) image -> comps [ 0 ] . w ; h = ( int ) image -> comps [ 0 ] . h ; fprintf ( fdest , ""BM"" ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + 54 + 1024 + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + w * ( w % 2 ) ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 54 + 1024 ) & 0xff , ( ( 54 + 1024 ) >> 8 ) & 0xff , ( ( 54 + 1024 ) >> 16 ) & 0xff , ( ( 54 + 1024 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c"" , ( 8 ) & 0xff , ( ( 8 ) >> 8 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ; fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ; if ( image -> comps [ 0 ] . prec > 8 ) { adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ; printf ( ""BMPCONVERSION:Truncatingcomponent0from%dbitsto8bits\\n"" , image -> comps [ 0 ] . prec ) ; } else adjustR = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { fprintf ( fdest , ""%c%c%c%c"" , i , i , i , 0 ) ; } for ( i = 0 ; i < w * h ; i ++ ) { int r ; r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ; r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ; r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ; if ( r > 255 ) r = 255 ; else if ( r < 0 ) r = 0 ; fprintf ( fdest , ""%c"" , ( OPJ_UINT8 ) r ) ; if ( ( i + 1 ) % w == 0 ) {  for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- )  fprintf ( fdest , ""%c"" , 0 ) ; } } fclose ( fdest ) ; } return 0 ; }", { for ( pad = (  w % 4
768,"CWE-119 cJSON * cJSON_DetachItemFromArray ( cJSON * array , int which ) { cJSON * c = array -> child ;  while ( c && which > 0 ) {   c = c -> next ;  -- which ; } if ( ! c ) return 0 ; if ( c -> prev ) c -> prev -> next = c -> next ; if ( c -> next ) c -> next -> prev = c -> prev ; if ( c == array -> child ) array -> child = c -> next ; c -> prev = c -> next = 0 ; return c ; }"," > 0 )  c = c  c -> next , which -- ;  if ( !"
769,"CWE-284 int sandbox ( void * sandbox_arg ) { ( void ) sandbox_arg ; pid_t child_pid = getpid ( ) ; if ( arg_debug ) printf ( ""Initializingchildprocess\\n"" ) ; close ( parent_to_child_fds [ 1 ] ) ; close ( child_to_parent_fds [ 0 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; if ( arg_debug && child_pid == 1 ) printf ( ""PIDnamespaceinstalled\\n"" ) ; if ( cfg . hostname ) { if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( ""sethostname"" ) ; } if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { chk_chroot ( ) ; } preproc_mount_mnt_dir ( ) ; if ( mount ( LIBDIR ""/firejail"" , RUN_FIREJAIL_LIB_DIR , ""none"" , MS_BIND , NULL ) < 0 ) errExit ( ""mounting"" RUN_FIREJAIL_LIB_DIR ) ; if ( cfg . name ) fs_logger2 ( ""sandboxname:"" , cfg . name ) ; fs_logger2int ( ""sandboxpid:"" , ( int ) sandbox_pid ) ; if ( cfg . chrootdir ) fs_logger ( ""sandboxfilesystem:chroot"" ) ; else if ( arg_overlay ) fs_logger ( ""sandboxfilesystem:overlay"" ) ; else fs_logger ( ""sandboxfilesystem:local"" ) ; fs_logger ( ""installmountnamespace"" ) ; if ( arg_netfilter && any_bridge_configured ( ) ) { netfilter ( arg_netfilter_file ) ; } if ( arg_netfilter6 && any_bridge_configured ( ) ) { netfilter6 ( arg_netfilter6_file ) ; } int gw_cfg_failed = 0 ; if ( arg_nonetwork ) { net_if_up ( ""lo"" ) ; if ( arg_debug ) printf ( ""Networknamespaceenabled,onlyloopbackinterfaceavailable\\n"" ) ; } else if ( arg_netns ) { netns ( arg_netns ) ; if ( arg_debug ) printf ( ""Networknamespace\'%s\'activated\\n"" , arg_netns ) ; } else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { net_if_up ( ""lo"" ) ; if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ; sandbox_if_up ( & cfg . bridge0 ) ; if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ; sandbox_if_up ( & cfg . bridge1 ) ; if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ; sandbox_if_up ( & cfg . bridge2 ) ; if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ; sandbox_if_up ( & cfg . bridge3 ) ; if ( cfg . interface0 . configured && cfg . interface0 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface0 . ip ) , cfg . interface0 . dev ) ; net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ; } if ( cfg . interface1 . configured && cfg . interface1 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface1 . ip ) , cfg . interface1 . dev ) ; net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ; } if ( cfg . interface2 . configured && cfg . interface2 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface2 . ip ) , cfg . interface2 . dev ) ; net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ; } if ( cfg . interface3 . configured && cfg . interface3 . ip ) { if ( arg_debug ) printf ( ""Configuring%d.%d.%d.%daddressoninterface%s\\n"" , PRINT_IP ( cfg . interface3 . ip ) , cfg . interface3 . dev ) ; net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ; } if ( cfg . defaultgw ) { if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) { fwarning ( ""cannotconfiguredefaultroute\\n"" ) ; gw_cfg_failed = 1 ; } } if ( arg_debug ) printf ( ""Networknamespaceenabled\\n"" ) ; } if ( ! arg_quiet ) { if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) { fmessage ( ""\\n"" ) ; if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , ""printif"" , ""scan"" ) ; else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , ""printif"" ) ; } if ( cfg . defaultgw != 0 ) { if ( gw_cfg_failed ) fmessage ( ""Defaultgatewayconfigurationfailed\\n"" ) ; else fmessage ( ""Defaultgateway%d.%d.%d.%d\\n"" , PRINT_IP ( cfg . defaultgw ) ) ; } if ( cfg . dns1 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns1 ) ; if ( cfg . dns2 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns2 ) ; if ( cfg . dns3 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns3 ) ; if ( cfg . dns4 != NULL ) fmessage ( ""DNSserver%s\\n"" , cfg . dns4 ) ; fmessage ( ""\\n"" ) ; } } if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) { } else { EUID_USER ( ) ; env_ibus_load ( ) ; EUID_ROOT ( ) ; } # ifdef HAVE_SECCOMP if ( cfg . protocol ) { if ( arg_debug ) printf ( ""Buildprotocolfilter:%s\\n"" , cfg . protocol ) ; int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , ""protocol"" , ""build"" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ; if ( rv ) exit ( rv ) ; } if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ; # endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ; if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) { enforce_filters ( ) ; need_preload = arg_trace || arg_tracelog ; } if ( need_preload ) fs_trace_preload ( ) ; if ( cfg . hosts_file ) fs_store_hosts_file ( ) ; # ifdef HAVE_CHROOT if ( cfg . chrootdir ) { fs_chroot ( cfg . chrootdir ) ; if ( need_preload ) fs_trace_preload ( ) ; } else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ; else # endif fs_basic_fs ( ) ; if ( arg_private ) { if ( cfg . home_private ) { if ( cfg . chrootdir ) fwarning ( ""private=directoryfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private=directoryfeatureisdisabledinoverlay\\n"" ) ; else fs_private_homedir ( ) ; } else if ( cfg . home_private_keep ) { if ( cfg . chrootdir ) fwarning ( ""private-home=featureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-home=featureisdisabledinoverlay\\n"" ) ; else fs_private_home_list ( ) ; } else fs_private ( ) ; } if ( arg_private_dev ) fs_private_dev ( ) ; if ( arg_private_etc ) { if ( cfg . chrootdir ) fwarning ( ""private-etcfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-etcfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_dir_list ( ""/etc"" , RUN_ETC_DIR , cfg . etc_private_keep ) ; if ( need_preload ) fs_trace_preload ( ) ; } } if ( arg_private_opt ) { if ( cfg . chrootdir ) fwarning ( ""private-optfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-optfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_dir_list ( ""/opt"" , RUN_OPT_DIR , cfg . opt_private_keep ) ; } } if ( arg_private_srv ) { if ( cfg . chrootdir ) fwarning ( ""private-srvfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-srvfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_dir_list ( ""/srv"" , RUN_SRV_DIR , cfg . srv_private_keep ) ; } } if ( arg_private_bin && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( ""private-binfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-binfeatureisdisabledinoverlay\\n"" ) ; else { if ( arg_x11_xorg ) { EUID_USER ( ) ; char * tmp ; if ( asprintf ( & tmp , ""%s,xauth"" , cfg . bin_private_keep ) == - 1 ) errExit ( ""asprintf"" ) ; cfg . bin_private_keep = tmp ; EUID_ROOT ( ) ; } fs_private_bin_list ( ) ; } } if ( arg_private_lib && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( ""private-libfeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-libfeatureisdisabledinoverlay\\n"" ) ; else { fs_private_lib ( ) ; } } if ( arg_private_cache ) { if ( cfg . chrootdir ) fwarning ( ""private-cachefeatureisdisabledinchroot\\n"" ) ; else if ( arg_overlay ) fwarning ( ""private-cachefeatureisdisabledinoverlay\\n"" ) ; else fs_private_cache ( ) ; } if ( arg_private_tmp ) { EUID_USER ( ) ; fs_private_tmp ( ) ; EUID_ROOT ( ) ; } if ( arg_nodbus ) dbus_session_disable ( ) ; if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ; if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ; if ( arg_netns ) netns_mounts ( arg_netns ) ; fs_proc_sys_dev_boot ( ) ; if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ; else if ( arg_disable_mnt ) fs_mnt ( 0 ) ; fs_whitelist ( ) ; fs_blacklist ( ) ; if ( arg_nosound ) { pulseaudio_disable ( ) ; fs_dev_disable_sound ( ) ; } else if ( ! arg_noautopulse ) pulseaudio_init ( ) ; if ( arg_no3d ) fs_dev_disable_3d ( ) ; if ( arg_notv ) fs_dev_disable_tv ( ) ; if ( arg_nodvd ) fs_dev_disable_dvd ( ) ; if ( arg_nou2f ) fs_dev_disable_u2f ( ) ; if ( arg_novideo ) fs_dev_disable_video ( ) ; if ( need_preload ) fs_trace ( ) ; fs_resolvconf ( ) ; fs_logger_print ( ) ; fs_logger_change_owner ( ) ; EUID_USER ( ) ; int cwd = 0 ; if ( cfg . cwd ) { if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ; } if ( ! cwd ) { if ( chdir ( ""/"" ) < 0 ) errExit ( ""chdir"" ) ; if ( cfg . homedir ) { struct stat s ; if ( stat ( cfg . homedir , & s ) == 0 ) { if ( chdir ( cfg . homedir ) < 0 ) errExit ( ""chdir"" ) ; } } } if ( arg_debug ) { char * cpath = get_current_dir_name ( ) ; if ( cpath ) { printf ( ""Currentdirectory:%s\\n"" , cpath ) ; free ( cpath ) ; } } EUID_ROOT ( ) ; fs_x11 ( ) ; if ( arg_x11_xorg ) x11_xorg ( ) ; save_umask ( ) ; save_nonewprivs ( ) ;  set_caps ( ) ;  save_cpu ( ) ; save_cgroup ( ) ; # ifdef HAVE_SECCOMP # ifdef SYS_socket if ( cfg . protocol ) { if ( arg_debug ) printf ( ""Installprotocolfilter:%s\\n"" , cfg . protocol ) ; seccomp_load ( RUN_SECCOMP_PROTOCOL ) ; protocol_filter_save ( ) ; } else { int rv = unlink ( RUN_SECCOMP_PROTOCOL ) ; ( void ) rv ; } # endif if ( arg_seccomp == 1 ) { if ( cfg . seccomp_list_keep ) seccomp_filter_keep ( ) ; else seccomp_filter_drop ( ) ; } else { int rv = unlink ( RUN_SECCOMP_CFG ) ; rv |= unlink ( RUN_SECCOMP_32 ) ; ( void ) rv ; } if ( arg_memory_deny_write_execute ) { if ( arg_debug ) printf ( ""Installmemorywrite&executefilter\\n"" ) ; seccomp_load ( RUN_SECCOMP_MDWX ) ; } else { int rv = unlink ( RUN_SECCOMP_MDWX ) ; ( void ) rv ; }  # endif  FILE * rj = create_ready_for_join_file ( ) ; save_nogroups ( ) ; if ( arg_noroot ) { int rv = unshare ( CLONE_NEWUSER ) ; if ( rv == - 1 ) { fwarning ( ""cannotcreateanewusernamespace,goingforwardwithoutit...\\n"" ) ; arg_noroot = 0 ; } } notify_other ( child_to_parent_fds [ 1 ] ) ; close ( child_to_parent_fds [ 1 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; close ( parent_to_child_fds [ 0 ] ) ; if ( arg_noroot ) { if ( arg_debug ) printf ( ""norootusernamespaceinstalled\\n"" ) ; set_caps ( ) ; } if ( arg_nonewprivs ) { prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) ; if ( prctl ( PR_GET_NO_NEW_PRIVS , 0 , 0 , 0 , 0 ) != 1 ) { fwarning ( ""cannotsetNO_NEW_PRIVS,itrequiresaLinuxkernelversion3.5ornewer.\\n"" ) ; if ( force_nonewprivs ) { fprintf ( stderr , ""Error:NO_NEW_PRIVSrequiredforthissandbox,exiting...\\n"" ) ; exit ( 1 ) ; } } else if ( arg_debug ) printf ( ""NO_NEW_PRIVSset\\n"" ) ; } drop_privs ( arg_nogroups ) ; prctl ( PR_SET_PDEATHSIG , SIGKILL , 0 , 0 , 0 ) ; if ( cfg . cpus ) set_cpu_affinity ( ) ; pid_t app_pid = fork ( ) ; if ( app_pid == - 1 ) errExit ( ""fork"" ) ; if ( app_pid == 0 ) { # ifdef HAVE_APPARMOR if ( checkcfg ( CFG_APPARMOR ) && arg_apparmor ) { errno = 0 ; if ( aa_change_onexec ( ""firejail-default"" ) ) { fwarning ( ""CannotconfinetheapplicationusingAppArmor.\\n"" ""Maybefirejail-defaultAppArmorprofileisnotloadedintothekernel.\\n"" ""Asroot,run\\""aa-enforcefirejail-default\\""toloadit.\\n"" ) ; } else if ( arg_debug ) printf ( ""AppArmorenabled\\n"" ) ; } # endif if ( arg_nice ) set_nice ( cfg . nice ) ; set_rlimits ( ) ; start_application ( 0 , rj ) ; } fclose ( rj ) ; int status = monitor_application ( app_pid ) ; flush_stdin ( ) ; if ( WIFEXITED ( status ) ) { return WEXITSTATUS ( status ) ; } else { return - 1 ; } }", ( ) ;  save_cpu ( )  rv ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ;  FILE * rj
770,"CWE-119 void PNGAPI png_info_init_3 ( png_infopp ptr_ptr , png_size_t png_info_struct_size ) { png_infop info_ptr = * ptr_ptr ; png_debug ( 1 , ""inpng_info_init_3"" ) ; if ( info_ptr == NULL ) return ; if ( png_sizeof ( png_info ) > png_info_struct_size ) { png_destroy_struct ( info_ptr ) ; info_ptr = ( png_infop ) png_create_struct ( PNG_STRUCT_INFO ) ; * ptr_ptr = info_ptr ;  }  png_memset ( info_ptr , 0 , png_sizeof ( png_info ) ) ; }", = info_ptr ; if ( info_ptr == NULL ) return ;
771,"CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ;  opj_write_bytes ( p_data , J2K_MS_SOD ,  2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && ""TODO"" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , ""Cannotencodetile\\n"" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }"," p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , ""NotenoughbytesinoutputbuffertowriteSODmarker\\n"" ) ; return OPJ_FALSE ; }"
772,CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer )  {  kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }, mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
773,"CWE-787 int mwifiex_ret_wmm_get_status ( struct mwifiex_private * priv , const struct host_cmd_ds_command * resp ) { u8 * curr = ( u8 * ) & resp -> params . get_wmm_status ; uint16_t resp_len = le16_to_cpu ( resp -> size ) , tlv_len ; int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK ; bool valid = true ; struct mwifiex_ie_types_data * tlv_hdr ; struct mwifiex_ie_types_wmm_queue_status * tlv_wmm_qstatus ; struct ieee_types_wmm_parameter * wmm_param_ie = NULL ; struct mwifiex_wmm_ac_status * ac_status ; mwifiex_dbg ( priv -> adapter , INFO , ""info:WMM:WMM_GET_STATUScmdrespreceived:%d\\n"" , resp_len ) ; while ( ( resp_len >= sizeof ( tlv_hdr -> header ) ) && valid ) { tlv_hdr = ( struct mwifiex_ie_types_data * ) curr ; tlv_len = le16_to_cpu ( tlv_hdr -> header . len ) ; if ( resp_len < tlv_len + sizeof ( tlv_hdr -> header ) ) break ; switch ( le16_to_cpu ( tlv_hdr -> header . type ) ) { case TLV_TYPE_WMMQSTATUS : tlv_wmm_qstatus = ( struct mwifiex_ie_types_wmm_queue_status * ) tlv_hdr ; mwifiex_dbg ( priv -> adapter , CMD , ""info:CMD_RESP:WMM_GET_STATUS:\\t"" ""QSTATUSTLV:%d,%d,%d\\n"" , tlv_wmm_qstatus -> queue_index , tlv_wmm_qstatus -> flow_required , tlv_wmm_qstatus -> disabled ) ; ac_status = & priv -> wmm . ac_status [ tlv_wmm_qstatus -> queue_index ] ; ac_status -> disabled = tlv_wmm_qstatus -> disabled ; ac_status -> flow_required = tlv_wmm_qstatus -> flow_required ; ac_status -> flow_created = tlv_wmm_qstatus -> flow_created ; break ; case WLAN_EID_VENDOR_SPECIFIC : wmm_param_ie = ( struct ieee_types_wmm_parameter * ) ( curr + 2 ) ; wmm_param_ie -> vend_hdr . len = ( u8 ) tlv_len ; wmm_param_ie -> vend_hdr . element_id = WLAN_EID_VENDOR_SPECIFIC ; mwifiex_dbg ( priv -> adapter , CMD , ""info:CMD_RESP:WMM_GET_STATUS:\\t"" ""WMMParameterSetCount:%d\\n"" , wmm_param_ie -> qos_info_bitmap & mask ) ;  memcpy ( ( u8 * ) & priv -> curr_bss_params . bss_descriptor .  wmm_ie , wmm_param_ie , wmm_param_ie -> vend_hdr . len + 2 ) ; break ; default : valid = false ; break ; } curr += ( tlv_len + sizeof ( tlv_hdr -> header ) ) ; resp_len -= ( tlv_len + sizeof ( tlv_hdr -> header ) ) ; } mwifiex_wmm_setup_queue_priorities ( priv , wmm_param_ie ) ; mwifiex_wmm_setup_ac_downgrade ( priv ) ; return 0 ; }", mask ) ; if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;
774,"CWE-284 static void toggle_os_keylockstates ( int fd , int changedlockstates ) { BTIF_TRACE_EVENT ( ""%s:fd=%d,changedlockstates=0x%x"" , __FUNCTION__ , fd , changedlockstates ) ; UINT8 hidreport [ 9 ] ; int reportIndex ; memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; reportIndex = 4 ; if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK ) { BTIF_TRACE_DEBUG ( ""%sSettingCAPSLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_CAPSLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK ) { BTIF_TRACE_DEBUG ( ""%sSettingNUMLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_NUMLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK ) { BTIF_TRACE_DEBUG ( ""%sSettingSCROLLLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_SCROLLLOCK ; } BTIF_TRACE_DEBUG ( ""Writinghidreport#1toos:"" ""%s:%x%x%x"" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( ""%s:%x%x%x"" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( ""%s:%x%x%x"" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ;  usleep ( 200000 ) ;  memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( ""Writinghidreport#2toos:"" ""%s:%x%x%x"" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( ""%s:%x%x%x"" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( ""%s:%x%x%x"" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; }", ) ) ; TEMP_FAILURE_RETRY (  usleep ( 200000 )
775,CWE-416 static void smp_task_done ( struct sas_task * task ) {  if ( ! del_timer ( & task -> slow_task -> timer ) )  return ; complete ( & task -> slow_task -> completion ) ; }, task ) {  del_timer ( &  -> timer )  ; complete (
776,"CWE-416 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req -> mss = mss ; ireq -> ir_rmt_port = th -> source ; ireq -> ir_num = ntohs ( th -> dest ) ; ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { atomic_inc ( & skb -> users ) ; ireq -> pktopts = skb ; } ireq -> ir_iif = sk -> sk_bound_dev_if ; if ( ! sk -> sk_bound_dev_if && ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) ireq -> ir_iif = tcp_v6_iif ( skb ) ; ireq -> ir_mark = inet_request_mark ( sk , skb ) ; req -> num_retrans = 0 ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; treq -> snt_synack . v64 = 0 ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ;  final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;  fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) goto out_free ; } req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; out : return ret ; out_free : reqsk_free ( req ) ; return NULL ; }"," & fl6 , rcu_dereference (  np -> opt )"
777,"CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ;  ue -> info = * info ;  ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }", ; ue -> card = card ; ue ->
778,"CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; }  truncate_pagecache ( inode , inode -> i_size ) ;  if ( shrink )  ext4_truncate ( inode ) ;  } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }", ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;  ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
779,"CWE-200 static void save_bt_to_dump_dir ( const char * bt , const char * exe , const char * reason ) { time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! ( g_opts & OPT_x ) ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; }  pid_t my_pid = getpid ( ) ;  char base [ sizeof ( ""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , ""xorg-%s-%lu-%u"" , iso_date , ( long ) my_pid , g_bt_count ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""xorg"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""xorg"" ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; dd_save_text ( dd , FILENAME_BACKTRACE , bt ) ; if ( ! exe ) { exe = ""/usr/bin/X"" ; if ( access ( ""/usr/bin/Xorg"" , X_OK ) == 0 ) exe = ""/usr/bin/Xorg"" ; } dd_save_text ( dd , FILENAME_EXECUTABLE , exe ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } free ( path ) ; }"," ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( ""NotgoingtomakedumpdirectoriesworldreadablebecausePrivateReportsison"" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }"
780,"CWE-119 IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 vps_id ; WORD32 sps_max_sub_layers ; WORD32 sps_id ; WORD32 sps_temporal_id_nesting_flag ; sps_t * ps_sps ; profile_tier_lvl_info_t s_ptl ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; BITS_PARSE ( ""video_parameter_set_id"" , value , ps_bitstrm , 4 ) ; vps_id = value ; vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; BITS_PARSE ( ""sps_max_sub_layers_minus1"" , value , ps_bitstrm , 3 ) ; sps_max_sub_layers = value + 1 ; sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; BITS_PARSE ( ""sps_temporal_id_nesting_flag"" , value , ps_bitstrm , 1 ) ; sps_temporal_id_nesting_flag = value ; ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , ( sps_max_sub_layers - 1 ) ) ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; sps_id = value ; if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) { if ( ps_codec -> i4_sps_done ) return IHEVCD_UNSUPPORTED_SPS_ID ; else sps_id = 0 ; } ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; ps_sps -> i1_sps_id = sps_id ; ps_sps -> i1_vps_id = vps_id ; ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; ps_codec -> i4_sps_id = sps_id ; memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; UEV_PARSE ( ""chroma_format_idc"" , value , ps_bitstrm ) ; ps_sps -> i1_chroma_format_idc = value ; if ( ps_sps -> i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420 ) { ps_codec -> s_parse . i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC ; return ( IHEVCD_ERROR_T ) IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC ; } if ( CHROMA_FMT_IDC_YUV444_PLANES == ps_sps -> i1_chroma_format_idc ) { BITS_PARSE ( ""separate_colour_plane_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_separate_colour_plane_flag = value ; } else { ps_sps -> i1_separate_colour_plane_flag = 0 ; } UEV_PARSE ( ""pic_width_in_luma_samples"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_width_in_luma_samples = value ; UEV_PARSE ( ""pic_height_in_luma_samples"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_height_in_luma_samples = value ; if ( ( 0 >= ps_sps -> i2_pic_width_in_luma_samples ) || ( 0 >= ps_sps -> i2_pic_height_in_luma_samples ) ) return IHEVCD_INVALID_PARAMETER ; ps_sps -> i2_pic_width_in_luma_samples = ALIGN8 ( ps_sps -> i2_pic_width_in_luma_samples ) ; ps_sps -> i2_pic_height_in_luma_samples = ALIGN8 ( ps_sps -> i2_pic_height_in_luma_samples ) ; if ( ( ps_sps -> i2_pic_width_in_luma_samples > ps_codec -> i4_max_wd ) || ( ps_sps -> i2_pic_width_in_luma_samples * ps_sps -> i2_pic_height_in_luma_samples > ps_codec -> i4_max_wd * ps_codec -> i4_max_ht ) || ( ps_sps -> i2_pic_height_in_luma_samples > MAX ( ps_codec -> i4_max_wd , ps_codec -> i4_max_ht ) ) ) { ps_codec -> i4_new_max_wd = ps_sps -> i2_pic_width_in_luma_samples ; ps_codec -> i4_new_max_ht = ps_sps -> i2_pic_height_in_luma_samples ; return ( IHEVCD_ERROR_T ) IHEVCD_UNSUPPORTED_DIMENSIONS ; } BITS_PARSE ( ""pic_cropping_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_pic_cropping_flag = value ; if ( ps_sps -> i1_pic_cropping_flag ) { UEV_PARSE ( ""pic_crop_left_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_left_offset = value ; UEV_PARSE ( ""pic_crop_right_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_right_offset = value ; UEV_PARSE ( ""pic_crop_top_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_top_offset = value ; UEV_PARSE ( ""pic_crop_bottom_offset"" , value , ps_bitstrm ) ; ps_sps -> i2_pic_crop_bottom_offset = value ; } else { ps_sps -> i2_pic_crop_left_offset = 0 ; ps_sps -> i2_pic_crop_right_offset = 0 ; ps_sps -> i2_pic_crop_top_offset = 0 ; ps_sps -> i2_pic_crop_bottom_offset = 0 ; } UEV_PARSE ( ""bit_depth_luma_minus8"" , value , ps_bitstrm ) ; if ( 0 != value ) return IHEVCD_UNSUPPORTED_BIT_DEPTH ; UEV_PARSE ( ""bit_depth_chroma_minus8"" , value , ps_bitstrm ) ; if ( 0 != value ) return IHEVCD_UNSUPPORTED_BIT_DEPTH ; UEV_PARSE ( ""log2_max_pic_order_cnt_lsb_minus4"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_max_pic_order_cnt_lsb = value + 4 ; BITS_PARSE ( ""sps_sub_layer_ordering_info_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sps_sub_layer_ordering_info_present_flag = value ; i = ( ps_sps -> i1_sps_sub_layer_ordering_info_present_flag ? 0 : ( ps_sps -> i1_sps_max_sub_layers - 1 ) ) ; for ( ; i < ps_sps -> i1_sps_max_sub_layers ; i ++ ) { UEV_PARSE ( ""max_dec_pic_buffering"" , value , ps_bitstrm ) ; ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] = value + 1 ;  UEV_PARSE ( ""num_reorder_pics"" , value , ps_bitstrm ) ;  ps_sps -> ai1_sps_max_num_reorder_pics [ i ] = value ;  UEV_PARSE ( ""max_latency_increase"" , value , ps_bitstrm ) ;  ps_sps -> ai1_sps_max_latency_increase [ i ] = value ; } UEV_PARSE ( ""log2_min_coding_block_size_minus3"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_min_coding_block_size = value + 3 ; UEV_PARSE ( ""log2_diff_max_min_coding_block_size"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_diff_max_min_coding_block_size = value ; UEV_PARSE ( ""log2_min_transform_block_size_minus2"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_min_transform_block_size = value + 2 ; UEV_PARSE ( ""log2_diff_max_min_transform_block_size"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_diff_max_min_transform_block_size = value ; ps_sps -> i1_log2_max_transform_block_size = ps_sps -> i1_log2_min_transform_block_size + ps_sps -> i1_log2_diff_max_min_transform_block_size ; ps_sps -> i1_log2_ctb_size = ps_sps -> i1_log2_min_coding_block_size + ps_sps -> i1_log2_diff_max_min_coding_block_size ; if ( ( ps_sps -> i1_log2_min_coding_block_size < 3 ) || ( ps_sps -> i1_log2_min_transform_block_size < 2 ) || ( ps_sps -> i1_log2_diff_max_min_transform_block_size < 0 ) || ( ps_sps -> i1_log2_max_transform_block_size > ps_sps -> i1_log2_ctb_size ) || ( ps_sps -> i1_log2_ctb_size < 4 ) || ( ps_sps -> i1_log2_ctb_size > 6 ) ) { return IHEVCD_INVALID_PARAMETER ; } ps_sps -> i1_log2_min_pcm_coding_block_size = 0 ; ps_sps -> i1_log2_diff_max_min_pcm_coding_block_size = 0 ; UEV_PARSE ( ""max_transform_hierarchy_depth_inter"" , value , ps_bitstrm ) ; ps_sps -> i1_max_transform_hierarchy_depth_inter = value ; UEV_PARSE ( ""max_transform_hierarchy_depth_intra"" , value , ps_bitstrm ) ; ps_sps -> i1_max_transform_hierarchy_depth_intra = value ; BITS_PARSE ( ""scaling_list_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_scaling_list_enable_flag = value ; if ( ps_sps -> i1_scaling_list_enable_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_sps -> pi2_scaling_mat ) ; BITS_PARSE ( ""sps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sps_scaling_list_data_present_flag = value ; if ( ps_sps -> i1_sps_scaling_list_data_present_flag ) ihevcd_scaling_list_data ( ps_codec , ps_sps -> pi2_scaling_mat ) ; } else { COPY_FLAT_SCALING_LIST ( ps_sps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""asymmetric_motion_partitions_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_amp_enabled_flag = value ; BITS_PARSE ( ""sample_adaptive_offset_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sample_adaptive_offset_enabled_flag = value ; BITS_PARSE ( ""pcm_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_pcm_enabled_flag = value ; if ( ps_sps -> i1_pcm_enabled_flag ) { BITS_PARSE ( ""pcm_sample_bit_depth_luma"" , value , ps_bitstrm , 4 ) ; ps_sps -> i1_pcm_sample_bit_depth_luma = value + 1 ; BITS_PARSE ( ""pcm_sample_bit_depth_chroma"" , value , ps_bitstrm , 4 ) ; ps_sps -> i1_pcm_sample_bit_depth_chroma = value + 1 ; UEV_PARSE ( ""log2_min_pcm_coding_block_size_minus3"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_min_pcm_coding_block_size = value + 3 ; UEV_PARSE ( ""log2_diff_max_min_pcm_coding_block_size"" , value , ps_bitstrm ) ; ps_sps -> i1_log2_diff_max_min_pcm_coding_block_size = value ; BITS_PARSE ( ""pcm_loop_filter_disable_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_pcm_loop_filter_disable_flag = value ; } UEV_PARSE ( ""num_short_term_ref_pic_sets"" , value , ps_bitstrm ) ; ps_sps -> i1_num_short_term_ref_pic_sets = value ; ps_sps -> i1_num_short_term_ref_pic_sets = CLIP3 ( ps_sps -> i1_num_short_term_ref_pic_sets , 0 , MAX_STREF_PICS_SPS ) ; for ( i = 0 ; i < ps_sps -> i1_num_short_term_ref_pic_sets ; i ++ ) ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , i , & ps_sps -> as_stref_picset [ i ] ) ; BITS_PARSE ( ""long_term_ref_pics_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_long_term_ref_pics_present_flag = value ; if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { UEV_PARSE ( ""num_long_term_ref_pics_sps"" , value , ps_bitstrm ) ; ps_sps -> i1_num_long_term_ref_pics_sps = value ; for ( i = 0 ; i < ps_sps -> i1_num_long_term_ref_pics_sps ; i ++ ) { BITS_PARSE ( ""lt_ref_pic_poc_lsb_sps[i]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ i ] = value ; BITS_PARSE ( ""used_by_curr_pic_lt_sps_flag[i]"" , value , ps_bitstrm , 1 ) ; ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ i ] = value ; } } BITS_PARSE ( ""sps_temporal_mvp_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_sps_temporal_mvp_enable_flag = value ; BITS_PARSE ( ""sps_strong_intra_smoothing_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_strong_intra_smoothing_enable_flag = value ; BITS_PARSE ( ""vui_parameters_present_flag"" , value , ps_bitstrm , 1 ) ; ps_sps -> i1_vui_parameters_present_flag = value ; if ( ps_sps -> i1_vui_parameters_present_flag ) ihevcd_parse_vui_parameters ( ps_bitstrm , & ps_sps -> s_vui_parameters , ps_sps -> i1_sps_max_sub_layers - 1 ) ; BITS_PARSE ( ""sps_extension_flag"" , value , ps_bitstrm , 1 ) ; { WORD32 numerator ; WORD32 ceil_offset ; ceil_offset = ( 1 << ps_sps -> i1_log2_ctb_size ) - 1 ; numerator = ps_sps -> i2_pic_width_in_luma_samples ; ps_sps -> i2_pic_wd_in_ctb = ( ( numerator + ceil_offset ) / ( 1 << ps_sps -> i1_log2_ctb_size ) ) ; numerator = ps_sps -> i2_pic_height_in_luma_samples ; ps_sps -> i2_pic_ht_in_ctb = ( ( numerator + ceil_offset ) / ( 1 << ps_sps -> i1_log2_ctb_size ) ) ; ps_sps -> i4_pic_size_in_ctb = ps_sps -> i2_pic_ht_in_ctb * ps_sps -> i2_pic_wd_in_ctb ; if ( 0 == ps_codec -> i4_sps_done ) ps_codec -> s_parse . i4_next_ctb_indx = ps_sps -> i4_pic_size_in_ctb ; numerator = ps_sps -> i2_pic_width_in_luma_samples ; ps_sps -> i2_pic_wd_in_min_cb = numerator / ( 1 << ps_sps -> i1_log2_min_coding_block_size ) ; numerator = ps_sps -> i2_pic_height_in_luma_samples ; ps_sps -> i2_pic_ht_in_min_cb = numerator / ( 1 << ps_sps -> i1_log2_min_coding_block_size ) ; } if ( ( 0 != ps_codec -> i4_first_pic_done ) && ( ( ps_codec -> i4_wd != ps_sps -> i2_pic_width_in_luma_samples ) || ( ps_codec -> i4_ht != ps_sps -> i2_pic_height_in_luma_samples ) ) ) { ps_codec -> i4_reset_flag = 1 ; ps_codec -> i4_error_code = IVD_RES_CHANGED ; return ( IHEVCD_ERROR_T ) IHEVCD_FAIL ; } { WORD32 disp_wd , disp_ht ; WORD32 crop_unit_x , crop_unit_y ; crop_unit_x = 1 ; crop_unit_y = 1 ; if ( CHROMA_FMT_IDC_YUV420 == ps_sps -> i1_chroma_format_idc ) { crop_unit_x = 2 ; crop_unit_y = 2 ; } disp_wd = ps_sps -> i2_pic_width_in_luma_samples ; disp_wd -= ps_sps -> i2_pic_crop_left_offset * crop_unit_x ; disp_wd -= ps_sps -> i2_pic_crop_right_offset * crop_unit_x ; disp_ht = ps_sps -> i2_pic_height_in_luma_samples ; disp_ht -= ps_sps -> i2_pic_crop_top_offset * crop_unit_y ; disp_ht -= ps_sps -> i2_pic_crop_bottom_offset * crop_unit_y ; if ( ( 0 >= disp_wd ) || ( 0 >= disp_ht ) ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_disp_wd = disp_wd ; ps_codec -> i4_disp_ht = disp_ht ; ps_codec -> i4_wd = ps_sps -> i2_pic_width_in_luma_samples ; ps_codec -> i4_ht = ps_sps -> i2_pic_height_in_luma_samples ; { WORD32 ref_strd ; ref_strd = ALIGN32 ( ps_sps -> i2_pic_width_in_luma_samples + PAD_WD ) ; if ( ps_codec -> i4_strd < ref_strd ) { ps_codec -> i4_strd = ref_strd ; } } if ( 0 == ps_codec -> i4_share_disp_buf ) { if ( ps_codec -> i4_disp_strd < ps_codec -> i4_disp_wd ) { ps_codec -> i4_disp_strd = ps_codec -> i4_disp_wd ; } } else { if ( ps_codec -> i4_disp_strd < ps_codec -> i4_strd ) { ps_codec -> i4_disp_strd = ps_codec -> i4_strd ; } } } ps_codec -> i4_sps_done = 1 ; return ret ; }", + 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; }  = value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }
781,"CWE-416 static void put_crypt_info ( struct fscrypt_info * ci ) { if ( ! ci ) return ;  key_put ( ci -> ci_keyring_key ) ;  crypto_free_skcipher ( ci -> ci_ctfm ) ; kmem_cache_free ( fscrypt_info_cachep , ci ) ; }", ) return ;  crypto_free_skcipher ( ci
782,"CWE-78 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ;  if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox )  { mutt_error ( _ ( ""Badmailboxname"" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , ""INBOX"" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ;  snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes\\""%s\\"""" , subscribe ? """" : ""un"" , path ) ;  if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Erroraddingsubscribedmailbox:%s\\n"" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( ""Subscribingto%s..."" ) , buf ) ; else mutt_message ( _ ( ""Unsubscribingfrom%s..."" ) , buf ) ; imap_munge_mbox_name ( idata , mbox , sizeof ( mbox ) , buf ) ; snprintf ( buf , sizeof ( buf ) , ""%sSUBSCRIBE%s"" , subscribe ? """" : ""UN"" , mbox ) ; if ( imap_exec ( idata , buf , 0 ) < 0 ) goto fail ; imap_unmunge_mbox_name ( idata , mx . mbox ) ; if ( subscribe ) mutt_message ( _ ( ""Subscribedto%s"" ) , mx . mbox ) ; else mutt_message ( _ ( ""Unsubscribedfrom%s"" ) , mx . mbox ) ; FREE ( & mx . mbox ) ; return 0 ; fail : FREE ( & mx . mbox ) ; return - 1 ; }"," ImapMbox mx ; size_t len = 0 ;  errstr ) ; len =  mbox ) , ""%smailboxes""  , subscribe ?  """" : ""un"" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true  ) ; if"
783,"CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ;  if ( key_is_instantiated ( key ) )  seq_printf ( m , "":%zu[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ; }", ; if ( key_is_positive  ( key )
784,"CWE-264 static int read_exceptions ( struct pstore * ps , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) { int r , full = 1 ; for ( ps -> current_area = 0 ; full ; ps -> current_area ++ ) { r = area_io ( ps , READ ) ; if ( r ) return r ; r = insert_exceptions ( ps , callback , callback_context , & full ) ; if ( r ) return r ; } ps -> current_area -- ;  return 0 ;  }", current_area -- ; skip_metadata ( ps ) ;
785,"CWE-189 asmlinkage long sys_oabi_semtimedop ( int semid , struct oabi_sembuf __user * tsops , unsigned nsops , const struct timespec __user * timeout ) { struct sembuf * sops ; struct timespec local_timeout ; long err ; int i ;  if ( nsops < 1 )  return - EINVAL ; sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops ) return - ENOMEM ; err = 0 ; for ( i = 0 ; i < nsops ; i ++ ) { __get_user_error ( sops [ i ] . sem_num , & tsops -> sem_num , err ) ; __get_user_error ( sops [ i ] . sem_op , & tsops -> sem_op , err ) ; __get_user_error ( sops [ i ] . sem_flg , & tsops -> sem_flg , err ) ; tsops ++ ; } if ( timeout ) { err |= copy_from_user ( & local_timeout , timeout , sizeof ( * timeout ) ) ; timeout = & local_timeout ; } if ( err ) { err = - EFAULT ; } else { mm_segment_t fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; err = sys_semtimedop ( semid , sops , nsops , timeout ) ; set_fs ( fs ) ; } kfree ( sops ) ; return err ; }", nsops < 1 || nsops > SEMOPM
786,"CWE-119 int VP8_UVSSE ( MACROBLOCK * x ) { unsigned char * uptr , * vptr ; unsigned char * upred_ptr = ( * ( x -> block [ 16 ] . base_src ) + x -> block [ 16 ] . src ) ; unsigned char * vpred_ptr = ( * ( x -> block [ 20 ] . base_src ) + x -> block [ 20 ] . src ) ; int uv_stride = x -> block [ 16 ] . src_stride ; unsigned int sse1 = 0 ; unsigned int sse2 = 0 ; int mv_row = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . row ; int mv_col = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . col ; int offset ; int pre_stride = x -> e_mbd . pre . uv_stride ; if ( mv_row < 0 ) mv_row -= 1 ; else mv_row += 1 ; if ( mv_col < 0 ) mv_col -= 1 ; else mv_col += 1 ; mv_row /= 2 ; mv_col /= 2 ; offset = ( mv_row >> 3 ) * pre_stride + ( mv_col >> 3 ) ; uptr = x -> e_mbd . pre . u_buffer + offset ; vptr = x -> e_mbd . pre . v_buffer + offset ; if ( ( mv_row | mv_col ) & 7 ) {  vp8_sub_pixel_variance8x8 ( uptr , pre_stride ,  mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ;  vp8_sub_pixel_variance8x8 ( vptr , pre_stride ,  mv_col & 7 , mv_row & 7 , vpred_ptr , uv_stride , & sse1 ) ; sse2 += sse1 ; } else {  vp8_variance8x8 ( uptr , pre_stride ,  upred_ptr , uv_stride , & sse2 ) ;  vp8_variance8x8 ( vptr , pre_stride ,  vpred_ptr , uv_stride , & sse1 ) ; sse2 += sse1 ; } return sse2 ; }"," 7 ) { vpx_sub_pixel_variance8x8  ( uptr ,  sse2 ) ; vpx_sub_pixel_variance8x8  ( vptr ,  } else { vpx_variance8x8  ( uptr ,  sse2 ) ; vpx_variance8x8  ( vptr ,"
787,"CWE-119  static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x ,  int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) { MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;  TX_SIZE uv_txfm_size = get_uv_tx_size ( mbmi ) ;  int plane ; int pnrate = 0 , pnskip = 1 ; int64_t pndist = 0 , pnsse = 0 ;  if ( ref_best_rd < 0 )   goto term ;   if ( is_inter_block ( mbmi ) ) {  int plane ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_subtract_plane ( x , bsize , plane ) ; } * rate = 0 ; * distortion = 0 ; * sse = 0 ; * skippable = 1 ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) { txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse ,  ref_best_rd , plane , bsize , uv_txfm_size ,  cpi -> sf . use_fast_coef_costing ) ; if ( pnrate == INT_MAX )  goto term ;  * rate += pnrate ; * distortion += pndist ; * sse += pnsse ; * skippable &= pnskip ; }  return ;  term : * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; return ; }","   static int  super_block_uvrd ( const  -> mbmi ; const TX_SIZE uv_tx_size  = get_uv_tx_size (  get_uv_tx_size ( mbmi , & xd -> plane [ 1 ]  = 0 ; int is_cost_valid = 1 ;  < 0 ) is_cost_valid = 0  ; if (  ( mbmi ) && is_cost_valid  , bsize , uv_tx_size  , cpi ->  == INT_MAX ) { is_cost_valid = 0 ; break ; }  * rate +=  pnskip ; } if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid  ; } "
788,"CWE-20  int sctp_verify_asconf ( const struct sctp_association * asoc ,   struct sctp_paramhdr * param_hdr , void * chunk_end ,  struct sctp_paramhdr * * errp ) {  sctp_addip_param_t * asconf_param ;  union sctp_params param ;  int length , plen ;   param . v = ( sctp_paramhdr_t * ) param_hdr ;  while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }","    bool  sctp_verify_asconf ( const  asoc , struct sctp_chunk * chunk , bool addr_param_needed  , struct sctp_paramhdr  errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr  ; union sctp_params  sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if (  param . v  param . v != chunk -> chunk_end ) return false ; return true  ; } "
789,"CWE-000 static void http_splitheader ( struct http * hp , int req ) { char * p , * q , * * hh ; int n ; char buf [ 20 ] ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; if ( req ) { memset ( hp -> req , 0 , sizeof hp -> req ) ; hh = hp -> req ; } else { memset ( hp -> resp , 0 , sizeof hp -> resp ) ; hh = hp -> resp ; } n = 0 ; p = hp -> rxbuf ; while ( vct_islws ( * p ) ) p ++ ; hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ;  assert ( ! vct_iscrlf ( * p ) ) ;  * p ++ = '\\0' ; while ( vct_issp ( * p ) ) p ++ ;  assert ( ! vct_iscrlf ( * p ) ) ;  hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ;  if ( vct_iscrlf ( * p ) ) {  hh [ n ++ ] = NULL ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\0' ; } else { * p ++ = '\\0' ; while ( vct_issp ( * p ) ) p ++ ; hh [ n ++ ] = p ;  while ( ! vct_iscrlf ( * p ) )  p ++ ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\0' ; } assert ( n == 3 ) ; while ( * p != '\\0' ) { assert ( n < MAX_HDR ) ;  if ( vct_iscrlf ( * p ) )  break ; hh [ n ++ ] = p ++ ;  while ( * p != '\\0' && ! vct_iscrlf ( * p ) )  p ++ ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\0' ; } p += vct_skipcrlf ( p ) ; assert ( * p == '\\0' ) ; for ( n = 0 ; n < 3 || hh [ n ] != NULL ; n ++ ) { sprintf ( buf , ""http[%2d]"" , n ) ; vtc_dump ( hp -> vl , 4 , buf , hh [ n ] , - 1 ) ; } }", ! vct_iscrlf (  p ) )  ! vct_iscrlf (  p ) )  ( vct_iscrlf (  p ) )  ! vct_iscrlf (  p ) )  ( vct_iscrlf (  p ) )  ! vct_iscrlf (  p ) )
790,"CWE-125 void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ;  spin_lock_irqsave ( & mpu -> input_lock , flags ) ;   while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) !=  readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ;  wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ;  if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }"," + MIDQ_DATA_BUFF ; u16 head , tail , size ;  flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val  , 1 )  1 ) ; if ( ++ head > size ) head = 0 ; writew ( head ,  mpu -> dev  + JQS_wHead ) ; } out :  spin_unlock_irqrestore ( &"
791,"CWE-20 static int handle_pte_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * pte , pmd_t * pmd , unsigned int flags ) { pte_t entry ; spinlock_t * ptl ; entry = * pte ; barrier ( ) ; if ( ! pte_present ( entry ) ) { if ( pte_none ( entry ) ) {  if ( vma -> vm_ops ) {  if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte ,  pmd , flags , entry ) ;  } return do_anonymous_page ( mm , vma , address ,  pte , pmd , flags ) ;  } return do_swap_page ( mm , vma , address , pte , pmd , flags , entry ) ; } if ( pte_protnone ( entry ) ) return do_numa_page ( mm , vma , address , entry , pte , pmd ) ; ptl = pte_lockptr ( mm , pmd ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pte_same ( * pte , entry ) ) ) goto unlock ; if ( flags & FAULT_FLAG_WRITE ) { if ( ! pte_write ( entry ) ) return do_wp_page ( mm , vma , address , pte , pmd , ptl , entry ) ; entry = pte_mkdirty ( entry ) ; } entry = pte_mkyoung ( entry ) ; if ( ptep_set_access_flags ( vma , address , pte , entry , flags & FAULT_FLAG_WRITE ) ) { update_mmu_cache ( vma , address , pte ) ; } else { if ( flags & FAULT_FLAG_WRITE ) flush_tlb_fix_spurious_fault ( vma , address ) ; } unlock : pte_unmap_unlock ( pte , ptl ) ; return 0 ; }"," -> vm_ops )  return do_fault (  , pte , pmd , flags , entry ) ;  return do_anonymous_page (  , address , pte , pmd ,  flags ) ;"
792,"CWE-787 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return __this_address ; switch ( mode & S_IFMT ) { case S_IFIFO : case S_IFCHR : case S_IFBLK : case S_IFSOCK : if ( dip -> di_format != XFS_DINODE_FMT_DEV ) return __this_address ; break ; case S_IFREG : case S_IFLNK : case S_IFDIR :  switch ( dip -> di_format ) {  case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ; if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ; if ( dip -> di_nextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { switch ( dip -> di_aformat ) { case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } } else { switch ( dip -> di_aformat ) { case 0 : case XFS_DINODE_FMT_EXTENTS : break ; default : return __this_address ; } if ( dip -> di_anextents ) return __this_address ; } fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , mode , flags ) ; if ( fa ) return fa ; if ( dip -> di_version < 3 ) return NULL ; flags2 = be64_to_cpu ( dip -> di_flags2 ) ; if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) return __this_address ; fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , mode , flags , flags2 ) ; if ( fa ) return fa ; return NULL ; }"," case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ;  } else {"
793,"CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , ""CLIENT_ERRORbadcommandlineformat"" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; }  it = item_get ( key , nkey , c , DO_UPDATE ) ;  if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , ""SERVER_ERRORoutofmemorymakingCASsuffix"" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , ""VALUE"" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , ""VALUE"" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , "">%dsendingkey"" , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , ""%c"" , key [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , "">%dEND\\n"" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , ""END\\r\\n"" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , ""SERVER_ERRORoutofmemorywritinggetresponse"" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }"," } it = limited_get  ( key ,  nkey , c  ) ; if"
794,"CWE-200 static int hidp_setup_hid ( struct hidp_session * session , struct hidp_connadd_req * req ) { struct hid_device * hid ; int err ; session -> rd_data = kzalloc ( req -> rd_size , GFP_KERNEL ) ; if ( ! session -> rd_data ) return - ENOMEM ; if ( copy_from_user ( session -> rd_data , req -> rd_data , req -> rd_size ) ) { err = - EFAULT ; goto fault ; } session -> rd_size = req -> rd_size ; hid = hid_allocate_device ( ) ; if ( IS_ERR ( hid ) ) { err = PTR_ERR ( hid ) ; goto fault ; } session -> hid = hid ; hid -> driver_data = session ; hid -> bus = BUS_BLUETOOTH ; hid -> vendor = req -> vendor ; hid -> product = req -> product ; hid -> version = req -> version ; hid -> country = req -> country ;  strncpy ( hid -> name , req -> name , 128 ) ;  snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ; snprintf ( hid -> uniq , sizeof ( hid -> uniq ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> dst ) ; hid -> dev . parent = & session -> conn -> dev ; hid -> ll_driver = & hidp_hid_driver ; hid -> hid_get_raw_report = hidp_get_raw_report ; hid -> hid_output_raw_report = hidp_output_raw_report ; if ( hid_ignore ( hid ) ) { hid_destroy_device ( session -> hid ) ; session -> hid = NULL ; return - ENODEV ; } return 0 ; fault : kfree ( session -> rd_data ) ; session -> rd_data = NULL ; return err ; }"," -> name , sizeof ( req -> name ) - 1  ) ; snprintf"
795,"CWE-190  jas_matrix_t * jas_matrix_create ( int numrows , int numcols )  { jas_matrix_t * matrix ;  int i ;  size_t size ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { goto error ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { goto error ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; }"," * jas_matrix_create ( jas_matind_t numrows , jas_matind_t  numcols ) {  * matrix ; jas_matind_t  i ; size_t"
796,"CWE-362 static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode ,  struct ext4_ext_path * path )  {  struct ext4_extent * ex ;  int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ;  ext_debug ( ""ext4_convert_unwritten_extents_endio:inode%lu,logical""  ""block%llu,max_blocks%u\\n"" , inode -> i_ino ,  ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) ,  ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }"," inode , struct ext4_map_blocks * map , struct  ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len  . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ;  long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; }  err = ext4_ext_get_access"
797,"CWE-125 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD"" , 4 ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%sisnotavalid.DFFfile(bytotalsize)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""fileheaderindicatedlength=%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunkheaderindicatedlength=%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdifffileversion=0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) {  char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ;  if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""gotsamplerateof%uHz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefinedchannelID%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%dchannels,mask=0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD"" , 4 ) ) { error_line ( ""DSDIFFfilesmustbeuncompressed,not\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""gotPROP/SNDchunktype\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""thisDSDIFFfilealreadyhaschannelorderinformation!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""gotunknownPROPchunktype\\""%c%c%c%c\\""of%dbytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extraunknownchunk\\""%c%c%c%c\\""of%dbytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""settingconfigurationwith%lldsamples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }"," { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""gotPROPchunkof%dbytestotal"" , ( int ) dff_chunk_header . ckDataSize ) ;"
798,"CWE-200 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ;  int family = sk -> sk_family ;  struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ;  if ( addr_len ) {  if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) {  sin = ( struct sockaddr_in * ) msg -> msg_name ;  sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;  if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ;  sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;  sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;  if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg->%d\\n"" , err ) ; return err ; }", sk -> sk_family  ; struct sk_buff  goto out ;  if ( flags  AF_INET ) { struct sockaddr_in *  ) ) ; * addr_len = sizeof ( * sin ) ;  skb ) ;  struct sockaddr_in6 *  struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 *  ) -> iif ) ; * addr_len = sizeof ( * sin6
799,"CWE-000 static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - EIO ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ;  if ( ! port -> interrupt_in_urb ) {  dev_err ( & port -> dev , ""%s-interrupt_in_urbisempty!\\n"" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev , ""%s-failedsubmittingreadurb,error%d\\n"" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }", tmp_termios ) ;  usb_fill_int_urb ( port
800,"CWE-362 static int packet_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct packet_sock * po = pkt_sk ( sk ) ; int ret ; if ( level != SOL_PACKET ) return - ENOPROTOOPT ; switch ( optname ) { case PACKET_ADD_MEMBERSHIP : case PACKET_DROP_MEMBERSHIP : { struct packet_mreq_max mreq ; int len = optlen ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( len < sizeof ( struct packet_mreq ) ) return - EINVAL ; if ( len > sizeof ( mreq ) ) len = sizeof ( mreq ) ; if ( copy_from_user ( & mreq , optval , len ) ) return - EFAULT ; if ( len < ( mreq . mr_alen + offsetof ( struct packet_mreq , mr_address ) ) ) return - EINVAL ; if ( optname == PACKET_ADD_MEMBERSHIP ) ret = packet_mc_add ( sk , & mreq ) ; else ret = packet_mc_drop ( sk , & mreq ) ; return ret ; } case PACKET_RX_RING : case PACKET_TX_RING : { union tpacket_req_u req_u ; int len ; switch ( po -> tp_version ) { case TPACKET_V1 : case TPACKET_V2 : len = sizeof ( req_u . req ) ; break ; case TPACKET_V3 : default : len = sizeof ( req_u . req3 ) ; break ; } if ( optlen < len ) return - EINVAL ; if ( copy_from_user ( & req_u . req , optval , len ) ) return - EFAULT ; return packet_set_ring ( sk , & req_u , 0 , optname == PACKET_TX_RING ) ; } case PACKET_COPY_THRESH : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; pkt_sk ( sk ) -> copy_thresh = val ; return 0 ; } case PACKET_VERSION : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ;  if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec )   return - EBUSY ;   if ( copy_from_user ( & val , optval , sizeof ( val ) ) )  return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : po -> tp_version = val ;  return 0 ;  default : return - EINVAL ; } } case PACKET_RESERVE : { unsigned int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_reserve = val ; return 0 ; } case PACKET_LOSS : { unsigned int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_loss = ! ! val ; return 0 ; } case PACKET_AUXDATA : { int val ; if ( optlen < sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> auxdata = ! ! val ; return 0 ; } case PACKET_ORIGDEV : { int val ; if ( optlen < sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> origdev = ! ! val ; return 0 ; } case PACKET_VNET_HDR : { int val ; if ( sock -> type != SOCK_RAW ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( optlen < sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> has_vnet_hdr = ! ! val ; return 0 ; } case PACKET_TIMESTAMP : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_tstamp = val ; return 0 ; } case PACKET_FANOUT : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; return fanout_add ( sk , val & 0xffff , val >> 16 ) ; } case PACKET_FANOUT_DATA : { if ( ! po -> fanout ) return - EINVAL ; return fanout_set_data ( po , optval , optlen ) ; } case PACKET_TX_HAS_OFF : { unsigned int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_tx_has_off = ! ! val ; return 0 ; } case PACKET_QDISC_BYPASS : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> xmit = val ? packet_direct_xmit : dev_queue_xmit ; return 0 ; } default : return - ENOPROTOOPT ; } }"," ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if (  . pg_vec ) { ret =  - EBUSY ;  - EBUSY ; } else {  po -> tp_version  = val ; ret = 0 ; } release_sock ( sk ) ; return ret ;  } case PACKET_RESERVE"
801,"CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ;  addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ;   addModuleArgument ( db , pTab , 0 ) ;   addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ;  rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , ""%s"" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1 ; }"," ; addModuleArgument ( pParse  , pTab ,  ; addModuleArgument ( pParse  , pTab ,  ; addModuleArgument ( pParse  , pTab ,"
802,"CWE-284 int send_event ( int fd , uint16_t type , uint16_t code , int32_t value ) { struct uinput_event event ; BTIF_TRACE_DEBUG ( ""%stype:%ucode:%uvalue:%d"" , __FUNCTION__ , type , code , value ) ; memset ( & event , 0 , sizeof ( event ) ) ; event . type = type ; event . code = code ; event . value = value ;  return write ( fd , & event , sizeof ( event ) ) ;  }", value ; return TEMP_FAILURE_RETRY (  event ) ) )
803,"CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , ""8BIM"" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned char * ) NULL ) return 0 ; for ( i = 0 ; i < plen ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } PString [ i ] = ( unsigned char ) c ; } PString [ plen ] = 0 ; if ( ( plen & 0x01 ) == 0 ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } } } count = ( ssize_t ) ReadBlobMSBSignedLong ( ifile ) ; if ( ( count < 0 ) || ( count > GetBlobSize ( ifile ) ) ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; }  str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ;  if ( str == ( unsigned char * ) NULL ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return 0 ; } for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } str [ i ] = ( unsigned char ) c ; } if ( ID != THUMBNAIL_ID ) { if ( strlen ( ( const char * ) PString ) > 0 ) ( void ) FormatLocaleString ( temp , MagickPathExtent , ""8BIM#%d#%s="" , ID , PString ) ; else ( void ) FormatLocaleString ( temp , MagickPathExtent , ""8BIM#%d="" , ID ) ; ( void ) WriteBlobString ( ofile , temp ) ; if ( ID == IPTC_ID ) { formatString ( ofile , ""IPTC"" , 4 ) ; formatIPTCfromBuffer ( ofile , ( char * ) str , ( ssize_t ) count ) ; } else formatString ( ofile , ( char * ) str , ( ssize_t ) count ) ; } str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; resCount ++ ; c = ReadBlobByte ( ifile ) ; } return resCount ; }", size_t ) count + 1
804,"CWE-362 struct dst_entry * inet_csk_route_req ( struct sock * sk , const struct request_sock * req ) { struct rtable * rt ; const struct inet_request_sock * ireq = inet_rsk ( req ) ;  struct ip_options * opt = inet_rsk ( req ) -> opt ;  struct net * net = sock_net ( sk ) ; struct flowi4 fl4 ; flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) ,  ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr ,  ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) goto no_route ;  if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway )  goto route_err ; return & rt -> dst ; route_err : ip_rt_put ( rt ) ; no_route : IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; return NULL ; }", ) ; struct ip_options_rcu  * opt =  && opt -> opt .  ? opt -> opt .  && opt -> opt .
805,"CWE-119 int ParseDateTime ( char * timestr , char * lowstr , char * * field , int * ftype , int * numfields , char * * endstr ) { int nf = 0 ; char * lp = lowstr ; * endstr = timestr ; while ( * ( * endstr ) != '\\0' ) {  field [ nf ] = lp ;  if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == ':' ) { ftype [ nf ] = DTK_TIME ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; * lp ++ = * ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = ( * dp == '.' ) ? DTK_NUMBER : DTK_DATE ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == * dp ) { ftype [ nf ] = DTK_DATE ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == * dp ) ) * lp ++ = * ( * endstr ) ++ ; } } else { ftype [ nf ] = DTK_DATE ; while ( isalnum ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == * dp ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; } } else ftype [ nf ] = DTK_NUMBER ; } else if ( * ( * endstr ) == '.' ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; ftype [ nf ] = DTK_NUMBER ; } else if ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_STRING ; * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; while ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; ftype [ nf ] = DTK_DATE ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || * ( * endstr ) == * dp ) * lp ++ = * ( * endstr ) ++ ; } } else if ( isspace ( ( unsigned char ) * ( * endstr ) ) ) { ( * endstr ) ++ ; continue ; } else if ( * ( * endstr ) == '+' || * ( * endstr ) == '-' ) { * lp ++ = * ( * endstr ) ++ ; while ( isspace ( ( unsigned char ) * ( * endstr ) ) ) ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_TZ ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_SPECIAL ; * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; while ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; } else return - 1 ; } else if ( ispunct ( ( unsigned char ) * ( * endstr ) ) ) { ( * endstr ) ++ ; continue ; } else return - 1 ; * lp ++ = '\\0' ; nf ++ ;  if ( nf > MAXDATEFIELDS )  return - 1 ; } * numfields = nf ; return 0 ; }", ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1  nf ++ ;  } * numfields
806,"CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : {  int a = getnum ( L , fmt , MAXALIGN ) ;  if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment%disnotapowerof2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalidformatoption\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }"," = getnum (  fmt , MAXALIGN"
807,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ;  for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) {  int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , ""n:%"" PRId64 ""pts:%spts_time:%spos:%"" PRId64 """" ""fmt:%ssar:%d/%ds:%dx%di:%ciskey:%dtype:%c"" ""checksum:%08Xplane_checksum:[%08X"" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type_char ( frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ;  for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ )  av_log ( ctx , AV_LOG_INFO , ""%08X"" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , ""]\\n"" ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , frame ) ; }", frame -> data [ plane ] && frame -> linesize  [ plane ] && frame -> linesize [ plane ]
808,"CWE-119 void safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while ( * p != '\\0' ) { if ( try_wc && ( n = mbtowc ( & wc , p , length ) ) != - 1 ) { length -= n ; if ( iswprint ( wc ) && wc != L'\\\\' ) { while ( n -- > 0 ) outbuff [ i ++ ] = * p ++ ; } else { while ( n -- > 0 ) i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; } } else { i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; try_wc = 0 ; }  if ( i > ( sizeof ( outbuff ) - 20 ) ) {  outbuff [ i ] = '\\0' ; fprintf ( f , ""%s"" , outbuff ) ; i = 0 ; } } outbuff [ i ] = '\\0' ; fprintf ( f , ""%s"" , outbuff ) ; free ( fmtbuff_heap ) ; }", outbuff ) - 128  ) ) {
809,"CWE-119  static int test_candidate_kf ( struct twopass_rc * twopass ,  const FIRSTPASS_STATS * last_frame , const FIRSTPASS_STATS * this_frame , const FIRSTPASS_STATS * next_frame ) { int is_viable_kf = 0 ;  if ( ( this_frame -> pcnt_second_ref < 0.10 ) &&   ( next_frame -> pcnt_second_ref < 0.10 ) &&  ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> intra_error /  DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) &&  ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) /  DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) ||  ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) /  DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) ||  ( ( next_frame -> intra_error /  DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) {  int i ; const FIRSTPASS_STATS * start_pos = twopass -> stats_in ; FIRSTPASS_STATS local_next_frame = * next_frame ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; for ( i = 0 ; i < 16 ; ++ i ) {  double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error /  DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ;  if ( next_iiratio > RMAX )  next_iiratio = RMAX ; if ( local_next_frame . pcnt_inter > 0.85 ) decay_accumulator *= local_next_frame . pcnt_inter ; else decay_accumulator *= ( 0.85 + local_next_frame . pcnt_inter ) / 2.0 ; boost_score += ( decay_accumulator * next_iiratio ) ; if ( ( local_next_frame . pcnt_inter < 0.05 ) || ( next_iiratio < 1.5 ) || ( ( ( local_next_frame . pcnt_inter - local_next_frame . pcnt_neutral ) < 0.20 ) && ( next_iiratio < 3.0 ) ) || ( ( boost_score - old_boost_score ) < 3.0 ) || ( local_next_frame . intra_error < 200 ) ) { break ; } old_boost_score = boost_score ; if ( EOF == input_stats ( twopass , & local_next_frame ) ) break ; } if ( boost_score > 30.0 && ( i > 3 ) ) { is_viable_kf = 1 ; } else { reset_fpf_position ( twopass , start_pos ) ; is_viable_kf = 0 ; } } return is_viable_kf ; }"," int test_candidate_kf ( TWO_PASS  * twopass ,  = 0 ; double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ;  -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH  ) && (  -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter )  ) && (  ) ) < KF_II_ERR_THRESHOLD  ) && (  coded_error ) > ERR_CHANGE_THRESHOLD  ) || (  intra_error ) > ERR_CHANGE_THRESHOLD  ) || (  ) ) > II_IMPROVEMENT_THRESHOLD  ) ) )  next_iiratio = ( BOOST_FACTOR  * local_next_frame .  ( next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX  ; if ("
810,"CWE-787 void mp_encode_lua_table_as_array ( lua_State * L , mp_buf * buf , int level ) { # if LUA_VERSION_NUM < 502 size_t len = lua_objlen ( L , - 1 ) , j ; # else size_t len = lua_rawlen ( L , - 1 ) , j ; # endif mp_encode_array ( L , buf , len ) ;  for ( j = 1 ; j <= len ; j ++ ) {  lua_pushnumber ( L , j ) ; lua_gettable ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }"," len ) ; luaL_checkstack ( L , 1 , ""infunctionmp_encode_lua_table_as_array"" ) ;"
811,"CWE-119 php_http_url_t * php_http_url_parse ( const char * str , size_t len , unsigned flags TSRMLS_DC ) {  size_t maxlen = 3 * len ;  struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ; state -> end = str + len ; state -> ptr = str ; state -> flags = flags ; state -> maxlen = maxlen ; TSRMLS_SET_CTX ( state -> ts ) ; if ( ! parse_scheme ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""FailedtoparseURLscheme:\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_hier ( state ) ) { efree ( state ) ; return NULL ; } if ( ! parse_query ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""FailedtoparseURLquery:\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_fragment ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""FailedtoparseURLfragment:\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } return ( php_http_url_t * ) state ; }", 3 * len + 8
812,"CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ;  if ( data -> multi_easy )   curl_multi_cleanup ( data -> multi_easy ) ;  Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }", -> multi_easy ) {  multi_easy ) ; data -> multi_easy = NULL ; }
813,"CWE-125 static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ;  while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) {  u16 wTmp ; snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ;  wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ;   if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) )  writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ;  }  inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }"," + DSPQ_DATA_BUFF ; u16 head , tail , size ; head  = readw (  + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size =  readw ( chip  + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head  , chip ->  ) ; } out :"
814,"CWE-125 PyMODINIT_FUNC PyInit__ast3 ( void ) { PyObject * m , * d ; if ( ! init_types ( ) ) return NULL ;  m = PyModule_Create ( & _astmodule3 ) ;  if ( ! m ) return NULL ; d = PyModule_GetDict ( m ) ; if ( PyDict_SetItemString ( d , ""AST"" , ( PyObject * ) & AST_type ) < 0 ) return NULL ; if ( PyModule_AddIntMacro ( m , PyCF_ONLY_AST ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Module"" , ( PyObject * ) Module_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Interactive"" , ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Expression"" , ( PyObject * ) Expression_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FunctionType"" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""stmt"" , ( PyObject * ) stmt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FunctionDef"" , ( PyObject * ) FunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AsyncFunctionDef"" , ( PyObject * ) AsyncFunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ClassDef"" , ( PyObject * ) ClassDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Return"" , ( PyObject * ) Return_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Delete"" , ( PyObject * ) Delete_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Assign"" , ( PyObject * ) Assign_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AugAssign"" , ( PyObject * ) AugAssign_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AnnAssign"" , ( PyObject * ) AnnAssign_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""For"" , ( PyObject * ) For_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AsyncFor"" , ( PyObject * ) AsyncFor_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""While"" , ( PyObject * ) While_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""If"" , ( PyObject * ) If_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""With"" , ( PyObject * ) With_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AsyncWith"" , ( PyObject * ) AsyncWith_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Raise"" , ( PyObject * ) Raise_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Try"" , ( PyObject * ) Try_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Assert"" , ( PyObject * ) Assert_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Import"" , ( PyObject * ) Import_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ImportFrom"" , ( PyObject * ) ImportFrom_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Global"" , ( PyObject * ) Global_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Nonlocal"" , ( PyObject * ) Nonlocal_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Expr"" , ( PyObject * ) Expr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Pass"" , ( PyObject * ) Pass_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Break"" , ( PyObject * ) Break_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Continue"" , ( PyObject * ) Continue_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""expr"" , ( PyObject * ) expr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BoolOp"" , ( PyObject * ) BoolOp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BinOp"" , ( PyObject * ) BinOp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""UnaryOp"" , ( PyObject * ) UnaryOp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Lambda"" , ( PyObject * ) Lambda_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""IfExp"" , ( PyObject * ) IfExp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Dict"" , ( PyObject * ) Dict_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Set"" , ( PyObject * ) Set_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ListComp"" , ( PyObject * ) ListComp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""SetComp"" , ( PyObject * ) SetComp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""DictComp"" , ( PyObject * ) DictComp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""GeneratorExp"" , ( PyObject * ) GeneratorExp_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Await"" , ( PyObject * ) Await_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Yield"" , ( PyObject * ) Yield_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""YieldFrom"" , ( PyObject * ) YieldFrom_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Compare"" , ( PyObject * ) Compare_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Call"" , ( PyObject * ) Call_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Num"" , ( PyObject * ) Num_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Str"" , ( PyObject * ) Str_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FormattedValue"" , ( PyObject * ) FormattedValue_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""JoinedStr"" , ( PyObject * ) JoinedStr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Bytes"" , ( PyObject * ) Bytes_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NameConstant"" , ( PyObject * ) NameConstant_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Ellipsis"" , ( PyObject * ) Ellipsis_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Constant"" , ( PyObject * ) Constant_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Attribute"" , ( PyObject * ) Attribute_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Subscript"" , ( PyObject * ) Subscript_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Starred"" , ( PyObject * ) Starred_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Name"" , ( PyObject * ) Name_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""List"" , ( PyObject * ) List_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Tuple"" , ( PyObject * ) Tuple_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""expr_context"" , ( PyObject * ) expr_context_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Load"" , ( PyObject * ) Load_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Store"" , ( PyObject * ) Store_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Del"" , ( PyObject * ) Del_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AugLoad"" , ( PyObject * ) AugLoad_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""AugStore"" , ( PyObject * ) AugStore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Param"" , ( PyObject * ) Param_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""slice"" , ( PyObject * ) slice_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Slice"" , ( PyObject * ) Slice_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ExtSlice"" , ( PyObject * ) ExtSlice_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Index"" , ( PyObject * ) Index_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""boolop"" , ( PyObject * ) boolop_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""And"" , ( PyObject * ) And_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Or"" , ( PyObject * ) Or_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""operator"" , ( PyObject * ) operator_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Add"" , ( PyObject * ) Add_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Sub"" , ( PyObject * ) Sub_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Mult"" , ( PyObject * ) Mult_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""MatMult"" , ( PyObject * ) MatMult_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Div"" , ( PyObject * ) Div_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Mod"" , ( PyObject * ) Mod_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Pow"" , ( PyObject * ) Pow_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""LShift"" , ( PyObject * ) LShift_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""RShift"" , ( PyObject * ) RShift_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BitOr"" , ( PyObject * ) BitOr_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BitXor"" , ( PyObject * ) BitXor_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""BitAnd"" , ( PyObject * ) BitAnd_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""FloorDiv"" , ( PyObject * ) FloorDiv_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""unaryop"" , ( PyObject * ) unaryop_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Invert"" , ( PyObject * ) Invert_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Not"" , ( PyObject * ) Not_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""UAdd"" , ( PyObject * ) UAdd_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""USub"" , ( PyObject * ) USub_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""cmpop"" , ( PyObject * ) cmpop_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Eq"" , ( PyObject * ) Eq_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NotEq"" , ( PyObject * ) NotEq_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Lt"" , ( PyObject * ) Lt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""LtE"" , ( PyObject * ) LtE_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Gt"" , ( PyObject * ) Gt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""GtE"" , ( PyObject * ) GtE_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""Is"" , ( PyObject * ) Is_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""IsNot"" , ( PyObject * ) IsNot_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""In"" , ( PyObject * ) In_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""NotIn"" , ( PyObject * ) NotIn_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""comprehension"" , ( PyObject * ) comprehension_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""excepthandler"" , ( PyObject * ) excepthandler_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""ExceptHandler"" , ( PyObject * ) ExceptHandler_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""arguments"" , ( PyObject * ) arguments_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""arg"" , ( PyObject * ) arg_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""keyword"" , ( PyObject * ) keyword_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""alias"" , ( PyObject * ) alias_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""type_ignore"" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""TypeIgnore"" , ( PyObject * ) TypeIgnore_type ) < 0 ) return NULL ; return m ; }", PyModule_Create ( & _astmodule  ) ; if
815,"CWE-362 static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ;  if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) {   spin_lock_irq ( & child -> sighand -> siglock ) ;  WARN_ON_ONCE ( task_is_stopped ( child ) ) ;  if ( ignore_state || ( task_is_traced ( child ) &&  ! ( child -> jobctl & JOBCTL_LISTENING ) ) )  ret = 0 ;  spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ;  if ( ! ret && ! ignore_state )   ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ;  return ret ; }"," ; if (  child -> ptrace  child -> ptrace  && child ->  current ) { WARN_ON ( child -> state == __TASK_TRACED  ) ; if  ( ignore_state || ptrace_freeze_traced ( child  ) ) ret  ret = 0  ; } read_unlock  ! ignore_state ) { if ( !  wait_task_inactive ( child  ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret =  - ESRCH ;  - ESRCH ; } }"
816,"CWE-416 static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ;  kfree ( user ) ;  }", refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
817,"CWE-285 int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) {  error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;  if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ;  if ( error == 0 )  acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }"," { error = posix_acl_update_mode ( inode  , & inode  inode -> i_mode , & acl ) ; if ( error ) return error ;  inode -> i_ctime  inode ) ;  } break ;"
818,"CWE-78 static int download ( struct SPDBDownloader * pd ) { SPDBDownloaderOpt * opt = pd -> opt ;  char * curl_cmd = NULL ;  char * extractor_cmd = NULL ; char * abspath_to_archive = NULL ; char * abspath_to_file = NULL ; char * archive_name = NULL ; size_t archive_name_len = 0 ; char * symbol_store_path = NULL ; char * dbg_file = NULL ; char * guid = NULL ; char * archive_name_escaped = NULL ; char * user_agent = NULL ; char * symbol_server = NULL ; int res = 0 ; int cmd_ret ; if ( ! opt -> dbg_file || ! * opt -> dbg_file ) { return 0 ; }  if ( ! checkCurl ( ) ) {  return 0 ; } archive_name_len = strlen ( opt -> dbg_file ) ; archive_name = malloc ( archive_name_len + 1 ) ; if ( ! archive_name ) { return 0 ; } memcpy ( archive_name , opt -> dbg_file , archive_name_len + 1 ) ; archive_name [ archive_name_len - 1 ] = '_' ;  symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ;  dbg_file = r_str_escape ( opt -> dbg_file ) ; guid = r_str_escape ( opt -> guid ) ; archive_name_escaped = r_str_escape ( archive_name ) ; user_agent = r_str_escape ( opt -> user_agent ) ; symbol_server = r_str_escape ( opt -> symbol_server ) ;  abspath_to_archive = r_str_newf ( ""%s%s%s%s%s%s%s"" ,  symbol_store_path , R_SYS_DIR , dbg_file , R_SYS_DIR , guid , R_SYS_DIR , archive_name_escaped ) ; abspath_to_file = strdup ( abspath_to_archive ) ; abspath_to_file [ strlen ( abspath_to_file ) - 1 ] = 'b' ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( ""Filealreadydownloaded.\\n"" ) ; R_FREE ( user_agent ) ; R_FREE ( abspath_to_archive ) ; R_FREE ( archive_name_escaped ) ; R_FREE ( symbol_store_path ) ; R_FREE ( dbg_file ) ; R_FREE ( guid ) ; R_FREE ( archive_name ) ; R_FREE ( abspath_to_file ) ; R_FREE ( symbol_server ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { res = 1 ; curl_cmd = r_str_newf ( ""curl-sfLA\\""%s\\""\\""%s/%s/%s/%s\\""--create-dirs-o\\""%s\\"""" , user_agent , symbol_server , dbg_file , guid , archive_name_escaped , abspath_to_archive ) ; # if __WINDOWS__ const char * cabextractor = ""expand"" ; const char * format = ""%s%s%s"" ; extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_archive , abspath_to_file ) ; # else  const char * cabextractor = ""cabextract"" ;  const char * format = ""%s-d\\""%s\\""\\""%s\\"""" ; char * abspath_to_dir = r_file_dirname ( abspath_to_archive ) ;  extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_dir , abspath_to_archive ) ;  R_FREE ( abspath_to_dir ) ; # endif  eprintf ( ""Attemptingtodownloadcompressedpdbin%s\\n"" , abspath_to_archive ) ;  if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) { eprintf ( ""curlexitedwitherror%d\\n"" , cmd_ret ) ; res = 0 ; } eprintf ( ""Attemptingtodecompresspdb\\n"" ) ;  if ( opt -> extract > 0 ) {  if ( res && ( ( cmd_ret = r_sys_cmd ( extractor_cmd ) ) != 0 ) ) { eprintf ( ""cabextractorexitedwitherror%d\\n"" , cmd_ret ) ; res = 0 ; } r_file_rm ( abspath_to_archive ) ; }  R_FREE ( curl_cmd ) ;  } if ( res == 0 ) { eprintf ( ""Fallingbacktouncompressedpdb\\n"" ) ;  res = 1 ;  archive_name_escaped [ strlen ( archive_name_escaped ) - 1 ] = 'b' ; curl_cmd = r_str_newf ( ""curl-sfLA\\""%s\\""\\""%s/%s/%s/%s\\""--create-dirs-o\\""%s\\"""" , opt -> user_agent , opt -> symbol_server , opt -> dbg_file , opt -> guid , archive_name_escaped , abspath_to_file ) ; eprintf ( ""Attemptingtodownloaduncompressedpdbin%s\\n"" , abspath_to_file ) ;  if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) {  eprintf ( ""curlexitedwitherror%d\\n"" , cmd_ret ) ; res = 0 ; } R_FREE ( curl_cmd ) ; } R_FREE ( abspath_to_archive ) ; R_FREE ( abspath_to_file ) ; R_FREE ( archive_name ) ; R_FREE ( extractor_cmd ) ; R_FREE ( symbol_store_path ) ; R_FREE ( dbg_file ) ; R_FREE ( guid ) ; R_FREE ( archive_name_escaped ) ; R_FREE ( user_agent ) ; R_FREE ( symbol_server ) ; return res ; }"," -> opt ;  int res =  0 ; } char * abspath_to_file = r_str_newf ( ""%s%s%s%s%s%s%s"" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( ""Filealreadydownloaded.\\n"" ) ; free ( abspath_to_file ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { char * extractor_cmd = NULL ; char * archive_name = strdup ( opt -> dbg_file ) ; archive_name [ strlen ( archive_name )  - 1 ]  = '_' ; char * abspath_to_archive = r_str_newf ( ""%s%s%s%s%s%s%s"" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , archive_name ) ; eprintf ( ""Attemptingtodownloadcompressedpdbin%s\\n"" , abspath_to_archive ) ; char * abs_arch_esc = r_str_escape_sh ( abspath_to_archive ) ; # if __WINDOWS__ char * abs_file_esc = r_str_escape_sh ( abspath_to_file ) ; extractor_cmd  = r_str_newf (  = r_str_newf ( ""expand\\""%s\\""\\""%s\\"""" , abs_arch_esc , abs_file_esc ) ; free ( abs_file_esc  ) ; #  ; # else  char * abspath_to_dir  abspath_to_archive ) ; char * abs_dir_esc = r_str_escape_sh ( abspath_to_dir ) ;  = r_str_newf ( ""cabextract-d\\""%s\\""\\""%s\\"""" , abs_arch_esc , abs_dir_esc ) ; free ( abs_dir_esc ) ; free  ( abspath_to_dir )  ; # endif free ( abs_arch_esc ) ; res = download_and_write ( opt , archive_name  ) ; if  extract > 0 && res ) { eprintf ( ""Attemptingtodecompresspdb\\n"" ) ; if ( res &&  ( ( cmd_ret  ) ; } free ( archive_name ) ; free ( abspath_to_archive  ) ; }  ""Fallingbacktouncompressedpdb\\n"" ) ;  eprintf ( ""Attemptingtodownloaduncompressedpdbin%s\\n""  abspath_to_file ) ; res = download_and_write ( opt , opt -> dbg_file ) ; } free ( abspath_to_file  ) ; return"
819,"CWE-416 PHP_MINIT_FUNCTION ( spl_array ) { REGISTER_SPL_STD_CLASS_EX ( ArrayObject , spl_array_object_new , spl_funcs_ArrayObject ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Aggregate ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Countable ) ; memcpy ( & spl_handler_ArrayObject , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; spl_handler_ArrayObject . clone_obj = spl_array_object_clone ; spl_handler_ArrayObject . read_dimension = spl_array_read_dimension ; spl_handler_ArrayObject . write_dimension = spl_array_write_dimension ; spl_handler_ArrayObject . unset_dimension = spl_array_unset_dimension ; spl_handler_ArrayObject . has_dimension = spl_array_has_dimension ; spl_handler_ArrayObject . count_elements = spl_array_object_count_elements ; spl_handler_ArrayObject . get_properties = spl_array_get_properties ;  spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ;  spl_handler_ArrayObject . read_property = spl_array_read_property ; spl_handler_ArrayObject . write_property = spl_array_write_property ; spl_handler_ArrayObject . get_property_ptr_ptr = spl_array_get_property_ptr_ptr ; spl_handler_ArrayObject . has_property = spl_array_has_property ; spl_handler_ArrayObject . unset_property = spl_array_unset_property ; spl_handler_ArrayObject . compare_objects = spl_array_compare_objects ; REGISTER_SPL_STD_CLASS_EX ( ArrayIterator , spl_array_object_new , spl_funcs_ArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Iterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , SeekableIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Countable ) ; memcpy ( & spl_handler_ArrayIterator , & spl_handler_ArrayObject , sizeof ( zend_object_handlers ) ) ; spl_ce_ArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_SUB_CLASS_EX ( RecursiveArrayIterator , ArrayIterator , spl_array_object_new , spl_funcs_RecursiveArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( RecursiveArrayIterator , RecursiveIterator ) ; spl_ce_RecursiveArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , ""STD_PROP_LIST"" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , ""ARRAY_AS_PROPS"" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , ""STD_PROP_LIST"" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , ""ARRAY_AS_PROPS"" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( RecursiveArrayIterator , ""CHILD_ARRAYS_ONLY"" , SPL_ARRAY_CHILD_ARRAYS_ONLY ) ; return SUCCESS ; }", get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
820,"CWE-401 int i2400m_op_rfkill_sw_toggle ( struct wimax_dev * wimax_dev , enum wimax_rf_state state ) { int result ; struct i2400m * i2400m = wimax_dev_to_i2400m ( wimax_dev ) ; struct device * dev = i2400m_dev ( i2400m ) ; struct sk_buff * ack_skb ; struct { struct i2400m_l3l4_hdr hdr ; struct i2400m_tlv_rf_operation sw_rf ; } __packed * cmd ; char strerr [ 32 ] ; d_fnstart ( 4 , dev , ""(wimax_dev%pstate%d)\\n"" , wimax_dev , state ) ; result = - ENOMEM ; cmd = kzalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; if ( cmd == NULL ) goto error_alloc ; cmd -> hdr . type = cpu_to_le16 ( I2400M_MT_CMD_RF_CONTROL ) ; cmd -> hdr . length = sizeof ( cmd -> sw_rf ) ; cmd -> hdr . version = cpu_to_le16 ( I2400M_L3L4_VERSION ) ; cmd -> sw_rf . hdr . type = cpu_to_le16 ( I2400M_TLV_RF_OPERATION ) ; cmd -> sw_rf . hdr . length = cpu_to_le16 ( sizeof ( cmd -> sw_rf . status ) ) ; switch ( state ) { case WIMAX_RF_OFF : cmd -> sw_rf . status = cpu_to_le32 ( 2 ) ; break ; case WIMAX_RF_ON : cmd -> sw_rf . status = cpu_to_le32 ( 1 ) ; break ; default : BUG ( ) ; } ack_skb = i2400m_msg_to_dev ( i2400m , cmd , sizeof ( * cmd ) ) ; result = PTR_ERR ( ack_skb ) ; if ( IS_ERR ( ack_skb ) ) { dev_err ( dev , ""Failedtoissue\'RFControl\'command:%d\\n"" , result ) ; goto error_msg_to_dev ; } result = i2400m_msg_check_status ( wimax_msg_data ( ack_skb ) , strerr , sizeof ( strerr ) ) ; if ( result < 0 ) { dev_err ( dev , ""\'RFControl\'(0x%04x)commandfailed:%d-%s\\n"" , I2400M_MT_CMD_RF_CONTROL , result , strerr ) ; goto error_cmd ; } result = wait_event_timeout ( i2400m -> state_wq , i2400m_radio_is ( i2400m , state ) , 5 * HZ ) ; if ( result == 0 ) result = - ETIMEDOUT ; if ( result < 0 ) dev_err ( dev , ""ErrorwaitingfordevicetotoggleRFstate:"" ""%d\\n"" , result ) ; result = 0 ; error_cmd :  kfree ( cmd ) ;  kfree_skb ( ack_skb ) ; error_msg_to_dev : error_alloc : d_fnend ( 4 , dev , ""(wimax_dev%pstate%d)=%d\\n"" , wimax_dev , state , result ) ; return result ; }"," ; error_cmd : kfree_skb ( ack_skb ) ; error_msg_to_dev : error_alloc : d_fnend ( 4 , dev , ""(wimax_dev%pstate%d)=%d\\n"" , wimax_dev , state , result ) ;  kfree ( cmd  ) ; return"
821,"CWE-476 static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , ""tune"" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , ""ERROR"" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , ""ERRORhotandwarmpctsmustnotexceed80"" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , ""ERRORhot/warmagefactorsmustbegreaterthan0"" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , ""OK"" ) ; } }  } else if ( strcmp ( tokens [ 1 ] . value , ""mode"" ) == 0 && ntokens >= 3 &&  settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , ""flat"" ) == 0 ) { settings . lru_segmented = false ; out_string ( c , ""OK"" ) ; } else if ( strcmp ( tokens [ 2 ] . value , ""segmented"" ) == 0 ) { settings . lru_segmented = true ; out_string ( c , ""OK"" ) ; } else { out_string ( c , ""ERROR"" ) ; }  } else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 &&  settings . lru_maintainer_thread ) { if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { out_string ( c , ""ERROR"" ) ; } else { if ( ttl < 0 ) { settings . temp_lru = false ; } else { settings . temp_lru = true ; settings . temporary_ttl = ttl ; } out_string ( c , ""OK"" ) ; } } else { out_string ( c , ""ERROR"" ) ; } }", && ntokens >= 4  && settings .  && ntokens >= 4  && settings .
822,"CWE-476 rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ;  ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;  if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( ""Software\\\\FreeRDP\\\\Server"" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( ""SspiModule"" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( ""SspiModule"" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( ""UsingSSPIModule:%s\\n"" ) , credssp -> SspiModule ) ; RegCloseKey ( hKey ) ; } } } } } return credssp ; }", ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context
823,"CWE-119 static void copy_fields ( const FieldMatchContext * fm , AVFrame * dst , const AVFrame * src , int field ) { int plane ;  for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ )  av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ; }", src -> data [ plane ] && src -> linesize
824,"CWE-476 int sqlite3ExprCodeTarget ( Parse * pParse , Expr * pExpr , int target ) { Vdbe * v = pParse -> pVdbe ; int op ; int inReg = target ; int regFree1 = 0 ; int regFree2 = 0 ; int r1 , r2 ; Expr tempX ; int p5 = 0 ; assert ( target > 0 && target <= pParse -> nMem ) ; if ( v == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return 0 ; } expr_code_doover : if ( pExpr == 0 ) { op = TK_NULL ; } else { op = pExpr -> op ; } switch ( op ) { case TK_AGG_COLUMN : { AggInfo * pAggInfo = pExpr -> pAggInfo ; struct AggInfo_col * pCol = & pAggInfo -> aCol [ pExpr -> iAgg ] ; if ( ! pAggInfo -> directMode ) { assert ( pCol -> iMem > 0 ) ; return pCol -> iMem ; } else if ( pAggInfo -> useSortingIdx ) { sqlite3VdbeAddOp3 ( v , OP_Column , pAggInfo -> sortingIdxPTab , pCol -> iSorterColumn , target ) ; return target ; } } case TK_COLUMN : { int iTab = pExpr -> iTable ; if ( ExprHasProperty ( pExpr , EP_FixedCol ) ) { int iReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ;  int aff = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;  if ( aff > SQLITE_AFF_BLOB ) { static const char zAff [ ] = ""B\\000C\\000D\\000E"" ; assert ( SQLITE_AFF_BLOB == 'A' ) ; assert ( SQLITE_AFF_TEXT == 'B' ) ; if ( iReg != target ) { sqlite3VdbeAddOp2 ( v , OP_SCopy , iReg , target ) ; iReg = target ; } sqlite3VdbeAddOp4 ( v , OP_Affinity , iReg , 1 , 0 , & zAff [ ( aff - 'B' ) * 2 ] , P4_STATIC ) ; } return iReg ; } if ( iTab < 0 ) { if ( pParse -> iSelfTab < 0 ) { Column * pCol ; Table * pTab = pExpr -> y . pTab ; int iSrc ; int iCol = pExpr -> iColumn ; assert ( pTab != 0 ) ; assert ( iCol >= XN_ROWID ) ; assert ( iCol < pExpr -> y . pTab -> nCol ) ; if ( iCol < 0 ) { return - 1 - pParse -> iSelfTab ; } pCol = pTab -> aCol + iCol ; testcase ( iCol != sqlite3TableColumnToStorage ( pTab , iCol ) ) ; iSrc = sqlite3TableColumnToStorage ( pTab , iCol ) - pParse -> iSelfTab ; # ifndef SQLITE_OMIT_GENERATED_COLUMNS if ( pCol -> colFlags & COLFLAG_GENERATED ) { if ( pCol -> colFlags & COLFLAG_BUSY ) { sqlite3ErrorMsg ( pParse , ""generatedcolumnloopon\\""%s\\"""" , pCol -> zName ) ; return 0 ; } pCol -> colFlags |= COLFLAG_BUSY ; if ( pCol -> colFlags & COLFLAG_NOTAVAIL ) { sqlite3ExprCodeGeneratedColumn ( pParse , pCol , iSrc ) ; } pCol -> colFlags &= ~ ( COLFLAG_BUSY | COLFLAG_NOTAVAIL ) ; return iSrc ; } else # endif if ( pCol -> affinity == SQLITE_AFF_REAL ) { sqlite3VdbeAddOp2 ( v , OP_SCopy , iSrc , target ) ; sqlite3VdbeAddOp1 ( v , OP_RealAffinity , target ) ; return target ; } else { return iSrc ; } } else { iTab = pParse -> iSelfTab - 1 ; } } return sqlite3ExprCodeGetColumn ( pParse , pExpr -> y . pTab , pExpr -> iColumn , iTab , target , pExpr -> op2 ) ; } case TK_INTEGER : { codeInteger ( pParse , pExpr , 0 , target ) ; return target ; } case TK_TRUEFALSE : { sqlite3VdbeAddOp2 ( v , OP_Integer , sqlite3ExprTruthValue ( pExpr ) , target ) ; return target ; } # ifndef SQLITE_OMIT_FLOATING_POINT case TK_FLOAT : { assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; codeReal ( v , pExpr -> u . zToken , 0 , target ) ; return target ; } # endif case TK_STRING : { assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; sqlite3VdbeLoadString ( v , target , pExpr -> u . zToken ) ; return target ; } case TK_NULL : { sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; return target ; } # ifndef SQLITE_OMIT_BLOB_LITERAL case TK_BLOB : { int n ; const char * z ; char * zBlob ; assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; assert ( pExpr -> u . zToken [ 0 ] == 'x' || pExpr -> u . zToken [ 0 ] == 'X' ) ; assert ( pExpr -> u . zToken [ 1 ] == '\\'' ) ; z = & pExpr -> u . zToken [ 2 ] ; n = sqlite3Strlen30 ( z ) - 1 ; assert ( z [ n ] == '\\'' ) ; zBlob = sqlite3HexToBlob ( sqlite3VdbeDb ( v ) , z , n ) ; sqlite3VdbeAddOp4 ( v , OP_Blob , n / 2 , target , 0 , zBlob , P4_DYNAMIC ) ; return target ; } # endif case TK_VARIABLE : { assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; assert ( pExpr -> u . zToken != 0 ) ; assert ( pExpr -> u . zToken [ 0 ] != 0 ) ; sqlite3VdbeAddOp2 ( v , OP_Variable , pExpr -> iColumn , target ) ; if ( pExpr -> u . zToken [ 1 ] != 0 ) { const char * z = sqlite3VListNumToName ( pParse -> pVList , pExpr -> iColumn ) ; assert ( pExpr -> u . zToken [ 0 ] == '?' || strcmp ( pExpr -> u . zToken , z ) == 0 ) ; pParse -> pVList [ 0 ] = 0 ; sqlite3VdbeAppendP4 ( v , ( char * ) z , P4_STATIC ) ; } return target ; } case TK_REGISTER : { return pExpr -> iTable ; } # ifndef SQLITE_OMIT_CAST case TK_CAST : { inReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ; if ( inReg != target ) { sqlite3VdbeAddOp2 ( v , OP_SCopy , inReg , target ) ; inReg = target ; } sqlite3VdbeAddOp2 ( v , OP_Cast , target , sqlite3AffinityType ( pExpr -> u . zToken , 0 ) ) ; return inReg ; } # endif case TK_IS : case TK_ISNOT : op = ( op == TK_IS ) ? TK_EQ : TK_NE ; p5 = SQLITE_NULLEQ ; case TK_LT : case TK_LE : case TK_GT : case TK_GE : case TK_NE : case TK_EQ : { Expr * pLeft = pExpr -> pLeft ; if ( sqlite3ExprIsVector ( pLeft ) ) { codeVectorCompare ( pParse , pExpr , target , op , p5 ) ; } else { r1 = sqlite3ExprCodeTemp ( pParse , pLeft , & regFree1 ) ; r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; codeCompare ( pParse , pLeft , pExpr -> pRight , op , r1 , r2 , inReg , SQLITE_STOREP2 | p5 , ExprHasProperty ( pExpr , EP_Commuted ) ) ; assert ( TK_LT == OP_Lt ) ; testcase ( op == OP_Lt ) ; VdbeCoverageIf ( v , op == OP_Lt ) ; assert ( TK_LE == OP_Le ) ; testcase ( op == OP_Le ) ; VdbeCoverageIf ( v , op == OP_Le ) ; assert ( TK_GT == OP_Gt ) ; testcase ( op == OP_Gt ) ; VdbeCoverageIf ( v , op == OP_Gt ) ; assert ( TK_GE == OP_Ge ) ; testcase ( op == OP_Ge ) ; VdbeCoverageIf ( v , op == OP_Ge ) ; assert ( TK_EQ == OP_Eq ) ; testcase ( op == OP_Eq ) ; VdbeCoverageIf ( v , op == OP_Eq ) ; assert ( TK_NE == OP_Ne ) ; testcase ( op == OP_Ne ) ; VdbeCoverageIf ( v , op == OP_Ne ) ; testcase ( regFree1 == 0 ) ; testcase ( regFree2 == 0 ) ; } break ; } case TK_AND : case TK_OR : case TK_PLUS : case TK_STAR : case TK_MINUS : case TK_REM : case TK_BITAND : case TK_BITOR : case TK_SLASH : case TK_LSHIFT : case TK_RSHIFT : case TK_CONCAT : { assert ( TK_AND == OP_And ) ; testcase ( op == TK_AND ) ; assert ( TK_OR == OP_Or ) ; testcase ( op == TK_OR ) ; assert ( TK_PLUS == OP_Add ) ; testcase ( op == TK_PLUS ) ; assert ( TK_MINUS == OP_Subtract ) ; testcase ( op == TK_MINUS ) ; assert ( TK_REM == OP_Remainder ) ; testcase ( op == TK_REM ) ; assert ( TK_BITAND == OP_BitAnd ) ; testcase ( op == TK_BITAND ) ; assert ( TK_BITOR == OP_BitOr ) ; testcase ( op == TK_BITOR ) ; assert ( TK_SLASH == OP_Divide ) ; testcase ( op == TK_SLASH ) ; assert ( TK_LSHIFT == OP_ShiftLeft ) ; testcase ( op == TK_LSHIFT ) ; assert ( TK_RSHIFT == OP_ShiftRight ) ; testcase ( op == TK_RSHIFT ) ; assert ( TK_CONCAT == OP_Concat ) ; testcase ( op == TK_CONCAT ) ; r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pRight , & regFree2 ) ; sqlite3VdbeAddOp3 ( v , op , r2 , r1 , target ) ; testcase ( regFree1 == 0 ) ; testcase ( regFree2 == 0 ) ; break ; } case TK_UMINUS : { Expr * pLeft = pExpr -> pLeft ; assert ( pLeft ) ; if ( pLeft -> op == TK_INTEGER ) { codeInteger ( pParse , pLeft , 1 , target ) ; return target ; # ifndef SQLITE_OMIT_FLOATING_POINT } else if ( pLeft -> op == TK_FLOAT ) { assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; codeReal ( v , pLeft -> u . zToken , 1 , target ) ; return target ; # endif } else { tempX . op = TK_INTEGER ; tempX . flags = EP_IntValue | EP_TokenOnly ; tempX . u . iValue = 0 ; r1 = sqlite3ExprCodeTemp ( pParse , & tempX , & regFree1 ) ; r2 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree2 ) ; sqlite3VdbeAddOp3 ( v , OP_Subtract , r2 , r1 , target ) ; testcase ( regFree2 == 0 ) ; } break ; } case TK_BITNOT : case TK_NOT : { assert ( TK_BITNOT == OP_BitNot ) ; testcase ( op == TK_BITNOT ) ; assert ( TK_NOT == OP_Not ) ; testcase ( op == TK_NOT ) ; r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; testcase ( regFree1 == 0 ) ; sqlite3VdbeAddOp2 ( v , op , r1 , inReg ) ; break ; } case TK_TRUTH : { int isTrue ; int bNormal ; r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; testcase ( regFree1 == 0 ) ; isTrue = sqlite3ExprTruthValue ( pExpr -> pRight ) ; bNormal = pExpr -> op2 == TK_IS ; testcase ( isTrue && bNormal ) ; testcase ( ! isTrue && bNormal ) ; sqlite3VdbeAddOp4Int ( v , OP_IsTrue , r1 , inReg , ! isTrue , isTrue ^ bNormal ) ; break ; } case TK_ISNULL : case TK_NOTNULL : { int addr ; assert ( TK_ISNULL == OP_IsNull ) ; testcase ( op == TK_ISNULL ) ; assert ( TK_NOTNULL == OP_NotNull ) ; testcase ( op == TK_NOTNULL ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , target ) ; r1 = sqlite3ExprCodeTemp ( pParse , pExpr -> pLeft , & regFree1 ) ; testcase ( regFree1 == 0 ) ; addr = sqlite3VdbeAddOp1 ( v , op , r1 ) ; VdbeCoverageIf ( v , op == TK_ISNULL ) ; VdbeCoverageIf ( v , op == TK_NOTNULL ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 0 , target ) ; sqlite3VdbeJumpHere ( v , addr ) ; break ; } case TK_AGG_FUNCTION : { AggInfo * pInfo = pExpr -> pAggInfo ; if ( pInfo == 0 ) { assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; sqlite3ErrorMsg ( pParse , ""misuseofaggregate:%s()"" , pExpr -> u . zToken ) ; } else { return pInfo -> aFunc [ pExpr -> iAgg ] . iMem ; } break ; } case TK_FUNCTION : { ExprList * pFarg ; int nFarg ; FuncDef * pDef ; const char * zId ; u32 constMask = 0 ; int i ; sqlite3 * db = pParse -> db ; u8 enc = ENC ( db ) ; CollSeq * pColl = 0 ; # ifndef SQLITE_OMIT_WINDOWFUNC if ( ExprHasProperty ( pExpr , EP_WinFunc ) ) { return pExpr -> y . pWin -> regResult ; } # endif if ( ConstFactorOk ( pParse ) && sqlite3ExprIsConstantNotJoin ( pExpr ) ) { return sqlite3ExprCodeAtInit ( pParse , pExpr , - 1 ) ; } assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) ) ; if ( ExprHasProperty ( pExpr , EP_TokenOnly ) ) { pFarg = 0 ; } else { pFarg = pExpr -> x . pList ; } nFarg = pFarg ? pFarg -> nExpr : 0 ; assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; zId = pExpr -> u . zToken ; pDef = sqlite3FindFunction ( db , zId , nFarg , enc , 0 ) ; # ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION if ( pDef == 0 && pParse -> explain ) { pDef = sqlite3FindFunction ( db , ""unknown"" , nFarg , enc , 0 ) ; } # endif if ( pDef == 0 || pDef -> xFinalize != 0 ) { sqlite3ErrorMsg ( pParse , ""unknownfunction:%s()"" , zId ) ; break ; } if ( pDef -> funcFlags & SQLITE_FUNC_COALESCE ) { int endCoalesce = sqlite3VdbeMakeLabel ( pParse ) ; assert ( nFarg >= 2 ) ; sqlite3ExprCode ( pParse , pFarg -> a [ 0 ] . pExpr , target ) ; for ( i = 1 ; i < nFarg ; i ++ ) { sqlite3VdbeAddOp2 ( v , OP_NotNull , target , endCoalesce ) ; VdbeCoverage ( v ) ; sqlite3ExprCode ( pParse , pFarg -> a [ i ] . pExpr , target ) ; } sqlite3VdbeResolveLabel ( v , endCoalesce ) ; break ; } if ( pDef -> funcFlags & SQLITE_FUNC_UNLIKELY ) { assert ( nFarg >= 1 ) ; return sqlite3ExprCodeTarget ( pParse , pFarg -> a [ 0 ] . pExpr , target ) ; } # ifdef SQLITE_DEBUG if ( pDef -> funcFlags & SQLITE_FUNC_AFFINITY ) { const char * azAff [ ] = { ""blob"" , ""text"" , ""numeric"" , ""integer"" , ""real"" } ; char aff ; assert ( nFarg == 1 ) ; aff = sqlite3ExprAffinity ( pFarg -> a [ 0 ] . pExpr ) ; sqlite3VdbeLoadString ( v , target , ( aff <= SQLITE_AFF_NONE ) ? ""none"" : azAff [ aff - SQLITE_AFF_BLOB ] ) ; return target ; } # endif for ( i = 0 ; i < nFarg ; i ++ ) { if ( i < 32 && sqlite3ExprIsConstant ( pFarg -> a [ i ] . pExpr ) ) { testcase ( i == 31 ) ; constMask |= MASKBIT32 ( i ) ; } if ( ( pDef -> funcFlags & SQLITE_FUNC_NEEDCOLL ) != 0 && ! pColl ) { pColl = sqlite3ExprCollSeq ( pParse , pFarg -> a [ i ] . pExpr ) ; } } if ( pFarg ) { if ( constMask ) { r1 = pParse -> nMem + 1 ; pParse -> nMem += nFarg ; } else { r1 = sqlite3GetTempRange ( pParse , nFarg ) ; } if ( ( pDef -> funcFlags & ( SQLITE_FUNC_LENGTH | SQLITE_FUNC_TYPEOF ) ) != 0 ) { u8 exprOp ; assert ( nFarg == 1 ) ; assert ( pFarg -> a [ 0 ] . pExpr != 0 ) ; exprOp = pFarg -> a [ 0 ] . pExpr -> op ; if ( exprOp == TK_COLUMN || exprOp == TK_AGG_COLUMN ) { assert ( SQLITE_FUNC_LENGTH == OPFLAG_LENGTHARG ) ; assert ( SQLITE_FUNC_TYPEOF == OPFLAG_TYPEOFARG ) ; testcase ( pDef -> funcFlags & OPFLAG_LENGTHARG ) ; pFarg -> a [ 0 ] . pExpr -> op2 = pDef -> funcFlags & ( OPFLAG_LENGTHARG | OPFLAG_TYPEOFARG ) ; } } sqlite3ExprCodeExprList ( pParse , pFarg , r1 , 0 , SQLITE_ECEL_DUP | SQLITE_ECEL_FACTOR ) ; } else { r1 = 0 ; } # ifndef SQLITE_OMIT_VIRTUALTABLE if ( nFarg >= 2 && ExprHasProperty ( pExpr , EP_InfixFunc ) ) { pDef = sqlite3VtabOverloadFunction ( db , pDef , nFarg , pFarg -> a [ 1 ] . pExpr ) ; } else if ( nFarg > 0 ) { pDef = sqlite3VtabOverloadFunction ( db , pDef , nFarg , pFarg -> a [ 0 ] . pExpr ) ; } # endif if ( pDef -> funcFlags & SQLITE_FUNC_NEEDCOLL ) { if ( ! pColl ) pColl = db -> pDfltColl ; sqlite3VdbeAddOp4 ( v , OP_CollSeq , 0 , 0 , 0 , ( char * ) pColl , P4_COLLSEQ ) ; } # ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC if ( pDef -> funcFlags & SQLITE_FUNC_OFFSET ) { Expr * pArg = pFarg -> a [ 0 ] . pExpr ; if ( pArg -> op == TK_COLUMN ) { sqlite3VdbeAddOp3 ( v , OP_Offset , pArg -> iTable , pArg -> iColumn , target ) ; } else { sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; } } else # endif { sqlite3VdbeAddFunctionCall ( pParse , constMask , r1 , target , nFarg , pDef , pExpr -> op2 ) ; } if ( nFarg && constMask == 0 ) { sqlite3ReleaseTempRange ( pParse , r1 , nFarg ) ; } return target ; } # ifndef SQLITE_OMIT_SUBQUERY case TK_EXISTS : case TK_SELECT : { int nCol ; testcase ( op == TK_EXISTS ) ; testcase ( op == TK_SELECT ) ; if ( op == TK_SELECT && ( nCol = pExpr -> x . pSelect -> pEList -> nExpr ) != 1 ) { sqlite3SubselectError ( pParse , nCol , 1 ) ; } else { return sqlite3CodeSubselect ( pParse , pExpr ) ; } break ; } case TK_SELECT_COLUMN : { int n ; if ( pExpr -> pLeft -> iTable == 0 ) { pExpr -> pLeft -> iTable = sqlite3CodeSubselect ( pParse , pExpr -> pLeft ) ; } assert ( pExpr -> iTable == 0 || pExpr -> pLeft -> op == TK_SELECT ) ; if ( pExpr -> iTable != 0 && pExpr -> iTable != ( n = sqlite3ExprVectorSize ( pExpr -> pLeft ) ) ) { sqlite3ErrorMsg ( pParse , ""%dcolumnsassigned%dvalues"" , pExpr -> iTable , n ) ; } return pExpr -> pLeft -> iTable + pExpr -> iColumn ; } case TK_IN : { int destIfFalse = sqlite3VdbeMakeLabel ( pParse ) ; int destIfNull = sqlite3VdbeMakeLabel ( pParse ) ; sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; sqlite3ExprCodeIN ( pParse , pExpr , destIfFalse , destIfNull ) ; sqlite3VdbeAddOp2 ( v , OP_Integer , 1 , target ) ; sqlite3VdbeResolveLabel ( v , destIfFalse ) ; sqlite3VdbeAddOp2 ( v , OP_AddImm , target , 0 ) ; sqlite3VdbeResolveLabel ( v , destIfNull ) ; return target ; } # endif case TK_BETWEEN : { exprCodeBetween ( pParse , pExpr , target , 0 , 0 ) ; return target ; } case TK_SPAN : case TK_COLLATE : case TK_UPLUS : { pExpr = pExpr -> pLeft ; goto expr_code_doover ; } case TK_TRIGGER : { Table * pTab = pExpr -> y . pTab ; int iCol = pExpr -> iColumn ; int p1 = pExpr -> iTable * ( pTab -> nCol + 1 ) + 1 + ( iCol >= 0 ? sqlite3TableColumnToStorage ( pTab , iCol ) : - 1 ) ; assert ( pExpr -> iTable == 0 || pExpr -> iTable == 1 ) ; assert ( iCol >= - 1 && iCol < pTab -> nCol ) ; assert ( pTab -> iPKey < 0 || iCol != pTab -> iPKey ) ; assert ( p1 >= 0 && p1 < ( pTab -> nCol * 2 + 2 ) ) ; sqlite3VdbeAddOp2 ( v , OP_Param , p1 , target ) ; VdbeComment ( ( v , ""r[%d]=%s.%s"" , target , ( pExpr -> iTable ? ""new"" : ""old"" ) , ( pExpr -> iColumn < 0 ? ""rowid"" : pExpr -> y . pTab -> aCol [ iCol ] . zName ) ) ) ; # ifndef SQLITE_OMIT_FLOATING_POINT if ( iCol >= 0 && pTab -> aCol [ iCol ] . affinity == SQLITE_AFF_REAL ) { sqlite3VdbeAddOp1 ( v , OP_RealAffinity , target ) ; } # endif break ; } case TK_VECTOR : { sqlite3ErrorMsg ( pParse , ""rowvaluemisused"" ) ; break ; } case TK_IF_NULL_ROW : { int addrINR ; u8 okConstFactor = pParse -> okConstFactor ; addrINR = sqlite3VdbeAddOp1 ( v , OP_IfNullRow , pExpr -> iTable ) ; pParse -> okConstFactor = 0 ; inReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ; pParse -> okConstFactor = okConstFactor ; sqlite3VdbeJumpHere ( v , addrINR ) ; sqlite3VdbeChangeP3 ( v , addrINR , inReg ) ; break ; } default : assert ( op == TK_CASE ) ; { int endLabel ; int nextCase ; int nExpr ; int i ; ExprList * pEList ; struct ExprList_item * aListelem ; Expr opCompare ; Expr * pX ; Expr * pTest = 0 ; Expr * pDel = 0 ; sqlite3 * db = pParse -> db ; assert ( ! ExprHasProperty ( pExpr , EP_xIsSelect ) && pExpr -> x . pList ) ; assert ( pExpr -> x . pList -> nExpr > 0 ) ; pEList = pExpr -> x . pList ; aListelem = pEList -> a ; nExpr = pEList -> nExpr ; endLabel = sqlite3VdbeMakeLabel ( pParse ) ; if ( ( pX = pExpr -> pLeft ) != 0 ) { pDel = sqlite3ExprDup ( db , pX , 0 ) ; if ( db -> mallocFailed ) { sqlite3ExprDelete ( db , pDel ) ; break ; } testcase ( pX -> op == TK_COLUMN ) ; exprToRegister ( pDel , exprCodeVector ( pParse , pDel , & regFree1 ) ) ; testcase ( regFree1 == 0 ) ; memset ( & opCompare , 0 , sizeof ( opCompare ) ) ; opCompare . op = TK_EQ ; opCompare . pLeft = pDel ; pTest = & opCompare ; regFree1 = 0 ; } for ( i = 0 ; i < nExpr - 1 ; i = i + 2 ) { if ( pX ) { assert ( pTest != 0 ) ; opCompare . pRight = aListelem [ i ] . pExpr ; } else { pTest = aListelem [ i ] . pExpr ; } nextCase = sqlite3VdbeMakeLabel ( pParse ) ; testcase ( pTest -> op == TK_COLUMN ) ; sqlite3ExprIfFalse ( pParse , pTest , nextCase , SQLITE_JUMPIFNULL ) ; testcase ( aListelem [ i + 1 ] . pExpr -> op == TK_COLUMN ) ; sqlite3ExprCode ( pParse , aListelem [ i + 1 ] . pExpr , target ) ; sqlite3VdbeGoto ( v , endLabel ) ; sqlite3VdbeResolveLabel ( v , nextCase ) ; } if ( ( nExpr & 1 ) != 0 ) { sqlite3ExprCode ( pParse , pEList -> a [ nExpr - 1 ] . pExpr , target ) ; } else { sqlite3VdbeAddOp2 ( v , OP_Null , 0 , target ) ; } sqlite3ExprDelete ( db , pDel ) ; sqlite3VdbeResolveLabel ( v , endLabel ) ; break ; } # ifndef SQLITE_OMIT_TRIGGER case TK_RAISE : { assert ( pExpr -> affExpr == OE_Rollback || pExpr -> affExpr == OE_Abort || pExpr -> affExpr == OE_Fail || pExpr -> affExpr == OE_Ignore ) ; if ( ! pParse -> pTriggerTab ) { sqlite3ErrorMsg ( pParse , ""RAISE()mayonlybeusedwithinatrigger-program"" ) ; return 0 ; } if ( pExpr -> affExpr == OE_Abort ) { sqlite3MayAbort ( pParse ) ; } assert ( ! ExprHasProperty ( pExpr , EP_IntValue ) ) ; if ( pExpr -> affExpr == OE_Ignore ) { sqlite3VdbeAddOp4 ( v , OP_Halt , SQLITE_OK , OE_Ignore , 0 , pExpr -> u . zToken , 0 ) ; VdbeCoverage ( v ) ; } else { sqlite3HaltConstraint ( pParse , SQLITE_CONSTRAINT_TRIGGER , pExpr -> affExpr , pExpr -> u . zToken , 0 , 0 ) ; } break ; } # endif } sqlite3ReleaseTempReg ( pParse , regFree1 ) ; sqlite3ReleaseTempReg ( pParse , regFree2 ) ; return inReg ; }", ; int aff ; if ( pExpr -> y . pTab ) { aff  iColumn ) ; } else { aff = pExpr -> affExpr ; }
825,"CWE-362 void inet_sock_destruct ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; __skb_queue_purge ( & sk -> sk_error_queue ) ; sk_mem_reclaim ( sk ) ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state != TCP_CLOSE ) { pr_err ( ""AttempttoreleaseTCPsocketinstate%d%p\\n"" , sk -> sk_state , sk ) ; return ; } if ( ! sock_flag ( sk , SOCK_DEAD ) ) { pr_err ( ""Attempttoreleasealiveinetsocket%p\\n"" , sk ) ; return ; } WARN_ON ( atomic_read ( & sk -> sk_rmem_alloc ) ) ; WARN_ON ( atomic_read ( & sk -> sk_wmem_alloc ) ) ; WARN_ON ( sk -> sk_wmem_queued ) ; WARN_ON ( sk -> sk_forward_alloc ) ;  kfree ( inet -> opt ) ;  dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }"," ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 )  ) ; dst_release"
826,"CWE-125 static identifier new_identifier ( const char * n , struct compiling * c ) { PyObject * id = PyUnicode_DecodeUTF8 ( n , strlen ( n ) , NULL ) ; if ( ! id ) return NULL ; assert ( PyUnicode_IS_READY ( id ) ) ; if ( ! PyUnicode_IS_ASCII ( id ) ) { PyObject * id2 ;  if ( ! c -> c_normalize && ! init_normalization ( c ) ) {  Py_DECREF ( id ) ; return NULL ; }  PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , id ) ;   id2 = PyObject_Call ( c -> c_normalize , c -> c_normalize_args , NULL ) ;  Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; id = id2 ; } PyUnicode_InternInPlace ( & id ) ; if ( PyArena_AddPyObject ( c -> c_arena , id ) < 0 ) { Py_DECREF ( id ) ; return NULL ; } return id ; }"," * id2 ; PyObject * form ; PyObject * args [ 2 ] ; _Py_IDENTIFIER ( NFKC ) ;  NULL ; } form = _PyUnicode_FromId ( & PyId_NFKC ) ; if ( form == NULL ) { Py_DECREF ( id ) ; return NULL ; } args [ 0 ] = form ; args [ 1 ] = id ; id2 = _PyObject_FastCall  ( c ->  -> c_normalize , args , 2 ) ; Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; if ( ! PyUnicode_Check ( id2 ) ) { PyErr_Format ( PyExc_TypeError , ""unicodedata.normalize()mustreturnastring,not"" ""%.200s"" , Py_TYPE ( id2 ) -> tp_name ) ; Py_DECREF ( id2 ) ; return NULL ; }  id = id2"
827,"CWE-415 static netsnmp_pdu * _clone_pdu_header ( netsnmp_pdu * pdu ) { netsnmp_pdu * newpdu ; struct snmp_secmod_def * sptr ; int ret ; if ( ! pdu ) return NULL ; newpdu = ( netsnmp_pdu * ) malloc ( sizeof ( netsnmp_pdu ) ) ; if ( ! newpdu ) return NULL ; memmove ( newpdu , pdu , sizeof ( netsnmp_pdu ) ) ; newpdu -> variables = NULL ; newpdu -> enterprise = NULL ; newpdu -> community = NULL ; newpdu -> securityEngineID = NULL ; newpdu -> securityName = NULL ; newpdu -> contextEngineID = NULL ; newpdu -> contextName = NULL ; newpdu -> transport_data = NULL ; if ( snmp_clone_mem ( ( void * * ) & newpdu -> enterprise , pdu -> enterprise , sizeof ( oid ) * pdu -> enterprise_length ) || snmp_clone_mem ( ( void * * ) & newpdu -> community , pdu -> community , pdu -> community_len ) || snmp_clone_mem ( ( void * * ) & newpdu -> contextEngineID , pdu -> contextEngineID , pdu -> contextEngineIDLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> securityEngineID , pdu -> securityEngineID , pdu -> securityEngineIDLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> contextName , pdu -> contextName , pdu -> contextNameLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> securityName , pdu -> securityName , pdu -> securityNameLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> transport_data , pdu -> transport_data , pdu -> transport_data_length ) ) { snmp_free_pdu ( newpdu ) ; return NULL ; }  if ( pdu -> securityStateRef &&  pdu -> command == SNMP_MSG_TRAP2 ) { netsnmp_assert ( pdu -> securityModel == SNMP_DEFAULT_SECMODEL ) ; ret = usm_clone_usmStateReference ( ( struct usmStateReference * ) pdu -> securityStateRef , ( struct usmStateReference * * ) & newpdu -> securityStateRef ) ; if ( ret ) { snmp_free_pdu ( newpdu ) ; return NULL ; }  }  if ( ( sptr = find_sec_mod ( newpdu -> securityModel ) ) != NULL && sptr -> pdu_clone != NULL ) { ( * sptr -> pdu_clone ) ( pdu , newpdu ) ; } return newpdu ; }"," NULL ; } sptr = find_sec_mod ( newpdu -> securityModel ) ; if ( sptr && sptr -> pdu_clone ) { ret = sptr -> pdu_clone ( pdu , newpdu  ) ; if  NULL ; }  } return newpdu"
828,"CWE-254 UWORD16 impeg2d_get_mb_addr_incr ( stream_t * ps_stream ) { UWORD16 u2_mb_addr_incr = 0 ;  while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE )  { impeg2d_bit_stream_flush ( ps_stream , MB_ESCAPE_CODE_LEN ) ; u2_mb_addr_incr += 33 ; } u2_mb_addr_incr += impeg2d_dec_vld_symbol ( ps_stream , gai2_impeg2d_mb_addr_incr , MB_ADDR_INCR_LEN ) + MB_ADDR_INCR_OFFSET ; return ( u2_mb_addr_incr ) ; }", ) == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
829,"CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ;  struct dw2102_state * state = d -> priv ;  u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ;  if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x02 ;   obuf [ 2 ] = 1 ;   if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ; msleep ( 300 ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x83 ;   obuf [ 2 ] = 0 ;   if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ;  obuf [ 0 ] = 0xe ;   obuf [ 1 ] = 0x83 ;   obuf [ 2 ] = 1 ;   if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command0x0etransferfailed."" ) ;  obuf [ 0 ] = 0x51 ;   if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 )   err ( ""command0x51transferfailed."" ) ;  m88ds3103_pdata . clk = 27000000 ; m88ds3103_pdata . i2c_wr_max = 33 ; m88ds3103_pdata . ts_mode = M88DS3103_TS_CI ; m88ds3103_pdata . ts_clk = 16000 ; m88ds3103_pdata . ts_clk_pol = 0 ; m88ds3103_pdata . spec_inv = 0 ; m88ds3103_pdata . agc = 0x99 ; m88ds3103_pdata . agc_inv = 0 ; m88ds3103_pdata . clk_out = M88DS3103_CLOCK_OUT_ENABLED ; m88ds3103_pdata . envelope_mode = 0 ; m88ds3103_pdata . lnb_hv_pol = 1 ; m88ds3103_pdata . lnb_en_pol = 0 ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""m88ds3103"" , I2C_NAME_SIZE ) ; board_info . addr = 0x68 ; board_info . platform_data = & m88ds3103_pdata ; request_module ( ""m88ds3103"" ) ; client = i2c_new_device ( & d -> i2c_adap , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) return - ENODEV ; if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe = m88ds3103_pdata . get_dvb_frontend ( client ) ; i2c_adapter = m88ds3103_pdata . get_i2c_adapter ( client ) ; state -> i2c_client_demod = client ; ts2020_config . fe = adap -> fe_adap [ 0 ] . fe ; memset ( & board_info , 0 , sizeof ( board_info ) ) ; strlcpy ( board_info . type , ""ts2022"" , I2C_NAME_SIZE ) ; board_info . addr = 0x60 ; board_info . platform_data = & ts2020_config ; request_module ( ""ts2020"" ) ; client = i2c_new_device ( i2c_adapter , & board_info ) ; if ( client == NULL || client -> dev . driver == NULL ) { dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } if ( ! try_module_get ( client -> dev . driver -> owner ) ) { i2c_unregister_device ( client ) ; dvb_frontend_detach ( adap -> fe_adap [ 0 ] . fe ) ; return - ENODEV ; } adap -> fe_adap [ 0 ] . fe -> ops . read_signal_strength = adap -> fe_adap [ 0 ] . fe -> ops . tuner_ops . get_rf_strength ; state -> i2c_client_tuner = client ; state -> fe_read_status = adap -> fe_adap [ 0 ] . fe -> ops . read_status ; adap -> fe_adap [ 0 ] . fe -> ops . read_status = tt_s2_4600_read_status ; state -> last_lock = 0 ; return 0 ; }"," d -> priv  ; struct i2c_adapter  { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ;  ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  ""command0x0etransferfailed."" ) ; state -> data  [ 0 ]  = 0xe ; state -> data  [ 1 ]  = 0x02 ; state -> data  [ 2 ]  ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  300 ) ; state -> data  [ 0 ]  = 0xe ; state -> data  [ 1 ]  = 0x83 ; state -> data  [ 2 ]  ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  ""command0x0etransferfailed."" ) ; state -> data  [ 0 ]  = 0xe ; state -> data  [ 1 ]  = 0x83 ; state -> data  [ 2 ]  ( d , state -> data  , 3 ,  , 3 , state -> data  , 1 ,  ""command0x0etransferfailed."" ) ; state -> data  [ 0 ]  ( d , state -> data , 1 , state -> data  , 1 ,  err ( ""command0x51transferfailed."" ) ; mutex_unlock ( & d -> data_mutex"
830,"CWE-190 static int jas_iccgetsint32 ( jas_stream_t * in , jas_iccsint32_t * val ) {  ulonglong tmp ;  if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;  * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) &   0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ;  return 0 ; }"," val ) { jas_ulonglong  tmp ; if  - JAS_CAST ( jas_longlong  , ( (  : JAS_CAST ( jas_longlong  , tmp )"
831,"CWE-400 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ;  if ( perf_event_overflow ( event , 0 , data , regs ) )  mipspmu -> disable_event ( idx ) ; }"," ( event ,  data , regs"
832,"CWE-125 static mrb_value fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ;  mrb_value value ;   fiber_check_cfunc ( mrb , c ) ;   if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) {  mrb_raise ( mrb , E_FIBER_ERROR , ""resumingtransferredfiber"" ) ; }  if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {  mrb_raise ( mrb , E_FIBER_ERROR , ""doubleresume(fib)"" ) ; }  if ( c -> status == MRB_FIBER_TERMINATED ) {  mrb_raise ( mrb , E_FIBER_ERROR , ""resumingdeadfiber"" ) ; }  mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;  c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;  if ( c -> status == MRB_FIBER_CREATED ) {  mrb_value * b , * e ;  if ( len >= c -> stend - c -> stack ) {  mrb_raise ( mrb , E_FIBER_ERROR , ""toomanyargumentstofiber"" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value = c -> stack [ 0 ] = MRB_PROC_ENV ( c -> ci -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; }  fiber_switch_context ( mrb , c ) ;  if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci [ - 1 ] . proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }"," -> c ; enum mrb_fiber_state status ;  , c ) ; status = c -> status  ( resume &&  status == MRB_FIBER_TRANSFERRED  } if (  status == MRB_FIBER_RUNNING  == MRB_FIBER_RUNNING ||  status == MRB_FIBER_RESUMED  } if (  status == MRB_FIBER_TERMINATED  ) ; } old_c  -> status =  root_c ) ; fiber_switch_context ( mrb , c ) ; if (  status == MRB_FIBER_CREATED  * e ; mrb_stack_extend ( mrb , len + 2 ) ;  b = c  ) ; }  if ( vmexec"
833,"CWE-310 int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX md_ctx ; unsigned char * param , * p ; int al , j , ok ; long i , param_len , n , alg_k , alg_a ; EVP_PKEY * pkey = NULL ; const EVP_MD * md = NULL ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif  n = s -> method -> ssl_get_message ( s ,  SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ;  if ( ! ok ) return ( ( int ) n ) ;  if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) {  # ifndef OPENSSL_NO_PSK   if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK )  { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; alg_a = s -> s3 -> tmp . new_cipher -> algorithm_auth ; EVP_MD_CTX_init ( & md_ctx ) ; al = SSL_AD_DECODE_ERROR ; # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { char tmp_id_hint [ PSK_MAX_IDENTITY_LEN + 1 ] ; param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > PSK_MAX_IDENTITY_LEN ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH ) ; goto f_err ; } param_len += i ; memcpy ( tmp_id_hint , p , i ) ; memset ( tmp_id_hint + i , 0 , PSK_MAX_IDENTITY_LEN + 1 - i ) ; if ( s -> ctx -> psk_identity_hint != NULL ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = BUF_strdup ( tmp_id_hint ) ; if ( s -> ctx -> psk_identity_hint == NULL ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } p += i ; n -= param_len ; } else # endif # ifndef OPENSSL_NO_SRP if ( alg_k & SSL_kSRP ) { param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_N_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . N = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 1 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 1 ; i = ( unsigned int ) ( p [ 0 ] ) ; p ++ ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_S_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . s = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_B_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . B = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! srp_verify_server_param ( s , & al ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_PARAMETERS ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif } else # endif # ifndef OPENSSL_NO_RSA if ( alg_k & SSL_kRSA ) { if ( ( rsa = RSA_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_MODULUS_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> n = BN_bin2bn ( p , i , rsa -> n ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_E_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> e = BN_bin2bn ( p , i , rsa -> e ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; else { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } s -> session -> sess_cert -> peer_rsa_tmp = rsa ; rsa = NULL ; } # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DH else if ( alg_k & SSL_kDHE ) { if ( ( dh = DH_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> p = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> pub_key = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! ssl_security ( s , SSL_SECOP_TMP_DH , DH_security_bits ( dh ) , 0 , dh ) ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DH_KEY_TOO_SMALL ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif s -> session -> sess_cert -> peer_dh_tmp = dh ; dh = NULL ; } else if ( ( alg_k & SSL_kDHr ) || ( alg_k & SSL_kDHd ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER ) ; goto f_err ; } # endif # ifndef OPENSSL_NO_ECDH else if ( alg_k & SSL_kECDHE ) { EC_GROUP * ngroup ; const EC_GROUP * group ; if ( ( ecdh = EC_KEY_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 4 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( ! tls1_check_curve ( s , p , 3 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_CURVE ) ; goto f_err ; } if ( ( curve_nid = tls1_ec_curve_id2nid ( * ( p + 2 ) ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS ) ; goto f_err ; } ngroup = EC_GROUP_new_by_curve_name ( curve_nid ) ; if ( ngroup == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } if ( EC_KEY_set_group ( ecdh , ngroup ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } EC_GROUP_free ( ngroup ) ; group = EC_KEY_get0_group ( ecdh ) ; if ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && ( EC_GROUP_get_degree ( group ) > 163 ) ) { al = SSL_AD_EXPORT_RESTRICTION ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER ) ; goto f_err ; } p += 3 ; if ( ( ( srvr_ecpoint = EC_POINT_new ( group ) ) == NULL ) || ( ( bn_ctx = BN_CTX_new ( ) ) == NULL ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } encoded_pt_len = * p ; p += 1 ; if ( ( encoded_pt_len > n - param_len ) || ( EC_POINT_oct2point ( group , srvr_ecpoint , p , encoded_pt_len , bn_ctx ) == 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_ECPOINT ) ; goto f_err ; } param_len += encoded_pt_len ; n -= param_len ; p += encoded_pt_len ; if ( 0 ) ; # ifndef OPENSSL_NO_RSA else if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # endif # ifndef OPENSSL_NO_ECDSA else if ( alg_a & SSL_aECDSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_ECC ] . x509 ) ; # endif EC_KEY_set_public_key ( ecdh , srvr_ecpoint ) ; s -> session -> sess_cert -> peer_ecdh_tmp = ecdh ; ecdh = NULL ; BN_CTX_free ( bn_ctx ) ; bn_ctx = NULL ; EC_POINT_free ( srvr_ecpoint ) ; srvr_ecpoint = NULL ; } else if ( alg_k ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } # endif if ( pkey != NULL ) { if ( SSL_USE_SIGALGS ( s ) ) { int rv ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) goto err ; else if ( rv == 0 ) { goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USINGTLSv1.2HASH%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } else md = EVP_sha1 ( ) ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; n -= 2 ; j = EVP_PKEY_size ( pkey ) ; if ( ( i != n ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_SIGNATURE_LENGTH ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA && ! SSL_USE_SIGALGS ( s ) ) { int num ; unsigned int size ; j = 0 ; q = md_buf ; for ( num = 2 ; num > 0 ; num -- ) { EVP_MD_CTX_set_flags ( & md_ctx , EVP_MD_CTX_FLAG_NON_FIPS_ALLOW ) ; EVP_DigestInit_ex ( & md_ctx , ( num == 2 ) ? s -> ctx -> md5 : s -> ctx -> sha1 , NULL ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , param , param_len ) ; EVP_DigestFinal_ex ( & md_ctx , q , & size ) ; q += size ; j += size ; } i = RSA_verify ( NID_md5_sha1 , md_buf , j , p , n , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # endif { EVP_VerifyInit_ex ( & md_ctx , md , NULL ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , param , param_len ) ; if ( EVP_VerifyFinal ( & md_ctx , p , ( int ) n , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } } else { if ( ! ( alg_a & ( SSL_aNULL | SSL_aSRP ) ) && ! ( alg_k & SSL_kPSK ) ) { if ( ssl3_check_cert_and_algorithm ( s ) ) SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( n != 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_EXTRA_DATA_IN_MESSAGE ) ; goto f_err ; } } EVP_PKEY_free ( pkey ) ; EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : EVP_PKEY_free ( pkey ) ; # ifndef OPENSSL_NO_RSA if ( rsa != NULL ) RSA_free ( rsa ) ; # endif # ifndef OPENSSL_NO_DH if ( dh != NULL ) DH_free ( dh ) ; # endif # ifndef OPENSSL_NO_ECDH BN_CTX_free ( bn_ctx ) ; EC_POINT_free ( srvr_ecpoint ) ; if ( ecdh != NULL ) EC_KEY_free ( ecdh ) ; # endif EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( - 1 ) ; }"," ; # endif EVP_MD_CTX_init ( & md_ctx ) ;  ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey  SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; }  OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a =  . new_cipher -> algorithm_auth  ; al ="
834,"CWE-119  static void write_mv_update ( const vp9_tree_index * tree ,   vp9_prob probs [ ] ,  const unsigned int counts [ ] ,  int n , vp9_writer * w ) {  int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) update_mv ( w , branch_ct [ i ] , & probs [ i ] , MV_UPDATE_PROB ) ; }"," write_mv_update ( const vpx_tree_index  * tree ,  * tree , vpx_prob  probs [ ]  int n , vpx_writer  * w )"
835,"CWE-362 static int sctp_setsockopt_auto_asconf ( struct sock * sk , char __user * optval , unsigned int optlen ) { int val ; struct sctp_sock * sp = sctp_sk ( sk ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; if ( ! sctp_is_ep_boundall ( sk ) && val ) return - EINVAL ; if ( ( val && sp -> do_auto_asconf ) || ( ! val && ! sp -> do_auto_asconf ) ) return 0 ;  if ( val == 0 && sp -> do_auto_asconf ) {  list_del ( & sp -> auto_asconf_list ) ; sp -> do_auto_asconf = 0 ; } else if ( val && ! sp -> do_auto_asconf ) { list_add_tail ( & sp -> auto_asconf_list , & sock_net ( sk ) -> sctp . auto_asconf_splist ) ; sp -> do_auto_asconf = 1 ; }  return 0 ;  }", return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;  1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;
836,"CWE-120 void test_base64_decode ( void ) { char buffer [ 16 ] ;  int len = mutt_b64_decode ( buffer , encoded ) ;  if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( ""Expected:%zu"" , sizeof ( clear ) - 1 ) ; TEST_MSG ( ""Actual:%zu"" , len ) ; } buffer [ len ] = '\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( ""Expected:%s"" , clear ) ; TEST_MSG ( ""Actual:%s"" , buffer ) ; } }"," buffer , encoded , sizeof ( buffer )"
837,"CWE-362 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; }  }  if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( ""allocatedconn%pfor%pI4->%pI4over%s%s\\n"" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : ""[unknown]"" , is_outgoing ? ""(outgoing)"" : """" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }", rds_loop_transport ; }  } conn ->
838,"CWE-119  void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride ,  int tx_type ) { const transform_2d IHT_4 [ ] = {  { idct4 , idct4 } ,  { iadst4 , idct4 } , { idct4 , iadst4 } , { iadst4 , iadst4 } } ; int i , j ;  int16_t out [ 4 * 4 ] ;   int16_t * outptr = out ;   int16_t temp_in [ 4 ] , temp_out [ 4 ] ;  for ( i = 0 ; i < 4 ; ++ i ) { IHT_4 [ tx_type ] . rows ( input , outptr ) ; input += 4 ; outptr += 4 ; } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j * 4 + i ] ; IHT_4 [ tx_type ] . cols ( temp_in , temp_out ) ;  for ( j = 0 ; j < 4 ; ++ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 )   + dest [ j * stride + i ] ) ;  } }"," vp9_iht4x4_16_add_c ( const tran_low_t  * input ,  = { { idct4_c , idct4_c } , { iadst4_c , idct4_c } , { idct4_c , iadst4_c } , { iadst4_c , iadst4_c  } } ;  , j ; tran_low_t  out [ 4  4 ] ; tran_low_t  * outptr =  = out ; tran_low_t  temp_in [ 4  ++ j ) {  i ] = clip_pixel_add (  dest [ j  + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ; }  } } "
839,"CWE-22 char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ PATH_MAX ] ; char * name , * ptr ; char dir [ PATH_MAX ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; DBG ( ""Composepathfromcwd:%s,arg:%s"" , ctrl -> cwd , path ? : """" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , ""/"" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , ""//"" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; DBG ( ""ServerpathfromCWD:%s"" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; DBG ( ""Resultingnon-chrootpath:%s"" , dir ) ; } if ( ! stat ( dir , & st ) && S_ISDIR ( st . st_mode ) ) { if ( ! realpath ( dir , rpath ) ) return NULL ; } else { name = basename ( path ) ; ptr = dirname ( dir ) ; memset ( rpath , 0 , sizeof ( rpath ) ) ; if ( ! realpath ( ptr , rpath ) ) { INFO ( ""Failedrealpath(%s):%m"" , ptr ) ; return NULL ; } if ( rpath [ 1 ] != 0 ) strlcat ( rpath , ""/"" , sizeof ( rpath ) ) ; strlcat ( rpath , name , sizeof ( rpath ) ) ; }  if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) {  DBG ( ""Failednon-chrootdir:%svshome:%s"" , dir , home ) ; return NULL ; } return rpath ; }"," && strncmp ( rpath  , home ,"
840,CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ;  pinctrl_unregister ( gpio_dev -> pctrl ) ;  return 0 ; }, gc ) ;  return 0 ;
841,"CWE-125 unsigned char * base64decode ( const char * buf , size_t * size ) { if ( ! buf || ! size ) return NULL ; size_t len = ( * size > 0 ) ? * size : strlen ( buf ) ; if ( len <= 0 ) return NULL ; unsigned char * outbuf = ( unsigned char * ) malloc ( ( len / 4 ) * 3 + 3 ) ; const char * ptr = buf ; int p = 0 ;  size_t l = 0 ;  do {  ptr += strspn ( ptr , ""\\r\\n\\t"" ) ;  if ( * ptr == '\\0' || ptr >= buf + len ) { break ; }  l = strcspn ( ptr , ""\\r\\n\\t"" ) ;  if ( l > 3 && ptr + l <= buf + len ) { p += base64decode_block ( outbuf + p , ptr , l ) ; ptr += l ; } else { break ; } } while ( 1 ) ; outbuf [ p ] = 0 ; * size = p ; return outbuf ; }"," = 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt  = 0 ;  ; do { while ( ptr < buf + len && ( * ptr == '' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; }  if ( *  break ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; }  } } while"
842,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ;  if ( likely ( walk . nbytes == nbytes ) )  { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }", iv ) ;  while ( walk
843,"CWE-369 static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ;  rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;  rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize = ( unsigned int ) rctx -> rbuf [ 0 ] ; if ( root_codesize < 2 || root_codesize > 11 ) { iw_set_error ( rctx -> ctx , ""InvalidLZWminimumcodesize"" ) ; goto done ; } if ( ! iwgif_init_screen ( rctx ) ) goto done ; rctx -> total_npixels = ( size_t ) rctx -> image_width * ( size_t ) rctx -> image_height ; if ( ! iwgif_make_row_pointers ( rctx ) ) goto done ; lzw_init ( & d , root_codesize ) ; lzw_clear ( & d ) ; while ( 1 ) { if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; subblocksize = ( size_t ) rctx -> rbuf [ 0 ] ; if ( subblocksize == 0 ) break ; if ( ! iwgif_read ( rctx , rctx -> rbuf , subblocksize ) ) goto done ; if ( ! lzw_process_bytes ( rctx , & d , rctx -> rbuf , subblocksize ) ) goto done ; if ( d . eoi_flag ) break ; if ( rctx -> pixels_set >= rctx -> total_npixels ) break ; } retval = 1 ; done : return retval ; }"," ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , ""Invalidimagedimensions"" ) ; goto done ; }"
844,"CWE-125 void vqp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct vqp_common_header_t * vqp_common_header ; const struct vqp_obj_tlv_t * vqp_obj_tlv ; const u_char * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ;  int tlen ;  uint8_t nitems ; tptr = pptr ; tlen = len ; vqp_common_header = ( const struct vqp_common_header_t * ) pptr ;  ND_TCHECK ( * vqp_common_header ) ;  if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) { ND_PRINT ( ( ndo , ""VQPversion%upacketnotsupported"" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""VQPv%u%sMessage,error-code%s(%u),length%u"" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , ""unknown(%u)"" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , ""unknown(%u)"" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , len ) ) ; return ; } nitems = vqp_common_header -> nitems ; ND_PRINT ( ( ndo , ""\\n\\tVQPv%u,%sMessage,error-code%s(%u),seq0x%08x,items%u,length%u"" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , ""unknown(%u)"" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , ""unknown(%u)"" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , EXTRACT_32BITS ( & vqp_common_header -> sequence ) , nitems , len ) ) ; tptr += sizeof ( const struct vqp_common_header_t ) ; tlen -= sizeof ( const struct vqp_common_header_t ) ; while ( nitems > 0 && tlen > 0 ) { vqp_obj_tlv = ( const struct vqp_obj_tlv_t * ) tptr ;  vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ;  vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ; tptr += sizeof ( struct vqp_obj_tlv_t ) ; tlen -= sizeof ( struct vqp_obj_tlv_t ) ; ND_PRINT ( ( ndo , ""\\n\\t%sObject(0x%08x),length%u,value:"" , tok2str ( vqp_obj_values , ""Unknown"" , vqp_obj_type ) , vqp_obj_type , vqp_obj_len ) ) ; if ( vqp_obj_type == 0 || vqp_obj_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , vqp_obj_len ) ;  switch ( vqp_obj_type ) {  case VQP_OBJ_IP_ADDRESS :  ND_PRINT ( ( ndo , ""%s(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ;  break ; case VQP_OBJ_PORT_NAME : case VQP_OBJ_VLAN_NAME : case VQP_OBJ_VTP_DOMAIN : case VQP_OBJ_ETHERNET_PKT : safeputs ( ndo , tptr , vqp_obj_len ) ; break ; case VQP_OBJ_MAC_ADDRESS :  case VQP_OBJ_MAC_NULL :  ND_PRINT ( ( ndo , ""%s"" , etheraddr_string ( ndo , tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t"" , vqp_obj_len ) ; break ; } tptr += vqp_obj_len ; tlen -= vqp_obj_len ; nitems -- ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|VQP]"" ) ) ; }", uint32_t vqp_obj_type ; u_int  tlen ; uint8_t  * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc  ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ;  vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ;  case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ;  case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
845,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , ""picturewillmove%soneline\\n"" , s -> dst_tff ? ""up"" : ""down"" ) ; h = frame -> height ;  for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) {  line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size ) ; } else { memcpy ( data , data + line_step + line_step , line_size ) ; } data -= line_step ; } } } frame -> top_field_first = s -> dst_tff ; return ff_filter_frame ( outlink , frame ) ; }", [ plane ] && frame -> linesize [ plane ]
846,"CWE-400 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,killinginterrupthandler!"" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attemptedtokilltheidletask!"" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT ""Fixingrecursivefaultbutrebootisneeded!\\n"" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:%s[%d]exitedwithpreempt_count%d\\n"" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; proc_exit_connector ( tsk ) ; perf_event_exit_task ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context )  exit_io_context ( ) ;  if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; validate_creds_for_do_exit ( tsk ) ; preempt_disable ( ) ; exit_rcu ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }", ) exit_io_context ( tsk
847,"CWE-20 static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ;  if ( key_is_instantiated ( key ) ) {  int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ; if ( err ) seq_printf ( m , "":%d"" , err ) ; else seq_printf ( m , "":%u"" , key -> datalen ) ; } }", ; if ( key_is_positive  ( key )
848,CWE-763  static void pcrypt_free ( struct crypto_instance * inst )  {  struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;  crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }, pcrypt_free ( struct aead_instance  * inst )  * ctx = aead_instance_ctx  ( inst )
849,"CWE-119 static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ;  uint8_t value ;  dev_dbg ( & usb_dev -> dev , ""atusb:reg=0x%x\\n"" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV ,  0 , reg , & value , 1 , 1000 ) ;   return ret >= 0 ? value : ret ;   } "," ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM  ; dev_dbg (  , reg , buffer  , 1 ,  1000 ) ; if (  ret >= 0  ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return  ret ; }  ret ; } }"
850,"CWE-119  int main_loop ( int argc , const char * * argv_ ) {  vpx_codec_ctx_t decoder ; char * fn = NULL ; int i ; uint8_t * buf = NULL ; size_t bytes_in_buffer = 0 , buffer_size = 0 ; FILE * infile ; int frame_in = 0 , frame_out = 0 , flipuv = 0 , noblit = 0 ;  int do_md5 = 0 , progress = 0 ;  int stop_after = 0 , postproc = 0 , summary = 0 , quiet = 1 ; int arg_skip = 0 ;  int ec_enabled = 0 ;  const VpxInterface * interface = NULL ; const VpxInterface * fourcc_interface = NULL ; uint64_t dx_time = 0 ; struct arg arg ; char * * argv , * * argi , * * argj ; int single_file ; int use_y4m = 1 ;  vpx_codec_dec_cfg_t cfg = { 0 } ;  # if CONFIG_VP8_DECODER vp8_postproc_cfg_t vp8_pp_cfg = { 0 } ; int vp8_dbg_color_ref_frame = 0 ; int vp8_dbg_color_mb_modes = 0 ; int vp8_dbg_color_b_modes = 0 ; int vp8_dbg_display_mv = 0 ; # endif int frames_corrupted = 0 ; int dec_flags = 0 ; int do_scale = 0 ; vpx_image_t * scaled_img = NULL ;  int frame_avail , got_data ;  int num_external_frame_buffers = 0 ;  struct ExternalFrameBufferList ext_fb_list = { 0 } ;  const char * outfile_pattern = NULL ; char outfile_name [ PATH_MAX ] = { 0 } ; FILE * outfile = NULL ; MD5Context md5_ctx ; unsigned char md5_digest [ 16 ] ;  struct VpxDecInputContext input = { 0 } ;   struct VpxInputContext vpx_input_ctx = { 0 } ;   struct WebmInputContext webm_ctx = { 0 } ;   input . vpx_input_ctx = & vpx_input_ctx ;  input . webm_ctx = & webm_ctx ; exec_name = argv_ [ 0 ] ; argv = argv_dup ( argc - 1 , argv_ + 1 ) ; for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { memset ( & arg , 0 , sizeof ( arg ) ) ; arg . argv_step = 1 ; if ( arg_match ( & arg , & codecarg , argi ) ) { interface = get_vpx_decoder_by_name ( arg . val ) ; if ( ! interface ) die ( ""Error:Unrecognizedargument(%s)to--codec\\n"" , arg . val ) ; } else if ( arg_match ( & arg , & looparg , argi ) ) { } else if ( arg_match ( & arg , & outputfile , argi ) ) outfile_pattern = arg . val ; else if ( arg_match ( & arg , & use_yv12 , argi ) ) { use_y4m = 0 ; flipuv = 1 ;  } else if ( arg_match ( & arg , & use_i420 , argi ) ) {  use_y4m = 0 ; flipuv = 0 ;  } else if ( arg_match ( & arg , & flipuvarg , argi ) )  flipuv = 1 ; else if ( arg_match ( & arg , & noblitarg , argi ) ) noblit = 1 ; else if ( arg_match ( & arg , & progressarg , argi ) ) progress = 1 ; else if ( arg_match ( & arg , & limitarg , argi ) ) stop_after = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & skiparg , argi ) ) arg_skip = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & postprocarg , argi ) ) postproc = 1 ; else if ( arg_match ( & arg , & md5arg , argi ) ) do_md5 = 1 ; else if ( arg_match ( & arg , & summaryarg , argi ) ) summary = 1 ; else if ( arg_match ( & arg , & threadsarg , argi ) ) cfg . threads = arg_parse_uint ( & arg ) ;  else if ( arg_match ( & arg , & verbosearg , argi ) )  quiet = 0 ; else if ( arg_match ( & arg , & scalearg , argi ) ) do_scale = 1 ; else if ( arg_match ( & arg , & fb_arg , argi ) )  num_external_frame_buffers = arg_parse_uint ( & arg ) ;  # if CONFIG_VP8_DECODER else if ( arg_match ( & arg , & addnoise_level , argi ) ) { postproc = 1 ; vp8_pp_cfg . post_proc_flag |= VP8_ADDNOISE ; vp8_pp_cfg . noise_level = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & demacroblock_level , argi ) ) { postproc = 1 ; vp8_pp_cfg . post_proc_flag |= VP8_DEMACROBLOCK ; vp8_pp_cfg . deblocking_level = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & deblock , argi ) ) { postproc = 1 ; vp8_pp_cfg . post_proc_flag |= VP8_DEBLOCK ; } else if ( arg_match ( & arg , & mfqe , argi ) ) { postproc = 1 ; vp8_pp_cfg . post_proc_flag |= VP8_MFQE ; } else if ( arg_match ( & arg , & pp_debug_info , argi ) ) { unsigned int level = arg_parse_uint ( & arg ) ; postproc = 1 ; vp8_pp_cfg . post_proc_flag &= ~ 0x7 ; if ( level ) vp8_pp_cfg . post_proc_flag |= level ; } else if ( arg_match ( & arg , & pp_disp_ref_frame , argi ) ) { unsigned int flags = arg_parse_int ( & arg ) ; if ( flags ) { postproc = 1 ; vp8_dbg_color_ref_frame = flags ; } } else if ( arg_match ( & arg , & pp_disp_mb_modes , argi ) ) { unsigned int flags = arg_parse_int ( & arg ) ; if ( flags ) { postproc = 1 ; vp8_dbg_color_mb_modes = flags ; } } else if ( arg_match ( & arg , & pp_disp_b_modes , argi ) ) { unsigned int flags = arg_parse_int ( & arg ) ; if ( flags ) { postproc = 1 ; vp8_dbg_color_b_modes = flags ; } } else if ( arg_match ( & arg , & pp_disp_mvs , argi ) ) { unsigned int flags = arg_parse_int ( & arg ) ; if ( flags ) { postproc = 1 ; vp8_dbg_display_mv = flags ; } } else if ( arg_match ( & arg , & error_concealment , argi ) ) { ec_enabled = 1 ; } # endif else argj ++ ; } for ( argi = argv ; * argi ; argi ++ ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( ""Error:Unrecognizedoption%s\\n"" , * argi ) ; fn = argv [ 0 ] ;  if ( ! fn )   usage_exit ( ) ;  infile = strcmp ( fn , ""-"" ) ? fopen ( fn , ""rb"" ) : set_binary_mode ( stdin ) ; if ( ! infile ) {  fprintf ( stderr , ""Failedtoopenfile\'%s\'"" , strcmp ( fn , ""-"" ) ? fn : ""stdin"" ) ;  return EXIT_FAILURE ; } # if CONFIG_OS_SUPPORT if ( ! outfile_pattern && isatty ( fileno ( stdout ) ) && ! do_md5 && ! noblit ) { fprintf ( stderr , ""Notdumpingrawvideotoyourterminal.Use\'-o-\'to"" ""override.\\n"" ) ; return EXIT_FAILURE ; } # endif input . vpx_input_ctx -> file = infile ; if ( file_is_ivf ( input . vpx_input_ctx ) ) input . vpx_input_ctx -> file_type = FILE_TYPE_IVF ; # if CONFIG_WEBM_IO else if ( file_is_webm ( input . webm_ctx , input . vpx_input_ctx ) ) input . vpx_input_ctx -> file_type = FILE_TYPE_WEBM ; # endif else if ( file_is_raw ( input . vpx_input_ctx ) ) input . vpx_input_ctx -> file_type = FILE_TYPE_RAW ; else { fprintf ( stderr , ""Unrecognizedinputfiletype.\\n"" ) ; # if ! CONFIG_WEBM_IO fprintf ( stderr , ""vpxdecwasbuiltwithoutWebMcontainersupport.\\n"" ) ; # endif return EXIT_FAILURE ; } outfile_pattern = outfile_pattern ? outfile_pattern : ""-"" ; single_file = is_single_file ( outfile_pattern ) ; if ( ! noblit && single_file ) { generate_filename ( outfile_pattern , outfile_name , PATH_MAX , vpx_input_ctx . width , vpx_input_ctx . height , 0 ) ; if ( do_md5 ) MD5Init ( & md5_ctx ) ; else outfile = open_outfile ( outfile_name ) ; } if ( use_y4m && ! noblit ) { if ( ! single_file ) { fprintf ( stderr , ""YUV4MPEG2notsupportedwithoutputpatterns,""  ""try--i420or--yv12.\\n"" ) ;  return EXIT_FAILURE ; } # if CONFIG_WEBM_IO if ( vpx_input_ctx . file_type == FILE_TYPE_WEBM ) { if ( webm_guess_framerate ( input . webm_ctx , input . vpx_input_ctx ) ) { fprintf ( stderr , ""Failedtoguessframerate--errorparsing"" ""webmfile?\\n"" ) ; return EXIT_FAILURE ; } } # endif } fourcc_interface = get_vpx_decoder_by_fourcc ( vpx_input_ctx . fourcc ) ; if ( interface && fourcc_interface && interface != fourcc_interface ) warn ( ""Headerindicatescodec:%s\\n"" , fourcc_interface -> name ) ; else interface = fourcc_interface ; if ( ! interface ) interface = get_vpx_decoder_by_index ( 0 ) ; dec_flags = ( postproc ? VPX_CODEC_USE_POSTPROC : 0 ) |  ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) ;   if ( vpx_codec_dec_init ( & decoder , interface -> interface ( ) , & cfg , dec_flags ) ) {  fprintf ( stderr , ""Failedtoinitializedecoder:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } if ( ! quiet ) fprintf ( stderr , ""%s\\n"" , decoder . name ) ; # if CONFIG_VP8_DECODER if ( vp8_pp_cfg . post_proc_flag && vpx_codec_control ( & decoder , VP8_SET_POSTPROC , & vp8_pp_cfg ) ) { fprintf ( stderr , ""Failedtoconfigurepostproc:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } if ( vp8_dbg_color_ref_frame && vpx_codec_control ( & decoder , VP8_SET_DBG_COLOR_REF_FRAME , vp8_dbg_color_ref_frame ) ) { fprintf ( stderr , ""Failedtoconfigurereferenceblockvisualizer:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } if ( vp8_dbg_color_mb_modes && vpx_codec_control ( & decoder , VP8_SET_DBG_COLOR_MB_MODES , vp8_dbg_color_mb_modes ) ) { fprintf ( stderr , ""Failedtoconfiguremacroblockvisualizer:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } if ( vp8_dbg_color_b_modes && vpx_codec_control ( & decoder , VP8_SET_DBG_COLOR_B_MODES , vp8_dbg_color_b_modes ) ) { fprintf ( stderr , ""Failedtoconfigureblockvisualizer:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } if ( vp8_dbg_display_mv && vpx_codec_control ( & decoder , VP8_SET_DBG_DISPLAY_MV , vp8_dbg_display_mv ) ) { fprintf ( stderr , ""Failedtoconfiguremotionvectorvisualizer:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } # endif if ( arg_skip ) fprintf ( stderr , ""Skippingfirst%dframes.\\n"" , arg_skip ) ; while ( arg_skip ) { if ( read_frame ( & input , & buf , & bytes_in_buffer , & buffer_size ) ) break ; arg_skip -- ; } if ( num_external_frame_buffers > 0 ) { ext_fb_list . num_external_frame_buffers = num_external_frame_buffers ; ext_fb_list . ext_fb = ( struct ExternalFrameBuffer * ) calloc ( num_external_frame_buffers , sizeof ( * ext_fb_list . ext_fb ) ) ; if ( vpx_codec_set_frame_buffer_functions ( & decoder , get_vp9_frame_buffer , release_vp9_frame_buffer , & ext_fb_list ) ) { fprintf ( stderr , ""Failedtoconfigureexternalframebuffers:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } } frame_avail = 1 ; got_data = 0 ; while ( frame_avail || got_data ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img ; struct vpx_usec_timer timer ;  int corrupted ;  frame_avail = 0 ; if ( ! stop_after || frame_in < stop_after ) { if ( ! read_frame ( & input , & buf , & bytes_in_buffer , & buffer_size ) ) { frame_avail = 1 ; frame_in ++ ; vpx_usec_timer_start ( & timer ) ; if ( vpx_codec_decode ( & decoder , buf , ( unsigned int ) bytes_in_buffer , NULL , 0 ) ) { const char * detail = vpx_codec_error_detail ( & decoder ) ; warn ( ""Failedtodecodeframe%d:%s"" , frame_in , vpx_codec_error ( & decoder ) ) ; if ( detail ) warn ( ""Additionalinformation:%s"" , detail ) ;  goto fail ;  } vpx_usec_timer_mark ( & timer ) ; dx_time += vpx_usec_timer_elapsed ( & timer ) ;  }  }  vpx_usec_timer_start ( & timer ) ;  got_data = 0 ; if ( ( img = vpx_codec_get_frame ( & decoder , & iter ) ) ) { ++ frame_out ; got_data = 1 ; } vpx_usec_timer_mark ( & timer ) ; dx_time += ( unsigned int ) vpx_usec_timer_elapsed ( & timer ) ;  if ( vpx_codec_control ( & decoder , VP8D_GET_FRAME_CORRUPTED , & corrupted ) ) {   warn ( ""FailedVP8_GET_FRAME_CORRUPTED:%s"" , vpx_codec_error ( & decoder ) ) ;  goto fail ; } frames_corrupted += corrupted ; if ( progress ) show_progress ( frame_in , frame_out , dx_time ) ; if ( ! noblit && img ) { const int PLANES_YUV [ ] = { VPX_PLANE_Y , VPX_PLANE_U , VPX_PLANE_V } ; const int PLANES_YVU [ ] = { VPX_PLANE_Y , VPX_PLANE_V , VPX_PLANE_U } ; const int * planes = flipuv ? PLANES_YVU : PLANES_YUV ; if ( do_scale ) { if ( frame_out == 1 ) { int display_width = vpx_input_ctx . width ; int display_height = vpx_input_ctx . height ; if ( ! display_width || ! display_height ) { int display_size [ 2 ] ; if ( vpx_codec_control ( & decoder , VP9D_GET_DISPLAY_SIZE , display_size ) ) { display_width = img -> d_w ; display_height = img -> d_h ; } else { display_width = display_size [ 0 ] ; display_height = display_size [ 1 ] ; } }  scaled_img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , display_width ,   display_height , 16 ) ;  } if ( img -> d_w != scaled_img -> d_w || img -> d_h != scaled_img -> d_h ) {  vpx_image_scale ( img , scaled_img , kFilterBox ) ;  img = scaled_img ;  }  } if ( single_file ) { if ( use_y4m ) { char buf [ Y4M_BUFFER_SIZE ] = { 0 } ; size_t len = 0 ;  if ( frame_out == 1 ) {  len = y4m_write_file_header ( buf , sizeof ( buf ) , vpx_input_ctx . width , vpx_input_ctx . height ,  & vpx_input_ctx . framerate , img -> fmt ) ;  if ( do_md5 ) { MD5Update ( & md5_ctx , ( md5byte * ) buf , ( unsigned int ) len ) ; } else { fputs ( buf , outfile ) ; } } len = y4m_write_frame_header ( buf , sizeof ( buf ) ) ; if ( do_md5 ) { MD5Update ( & md5_ctx , ( md5byte * ) buf , ( unsigned int ) len ) ; } else { fputs ( buf , outfile ) ; }  }  if ( do_md5 ) { update_image_md5 ( img , planes , & md5_ctx ) ; } else { write_image_file ( img , planes , outfile ) ; } } else { generate_filename ( outfile_pattern , outfile_name , PATH_MAX , img -> d_w , img -> d_h , frame_in ) ; if ( do_md5 ) { MD5Init ( & md5_ctx ) ; update_image_md5 ( img , planes , & md5_ctx ) ; MD5Final ( md5_digest , & md5_ctx ) ; print_md5 ( md5_digest , outfile_name ) ; } else { outfile = open_outfile ( outfile_name ) ; write_image_file ( img , planes , outfile ) ; fclose ( outfile ) ; } } }  if ( stop_after && frame_in >= stop_after )  break ; } if ( summary || progress ) { show_progress ( frame_in , frame_out , dx_time ) ; fprintf ( stderr , ""\\n"" ) ; } if ( frames_corrupted ) fprintf ( stderr , ""WARNING:%dframescorrupted.\\n"" , frames_corrupted ) ; fail : if ( vpx_codec_destroy ( & decoder ) ) { fprintf ( stderr , ""Failedtodestroydecoder:%s\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; } if ( ! noblit && single_file ) { if ( do_md5 ) { MD5Final ( md5_digest , & md5_ctx ) ; print_md5 ( md5_digest , outfile_name ) ; } else { fclose ( outfile ) ; } } # if CONFIG_WEBM_IO if ( input . vpx_input_ctx -> file_type == FILE_TYPE_WEBM ) webm_free ( input . webm_ctx ) ; # endif if ( input . vpx_input_ctx -> file_type != FILE_TYPE_WEBM ) free ( buf ) ;  if ( scaled_img ) vpx_img_free ( scaled_img ) ;  for ( i = 0 ; i < ext_fb_list . num_external_frame_buffers ; ++ i ) { free ( ext_fb_list . ext_fb [ i ] . data ) ; } free ( ext_fb_list . ext_fb ) ; fclose ( infile ) ; free ( argv ) ; return frames_corrupted ? EXIT_FAILURE : EXIT_SUCCESS ; }","    static  progress = 0 , frame_parallel = 0  ; int ec_enabled = 0 ; int keep_going  = 1 ; int opt_yv12 = 0 ; int opt_i420 = 0 ;  = { 0 , 0 , 0 } ; # if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ; # endif  # if CONFIG_VP8_DECODER  = NULL ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ; # endif  frame_avail , got_data , flush_decoder = 0  = { 0 , NULL  input = { NULL , NULL  } ; struct  struct VpxInputContext vpx_input_ctx ; # if CONFIG_WEBM_IO  struct WebmInputContext webm_ctx  struct WebmInputContext webm_ctx ; memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) )  ; input .  ; input . webm_ctx = & webm_ctx ; # endif input .  = & vpx_input_ctx  ; exec_name =  = 1 ; opt_yv12 = 1 ; # if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ; # endif  = 0 ; opt_i420 = 1 ;  arg , & rawvideo , argi ) ) { use_y4m = 0 ; } else if ( arg_match ( & arg , &  arg ) ; # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER  arg , & frameparallelarg , argi ) ) frame_parallel = 1 ; # endif else if ( arg_match ( & arg , &  arg ) ; else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ; # if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { output_bit_depth = arg_parse_uint ( & arg ) ; } # endif  ! fn ) { free ( argv ) ;  ( ) ; }  infile ) { fatal ( ""Failedtoopeninputfile\'%s\'""  , strcmp (  : ""stdin"" )  ; } #  stderr , ""YUV4MPEG2notsupportedwithoutputpatterns,"" ""try--i420or--yv12or--rawvideo.\\n""  ) ; return  : 0 ) | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 )  , interface -> codec_interface ( ) ,  & cfg ,  ; int corrupted = 0  detail ) ; if ( ! keep_going )  ) ; } else { flush_decoder = 1 ; } } else { flush_decoder = 1 ;  timer ) ; if ( flush_decoder ) { if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { warn ( ""Failedtoflushdecoder:%s"" , vpx_codec_error ( & decoder ) ) ; } }  ; if ( ! frame_parallel &&  ) ) ; if ( ! keep_going )  ( NULL , img -> fmt  , display_width ,  , 16 ) ; scaled_img -> bit_depth = img -> bit_depth  d_h ) { # if CONFIG_LIBYUV libyuv_scale  ( img ,  = scaled_img ; # else fprintf ( stderr , ""Failedtoscaleoutputframe:%s.\\n"" ""Scalingisdisabledinthisconfiguration."" ""Toenablescaling,configurewith--enable-libyuv\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) { output_bit_depth = img -> bit_depth ; } if ( output_bit_depth != img -> bit_depth ) { const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { vpx_img_free ( img_shifted ) ; img_shifted = NULL ; } if ( ! img_shifted ) { img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ; img_shifted -> bit_depth = output_bit_depth ; } if ( output_bit_depth > img -> bit_depth ) { vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ; } else { vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ; } img = img_shifted ; } # endif  if ( single_file  ; if ( img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { fprintf ( stderr , ""Cannotproducey4moutputfor440sampling.\\n"" ) ; goto fail ; } if (  img -> fmt , img -> bit_depth  ; } } else { if ( frame_out == 1 ) { if ( opt_i420 ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , ""Cannotproducei420outputforbit-stream.\\n"" ) ; goto fail ; } } if ( opt_yv12 ) { if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { fprintf ( stderr , ""Cannotproduceyv12outputforbit-stream.\\n"" ) ; goto fail ; } } } }  } } }  } if (  scaled_img ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ; # endif"
851,"CWE-200 int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ;  if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) )  return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }"," compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;"
852,"CWE-20 static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ;  if ( key_is_instantiated ( key ) ) {  int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ; if ( err ) seq_printf ( m , "":%d"" , err ) ; else seq_printf ( m , "":%u"" , key -> datalen ) ; } }", ; if ( key_is_positive  ( key )
