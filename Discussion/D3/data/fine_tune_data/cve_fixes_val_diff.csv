,source,target,group
0,sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;,"unix_dgram_peer_wake_disconnect ( sk , skpair ) ;sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;",0
1,"static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index ,  int_mv * ref_mv ,  int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] ,  int64_t tx_size_diff [ TX_MODES ] ,   int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) {MACROBLOCKD * const xd = & x -> e_mbd ;ctx -> best_mode_index = mode_index ;ctx -> mic = * xd -> mi [ 0 ] ;ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ;vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;","static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , int64_t tx_size_diff [ TX_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable ) {MACROBLOCKD * const xd = & x -> e_mbd ;ctx -> mbmi_ext = * x -> mbmi_ext ;ctx -> best_mode_index = mode_index ;ctx -> mic = * xd -> mi [ 0 ] ;ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ;memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;",1
2,"ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;","ND_TCHECK2 ( * ext , sizeof ( a ) ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;",2
3,if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) {cm -> allow_comp_inter_inter = 0 ;}cm -> allow_comp_inter_inter = 1 ;cm -> comp_fixed_ref = ALTREF_FRAME ;int i ;const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ;const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter )  cm -> reference_mode = SINGLE_REFERENCE ;else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] &&   mode_thresh [ COMPOUND_REFERENCE ] >   mode_thresh [ REFERENCE_MODE_SELECT ] &&  check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ;else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] )  cm -> reference_mode = SINGLE_REFERENCE ;else cm -> reference_mode = REFERENCE_MODE_SELECT ;if ( cm -> interp_filter == SWITCHABLE ) {if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP_SMOOTH ;}else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP_SHARP ;}else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP ;}}encode_frame_internal ( cpi ) ;for ( i = 0 ;i < REFERENCE_MODES ;++ i ) {const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ;cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ;for ( i = 0 ;const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;}for ( i = 0 ;,cpi -> allow_comp_inter_inter = 0 ;}cm -> allow_comp_inter_inter = 1 ;cm -> comp_fixed_ref = ALTREF_FRAME ;+ i ) {int i ;const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;int64_t * const mode_thrs = rd_opt -> prediction_type_threshes [ frame_type ] ;const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;int64_t * const filter_thrs = rd_opt -> filter_threshes [ frame_type ] [ i ] += diff ;for ( i = 0 ;const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;}for ( i = 0 ;,3
4,single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;}vp9_zero ( cm -> counts . comp_inter ) ;}vp9_zero ( cm -> counts . comp_inter ) ;},single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;}vp9_zero ( cm -> counts . comp_inter ) ;}vp9_zero ( cm -> counts . comp_inter ) ;},3
5,"count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;}reset_skip_txfm_size ( cm , TX_8X8 ) ;}reset_skip_txfm_size ( cm , TX_4X4 ) ;}reset_skip_txfm_size ( cm , TX_16X16 ) ;}cm -> interp_filter = SWITCHABLE ;encode_frame_internal ( cpi ) ;","count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;}reset_skip_txfm_size ( cm , TX_8X8 ) ;}reset_skip_txfm_size ( cm , TX_4X4 ) ;}reset_skip_txfm_size ( cm , TX_16X16 ) ;}cm -> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ;encode_frame_internal ( cpi ) ;",3
6,"if ( test_bit ( EV_KEY , dev -> evbit ) &&  ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) {","if ( old_keycode > KEY_MAX ) {dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\\}else if ( test_bit ( EV_KEY , dev -> evbit ) && ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) {",4
7,if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;if ( addr_len ) * addr_len = sizeof ( sa ) ;,if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) goto out_nofree ;,5
8,"if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;out : skb_free_datagram ( sk , skb ) ;","if ( msg -> msg_name != NULL ) {memcpy ( msg -> msg_name , & sa , sizeof ( sa ) ) ;* addr_len = sizeof ( sa ) ;}out : skb_free_datagram ( sk , skb ) ;",5
9,if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ;,if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;,6
10,"if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;","if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;",7
11,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,8
12,"FILE * fp = fopen ( dest_filename , ""w"" ) ;if ( ! fp ) return false ;","FILE * fp = fopen ( dest_filename , ""wx"" ) ;if ( ! fp ) return false ;",9
13,"* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc ,  ( pprev ? pprev : str ) , * low ) ;}","if ( p - str < reg -> dmax ) {* low = ( UChar * ) str ;if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ;}}else {* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ;}",10
14,"if ( hrtimer_cancel ( timer ) )  hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;}","mutex_lock ( & pit -> pit_state . lock ) ;if ( hrtimer_cancel ( timer ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;mutex_unlock ( & pit -> pit_state . lock ) ;}",11
15,vpx_roi_map_t roi = {0 };roi . rows = ( cfg -> g_h + 15 ) / 16 ;,"vpx_roi_map_t roi ;memset ( & roi , 0 , sizeof ( roi ) ) ;roi . rows = ( cfg -> g_h + 15 ) / 16 ;",12
16,"static const char * parse_object ( cJSON * item , const char * value )  {ep = value ;return 0 ;' )  return value + 1 ;if ( ! ( item -> child = child = cJSON_New_Item ( ) ) )  return 0 ;if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) )  return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ;child -> next = new_item ;new_item -> prev = child ;child = new_item ;if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) )  return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;' )  return value + 1 ;ep = value ;","static const char * parse_object ( cJSON * item , const char * value , const char * * ep ) {* ep = value ;return 0 ;' ) return value + 1 ;item -> child = child = cJSON_New_Item ( ) ) ) return 0 ;if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ;if ( ! item -> child ) return 0 ;value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) return 0 ;* ep = value ;return 0 ;value = skip ( parse_value ( child , skip ( value + 1 ) , ep ) ) ;if ( ! value ) return 0 ;' ) return value + 1 ;* ep = value ;",13
17,"
","if ( s -> image_offset_x || s -> image_offset_y ) {avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ;return AVERROR_PATCHWELCOME ;}",14
18,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,14
19,"addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;}","addModuleArgument ( pParse , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;}",15
20,return 0 ;},av_freep ( & x -> buf ) ;x -> buf_size = 0 ;return 0 ;},16
21,"new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;","new_fname = safe_calloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;",17
22,break ;},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;},18
23,"strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;","strncpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;",19
24,"void imap_quote_string ( char * dest , size_t dlen , const char * src )  {static const char quote [ ] = ""\\\\""\\\\\\\\"" ;","void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) {const char * quote = ""`\\\\""\\\\\\\\"" ;if ( ! quote_backtick ) quote ++ ;",20
25,"int r ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {","int r , dontmax = 0 ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) {st . st_size = 64 * 1024 ;dontmax = 1 ;}if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {",21
26,if ( params -> buffer . fragment_size == 0 ||  params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size )  return - EINVAL ;,if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > INT_MAX / params -> buffer . fragment_size ) return - EINVAL ;,22
27,"memcpy ( output , input , sizeof ( uint8_t ) * length ) ;return ;","memcpy ( output , input , sizeof ( output [ 0 ] ) * length ) ;return ;",23
28,if ( vcpu -> arch . time_page ) {kvm_release_page_dirty ( vcpu -> arch . time_page ) ;vcpu -> arch . time_page = NULL ;},vcpu -> arch . pv_time_enabled = false ;,24
29,"handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ;data . allocation . handle = handle -> id ;cleanup_handle = handle ;break ;case ION_IOC_FREE : {struct ion_handle * handle ;handle = ion_handle_get_by_id ( client , data . handle . handle ) ;if ( IS_ERR ( handle ) )  return PTR_ERR ( handle ) ;ion_free ( client , handle ) ;ion_handle_put ( handle ) ;","mutex_lock ( & client -> lock ) ;handle = ion_handle_get_by_id_nolock ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) {mutex_unlock ( & client -> lock ) ;return PTR_ERR ( handle ) ;ion_free_nolock ( client , handle ) ;ion_handle_put_nolock ( handle ) ;mutex_unlock ( & client -> lock ) ;",25
30,int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;,"u16 offs , total_size ;u8 data_len ;if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ;data_len = elt -> length - ( sizeof ( struct oz_get_desc_rsp ) - 1 ) ;offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;",26
31,"
","case OZ_SET_CONFIG_RSP : {struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_SET_INTERFACE_RSP : {struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_VENDOR_CLASS_RSP : {struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ;}break ;",26
32,"growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;","growBuffer ( buffer , i + XML_PARSER_BUFFER_SIZE ) ;",27
33,"growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;}","growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;}",27
34,if ( len < 5 )   return len ;b -> opcode = 0xe9 ;,"if ( len < 5 ) {# ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\\# endif return len ;}b -> opcode = 0xe9 ;",28
35,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},29
36,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},29
37,}},buffer_size -= ( size_t ) pkg_length ;}},29
38,mapping = ( struct address_space * ) page_private ( page ) ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,30
39,"void fdct16_8col ( __m128i * in ) {__m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;","static void fdct16_8col ( __m128i * in ) {__m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;const __m128i k__cospi_p08_m24 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 ) ;const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;",31
40,"i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ;i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ;i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ;i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ;i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ;i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ;s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ;s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ;s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ;s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ;s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ;s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ;s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ;s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ;p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ;p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ;p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ;p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ;p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ;p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ;p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ;p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ;u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ;u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ;u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ;u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ;v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ;v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ;v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ;v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ;u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ;u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ;u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ;u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ;u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ;","i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , k__cospi_p24_p08 ) ;",31
41,"v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ;u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ;u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ;u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ;u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ;v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ;p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ;p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ;p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ;p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ;p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ;p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ;p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ;u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ;u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ;u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ;u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ;v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;","v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p24_p08 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;u [ 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;",31
42,"s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ;","s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ;",31
43,"
",if ( avio_feof ( pb ) ) {return AVERROR_EOF ;},32
44,"if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\","if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\",32
45,newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,33
46,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,33
47,"long elements ;elements = parse_iv2 ( ( * p ) + 2 , p ) ;( * p ) += 2 ;if ( ce -> serialize == NULL ) {object_init_ex ( * rval , ce ) ;else {zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\\'%s\\\'"" , ce -> name ) ;return 0 ;}","long elements ;if ( * p >= max - 2 ) {zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ;return - 1 ;",34
48,trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,trace_kvm_emulate_insn_failed ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0 ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,35
49,auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;,"if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) {kfree_skb ( chunk -> auth_chunk ) ;sctp_association_free ( new_asoc ) ;return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ;}auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;",36
50,params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",37
51,"declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {",38
52,"declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == i ) ) {","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == i ) ) {",38
53,"RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ;RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ;RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;","RANGE_CHECK ( cfg , g_w , 1 , 1000000000 ) ;RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;",39
54,"RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;","RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 ) ;if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;",39
55,"i ++ )  if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ;","i ++ ) if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] && cfg -> rc_target_bitrate > 0 ) ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ;",39
56,"if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ;if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ;ret = 0 ;if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ;key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ;if ( IS_ERR ( key_ref ) ) {ret = PTR_ERR ( key_ref ) ;goto error ;}key = key_ref_to_ptr ( key_ref ) ;ret = - EACCES ;down_write ( & key -> sem ) ;if ( ! capable ( CAP_SYS_ADMIN ) ) {if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ;if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ;}if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) {ret = - ENOMEM ;newowner = key_user_lookup ( uid ) ;if ( ! newowner ) goto error_put ;if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) {unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ;unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ;spin_lock ( & newowner -> lock ) ;if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ;newowner -> qnkeys ++ ;newowner -> qnbytes += key -> quotalen ;spin_unlock ( & newowner -> lock ) ;spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;atomic_inc ( & newowner -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_dec ( & key -> user -> nikeys ) ;",if ( key -> state != KEY_IS_UNINSTANTIATED ) {atomic_dec ( & key -> user -> nikeys ) ;,40
57,"long mtemp , save_adjust , rem ;s64 freq_adj ;","long mtemp , save_adjust ;s64 freq_adj ;",41
58,"time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;","time_offset = div_s64 ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;",41
59,"time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ;","time_offset = div_long_long_rem_signed ( time_offset , NTP_INTERVAL_FREQ ) ;",41
60,"
",ND_TCHECK_32BITS ( bp ) ;,42
61,temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,42
62,if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,if ( ( '%' == in ) && ( alloc > 2 ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,43
63,size_t length ;uint_t i ;if ( segment -> dataOffset < 5 )  return NULL ;length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ;i = 0 ;if ( option -> kind == TCP_OPTION_NOP )  {continue ;}if ( option -> kind == TCP_OPTION_END ) break ;if ( ( i + 1 ) >= length || ( i + option -> length ) > length )  break ;return NULL ;},size_t i ;size_t length ;if ( segment -> dataOffset >= ( sizeof ( TcpHeader ) / 4 ) ) {length = ( segment -> dataOffset * 4 ) - sizeof ( TcpHeader ) ;i = 0 ;if ( option -> kind == TCP_OPTION_END ) {break ;}else if ( option -> kind == TCP_OPTION_NOP ) {}else {if ( ( i + 1 ) >= length ) break ;if ( option -> length < sizeof ( TcpOption ) || ( i + option -> length ) > length ) break ;}}return NULL ;},44
64,"double vp9_convert_qindex_to_q ( int qindex ) {return vp9_ac_quant ( qindex , 0 ) / 4.0 ;}","double vp9_convert_qindex_to_q ( int qindex , vpx_bit_depth_t bit_depth ) {# if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {case VPX_BITS_8 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ;case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ;case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return - 1.0 ;}# else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ;# endif }",45
65,if ( byte [ i ] & 0x40 )  i -- ;,if ( byte [ i ] & 0x40 && i > 0 ) i -- ;,46
66,if ( s -> pts == AV_NOPTS_VALUE ) {,if ( s -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0 ) {,47
67,"if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;","if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;",47
68,parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;parameters -> prch_init [ i ] = 256 ;},if ( parameters -> numresolution == 1 ) {parameters -> res_spec = 1 ;parameters -> prcw_init [ 0 ] = 128 ;parameters -> prch_init [ 0 ] = 128 ;}else {parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;}parameters -> prch_init [ i ] = 256 ;},48
69,return ERROR_INV_SPS_PPS_T ;},return ERROR_INV_SLICE_HDR_T ;},49
70,"if ( ! setup_stratum_curl ( pool ) ) goto out ;resend : if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) {",if ( n2size < 1 ) {,50
71,"if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",50
72,"for ( i = 0 ;i ++ )   nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;}if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {",51
73,# undef _  default : switch ( variable & 0xff ) {,_ ( NPPVpluginUrlRequestsDisplayedBool ) ;_ ( NPPVpluginWantsAllNetworkStreams ) ;_ ( NPPVpluginNativeAccessibleAtkPlugId ) ;_ ( NPPVpluginCancelSrcStream ) ;_ ( NPPVSupportsAdvancedKeyHandling ) ;# undef _ default : switch ( variable & 0xff ) {,52
74,"if ( level != SOL_PPPOL2TP )  return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;","if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( get_user ( len , optlen ) ) return - EFAULT ;",53
75,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;# endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql ) ;if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",54
76,"if ( ipv6_hdr ( skb ) -> payload_len == 0 ) {pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\\return skb ;}if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ;clone = skb_clone ( skb , GFP_ATOMIC ) ;if ( clone == NULL ) {pr_debug ( ""Can\\\'t<S2SV_blank>clone<S2SV_blank>skb\\\return skb ;}NFCT_FRAG6_CB ( clone ) -> orig = skb ;if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) {pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\\goto ret_orig ;}skb_set_transport_header ( clone , fhoff ) ;hdr = ipv6_hdr ( clone ) ;fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ;if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) {pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\\goto ret_orig ;}","
",55
77,"if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS )  {enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ;enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ;return NO_ERROR ;","if ( enc624j600ReadReg ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS ) {enc624j600WriteReg ( interface , ENC624J600_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteBuffer ( interface , ENC624J600_ETXST , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;enc624j600ClearBit ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF ) ;enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS ) ;return NO_ERROR ;",56
78,native_handle_t * h = malloc (   sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ;if ( h ) {,if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) {return NULL ;}size_t mallocSize = sizeof ( native_handle_t ) + ( sizeof ( int ) * ( numFds + numInts ) ) ;native_handle_t * h = malloc ( mallocSize ) ;if ( h ) {,57
79,"static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = x ;};}","static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) {psf -> header ) - 3 ) {psf -> header . ptr [ psf -> header . ptr [ psf -> headindex ++ ] = x ;}",58
80,ptr = p + 2 ;},ptr = p + 3 ;},59
81,"if ( pmd_none ( * pmd ) ) {if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ;if ( err ) break ;continue ;}if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ;if ( err ) break ;if ( ! walk -> pte_entry ) continue ;split_huge_page_pmd ( walk -> mm , pmd ) ;if ( pmd_none_or_clear_bad ( pmd ) )  goto again ;",if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) goto again ;,60
82,"while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 )  {","while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) {",61
83,"else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ;else {vpx_codec_ctrl_fn_map_t * entry ;res = VPX_CODEC_ERROR ;for ( entry = ctx -> iface -> ctrl_maps ;entry && entry -> fn ;entry ++ ) {if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) {va_list ap ;va_start ( ap , ctrl_id ) ;res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ;va_end ( ap ) ;","else if ( ! ctx -> iface || ! ctx -> priv , ap ) ;va_end ( ap ) ;",62
84,"isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;","isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;",63
85,"# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE &&  * p == SSL3_MT_CLIENT_HELLO ) &&  ! dtls1_record_replay_check ( s , bitmap ) ) {","# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) {",64
86,"d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ;if ( ! d ) return NULL ;","d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr , true ) ;if ( ! d ) return NULL ;",65
87,ue -> info = * info ;ue -> info . access = 0 ;,ue -> card = card ;ue -> info = * info ;ue -> info . access = 0 ;,66
88,}fpp = & fpl -> fp [ fpl -> count ] ;,fpl -> user = NULL ;}fpp = & fpl -> fp [ fpl -> count ] ;,67
89,return num ;},if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;return num ;},67
90,"u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;smin_val = src_reg . smin_value ;smax_val = src_reg . smax_value ;umin_val = src_reg . umin_value ;umax_val = src_reg . umax_value ;src_known = tnum_is_const ( src_reg . var_off ) ;dst_known = tnum_is_const ( dst_reg -> var_off ) ;if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}switch ( opcode ) {case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value += smin_val ;dst_reg -> smax_value += smax_val ;}if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value += umin_val ;dst_reg -> umax_value += umax_val ;}dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value -= smax_val ;dst_reg -> smax_value -= smin_val ;}if ( dst_reg -> umin_value < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value -= umax_val ;dst_reg -> umax_value -= umin_val ;}dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ;if ( smin_val < 0 || dst_reg -> smin_value < 0 ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value <<= umin_val ;dst_reg -> umax_value <<= umax_val ;}dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_RSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value >>= umax_val ;dst_reg -> umax_value >>= umin_val ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_ARSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value >>= umin_val ;dst_reg -> smax_value >>= umin_val ;dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;__update_reg_bounds ( dst_reg ) ;break ;default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( & src_reg , 4 ) ;}",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {},68
91,"error = copy_to_user ( buf , & socket_packet -> icmp_packet ,   socket_packet -> icmp_len ) ;packet_len = socket_packet -> icmp_len ;","packet_len = min ( count , socket_packet -> icmp_len ) ;error = copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) ;",69
92,"READ ( data , msg . f . length )   if ( msg . f . length > sizeof ( data ) )  rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\else   HandleFence ( cl , flags , msg . f . length , data ) ;return ;","if ( msg . f . length > sizeof ( data ) ) {rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\SKIP ( msg . f . length ) }else {READ ( data , msg . f . length ) HandleFence ( cl , flags , msg . f . length , data ) ;}return ;",70
93,uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ( cc % ( bps * stride ) ) != 0 ) {if ( ! tmp )  return 0 ;,uint8 * tmp ;if ( ( cc % ( bps * stride ) ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,71
94,"spin_lock_irq ( & tu -> qlock ) ;while ( ( long ) count - result >= unit ) {while ( ! tu -> qused ) {wait_queue_t wait ;if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) {err = - EAGAIN ;goto _error ;}set_current_state ( TASK_INTERRUPTIBLE ) ;init_waitqueue_entry ( & wait , current ) ;add_wait_queue ( & tu -> qchange_sleep , & wait ) ;spin_unlock_irq ( & tu -> qlock ) ;schedule ( ) ;spin_lock_irq ( & tu -> qlock ) ;",mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;schedule ( ) ;mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;,72
95,"mutex_lock ( & tu -> ioctl_lock ) ;if ( tu -> tread ) {else {if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ;}mutex_unlock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;return result > 0 ? result : err ;}",if ( tu -> tread ) {spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;return result > 0 ? result : err ;},72
96,avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,73
97,"int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) {const char * cbuf = buf ;int sent = send ( conn -> sock , cbuf , len , flags ) ;if ( sent == - 1 ) {","int mongo_env_write_socket ( mongo * conn , const void * buf , size_t len ) {const char * cbuf = buf ;size_t sent = send ( conn -> sock , cbuf , len , flags ) ;if ( sent == - 1 ) {",74
98,"uint32_t qttag , qtsize32 , len ;int32_t nest = 0 ;","uint32_t qttag , qtsize32 ;size_t len ;int32_t nest = 0 ;",75
99,"LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;","LongSeek ( mp4 , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;",75
100,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","LongSeek ( mp4 , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",75
101,"mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ;mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ;mp4 -> metasize_count = 1 ;return ( size_t ) mp4 ;}if ( qttag != MAKEID ( \'m\' , \'o\' , \'o\' , \'v\' ) && qttag != MAKEID ( \'u\' , \'d\' , \'t\' , \'a\' ) ) {LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ) ;NESTSIZE ( qtsize ) ;,75
102,"struct sk_buff * skb ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;if ( dump_one_state ( x , 0 , & info ) ) {kfree_skb ( skb ) ;return NULL ;}","struct sk_buff * skb ;int err ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;err = dump_one_state ( x , 0 , & info ) ;if ( err ) {kfree_skb ( skb ) ;return ERR_PTR ( err ) ;}",76
103,"len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;if ( len == - 1 ) {","len = mutt_b64_decode ( obuf , idata -> buf + 2 , sizeof ( obuf ) ) ;if ( len == - 1 ) {",77
104,"UWORD16 u2_first_mb_in_slice , u2_frame_num ;UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ;UWORD32 u4_idr_pic_id = 0 ;UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ;UWORD8 u1_nal_unit_type ;UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ;UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ;WORD8 i1_is_end_of_poc ;WORD32 ret , end_of_frame ;WORD32 prev_slice_err , num_mb_skipped ;UWORD8 u1_mbaff ;pocstruct_t * ps_cur_poc ;UWORD32 u4_temp ;WORD32 i_temp ;UWORD32 u4_call_end_of_pic = 0 ;ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ;u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) {return ERROR_CORRUPTED_SLICE ;}if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) {return ERROR_CORRUPTED_SLICE ;}COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ;u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ;u1_slice_type = u4_temp ;COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ;ps_dec -> u1_sl_typ_5_9 = 0 ;if ( u1_slice_type > 4 ) {u1_slice_type -= 5 ;ps_dec -> u1_sl_typ_5_9 = 1 ;}{UWORD32 skip ;if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) {UWORD32 u4_bit_stream_offset = 0 ;if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else {skip = 1 ;}if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) {skip = 0 ;}if ( skip ) {ps_dec -> u4_prev_nal_skipped = 1 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ;return 0 ;}else {if ( 1 == ps_dec -> u4_prev_nal_skipped ) {ps_dec -> u4_return_to_app = 1 ;return 0 ;}}}}u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ;ps_pps = & ps_dec -> ps_pps [ u4_temp ] ;if ( FALSE == ps_pps -> u1_is_valid ) {return ERROR_INV_SLICE_HDR_T ;}ps_seq = ps_pps -> ps_sps ;if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ;if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ;u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;if ( ! ps_seq -> u1_frame_mbs_only_flag )  {u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ;u1_bottom_field_flag = 0 ;",if ( i1_is_end_of_poc ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_INCOMPLETE_FRAME ;},78
105,}u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;,}u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;,78
106,if ( ! ps_dec -> u1_first_slice_in_stream )  {,if ( ! ps_dec -> u1_first_slice_in_stream ) {,78
107,int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,struct address_space * mapping ;pgoff_t idx ;unsigned long size ;int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,79
108,"if ( vm_shared ) {struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;spin_lock ( ptl ) ;ret = - EEXIST ;","mapping = dst_vma -> vm_file -> f_mapping ;idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;if ( vm_shared ) {size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_nounlock ;spin_lock ( ptl ) ;size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_unlock ;ret = - EEXIST ;",79
109,"char query [ 1024 ] , * end ;MYSQL_RES * result ;end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ;if ( wild && wild [ 0 ] )  strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;","char query [ NAME_LEN + 100 ] ;int len ;MYSQL_RES * result ;len = sizeof ( query ) ;len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db ) ;if ( wild && wild [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;",80
110,"unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ;unsigned char * y ;y_stride = 32 ;vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ;y = xd -> y_buf + y_stride + 1 ;# else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ;y_stride = pre_stride ;# endif  bestmv -> as_mv . row <<= 3 ;bestmv -> as_mv . col <<= 3 ;startmv = * bestmv ;",unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row *= 8 ;bestmv -> as_mv . col <<= 3 ;startmv = * bestmv ;,81
111,"this_mv . as_mv . col += 8 ;thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ;right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( right < bestmse ) {* bestmv = this_mv ;bestmse = right ;* distortion = thismse ;* sse1 = sse ;}this_mv . as_mv . col = startmv . as_mv . col ;this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ;thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ;up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( up < bestmse ) {* bestmv = this_mv ;bestmse = up ;* distortion = thismse ;* sse1 = sse ;}this_mv . as_mv . row += 8 ;thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ;down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( down < bestmse ) {* bestmv = this_mv ;bestmse = down ;* distortion = thismse ;* sse1 = sse ;}whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ;this_mv = startmv ;switch ( whichdir ) {case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ;this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ;thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ;break ;case 1 : this_mv . as_mv . col += 4 ;this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ;thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ;break ;case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ;this_mv . as_mv . row += 4 ;thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ;break ;case 3 : default : this_mv . as_mv . col += 4 ;this_mv . as_mv . row += 4 ;thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ;break ;}diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( diag < bestmse ) {* bestmv = this_mv ;bestmse = diag ;* distortion = thismse ;* sse1 = sse ;}if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ;if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ;",this_mv . as_mv . col *= 8 ;,81
112,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,82
113,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",82
114,"error = scsi_nonblockable_ioctl ( sdp , cmd , p ,  ( mode & FMODE_NDELAY ) != 0 ) ;","error = scsi_verify_blk_ioctl ( bdev , cmd ) ;if ( error < 0 ) return error ;error = scsi_nonblockable_ioctl ( sdp , cmd , p , ( mode & FMODE_NDELAY ) != 0 ) ;",83
115,if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ;,char * p ;int len ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;,84
116,"if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {truncate = 1 ;strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;retnamlen += rr -> len - 5 ;break ;","len = rr -> len - 5 ) >= 254 ) {truncate = 1 ;p = memchr ( rr -> u . NM . name , len ) ;retnamlen += rr -> len - 5 ;break ;",84
117,VpxVideoWriter * writer = NULL ;vpx_codec_ctx_t codec ;vpx_fixed_buf_t stats = {0 };VpxVideoInfo info = {0 };const VpxInterface * encoder = NULL ;int pass ;,"int w , h ;vpx_codec_ctx_t codec ;vpx_fixed_buf_t stats ;const VpxInterface * encoder = NULL ;int pass ;",85
118,"info . codec_fourcc = encoder -> fourcc ;info . time_base . numerator = 1 ;info . time_base . denominator = fps ;info . frame_width = strtol ( width_arg , NULL , 0 ) ;info . frame_height = strtol ( height_arg , NULL , 0 ) ;if ( info . frame_width <= 0 ||   info . frame_height <= 0 ||   ( info . frame_width % 2 ) != 0 ||   ( info . frame_height % 2 ) != 0 ) {die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;}if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width ,   info . frame_height , 1 ) ) {die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;}","w = strtol ( width_arg , NULL , 0 ) ;info . frame_height = strtol ( height_arg , NULL , 0 ) ;if ( info . frame_width <= 0 || info . frame_height <= 0 || ( w % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;}if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , w , h , 1 ) ) {die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;}",85
119,"while ( vpx_img_read ( & raw , infile ) ) {++ frame_count ;if ( pass == 0 ) {get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;}else {encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;}}if ( pass == 0 ) {get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;}else {printf ( ""\\\}fclose ( infile ) ;printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\\","+ frame_count ;while ( vpx_img_read ( & raw ) ;fclose ( infile ) ;printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\\",85
120,if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ;if ( c -> string )  cJSON_free ( c -> string ) ;,if ( ! ( c -> type & cJSON_StringIsConst ) && ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ;if ( c -> string ) cJSON_free ( c -> string ) ;,86
121,void vp9_inc_frame_in_layer ( SVC * svc ) {LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 )  ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ;},void vp9_inc_frame_in_layer ( VP9_COMP * const cpi ) {LAYER_CONTEXT * const lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] ;++ lc -> frames_from_key_frame ;},87
122,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",88
123,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",89
124,"switch ( atype ) {case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;else {ND_TCHECK ( * tptr ) ;","
",90
125,"tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;","ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;",90
126,ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,quantum_info = DestroyQuantumInfo ( quantum_info ) ;ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,91
127,skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == \'\\\,skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) && ! eof ( s ) ) ) if ( next ( s ) == \'\\\,92
128,"while ( peek ( s ) != \'>\' && ! eol ( s ) )  buf_append ( s , next ( s ) ) ;","while ( peek ( s ) != \'>\' && ! eol ( s ) ) buf_append ( s , next ( s ) ) ;",92
129,"enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ;}while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 )  {}enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ;sleep ( 1 ) ;if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 )  {","enc624j600WriteReg ( interface , ENC624J600_EUDAST , 0x1234 ) ;}while ( enc624j600ReadReg ( interface , ENC624J600_EUDAST ) != 0x1234 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY ) == 0 ) {}enc624j600SetBit ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST ) ;sleep ( 1 ) ;if ( enc624j600ReadReg ( interface , ENC624J600_EUDAST ) != 0x0000 ) {",93
130,"if ( length < 2 ) return 0 ;elementlen = * ( p + offset + 1 ) ;if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ;if ( length < elementlen + 2 ) return 0 ;switch ( * ( p + offset ) ) {case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ;","memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;",94
131,"if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ;if ( length < challenge . length ) return 0 ;","
",94
132,"case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) )  return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {offset += tim . length ;length -= tim . length ;break ;}if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ;memcpy ( & tim . count , p + offset , 3 ) ;offset += 3 ;length -= 3 ;memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ;offset += tim . length - 3 ;","case E_RATES : memcpy ( & rates , p + offset , tim . length - 3 ) ;offset += tim . length - 3 ;",94
133,size_t e ;if ( c -> stack == NULL ) return ;,size_t e ;mrb_value nil ;if ( c -> stack == NULL ) return ;,95
134,if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) {c -> stbase [ i ] = mrb_nil_value ( ) ;}else {}},e = c -> stend - c -> stbase ;nil = mrb_nil_value ( ) ;for ( ;i < e ;i ++ ) {c -> stbase [ i ] = nil ;}},95
135,"if ( client -> ipc == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;","if ( client -> ipc == NULL && client -> session == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;",96
136,"
",if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;,97
137,"sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {","sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {",97
138,"ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 )  ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;""  ""<S2SV_blank>using<S2SV_blank>read-until-close"" , tenc ) ;return APR_EGENERAL ;}lenp = NULL ;","ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" , tenc ) ;return APR_EINVAL ;",98
139,return APR_ENOSPC ;},return APR_ENOSPC ;},98
140,if ( rv != APR_SUCCESS ) {return AP_FILTER_ERROR ;,apr_brigade_cleanup ( bb ) ;if ( rv != APR_SUCCESS ) {return AP_FILTER_ERROR ;,98
141,"case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT :  case BODY_CHUNK_END : {rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;","case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF : {rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;",98
142,"int merge_trailers =  conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ;return read_chunked_trailers ( ctx , f , b , merge_trailers ) ;","return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ) ;",98
143,break ;},"ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ;return APR_EGENERAL ;}",98
144,"if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ;len -= sizeof ( * id ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ;nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ;len -= sizeof ( * io ) * nid ;io = ( struct id_off * ) ( id + 1 ) ;cp = ( char * ) ( io + nid ) ;if ( ! ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;","if ( ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;",99
145,struct ipv6_txoptions * opt = NULL ;struct ip6_flowlabel * flowlabel = NULL ;,struct ipv6_txoptions * opt = NULL ;struct ipv6_txoptions * opt_to_free = NULL ;struct ip6_flowlabel * flowlabel = NULL ;,100
146,if ( ! opt )  opt = np -> opt ;,if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;},100
147,fl6_sock_release ( flowlabel ) ;if ( ! err ) return len ;,fl6_sock_release ( flowlabel ) ;txopt_put ( opt_to_free ) ;if ( ! err ) return len ;,100
148,"umode_t mode = inode -> i_mode ;ret = posix_acl_equiv_mode ( acl , & mode ) ;if ( ret < 0 ) return ret ;","umode_t mode ;ret = posix_acl_update_mode ( inode , & mode ) ;if ( ret < 0 ) return ret ;",101
149,NUMA * na ;PIX * pixt ;,NUMA * na ;,102
150,"pixt = pixCopy ( NULL , pix ) ;goodcol = 0 ;",goodcol = 0 ;,102
151,"for ( j = goodcol - 1 ;j -- ) {pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ;pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ;}pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ;pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ;}pixDestroy ( & pixt ) ;","for ( j = goodcol - 1 ;j -- ) pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pix , j + 1 , 0 ) ;pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pix , j - 1 , 0 ) ;}",102
152,"u16 source_node_id ;u32 specifier_id ;u32 ver ;offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ;buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ;if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ;spin_unlock_irqrestore ( & dev -> lock , flags ) ;specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8  | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ;ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ;source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ;if ( specifier_id == IANA_SPECIFIER_ID &&  ( ver == RFC2734_SW_VERSION  # if IS_ENABLED ( CONFIG_IPV6 )  || ver == RFC3146_SW_VERSION  # endif  ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;",if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) == IANA_SPECIFIER_ID && ( ver == RFC2734_SW_VERSION # if IS_ENABLED ( CONFIG_IPV6 ) || ver == RFC3146_SW_VERSION # endif ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;,103
153,"sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;","if ( sin ) {sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;}if ( isk -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;if ( sin6 ) {sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;}if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",104
154,"down_write ( & mm -> mmap_sem ) ;mutex_lock ( & ufile -> umap_lock ) ;list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;mutex_lock ( & ufile -> umap_lock ) ;skip_mm : list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {",105
155,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,105
156,"guint uint_val = GST_READ_UINT32_LE ( value ) ;g_value_init ( & tag_value , G_TYPE_UINT ) ;gboolean bool_val = GST_READ_UINT32_LE ( value ) ;if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {","guint uint_val ;if ( value_len < 4 ) break ;uint_val = GST_READ_UINT32_LE ( value ) ;g_value_init ( & tag_value , G_TYPE_UINT ) ;gboolean bool_val ;if ( value_len < 4 ) break ;bool_val = GST_READ_UINT32_LE ( value ) ;if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {",106
157,kk = malloc ( xsize * kmax * sizeof ( float ) ) ;if ( ! kk )  return ( Imaging ) ImagingError_MemoryError ( ) ;,if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ;if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ;kk = malloc ( xsize * kmax * sizeof ( float ) ) ;if ( ! kk ) return ( Imaging ) ImagingError_MemoryError ( ) ;if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) ) ) return ( Imaging ) ImagingError_MemoryError ( ) ;,107
158,countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,108
159,"struct timespec ts ;if ( ! nsec ) return ( struct timespec ) {ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ;if ( unlikely ( nsec < 0 ) )   set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ;return ts ;","struct timespec ts ;s32 rem ;if ( ! nsec ) return ( struct timespec ) {ts . tv_sec = div_s64_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( unlikely ( nsec < 0 ) ) {ts . tv_sec , ts . tv_nsec ) ;return ts ;",109
160,"default :  buffer = malloc ( msg . tc . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) {","default : if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ;buffer = malloc ( msg . tc . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) {",110
161,"rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;","rb_define_singleton_method ( klass , ""read_memory"" , read_memory , - 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , - 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;",111
162,"static void nsc_encode_subsampling ( NSC_CONTEXT * context )  {BYTE * co_dst ;BYTE * cg_dst ;INT8 * co_src0 ;INT8 * co_src1 ;INT8 * cg_src0 ;INT8 * cg_src1 ;UINT32 tempHeight ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;co_src1 = co_src0 + tempWidth ;cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;","static BOOL nsc_encode_subsampling ( NSC_CONTEXT * context ) {UINT32 tempHeight ;if ( ! context ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( tempHeight == 0 ) return FALSE ;if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ;for ( y = 0 ;y ++ ) {BYTE * co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;BYTE * cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;const INT8 * co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;const INT8 * co_src1 = co_src0 + tempWidth ;const INT8 * cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;const INT8 * cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;",112
163,},return TRUE ;},112
164,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,113
165,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},113
166,"if ( hrtimer_cancel ( timer ) )  hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;}","mutex_lock ( & pit -> pit_state . lock ) ;if ( hrtimer_cancel ( timer ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;mutex_unlock ( & pit -> pit_state . lock ) ;}",114
167,"FILE * file = NULL ;ASSERT ( idfile ) ;md5_context_t ctx ;char buf [ STRLEN ] ;snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ;md5_init ( & ctx ) ;fprintf ( file , ""%s"" , Run . id ) ;LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\\LogError ( ""idfile<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\\return NULL ;}if ( ( file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) {","ASSERT ( idfile ) ;FILE * file = NULL ;md5_context_t ctx ;char buf [ STRLEN ] ;snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ;md5_init ( & ctx ) ;fprintf ( file , ""%s"" , Run . id ) ;LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\\file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) {",115
168,"aptr += RRFIXEDSZ ;if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) {","aptr += RRFIXEDSZ ;if ( aptr + rr_len > abuf + alen ) {free ( rr_name ) ;status = ARES_EBADRESP ;break ;}if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) {",116
169,hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;lf = fwnet_get_hdr_lf ( & hdr ) ;,if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ;hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;lf = fwnet_get_hdr_lf ( & hdr ) ;,117
170,hdr . w1 = ntohl ( buf [ 1 ] ) ;buf += 2 ;,if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ;hdr . w1 = ntohl ( buf [ 1 ] ) ;buf += 2 ;if ( fg_off + len > dg_size ) return 0 ;,117
171,"spin_lock_irqsave ( & dev -> lock , flags ) ;peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ;","spin_lock_irqsave ( & dev -> lock , flags ) ;peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ;",117
172,"if ( ( mask & ~ ALL_PRINC_MASK ) )  return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;","if ( mask & KADM5_TL_DATA ) {for ( tl_data_tail = entry -> tl_data ;tl_data_tail != NULL ;tl_data_tail = tl_data_tail -> tl_data_next ) {if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;}}if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;",118
173,"static int em_jcxz ( struct x86_emulate_ctxt * ctxt )  {if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",119
174,if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ;if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ;else mnt -> mnt_group_id = old -> mnt_group_id ;if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) {err = mnt_alloc_group_id ( mnt ) ;if ( err ) goto out_free ;mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ;if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) )  mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )  mnt -> mnt . mnt_flags |= MNT_LOCKED ;,if ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ;if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ;if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) mnt -> mnt . mnt_flags |= MNT_LOCKED ;,120
175,"if ( ! f ) {if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) {warn ( ""write<S2SV_blank>%s:"" , name ) ;","if ( s && ( ! f ) {if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) ) {warn ( ""write<S2SV_blank>%s:"" , name ) ;",121
176,"if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  {",if ( ( psf = psf_allocate ( ) ) == NULL ) {,122
177,box -> len = len ;if ( box -> len == 1 ) {,"box -> len = len ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {box -> ops = & jp2_boxinfo_unk . ops ;",123
178,"jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;","jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;",123
179,"count = yr_max ( 64 , ( index + 1 ) * 2 ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc (  array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;","count = 64 ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;",124
180,if ( len == 6 ) {,if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && len == 6 ) {,125
181,"if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 )  ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 )  ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;","if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;",125
182,"ND_TCHECK2 ( dp [ 0 ] , 0 ) ;astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ;","ND_TCHECK ( dp [ 0 ] , 0 ) ;astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ;",126
183,"if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ;if ( copy > size ) {++ from ;-- count ;offset = 0 ;}else offset += size ;copy -= size ;offset1 += size ;}if ( len == offset1 ) return 0 ;while ( count -- ) {struct page * page [ MAX_SKB_FRAGS ] ;int num_pages ;unsigned long base ;unsigned long truesize ;len = from -> iov_len - offset ;if ( ! len ) {offset = 0 ;++ from ;continue ;}base = ( unsigned long ) from -> iov_base + offset ;size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ;num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ;if ( ( num_pages != size ) ||  ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) {",+ from ;+ from ;if ( num_pages != size ) || ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) {,127
184,"buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ;buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ;","if ( uri_ptr [ alias_len ] == '.' ) {char * s = uri_ptr + alias_len + 1 ;if ( * s == '.' ) ++ s ;if ( * s == '/' || * s == '\\\\0' ) {size_t vlen = buffer_string_length ( ds -> value ) ;if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) {con -> http_status = 403 ;return HANDLER_FINISHED ;}}}buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ;buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ;",128
185,"size_t buf_size = 0 ;if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {done :  if ( buf ) oe_free ( buf ) ;","size_t buf_size = 0 ;size_t data_size = 0 ;if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : if ( buf ) oe_free ( buf ) ;",129
186,out_err :  kfree ( init_name ) ;return rv ;,out_err : if ( rv && new_smi -> io . io_cleanup ) {new_smi -> io . io_cleanup ( & new_smi -> io ) ;new_smi -> io . io_cleanup = NULL ;}kfree ( init_name ) ;return rv ;,130
187,# endif  # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,# endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;# ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,131
188,len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ;len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,132
189,"if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}if ( ! bmp_issupported ( & hdr , info ) ) {","JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\\if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {",133
190,"case IPOPT_TS :  ip_printts ( ndo , cp , option_len ) ;break ;case IPOPT_RA :  if ( option_len < 4 ) {","case IPOPT_TS : if ( ip_printts ( ndo , cp , option_len ) ;break ;case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ;break ;case IPOPT_RA : if ( option_len < 4 ) {",134
191,numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;,"numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",135
192,"u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr ,  iph -> protocol ,  ip_idents_hashrnd ) ;","static u32 ip_idents_hashrnd_extra __read_mostly ;u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol ^ ip_idents_hashrnd_extra , ip_idents_hashrnd ) ;",136
193,"strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ;strncpy ( extra_response -> value , NOTUNDERSTOOD ,  strlen ( NOTUNDERSTOOD ) + 1 ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;","strlcpy ( extra_response -> key , key , sizeof ( extra_response -> key ) ) ;strlcpy ( extra_response -> value , NOTUNDERSTOOD , sizeof ( extra_response -> value ) ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;",137
194,"static int override_release ( char __user * release , int len )  {int ret = 0 ;char buf [ 65 ] ;char * rest = UTS_RELEASE ;int ndots = 0 ;unsigned v ;while ( * rest ) {snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , len ) ;}","static int override_release ( char __user * release , size_t len ) {int ret = 0 ;const char * rest = UTS_RELEASE ;char buf [ 65 ] = {0 };int ndots = 0 ;unsigned v ;size_t copy ;while ( * rest ) {copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ;copy = scnprintf ( buf , copy , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , copy + 1 ) ;}",138
195,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_gmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_gmac_stats_string ) ;,139
196,"struct rdcost_block_args args = {0 };args . x = x ;args . use_fast_coef_costing = use_fast_coef_casting ;if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;if ( args . skip ) {* rate = INT_MAX ;* skippable = 0 ;else {* distortion = args . this_dist ;* rate = args . this_rate ;* sse = args . this_sse ;* skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ;}",struct rdcost_block_args args ;vp9_zero ( args ) ;args . x = x ;args . use_fast_coef_costing = use_fast_coef_casting ;args . skippable = 1 ;if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;if ( args . exit_early ) {* rate = INT_MAX ;* skippable = args . skippable ;,140
197,"len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ;rundir = get_rundir ( ) ;ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ;if ( ret < 0 || ret >= len ) {int l2 = 22 + strlen ( n ) + strlen ( p ) ;if ( l2 > len ) {free ( rundir ) ;","len = strlen ( ""/lxc/lock/"" ) + strlen ( n ) + strlen ( p ) + 3 ;rundir = get_rundir ( ) ;ret = snprintf ( dest , len , ""%s/lxc/lock/%s"" , rundir , p ) ;if ( ret < 0 || ret >= len ) {free ( dest ) ;free ( rundir ) ;return NULL ;}ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ;free ( rundir ) ;if ( l2 > len ) {",141
198,free ( rundir ) ;return NULL ;,free ( rundir ) ;return NULL ;,141
199,struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;,struct flowi6 * fl6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ;fl6 = & inet -> cork . fl . u . ip6 ;,142
200,"endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;","if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\\err = - EINVAL ;goto fail3 ;}endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;",143
201,goto fail3 ;},err = - EINVAL ;goto fail3 ;},143
202,"GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ;if ( ptr -> esd ) {gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ;ptr -> esd = NULL ;","extern Bool use_dump_mode ;GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ;if ( ptr -> esd ) {if ( ! use_dump_mode ) gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ;ptr -> esd = NULL ;",144
203,if ( * pStackPtr >= CDL_STACK_SIZE )   return EAS_ERROR_FILE_FORMAT ;* pStackPtr = * pStackPtr + 1 ;,"if ( * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) {ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ;android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ;return EAS_ERROR_FILE_FORMAT ;}* pStackPtr = * pStackPtr + 1 ;",145
204,"memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) | txp -> offset ) , data_len ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",146
205,"}else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) {s -> filesize = strtoll ( p , NULL , 10 ) ;}","}else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == UINT64_MAX ) {s -> filesize = strtoll ( p , NULL , 10 ) ;}",147
206,"s -> filesize = - 1 ;s -> chunksize = 0 ;}else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) {ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) {ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) {ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) {if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ;","s -> filesize = strtoull ( p , ""close"" ) ) s -> willclose = 1 ;",147
207,"s -> icy_metaint = strtoll ( p , NULL , 10 ) ;}","s -> icy_metaint = strtoull ( p , NULL , 10 ) ;}",147
208,"
",mutt_socket_empty ( conn ) ;,148
209,"}if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) {","}if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) {",148
210,"outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ;}LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ;LineTo ( - length * 0.5 , - arrow . width ) ;outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ;}","send ( ""<S2SV_blank>h<S2SV_blank>f"" ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ;}send ( ""<S2SV_blank>h<S2SV_blank>f"" ) ;}",149
211,# endif  numSamples = pWTIntFrame -> numSamples ;pMixBuffer = pWTIntFrame -> pMixBuffer ;,"# endif numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pMixBuffer = pWTIntFrame -> pMixBuffer ;",150
212,char added ;},},151
213,"const char * name = d -> name ;struct device dev = d -> udev -> dev ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\dvb_usbv2_exit ( d ) ;dev_info ( & dev , ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}","const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ;const char * drvname = d -> name ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\pr_info ( ""%s:<S2SV_blank>\\\'%s:%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}",152
214,"list_del ( & key -> graveyard_link ) ;kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) &&  ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;","short state = key -> state ;list_del ( & key -> graveyard_link ) ;kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ;if ( state == KEY_IS_POSITIVE && key -> type -> destroy ) key -> type -> destroy ( key ) ;",153
215,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  atomic_dec ( & key -> user -> nikeys ) ;",if ( state != KEY_IS_UNINSTANTIATED ) atomic_dec ( & key -> user -> nikeys ) ;,153
216,"REQ ( n , for_stmt ) ;if ( NCH ( n ) == 9 ) {seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ;if ( ! seq ) return NULL ;","int has_type_comment ;string type_comment ;REQ ( n , for_stmt ) ;has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT ;if ( NCH ( n ) == 9 + has_type_comment ) {seq = ast_for_suite ( c , CHILD ( n , 8 + has_type_comment ) ) ;if ( ! seq ) return NULL ;",154
217,"suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ;if ( ! suite_seq ) return NULL ;if ( is_async )   return AsyncFor ( target , expression , suite_seq , seq ,  LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else  return For ( target , expression , suite_seq , seq ,  LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;","suite_seq = ast_for_suite ( c , CHILD ( n , 5 + has_type_comment ) ) ;if ( ! suite_seq ) return NULL ;if ( has_type_comment ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ;if ( ! type_comment ) return NULL ;}else type_comment = NULL ;if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else return For ( target , expression , suite_seq , seq , type_comment , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;",154
218,"if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ||  uid_eq ( root_uid , current_uid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( gid_eq ( root_gid , current_gid ( ) ) ) {int mode = ( table -> mode >> 3 ) & 7 ;","if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_euid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( in_egroup_p ( root_gid ) ) {int mode = ( table -> mode >> 3 ) & 7 ;",155
219,"
","( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;",156
220,MinVal = 0 ;MaxVal = 0 ;,MinVal = 0 ;MaxVal = 0 ;,156
221,mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;,"if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) {ret = - EINVAL ;goto free_ret ;}mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;",157
222,if ( bytecnt ) {wpc -> file_format = * byteptr ++ ;,if ( bytecnt >= 2 ) {wpc -> file_format = * byteptr ++ ;if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;,158
223,bytecnt -- ;},bytecnt -- ;},158
224,"if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ;cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ;if ( cur_node == 0 ) {if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\\free ( node ) ;return 1 ;}if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\\is_done = 0 ;while ( is_done == 0 ) {TSK_OFF_T cur_off ;uint16_t num_rec ;ssize_t cnt ;hfs_btree_node * node_desc ;if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) {",if ( keylen >= nodesize - rec_off ) {,159
225,"if ( ( keylen ) > nodesize ) {tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ;tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%""  PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ;free ( node ) ;","if ( ( keylen ) > nodesize ) {tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ;tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , ( nodesize - rec_off ) ) ;free ( node ) ;",159
226,"if ( sock -> ops ) {struct module * owner = sock -> ops -> owner ;sock -> ops -> release ( sock ) ;sock -> ops = NULL ;module_put ( owner ) ;}if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list )  pr_err ( ""%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\\if ( ! sock -> file ) {iput ( SOCK_INODE ( sock ) ) ;return ;}sock -> file = NULL ;","__sock_release ( sock , NULL ) ;",160
227,lock_sock ( sk ) ;if ( ctx -> more ) {,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( ctx -> more ) {,161
228,"ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ;ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ;return ;}","cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ;cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ;}",162
229,"# else fprintf ( stderr , ""WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\""%s\\\\""\\\# endif break ;}else if ( ! strcmp ( argv [ i ] , ""-p"" ) ) {if ( i + 1 < ( u32 ) argc ) gpac_profile = argv [ i + 1 ] ;else {fprintf ( stderr , ""Bad<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>-p,<S2SV_blank>expecting<S2SV_blank>profile<S2SV_blank>name<S2SV_blank>but<S2SV_blank>no<S2SV_blank>more<S2SV_blank>args\\\return 1 ;}}else if ( ! strncmp ( argv [ i ] , ""-p="" , 3 ) ) gpac_profile = argv [ i ] + 3 ;}# ifdef _TWO_DIGIT_EXPONENT _set_output_format ( _TWO_DIGIT_EXPONENT ) ;# endif gf_sys_init ( mem_track , gpac_profile ) ;if ( argc < 2 ) {fprintf ( stderr , ""Not<S2SV_blank>enough<S2SV_blank>arguments<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\gf_sys_close ( ) ;return 0 ;}helpout = stdout ;i = mp4box_parse_args ( argc , argv ) ;if ( i ) {return mp4box_cleanup ( i - 1 ) ;}if ( ! inName && dump_std ) inName = ""std"" ;if ( ! inName ) {if ( has_next_arg ) {fprintf ( stderr , ""Broken<S2SV_blank>argument<S2SV_blank>specifier<S2SV_blank>or<S2SV_blank>file<S2SV_blank>name<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\}else {PrintUsage ( ) ;}return mp4box_cleanup ( 1 ) ;}if ( ! strcmp ( inName , ""std"" ) ) dump_std = 2 ;if ( ! strcmp ( inName , ""stdb"" ) ) {inName = ""std"" ;dump_std = 1 ;}if ( ! interleaving_time ) {if ( dash_duration ) interleaving_time = dash_duration ;else if ( ! do_flat ) {interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ;}}if ( dump_std ) outName = ""std"" ;if ( dump_std == 2 ) {# ifdef WIN32 if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == - 1 ) # else if ( freopen ( NULL , ""wb"" , stdout ) == NULL ) # endif {fprintf ( stderr , ""Fatal<S2SV_blank>error:<S2SV_blank>cannot<S2SV_blank>reopen<S2SV_blank>stdout<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>mode.\\\return mp4box_cleanup ( 1 ) ;}}# if ! defined ( GPAC_DISABLE_STREAMING ) && ! defined ( GPAC_DISABLE_SENG ) if ( live_scene ) {int ret = live_session ( argc , argv ) ;return mp4box_cleanup ( ret ) ;}# endif GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO ;gf_log_set_tool_level ( GF_LOG_CONTAINER , level ) ;gf_log_set_tool_level ( GF_LOG_SCENE , level ) ;gf_log_set_tool_level ( GF_LOG_PARSER , level ) ;gf_log_set_tool_level ( GF_LOG_AUTHOR , level ) ;gf_log_set_tool_level ( GF_LOG_CODING , level ) ;gf_log_set_tool_level ( GF_LOG_DASH , level ) ;# ifdef GPAC_MEMORY_TRACKING if ( mem_track ) gf_log_set_tool_level ( GF_LOG_MEMORY , level ) ;# endif e = gf_sys_set_args ( argc , ( const char * * ) argv ) ;if ( e ) {fprintf ( stderr , ""Error<S2SV_blank>assigning<S2SV_blank>libgpac<S2SV_blank>arguments:<S2SV_blank>%s\\\return mp4box_cleanup ( 1 ) ;}if ( raw_cat ) {char chunk [ 4096 ] ;FILE * fin , * fout ;s64 to_copy , done ;fin = gf_fopen ( raw_cat , ""rb"" ) ;if ( ! fin ) return mp4box_cleanup ( 1 ) ;fout = gf_fopen ( inName , ""a+b"" ) ;if ( ! fout ) {gf_fclose ( fin ) ;return mp4box_cleanup ( 1 ) ;}gf_fseek ( fin , 0 , SEEK_END ) ;to_copy = gf_ftell ( fin ) ;gf_fseek ( fin , 0 , SEEK_SET ) ;done = 0 ;while ( 1 ) {u32 nb_bytes = ( u32 ) gf_fread ( chunk , 4096 , fin ) ;gf_fwrite ( chunk , nb_bytes , fout ) ;done += nb_bytes ;fprintf ( stderr , ""Appending<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%02.2f<S2SV_blank>done\\\\r"" , raw_cat , 100.0 * done / to_copy ) ;if ( done >= to_copy ) break ;}gf_fclose ( fin ) ;gf_fclose ( fout ) ;return mp4box_cleanup ( 0 ) ;}if ( compress_top_boxes ) {if ( size_top_box ) {u64 top_size = do_size_top_boxes ( inName , compress_top_boxes , size_top_box ) ;fprintf ( stdout , LLU ""\\\return mp4box_cleanup ( e ? 1 : 0 ) ;}else {e = do_compress_top_boxes ( inName , outName , compress_top_boxes , comp_top_box_version , comp_lzma ) ;return mp4box_cleanup ( e ? 1 : 0 ) ;}}if ( do_mpd_rip ) {e = rip_mpd ( inName , outName ) ;return mp4box_cleanup ( e ? 1 : 0 ) ;}# ifndef GPAC_DISABLE_CORE_TOOLS if ( do_wget != NULL ) {e = gf_dm_wget ( do_wget , inName , 0 , 0 , NULL ) ;if ( e != GF_OK ) {fprintf ( stderr , ""Cannot<S2SV_blank>retrieve<S2SV_blank>%s:<S2SV_blank>%s\\\return mp4box_cleanup ( 1 ) ;}return mp4box_cleanup ( 0 ) ;}# endif if ( udp_dest ) {GF_Socket * sock = gf_sk_new ( GF_SOCK_TYPE_UDP ) ;u16 port = 2345 ;char * sep = strrchr ( udp_dest , \':\' ) ;if ( sep ) {sep [ 0 ] = 0 ;port = atoi ( sep + 1 ) ;}e = gf_sk_bind ( sock , ""127.0.0.1"" , 0 , udp_dest , port , 0 ) ;if ( sep ) sep [ 0 ] = \':\' ;if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>%s\\\else {e = gf_sk_send ( sock , ( u8 * ) inName , ( u32 ) strlen ( inName ) ) ;if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>datagram:<S2SV_blank>%s\\\}gf_sk_del ( sock ) ;return 0 ;}# ifndef GPAC_DISABLE_MPD if ( do_mpd ) {Bool remote = GF_FALSE ;GF_MPD * mpd ;char * mpd_base_url = NULL ;if ( ! strnicmp ( inName , ""http://"" , 7 ) || ! strnicmp ( inName , ""https://"" , 8 ) ) {# if ! defined ( GPAC_DISABLE_CORE_TOOLS ) e = gf_dm_wget ( inName , ""tmp_main.m3u8"" , 0 , 0 , & mpd_base_url ) ;if ( e != GF_OK ) {fprintf ( stderr , ""Cannot<S2SV_blank>retrieve<S2SV_blank>M3U8<S2SV_blank>(%s):<S2SV_blank>%s\\\if ( mpd_base_url ) gf_free ( mpd_base_url ) ;return mp4box_cleanup ( 1 ) ;}remote = GF_TRUE ;# else gf_free ( mpd_base_url ) ;fprintf ( stderr , ""HTTP<S2SV_blank>Downloader<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build\\\return mp4box_cleanup ( 1 ) ;# endif if ( outName ) strcpy ( outfile , outName ) ;else {const char * sep = gf_file_basename ( inName ) ;char * ext = gf_file_ext_start ( sep ) ;if ( ext ) ext [ 0 ] = 0 ;sprintf ( outfile , ""%s.mpd"" , sep ) ;if ( ext ) ext [ 0 ] = \'.\' ;}}else {if ( outName ) strcpy ( outfile , outName ) ;else {char * dst = strdup ( inName ) ;char * ext = strstr ( dst , "".m3u8"" ) ;if ( ext ) ext [ 0 ] = 0 ;sprintf ( outfile , ""%s.mpd"" , dst ) ;gf_free ( dst ) ;}}mpd = gf_mpd_new ( ) ;if ( ! mpd ) {e = GF_OUT_OF_MEM ;fprintf ( stderr , ""[DASH]<S2SV_blank>Error:<S2SV_blank>MPD<S2SV_blank>creation<S2SV_blank>problem<S2SV_blank>%s\\\mp4box_cleanup ( 1 ) ;}FILE * f = gf_fopen ( remote ? ""tmp_main.m3u8"" : inName , ""r"" ) ;u32 manif_type = 0 ;if ( f ) {char szDATA [ 1000 ] ;s32 read ;szDATA [ 999 ] = 0 ;read = ( s32 ) gf_fread ( szDATA , 999 , f ) ;if ( read < 0 ) read = 0 ;szDATA [ read ] = 0 ;gf_fclose ( f ) ;if ( strstr ( szDATA , ""SmoothStreamingMedia"" ) ) manif_type = 2 ;else if ( strstr ( szDATA , ""#EXTM3U"" ) ) manif_type = 1 ;}if ( manif_type == 1 ) {e = gf_m3u8_to_mpd ( remote ? ""tmp_main.m3u8"" : inName , mpd_base_url ? mpd_base_url : inName , outfile , 0 , ""video/mp2t"" , GF_TRUE , use_url_template , segment_timeline , NULL , mpd , GF_TRUE , GF_TRUE ) ;}else if ( manif_type == 2 ) {e = gf_mpd_smooth_to_mpd ( remote ? ""tmp_main.m3u8"" : inName , mpd , mpd_base_url ? mpd_base_url : inName ) ;}else {e = GF_NOT_SUPPORTED ;}if ( ! e ) gf_mpd_write_file ( mpd , outfile ) ;if ( mpd ) gf_mpd_del ( mpd ) ;if ( mpd_base_url ) gf_free ( mpd_base_url ) ;if ( remote ) {gf_file_delete ( ""tmp_main.m3u8"" ) ;}if ( e != GF_OK ) {fprintf ( stderr , ""Error<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s):<S2SV_blank>%s\\\return mp4box_cleanup ( 1 ) ;}else {fprintf ( stderr , ""Done<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s)\\\return mp4box_cleanup ( 0 ) ;}}# endif if ( dash_duration && ! nb_dash_inputs ) {dash_inputs = set_dash_input ( dash_inputs , inName , & nb_dash_inputs ) ;}if ( do_saf && ! encode ) {switch ( get_file_type_by_ext ( inName ) ) {case GF_FILE_TYPE_BT_WRL_X3DV : case GF_FILE_TYPE_XMT_X3D : case GF_FILE_TYPE_SVG : encode = GF_TRUE ;break ;case GF_FILE_TYPE_NOT_SUPPORTED : case GF_FILE_TYPE_ISO_MEDIA : case GF_FILE_TYPE_SWF : case GF_FILE_TYPE_LSR_SAF : break ;}}# ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode == GF_SM_DUMP_SVG ) {if ( strstr ( inName , "".srt"" ) || strstr ( inName , "".ttxt"" ) ) import_subtitle = 2 ;}# endif if ( import_subtitle && ! trackID ) {# ifndef GPAC_DISABLE_MEDIA_IMPORT GF_MediaImporter import ;file = gf_isom_open ( ""ttxt_convert"" , GF_ISOM_OPEN_WRITE , NULL ) ;if ( timescale && file ) gf_isom_set_timescale ( file , timescale ) ;memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ;import . dest = file ;import . in_name = inName ;e = gf_media_import ( & import ) ;if ( e ) {fprintf ( stderr , ""Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\gf_isom_delete ( file ) ;gf_file_delete ( ""ttxt_convert"" ) ;return mp4box_cleanup ( 1 ) ;}strcpy ( outfile , inName ) ;","# else fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\\",163
230,"fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ;}","fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ;}",163
231,test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ;test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ;test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ;result_has_retransmits = j_sender_has_retransmits -> valueint ;,test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuedouble ;test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuedouble ;test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuedouble ;result_has_retransmits = j_sender_has_retransmits -> valueint ;,164
232,jitter = j_jitter -> valuefloat ;cerror = j_errors -> valueint ;,jitter = j_jitter -> valuedouble ;cerror = j_errors -> valueint ;,164
233,"skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;","m -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;",165
234,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",166
235,"uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ;parse_cmd_line ( ""js<S2SV_blank>Uzbl.run(\\\'print<S2SV_blank>@useragent\\\').toUpperCase();"" , result ) ;g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , result -> str ) ;","
",167
236,"if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ;map -> m_flags &= ~ EXT4_MAP_FLAGS ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) {retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ;}else {retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) {ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ;}if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ;}if ( retval > 0 ) {unsigned int status ;if ( unlikely ( retval != map -> m_len ) ) {ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ;WARN_ON ( 1 ) ;if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) {ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ;if ( ret ) {retval = ret ;goto out_sem ;}}if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) {if ( ext4_es_is_written ( & es ) ) goto out_sem ;}status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ;if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ;ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ;if ( ret < 0 ) {retval = ret ;goto out_sem ;}}out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) {ret = check_block_validity ( inode , map ) ;if ( ret != 0 ) return ret ;}return retval ;","if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) return ret ;return retval ;",168
237,head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;track_shift = 2 * head_shift + 3 ;,if ( ! F_SECT_PER_TRACK ) return ;head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;track_shift = 2 * head_shift + 3 ;,169
238,if ( roishift == 0 && bgshift == 0 ) {return ;,"if ( roishift < 0 ) {jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\\roishift = 0 ;}if ( roishift == 0 && bgshift == 0 ) {return ;",170
239,mask = ( 1 << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {,"mask = ( JAS_CAST ( uint_fast32_t , 1 ) << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {",170
240,case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  case EXIT_REASON_INVEPT :  return 1 ;,case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return 1 ;,171
241,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( is_software_event ( event ) ) return 1 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,172
242,int n = 0 ;apr_size_t len = 1 ;,int do_read = 1 ;int n = 0 ;apr_size_t len = 1 ;,173
243,plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ;sock = ap_get_conn_socket ( r -> connection ) ;if ( plaintext ) {,plaintext = ap_lua_ssl_is_https ( r -> connection ) ;while ( do_read ) {do_read = 0 ? 0 : 1 ;sock = ap_get_conn_socket ( r -> connection ) ;if ( plaintext ) {,173
244,"lua_pushboolean ( L , fin ) ;return 2 ;}if ( opcode == 0x09 ) {char frame [ 2 ] ;plen = 2 ;frame [ 0 ] = 0x8A ;frame [ 1 ] = 0 ;apr_socket_send ( sock , frame , & plen ) ;lua_websocket_read ( L ) ;}",do_read = 1 ;}},173
245,"if ( user_ns != mnt_ns -> user_ns )  copy_flags |= CL_SHARED_TO_SLAVE ;new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ;","if ( user_ns != mnt_ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ;new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ;",174
246,void uwbd_stop ( struct uwb_rc * rc )  {kthread_stop ( rc -> uwbd . task ) ;,void uwbd_stop ( struct uwb_rc * rc ) {if ( rc -> uwbd . task ) kthread_stop ( rc -> uwbd . task ) ;,175
247,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",176
248,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",177
249,"SetImageColorspace ( image , GRAYColorspace ) ;if ( scene == 0 ) {","SetImageColorspace ( image , GRAYColorspace ) ;if ( scene == 0 ) {",177
250,"const void * data ;size_t size ;int noffset = 0 ;char * err_msg = """" ;if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) {printf ( ""error!\\\return fit_image_verify_with_data ( fit , image_noffset , data , size ) ;}","const char * name = fit_get_name ( fit , image_noffset , NULL ) ;const void * data ;size_t size ;char * err_msg = """" ;if ( strchr ( name , \'@\' ) ) {err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ;goto err ;}if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) {goto err ;}return fit_image_verify_with_data ( fit , noffset , NULL ) , fit_get_name ( fit , image_noffset , NULL ) ) ;",178
251,if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) )  return FALSE ;if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) )  return FALSE ;,if ( * dp != ( csum & 0xff ) || dp [ 1 ] != ( ( csum >> 8 ) & 0xff ) || dp [ 2 ] != ( ( csum >> 16 ) & 0xff ) || dp [ 3 ] != ( ( csum >> 24 ) & 0xff ) ) return FALSE ;if ( * dp != ( csum & 0xff ) || dp [ 1 ] != ( ( csum >> 8 ) & 0xff ) ) return FALSE ;,179
252,"int ret ;word32 hash_len , hash_enc_len ;# ifdef WOLFSSL_SMALL_STACK byte * hash_data ;# else byte hash_data [ MAX_DER_DIGEST_SZ ] ;# endif if ( data == NULL || data_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) {return BAD_FUNC_ARG ;}if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) {WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ;return BAD_FUNC_ARG ;}ret = wc_HashGetDigestSize ( hash_type ) ;if ( ret < 0 ) {WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len"" ) ;return ret ;}hash_enc_len = hash_len = ret ;# if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) {hash_enc_len += MAX_DER_DIGEST_ASN_SZ ;}# endif # ifdef WOLFSSL_SMALL_STACK hash_data = ( byte * ) XMALLOC ( hash_enc_len , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ;if ( hash_data == NULL ) {return MEMORY_E ;}# endif  ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ;if ( ret == 0 ) {ret = wc_SignatureGenerateHash ( hash_type , sig_type ,  hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ;}}# ifdef WOLFSSL_SMALL_STACK XFREE ( hash_data , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ;# endif return ret ;","return wc_SignatureGenerate_ex ( hash_type , sig_type , data , data_len , hash_data , hash_len ) ;if ( ret == 0 ) {ret = wc_SignatureGenerateHash ( hash_type , sig_type , hash_data , hash_enc_len , sig , sig_len , key , key_len , rng , 1 ) ;",180
253,"if ( copy_in ) {ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ;* bounce_buf_ret = bounce_buf ;hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ;","* bounce_buf_ret = bounce_buf ;if ( copy_in ) {ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ;hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ;",181
254,"static double calculate_modified_err ( const VP9_COMP * cpi ,  const FIRSTPASS_STATS * this_frame ) {const struct twopass_rc * twopass = & cpi -> twopass ;const SVC * const svc = & cpi -> svc ;const FIRSTPASS_STATS * stats ;double av_err ;double modified_error ;if ( svc -> number_spatial_layers > 1 && svc -> number_temporal_layers == 1 ) {twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ;}stats = & twopass -> total_stats ;av_err = stats -> ssim_weighted_pred_err / stats -> count ;modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err /  DOUBLE_DIVIDE_CHECK ( av_err ) ,  cpi -> oxcf . two_pass_vbrbias / 100.0 ) ;return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ;","static double calculate_modified_err ( const VP9_COMP * cpi , const TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const FIRSTPASS_STATS * this_frame ) {const FIRSTPASS_STATS * const stats = & twopass -> total_stats ;av_err = stats -> ssim_weighted_pred_err / stats -> count ;const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ;double modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / DOUBLE_DIVIDE_CHECK ( av_err ) , cpi -> oxcf . two_pass_vbrbias / 100.0 ) ;modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION ) ;return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ;",182
255,"while ( bytes ) {int copy = min ( bytes , iov -> iov_len - base ) ;","while ( bytes || ! iov -> iov_len ) {int copy = min ( bytes , iov -> iov_len - base ) ;",183
256,return FALSE ;},transport -> credssp = NULL ;return FALSE ;},184
257,"return true ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;","return ( * field_rtrn != NULL ) ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;",185
258,int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ;int nStr = ( int ) strlen ( zMatchinfo ) ;pRet = sqlite3_malloc ( nByte + nStr + 1 ) ;if ( pRet ) {,sqlite3_int64 nByte = sizeof ( u32 ) * ( 2 * ( sqlite3_int64 ) nElem + 1 ) + sizeof ( MatchinfoBuffer ) ;sqlite3_int64 nStr = strlen ( zMatchinfo ) ;pRet = sqlite3_malloc ( nByte + nStr + 1 ) ;if ( pRet ) {,186
259,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;save_and_clear_fpu ( ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;save_and_clear_fpu ( ) ;",187
260,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;# endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql_connection ) ;if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",188
261,"memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ;memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ;if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ;","strlcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ;strlcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ;if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ;",189
262,"void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 ,  int c0 , int r1 , int c1 ) {int i ;if ( mat0 -> data_ ) {","void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t c1 ) {int i ;if ( mat0 -> data_ ) {",190
263,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) {return NULL ;,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 1 ) {return NULL ;,191
264,"case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;","# if 0 case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;",191
265,"case DW_FORM_data2 :  value -> encoding . data = READ ( buf , ut16 ) ;case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}","case DW_FORM_data2 : value -> encoding . data = READ ( buf , ut16 ) ;# endif case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}",191
266,"struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;","struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;",192
267,"void HTML_put_string ( HTStructured * me , const char * s )  {# ifdef USE_PRETTYSRC char * translated_string = NULL ;","void HTML_put_string ( HTStructured * me , const char * s ) {HTChunk * target = NULL ;# ifdef USE_PRETTYSRC char * translated_string = NULL ;",193
268,"case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;break ;case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;break ;case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;break ;case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;break ;case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;break ;case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;break ;","case HTML_TITLE : target = & me -> title , s ) ;break ;case HTML_STYLE : target = & me -> style_block , s ) ;break ;case HTML_SCRIPT : target = & me -> script , s ) ;break ;case HTML_OBJECT : target = & me -> object , s ) ;break ;case HTML_TEXTAREA : target = & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION : target = & me -> option , s ) ;break ;case HTML_MATH : target = & me -> math , s ) ;break ;",193
269,"
","if ( target != NULL ) {if ( target -> data == s ) {CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\\\'\\\}else {HTChunkPuts ( target , s ) ;}}",193
270,# ifdef USE_PRETTYSRC  if ( psrc_convert_string ) {,# ifdef USE_PRETTYSRC if ( psrc_convert_string ) {,193
271,"static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , va_list args ) {",194
272,when = timespec_to_ns ( new_setting -> it_value ) ;period = timespec_to_ns ( new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( n ) ;if ( when > now ) when -= now ;,when = timespec_to_ns ( & new_setting -> it_value ) ;period = timespec_to_ns ( & new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( & n ) ;if ( when > now ) when -= now ;,195
273,break ;},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;},196
274,"sprintf ( descriptor -> msg , ""\\\","sprintf ( descriptor -> msg , ""\\\",197
275,if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {,if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,197
276,"if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO )  && ext4_can_extents_be_merged ( inode , ex , newext ) ) {","if ( ex && ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) && ext4_can_extents_be_merged ( inode , ex , newext ) ) {",198
277,"merge :  if ( flag != EXT4_GET_BLOCKS_PRE_IO )  ext4_ext_try_to_merge ( inode , path , nearex ) ;","merge : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( inode , path , nearex ) ;",198
278,"static int  mptctl_replace_fw ( unsigned long arg )  {MPT_ADAPTER * ioc ;int iocnum ;return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_replace_fw ( MPT_ADAPTER * ioc , unsigned long arg ) {return - EFAULT ;",199
279,"if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 )  {read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ;if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) {","if ( ( addr_fd = TEMP_FAILURE_RETRY ( open ( val , O_RDONLY ) ) ) != - 1 ) {TEMP_FAILURE_RETRY ( read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ) ;if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) {",200
280,op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;++ reg_index ;}op -> offset += temp ;op -> regs [ reg_index ] = X86R_UNDEFINED ;},+ reg_index ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;}++ reg_index ;}op -> offset += temp ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = X86R_UNDEFINED ;}},201
281,"
","value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . Assign . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . For . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . With . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;",202
282,"break ;case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ;","break ;case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ;",202
283,"break ;case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ;","break ;case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ;",202
284,"break ;case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ;","break ;case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ;",202
285,"break ;case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ;","break ;case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ;",202
286,"break ;case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ;","break ;case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ;",202
287,"break ;case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ;","break ;case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ;",202
288,"break ;case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ;","break ;case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ;",202
289,if ( qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,203
290,"if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & context_expr , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""context_expr\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ;if ( exists_not_none ( obj , & PyId_optional_vars ) ) {res = obj2ast_expr ( tmp , & optional_vars , arena ) ;if ( res != 0 ) goto failed ;else {","if ( lookup_attr_id ( obj , & PyId_context_expr ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""context_expr\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ;else {if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;else {int res ;res = obj2ast_expr ( tmp , & optional_vars , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",204
291,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",205
292,"( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;while ( ( c = ReadBlobByte ( image ) ) == 0 ) ;if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;version = ( ssize_t ) ReadBlobByte ( image ) ;if ( version == 2 ) {c = ReadBlobByte ( image ) ;if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;flags = 0 ;image -> depth = 8 ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;image -> resolution . x = DefaultResolution ;image -> resolution . y = DefaultResolution ;image -> units = UndefinedResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;jpeg = MagickFalse ;for ( code = 0 ;EOFBlob ( image ) == MagickFalse ;) {if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ;if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ;if ( code < 0 ) break ;if ( code == 0 ) continue ;if ( code > 0xa1 ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ;}else {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ;switch ( code ) {case 0x01 : {length = ReadBlobMSBShort ( image ) ;if ( length != 0x000a ) {for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;break ;}case 0x12 : case 0x13 : case 0x14 : {ssize_t pattern ;size_t height , width ;pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < 8 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( pattern == 2 ) {for ( i = 0 ;i < 5 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ;length = ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = ( size_t ) pixmap . component_size ;image -> resolution . x = 1.0 * pixmap . horizontal_resolution ;image -> resolution . y = 1.0 * pixmap . vertical_resolution ;image -> units = PixelsPerInchResolution ;( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i <= ( ssize_t ) length ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;width = ( size_t ) ( frame . bottom - frame . top ) ;height = ( size_t ) ( frame . right - frame . left ) ;if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ;if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ;if ( length == 0 ) length = width ;if ( length < 8 ) {for ( i = 0 ;i < ( ssize_t ) ( length * height ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( i = 0 ;i < ( ssize_t ) height ;i ++ ) {if ( EOFBlob ( image ) != MagickFalse ) break ;if ( length > 200 ) {for ( j = 0 ;j < ( ssize_t ) ReadBlobMSBShort ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( j = 0 ;j < ( ssize_t ) ReadBlobByte ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}break ;}case 0x1b : {image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;break ;}case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : {PICTRectangle source , destination ;register unsigned char * p ;size_t j ;ssize_t bytes_per_line ;unsigned char * pixels ;bytes_per_line = 0 ;if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ;else {( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ;if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) {if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image -> depth = ( size_t ) pixmap . component_size ;tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ;tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ;tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ;tile_image -> units = PixelsPerInchResolution ;if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ;}if ( ( code != 0x9a ) && ( code != 0x9b ) ) {tile_image -> colors = 2 ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ;}status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ;if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {j = ReadBlobMSBShort ( image ) % tile_image -> colors ;if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ;tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;}}else {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ;tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ;tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ;}}}if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ;else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ;if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ;p = pixels ;for ( y = 0 ;y < ( ssize_t ) tile_image -> rows ;y ++ ) {if ( p > ( pixels + extent + image -> columns ) ) {pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;}q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) tile_image -> columns ;x ++ ) {if ( tile_image -> storage_class == PseudoClass ) {index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ;SetPixelIndex ( tile_image , index , q ) ;SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ;SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ;SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ;}else {if ( pixmap . bits_per_pixel == 16 ) {i = ( ssize_t ) ( * p ++ ) ;j = ( size_t ) ( * p ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ;}else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) {if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;}else {if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ;}}p ++ ;q += GetPixelChannels ( tile_image ) ;}if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ;if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) {p += ( pixmap . component_count - 1 ) * tile_image -> columns ;if ( p < pixels ) break ;}status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ;if ( status == MagickFalse ) break ;}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ;tile_image = DestroyImage ( tile_image ) ;break ;}case 0xa1 : {unsigned char * info ;size_t type ;type = ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;if ( length == 0 ) break ;( void ) ReadBlobMSBLong ( image ) ;length -= MagickMin ( length , 4 ) ;if ( length == 0 ) break ;info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ;if ( info == ( unsigned char * ) NULL ) break ;count = ReadBlob ( image , length , info ) ;if ( count != ( ssize_t ) length ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ;}switch ( type ) {case 0xe0 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""icc"" , profile , exception ) ;profile = DestroyStringInfo ( profile ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case 0x1f2 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""iptc"" , profile , exception ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}profile = DestroyStringInfo ( profile ) ;break ;}default : break ;}info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;break ;}default : {if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ;else for ( i = 0 ;i < ( ssize_t ) codes [ code ] . length ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}}}if ( code == 0xc00 ) {for ( i = 0 ;i < 24 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;continue ;}if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ;if ( code == 0x8200 ) {char filename [ MaxTextExtent ] ;FILE * file ;int unique_file ;jpeg = MagickTrue ;read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ;ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ;}length = ReadBlobMSBLong ( image ) ;if ( length > 154 ) {for ( i = 0 ;i < 6 ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) {( void ) fclose ( file ) ;( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}for ( i = 0 ;i < 122 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i < ( ssize_t ) ( length - 154 ) ;i ++ ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",205
293,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,206
294,"static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , va_list args ) {",207
295,"enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ;if ( rc == IMAP_EXEC_FATAL ) goto bail ;","enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ;mutt_socket_empty ( adata -> conn ) ;if ( rc == IMAP_EXEC_FATAL ) goto bail ;",208
296,"log_file = NULL ;}if ( ! name ) return ;file_name = make_file_name ( name , prog , namespace , instance ) ;log_file = fopen ( file_name , ""a"" ) ;if ( log_file ) {","log_file = fopen_safe ( file_name , ""a"" ) ;if ( log_file ) {",209
297,f2fs_wait_discard_bios ( sbi ) ;out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ;,"f2fs_wait_discard_bios ( sbi , false ) ;out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ;",210
298,"int frame_avail , got_data ;struct VpxInputContext input = {0 };struct VpxEncoderConfig global ;exec_name = argv_ [ 0 ] ;if ( argc < 3 ) usage_exit ( ) ;input . framerate . numerator = 30 ;input . framerate . denominator = 1 ;input . use_i420 = 1 ;input . only_i420 = 1 ;argv = argv_dup ( argc - 1 , argv_ + 1 ) ;parse_global_config ( & global , argv ) ;{","# if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ;int allocated_raw_shift = 0 ;int use_16bit_internal = 0 ;int input_shift = 0 ;# endif int frame_avail , got_data ;struct VpxInputContext input ;struct VpxEncoderConfig global ;memset ( & input , 0 , sizeof ( input ) ) ;exec_name = argv_ [ 0 ] ;if ( argc < 3 ) usage_exit ( ) ;input . only_i420 = 1 ;input . use_i420 = 1 ;input . only_i420 = 1 ;argv = argv_dup ( argc - 1 , argv_ + 1 ) ;parse_global_config ( & global , argv ) ;{",211
299,"int64_t average_rate = - 1 ;off_t lagged_count = 0 ;open_input_file ( & input ) ;if ( ! input . width || ! input . height )  FOREACH_STREAM ( {}if ( ! input . width || ! input . height ) fatal ( ""Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>""  ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ;FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ;","int64_t lagged_count = 0 ;open_input_file ( & input ) ;if ( ! input . width || ! input . height ) {FOREACH_STREAM ( {}) ;}if ( ! input . width || ! input . height ) fatal ( ""Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>"" ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ;if ( ! input . bit_depth ) {FOREACH_STREAM ( {if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ;else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ;}) ;if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ;}else {FOREACH_STREAM ( {stream -> config . cfg . g_input_bit_depth = input . bit_depth ;}}FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ;",211
300,"if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , 0 , sizeof ( raw ) ) ;else vpx_img_alloc ( & raw ,  input . use_i420 ? VPX_IMG_FMT_I420  : VPX_IMG_FMT_YV12 , input . width , input . height , 32 ) ;FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global . framerate ) ) ;FOREACH_STREAM ( open_output_file ( stream , & global ) ) ;FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ;frame_avail = 1 ;","if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , input . fmt , input . width , input . height , 32 ) ;FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global , & input . pixel_aspect_ratio . framerate ) ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , ""vp9"" ) == 0 || strcmp ( global . codec -> name , ""vp10"" ) == 0 ) {FOREACH_STREAM ( {if ( stream -> config . use_16bit_internal ) {use_16bit_internal = 1 ;}if ( stream -> config . cfg . g_profile == 0 ) {input_shift = 0 ;else {input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ;}}) ;}# endif }FOREACH_STREAM ( open_output_file ( stream , & global ) ) ;FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ;frame_avail = 1 ;",211
301,"fprintf ( stderr , ""\\\\033[K"" ) ;}if ( frames_in > global . skip_frames ) {vpx_usec_timer_start ( & timer ) ;vpx_usec_timer_mark ( & timer ) ;cx_time += vpx_usec_timer_elapsed ( & timer ) ;if ( ! got_data && input . length && ! streams -> frames_out ) {lagged_count = global . limit ? seen_frames : ftello ( input . file ) ;off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ;rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ;off_t input_pos = ftello ( input . file ) ;off_t input_pos_lagged = input_pos - lagged_count ;int64_t limit = input . length ;rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ;","}if ( frames_in > global . skip_frames ) {# if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ;if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) {assert ( use_16bit_internal ) ;if ( ! allocated_raw_shift ) {vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ;allocated_raw_shift = 1 ;}vpx_img_upshift ( & raw_shift , & raw , input_shift ) ;frame_to_encode = & raw_shift ;}else {frame_to_encode = & raw ;}vpx_usec_timer_start ( & timer ) ;if ( use_16bit_internal ) {assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ;FOREACH_STREAM ( {if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ;else assert ( 0 ) ;}) ;}else {assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ;FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ;# endif }# else vpx_usec_timer_start ( & timer ) ;vpx_usec_timer_mark ( & timer ) ;cx_time += vpx_usec_timer_elapsed ( & timer ) ;if ( ! got_data && input . length && streams != NULL && ! streams -> frames_out ) {lagged_count = global . limit ? seen_frames : ftello ( input . file ) ;const int64_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ;rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ;const int64_t input_pos = ftello ( input . file ) ;const int64_t input_pos_lagged = input_pos - lagged_count ;const int64_t limit = input . length ;rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ;",211
302,"}if ( stream_cnt > 1 ) fprintf ( stderr , ""\\\if ( ! global . quiet )  FOREACH_STREAM ( fprintf ( stderr ,  ""\\\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7lub/f<S2SV_blank>%7"" PRId64 ""b/s""  ""<S2SV_blank>%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\033[K\\\) ;if ( global . show_psnr )  FOREACH_STREAM ( show_psnr ( stream ) ) ;FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ;","if ( ! global . quiet ) {fprintf ( stderr , ""\\\\033[K"" ) ;}if ( stream_cnt > 1 ) fprintf ( stderr , ""\\\if ( ! global . quiet ) FOREACH_STREAM ( fprintf ( stderr , ""\\\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7"" PRId64 ""b/f<S2SV_blank>%7"" PRId64 ""b/s"" ""<S2SV_blank>%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\033[K\\\}if ( global . show_psnr ) {if ( global . codec -> fourcc == VP9_FOURCC ) {FOREACH_STREAM ( show_psnr ( stream , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ;# if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ;# endif }else {FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ;}) ;# endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift }FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ;",211
303,"FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ;if ( global . pass ) break ;","FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ;if ( global . pass ) break ;",211
304,}# endif vpx_img_free ( & raw ) ;,}# endif vpx_img_free ( & raw ) ;switch ( global . color_type ) {case I420 : input . fmt = VPX_IMG_FMT_I420 ;break ;case I422 : input . fmt = VPX_IMG_FMT_I422 ;break ;case I444 : input . fmt = VPX_IMG_FMT_I444 ;break ;case I440 : input . fmt = VPX_IMG_FMT_I440 ;break ;case YV12 : input . fmt = VPX_IMG_FMT_YV12 ;break ;},211
305,int opts ;Resub m ;,int result ;int opts ;Resub m ;,212
306,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;",212
307,"uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out )  {if ( mp4 == NULL ) return 0 ;if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ;* in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;* out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;return 0 ;}","uint32_t GetPayloadTime ( size_t handle , uint32_t index , double * in , float * out ) {if ( mp4 == NULL ) return GPMF_ERROR_MEMORY ;if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return GPMF_ERROR_MEMORY ;* in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;* out = ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;return GPMF_OK ;}",213
308,uint32_t id ;ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;,"uint32_t id ;if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;size_left = 0 ;continue ;}ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;",214
309,"separator = strchr ( connection -> buffer , \':\' ) ;if ( separator != NULL ) {","separator = osStrchr ( connection -> buffer , \':\' ) ;if ( separator != NULL ) {",215
310,if ( option ) {if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) {,( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ;if ( option ) {if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) {,216
311,"}rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ;","if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) {( * session_ptr ) -> max_settings = option -> max_settings ;}}rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ;",216
312,"if ( rc < 0 )   dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\\","if ( rc != KLSI_STATUSBUF_LEN ) {dev_err ( & port -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\\if ( rc >= 0 ) rc = - EIO ;}",217
313,"case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ;w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ;if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ;return 1 ;case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ;cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ;w = cpu -> type ;if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ;return 1 ;case GSI_GET_HWRPB :  if ( nbytes < sizeof ( * hwrpb ) )  return - EINVAL ;",case GSI_UACPROC : if ( nbytes > sizeof ( * hwrpb ) ) return - EINVAL ;,218
314,"else  jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\}","else {jsExceptionHere ( JSET_ERROR , ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\return 0 ;}if ( gfx . data . height & 7 ) {jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\\return 0 ;}}",219
315,"if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) )  return 1 ;if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL ||  ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX &&  inode -> i_flock -> fl_type != F_RDLCK ) ) )  return 1 ;",if ( inode -> i_flock == NULL || ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && inode -> i_flock -> fl_type != F_RDLCK ) ) ) return 1 ;,220
316,"static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags ,  const struct oe_sockaddr * src_addr ,  oe_socklen_t * addrlen ) {oe_socklen_t addrlen_in = 0 ;oe_errno = 0 ;if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen ) addrlen_in = * addrlen ;if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags ,  ( struct oe_sockaddr * ) src_addr ,  addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;","static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags , struct oe_sockaddr * src_addr , oe_socklen_t * addrlen ) {oe_socklen_t addrlen_in = 0 ;oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( src_addr && addrlen ) addrlen_in = * addrlen ;if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags , src_addr , addrlen_in , addrlen ) != OE_OK ) {if ( src_addr && addrlen ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;* addrlen = addrlen_out ;}if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;",221
317,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ;else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {i_temp = ih264d_read_mmco_commands ( ps_dec ) ;if ( i_temp < 0 ) {return ERROR_DBP_MANAGER_T ;}ps_dec -> u4_bitoffset = i_temp ;}else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,222
318,"static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r ,  int size_group ) {const MB_PREDICTION_MODE y_mode = read_intra_mode ( r ,   cm -> fc . y_mode_prob [ size_group ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ;","static PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , int size_group ) {const PREDICTION_MODE y_mode = read_intra_mode ( r , cm -> fc -> y_mode_prob [ size_group ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> y_mode [ size_group ] [ y_mode ] ;",223
319,"case MAPI_ATTACH_LONG_FILENAME :  if ( file -> name ) XFREE ( file -> name ) ;file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ;case MAPI_ATTACH_DATA_OBJ :  file -> len = a -> values [ 0 ] . len ;if ( file -> data ) XFREE ( file -> data ) ;case MAPI_ATTACH_MIME_TAG :  if ( file -> mime_type ) XFREE ( file -> mime_type ) ;file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;case MAPI_ATTACH_CONTENT_ID :  if ( file -> content_id ) XFREE ( file -> content_id ) ;file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;","case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ;if ( file -> name ) XFREE ( file -> name ) ;file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ;case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ;file -> len = a -> values [ 0 ] . len ;if ( file -> data ) XFREE ( file -> data ) ;case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ;if ( file -> mime_type ) XFREE ( file -> mime_type ) ;file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;if ( file -> content_id ) XFREE ( file -> content_id ) ;file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;",224
320,"final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;fl6 -> saddr = ireq -> ir_v6_loc_addr ;fl6 -> flowi6_oif = ireq -> ir_iif ;","rcu_read_lock ( ) ;final_p = fl6_update_dst ( fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;fl6 -> saddr = ireq -> ir_v6_loc_addr ;fl6 -> flowi6_oif = ireq -> ir_iif ;",225
321,new -> cid_mask = 0 ;,new -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;0 ;,226
322,new -> cid_mask = new -> lid_mask = 0xffff ;},new -> cid_mask = new -> lid_mask = 0xffff ;},226
323,"# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;","# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;",227
324,"case SIG ( \'E\' , \'R\' ) :  ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;","case SIG ( \'E\' , \'R\' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;",227
325,"return ( mhlen ) ;break ;if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ;return ( mhlen ) ;trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ( mhlen ) ;}",return ( - 1 ) ;,228
326,int rc = 0 ;if ( ! ss_initialized ) {,int rc = 0 ;if ( ! scontext_len ) return - EINVAL ;if ( ! ss_initialized ) {,229
327,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,230
328,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",230
329,"
",LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;,230
330,l_row -- ;l_column -- ;,l_row -- ;l_column -- ;,230
331,"float * w = get_window ( f , n ) ;for ( i = 0 ;","float * w = get_window ( f , n ) ;if ( w == NULL ) return 0 ;for ( i = 0 ;",231
332,"if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) {ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;","if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;",232
333,for ( n = 0 ;n ++ )  {,"if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;for ( n = 0 ;n ++ ) {",232
334,"struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int i , j ;","tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int i , j ;",233
335,"if ( ! x -> skip_recode )   vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) {optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ;}switch ( tx_size ) {case TX_32X32 :  vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_16X16 :  vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_8X8 :  vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_4X4 :  xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;}","if ( ! x -> skip_recode ) {if ( x -> quant_fp ) {if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) {p -> eobs [ block ] = 0 ;* a = * l = 0 ;return ;}else {vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ;}else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) {vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ;}else {p -> eobs [ block ] = 0 ;* a = * l = 0 ;return ;}}else {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;}}}}}else {if ( max_txsize_lookup [ plane_bsize ] == tx_size ) {int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ;if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) {const int ctx = combine_entropy_contexts ( * a , * l ) ;* a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 ;}# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {switch ( tx_size ) {case TX_32X32 : vp9_highbd_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;case TX_16X16 : vp9_highbd_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;case TX_8X8 : vp9_highbd_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;case TX_4X4 : x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ;}return ;}# endif switch ( tx_size ) {case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;break ;}",233
336,"
","if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",234
337,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,234
338,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,235
339,for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,if ( in_dev -> dead ) goto no_promotions ;for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,236
340,"}if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;","}no_promotions : if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;",236
341,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,237
342,BUG ( ) ;}BUG ( ) ;},return false ;}}else if ( r -> CRn == 0 && r -> CRm == 9 ) {if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ;idx = ARMV8_PMU_CYCLE_IDX ;return false ;},238
343,"static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx )  {make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ;index = pending_index ( netbk -> pending_prod ++ ) ;","static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx , u8 status ) {make_tx_response ( vif , & pending_tx_info -> req , status ) ;index = pending_index ( netbk -> pending_prod ++ ) ;",239
344,"goto try_again ;req -> status = 0 ;req -> zero = 0 ;req -> length = count ;req -> complete = f_hidg_req_complete ;req -> context = hidg ;status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ;if ( status < 0 ) {ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\\goto release_write_pending_unlocked ;}spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked :  hidg -> write_pending = 0 ;","goto release_write_pending ;spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked : hidg -> write_pending = 0 ;",240
345,"ret = snprintf ( path , PATH_MAX , SBINDIR ""/init.lxc.static"" ) ;","ret = safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount ) ;",241
346,"ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ;","ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ;",241
347,"status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {","inode_dio_wait ( inode ) ;status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {",242
348,if ( status )  goto bail_unlock ;inode_dio_wait ( inode ) ;,if ( status ) goto bail_unlock ;,242
349,"count = yr_max ( 64 , ( index + 1 ) * 2 ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc (  array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;","count = 64 ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;",243
350,"if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) {printk ( ""sysinfo(%d)"" , command ) ;goto out ;}down_read ( & uts_sem ) ;res = sysinfo_table [ offset ] ;len = strlen ( res ) + 1 ;if ( len > count )  len = count ;",if ( ( unsigned long ) len > ( unsigned long ) count ) len = count ;,244
351,"if ( ( mask & ~ ALL_PRINC_MASK ) )  return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;","if ( mask & KADM5_TL_DATA ) {for ( tl_data_tail = entry -> tl_data ;tl_data_tail != NULL ;tl_data_tail = tl_data_tail -> tl_data_next ) {if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;}}if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;",245
352,"int rose_parse_facilities ( unsigned char * p ,  struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 )  return 0 ;while ( facilities_len > 0 ) {if ( * p == 0x00 ) {if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\facilities_len -- ;p ++ ;else break ;}return 1 ;","int rose_parse_facilities ( unsigned char * p , unsigned packet_len , struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 || ( unsigned ) facilities_len > packet_len ) return 0 ;while ( facilities_len >= 3 && * p == 0x00 ) {break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\len = 1 ;if ( len < 0 ) return 0 ;if ( WARN_ON ( len >= facilities_len ) ) return 0 ;facilities_len -= len + 1 ;return facilities_len == 0 ;",246
353,"if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",247
354,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",248
355,"media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;","memset ( & pad , 0 , sizeof ( pad ) ) ;media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;",249
356,"media_device_kpad_to_upad ( entity -> links [ l ] . source ,  & link . source ) ;","memset ( & link , 0 , sizeof ( link ) ) ;media_device_kpad_to_upad ( entity -> links [ l ] . source , & link . source ) ;",249
357,efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ;rc = efx_probe_channels ( efx ) ;,BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ;if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) {rc = - EINVAL ;goto fail3 ;}efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ;rc = efx_probe_channels ( efx ) ;,250
358,struct sock * sk = sock -> sk ;struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ;,struct sock * sk = sock -> sk ;,251
359,if ( ! err ) {if ( sat ) {}msg -> msg_namelen = sizeof ( * sat ) ;,if ( ! err && msg -> msg_name ) {struct sockaddr_at * sat = msg -> msg_name ;msg -> msg_namelen = sizeof ( * sat ) ;,251
360,"if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ;GET_HANDLE ( ) ;if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ;goto cleanup ;}if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ;filtuser = ldap_filter_correct ( user ) ;if ( filtuser == NULL ) {st = ENOMEM ;goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ;else optype = MODIFY_PRINCIPAL ;if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ;if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ;if ( entry -> mask & KADM5_LOAD ) {unsigned int tree = 0 ;int numlentries = 0 ;char * filter = NULL ;if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) {filter = NULL ;if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ;found_entry = FALSE ;for ( tree = 0 ;found_entry == FALSE && tree < ntrees ;++ tree ) {if ( principal_dn == NULL ) {LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ;}else {LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ;}if ( st == LDAP_SUCCESS ) {numlentries = ldap_count_entries ( ld , result ) ;if ( numlentries > 1 ) {free ( filter ) ;st = EINVAL ;k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>found"" ) , user ) ;goto cleanup ;}else if ( numlentries == 1 ) {found_entry = TRUE ;if ( principal_dn == NULL ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) {ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ;st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}}}}}else if ( st != LDAP_NO_SUCH_OBJECT ) {st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}ldap_msgfree ( result ) ;result = NULL ;}free ( filter ) ;if ( found_entry == FALSE && principal_dn != NULL ) {create_standalone_prinicipal = TRUE ;standalone_principal_dn = strdup ( principal_dn ) ;CHECK_NULL ( standalone_principal_dn ) ;}}if ( principal_dn == NULL && xargs . dn == NULL ) {if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}else if ( xargs . containerdn ) {if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) {if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) {int ost = st ;st = EINVAL ;k5_prependmsg ( context , ost , st , _ ( ""\\\'%s\\\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ;}goto cleanup ;}subtree = strdup ( xargs . containerdn ) ;}else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) {subtree = strdup ( ldap_context -> lrparams -> containerref ) ;}else {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}CHECK_NULL ( subtree ) ;if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ;CHECK_NULL ( standalone_principal_dn ) ;create_standalone_prinicipal = TRUE ;free ( subtree ) ;subtree = NULL ;}if ( xargs . dn_from_kbd == TRUE ) {int dnlen = 0 , subtreelen = 0 ;char * dn = NULL ;krb5_boolean outofsubtree = TRUE ;if ( xargs . dn != NULL ) {dn = xargs . dn ;}else if ( xargs . linkdn != NULL ) {dn = xargs . linkdn ;}else if ( standalone_principal_dn != NULL ) {dn = standalone_principal_dn ;}if ( subtreelist == NULL ) {st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ;if ( st ) goto cleanup ;}for ( tre = 0 ;tre < ntrees ;++ tre ) {if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) {outofsubtree = FALSE ;break ;}else {dnlen = strlen ( dn ) ;subtreelen = strlen ( subtreelist [ tre ] ) ;if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) {outofsubtree = FALSE ;break ;}}}if ( outofsubtree == TRUE ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ;goto cleanup ;}if ( standalone_principal_dn == NULL ) {char * attributes [ ] = {""krbticketpolicyreference"" , ""krbprincipalname"" , NULL };ldap_msgfree ( result ) ;result = NULL ;LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ;if ( st == LDAP_SUCCESS ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) {ldap_value_free ( values ) ;}if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) {krb_identity_exists = TRUE ;ldap_value_free ( values ) ;}}}else {st = set_ldap_error ( context , st , OP_SEARCH ) ;goto cleanup ;}}}if ( xargs . dn != NULL && krb_identity_exists == TRUE ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( xargs . linkdn != NULL ) {if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}{char * * linkdns = NULL ;int j = 0 ;if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) {snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( linkdns != NULL ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;for ( j = 0 ;linkdns [ j ] != NULL ;++ j ) free ( linkdns [ j ] ) ;free ( linkdns ) ;goto cleanup ;}}establish_links = TRUE ;}if ( entry -> mask & KADM5_LAST_SUCCESS ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_LAST_FAILED ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) {krb5_kvno fail_auth_count ;fail_auth_count = entry -> fail_auth_count ;if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ;st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) {int attr_mask = 0 ;krb5_boolean has_fail_count ;st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ;if ( st != 0 ) goto cleanup ;has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ;# ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ;if ( st != 0 ) goto cleanup ;}else {# endif if ( has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ;if ( st != 0 ) goto cleanup ;# ifdef LDAP_MOD_INCREMENT }# endif }else if ( optype == ADD_PRINCIPAL ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ;}if ( entry -> mask & KADM5_MAX_LIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_MAX_RLIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_ATTRIBUTES ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) {memset ( strval , 0 , sizeof ( strval ) ) ;strval [ 0 ] = user ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_PW_EXPIRATION ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_POLICY ) {memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ;for ( tl_data = entry -> tl_data ;tl_data ;tl_data = tl_data -> tl_data_next ) {if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) {if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) {goto cleanup ;}break ;}}if ( princ_ent . aux_attributes & KADM5_POLICY ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ;strval [ 0 ] = polname ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}else {st = EINVAL ;k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ;goto cleanup ;}}else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_POLICY_CLR ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) {krb5_kvno mkvno ;if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ;bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ;if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" ,   LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 )  goto cleanup ;","if ( bersecretkey == NULL ) {+ tree ) {+ tre ) {+ j ) free ( linkdns [ j ] ) ;if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) {st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) goto cleanup ;",252
361,"pirlvl = pi -> picomp -> pirlvls ;pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;","pirlvl = pi -> picomp -> pirlvls ;if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;",253
362,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",253
363,bh -> b_size = map . m_len << inode -> i_blkbits ;},bh -> b_size = ( u64 ) map . m_len << inode -> i_blkbits ;},254
364,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,255
365,"memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;","if ( l > ll ) l = ll ;memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;",256
366,addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;,"memset ( addr , 0 , sizeof ( * addr ) ) ;addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;",257
367,file_sb_list_del ( file ) ;BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ;,BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ;,258
368,for ( i = 0 ;i < 4 && out -> data [ i ] ;int hsub = s -> draw . hsub [ i ] ;,for ( i = 0 ;i < 4 && out -> data [ i ] && out -> linesize [ i ] ;int hsub = s -> draw . hsub [ i ] ;,259
369,WORD16 i2_level_arr [ 16 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,WORD16 ai2_level_arr [ 19 ] ;WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,260
370,"image = 0 ;info = 0 ;if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\","bmp_dec_importopts_t opts ;size_t num_samples ;image = 0 ;info = 0 ;if ( bmp_dec_parseopts ( optstr , & opts ) ) {goto error ;",261
371,"jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;","jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;}if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) {jas_eprintf ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\\goto error ;}if ( opts . max_samples > 0 && num_samples > opts . max_samples ) {jas_eprintf ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\\goto error ;",261
372,"q = strchr ( context -> buffer , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;q = strchr ( uri , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;","q = osStrchr ( context -> buffer , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;q = osStrchr ( uri , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;",262
373,"BUG_ON ( ! thresholds ) ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;","BUG_ON ( ! thresholds ) ;if ( ! thresholds -> primary ) goto unlock ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;",263
374,mutex_unlock ( & memcg -> thresholds_lock ) ;},unlock : mutex_unlock ( & memcg -> thresholds_lock ) ;},263
375,"char query [ 255 ] ;MYSQL_FIELD * field ;fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>databases:<S2SV_blank>%s\\\return 1 ;}if ( wild && mysql_num_rows ( result ) == 1 ) {row = mysql_fetch_row ( result ) ;if ( ! my_strcasecmp ( & my_charset_latin1 , row [ 0 ] , wild ) ) {mysql_free_result ( result ) ;if ( opt_status ) return list_table_status ( mysql , wild , NULL ) ;else return list_tables ( mysql , wild , NULL ) ;}}if ( wild ) printf ( ""Wildcard:<S2SV_blank>%s\\\header = ""Databases"" ;length = ( uint ) strlen ( header ) ;field = mysql_fetch_field ( result ) ;if ( length < field -> max_length ) length = field -> max_length ;if ( ! opt_verbose ) print_header ( header , length , NullS ) ;else if ( opt_verbose == 1 ) print_header ( header , length , ""Tables"" , 6 , NullS ) ;else print_header ( header , length , ""Tables"" , 6 , ""Total<S2SV_blank>Rows"" , 12 , NullS ) ;while ( row || ( row = mysql_fetch_row ( result ) ) ) {counter ++ ;if ( opt_verbose ) {if ( ! ( mysql_select_db ( mysql , row [ 0 ] ) ) ) {MYSQL_RES * tresult = mysql_list_tables ( mysql , ( char * ) NULL ) ;if ( mysql_affected_rows ( mysql ) > 0 ) {sprintf ( tables , ""%6lu"" , ( ulong ) mysql_affected_rows ( mysql ) ) ;rowcount = 0 ;if ( opt_verbose > 1 ) {MYSQL_ROW trow ;while ( ( trow = mysql_fetch_row ( tresult ) ) ) {sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ;if ( ! ( mysql_query ( mysql , query ) ) ) {","char query [ NAME_LEN + 100 ] ;MYSQL_FIELD * field ;my_snprintf ( query , sizeof ( query ) , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ;if ( ! ( mysql_query ( mysql , query ) ) ) {",264
376,}return 0 ;,return - ENOMEM ;}return 0 ;,265
377,"skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;","m -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;",266
378,"tok -> err = json_tokener_success ;while ( PEEK_CHAR ( c , tok ) ) {","tok -> err = json_tokener_success ;if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) {tok -> err = json_tokener_error_size ;return NULL ;}while ( PEEK_CHAR ( c , tok ) ) {",267
379,"ascii = malloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;","ascii = safe_calloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;",268
380,ascii = malloc ( str_len ) ;for ( ;,ascii = safe_calloc ( str_len ) ;for ( ;,268
381,"char * *  prepenv ( const struct rule * rule )  {static const char * safeset [ ] = {""DISPLAY"" , ""HOME"" , ""LOGNAME"" , ""MAIL"" , ""PATH"" , ""TERM"" , ""USER"" , ""USERNAME"" , NULL };env = createenv ( rule ) ;if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ;","char * * prepenv ( const struct rule * rule , const struct passwd * mypw , const struct passwd * targpw ) {env = createenv ( rule ) ;if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ;",269
382,"if ( hashbin -> hb_type & HB_LOCK ) {spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ;}queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;while ( queue ) {if ( free_func )  ( * free_func ) ( queue ) ;queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;}}hashbin -> hb_current = NULL ;hashbin -> magic = ~ HB_MAGIC ;if ( hashbin -> hb_type & HB_LOCK ) {spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP  hashbin_lock_depth -- ;","if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ;while ( 1 ) {queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;if ( ! queue ) break ;if ( free_func ) {if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;free_func ( queue ) ;if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP hashbin_lock_depth -- ;",270
383,section -> spatial_layer_id = frame -> spatial_layer_id ;section -> intra_error += frame -> intra_error ;section -> coded_error += frame -> coded_error ;section -> sr_coded_error += frame -> sr_coded_error ;section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ;section -> pcnt_inter += frame -> pcnt_inter ;section -> pcnt_neutral += frame -> pcnt_neutral ;section -> MVr += frame -> MVr ;,section -> pcnt_inter += frame -> pcnt_inter ;section -> pcnt_neutral += frame -> pcnt_neutral ;section -> intra_skip_pct += frame -> intra_skip_pct ;section -> inactive_zone_rows += frame -> inactive_zone_rows ;section -> inactive_zone_cols += frame -> inactive_zone_cols ;section -> MVr += frame -> MVr ;,271
384,struct loop_device * lo = disk -> private_data ;int err ;if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ;mutex_lock ( & lo -> lo_ctl_mutex ) ;if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) {err = loop_clr_fd ( lo ) ;if ( ! err ) return ;else if ( lo -> lo_state == Lo_bound ) {blk_mq_freeze_queue ( lo -> lo_queue ) ;blk_mq_unfreeze_queue ( lo -> lo_queue ) ;}mutex_unlock ( & lo -> lo_ctl_mutex ) ;},mutex_lock ( & loop_index_mutex ) ;__lo_release ( disk -> private_data ) ;mutex_unlock ( & lo -> lo_ctl_mutex ) ;,272
385,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) {ret = - ENOENT ;goto out ;}",273
386,"if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;",273
387,error = 0 ;if ( pkt == NULL ) continue ;,error = 0 ;,274
388,countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,275
389,"unsigned char * buf ;assert ( m -> buf_ ) ;if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {return - 1 ;","unsigned char * buf ;assert ( m -> buf_ ) ;if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {return - 1 ;",276
390,case SO_SNDBUF :  if ( val > sysctl_wmem_max )  val = sysctl_wmem_max ;if ( ( val * 2 ) < SOCK_MIN_SNDBUF )  sk -> sk_sndbuf = SOCK_MIN_SNDBUF ;else sk -> sk_sndbuf = val * 2 ;,"case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ;sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;",277
391,case SO_RCVBUF :  if ( val > sysctl_rmem_max )  val = sysctl_rmem_max ;if ( ( val * 2 ) < SOCK_MIN_RCVBUF )  sk -> sk_rcvbuf = SOCK_MIN_RCVBUF ;else sk -> sk_rcvbuf = val * 2 ;,"case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ;sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;",277
392,x < ( ssize_t ) image -> columns ;,"x < ( ssize_t ) ConstrainColormapIndex ( image , image -> columns ;",278
393,"SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;","SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , exception ) , q ) ;",278
394,"SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t )  GetPixelIndex ( image , q ) , q ) ;q += GetPixelChannels ( image ) ;","SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) GetPixelIndex ( image , q ) , q ) ;q += GetPixelChannels ( image ) ;",278
395,"# endif  while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) {switch ( ch ) {case \'k\' :  k_flag ++ ;break ;","# endif while ( ( ch = getopt ( ac , av , ""cDdksE:a:P:t:"" ) ) != - 1 ) {switch ( ch ) {case \'k\' : k_flag ++ ;break ;case \'P\' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ;pkcs11_whitelist = xstrdup ( optarg ) ;break ;",279
396,"if ( ac == 0 && ! c_flag && ! s_flag ) {shell = getenv ( ""SHELL"" ) ;","if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ;if ( ac == 0 && ! c_flag && ! s_flag ) {shell = getenv ( ""SHELL"" ) ;",279
397,"if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 )  fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ;","if ( pledge ( ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ;",279
398,int i ;int j ;,jas_matind_t i ;jas_matind_t j ;,280
399,"if ( sport == 1719 || dport == 1719 )  {if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 )   {NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\\","if ( sport == 1719 || dport == 1719 ) {if ( ( packet -> payload_packet_len >= 5 ) && ( packet -> payload [ 0 ] == 0x16 ) && ( packet -> payload [ 1 ] == 0x80 ) && ( packet -> payload [ 4 ] == 0x06 ) && ( packet -> payload [ 5 ] == 0x00 ) ) {NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\\",281
400,mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,282
401,"# else  path = g_get_tmp_dir ( ) ;# endif filename = g_build_filename ( path , "".ettercap_gtk"" , NULL ) ;","# else path = g_get_home_dir ( ) ;# endif filename = g_build_filename ( path , "".ettercap_gtk"" , NULL ) ;",283
402,"switch ( fmt ) {case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : xcs = 1 ;break ;default : xcs = 0 ;break ;}switch ( fmt ) {case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 : ycs = 1 ;break ;default : ycs = 0 ;break ;}align = ( 1 << xcs ) - 1 ;w = ( d_w + align ) & ~ align ;align = ( 1 << ycs ) - 1 ;h = ( d_h + align ) & ~ align ;if ( ! img ) {img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;if ( ! img ) goto fail ;img -> self_allocd = 1 ;}else {memset ( img , 0 , sizeof ( vpx_image_t ) ) ;}img -> img_data = img_data ;if ( ! img_data ) {const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ;",w = d_w ;h = d_h ;alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ;,284
403,"INIT_LIST_HEAD ( & f -> f_u . fu_list ) ;atomic_long_set ( & f -> f_count , 1 ) ;","atomic_long_set ( & f -> f_count , 1 ) ;",285
404,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,286
405,if ( count < sizeof hdr )  return - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( count < sizeof hdr ) return - EINVAL ;,287
406,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;offset += 4 + len ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;offset += 4 + len ;if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,288
407,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,288
408,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( client_hash ) {,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( client_hash ) {,288
409,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,288
410,"
",if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;,288
411,else  offset += 4 + len ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,else offset += 4 + len ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,288
412,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},289
413,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},289
414,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,290
415,"list_add_tail ( & info -> list , & xen_irq_list_head ) ;}","INIT_LIST_HEAD ( & info -> eoi_list ) ;list_add_tail ( & info -> list , & xen_irq_list_head ) ;}",291
416,"const VP9_COMMON * const cm = & cpi -> common ;const VP9_CONFIG * oxcf = & cpi -> oxcf ;rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ;}rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ;rc -> buffer_level = rc -> bits_off_target ;if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ;","const VP9_COMMON * const cm = & cpi -> common ;rc -> bits_off_target += rc -> avg_frame_bandwidth - encoded_frame_size ;}rc -> bits_off_target = MIN ( rc -> bits_off_target , rc -> maximum_buffer_size ) ;rc -> buffer_level = rc -> bits_off_target ;if ( is_one_pass_cbr_svc ( cpi ) ) {update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ;",292
417,sun_info . height = ReadBlobMSBLong ( image ) ;sun_info . depth = ReadBlobMSBLong ( image ) ;sun_info . length = ReadBlobMSBLong ( image ) ;sun_info . type = ReadBlobMSBLong ( image ) ;sun_info . maptype = ReadBlobMSBLong ( image ) ;sun_info . maplength = ReadBlobMSBLong ( image ) ;extent = sun_info . height * sun_info . width ;,bytes_per_line = sun_info . width * sun_info . depth ;sun_info . height ;,293
418,"sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length ,   sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;","sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;",293
419,return 0 ;},skip_metadata ( ps ) ;return 0 ;},294
420,"if ( strchr ( argv [ 1 ] , \'<S2SV_blank>\' ) ) {","# if 0 if ( strchr ( argv [ 1 ] , \'<S2SV_blank>\' ) ) {",295
421,logmode = LOGMODE_JOURNAL ;,# endif logmode = LOGMODE_JOURNAL ;,295
422,"{char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ;","{char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ;",295
423,}dd_close ( dd ) ;,}dd_close ( dd ) ;,295
424,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,296
425,"error = copy_to_user ( buf , & socket_packet -> icmp_packet ,   socket_packet -> icmp_len ) ;packet_len = socket_packet -> icmp_len ;","packet_len = min ( count , socket_packet -> icmp_len ) ;error = copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) ;",297
426,return 0 ;},if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;return 0 ;},298
427,"uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ;unsigned char * channel_identities = NULL ;","uint32_t chan_chunk = 0 , desc_chunk = 0 , channel_layout = 0 , bcount ;unsigned char * channel_identities = NULL ;",299
428,"WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;if ( debug_logging_mode ) {","WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;desc_chunk = 1 ;if ( debug_logging_mode ) {",299
429,else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;,else if ( ! desc_chunk || ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;,299
430,"if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) ||  bcount != sizeof ( mEditCount ) ) {","if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {",299
431,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;set_acl_inode ( inode , inode -> i_mode ) ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;",300
432,"
","{uint8_t computedHvi [ 32 ] ;uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ;uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ;uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ;memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ;memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ;zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ;free ( DHPartHelloMessageString ) ;if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) {free ( messageData ) ;return BZRTP_PARSER_ERROR_UNMATCHINGHVI ;}}",301
433,}uint8_t checkH2 [ 32 ] ;,}uint8_t checkH2 [ 32 ] ;,301
434,"}err = hidp_connection_add ( & ca , csock , isock ) ;","}ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;err = hidp_connection_add ( & ca , csock , isock ) ;",302
435,if ( keyring ) {,if ( keyring && link_ret == 0 ) {,303
436,"if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ;","if ( keyring ) __key_link_end ( keyring , & key -> index_key , edit ) ;",303
437,"size_t ld ;const char * data = luaL_checklstring ( L , 2 , & ld ) ;size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;int n = 0 ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;","luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ;pos -- ;int n = 0 ;size_t size = optsize ( L , size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;",304
438,"up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE ,  & control -> id ) ;return 0 ;","struct snd_ctl_elem_id id = control -> id ;up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & id ) ;return 0 ;",305
439,evtchn = info -> evtchn ;if ( ! VALID_EVTCHN ( evtchn ) )  return ;,"unsigned int cpu ;evtchn = info -> evtchn ;if ( ! VALID_EVTCHN ( evtchn ) || ! list_empty ( & info -> eoi_list ) ) return ;cpu = info -> eoi_cpu ;if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) {lateeoi_list_add ( info ) ;return ;}info -> eoi_time = 0 ;",306
440,"static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , va_list args ) {",307
441,# else  return VPX_CODEC_INCAPABLE ;# endif },# else ( void ) ctx ;( void ) args ;return VPX_CODEC_INCAPABLE ;# endif },307
442,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {",308
443,"struct file * file = vma -> vm_file ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {","struct file * file = vma -> vm_file ) ;down_read ( & EXT4_I ( inode ) -> i_mmap_sem ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {",309
444,out :  sb_end_pagefault ( inode -> i_sb ) ;return ret ;,out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;sb_end_pagefault ( inode -> i_sb ) ;return ret ;,309
445,"uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }","uint8_t * const buffers [ 3 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }",310
446,"char * buf , * payload ;uint32_t * payload32 ;int ret = - 1 , result = - 1 ;int total = 0 ;ws_mask_t mask ;","int result = - 1 , result = - 1 ;int total = 0 ;ws_mask_t mask ;",311
447,"}else if ( 0 == ret ) {result = 0 ;else {errno = EAGAIN ;}goto spor ;}opcode = header -> b0 & 0x0f ;flength = header -> b1 & 0x7f ;if ( ! ( header -> b1 & 0x80 ) ) {rfbErr ( ""%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\\errno = EIO ;goto spor ;}if ( flength < 126 ) {fhlen = 2 ;mask = header -> u . m ;}else if ( flength == 126 && 4 <= ret ) {flength = WS_NTOH16 ( header -> u . s16 . l16 ) ;fhlen = 4 ;mask = header -> u . s16 . m16 ;}else if ( flength == 127 && 10 <= ret ) {flength = WS_NTOH64 ( header -> u . s64 . l64 ) ;fhlen = 10 ;mask = header -> u . s64 . m64 ;}else {rfbErr ( ""%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\\errno = EIO ;goto spor ;}total = fhlen + flength + 4 ;payload = buf + fhlen + 4 ;if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) {int olderrno = errno ;rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%m"" , __func__ ) ;errno = olderrno ;return ret ;}else if ( ret < total ) {rfbLog ( ""%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\\}else {buf [ ret ] = \'\\\\0\' ;}payload32 = ( uint32_t * ) payload ;for ( i = 0 ;i < flength / 4 ;i ++ ) {payload32 [ i ] ^= mask . u ;}for ( i *= 4 ;i < flength ;i ++ ) {payload [ i ] ^= mask . c [ i % 4 ] ;}switch ( opcode ) {case WS_OPCODE_CLOSE : rfbLog ( ""got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\\errno = ECONNRESET ;break ;case WS_OPCODE_TEXT_FRAME : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codeBufDecode , sizeof ( wsctx -> codeBufDecode ) ) ) ) {rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\\break ;}payload = wsctx -> codeBufDecode ;case WS_OPCODE_BINARY_FRAME : if ( flength > len ) {memcpy ( wsctx -> readbuf , payload + len , flength - len ) ;wsctx -> readbufstart = 0 ;wsctx -> readbuflen = flength - len ;flength = len ;}memcpy ( dst , payload , flength ) ;result = flength ;break ;default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\\spor : return result ;","else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) {hybiDecodeCleanup ( wsctx ) ;rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\\return result ;",311
448,double motion_pct = next_frame -> pcnt_motion ;prediction_decay_rate = next_frame -> pcnt_inter ;,double motion_pct = next_frame -> pcnt_motion ;( void ) cpi ;prediction_decay_rate = next_frame -> pcnt_inter ;,312
449,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;ext4_mark_inode_dirty ( handle , inode ) ;if ( error == 0 )  acl = NULL ;}","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",313
450,"if ( level != SOL_IP ) return - EOPNOTSUPP ;if ( ip_mroute_opt ( optname ) ) return ip_mroute_getsockopt ( sk , optname , optval , optlen ) ;","if ( inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . optlen ) ;",314
451,"opt -> optlen = 0 ;if ( inet -> opt )  memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ;","struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;opt -> optlen = 0 ;if ( inet -> opt ) memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ;",314
452,"UINT32 PathLength ;Stream_Seek ( irp -> input , 28 ) ;Stream_Read_UINT32 ( irp -> input , PathLength ) ;status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 ,  & path , 0 , NULL , NULL ) ;","WCHAR * ptr ;UINT32 PathLength ;if ( ! Stream_SafeSeek ( irp -> input , 28 ) ) return ERROR_INVALID_DATA ;if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA ;Stream_Read_UINT32 ( irp -> input , PathLength ) ;ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ;status = ConvertFromUnicode ( CP_UTF8 , 0 , ptr , PathLength / 2 , & path , 0 , NULL , NULL ) ;",315
453,"ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;",316
454,void * buffer ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,void * buffer ;if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,317
455,"if ( p7 -> d . ptr == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ;return NULL ;}i = OBJ_obj2nid ( p7 -> type ) ;p7 -> state = PKCS7_S_HEADER ;switch ( i ) {case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ;if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ;goto err ;}md_sk = p7 -> d . sign -> md_algs ;break ;case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ;md_sk = p7 -> d . signed_and_enveloped -> md_algs ;data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ;enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ;enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ;data_body = p7 -> d . enveloped -> enc_data -> enc_data ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ;goto err ;}if ( md_sk != NULL ) {for ( i = 0 ;i < sk_X509_ALGOR_num ( md_sk ) ;i ++ ) {xa = sk_X509_ALGOR_value ( md_sk , i ) ;if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}j = OBJ_obj2nid ( xa -> algorithm ) ;evp_md = EVP_get_digestbynid ( j ) ;if ( evp_md == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ;goto err ;}BIO_set_md ( btmp , evp_md ) ;if ( out == NULL ) out = btmp ;else BIO_push ( out , btmp ) ;btmp = NULL ;}}if ( evp_cipher != NULL ) {if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}if ( pcert ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ;ri = NULL ;}if ( ri == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ;goto err ;}}if ( pcert == NULL ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}}else {if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}evp_ctx = NULL ;BIO_get_cipher_ctx ( etmp , & evp_ctx ) ;if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ;if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ;tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ;tkey = OPENSSL_malloc ( tkeylen ) ;if ( ! tkey ) goto err ;if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ;if ( ek == NULL ) {ek = tkey ;eklen = tkeylen ;tkey = NULL ;}if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) {if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) {OPENSSL_clear_free ( ek , eklen ) ;ek = tkey ;eklen = tkeylen ;tkey = NULL ;}}ERR_clear_error ( ) ;if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ;OPENSSL_clear_free ( ek , eklen ) ;ek = NULL ;OPENSSL_clear_free ( tkey , tkeylen ) ;tkey = NULL ;if ( out == NULL ) out = etmp ;else BIO_push ( out , etmp ) ;etmp = NULL ;}if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) {bio = in_bio ;",if ( in_bio != NULL ) ) {bio = in_bio ;,318
456,if ( ret ) goto out ;touch_atime ( & path ) ;path_put ( & path ) ;,if ( ! IS_ERR ( raw ) ) if ( ret ) goto out ;touch_atime ( & path ) ;path_put ( & path ) ;,319
457,proc = rqstp -> rq_procinfo ;rqstp -> rq_cachetype = proc -> pc_cachetype ;,"proc = rqstp -> rq_procinfo ;if ( nfs_request_too_big ( rqstp , proc ) ) {dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\\* statp = rpc_garbage_args ;return 1 ;}rqstp -> rq_cachetype = proc -> pc_cachetype ;",320
458,"if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 )   goto end ;if ( MyFlags & MY_REDEL_MAKE_BACKUP ) {","if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) {if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) goto end ;}if ( MyFlags & MY_REDEL_MAKE_BACKUP ) {",321
459,e . ifindex = port -> dev -> ifindex ;e . state = p -> state ;,"memset ( & e , 0 , sizeof ( e ) ) ;e . ifindex = port -> dev -> ifindex ;e . state = p -> state ;",322
460,"u_int len , j ;if ( ( offset + 4 + str_len ) >= packet -> payload_packet_len ) return ( - 1 ) ;","u_int len , j ;if ( * rdnSeqBuf_offset >= rdnSeqBuf_len ) {# ifdef DEBUG_TLS printf ( ""[TLS]<S2SV_blank>%s()<S2SV_blank>[buffer<S2SV_blank>capacity<S2SV_blank>reached][%u]\\\# endif return - 1 ;}if ( ( offset + 4 + str_len ) >= packet -> payload_packet_len ) return ( - 1 ) ;",323
461,sec = t % 86400 ;wday = ( 4 + days ) % 7 ;,sec = t % 86400 ;if ( days > 2932896 ) {days = 2932896 ;sec = 86399 ;}wday = ( 4 + days ) % 7 ;,324
462,"struct rose_sock * rose = rose_sk ( sk ) ;struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ;if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ;if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ;qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ;skb_pull ( skb , ROSE_MIN_LEN ) ;if ( rose -> qbitincl ) {asmptr = skb_push ( skb , 1 ) ;* asmptr = qbit ;}skb_reset_transport_header ( skb ) ;copied = skb -> len ;if ( copied > size ) {copied = size ;msg -> msg_flags |= MSG_TRUNC ;}skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ;if ( srose != NULL ) {memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;","struct rose_sock * rose = rose_sk ( sk ) ;if ( msg -> msg_name ) {struct sockaddr_rose * srose ;memset ( msg -> msg_name , 0 , msg -> msg_iov , copied ) ;if ( srose != NULL ) {memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;",325
463,"if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" ,  ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , o , s ) ;","if ( o >= ds ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , o , s ) ;",326
464,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,327
465,"map = __bpf_map_get ( f ) ;if ( IS_ERR ( map ) ) {verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\\fdput ( f ) ;return PTR_ERR ( map ) ;",return PTR_ERR ( map ) ;,328
466,"case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , len ) ) ;","case IPSECDOI_ID_IPV4_ADDR : if ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , len ) ) ;",329
467,"if ( len < 20 )  ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;","if ( len < 20 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;",329
468,case OBJECT_TYPE_INTEGER :  ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ;break ;case OBJECT_TYPE_STRING :  ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;break ;,case OBJECT_TYPE_INTEGER : ( ( YR_OBJECT_INTEGER * ) copy ) -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value ;break ;case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) object ) -> value != NULL ) {( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ;}else {( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;}break ;case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value ;break ;,330
469,"if ( ( e -> target_offset == sizeof ( struct ipt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> ip ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",331
470,if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt )   return - EINVAL ;if ( ! rt ) return 0 ;,struct xfrm_replay_state_esn * rs ;if ( p -> flags & XFRM_STATE_ESN ) {if ( ! rt ) return - EINVAL ;rs = nla_data ( rt ) ;if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ;if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ;}if ( ! rt ) return 0 ;,332
471,"int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;","unlink ( path ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_EXCL , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;",333
472,"static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client ,  krb5_principal client_principal ,  hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {","static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , krb5_principal client_principal , const char * tgt_realm , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {",334
473,"# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) ,  krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ;if ( ret ) goto out ;","# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , tgt_realm ) ;if ( ret ) goto out ;",334
474,"static void evtchn_fifo_handle_events ( unsigned cpu )  {__evtchn_fifo_handle_events ( cpu , false ) ;}","static void evtchn_fifo_handle_events ( unsigned cpu , struct evtchn_loop_ctrl * ctrl ) {__evtchn_fifo_handle_events ( cpu , ctrl ) ;}",335
475,"map = __bpf_map_get ( f ) ;if ( IS_ERR ( map ) ) {verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\\fdput ( f ) ;return PTR_ERR ( map ) ;",return PTR_ERR ( map ) ;,336
476,"
",queueItem -> interface = interface ;,337
477,queueItem -> srcPort = 0 ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,queueItem -> srcPort = 0 ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,337
478,"static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;int ctx ;BLOCK_SIZE subsize ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;subsize = * get_sb_partitioning ( x , bsize ) ;}partition = partition_lookup [ bsl ] [ subsize ] ;switch ( partition ) {case PARTITION_NONE :  if ( output_enabled && bsize >= BLOCK_8X8 )  cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ;encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;break ;case PARTITION_VERT :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ;}case PARTITION_HORZ :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ;encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ;}case PARTITION_SPLIT :  subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 1 ;encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 2 ;encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 3 ;encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ;break ;default :  assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}","static void encode_sb ( VP9_COMP * cpi , ThreadData * td , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;int ctx ;BLOCK_SIZE subsize = bsize ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;subsize = get_subsize ( bsize , pc_tree -> partitioning ) ;}partition = partition_lookup [ bsl ] [ subsize ] ;if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ;switch ( partition ) {case PARTITION_NONE : encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;case PARTITION_VERT : if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;default : assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}",338
479,spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,339
480,"list_add_tail ( & sp -> auto_asconf_list ,  & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;}else   sp -> do_auto_asconf = 0 ;local_bh_enable ( ) ;","spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;list_add_tail ( & sp -> auto_asconf_list , & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;}else {sp -> do_auto_asconf = 0 ;}local_bh_enable ( ) ;",340
481,file_sb_list_del ( file ) ;file_free ( file ) ;,file_free ( file ) ;,341
482,}return item ;,if ( ! item -> valuestring ) {cJSON_Delete ( item ) ;return 0 ;}}return item ;,342
483,if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) +  sizeof ( uint16_t ) ) ) {status = - EINVAL ;,if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t ) ) {status = - EINVAL ;,343
484,"if ( new -> process_keyring )  return - EEXIST ;keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","if ( new -> process_keyring ) return 0 ;keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",344
485,"strncpy ( result , ""undefined"" , 10 ) ;}","strcpy ( result , ""undefined"" , 10 ) ;}",345
486,FreeStmt ( ( ParseCommon * ) & append ) ;return expr ;,FreeStmt ( ( ParseCommon * ) append ) ;return expr ;,346
487,"ret = - EEXIST ;if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ;if ( vm_shared ) {page_dup_rmap ( page , true ) ;}else {ClearPagePrivate ( page ) ;hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ;}_dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ;if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ;_dst_pte = pte_mkyoung ( _dst_pte ) ;set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ;( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ;hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ;update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ;spin_unlock ( ptl ) ;ret = 0 ;out : return ret ;out_release_unlock : spin_unlock ( ptl ) ;out_release_nounlock :  if ( vm_shared ) unlock_page ( page ) ;put_page ( page ) ;",out_release_nounlock : put_page ( page ) ;,347
488,frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,348
489,"struct range * range ;struct evbuffer * evb = NULL ;size_t content_length ;int code = 500 , fd = - 1 , i , nranges , ret ;uint32_t boundary ;if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) {code = 416 ;if ( ( evb = evbuffer_new ( ) ) == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ;goto abort ;}( void ) snprintf ( content_range , sizeof ( content_range ) ,  ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;content_length = range -> end - range -> start + 1 ;if ( buffer_add_range ( fd , evb , range ) == 0 )  goto abort ;content_length = 0 ;boundary = arc4random ( ) ;-%ud\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\\\r\\\range ++ ;}if ( ( i = evbuffer_add_printf ( evb , ""\\\\r\\\-%ud--\\\\r\\\content_length += i ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) ,  ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ;media = & multipart_media ;-%llu--\\\\r\\\close ( fd ) ;fd = - 1 ;case 0 :  goto done ;default : break ;if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 )  goto fail ;bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ;if ( clt -> clt_persist )  clt -> clt_toread = TOREAD_HTTP_HEADER ;else clt -> clt_toread = TOREAD_HTTP_NONE ;clt -> clt_done = 0 ;done : evbuffer_free ( evb ) ;server_reset_http ( clt ) ;abort :  if ( evb != NULL )  evbuffer_free ( evb ) ;","struct range_data * r = & clt -> clt_ranges ;struct range * range ;size_t content_length = 0 ;int code = 500 , fd = - 1 , i , nranges , ret ;if ( ( nranges = parse_ranges ( clt , range_str , st -> st_size ) ) < 1 ) {code = 416 ;r -> range_media = media ;range = & r -> range [ 0 ] ;( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;range = & r -> range [ 0 ] ;content_length += range -> end - range -> start + 1 ;content_length = 0 ;boundary = arc4random ( ) ;content_length += ret + range -> end , st -> st_size ) ) == - 1 ) goto abort ;range ++ ;}if ( ( ret = snprintf ( NULL , 0 , ""\\\\r\\\content_length += ret ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary ) ;media = & multipart_media ;r -> range_toread = TOREAD_HTTP_RANGE ;case 0 : close ( fd ) ;goto done ;default : break ;}clt -> clt_fd = fd ;if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ;clt -> clt_srvbev_throttled = 0 ;clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ;if ( clt -> clt_srvbev == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ;goto fail ;bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ;bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ;bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ;bufferevent_disable ( clt -> clt_bev , EV_READ ) ;done : server_reset_http ( clt ) ;abort : if ( evb != NULL ) evbuffer_free ( evb ) ;",349
490,io -> io_cleanup = port_cleanup ;switch ( io -> regsize ) {,switch ( io -> regsize ) {,350
491,return 0 ;},io -> io_cleanup = port_cleanup ;return 0 ;},350
492,\\\\\\,\\\\\\,351
493,"if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ;","int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ;if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , session_state , op_iframe_id , poll_interval , redirect_uri , redirect_uri ) ;",351
494,# endif  exit ( i ) ;},"# endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) {fprintf ( stderr , ""Can\\\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\\exit ( 1 ) ;}# endif exit ( i ) ;}",352
495,"remaining = tvb_captured_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {","remaining = tvb_reported_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {",353
496,new_timer -> it_overrun = - 1 ;if ( event ) {,new_timer -> it_overrun = - 1LL ;if ( event ) {,354
497,for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,355
498,struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret )  return ret ;},struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {ret = - EINVAL ;goto out ;}if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) {ret = - EBUSY ;goto out ;}if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret ) goto out ;},356
499,return count ;},ret = count ;out : o2nm_unlock_subsystem ( ) ;return ret ;},356
500,if ( ! vcpu -> arch . time_page )  return - EINVAL ;,if ( ! vcpu -> arch . pv_time_enabled ) return - EINVAL ;,357
501,"while ( nr > 0 ) {c = tty -> ops -> write ( tty , b , nr ) ;if ( c < 0 ) {","struct n_tty_data * ldata = tty -> disc_data ;while ( nr > 0 ) {mutex_lock ( & ldata -> output_lock ) ;c = tty -> ops -> write ( tty , b , nr ) ;mutex_unlock ( & ldata -> output_lock ) ;if ( c < 0 ) {",358
502,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",359
503,if ( ! new )  return - ENOMEM ;BUG_ON ( new -> thread_keyring ) ;,if ( ! new ) return - ENOMEM ;,360
504,subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ;subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ;,ND_TCHECK_16BITS ( obj_tptr + offset ) ;subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ;subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ;,361
505,"case INT_SWITCHING_TYPE_SUBOBJ :  ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\case WAVELENGTH_SUBOBJ :  ND_PRINT ( ( ndo , ""\\\","case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK_8BITS ( obj_tptr + offset + 3 , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ;ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\",361
506,"static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi ,  int mi_row , int mi_col ) {unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb ,  mi_row , mi_col , BLOCK_64X64 ) ;","static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , MACROBLOCK * x , int mi_row , int mi_col ) {unsigned int var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , BLOCK_64X64 ) ;",362
507,"nfca_poll -> nfcid1_len = * data ++ ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\","nfca_poll -> nfcid1_len = min_t ( __u8 , * data ++ , NFC_NFCID1_MAXSIZE ) ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\",363
508,"static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;const int mb_row = mi_row >> 1 ;const int mb_col = mi_col >> 1 ;const int idx_map = mb_row * cm -> mb_cols + mb_col ;x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ;x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ;x -> rddiv = cpi -> RDDIV ;x -> rdmult = cpi -> RDMULT ;if ( seg -> enabled ) {mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}","static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCK * const x , int mi_row , int mi_col , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ;x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;vp9_setup_dst_planes ( xd -> plane , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ;x -> rddiv = cpi -> rd . RDDIV ;x -> rdmult = cpi -> rd . RDMULT ;if ( seg -> enabled ) {mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}",364
509,},xd -> tile = * tile ;},364
510,"
","if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) {SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ;}",365
511,"if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;","if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;",365
512,ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ;},if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) {return IHEVCD_INVALID_PARAMETER ;}ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ;},366
513,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {smp_rmb ( ) ;return key -> reject_error ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) return ret ;,367
514,"u64 t = ca -> sum_rtt ;do_div ( t , ca -> cnt_rtt ) ;info . tcpv_rtt = t ;nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ;","if ( info . tcpv_rttcnt > 0 ) {u64 t = ca -> sum_rtt ;do_div ( t , info . tcpv_rttcnt ) ;info . tcpv_rtt = t ;}nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ;",368
515,"for ( i = 0 ;i <= SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;","for ( i = 0 ;i < SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;",369
516,if ( err > 0 ) {signo = SIGCHLD ;err = 0 ;}if ( ! err ) {,"
",370
517,"static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) {const VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) {assert ( ! is_compound ) ;assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME ,  vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ;vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ;if ( bit0 ) {vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ;}","static void write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) {if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;}else {assert ( ! is_compound == ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ;vpx_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ;if ( bit0 ) {vpx_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ;}",371
518,"strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ;","strncpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ;",372
519,void * H264SwDecMalloc ( u32 size ) {return malloc ( size ) ;},"void * H264SwDecMalloc ( u32 size , u32 num ) {if ( size > UINT32_MAX / num ) {ALOGE ( ""can\\\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ;android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ;return NULL ;}return malloc ( size * num ) ;}",373
520,"
",h . h2 -> tp_padding = 0 ;,374
521,hdrlen = sizeof ( * h . h2 ) ;break ;,hdrlen = sizeof ( * h . h2 ) ;break ;,374
522,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,375
523,"strcpy ( m , name ) ;for ( p = path ;","memcpy ( m , name , nlen + 1 ) ;for ( p = path ;",376
524,"nmv_context * fc = & cm -> fc . nmvc ;const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ;adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ;for ( i = 0 ;comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ;adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes ,  comp -> classes ) ;adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ;for ( j = 0 ;++ j )  comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ;for ( j = 0 ;++ j )  adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] ,  comp -> class0_fp [ j ] ) ;adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ;if ( allow_hp ) {comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ;comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ;}","nmv_context * fc = & cm -> fc -> nmvc ;const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ;vpx_tree_merge_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ;for ( i = 0 ;comp -> sign = mode_mv_merge_probs ( pre_comp -> sign , c -> sign ) ;vpx_tree_merge_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , comp -> classes ) ;vpx_tree_merge_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ;for ( j = 0 ;+ j )  comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ;++ j ) comp -> bits [ j ] = mode_mv_merge_probs ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ;for ( j = 0 ;+ j )  adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] ,  comp -> class0_fp [ j ] ) ;++ j ) vpx_tree_merge_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , comp -> class0_fp [ j ] ) ;vpx_tree_merge_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ;if ( allow_hp ) {comp -> class0_hp = mode_mv_merge_probs ( pre_comp -> class0_hp , c -> class0_hp ) ;comp -> hp = mode_mv_merge_probs ( pre_comp -> hp , c -> hp ) ;}",377
525,"if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\","if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ;if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ;if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\",378
526,"}if ( lastPart ) {warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\\\""boundary\\\\""<S2SV_blank>for<S2SV_blank>\\\\""multipart/form-data\\\\""!"" ) ;}","else {warn ( ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ;break ;}}if ( lastPart ) {warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\\\""boundary\\\\""<S2SV_blank>for<S2SV_blank>\\\\""multipart/form-data\\\\""!"" ) ;",379
527,"interface = socket -> interface ;buffer = ipAllocBuffer ( 0 , & offset ) ;","if ( message -> interface != NULL ) {interface = message -> interface ;}else {interface = socket -> interface ;}buffer = ipAllocBuffer ( 0 , & offset ) ;",380
528,"variance_node node ;tree_to_node ( data , bsize , & node ) ;","variance_node node ;memset ( & node , 0 , sizeof ( node ) ) ;tree_to_node ( data , bsize , & node ) ;",381
529,"int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct ,  const vp9_prob * oldp ,  vp9_prob * bestp ,  vp9_prob upd ) {int i , old_b , new_b , update_b , savings , bestsavings , step ;vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ;vp9_model_to_full_probs ( oldp , oldplist ) ;vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ;for ( i = UNCONSTRAINED_NODES , old_b = 0 ;step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ;for ( newp = * bestp ;","int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , const vpx_prob * oldp , vpx_prob * bestp , vp9_prob upd ) {int i , old_b , new_b , update_b , savings , bestsavings , step ;vpx_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ;vp9_model_to_full_probs ( oldp , oldplist ) ;memcpy ( newplist , oldp , sizeof ( vpx_prob ) * UNCONSTRAINED_NODES ) ;for ( i = UNCONSTRAINED_NODES , old_b = 0 ;if ( * bestp > oldp [ PIVOT_NODE ] ) {step = - stepsize ;for ( newp = * bestp ;newp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ;for ( newp = * bestp ;",382
530,* bestp = bestnewp ;return bestsavings ;,"}else {step = stepsize ;for ( newp = * bestp ;newp < oldp [ PIVOT_NODE ] ;newp += step ) {if ( newp < 1 || newp > 255 ) continue ;newplist [ PIVOT_NODE ] = newp ;vp9_model_to_full_probs ( newplist , newplist ) ;for ( i = UNCONSTRAINED_NODES , new_b = 0 ;i < ENTROPY_NODES ;++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ;new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ;update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ;savings = old_b - new_b - update_b ;if ( savings > bestsavings ) {bestsavings = savings ;bestnewp = newp ;}}}* bestp = bestnewp ;return bestsavings ;",382
531,"static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn ,   struct se_device * * found_dev )  {struct xcopy_dev_search_info info ;int ret ;memset ( & info , 0 , sizeof ( info ) ) ;info . dev_wwn = dev_wwn ;ret = target_for_each_device ( target_xcopy_locate_se_dev_e4_iter , & info ) ;if ( ret == 1 ) {* found_dev = info . found_dev ;}else {pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\\}","static int target_xcopy_locate_se_dev_e4 ( struct se_session * sess , const unsigned char * dev_wwn , struct se_device * * _found_dev , struct percpu_ref * * _found_lun_ref ) {struct se_dev_entry * deve ;struct se_node_acl * nacl ;struct se_lun * this_lun = NULL ;struct se_device * found_dev = NULL ;if ( ! sess ) goto err_out ;pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\\nacl = sess -> se_node_acl ;rcu_read_lock ( ) ;hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) {struct se_device * this_dev ;int rc ;this_lun = rcu_dereference ( deve -> se_lun ) ;this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ;rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ;if ( rc ) {if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ;break ;}}rcu_read_unlock ( ) ;if ( found_dev == NULL ) goto err_out ;pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\\* _found_dev = found_dev ;* _found_lun_ref = & this_lun -> lun_ref ;err_out : pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\\",383
532,if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) )  return - EINVAL ;param . regd = hwsim_world_regdom_custom [ idx ] ;},if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) {kfree ( hwname ) ;return - EINVAL ;}param . regd = hwsim_world_regdom_custom [ idx ] ;},384
533,"reason = malloc ( ( uint64_t ) reasonLen + 1 ) ;if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) {","if ( reasonLen > 1 << 20 ) {rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ;return ;}reason = malloc ( reasonLen + 1 ) ;if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) {",385
534,},"if ( cpu_has_secondary_exec_ctrls ( ) ) {if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;}if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;}",386
535,"switch ( opt ) {case LCPOPT_VEXT : if ( len < 6 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 2 ) , 3 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;","ND_TCHECK_24BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;",387
536,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;",387
537,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",387
538,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( ppp_callback_values , ""Unknown"" , p [ 2 ] ) , p [ 2 ] ) ) ;break ;case LCPOPT_MLMRRU : if ( len != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;",387
539,"char * dbuf ;char * ticket_buf ;int ret ;dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ;ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ;ret = process_one_ticket ( ac , secret , & p , end ,  dbuf , ticket_buf ) ;if ( ret )  goto out ;}ret = 0 ;out : kfree ( ticket_buf ) ;out_dbuf : kfree ( dbuf ) ;return ret ;bad :  ret = - EINVAL ;goto out ;}","int ret ;dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ;ceph_decode_8_safe ( & p , end ) ;ret = process_one_ticket ( ac , secret , & p , end , dbuf , ticket_buf ) ;if ( ret ) return ret ;}return 0 ;bad : ret = - EINVAL ;}",388
540,for ( arc = 0 ;short a_label = dfa_state -> s_arc [ arc ] . a_lbl ;,if ( ch_type == suite && TYPE ( tree ) == funcdef ) {ch_type = func_body_suite ;}for ( arc = 0 ;short a_label = dfa_state -> s_arc [ arc ] . a_lbl ;,389
541,bitlen2 = VARBITLEN ( arg2 ) ;bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ;,"bitlen2 = VARBITLEN ( arg2 ) ;if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ;bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ;",390
542,return alg -> cra_rng . rng_make_random ?  alg -> cra_rng . seedsize : ralg -> seedsize ;,return ralg -> seedsize ;,391
543,"static void  horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 4 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 4 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",392
544,},return 1 ;},392
545,"if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) {* pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ;if ( * pgmap ) page = pte_page ( pte ) ;else goto no_page ;else if ( unlikely ( ! page ) ) {",if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) {if ( unlikely ( ! try_get_page ( page ) ) ) {page = ERR_PTR ( - ENOMEM ) ;goto out ;},393
546,if ( flags & FOLL_GET )  get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,if ( flags & FOLL_GET ) get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,393
547,"if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , false ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",394
548,"if ( credit < 0 )   state = decrease_reservation ( - credit , GFP_BALLOON ) ;state = update_schedule ( state ) ;","if ( credit < 0 ) {long n_pages ;n_pages = min ( - credit , si_mem_available ( ) ) ;state = decrease_reservation ( n_pages , GFP_BALLOON ) ;if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ;}state = update_schedule ( state ) ;",395
549,ps_dec -> u2_disp_height = i4_cropped_ht ;ps_dec -> u2_disp_width = i4_cropped_wd ;,if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) {return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ;}ps_dec -> u2_disp_height = i4_cropped_ht ;ps_dec -> u2_disp_width = i4_cropped_wd ;,396
550,"void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {get_page ( buf -> page ) ;}","bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {return try_get_page ( buf -> page ) ;}",397
551,byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ;if ( byteStrm == NULL ) {,"byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) , strmLen ) ;if ( byteStrm == NULL ) {",398
552,"static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree ,   int16_t extra , uint8_t token ,  uint8_t skip_eob_node , unsigned int * counts ) {","static INLINE void add_token ( TOKENEXTRA * * t , const vpx_prob * context_tree , int16_t extra , uint8_t token , uint8_t skip_eob_node , unsigned int * counts ) {",399
553,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,400
554,struct siginfo info ;info . si_signo = sig ;,struct siginfo info = {};info . si_signo = sig ;,401
555,# ifdef CONFIG_SMP  free_percpu ( s -> s_files ) ;# endif for ( i = 0 ;,for ( i = 0 ;,402
556,"rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ;}","rc = expandRegular ( fi , dest , psm , 1 , nodigest , 1 ) ;}",403
557,"if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;}if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;* firsthardlink = - 1 ;","if ( ! rc ) rc = expandRegular ( fi , dest , psm , 1 , nodigest , 0 ) ;}if ( ! rc ) rc = expandRegular ( fi , dest , psm , 0 , nodigest , 0 ) ;* firsthardlink = - 1 ;",403
558,"const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i ,  p -> src . stride ) ] ;uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> dst . stride ) ] ;const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;for ( ref = 0 ;const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> pre [ ref ] . stride ) ] ;vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride ,  dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv ,  & xd -> block_refs [ ref ] -> sf , width , height , ref ,  kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) ,  mi_row * MI_SIZE + 4 * ( i / 2 ) ) ;}vp9_subtract_block ( height , width ,  raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride ,  dst , pd -> dst . stride ) ;k = i ;","const uint8_t * const src = & p -> src . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;uint8_t * const dst = & pd -> dst . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , pd -> dst . stride ) ] ;const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ) ;for ( ref = 0 ;const uint8_t * pre = & pd -> pre [ ref ] . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , pd -> pre [ ref ] . stride ) ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vp9_highbd_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) , xd -> bd ) ;}else {vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , xd -> bd ) ;}else {vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ;}# else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ;# endif k = i ;",404
559,"int16_t * coeff ;k += ( idy * 2 + idx ) ;x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) ,  coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ;thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;thissse += ssz ;thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;","int16_t * coeff ;k += ( idy * 2 + idx ) ;x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ;}else {thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;}# else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;# endif thissse += ssz ;thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;",404
560,"sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",405
561,"const char * old_name ;trap = lock_rename ( new_dir , old_dir ) ;if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ;dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ;if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ;old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ;fsnotify_oldname_free ( old_name ) ;fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;unlock_rename ( new_dir , old_dir ) ;","struct name_snapshot old_name ;trap = lock_rename ( new_dir , old_dir ) ;take_dentry_name_snapshot ( & old_name , old_dentry ) ;error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ;release_dentry_name_snapshot ( & old_name ) ;fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;unlock_rename ( new_dir , old_dir ) ;",406
562,if ( ! offset ) {return & EG ( uninitialized_zval_ptr ) ;,if ( ! offset || ! ht ) {return & EG ( uninitialized_zval_ptr ) ;,407
563,if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) )  * flags &= ~ FOLL_WRITE ;return 0 ;,if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) * flags |= FOLL_COW ;return 0 ;,408
564,"sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;","snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;",409
565,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;",409
566,"# undef llint  sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;","# undef llint snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;",409
567,"case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{break ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{break ;sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}","case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}",409
568,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",409
569,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}",409
570,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",409
571,"sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ;}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>class+%i"" , vB ) ;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>method+%i"" , vB ) ;}",409
572,"gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ;}return GF_OK ;}","if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\\ptr -> key_info [ 20 ] = 16 ;return GF_NON_COMPLIANT_BITSTREAM ;}gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ;}else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\\return GF_NON_COMPLIANT_BITSTREAM ;}return GF_OK ;}",410
573,if ( ret == - EEXIST )  goto fail_dir_item ;,if ( ret == - EEXIST || ret == - EOVERFLOW ) goto fail_dir_item ;,411
574,if ( i4_prev_row != i4_row )  {,if ( i4_prev_row < i4_row ) {,412
575,"}impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ;","}else if ( i4_prev_row > i4_row ) {android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ;}impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ;",412
576,"struct hstate * h = hstate_vma ( vma ) ;struct page * page ;struct address_space * mapping = vma -> vm_file -> f_mapping ;struct inode * inode = mapping -> host ;if ( chg )  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return ERR_PTR ( - VM_FAULT_SIGBUS ) ;page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ;if ( ! page ) {hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;","struct hugepage_subpool * spool = subpool_vma ( vma ) ;struct hstate * h = hstate_vma ( vma ) ;struct page * page ;if ( chg ) if ( hugepage_subpool_get_pages ( spool , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS ) ;hugepage_subpool_put_pages ( spool , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;",413
577,"if ( svm_set_msr ( & svm -> vcpu , & msr ) ) {trace_kvm_msr_write_ex ( ecx , data ) ;","if ( kvm_set_msr ( & svm -> vcpu , & msr ) ) {trace_kvm_msr_write_ex ( ecx , data ) ;",414
578,uchar * dp ;dp = data ;,jas_uchar * dp ;dp = data ;,415
579,len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) )   len -= cctx -> M ;EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ;len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {if ( len < cctx -> M ) return 0 ;len -= cctx -> M ;}EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,416
580,"if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) )  MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;filepos = TellBlob ( image ) ;","if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) {MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}filepos = TellBlob ( image ) ;",417
581,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",418
582,char * ptr ;int n = 0 ;ptr = fmt ;while ( * ptr != \'\\\\0\' ) if ( * ptr ++ == \'%\' ) {if ( * ptr == \'\\\\0\' ) return 1 ;if ( * ptr == \'%\' ) ptr ++ ;else if ( * ptr == \'s\' || * ptr == \'S\' ) {n = 1 ;ptr ++ ;}else {if ( * ptr == \'<S2SV_blank>\' ) ptr ++ ;while ( * ptr >= \'0\' && * ptr <= \'9\' ) ptr ++ ;if ( * ptr ++ != \'l\' ) return 1 ;if ( * ptr == \'u\' ) ptr ++ ;else return 1 ;n ++ ;}}return ( n != 3 ) ;,"return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt ) ;",419
583,"buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ;if ( buf == NULL ) {","buf = _PyObject_CallNoArg ( tok -> decoding_readline , NULL ) ;if ( buf == NULL ) {",420
584,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;switch ( rd ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;switch ( rd ) {",421
585,struct ip_options * opt = NULL ;struct inet_request_sock * req_inet ;,struct ip_options_rcu * opt = NULL ;struct inet_request_sock * req_inet ;,422
586,"memcpy ( opt -> __data , buf , buf_len ) ;opt -> optlen = opt_len ;opt -> cipso = sizeof ( struct iphdr ) ;kfree ( buf ) ;kfree ( opt ) ;return 0 ;","memcpy ( opt -> opt . __data , buf , buf_len ) ;opt -> opt . optlen = opt_len ;opt -> opt . cipso = sizeof ( struct iphdr ) ;kfree ( buf ) ;if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu ) ;return 0 ;",422
587,"char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ;if ( curl_env && * curl_env ) {char * encoded_url = r_str_escape ( url ) ;char * res = r_sys_cmd_strf ( ""curl<S2SV_blank>\\\'%s\\\'"" , encoded_url ) ;free ( encoded_url ) ;if ( res ) {if ( code ) {* code = 200 ;}if ( rlen ) {* rlen = strlen ( res ) ;}}free ( curl_env ) ;return res ;}free ( curl_env ) ;RSocket * s ;int ssl = r_str_startswith ( url , ""https://"" ) ;char * response , * host , * path , * port = ""80"" ;char * uri = strdup ( url ) ;if ( ! uri ) {return NULL ;}if ( code ) {* code = 0 ;}if ( rlen ) {* rlen = 0 ;}host = strstr ( uri , ""://"" ) ;if ( ! host ) {free ( uri ) ;eprintf ( ""r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI"" ) ;return NULL ;}host += 3 ;port = strchr ( host , \':\' ) ;if ( ! port ) {port = ssl ? ""443"" : ""80"" ;path = host ;}else {* port ++ = 0 ;path = port ;}path = strchr ( path , \'/\' ) ;if ( ! path ) {path = """" ;}else {* path ++ = 0 ;}s = r_socket_new ( ssl ) ;if ( ! s ) {eprintf ( ""r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\\free ( uri ) ;return NULL ;}if ( r_socket_connect_tcp ( s , host , port , 0 ) ) {r_socket_printf ( s , ""GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\\\r\\\response = r_socket_http_answer ( s , code , rlen ) ;}else {eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\\response = NULL ;}free ( uri ) ;r_socket_free ( s ) ;return response ;","return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS ) ;",423
588,"
",if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) {,424
589,flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,}flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,424
590,}if ( end - p >= 88 ) {,}if ( end - p >= 88 ) {,424
591,}p += chunksize ;,"if ( chunksize > end - p ) {av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\\return AVERROR_INVALIDDATA ;}}p += chunksize ;",424
592,"kref_put ( & reservations -> refs , resv_map_release ) ;if ( reserve ) {",resv_map_put ( vma ) ;if ( reserve ) {,425
593,int file_is_raw ( struct VpxInputContext * input ) {uint8_t buf [ 32 ] ;,static int file_is_raw ( struct VpxInputContext * input ) {uint8_t buf [ 32 ] ;,426
594,"if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) ,  buf + 4 , 32 - 4 , & si ) ) {","if ( ! vpx_codec_peek_stream_info ( decoder -> codec_interface ( ) , buf + 4 , 32 - 4 , & si ) ) {",426
595,"vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ;}","memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ;}",427
596,"deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' ,  & key_datums , & key_nulls , & key_count ) ;if ( PG_ARGISNULL ( 1 ) ) {","deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' , & key_datums , & key_nulls , & key_count ) ;if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;if ( PG_ARGISNULL ( 1 ) ) {",428
597,case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR :  return ( ( iova < mem -> iova ) ||   ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ?  - EFAULT : 0 ;,case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : if ( iova < mem -> iova ) || ( ( iova + length ) > ( mem -> iova + mem -> length - length ) return - EFAULT ;return 0 ;,429
598,s -> filesize = - 1 ;s -> location = av_strdup ( uri ) ;,s -> filesize = UINT64_MAX ;s -> location = av_strdup ( uri ) ;,430
599,"static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) {int min_log2_tile_cols , max_log2_tile_cols , ones ;while ( ones -- )  vp9_wb_write_bit ( wb , 1 ) ;if ( cm -> log2_tile_cols < max_log2_tile_cols )  vp9_wb_write_bit ( wb , 0 ) ;vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ;if ( cm -> log2_tile_rows != 0 )  vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ;}","static void write_tile_info ( const VP9_COMMON * const cm , struct vp9_write_bit_buffer * wb ) {int min_log2_tile_cols , max_log2_tile_cols , ones ;while ( ones -- ) vpx_wb_write_bit ( wb , 1 ) ;if ( cm -> log2_tile_cols < max_log2_tile_cols ) vpx_wb_write_bit ( wb , 0 ) ;vpx_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) vpx_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ;}",431
600,"memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ;for ( section = new_service_options . next ;number_of_sections = num ;CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;","memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ;memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ;memset ( & new_global_options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ;for ( section = new_service_options . next ;number_of_sections = num ;CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;",432
601,"int j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;","size_t j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;",433
602,"case 0x84 :  memcpy ( file -> name , d , len ) ;file -> namelen = len ;break ;","case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ;memcpy ( file -> name , d , file -> namelen = len ;break ;",433
603,"dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;","dentry -> d_flags |= DCACHE_RCUACCESS ;dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;",434
604,"LPSTR tmp = NULL ;size_t cs = 0 , x , ds , len ;if ( s )  tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","LPSTR tmp = NULL ;LPSTR tmp2 = NULL ;size_t cs = 0 , x , ds , len ;if ( s ) {tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;}if ( NULL == tmp ) {",435
605,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
606,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
607,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
608,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
609,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp )  {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
610,uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ;if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) {if ( ! anonTLS )  {if ( cred -> x509Credential . x509CACertFile ) {,uint8_t verify_crls ;if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) {if ( ! anonTLS ) {verify_crls = cred -> x509Credential . x509CrlVerifyMode ;if ( cred -> x509Credential . x509CACertFile ) {,436
611,"char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;","char * pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;",437
612,while ( ( u64 ) len > s ) {,while ( ( u64 ) len - s > s ) {,438
613,"_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;","_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;",438
614,if ( err < 0 )   return err ;msg_bytes = sparams -> msg_bytes ;,if ( err < 0 ) {kfree ( partdata ) ;return err ;}msg_bytes = sparams -> msg_bytes ;,439
615,if ( unlikely ( chunk_length < required_length ) )  return 0 ;,if ( unlikely ( chunk -> pdiscard ) ) return 0 ;if ( unlikely ( chunk_length < required_length ) ) return 0 ;,440
616,"show ( obj , base , name , cb_data ) ;strbuf_addstr ( base , name ) ;","strbuf_addstr ( base , name ) ;show ( obj , base -> buf , cb_data ) ;",441
617,"if ( uref -> field_index >= report -> maxfield ) goto inval ;field = report -> field [ uref -> field_index ] ;if ( uref -> usage_index >= field -> maxusage ) goto inval ;uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ;if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ;goto goodreturn ;default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ;if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) {field = hiddev_lookup_usage ( hid , uref ) ;if ( field == NULL ) goto inval ;else {rinfo . report_type = uref -> report_type ;rinfo . report_id = uref -> report_id ;","
",442
618,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) &&  ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,442
619,switch ( bps / 8 )  {,"if ( bytes_per_pixel > sizeof ( swapbuff ) ) {TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ;return ( 1 ) ;}switch ( bps / 8 ) {",443
620,"ND_PRINT ( ( ndo , ""<S2SV_blank>opt:pad0"" ) ) ;","ND_PRINT ( ( ndo , ""%s"" , rpl_tstr ) ) ;",444
621,"}return ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","ND_TCHECK ( opt -> rpl_dio_len ) ;}return ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",444
622,"if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ;if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ;done :  if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;",if ( ctxt -> rip_relative ) ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;done : return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;,445
623,# endif  # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,# endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;# ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,446
624,value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |   ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = value & 0xffff ) ;return ( quantum . signed_value ) ;,447
625,"extent_type = btrfs_file_extent_type ( leaf , fi ) ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ;else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ;item_end -- ;if ( found_type > min_type ) {del_item = 1 ;else {if ( item_end < new_size ) break ;if ( found_key . offset >= new_size ) del_item = 1 ;else del_item = 0 ;}found_extent = 0 ;if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ;if ( del_item ) last_size = found_key . offset ;else last_size = new_size ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {u64 num_dec ;extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ;if ( ! del_item ) {u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ;extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ;btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ;num_dec = ( orig_num_bytes - extent_num_bytes ) ;if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;","extent_type = btrfs_file_extent_type ( leaf , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) {err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;pending_del_nr = 0 ;err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;",448
626,"if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item &&  btrfs_file_extent_compression ( leaf , fi ) == 0 &&  btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) )  inode_sub_bytes ( inode , item_end + 1 -  new_size ) ;btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ;size = btrfs_file_extent_calc_inline_size ( size ) ;btrfs_truncate_item ( root , path , size , 1 ) ;","if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) {inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( btrfs_file_extent_compression ( leaf , fi ) == 0 && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , item_end + 1 - new_size ) ;",448
627,"int err ;unsigned int hash ;struct sk_buff * skb ;long timeo ;struct scm_cookie scm ;int max_level ;int data_len = 0 ;wait_for_unix_gc ( ) ;err = scm_send ( sock , msg , & scm , false ) ;if ( err < 0 ) return err ;err = - EOPNOTSUPP ;if ( msg -> msg_flags & MSG_OOB ) goto out ;if ( msg -> msg_namelen ) {err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ;if ( err < 0 ) goto out ;namelen = err ;}else {sunaddr = NULL ;err = - ENOTCONN ;other = unix_peer_get ( sk ) ;if ( ! other ) goto out ;}if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ;err = - EMSGSIZE ;if ( len > sk -> sk_sndbuf - 32 ) goto out ;if ( len > SKB_MAX_ALLOC ) {data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ;data_len = PAGE_ALIGN ( data_len ) ;BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ;}skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err , PAGE_ALLOC_COSTLY_ORDER ) ;if ( skb == NULL ) goto out ;err = unix_scm_to_skb ( & scm , skb , true ) ;if ( err < 0 ) goto out_free ;max_level = err + 1 ;skb_put ( skb , len - data_len ) ;skb -> data_len = data_len ;skb -> len = len ;err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ;if ( err ) goto out_free ;timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ;restart : if ( ! other ) {err = - ECONNRESET ;if ( sunaddr == NULL ) goto out_free ;other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ;if ( other == NULL ) goto out_free ;}if ( sk_filter ( other , skb ) < 0 ) {err = len ;goto out_free ;}unix_state_lock ( other ) ;err = - EPERM ;if ( ! unix_may_send ( sk , other ) ) goto out_unlock ;if ( sock_flag ( other , SOCK_DEAD ) ) {unix_state_unlock ( other ) ;sock_put ( other ) ;err = 0 ;unix_state_lock ( sk ) ;if ( unix_peer ( sk ) == other ) {unix_peer ( sk ) = NULL ;unix_state_unlock ( sk ) ;","if ( unix_peer ( sk ) == other ) {unix_peer ( sk ) = NULL ;unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) ;unix_state_unlock ( sk ) ;",449
628,"if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) {if ( ! timeo ) {err = - EAGAIN ;goto out_unlock ;}timeo = unix_wait_for_peer ( other , timeo ) ;err = sock_intr_errno ( timeo ) ;","if ( unlikely ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) {if ( ! timeo ) {err = - EAGAIN ;sk_locked = 1 ;goto out_unlock ;}timeo = unix_wait_for_peer ( other , timeo ) ;err = sock_intr_errno ( timeo ) ;",449
629,out_unlock :  unix_state_unlock ( other ) ;out_free : kfree_skb ( skb ) ;,out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;unix_state_unlock ( other ) ;out_free : kfree_skb ( skb ) ;,449
630,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,450
631,load_xid_epoch ( & state ) ;nxip = cur -> xcnt ;,"load_xid_epoch ( & state ) ;StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()"" ) ;nxip = cur -> xcnt ;",451
632,"err = - EMSGSIZE ;if ( len > 0xFFFF )  goto out ;err = - EOPNOTSUPP ;if ( msg -> msg_flags & MSG_OOB ) goto out ;if ( msg -> msg_namelen ) {DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ;err = - EINVAL ;if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ;if ( usin -> sin_family != AF_INET ) {pr_info_once ( ""%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\\err = - EAFNOSUPPORT ;if ( usin -> sin_family ) goto out ;}daddr = usin -> sin_addr . s_addr ;}else {err = - EDESTADDRREQ ;if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ;daddr = inet -> inet_daddr ;}ipc . sockc . tsflags = sk -> sk_tsflags ;ipc . addr = inet -> inet_saddr ;ipc . opt = NULL ;ipc . tx_flags = 0 ;ipc . ttl = 0 ;ipc . tos = - 1 ;ipc . oif = sk -> sk_bound_dev_if ;if ( msg -> msg_controllen ) {err = ip_cmsg_send ( sk , msg , & ipc , false ) ;if ( unlikely ( err ) ) {kfree ( ipc . opt ) ;goto out ;}if ( ipc . opt ) free = 1 ;}saddr = ipc . addr ;ipc . addr = daddr ;if ( ! ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;}rcu_read_unlock ( ) ;}if ( ipc . opt ) {err = - EINVAL ;if ( inet -> hdrincl )  goto done ;",int hdrincl ;err = - EMSGSIZE ;if ( hdrincl ) goto done ;,452
633,"flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE ,  inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol ,  inet_sk_flowi_flags ( sk ) |  ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) ,  daddr , saddr , 0 , 0 , sk -> sk_uid ) ;if ( ! inet -> hdrincl ) {rfv . msg = msg ;","flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , daddr , saddr , 0 , 0 , sk -> sk_uid ) ;if ( ! inet -> hdrincl ) {rfv . msg = msg ;",452
634,"back_from_confirm :  if ( inet -> hdrincl )  err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;","back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;",452
635,case IO_DISCONNECTED :  io_free ( fs -> io ) ;fs -> io = NULL ;break ;,"
",453
636,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},454
637,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,454
638,"if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;","fix_google_param ( google_out ) ;fix_google_param ( google_sig ) ;fix_google_param ( google_reqId ) ;fix_google_param ( google_version ) ;fix_google_param ( responseHandler ) ;fix_google_param ( outFileName ) ;if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;",455
639,"while ( i < npages ) {# ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ;# endif unsigned order = 0 , j ;if ( ! pages [ i ] ) {++ i ;continue ;}# ifdef CONFIG_TRANSPARENT_HUGEPAGE  if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) {for ( j = 0 ;j < HPAGE_PMD_NR ;++ j ) if ( p ++ != pages [ i + j ] ) break ;if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ;}# endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\\__free_pages ( pages [ i ] , order ) ;j = 1 << order ;while ( j ) {pages [ i ++ ] = NULL ;-- j ;}}return ;}i = 0 ;# ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) {unsigned max_size , n2free ;spin_lock_irqsave ( & huge -> lock , irq_flags ) ;while ( i < npages ) {struct page * p = pages [ i ] ;",+ i ;+ j ) if ( p ++ != pages [ i + j ] ) break ;while ( ( npages - i ) >= HPAGE_PMD_NR ) {struct page * p = pages [ i ] ;,456
640,"asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr )  {console_verbose ( ) ;die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ;local_irq_disable ( ) ;panic ( ""bad<S2SV_blank>mode"" ) ;","asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) {siginfo_t info ;void __user * pc = ( void __user * ) instruction_pointer ( regs ) ;console_verbose ( ) ;__show_regs ( regs ) ;info . si_signo = SIGILL ;info . si_errno = 0 ;info . si_code = ILL_ILLOPC ;info . si_addr = pc ;arm64_notify_die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , & info , 0 ) ;",457
641,status = sBtInterface -> enable ( ) ;check_return_status ( status ) ;,status = sBtInterface -> enable ( false ) ;check_return_status ( status ) ;,458
642,"static int  l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 )   {if ( tl1 > l2 ) return 0 ;","static int l_strnstart ( netdissect_options * ndo , const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) {if ( ! ND_TTEST2 ( * str2 , tl1 ) ) {return 0 ;}if ( tl1 > l2 ) return 0 ;",459
643,else   iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ;if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,else {dst = skb_dst ( skb ) ;iif = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ;}if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,460
644,"int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) )  return - 1 ;","static int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {const UINT64 offset = ( UINT64 ) fields -> BufferOffset + ( UINT64 ) fields -> Len ;if ( offset > Stream_Length ( s ) ) return - 1 ;",461
645,"if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) {fprintf ( tf , ""%d\\\","if ( ( tf = fopen_safe ( tfile -> file_path , ""w"" ) ) ) {fprintf ( tf , ""%d\\\",462
646,"int  rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len )  {attr = ( struct vendor_attribute * ) * data ;* vendor = ntohl ( attr -> vendor_value ) ;* data = attr -> attrib_data ;return ( attr -> attrib_type ) ;}","int rad_get_vendor_attr ( u_int32_t * vendor , unsigned char * type , const void * * data , size_t * len , const void * raw , size_t raw_len ) {if ( raw_len < sizeof ( struct vendor_attribute ) ) {return - 1 ;}attr = ( struct vendor_attribute * ) raw ;* vendor = ntohl ( attr -> vendor_value ) ;* type = attr -> attrib_type ;* data = attr -> attrib_data ;if ( ( attr -> attrib_len + 4 ) > raw_len ) {return - 1 ;}return ( attr -> attrib_type ) ;}",463
647,mutex_lock ( & tu -> tread_sem ) ;if ( tu -> timeri ) {,if ( tu -> timeri ) {,464
648,__err :  mutex_unlock ( & tu -> tread_sem ) ;return err ;,__err : return err ;,464
649,"strlcpy ( comp1_str , comp1 -> data , comp1 -> length + 1 ) ;if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST ||  krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) {if ( memchr ( comp2 -> data , \'.\' , comp2 -> length ) == NULL ) goto cleanup ;temp_buf = calloc ( 1 , comp2 -> length + 1 ) ;strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ;retval = krb5int_get_domain_realm_mapping ( kdc_context , temp_buf , & realms ) ;","if ( comp1 -> data , comp1 -> length + 1 ) ;strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ;retval = krb5int_get_domain_realm_mapping ( kdc_context , temp_buf , & realms ) ;",465
650,"for ( i = 0 ;i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ )  photometric [ i ] = ( char ) data [ i ] ;","if ( data == ( unsigned char * ) NULL ) break ;for ( i = 0 ;i <= ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ ) photometric [ i ] = ( char ) data [ i ] ;",466
651,case 0x0008 :  {number_scenes = StringToUnsignedLong ( ( char * ) data ) ;,case 0x0008 : {if ( data == ( unsigned char * ) NULL ) break ;number_scenes = StringToUnsignedLong ( ( char * ) data ) ;,466
652,"if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1051 : {if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ;break ;}case 0x1052 : {if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1053 : {if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1200 : case 0x3006 : {if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / bytes_per_pixel ) ;datum = ( int ) colors ;graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ;if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ;else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ;break ;}case 0x1201 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ;if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;redmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1202 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ;if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;greenmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1203 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ;if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;bluemap [ i ] = ( int ) index ;p += 2 ;}break ;}default : break ;}break ;}case 0x2050 : {switch ( element ) {case 0x0020 : {if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ;break ;}default : break ;}break ;}default : break ;}if ( data != ( unsigned char * ) NULL ) {char * attribute ;for ( i = 0 ;dicom_info [ i ] . description != ( char * ) NULL ;i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ;if ( dicom_info [ i ] . description != ( char * ) NULL ) {attribute = AcquireString ( ""dcm:"" ) ;( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ;for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) {( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ;( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ;}attribute = DestroyString ( attribute ) ;}}if ( image_info -> verbose != MagickFalse ) {if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\\else {for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) {ssize_t j ;datum = 0 ;for ( j = ( ssize_t ) length - 1 ;j >= 0 ;j -- ) datum = ( 256 * datum + data [ j ] ) ;( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ;}else for ( i = 0 ;i < ( ssize_t ) length ;i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ;else ( void ) FormatLocaleFile ( stdout , ""%c"" , \'.\' ) ;( void ) FormatLocaleFile ( stdout , ""\\\}}if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}}if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ;if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) {Image * images ;ImageInfo * read_info ;int c ;size_t length ;unsigned int tag ;for ( i = 0 ;i < ( ssize_t ) stream_info -> remaining ;i ++ ) ( void ) ReadBlobByte ( image ) ;tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;( void ) tag ;length = ( size_t ) ReadBlobLSBLong ( image ) ;stream_info -> offset_count = length >> 2 ;if ( stream_info -> offset_count != 0 ) {MagickOffsetType offset ;stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ;if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;offset = TellBlob ( image ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] += offset ;}read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;images = NewImageList ( ) ;for ( scene = 0 ;scene < ( ssize_t ) number_scenes ;scene ++ ) {char filename [ MagickPathExtent ] ;const char * property ;FILE * file ;Image * jpeg_image ;int unique_file ;unsigned int tag ;tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( tag == 0xFFFEE0DD ) break ;if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( file == ( FILE * ) NULL ) {( void ) RelinquishUniqueFileResource ( filename ) ;ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ;break ;}for ( ;length != 0 ;length -- ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}( void ) fputc ( c , file ) ;}( void ) fclose ( file ) ;( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ;if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ;jpeg_image = ReadImage ( read_info , exception ) ;if ( jpeg_image != ( Image * ) NULL ) {ResetImagePropertyIterator ( image ) ;property = GetNextImageProperty ( image ) ;while ( property != ( const char * ) NULL ) {( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ;property = GetNextImageProperty ( image ) ;}AppendImageToList ( & images , jpeg_image ) ;}( void ) RelinquishUniqueFileResource ( filename ) ;}read_info = DestroyImageInfo ( read_info ) ;image = DestroyImage ( image ) ;return ( GetFirstImageInList ( images ) ) ;}if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) {QuantumAny range ;size_t length ;length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ;for ( i = 0 ;i ++ )  scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ;","if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) GetQuantumRange ( depth ) + 1 ) ;for ( i = 0 ;i ++ ) scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ;",466
653,"status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;","if ( pixel . red <= GetQuantumRange ( depth ) ) status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;",466
654,pixel . red = scale [ pixel . red ] ;pixel . green = scale [ pixel . green ] ;pixel . blue = scale [ pixel . blue ] ;},pixel . red = scale [ pixel . red ] ;if ( pixel . green <= GetQuantumRange ( depth ) ) pixel . green = scale [ pixel . green ] ;if ( pixel . blue <= GetQuantumRange ( depth ) ) pixel . blue = scale [ pixel . blue ] ;},466
655,"size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > ss * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",467
656,"
",if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ;,468
657,( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ;}if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ;( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ;,( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ;}if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ;if ( co64 -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ;( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ;,468
658,"memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;rcu_read_lock ( ) ;","memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;rcu_read_lock ( ) ;",469
659,"vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;{vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ;","memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;{memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ;",470
660,"rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ;if ( rsrc . type_count < 1 ) {","if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) {psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\\goto parse_rsrc_fork_cleanup ;};rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ;if ( rsrc . type_count < 1 ) {",471
661,k ++ )  {if ( marker == STR_MARKER ) {,"k ++ ) {if ( rsrc . type_offset + k * 8 > rsrc . rsrc_len ) {psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\\goto parse_rsrc_fork_cleanup ;};if ( marker == STR_MARKER ) {",471
662,"int start = 0 ;u32 prev_legacy , cur_legacy ;kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","int start = 0 ;int i ;u32 prev_legacy , cur_legacy ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , kvm -> arch . vpit -> pit_state . channels [ i ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",472
663,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",473
664,if ( ( s -> options & SSL_OP_EPHEMERAL_RSA )  # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif )  s -> s3 -> tmp . use_rsa_tmp = 1 ;else s -> s3 -> tmp . use_rsa_tmp = 0 ;,s -> s3 -> tmp . use_rsa_tmp = 1 ;else s -> s3 -> tmp . use_rsa_tmp = 0 ;,474
665,"if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ;if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) {code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ;if ( code ) return code ;}tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ;code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ;if ( code ) goto error_return ;lock_flags = XFS_ILOCK_EXCL ;xfs_ilock ( ip , lock_flags ) ;if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) {",if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! capable_wrt_inode_uidgid ( VFS_I ( ip ) ) ) {,475
666,"if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) &&  ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) )  ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;","if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;",475
667,release_sock ( sk ) ;return 0 ;,msg -> msg_namelen = 0 ;release_sock ( sk ) ;return 0 ;,476
668,"}ret = pipe_set_size ( pipe , nr_pages ) ;","}else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) {ret = - EPERM ;goto out ;}ret = pipe_set_size ( pipe , nr_pages ) ;",477
669,"# ifdef CONFIG_SWAP  if ( ! file ) {* prev = vma ;force_swapin_readahead ( vma , start , end ) ;* prev = vma ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;# else if ( ! file ) return - EBADF ;# endif if ( IS_DAX ( file_inode ( file ) ) ) {return 0 ;}* prev = vma ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;","* prev = vma ;# ifdef CONFIG_SWAP if ( ! file ) {force_swapin_readahead ( vma , start , end ) ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;",478
670,sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;iv = timr -> it_interval ;,sig_none = timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;iv = timr -> it_interval ;,479
671,"uint8_t i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\switch ( subtype ) {case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_len < 7 ) {return hexdump ;}sublen = * ( tptr + 6 ) ;if ( tlv_len < 7 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 7 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) {return hexdump ;}sublen = * ( tptr + 4 ) ;if ( tlv_len < 5 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 5 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;tval = * ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","u_int i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\",480
672,"ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;","ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;",480
673,if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,if ( numrows < 0 || numcols < 0 ) {return 0 ;}if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,481
674,"int len = mutt_b64_decode ( buffer , encoded ) ;if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) {","int len = mutt_b64_decode ( buffer , encoded , sizeof ( buffer ) ) ;if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) {",482
675,case L2CAP_MODE_ERTM :  if ( enable_ertm )  break ;,case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING : if ( enable_ertm ) break ;,483
676,if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) {pDup -> op = TK_NULL ;pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ;},"assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ;if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) {pDup -> op = TK_NULL ;pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ;pDup -> u . zToken = 0 ;}",484
677,"
","if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;",485
678,return self ;},return self ;},485
679,"rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;","if ( desc == NULL ) desc = """" ;rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;",486
680,"ND_PRINT ( ( ndo , ""%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\\","ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;",487
681,"trunc :  ND_PRINT ( ( ndo , ""\\\return 0 ;","trunc : ND_PRINT ( ( ndo , ""\\\return 0 ;",487
682,uint64 nstrips64 ;uint32 nstrips32 ;,uint32 nstrips ;,488
683,"nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ;if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) )  return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips32 ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ;newoffsets [ strip ] = offset ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips32 ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;","nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ;if ( nstrips == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ? offset : 0 ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;",488
684,static ssize_t aio_setup_single_vector ( struct kiocb * kiocb )   {kiocb -> ki_iovec = & kiocb -> ki_inline_vec ;kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ;kiocb -> ki_nr_segs = 1 ;,"static ssize_t aio_setup_single_vector ( int type , struct file * file , struct kiocb * kiocb ) {int bytes ;bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ;if ( bytes < 0 ) return bytes ;kiocb -> ki_iovec = & kiocb -> ki_inline_vec ;kiocb -> ki_iovec -> iov_len = bytes ;kiocb -> ki_nr_segs = 1 ;",489
685,switch ( c = ( * dis_getc ) ( stream ) )  {,"if ( count >= dis_umaxd ) {if ( count > dis_umaxd ) goto overflow ;if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ;}switch ( c = ( * dis_getc ) ( stream ) ) {",490
686,"if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 )  return - 1 ;","if ( TEMP_FAILURE_RETRY ( ioctl ( socket -> fd , FIONREAD , & size ) ) == - 1 ) return - 1 ;",491
687,"static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd ,  int hbs , int mi_row , int mi_col ,  PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) {const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ;const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;}vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;}","static void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const xd , int hbs , int mi_row , int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vpx_writer * w ) {const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;const vpx_prob * const probs = xd -> partition_probs [ ctx ] ;const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;vpx_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;}vpx_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;}",492
688,int i ;vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ;for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ;i -- )  {,vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ;for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ;i -- ) {,493
689,void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields )  {,static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {,494
690,"result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ,  USB_DT_SECURITY , ( void * * ) & secd ) ;if ( result == - 1 ) {","result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , USB_DT_SECURITY , ( void * * ) & secd , sizeof ( * secd ) ) ;if ( result == - 1 ) {",495
691,"vpx_memcpy ( udp , up , 4 ) ;vpx_memcpy ( vdp , vp , 4 ) ;}","memcpy ( udp , up , 4 ) ;memcpy ( vdp , vp , 4 ) ;}",496
692,"regs [ value_regno ] . id = 0 ;regs [ value_regno ] . off = 0 ;regs [ value_regno ] . range = 0 ;regs [ value_regno ] . type = reg_type ;}}else if ( reg -> type == PTR_TO_STACK ) {if ( ! tnum_is_const ( reg -> var_off ) ) {char tn_buf [ 48 ] ;tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ;verbose ( env , ""variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ;return - EACCES ;}off += reg -> var_off . value ;if ( off >= 0 || off < - MAX_BPF_STACK ) {verbose ( env , ""invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\\return - EACCES ;}if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ;if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ;else err = check_stack_read ( env , state , off , size , value_regno ) ;","regs [ value_regno ] , size ) ;",497
693,"regs [ value_regno ] . var_off =  tnum_cast ( regs [ value_regno ] . var_off , size ) ;","coerce_reg_to_size ( & regs [ value_regno ] . var_off = tnum_cast ( regs [ value_regno ] . var_off , size ) ;",497
694,"int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int ,   cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) )  return FALSE ;","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , cap_dst , & wth -> phdr , wth -> frame_buffer , line , err , err_info ) ) return FALSE ;",498
695,"return MSPACK_ERR_SIGNATURE ;}hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ;hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ;hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ;hdr -> length = 0 ;hdr -> filename = NULL ;hdr -> extra = NULL ;hdr -> extra_length = 0 ;if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) {if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;hdr -> length = EndGetI32 ( & buf [ 0 ] ) ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;i = EndGetI16 ( & buf [ 0 ] ) ;if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ;}if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) {off_t pos = sys -> tell ( fh ) ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ;","int len ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( ! ( hdr -> filename = fn ) ) return MSPACK_ERR_NOMEMORY ;",499
696,"int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out ,  size_t * buf_size_out )  {if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out )  goto done ;* buf_size_out = buf_size ;buf = NULL ;","int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out , size_t * buf_size_out , size_t * data_size_out ) {if ( data_size_out ) * data_size_out = 0 ;if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out || ! data_size_out ) goto done ;* buf_size_out = buf_size ;* data_size_out = data_size ;buf = NULL ;",500
697,buf = NULL ;ret = 0 ;,* data_size_out = data_size ;buf = NULL ;ret = 0 ;,500
698,"if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;","if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;}if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;",501
699,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;out_drop_write :  fh_drop_write ( fh ) ;","error = fh_want_write ( fh ) ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;out_drop_lock : fh_unlock ( fh ) ;fh_drop_write ( fh ) ;",502
700,"forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;","forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;",503
701,"backward_matches = exec ( ac_match -> backward_code ,  data + offset ,  offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;","backward_matches = exec ( ac_match -> backward_code , data + offset , data_size - offset , offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;",503
702,"
",if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;,504
703,"bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {","bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {",504
704,"SEPARATE_ZVAL ( var2 ) ;convert_to_double ( * var2 ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}","if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) {zval dval ;dval = * * var ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ;}else {matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}",505
705,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;set_acl_inode ( inode , inode -> i_mode ) ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;",506
706,"vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ;if ( cpi -> common . frame_type != KEY_FRAME )  {","if ( cpi -> oxcf . screen_content_mode ) {int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ;if ( Q >= qp_thresh ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ;}else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ;}else {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ;}block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ;}memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ;if ( cpi -> common . frame_type != KEY_FRAME && block_count > 0 ) {",507
707,cpi -> cyclic_refresh_mode_index = i ;},cpi -> cyclic_refresh_mode_index = i ;# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) {cpi -> cyclic_refresh_q = Q ;lf_adjustment = - 40 ;for ( i = 0 ;i < mbs_in_frame ;++ i ) {seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ;}}}# endif },507
708,struct serial_icounter_struct icount ;struct sb_uart_icount cnow ;,struct serial_icounter_struct icount = {};struct sb_uart_icount cnow ;,508
709,"other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;","other_branch = push_stack ( env , * insn_idx , false + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;",509
710,}# ifdef FEAT_EVAL if ( ignore_script ) return ;,}if ( check_secure ( ) ) return ;# ifdef FEAT_EVAL if ( ignore_script ) return ;,510
711,msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;msc -> ntouches = 0 ;,"if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;",511
712,"bool inode_owner_or_capable ( const struct inode * inode )  {if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;if ( inode_capable ( inode , CAP_FOWNER ) )  return true ;","bool inode_owner_or_capable ( const struct inode * inode ) {struct user_namespace * ns ;if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;ns = current_user_ns ( ) ;if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid ) ) return true ;",512
713,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,513
714,goto error ;},usb_free_urb ( urb ) ;goto error ;},514
715,"msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ;","skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ;",515
716,"static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data ,  OPJ_UINT32 * p_data_written ,  const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {opj_write_bytes ( p_data , J2K_MS_SOT ,  2 ) ;","static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {if ( p_total_data_size < 12 ) {opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\\return OPJ_FALSE ;}opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ;",516
717,"void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) {fadst16_8col ( in0 ) ;","static void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) {fadst16_8col ( in0 ) ;",517
718,# if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL &&  ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) &&  EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) {,# if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && ! SSL_WRITE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) {,518
719,"static const u_char * ikev1_attrmap_print ( netdissect_options * ndo ,  const u_char * p , const u_char * ep ,  const struct attrmap * map , size_t nmap ) {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else  rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 , const struct attrmap * map , size_t nmap ) {ND_TCHECK ( p [ 0 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",519
720,u32 offset ;msg -> msg_namelen = 0 ;,u32 offset ;,520
721,rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i )  {if ( i -> next == 0 ) {,rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) {if ( ! i ) return NULL ;if ( i -> next == 0 ) {,521
722,if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,if ( bpp == 1 && buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,522
723,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( bpp == 8 && pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,522
724,"void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd ,  int frame_filter_level , int y_only , int partial_frame ) {","void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , VP9_COMMON * cm , MACROBLOCKD * xd , int frame_filter_level , int y_only , int partial_frame ) {",523
725,"vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd ,  start_mi_row , end_mi_row , y_only ) ;","vp9_loop_filter_rows ( frame , cm , xd -> plane , start_mi_row , end_mi_row , y_only ) ;",523
726,"
",queueItem -> interface = interface ;,524
727,queueItem -> srcPort = ntohs ( header -> srcPort ) ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,queueItem -> srcPort = ntohs ( header -> srcPort ) ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,524
728,"server . bindaddr = NULL ;server . unixsocket = NULL ;server . ipfd = - 1 ;server . sofd = - 1 ;server . dbnum = REDIS_DEFAULT_DBNUM ;server . verbosity = REDIS_VERBOSE ;server . maxidletime = REDIS_MAXIDLETIME ;server . saveparams = NULL ;server . loading = 0 ;server . logfile = NULL ;server . syslog_enabled = 0 ;server . syslog_ident = zstrdup ( ""redis"" ) ;","server . ds_enabled = 0 ;server . ds_path = zstrdup ( ""redis"" ) ;",525
729,"server . pidfile = zstrdup ( ""/var/run/redis.pid"" ) ;server . dbfilename = zstrdup ( ""dump.rdb"" ) ;server . appendfilename = zstrdup ( ""appendonly.aof"" ) ;server . requirepass = NULL ;server . rdbcompression = 1 ;server . activerehashing = 1 ;server . maxclients = 0 ;server . bpop_blocked_clients = 0 ;server . maxmemory = 0 ;server . maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU ;server . maxmemory_samples = 3 ;server . vm_enabled = 0 ;server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ;server . vm_page_size = 256 ;server . vm_pages = 1024 * 1024 * 100 ;server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ;server . vm_max_threads = 4 ;","server . pidfile = zstrdup ( ""/tmp/redis.ds"" ) ;server . cache_max_memory = 64LL * 1024 * 100 ;server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ;server . vm_max_threads = 4 ;",525
730,int this_rd ;if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) {,int this_rd ;int denoise_aggressive = 0 ;if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) {,526
731,if ( this_mode == ZEROMV )  {if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME &  cpi -> common . refresh_last_frame ) && x -> e_mbd . mode_info_context -> mbmi . ref_frame != LAST_FRAME ) rd_adj = 100 ;,# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ;}# endif if ( ! cpi -> oxcf . screen_content_mode && this_mode == ZEROMV && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) ) {if ( x -> is_skin ) rd_adj = 100 ;,526
732,kfree ( adis -> buffer ) ;if ( ! adis -> buffer )  return - ENOMEM ;rx = adis -> buffer ;tx = rx + scan_count ;,kfree ( adis -> buffer ) {kfree ( adis -> xfer ) ;adis -> xfer = NULL ;;}if ( ! adis -> buffer ) return - ENOMEM ;rx = adis -> buffer ;tx = rx + scan_count ;,527
733,"static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel )  {assign_eip_near ( ctxt , ctxt -> _eip + rel ) ;}","static inline int jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) {return assign_eip_near ( ctxt , ctxt -> _eip + rel ) ;}",528
734,"option_number += option_ext ;* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ;","if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) {return - 1 ;}* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ;",529
735,"option_number += 269 ;* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ;","if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) {return - 1 ;}* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ;",529
736,"if ( io -> status ) {spin_unlock_irqrestore ( & io -> lock , flags ) ;spin_unlock_irqrestore ( & io -> lock , flags ) ;for ( i = io -> entries - 1 ;}","if ( io -> status || io -> count == 0 ) {spin_unlock_irqrestore ( & io -> lock , flags ) ;io -> count ++ ;spin_unlock_irqrestore ( & io -> lock , flags ) ;for ( i = io -> entries - 1 ;spin_lock_irqsave ( & io -> lock , flags ) ;io -> count -- ;if ( ! io -> count ) complete ( & io -> complete ) ;spin_unlock_irqrestore ( & io -> lock , flags ) ;}",530
737,"else if ( n <= 15 && ! strchr ( name , \'.\' ) && type == HOST_TYPE_IPV4 )  {else if ( ! strchr ( name , \'.\' ) )  {","else if ( n <= 15 && ! osStrchr ( name , \'.\' ) && type == HOST_TYPE_IPV4 ) {else if ( ! osStrchr ( name , \'.\' ) ) {",531
738,"hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;nexthdr = * prevhdr ;","hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;if ( hlen < 0 ) {err = hlen ;goto fail ;}nexthdr = * prevhdr ;",532
739,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\if ( msg_flags & MSG_OOB ) goto out ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;if ( msg_flags & MSG_OOB ) goto out ;",533
740,"
",msg -> msg_namelen = sizeof ( * sin ) ;,533
741,}break ;,}break ;,533
742,}if ( addr_len ) * addr_len = sizeof ( * saddr ) ;,* addr_len = sizeof ( * saddr ) ;},534
743,"void fadst8_sse2 ( __m128i * in ) {const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ;","static void fadst8_sse2 ( __m128i * in ) {const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ;",535
744,const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ;,const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ;,535
745,"int rc ;sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ;rc = ecryptfs_parse_options ( sbi , raw_data ) ;if ( rc ) {","uid_t check_ruid ;int rc ;sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ;rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ;if ( rc ) {",536
746,"ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ;s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ;","if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) {rc = - EPERM ;printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\\goto out_free ;}ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ;s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ;",536
747,"list_add ( & dev -> vm_node , & kvm -> devices ) ;mutex_unlock ( & kvm -> lock ) ;if ( ops -> init ) ops -> init ( dev ) ;ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ;if ( ret < 0 ) {mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;ops -> destroy ( dev ) ;return ret ;}kvm_get_kvm ( kvm ) ;cd -> fd = ret ;",kvm_get_kvm ( kvm ) ;cd -> fd = ret ;,537
748,int is_entity ;int i ;Dwg_Class * klass ;unhandled : is_entity = 0 ;i = obj -> type - 500 ;klass = NULL ;dwg = obj -> parent ;if ( dwg -> dwg_class && i >= 0 && i < ( int ) dwg -> num_classes ) {klass = & dwg -> dwg_class [ i ] ;is_entity = klass ? dwg_class_is_entity ( klass ) : 0 ;}if ( obj -> fixedtype == DWG_TYPE_TABLE )  {}else if ( obj -> fixedtype == DWG_TYPE_DATATABLE )  {}else if ( klass && ! is_entity ) {,unhandled : if ( obj -> fixedtype == DWG_TYPE_TABLE ) {}else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) {}else if ( klass && ! is_entity ) {,538
749,evtchn_to_irq [ row ] [ col ] = irq ;return 0 ;,"WRITE_ONCE ( evtchn_to_irq [ row ] [ col ] , irq ) ;return 0 ;",539
750,"inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;goto err ;}inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;",540
751,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return 0 ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return 0 ;",541
752,"
",if ( ! cursor ) goto gc_complete ;,542
753,}slot = node -> parent_slot ;BUG_ON ( ! ptr ) ;node = assoc_array_ptr_to_node ( cursor ) ;,}slot = node -> parent_slot ;BUG_ON ( ! cursor ) ;node = assoc_array_ptr_to_node ( cursor ) ;,542
754,"down_write ( & mm -> mmap_sem ) ;vma = find_vma_prev ( mm , start , & prev ) ;","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;vma = find_vma_prev ( mm , start , & prev ) ;",543
755,goto present_leaves_cluster_but_not_new_leaf ;},"pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\\}",544
756,"return true ;present_leaves_cluster_but_not_new_leaf :  pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\\new_n0 -> back_pointer = node -> back_pointer ;new_n0 -> parent_slot = node -> parent_slot ;new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ;new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ;new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ;new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ;edit -> adjust_count_on = new_n0 ;for ( i = 0 ;i < ASSOC_ARRAY_FAN_OUT ;i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ;new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ;edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ;edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ;edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ;edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ;pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\\","
",544
757,"
",msg -> msg_namelen = 0 ;,545
758,"lock_sock ( sk ) ;for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ;","lock_sock ( sk ) ;for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ;",545
759,"struct mount * m , * child ;int ret = 0 ;","struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ;struct mount * m , * child ;int ret = 0 ;",546
760,"source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;child = copy_tree ( source , source -> mnt . mnt_root , type ) ;","source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ;child = copy_tree ( source , source -> mnt . mnt_root , type ) ;",546
761,}msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ;,}INTL_CHECK_LOCALE_LEN ( slocale_len ) ;msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ;,547
762,if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;},if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},548
763,"if ( client -> priv -> conn != NULL ) {SmsCleanUp ( client -> priv -> conn ) ;}if ( client -> priv -> ice_connection != NULL ) {IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ;IceCloseConnection ( client -> priv -> ice_connection ) ;}if ( client -> priv -> protocol_timeout > 0 ) {g_source_remove ( client -> priv -> protocol_timeout ) ;}","
",549
764,"args -> index = probe ;else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ;if ( name_rmt -> namelen != args -> namelen ) continue ;if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ;if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ;args -> index = probe ;args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount ,  args -> valuelen ) ;return XFS_ERROR ( EEXIST ) ;}","args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , args -> valuelen ) ;",550
765,"void sum_2_variances ( const var * a , const var * b , var * r ) {fill_variance ( a -> sum_square_error + b -> sum_square_error ,  a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ;}","static void sum_2_variances ( const var * a , const var * b , var * r ) {assert ( a -> log2_count == b -> log2_count ) ;fill_variance ( a -> sum_square_error + b -> sum_square_error , a -> log2_count + 1 , r ) ;}",551
766,goto next_desc ;},"goto next_desc ;}if ( ( buflen < elength ) || ( elength < 3 ) ) {dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\\break ;}",552
767,DevInfo . MaxRDMBufferSize = BUFFER_4K ;DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ;,"memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;DevInfo . MaxRDMBufferSize = BUFFER_4K ;DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ;",553
768,"for ( i = 0 ;data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ;assert ( data [ i ] ) ;","assert ( jas_image_numcmpts ( image ) ;++ i ) {data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) <= 3 ) ;for ( i = 0 ;i < 3 ;++ i ) {data [ i ] = 0 ;}for ( i = 0 ;if ( ! ( data [ i ] ) ;",554
769,return - 1 ;}z = ( z << 8 ) | c ;nz += 8 ;,goto error ;}z = ( z << 8 ) | c ;nz += 8 ;,554
770,return - 1 ;return - 1 ;,goto error ;goto error ;,554
771,"
",data [ i ] = 0 ;error : for ( i = 0 ;i < 3 ;++ i ) {if ( data [ i ] ) {jas_matrix_destroy ( data [ i ] ) ;}}return - 1 ;,554
772,# ifndef _MSC_VER   char fpath [ grub_strlen ( currpath ) + 1 ] ;# else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;# endif  char * name = fpath ;,char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;char * name = fpath ;,555
773,* currfound = currnode ;return 0 ;,* currfound = currnode ;free ( fpath ) ;return 0 ;,555
774,"return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno )   return grub_errno ;break ;return grub_error ( GRUB_ERR_SYMLINK_LOOP ,  ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free_node ( oldnode , c ) ;return grub_errno ;","free ( fpath ) ;return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno ) {free ( fpath ) ;return grub_errno ;}break ;free ( fpath ) ;free ( fpath ) ;return grub_error ( GRUB_ERR_SYMLINK_LOOP , ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free ( fpath ) ;free_node ( oldnode , c ) ;return grub_errno ;",555
775,"return grub_errno ;}return 0 ;}return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}","return grub_errno ;}free ( fpath ) ;return 0 ;}free ( fpath ) ;return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}",555
776,"
",if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) {ret = - EINVAL ;goto out_err1 ;},556
777,"clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ;if ( ! clips ) {","clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ;if ( ! clips ) {",556
778,return 0 ;},match_data -> cmp = asymmetric_key_cmp ;return 0 ;},557
779,"ret = - EFAULT ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;ret = security_file_permission ( file , MAY_READ ) ;if ( unlikely ( ret ) ) break ;ret = aio_setup_single_vector ( kiocb ) ;ret = - EFAULT ;if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;ret = security_file_permission ( file , MAY_WRITE ) ;if ( unlikely ( ret ) ) break ;ret = aio_setup_single_vector ( kiocb ) ;ret = security_file_permission ( file , MAY_READ ) ;if ( unlikely ( ret ) ) break ;","ret = aio_setup_single_vector ( READ , file , kiocb ) ;ret = aio_setup_single_vector ( WRITE , file , kiocb ) ;",558
780,"ret = security_file_permission ( file , MAY_WRITE ) ;if ( unlikely ( ret ) ) break ;","
",558
781,"long start ;char * header ;header = calloc ( 1 , 1024 ) ;start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;","char * header ;header = calloc ( 1 , 1024 ) ;long start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;",559
782,dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,560
783,return ret != - EEXIST ? ret : 0 ;},return ret ;},561
784,"for ( pass = 0 ;pass < 10 ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;","for ( pass = 0 ;pass < 10 || image ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;",562
785,int64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == - 1 && whence == SEEK_END ) )  return AVERROR ( ENOSYS ) ;,uint64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == UINT64_MAX && whence == SEEK_END ) ) return AVERROR ( ENOSYS ) ;,563
786,vpx_scale_rtcd ( ) ;once ( setup_rtcd_internal ) ;,once ( setup_rtcd_internal ) ;,564
787,"int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;BIO_write ( bio , obj_txt , len ) ;BIO_write ( bio , ""\\\","OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;BIO_printf ( bio , obj_txt , len ) ;BIO_write ( bio , ""%s\\\",565
788,return in ;},return NULL ;},566
789,"int perf_event_task_disable ( void )  {struct perf_event * event ;list_for_each_entry ( event , & current -> perf_event_list , owner_entry )   perf_event_for_each_child ( event , perf_event_disable ) ;mutex_unlock ( & current -> perf_event_mutex ) ;","int perf_event_task_disable ( void ) {struct perf_event_context * ctx ;struct perf_event * event ;list_for_each_entry ( event , _perf_event_disable ) ;perf_event_ctx_unlock ( event , ctx ) ;}mutex_unlock ( & current -> perf_event_mutex ) ;",567
790,if ( ! unconditional ( & e -> ipv6 ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,568
791,"if ( code )  return code ;code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;","if ( code ) {* status = ""DECODE_PA_S4U_X509_USER"" ;return code ;}code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;",569
792,"arg_ty  arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {","arg_ty arg ( identifier arg , expr_ty annotation , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",570
793,p -> lineno = lineno ;p -> col_offset = col_offset ;,p -> type_comment = type_comment ;p -> lineno = lineno ;p -> col_offset = col_offset ;,570
794,"int hdrlen ;uint16_t fc ;if ( caplen < 3 ) {ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ;return caplen ;}fc = EXTRACT_LE_16BITS ( p ) ;hdrlen = extract_header_length ( fc ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;if ( hdrlen == - 1 ) {ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ;return caplen ;}if ( ! ndo -> ndo_vflag ) {p += hdrlen ;caplen -= hdrlen ;}else {switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 :  panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 :  ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 :  ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case 0x03 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;break ;}caplen -= hdrlen ;}return 0 ;}","u_int hdrlen ;uint16_t fc ;switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;caplen -= 2 ;hdrlen += 2 ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 : panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 : if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p + 2 ) ) ) ;caplen -= 2 ;hdrlen += 2 ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;caplen -= 2 ;hdrlen += 2 ;caplen -= 2 ;hdrlen += 2 ;}if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) }ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;caplen -= 8 ;hdrlen += 8 ;caplen -= 8 ;hdrlen += 8 ;break ;}return hdrlen ;}",571
795,"static void  l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat )  {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) {","static void l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) {",572
796,"int filt_mid = cm -> filter_level ;int filt_low = 0 ;vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ;cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ;","int filt_mid ;int filt_low = 0 ;memset ( ss_err , 0 , sizeof ( ss_err ) ) ;cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ;",573
797,"strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;","strncpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;",574
798,vpx_active_map_t map = {0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;,"vpx_active_map_t map = {0 , 0 , 0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;",575
799,return NGHTTP2_ERR_INVALID_ARGUMENT ;},return NGHTTP2_ERR_INVALID_ARGUMENT ;}if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) {return NGHTTP2_ERR_TOO_MANY_SETTINGS ;},576
800,then = now ;for ( i = hist -> frames ;,if ( ! cfg -> rc_target_bitrate ) return ;then = now ;for ( i = hist -> frames ;,577
801,}},}}if ( free < 0 ) {err = - ENOMEM ;goto out ;},578
802,"if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",579
803,wp -> socket_mode = 0666 ;if ( ! c ) {,wp -> socket_mode = 0660 ;if ( ! c ) {,580
804,"strncpy ( str , ""?["" , len ) ;itostr ( token , & str [ 2 ] , 10 ) ;strncat ( str , ""]"" , len ) ;","espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",581
805,"rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ;}","minfo . flags = 0 ;rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ;}",582
806,srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;,"memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;",583
807,"if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ;len -= sizeof ( * id ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ;nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ;len -= sizeof ( * io ) * nid ;io = ( struct id_off * ) ( id + 1 ) ;cp = ( char * ) ( io + nid ) ;if ( ! ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;","if ( ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;",584
808,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,585
809,"newinet -> pinet6 = & newdp6 -> inet6 ;newnp = inet6_sk ( newsk ) ;memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ;ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ;ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ;inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ;newsk -> sk_backlog_rcv = dccp_v4_do_rcv ;newnp -> pktoptions = NULL ;",newinet -> inet_opt = NULL ;,586
810,newinet -> opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;,newinet -> opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;,586
811,"static double get_prediction_decay_rate ( const VP9_COMMON * cm ,  const FIRSTPASS_STATS * next_frame ) {const double mb_sr_err_diff = ( next_frame -> sr_coded_error -  next_frame -> coded_error ) / cm -> MBs ;const double second_ref_decay = mb_sr_err_diff <= 512.0   ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 )  : 0.85 ;return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ;","static double get_prediction_decay_rate ( const VP9_COMP * cpi , const FIRSTPASS_STATS * next_frame ) {const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) ;const double second_ref_decay = mb_sr_err_diff <= 512.0 ? fclamp ( pow ( 1.0 - sr_decay_rate ) * zero_motion_factor ) ) ) ;",587
812,"# endif case PTRACE_GET_THREAD_AREA :  ret = put_user ( task_thread_info ( child ) -> tp_value ,  datap ) ;","# endif case PTRACE_GET_THREAD_AREA : ret = put_user ( task_thread_info ( child ) -> tp_value [ 0 ] , datap ) ;",588
813,"flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ;vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) ,  & stream -> config . cfg , flags ) ;","# if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ;# endif flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ;vpx_codec_enc_init ( & stream -> encoder , global -> codec -> codec_interface ( ) , & stream -> config . cfg , flags ) ;",589
814,"vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ;}","vpx_codec_dec_init ( & stream -> decoder , decoder -> codec_interface ( ) , NULL , 0 ) ;}",589
815,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" ,  dev_name ( & qedi -> pdev -> dev ) , nfunc , line ,  qedi -> host_no , & vaf ) ;else  pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",590
816,* head = NULL ;* out = line ;return 0 ;,"giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ;return GIT_ERROR ;",591
817,"static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client ,  int id ) {handle = idr_find ( & client -> idr , id ) ;if ( handle ) ion_handle_get ( handle ) ;return handle ? handle : ERR_PTR ( - EINVAL ) ;}","struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , int id ) {handle = ion_handle_get_by_id_nolock ( client , id ) ;return handle ;}",592
818,"void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) {bloc = * offset ;send ( huff -> loc [ ch ] , NULL , fout ) ;* offset = bloc ;","void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset , int maxoffset ) {bloc = * offset ;send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ;* offset = bloc ;",593
819,"int i , j , offset ;uint8_t type ;","int i , offset ;uint8_t type ;",594
820,"u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ;if ( suf < 0x0200 ) {map -> s_partition_type = UDF_VIRTUAL_MAP15 ;map -> s_partition_func = udf_get_pblock_virt15 ;}else {map -> s_partition_type = UDF_VIRTUAL_MAP20 ;map -> s_partition_func = udf_get_pblock_virt20 ;}}else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) {uint32_t loc ;struct sparingTable * st ;struct sparablePartitionMap * spm =  ( struct sparablePartitionMap * ) gpm ;","if ( udf_load_sparable_map ( sb , map , ( struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ;",594
821,},( void ) _y4m ;( void ) _dst ;( void ) _aux ;},595
822,"struct mb_cache_entry * ce ;down_write ( & EXT2_I ( inode ) -> xattr_sem ) ;ea_bdebug ( bh , ""b_count=%d"" , atomic_read ( & ( bh -> b_count ) ) ) ;if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) {ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ;goto cleanup ;}ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ;lock_buffer ( bh ) ;if ( ce )  mb_cache_entry_free ( ce ) ;le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ;if ( ce ) mb_cache_entry_release ( ce ) ;","down_write ( & EXT2_I ( inode ) -> xattr_sem ) ;lock_buffer ( bh ) ;if ( ce ) mb_cache_entry_free ( ce ) ;le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ;if ( ce ) mb_cache_entry_release ( ce ) ;",596
823,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},597
824,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,597
825,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ;}m = n ;",598
826,out :  kfree ( resp ) ;return res ;,out : kfree ( req ) ;kfree ( resp ) ;return res ;,599
827,"char buf [ MAX_PKT_SIZE ] ;memset ( buf , 0 , sizeof ( buf ) ) ;len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ;if ( len > 0 ) {buf [ len ] = 0 ;if ( sa . sa_family != AF_INET ) return ;","char buf [ MAX_PKT_SIZE + 1 ] ;memset ( buf , 0 , sizeof ( buf ) - 1 ) ;len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ;if ( len > 0 ) {if ( sa . sa_family != AF_INET ) return ;",600
828,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;for ( i = 0U ;i < ( maxh & ~ ( unsigned int ) 1U ) ;i += 2U )  {ny = y + maxw ;nr = r + maxw ;for ( j = 0 ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ;int offset , upb ;size_t i ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;offy = img -> y0 & 1U ;loopmaxh = maxh - offy ;if ( offy > 0U ) {size_t j ;for ( j = 0 ;j < maxw ;++ j ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}}for ( i = 0U ;i < ( loopmaxh & ~ ( unsigned int ) 1U ) ;i += 2U ) {ny = y + maxw ;nr = r + maxw ;for ( j = 0 ;j < ( maxw & ~ ( size_t ) 1U ) ;j += 2U ) {size_t j ;",601
829,if ( j < maxw )  {,if ( j < maxw ) {,601
830,if ( i < maxh )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {,if ( i < maxh ) {for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {,601
831,if ( j < maxw ) {,if ( j < loopmaxw ) {,601
832,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else  img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},601
833,if ( * p == '#' ) {p ++ ;,"len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;if ( * p == '#' ) {p ++ ;",602
834,print_bpf_insn ( insn ) ;},"print_bpf_insn ( env , insn ) ;}",603
835,"if ( uid_eq ( uid , current_fsuid ( ) ) )  return true ;if ( gid_eq ( gid , current_fsgid ( ) ) )  return true ;","if ( uid_eq ( uid , file -> f_cred -> fsuid ) ) return true ;if ( gid_eq ( gid , file -> f_cred -> fsgid ) ) return true ;",604
836,return true ;},return nf_generic_should_process ( nf_ct_protonum ( ct ) ) ;},605
837,"im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ;im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ;","if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) {return NULL ;}im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ;im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ;",606
838,"if ( cpi -> pass == 0 ) {if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER )  q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ;if ( q == 0 )  q ++ ;","if ( cpi -> oxcf . rc_mode == VPX_CBR ) q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ;",607
839,"if ( packet -> size + act_size > MT_PACKET_LEN ) {fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\","if ( act_size > MT_PACKET_LEN - packet -> size ) {fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\",608
840,"while ( * s && * s != \\\'\\\\""\\\' )  * ptmp ++ = * s ++ ;","while ( * s && ( * s != \\\'\\\\""\\\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;",609
841,while ( isdigit ( ( unsigned char ) * s ) )  * ptmp ++ = * s ++ ;,while ( isdigit ( ( unsigned char ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;,609
842,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;",610
843,s -> servername_done = 0 ;s -> tlsext_status_type = - 1 ;,s -> tlsext_use_etm = 0 ;,611
844,s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;# ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ;,s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;# ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ;,611
845,"if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ;if ( type == TLSEXT_TYPE_renegotiate ) {if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ;renegotiate_seen = 1 ;}else if ( s -> version == SSL3_VERSION ) {}else if ( type == TLSEXT_TYPE_server_name ) {unsigned int servname_type ;PACKET sni , hostname ;if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) {return 0 ;}if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) {return 0 ;}if ( ! s -> hit ) {if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) {* al = TLS1_AD_UNRECOGNIZED_NAME ;return 0 ;}if ( PACKET_contains_zero_byte ( & hostname ) ) {* al = TLS1_AD_UNRECOGNIZED_NAME ;return 0 ;}if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}s -> servername_done = 1 ;}else {s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ;}}# ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) {PACKET srp_I ;if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ;if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ;if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}# endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) {PACKET ec_point_format_list ;if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) {return 0 ;}if ( ! s -> hit ) {if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}}else if ( type == TLSEXT_TYPE_elliptic_curves ) {PACKET elliptic_curve_list ;if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) {return 0 ;}if ( ! s -> hit ) {if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}}# endif else if ( type == TLSEXT_TYPE_session_ticket ) {if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}else if ( type == TLSEXT_TYPE_signature_algorithms ) {PACKET supported_sig_algs ;if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) {return 0 ;}if ( ! s -> hit ) {if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) {return 0 ;}}}else if ( type == TLSEXT_TYPE_status_request ) {if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) {return 0 ;}# ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) {const unsigned char * ext_data ;PACKET responder_id_list , exts ;if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ;sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ;if ( PACKET_remaining ( & responder_id_list ) > 0 ) {s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ;if ( s -> tlsext_ocsp_ids == NULL ) {* al = SSL_AD_INTERNAL_ERROR ;return 0 ;}}else {s -> tlsext_ocsp_ids = NULL ;}while ( PACKET_remaining ( & responder_id_list ) > 0 ) {OCSP_RESPID * id ;PACKET responder_id ;const unsigned char * id_data ;if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) {return 0 ;}id_data = PACKET_data ( & responder_id ) ;id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ;if ( id == NULL ) return 0 ;if ( id_data != PACKET_end ( & responder_id ) ) {OCSP_RESPID_free ( id ) ;return 0 ;}if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) {OCSP_RESPID_free ( id ) ;* al = SSL_AD_INTERNAL_ERROR ;return 0 ;}}if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ;if ( PACKET_remaining ( & exts ) > 0 ) {ext_data = PACKET_data ( & exts ) ;sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ;s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ;if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) {return 0 ;}}}else # endif {s -> tlsext_status_type = - 1 ;}}# ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) {unsigned int hbtype ;if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) {* al = SSL_AD_DECODE_ERROR ;return 0 ;}switch ( hbtype ) {case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ;break ;case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ;s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ;break ;default : * al = SSL_AD_ILLEGAL_PARAMETER ;return 0 ;}}# endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) {s -> s3 -> next_proto_neg_seen = 1 ;}# endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) {if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ;}# ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) {if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ;}# endif else if ( type == TLSEXT_TYPE_encrypt_then_mac )  s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ;else if ( ! s -> hit ) {",if ( s -> tlsext_debug_cb ) s -> tlsext_use_etm = 1 ;else if ( ! s -> hit ) {,611
846,int cpu = smp_processor_id ( ) ;do {},int cpu = smp_processor_id ( ) ;read_lock ( & evtchn_rwlock ) ;do {read_unlock ( & evtchn_rwlock ) ;},612
847,const char * path = conn -> data -> state . path ;int len ;,const char * path = conn -> data -> state . path ;,613
848,"smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ;if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ;","result = Curl_urldecode ( conn -> data , path , 0 , & smtpc -> domain , NULL , TRUE ) ;if ( result ) return result ;",613
849,while ( ! * ( iter -> substr_cur ) )  iter -> substr_cur ++ ;else * ( iter -> substr_end ) = '\\\\0' ;,else * ( iter -> substr_end ++ ) = '\\\\0' ;,614
850,"const struct aodv_hello * ah ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) )  goto trunc ;ND_PRINT ( ( ndo , ""\\\","const struct aodv_hello * ah ;ND_TCHECK ( * ep ) ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) ) goto trunc ;if ( ep -> length < 4 ) {ND_PRINT ( ( ndo , ""\\\break ;}ND_PRINT ( ( ndo , ""\\\",615
851,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;line_step = frame -> linesize [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;line_step = frame -> linesize [ plane ] ;,616
852,"
","if ( daemon_mode == TRUE && sigrestart == FALSE ) {result = daemon_init ( ) ;if ( result == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ;cleanup ( ) ;exit ( EXIT_FAILURE ) ;}nagios_pid = ( int ) getpid ( ) ;}",617
853,"if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ;","if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ;",617
854,exit ( EXIT_FAILURE ) ;},exit ( EXIT_FAILURE ) ;},617
855,"if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ;if ( ( ( int ) arg >= cdi -> capacity ) )  return - EINVAL ;",if ( arg >= cdi -> capacity ) ) return - EINVAL ;,618
856,rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) /  ( cm -> width * cm -> height ) ;,if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / ( cm -> width * cm -> height ) ;,619
857,else # endif  for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,else # endif for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,620
858,"if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) {log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\\","if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) {if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ;ret = fdt_check_full ( fit , size ) ;if ( ret ) {log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\\return - EINVAL ;}}if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) {log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\\",621
859,"dwc3_gadget_giveback ( dep , req , ret ) ;return ret ;","dwc3_gadget_del_and_unmap_request ( dep , req , ret ) ;return ret ;",622
860,"
","if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;",623
861,"return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ;}","return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ;}",623
862,if ( flags & MSG_OOB )  return - EOPNOTSUPP ;msg -> msg_namelen = 0 ;,if ( flags & MSG_OOB ) return - EOPNOTSUPP ;,624
863,if ( rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;,if ( rs -> rs_bound_addr == 0 || ! rs -> rs_transport ) {ret = - ENOTCONN ;,625
864,"iwl_sta_ucode_activate ( priv , sta_id ) ;ret = 0 ;","ret = iwl_sta_ucode_activate ( priv , sta_id ) ;",626
865,"if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 &&  unconditional ( & e -> ipv6 ) ) || visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",627
866,if ( ! chan ) {err = - EINVAL ;goto out_free ;}if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ;request -> channels [ i ] = chan ;,request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;,628
867,"nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;","nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;",628
868,"static void  sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) {newspan -> _next = before ;}","static void sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) {if ( newspan && before ) {newspan -> _next = before ;}}",629
869,int just_opened = 0 ;restart : if ( ! v -> needed ) return AVERROR_EOF ;,int just_opened = 0 ;int reload_count = 0 ;restart : if ( ! v -> needed ) return AVERROR_EOF ;,630
870,reload :  if ( ! v -> finished &&  av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) {,reload : reload_count ++ ;if ( reload_count > c -> max_reload ) return AVERROR_EOF ;if ( ! v -> finished && av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) {,630
871,"spin_lock_init ( & sta -> lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;","spin_lock_init ( & sta -> lock ) ;spin_lock_init ( & sta -> ps_lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;",631
872,out_size = in_len + 32 ;out_buf = flb_malloc ( out_size ) ;,int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ;out_size = 10 + 8 + max_input_expansion + in_len ;out_buf = flb_malloc ( out_size ) ;,632
873,cmap_len = get_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0  x_origin = get_ushort ( & tga [ 8 ] ) ;y_origin = get_ushort ( & tga [ 10 ] ) ;# endif  image_w = get_ushort ( & tga [ 12 ] ) ;image_h = get_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,cmap_len = get_tga_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0 x_origin = get_tga_ushort ( & tga [ 8 ] ) ;y_origin = get_tga_ushort ( & tga [ 10 ] ) ;# endif image_w = get_tga_ushort ( & tga [ 12 ] ) ;image_h = get_tga_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,633
874,"return ( ( Image * ) NULL ) ;}iris_info . magic = ReadBlobMSBShort ( image ) ;do {if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ;switch ( iris_info . storage ) {case 0x00 : image -> compression = NoCompression ;break ;case 0x01 : image -> compression = RLECompression ;break ;default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ;if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;iris_info . rows = ReadBlobMSBShort ( image ) ;iris_info . depth = ReadBlobMSBShort ( image ) ;if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . minimum_value = ReadBlobMSBLong ( image ) ;iris_info . maximum_value = ReadBlobMSBLong ( image ) ;iris_info . sans = ReadBlobMSBLong ( image ) ;( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * )   iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;","count = ReadBlob ( image , sizeof ( iris_info . name ) ;if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) , ( unsigned char * ) iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;",634
875,"if ( EOFBlob ( image ) != MagickFalse )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",634
876,"if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( bytes_per_pixel == 2 ) {for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {quantum = ( * p << 8 ) ;quantum |= ( * ( p + 1 ) ) ;SetPixelIndex ( image , ( Quantum ) quantum , q ) ;p += 8 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",if ( ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,634
877,"if ( key_is_instantiated ( key ) )  seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ;",635
878,"if ( context -> resynch ) {entry = & entries [ 0 ] ;for ( i = 0 ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) {if ( cursor -> offset == context -> dupcnt ) {context -> dupcnt = 0 ;break ;}context -> dupcnt ++ ;}else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) {context -> dupcnt = 0 ;break ;}}if ( i == ichdr . count ) {trace_xfs_attr_list_notfound ( context ) ;return 0 ;}}else {entry = & entries [ 0 ] ;i = 0 ;}context -> resynch = 0 ;retval = 0 ;for ( ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) {cursor -> hashval = be32_to_cpu ( entry -> hashval ) ;cursor -> offset = 0 ;}if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ;if ( entry -> flags & XFS_ATTR_LOCAL ) {xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ;retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;","if ( ! retval ) retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;",636
879,if ( retval )  return retval ;,if ( retval ) return retval ;,636
880,"cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ;vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ;","memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ;",637
881,"if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 )  return 1 ;","if ( th -> fin ) goto discard ;if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ;",638
882,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;u32 dst = insn -> dst_reg ;int ret ;if ( insn_bitness == 32 ) {,639
883,"case BPF_ADD :  if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) ||  signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {","case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {",639
884,"case BPF_SUB :  if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) ||  signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {","case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {",639
885,"static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ ] = {0x51 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;","static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;adap -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;",640
886,if ( ! vcpu -> arch . time_page )  return - EINVAL ;,if ( ! vcpu -> arch . pv_time_enabled ) return - EINVAL ;,641
887,default :  errno = EINVAL ;,case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ;return 0 ;default : errno = EINVAL ;,642
888,"ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;","ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;",643
889,"case BPF_TYPE_PROG :  atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ;break ;case BPF_TYPE_MAP :  bpf_map_inc ( raw , true ) ;break ;","case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw ) ;break ;case BPF_TYPE_MAP : raw = bpf_map_inc ( raw , true ) ;break ;",644
890,signed long personality ;if ( ! options ) options = & attach_static_default_options ;,int procfd ;signed long personality ;if ( ! options ) options = & attach_static_default_options ;,645
891,"
","procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ;shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ;rexit ( - 1 ) ;}",645
892,"ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ;if ( ret < 0 ) {","ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ;if ( ret < 0 ) {",645
893,". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function ,  . exec_payload = exec_payload  }",". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , . procfd = procfd }",645
894,"timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {","m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {",646
895,"if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\\","if ( * rsize >= 31 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\\",647
896,"pfn = kvm_pin_pages ( slot , gfn , page_size ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;","pfn = kvm_pin_pages ( slot , gfn , page_size >> PAGE_SHIFT ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size >> PAGE_SHIFT ) ;goto unmap_pages ;",648
897,if ( skb_is_nonlinear ( skb ) )  return 0 ;,if ( skb_is_nonlinear ( skb ) ) return 0 ;if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;,649
898,int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,650
899,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",650
900,"Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;","if ( length > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;",651
901,"jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len )  {","jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar * buf , int len ) {",652
902,return ret != - EEXIST ? ret : 0 ;},return ret ;},653
903,TfLiteIntArray * ret =   ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ;ret -> size = size ;,int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ;if ( alloc_size <= 0 ) return NULL ;TfLiteIntArray * ret = ( TfLiteIntArray * ) malloc ( alloc_size ) ;if ( ! ret ) return ret ;ret -> size = size ;,654
904,"struct gs_host_config hconf = {. byte_order = 0x0000beef , };struct gs_device_config dconf ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ,  & hconf ,   sizeof ( hconf ) ,  1000 ) ;if ( rc < 0 ) {dev_err ( & intf -> dev , ""Couldn\\\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\\}rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ,  & dconf ,   sizeof ( dconf ) ,  1000 ) ;return rc ;}icount = dconf . icount + 1 ;return - EINVAL ;}if ( ! dev )  return - ENOMEM ;init_usb_anchor ( & dev -> rx_submitted ) ;atomic_set ( & dev -> active_channels , 0 ) ;dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ;if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) {kfree ( dev ) ;return rc ;return 0 ;}","struct gs_host_config * hconf ;struct gs_device_config dconf ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , hconf , sizeof ( * hconf ) , 1000 ) ;kfree ( hconf ) ;if ( rc < 0 ) {dev_err ( & intf -> dev , ""Couldn\\\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\\}dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ;if ( ! dconf ) return - ENOMEM ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , dconf , sizeof ( * dconf ) , 1000 ) ;kfree ( dconf ) ;return rc ;}icount = dconf -> icount + 1 ;kfree ( dconf ) ;return - EINVAL ;}if ( ! dev ) {kfree ( dconf ) ;return - ENOMEM ;}init_usb_anchor ( & dev -> rx_submitted ) ;atomic_set ( & dev -> active_channels , 0 ) ;dev -> canch [ i ] = gs_make_candev ( i , intf , dconf ) ;if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) {kfree ( dconf ) ;kfree ( dev ) ;return rc ;kfree ( dconf ) ;return 0 ;}",655
905,case 0x00 :  p += 2 ;n += 2 ;case 0x40 :  p += 3 ;n += 3 ;case 0x80 :  p += 4 ;n += 4 ;case 0xC0 :  l = p [ 1 ] ;if ( l < 10 || l > 20 ) return - 1 ;,case 0x00 : if ( len < 2 ) return - 1 ;p += 2 ;n += 2 ;case 0x40 : if ( len < 3 ) return - 1 ;p += 3 ;n += 3 ;case 0x80 : if ( len < 4 ) return - 1 ;p += 4 ;n += 4 ;case 0xC0 : if ( len < 2 ) return - 1 ;l = p [ 1 ] ;if ( l < 10 || l > 20 ) return - 1 ;,656
906,"utee_param_to_param ( param , callee_params ) ;}","res = utee_param_to_param ( utc , param , callee_params ) ;if ( res != TEE_SUCCESS ) return res ;}",657
907,if ( image -> storage_class == PseudoClass )  {,"status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( image -> storage_class == PseudoClass ) {",658
908,"vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;","vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;",659
909,"for ( i = 0 ;i <= SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;","for ( i = 0 ;i < SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;",660
910,break ;},* objp = NULL ;break ;},661
911,else   iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ;if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,else {dst = skb_dst ( skb ) ;iif = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ;}if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,662
912,"static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags ,  const char * data , int optional )  {# endif  if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) {if ( optional ) {","static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , const char * data , int optional , const char * rootfs ) {# endif if ( safe_mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data , rootfs ) ) {if ( optional ) {",663
913,"# endif if ( mount ( fsname , target , fstype ,  mountflags | MS_REMOUNT , data ) ) {if ( optional ) {","# endif if ( mount ( fsname , target , fstype , mountflags | MS_REMOUNT , data ) < 0 ) {if ( optional ) {",663
914,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return simulate_ll ( regs , opcode ) ;perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return simulate_sc ( regs , opcode ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return simulate_ll ( regs , opcode ) ;perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return simulate_sc ( regs , opcode ) ;",664
915,cleanup_free char * base_path = NULL ;int clone_flags ;,const char * base_path = NULL ;int clone_flags ;,665
916,"base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ;if ( ensure_dir ( base_path , 0755 ) ) {free ( base_path ) ;base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ;if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ;}","base_path = ""/tmp"" ;",665
917,"void vp9_fht4x4_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct4x4_c ( input , output , stride ) ;}int16_t out [ 4 * 4 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 4 ] , temp_out [ 4 ] ;const transform_2d ht = FHT_4 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;++ j )  outptr [ j * 4 + i ] = temp_out [ j ] ;}","void vp9_fht4x4_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct4x4_c ( input , output , stride ) ;}tran_low_t out [ 4 * 4 ] ;int i , j ;int16_t temp_in [ 4 ] , temp_out [ 4 ] ;const transform_2d ht = FHT_4 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;++ j ) out [ j * stride + i ] * 16 ;+ j )  outptr [ j * 4 + i ] = temp_out [ j ] ;++ j ) outptr [ j * 4 + i ] = temp_out [ j ] ;}",666
918,"static const char * parse_array ( cJSON * item , const char * value )  {ep = value ;return 0 ;if ( * value == ']' )  return value + 1 ;if ( ! ( item -> child = child = cJSON_New_Item ( ) ) )  return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) )  return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ;child -> next = new_item ;new_item -> prev = child ;child = new_item ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;if ( * value == ']' )  return value + 1 ;ep = value ;","static const char * parse_array ( cJSON * item , const char * value , const char * * ep ) {* ep = value ;return 0 ;if ( * value == ']' ) return value + 1 ;item -> child = child = cJSON_New_Item ( ) ) ) return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ;if ( ! item -> child ) return 0 ;value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) return 0 ;if ( * value == ']' ) return value + 1 ;* ep = value ;",667
919,"int yy , mm , dd , hr , min , sec , csec ;guint pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;","int yy , mm , dd , hr , min , sec , csec , pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;",668
920,"num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}","num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",668
921,const char * args [ 11 ] ;{,"char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ;if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ;log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;const char * args [ 13 ] ;{args [ i ++ ] = ""--tmpdir"" ;args [ i ++ ] = tmp_directory ;",669
922,"args [ i ++ ] = ""--"" ;args [ i ] = NULL ;","args [ i ++ ] = ""--"" ;args [ i ] = NULL ;",669
923,"
","pid_t pid = fork ( ) ;if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ;if ( pid == 0 ) {",669
924,"execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}","int status ;if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ;if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ;if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ;if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ;error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ;}execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}",669
925,kern_msg -> msg_name = kern_address ;},if ( kern_msg -> msg_name ) kern_msg -> msg_name = kern_address ;},670
926,},"id_key_set = rb_intern_const ( ""key_set"" ) ;}",671
927,"if ( ! strcmp ( page , ""/styles.css"" ) ) {",if ( ! page_name_is_good ( page ) ) {,672
928,"if ( strchr ( page , \'/\' ) )  {","if ( strchr ( page , \'/\' ) ) {",672
929,"int do_rf64 = 0 , write_junk = 1 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;JunkChunk junkchunk ;","int do_rf64 = 0 , write_junk = 1 , table_length = 0 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;CS64Chunk cs64_chunk ;JunkChunk junkchunk ;",673
930,"if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;","total_riff_bytes += table_length * sizeof ( CS64Chunk ) ;if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;",673
931,ds64hdr . ckSize = sizeof ( ds64_chunk ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;riffhdr . ckSize = ( uint32_t ) - 1 ;,ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;ds64_chunk . tableLength = table_length ;riffhdr . ckSize = ( uint32_t ) - 1 ;,673
932,"WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {","if ( table_length ) {strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ;cs64_chunk . chunkSize64 = 12345678 ;WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ;}WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}if ( ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {",673
933,pipe -> curbuf = 0 ;kfree ( pipe -> bufs ) ;,"account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;pipe -> curbuf = 0 ;kfree ( pipe -> bufs ) ;",674
934,"cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ;cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ;","if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) {cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\\return CL_EFORMAT ;}cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ;cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ;",675
935,if ( shdr -> sh_size < 1 ) {return false ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;,676
936,"int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err :  ECDSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & p , sig_len ) == NULL ) goto err ;derlen = i2d_ECDSA_SIG ( s , & der ) ;if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}ECDSA_SIG_free ( s ) ;return ( ret ) ;",677
937,NAPI_GRO_CB ( skb ) -> same_flow = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,NAPI_GRO_CB ( skb ) -> encap_mark = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,678
938,"struct mb_cache_entry * ce = NULL ;int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ;if ( ce ) {mb_cache_entry_free ( ce ) ;ce = NULL ;}}unlock_buffer ( bs -> bh ) ;if ( error == - EFSCORRUPTED ) goto bad_block ;if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ;if ( error ) goto cleanup ;goto inserted ;}else {int offset = ( char * ) s -> here - bs -> bh -> b_data ;unlock_buffer ( bs -> bh ) ;if ( ce ) {mb_cache_entry_release ( ce ) ;ce = NULL ;}","struct mb2_cache_entry * ce = NULL ;int error = 0 ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;__u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ;mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ;",679
939,"le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb_cache_entry_release ( ce ) ;ce = NULL ;","if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) {unlock_buffer ( new_bh ) ;dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ;brelse ( new_bh ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;new_bh = NULL ;goto inserted ;}le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb2_cache_entry_touch ( ext4_mb_cache , ce ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;",679
940,cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;brelse ( new_bh ) ;,"cleanup : if ( ce ) mb2_cache_entry_put ( ext4_mb_cache , ce ) ;brelse ( new_bh ) ;",679
941,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\",680
942,"static void oidc_scrub_headers ( request_rec * r ) {oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;","void oidc_scrub_headers ( request_rec * r ) {oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;",681
943,"readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ;if ( readBytes < 0 ) goto exit_closed ;","if ( self -> packetSize <= bufPos ) goto exit_error ;readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ;if ( readBytes < 0 ) goto exit_closed ;",682
944,size_t e ;if ( c -> stack == NULL ) return ;,size_t e ;mrb_value nil ;if ( c -> stack == NULL ) return ;,683
945,if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) {c -> stbase [ i ] = mrb_nil_value ( ) ;}else {}},e = c -> stend - c -> stbase ;nil = mrb_nil_value ( ) ;for ( ;i < e ;i ++ ) {c -> stbase [ i ] = nil ;}},683
946,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,684
947,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,685
948,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> overread_index = pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,685
949,"private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h ,  const cdf_stream_t * sst , const uint64_t clsid [ 2 ] )  {","private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , const cdf_stream_t * sst , const cdf_directory_t * root_storage ) {",686
950,"str = cdf_clsid_to_mime ( clsid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 )  return - 2 ;}m = cdf_file_property_info ( ms , info , count , clsid ) ;free ( info ) ;","if ( root_storage ) {str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) return - 2 ;}}m = cdf_file_property_info ( ms , info , count , root_storage ) ;free ( info ) ;",686
951,op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;++ reg_index ;}op -> offset += temp ;op -> regs [ reg_index ] = X86R_UNDEFINED ;},+ reg_index ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;}++ reg_index ;}op -> offset += temp ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = X86R_UNDEFINED ;}},687
952,"gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc ,   & pdev -> dev , gpio_dev ) ;if ( IS_ERR ( gpio_dev -> pctrl ) ) {if ( ret )  goto out1 ;ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;","gpio_dev -> pctrl = devm_pinctrl_register ( & pdev -> dev , & amd_pinctrl_desc , gpio_dev ) ;if ( IS_ERR ( gpio_dev -> pctrl ) ) {if ( ret ) return ret ;ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;",688
953,out1 :  pinctrl_unregister ( gpio_dev -> pctrl ) ;,"
",688
954,"decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;","decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;",689
955,int is_udplite = IS_UDPLITE ( sk ) ;bool slow ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;bool slow ;,690
956,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",690
957,"int ret , last_pwd ;krb5_boolean have_pol = FALSE ;","int ret , last_pwd , n_new_keys ;krb5_boolean have_pol = FALSE ;",691
958,"if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) {if ( keepold ) return KADM5_PROTECT_PRINCIPAL ;new_n_ks_tuple = 1 ;}ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ;if ( ret ) goto done ;ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ;if ( ret ) goto done ;ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;if ( ret ) goto done ;kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ;ret = krb5_timeofday ( handle -> context , & now ) ;if ( ret ) goto done ;if ( ( adb . aux_attributes & KADM5_POLICY ) ) {ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ;if ( ret ) goto done ;}if ( have_pol ) {ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ;if ( ret ) goto done ;# if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) {ret = KADM5_PASS_TOOSOON ;goto done ;}# endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ;else kdb -> pw_expiration = 0 ;}else {kdb -> pw_expiration = 0 ;}ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ;if ( ret ) goto done ;kdb -> fail_auth_count = 0 ;if ( keyblocks ) {ret = decrypt_key_data ( handle -> context ,   kdb -> n_key_data , kdb -> key_data ,  keyblocks , n_keys ) ;","if ( krb5_principal_compare ( handle -> context , n_new_keys , kdb -> key_data ) ;ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;",691
959,"int isopen ;char * s ;size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ;poly = ( POLYGON * ) palloc0 ( size ) ;","int base_size ;int isopen ;char * s ;base_size = sizeof ( poly -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) ;poly = ( POLYGON * ) palloc0 ( size ) ;",692
960,"ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_32BITS ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",693
961,# if CONFIG_MULTIPLE_ARF  if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ;,rc -> source_alt_ref_pending = 0 ;,694
962,while ( ( u64 ) len > s ) {,while ( ( u64 ) len - s > s ) {,695
963,"_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;","_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;",695
964,struct desc_struct * desc ;unsigned long limit ;if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ;desc = get_desc ( sel ) ;if ( ! desc )  return 0 ;limit = get_desc_limit ( desc ) ;if ( desc -> g )  limit = ( limit << 12 ) + 0xfff ;,struct desc_struct desc ;unsigned long limit ;desc = get_desc ( sel ) ;if ( ! desc ) return 0 ;limit = get_desc_limit ( & desc ) ;if ( desc . g ) limit = ( limit << 12 ) + 0xfff ;,696
965,( void ) CloseBlob ( pwp_image ) ;pwp_image = DestroyImage ( pwp_image ) ;,"
",697
966,"if ( buf_len == 0 ) {return ;}s = p = ( const unsigned char * ) buf ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;if ( * p != \'x\' || * ++ p != \':\' ) {goto outexcept ;}++ p ;pcount = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) {goto outexcept ;}-- p ;count = Z_LVAL_P ( pcount ) ;while ( count -- > 0 ) {spl_SplObjectStorageElement * pelement ;zend_string * hash ;if ( * p != \';\' ) {goto outexcept ;}++ p ;if ( * p != \'O\' && * p != \'C\' && * p != \'r\' ) {goto outexcept ;}if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) {goto outexcept ;}if ( Z_TYPE ( entry ) != IS_OBJECT ) {zval_ptr_dtor ( & entry ) ;goto outexcept ;}}ZVAL_UNDEF ( & inf ) ;",+ p ;+ p ;}ZVAL_UNDEF ( & inf ) ;,698
967,"unsigned long tpgt ;int ret ;if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ;if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX )  return ERR_PTR ( - EINVAL ) ;","u16 tpgt ;int ret ;if ( kstrtou16 ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) return ERR_PTR ( - EINVAL ) ;",699
968,"static  void headerMergeLegacySigs ( Header h , Header sigh )  {HeaderIterator hi ;hi = headerInitIterator ( sigh ) ;for ( ;headerNext ( hi , & td ) ;rpmtdFreeData ( & td ) ) {switch ( td . tag ) {case RPMSIGTAG_SIZE :  td . tag = RPMTAG_SIGSIZE ;break ;case RPMSIGTAG_PGP :  td . tag = RPMTAG_SIGPGP ;break ;case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ;break ;case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ;break ;case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ;break ;case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ;break ;case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ;break ;case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ;break ;case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default :  if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) )  continue ;if ( ! headerIsEntry ( h , td . tag ) ) {switch ( td . type ) {","static rpmTagVal headerMergeLegacySigs ( Header h , Header sigh , char * * msg ) {const struct taglate_s * xl ;rpmtdReset ( & td ) ;for ( xl = xlateTags ;xl -> stag ;xl ++ ) {if ( headerIsEntry ( h , xl -> xtag ) ) break ;if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) {if ( xl -> stag != xl -> xtag ) td . tag ) {case RPMSIGTAG_SIZE : td . tag = xl -> xtag ;if ( td . type != rpmTagGetTagType ( td . tag ) ) break ;if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ;if ( xl -> count && td . count != xl -> count ) break ;if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) continue ;if ( ! headerIsEntry ( h , td . tag ) ) {switch ( td . type ) {",700
969,"( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ;}headerFreeIterator ( hi ) ;","( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ) break ;rpmtdFreeData ( & td ) ;}}rpmtdFreeData ( & td ) ;if ( xl -> stag ) {rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ;return xl -> stag ;",700
970,"xmlGenericError ( xmlGenericErrorContext ,  ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}","xmlGenericError ( xmlGenericErrorContext , ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) {xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ;while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ;return ( - 1 ) ;}",701
971,if ( ! ext4_handle_valid ( handle ) )  return 0 ;,if ( ! EXT4_SB ( sb ) -> s_journal ) return 0 ;,702
972,"ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;","ND_TCHECK2 ( * ext , sizeof ( a ) ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;",703
973,"netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;","memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;",704
974,"if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) )  return 1 ;if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL ||  ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX &&  inode -> i_flock -> fl_type != F_RDLCK ) ) )  return 1 ;",if ( inode -> i_flock == NULL || ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && inode -> i_flock -> fl_type != F_RDLCK ) ) ) return 1 ;,705
975,"static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode ,  struct ext4_ext_path * path )  {struct ext4_extent * ex ;int depth ;ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical""  ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\","static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path ) {struct ext4_extent * ex ;ext4_lblk_t ee_block ;unsigned int ee_len ;int depth ;ee_block = le32_to_cpu ( ex -> ee_block ) ;ee_len = ext4_ext_get_actual_len ( ex ) ;ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) {err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ;if ( err < 0 ) goto out ;ext4_ext_drop_refs ( path ) ;path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ;if ( IS_ERR ( path ) ) {err = PTR_ERR ( path ) ;goto out ;}depth = ext_depth ( inode ) ;ex = path [ depth ] . p_ext ;}",706
976,return ret ;},"if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;return ret ;}",707
977,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,708
978,"if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;","if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;",709
979,"init_thread :  fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ;","if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;init_thread : fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ;",710
980,"bool valid_handle ;BUG_ON ( client != handle -> client ) ;valid_handle = ion_handle_validate ( client , handle ) ;if ( ! valid_handle ) {return ;}mutex_unlock ( & client -> lock ) ;ion_handle_put ( handle ) ;","BUG_ON ( client != handle -> client ) ;ion_free_nolock ( client , handle ) ;if ( ! valid_handle ) {",711
981,"else umount_tree ( mnt , 0 ) ;}","else umount_tree ( mnt , UMOUNT_CONNECTED ) ;}",712
982,"s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;","s -> interlaced_dct = 0 ;s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;",713
983,"k -> get_config ( vdev , vdev -> config ) ;if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ;","if ( addr + sizeof ( val ) > vdev -> config_len ) {return ( uint32_t ) - 1 ;}k -> get_config ( vdev , vdev -> config ) ;",714
984,"static void encode_frame ( vpx_codec_ctx_t * ctx ,  const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {}","static int encode_frame ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {return got_pkts ;}",715
985,"static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ,   double this_frame_mv_in_out ) {double frame_boost ;if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min )   frame_boost = ( IIFACTOR * this_frame -> intra_error /   DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;return MIN ( frame_boost , GF_RMAX ) ;}","static double calc_frame_boost ( VP9_COMP * cpi , const FIRSTPASS_STATS * this_frame , double this_frame_mv_in_out , double max_boost ) {double frame_boost ;const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ;const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ;int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ;num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ;frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ;frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction ;return MIN ( frame_boost , max_boost * boost_q_correction ) ;}",716
986,"static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags )  {if ( open_stateid != NULL )  nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ;write_sequnlock ( & state -> seqlock ) ;update_open_stateflags ( state , open_flags ) ;spin_unlock ( & state -> owner -> so_lock ) ;","static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , fmode_t fmode ) {if ( open_stateid != NULL ) nfs_set_open_stateid_locked ( state , open_stateid , fmode ) ;write_sequnlock ( & state -> seqlock ) ;update_open_stateflags ( state , fmode ) ;spin_unlock ( & state -> owner -> so_lock ) ;",717
987,"ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {","if ( input <= 0.0 || output <= 0.0 ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ;RETURN_FALSE ;}ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {",718
988,"q = ( const uint8_t * ) ( const void * )  ( ( const char * ) ( const void * ) p +  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {","size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {",719
989,"char linebuf [ L_BUF_SIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL )  return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\","char linebuf [ L_BUFSIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUFSIZE , fp ) == NULL ) return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\",720
990,struct net_device * dev = vif -> dev ;if ( netif_carrier_ok ( dev ) ) {rtnl_lock ( ) ;if ( netif_running ( dev ) )  xenvif_down ( vif ) ;rtnl_unlock ( ) ;xenvif_put ( vif ) ;},if ( netif_carrier_ok ( dev ) ) {rtnl_lock ( ) ;if ( netif_running ( dev ) ) xenvif_carrier_off ( vif ) ;rtnl_unlock ( ) ;xenvif_put ( vif ) ;,721
991,"static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd ,  const struct in6_addr * dst , const struct in6_addr * src ) {u32 hash , id ;hash = __ipv6_addr_jhash ( dst , hashrnd ) ;hash = __ipv6_addr_jhash ( src , hash ) ;hash ^= net_hash_mix ( net ) ;","static u32 __ipv6_select_ident ( struct net * net , const struct in6_addr * dst , const struct in6_addr * src ) {const struct {struct in6_addr dst ;struct in6_addr src ;}__aligned ( SIPHASH_ALIGNMENT ) combined = {. dst = * dst , . src = * src , };u32 hash , id ;if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key ) ;",722
992,"err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ;err = - errno ;","err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ;err = - errno ;goto close_sock ;}val = 1 ;ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ;if ( ret == - 1 ) {err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" ) ;err = - errno ;",723
993,hlist_del ( & pin -> m_list ) ;hlist_del ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,hlist_del_init ( & pin -> m_list ) ;hlist_del_init ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,724
994,MACROBLOCK * x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;int step_param ;int sadpb = x -> sadperbit16 ;int bestsme = INT_MAX ;MV best_ref_mv1 = {,MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ;int step_param ;int sadpb = x -> sadperbit16 ;int bestsme = INT_MAX ;int distortion ;unsigned int sse ;int cost_list [ 5 ] ;MV best_ref_mv1 = {,725
995,"xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ;xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ;if ( cpi -> speed < 8 )  step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ;else step_param = cpi -> sf . reduce_first_step_size + 2 ;step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 ,  & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ;{int distortion ;","step_param = mv_sf -> reduce_first_step_size ;step_param = MIN ( step_param , MAX_MVSEARCH_STEPS - 2 ) ) ;vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , cond_cost_list ( cpi , cost_list ) , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ;{int distortion ;",725
996,"packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ;","if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ;",726
997,"ses = cifs_find_smb_ses ( server , volume_info -> username ) ;if ( ses ) {","ses = cifs_find_smb_ses ( server , volume_info ) ;if ( ses ) {",727
998,"
",ybf -> uv_crop_width = ( width + 1 ) / 2 ;ybf -> uv_crop_height = ( height + 1 ) / 2 ;,728
999,ybf -> uv_width = uv_width ;ybf -> uv_height = uv_height ;,ybf -> uv_width = uv_width ;ybf -> uv_height = uv_height ;,728
1000,f2fs_wait_discard_bios ( sbi ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {,"f2fs_wait_discard_bios ( sbi , true ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {",729
1001,s += padlen + 3 ;( * psig ) = s ;return NULL ;,"( * psig ) = s + padlen + 3 ;{const u_char * p ;size_t cnt_ffs = 0 ;for ( p = s + 2 ;p < s + padlen + 2 ;p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ;if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ;}return NULL ;",730
1002,if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) {ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ;}else {if ( ctx -> mb_height > 68 ||  ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) {ctx -> data_offset = 0x280 ;},if ( ctx -> mb_height > 68 ) {,731
1003,"if ( likely ( port -> exists && ! filtered ) )  serio_interrupt ( serio , data , dfl ) ;","if ( likely ( serio && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ;",732
1004,"reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;","reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;",733
1005,"band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;","band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;",733
1006,out1 :  free_netdev ( net ) ;out : return status ;,out1 : cancel_work_sync ( & dev -> kevent ) ;del_timer_sync ( & dev -> delay ) ;free_netdev ( net ) ;out : return status ;,734
1007,"# ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;strncpy ( fstr , ( cp + 1 ) , 7 ) ;strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ;* ( fstr + 6 ) = \'\\\\0\' ;",# ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ;int i ;cp ++ ;for ( i = 0 ;i < 6 ;i ++ ) fstr [ i ] = * cp != \'\\\\0\' ? * cp ++ : \'0\' ;fstr [ i ] = \'\\\\0\' ;,735
1008,ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;return em_pop ( ctxt ) ;,"int rc ;unsigned long eip ;rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ;return em_pop ( ctxt ) ;",736
1009,case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED :  if ( calldata -> arg . open_flags == 0 )  break ;,case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : if ( calldata -> arg . fmode == 0 ) break ;,737
1010,"found :  if ( prev ) {int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ;if ( i > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) {int i = end - FRAG6_CB ( next ) -> offset ;if ( i < next -> len ) {if ( ! pskb_pull ( next , i ) ) goto err ;FRAG6_CB ( next ) -> offset += i ;fq -> q . meat -= i ;if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ;break ;}else {struct sk_buff * free_it = next ;next = next -> next ;if ( prev ) prev -> next = next ;else fq -> q . fragments = next ;fq -> q . meat -= free_it -> len ;frag_kfree_skb ( fq -> q . net , free_it ) ;}}",found : if ( prev && ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) goto discard_fq ;,738
1011,"err :  IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;","discard_fq : fq_kill ( fq ) ;err : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;",738
1012,if ( sbinfo -> max_blocks >= 0 ) {buf -> f_blocks = sbinfo -> max_blocks ;buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ;buf -> f_files = sbinfo -> max_inodes ;,if ( sbinfo -> spool ) {long free_pages ;spin_lock ( & sbinfo -> spool -> lock ) ;buf -> f_blocks = sbinfo -> spool -> max_hpages ;free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages ;buf -> f_bavail = buf -> f_bfree = free_pages ;spin_unlock ( & sbinfo -> spool -> lock ) ;buf -> f_files = sbinfo -> max_inodes ;,739
1013,if ( operand >= MAX_OPERANDS ) {,if ( strlen ( token ) > 4 && operand >= MAX_OPERANDS ) {,740
1014,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,740
1015,else {ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ;}ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;if ( u1_slice_type == I_SLICE ) {,if ( u1_slice_type == I_SLICE ) {,741
1016,"vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ;vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;for ( j = 1 ;vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ;vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;}vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ;vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;}","memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ;memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;for ( j = 1 ;memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ;memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;}memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ;memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;}",742
1017,"# line 1661 ""grammar.c"" break ;case 9 : # line 242 ""grammar.y"" {YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( rule == NULL ) ;( yyval . rule ) = rule ;}# line 1674 ""grammar.c"" break ;case 10 : # line 251 ""grammar.y"" {YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ;rule -> tags = ( yyvsp [ - 3 ] . c_string ) ;rule -> metas = ( yyvsp [ - 1 ] . meta ) ;rule -> strings = ( yyvsp [ 0 ] . string ) ;}# line 1686 ""grammar.c"" break ;case 11 : # line 259 ""grammar.y"" {YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ;compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ;yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 1701 ""grammar.c"" break ;case 12 : # line 274 ""grammar.y"" {( yyval . meta ) = NULL ;}# line 1709 ""grammar.c"" break ;case 13 : # line 278 ""grammar.y"" {YR_META null_meta ;memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ;null_meta . type = META_TYPE_NULL ;compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ;( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 1736 ""grammar.c"" break ;case 14 : # line 305 ""grammar.y"" {( yyval . string ) = NULL ;}# line 1744 ""grammar.c"" break ;case 15 : # line 309 ""grammar.y"" {YR_STRING null_string ;memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ;null_string . g_flags = STRING_GFLAGS_NULL ;compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . string ) = ( yyvsp [ 0 ] . string ) ;}# line 1771 ""grammar.c"" break ;case 17 : # line 340 ""grammar.y"" {( yyval . integer ) = 0 ;}# line 1777 ""grammar.c"" break ;case 18 : # line 341 ""grammar.y"" {( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ;}# line 1783 ""grammar.c"" break ;case 19 : # line 346 ""grammar.y"" {( yyval . integer ) = RULE_GFLAGS_PRIVATE ;}# line 1789 ""grammar.c"" break ;case 20 : # line 347 ""grammar.y"" {( yyval . integer ) = RULE_GFLAGS_GLOBAL ;}# line 1795 ""grammar.c"" break ;case 21 : # line 353 ""grammar.y"" {( yyval . c_string ) = NULL ;}# line 1803 ""grammar.c"" break ;case 22 : # line 357 ""grammar.y"" {compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ;}# line 1821 ""grammar.c"" break ;case 23 : # line 375 ""grammar.y"" {char * identifier ;compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = identifier ;}# line 1838 ""grammar.c"" break ;case 24 : # line 388 ""grammar.y"" {char * tag_name = ( yyvsp [ - 1 ] . c_string ) ;size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ;while ( tag_length > 0 ) {if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) {yr_compiler_set_error_extra_info ( compiler , tag_name ) ;compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ;break ;}tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ;tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ;}if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ;}# line 1874 ""grammar.c"" break ;case 25 : # line 424 ""grammar.y"" {( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ;}# line 1880 ""grammar.c"" break ;case 26 : # line 425 ""grammar.y"" {( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ;}# line 1886 ""grammar.c"" break ;case 27 : # line 431 ""grammar.y"" {SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ;( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1906 ""grammar.c"" break ;case 28 : # line 447 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1923 ""grammar.c"" break ;case 29 : # line 460 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ;yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1940 ""grammar.c"" break ;case 30 : # line 473 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1957 ""grammar.c"" break ;case 31 : # line 486 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1974 ""grammar.c"" break ;case 32 : # line 502 ""grammar.y"" {( yyval . string ) = ( yyvsp [ 0 ] . string ) ;}# line 1980 ""grammar.c"" break ;case 33 : # line 503 ""grammar.y"" {( yyval . string ) = ( yyvsp [ - 1 ] . string ) ;}# line 1986 ""grammar.c"" break ;case 34 : # line 509 ""grammar.y"" {compiler -> error_line = yyget_lineno ( yyscanner ) ;}# line 1994 ""grammar.c"" break ;case 35 : # line 513 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ;yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;compiler -> error_line = 0 ;}# line 2009 ""grammar.c"" break ;case 36 : # line 524 ""grammar.y"" {compiler -> error_line = yyget_lineno ( yyscanner ) ;}# line 2017 ""grammar.c"" break ;case 37 : # line 528 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ;yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;compiler -> error_line = 0 ;}# line 2033 ""grammar.c"" break ;case 38 : # line 540 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;}# line 2047 ""grammar.c"" break ;case 39 : # line 553 ""grammar.y"" {( yyval . integer ) = 0 ;}# line 2053 ""grammar.c"" break ;case 40 : # line 554 ""grammar.y"" {( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ;}# line 2059 ""grammar.c"" break ;case 41 : # line 559 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_WIDE ;}# line 2065 ""grammar.c"" break ;case 42 : # line 560 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_ASCII ;}# line 2071 ""grammar.c"" break ;case 43 : # line 561 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_NO_CASE ;}# line 2077 ""grammar.c"" break ;case 44 : # line 562 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_FULL_WORD ;}# line 2083 ""grammar.c"" break ;case 45 : # line 568 ""grammar.y"" {int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ;if ( var_index >= 0 ) {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ;}else {YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ;if ( object == NULL ) {char * ns = compiler -> current_namespace -> name ;object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ;}if ( object != NULL ) {char * id ;compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = object ;( yyval . expression ) . identifier = object -> identifier ;}else {YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ;if ( rule != NULL ) {compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;( yyval . expression ) . value . integer = UNDEFINED ;( yyval . expression ) . identifier = rule -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ;compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ;}}}yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2172 ""grammar.c"" break ;case 46 : # line 653 ""grammar.y"" {YR_OBJECT * field = NULL ;if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) {field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ;if ( field != NULL ) {char * ident ;compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = field ;( yyval . expression ) . identifier = field -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ;compiler -> last_result = ERROR_INVALID_FIELD_NAME ;}}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_NOT_A_STRUCTURE ;}yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2222 ""grammar.c"" break ;case 47 : # line 699 ""grammar.y"" {YR_OBJECT_ARRAY * array ;YR_OBJECT_DICTIONARY * dict ;if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) {if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) {yr_compiler_set_error_extra_info ( compiler , ""array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ;array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = array -> prototype_item ;( yyval . expression ) . identifier = array -> identifier ;}else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) {if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) {yr_compiler_set_error_extra_info ( compiler , ""dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ;dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = dict -> prototype_item ;( yyval . expression ) . identifier = dict -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_NOT_INDEXABLE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2283 ""grammar.c"" break ;case 48 : # line 757 ""grammar.y"" {YR_OBJECT_FUNCTION * function ;char * args_fmt ;if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) {compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ;function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = function -> return_obj ;( yyval . expression ) . identifier = function -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_NOT_A_FUNCTION ;}yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2328 ""grammar.c"" break ;case 49 : # line 801 ""grammar.y"" {( yyval . c_string ) = yr_strdup ( """" ) ;}# line 2334 ""grammar.c"" break ;case 50 : # line 802 ""grammar.y"" {( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ;}# line 2340 ""grammar.c"" break ;case 51 : # line 807 ""grammar.y"" {( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ;switch ( ( yyvsp [ 0 ] . expression ) . type ) {case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ;break ;}ERROR_IF ( ( yyval . c_string ) == NULL ) ;}# line 2369 ""grammar.c""  break ;case 52 :  # line 832 ""grammar.y""  {","# line 2371 ""grammar.c"" break ;case 9 : # line 834 ""grammar.y"" {",743
1018,"
",default : assert ( FALSE ) ;,743
1019,"}}# line 2405 ""grammar.c""  break ;case 53 :  # line 868 ""grammar.y""  {","}}# line 2405 ""grammar.c"" break ;case 53 : # line 868 ""grammar.y"" {",743
1020,"# line 2451 ""grammar.c""  break ;case 54 :  # line 914 ""grammar.y""  {","# line 2451 ""grammar.c"" break ;case 54 : # line 914 ""grammar.y"" {",743
1021,"# line 2474 ""grammar.c""  break ;case 55 :  # line 936 ""grammar.y""  {# line 2487 ""grammar.c""  break ;case 56 :  # line 945 ""grammar.y""  {# line 2500 ""grammar.c""  break ;case 57 :  # line 954 ""grammar.y""  {# line 2519 ""grammar.c""  break ;case 58 :  # line 969 ""grammar.y""  {# line 2535 ""grammar.c""  break ;case 59 :  # line 981 ""grammar.y""  {# line 2553 ""grammar.c""  break ;case 60 :  # line 995 ""grammar.y""  {# line 2570 ""grammar.c""  break ;case 61 :  # line 1008 ""grammar.y""  {# line 2585 ""grammar.c""  break ;case 62 :  # line 1019 ""grammar.y""  {}# line 2597 ""grammar.c"" break ;case 63 :  # line 1027 ""grammar.y""  {","# line 2474 ""grammar.c"" break ;case 55 : # line 936 ""grammar.y"" {# line 2487 ""grammar.c"" break ;case 56 : # line 945 ""grammar.y"" {# line 2500 ""grammar.c"" break ;case 57 : # line 954 ""grammar.y"" {# line 2519 ""grammar.c"" break ;case 58 : # line 969 ""grammar.y"" {# line 2535 ""grammar.c"" break ;case 59 : # line 981 ""grammar.y"" {# line 2553 ""grammar.c"" break ;case 60 : # line 995 ""grammar.y"" {# line 2570 ""grammar.c"" break ;case 61 : # line 1008 ""grammar.y"" {# line 2585 ""grammar.c"" break ;case 62 : # line 1019 ""grammar.y"" {}# line 2597 ""grammar.c"" break ;case 63 : # line 1027 ""grammar.y"" {",743
1022,"# line 2631 ""grammar.c""  break ;case 64 :  # line 1057 ""grammar.y""  {","# line 2631 ""grammar.c"" break ;case 64 : # line 1057 ""grammar.y"" {",743
1023,"# line 2670 ""grammar.c""  break ;case 65 :  # line 1092 ""grammar.y""  {","# line 2670 ""grammar.c"" break ;case 65 : # line 1092 ""grammar.y"" {",743
1024,"# line 2753 ""grammar.c""  break ;case 66 :  # line 1171 ""grammar.y""  {","# line 2753 ""grammar.c"" break ;case 66 : # line 1171 ""grammar.y"" {",743
1025,"# line 2787 ""grammar.c""  break ;case 67 :  # line 1201 ""grammar.y""  {","# line 2787 ""grammar.c"" break ;case 67 : # line 1201 ""grammar.y"" {",743
1026,"# line 2840 ""grammar.c""  break ;case 68 :  # line 1250 ""grammar.y""  {# line 2850 ""grammar.c""  break ;case 69 :  # line 1256 ""grammar.y""  {# line 2860 ""grammar.c""  break ;case 70 :  # line 1262 ""grammar.y""  {","# line 2840 ""grammar.c"" break ;case 68 : # line 1250 ""grammar.y"" {# line 2850 ""grammar.c"" break ;case 69 : # line 1256 ""grammar.y"" {# line 2860 ""grammar.c"" break ;case 70 : # line 1262 ""grammar.y"" {",743
1027,"# line 2890 ""grammar.c""  break ;case 71 :  # line 1288 ""grammar.y""  {","# line 2890 ""grammar.c"" break ;case 71 : # line 1288 ""grammar.y"" {",743
1028,"# line 2930 ""grammar.c""  break ;case 72 :  # line 1324 ""grammar.y""  {","# line 2930 ""grammar.c"" break ;case 72 : # line 1324 ""grammar.y"" {",743
1029,"# line 2959 ""grammar.c""  break ;case 73 :  # line 1349 ""grammar.y""  {","# line 2959 ""grammar.c"" break ;case 73 : # line 1349 ""grammar.y"" {",743
1030,"# line 2999 ""grammar.c""  break ;case 74 :  # line 1385 ""grammar.y""  {# line 3012 ""grammar.c""  break ;case 75 :  # line 1394 ""grammar.y""  {# line 3025 ""grammar.c""  break ;case 76 :  # line 1403 ""grammar.y""  {# line 3038 ""grammar.c""  break ;case 77 :  # line 1412 ""grammar.y""  {# line 3051 ""grammar.c""  break ;case 78 :  # line 1421 ""grammar.y""  {# line 3064 ""grammar.c""  break ;case 79 :  # line 1430 ""grammar.y""  {# line 3077 ""grammar.c""  break ;case 80 :  # line 1439 ""grammar.y""  {# line 3085 ""grammar.c""  break ;case 81 :  # line 1443 ""grammar.y""  {# line 3093 ""grammar.c""  break ;case 82 :  # line 1450 ""grammar.y""  {# line 3099 ""grammar.c""  break ;case 83 :  # line 1451 ""grammar.y""  {# line 3105 ""grammar.c""  break ;case 84 :  # line 1457 ""grammar.y""  {","# line 2999 ""grammar.c"" break ;case 74 : # line 1385 ""grammar.y"" {# line 3012 ""grammar.c"" break ;case 75 : # line 1394 ""grammar.y"" {# line 3025 ""grammar.c"" break ;case 76 : # line 1403 ""grammar.y"" {# line 3038 ""grammar.c"" break ;case 77 : # line 1412 ""grammar.y"" {# line 3051 ""grammar.c"" break ;case 78 : # line 1421 ""grammar.y"" {# line 3064 ""grammar.c"" break ;case 79 : # line 1430 ""grammar.y"" {# line 3077 ""grammar.c"" break ;case 80 : # line 1439 ""grammar.y"" {# line 3085 ""grammar.c"" break ;case 81 : # line 1443 ""grammar.y"" {# line 3093 ""grammar.c"" break ;case 82 : # line 1450 ""grammar.y"" {# line 3099 ""grammar.c"" break ;case 83 : # line 1451 ""grammar.y"" {# line 3105 ""grammar.c"" break ;case 84 : # line 1457 ""grammar.y"" {",743
1031,"# line 3127 ""grammar.c""  break ;case 85 :  # line 1479 ""grammar.y""  {# line 3143 ""grammar.c""  break ;case 86 :  # line 1491 ""grammar.y""  {# line 3158 ""grammar.c""  break ;case 87 :  # line 1506 ""grammar.y""  {# line 3167 ""grammar.c""  break ;case 89 :  # line 1512 ""grammar.y""  {# line 3178 ""grammar.c""  break ;case 92 :  # line 1529 ""grammar.y""  {# line 3189 ""grammar.c""  break ;case 93 :  # line 1536 ""grammar.y""  {# line 3200 ""grammar.c""  break ;case 95 :  # line 1548 ""grammar.y""  {# line 3208 ""grammar.c""  break ;case 96 :  # line 1552 ""grammar.y""  {# line 3216 ""grammar.c""  break ;case 97 :  # line 1560 ""grammar.y""  {# line 3224 ""grammar.c""  break ;case 98 :  # line 1564 ""grammar.y""  {# line 3238 ""grammar.c""  break ;case 99 :  # line 1574 ""grammar.y""  {yywarning ( yyscanner , ""Using<S2SV_blank>deprecated<S2SV_blank>\\\\""entrypoint\\\\""<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\\\""entry_point\\\\""<S2SV_blank>"" ""function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead."" ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3256 ""grammar.c""  break ;case 100 :  # line 1588 ""grammar.y""  {CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX"" ) ;compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3276 ""grammar.c""  break ;case 101 :  # line 1604 ""grammar.y""  {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ;}# line 3290 ""grammar.c""  break ;case 102 :  # line 1614 ""grammar.y""  {compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;}# line 3303 ""grammar.c""  break ;case 103 :  # line 1623 ""grammar.y""  {","# line 3127 ""grammar.c"" break ;case 85 : # line 1479 ""grammar.y"" {# line 3143 ""grammar.c"" break ;case 86 : # line 1491 ""grammar.y"" {# line 3158 ""grammar.c"" break ;case 87 : # line 1506 ""grammar.y"" {# line 3167 ""grammar.c"" break ;case 89 : # line 1512 ""grammar.y"" {# line 3178 ""grammar.c"" break ;case 92 : # line 1529 ""grammar.y"" {# line 3189 ""grammar.c"" break ;case 93 : # line 1536 ""grammar.y"" {# line 3200 ""grammar.c"" break ;case 95 : # line 1548 ""grammar.y"" {# line 3208 ""grammar.c"" break ;case 96 : # line 1552 ""grammar.y"" {# line 3216 ""grammar.c"" break ;case 97 : # line 1560 ""grammar.y"" {# line 3224 ""grammar.c"" break ;case 98 : # line 1564 ""grammar.y"" {# line 2409 ""grammar.c"" break ;case 99 : # line 872 ""grammar.y"" {",743
1032,"# line 3332 ""grammar.c""  break ;case 104 :  # line 1648 ""grammar.y""  {# line 3348 ""grammar.c""  break ;case 105 :  # line 1660 ""grammar.y""  {# line 3364 ""grammar.c""  break ;case 106 :  # line 1672 ""grammar.y""  {","# line 3332 ""grammar.c"" break ;case 104 : # line 1648 ""grammar.y"" {# line 3348 ""grammar.c"" break ;case 105 : # line 1660 ""grammar.y"" {# line 3364 ""grammar.c"" break ;case 106 : # line 1672 ""grammar.y"" {",743
1033,"# line 3384 ""grammar.c""  break ;case 107 :  # line 1688 ""grammar.y""  {compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ;yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3400 ""grammar.c""  break ;case 108 :  # line 1700 ""grammar.y""  {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3420 ""grammar.c""  break ;case 109 :  # line 1716 ""grammar.y""  {","# line 2455 ""grammar.c"" break ;case 107 : # line 918 ""grammar.y"" {",743
1034,"# line 3469 ""grammar.c""  break ;case 110 :  # line 1761 ""grammar.y""  {CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ;if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) {( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ;}else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) {( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3492 ""grammar.c""  break ;case 111 :  # line 1780 ""grammar.y""  {","# line 2478 ""grammar.c"" break ;case 110 : # line 940 ""grammar.y"" {",743
1035,"# line 3514 ""grammar.c""  break ;case 112 :  # line 1798 ""grammar.y""  {","# line 3514 ""grammar.c"" break ;case 112 : # line 1798 ""grammar.y"" {",743
1036,"# line 3536 ""grammar.c""  break ;case 113 :  # line 1816 ""grammar.y""  {","# line 2491 ""grammar.c"" break ;case 113 : # line 949 ""grammar.y"" {",743
1037,"# line 3558 ""grammar.c""  break ;case 114 :  # line 1834 ""grammar.y""  {compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""\\\\\\\\"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) {if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) {( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;}else {compiler -> last_result = ERROR_DIVISION_BY_ZERO ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}}else {( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;}}# line 3588 ""grammar.c""  break ;case 115 :  # line 1860 ""grammar.y""  {","# line 2504 ""grammar.c"" break ;case 114 : # line 958 ""grammar.y"" {",743
1038,"# line 3610 ""grammar.c""  break ;case 116 :  # line 1878 ""grammar.y""  {# line 3624 ""grammar.c""  break ;case 117 :  # line 1888 ""grammar.y""  {# line 3638 ""grammar.c""  break ;case 118 :  # line 1898 ""grammar.y""  {# line 3652 ""grammar.c""  break ;case 119 :  # line 1908 ""grammar.y""  {# line 3666 ""grammar.c""  break ;case 120 :  # line 1918 ""grammar.y""  {# line 3680 ""grammar.c""  break ;case 121 :  # line 1928 ""grammar.y""  {# line 3694 ""grammar.c""  break ;case 122 :  # line 1938 ""grammar.y""  {# line 3702 ""grammar.c""  break ;# line 3706 ""grammar.c""  default : break ;","# line 3610 ""grammar.c"" break ;case 116 : # line 1878 ""grammar.y"" {# line 2523 ""grammar.c"" break ;case 117 : # line 973 ""grammar.y"" {# line 2539 ""grammar.c"" break ;case 118 : # line 1898 ""grammar.y"" {# line 2557 ""grammar.c"" break ;case 119 : # line 999 ""grammar.y"" {# line 2574 ""grammar.c"" break ;case 120 : # line 1918 ""grammar.y"" {# line 2589 ""grammar.c"" break ;case 121 : # line 1928 ""grammar.y"" {# line 2637 ""grammar.c"" break ;case 122 : # line 1938 ""grammar.y"" {# line 2676 ""grammar.c"" break ;# line 3706 ""grammar.c"" default : break ;",743
1039,if ( roishift == 0 && bgshift == 0 ) {return ;,"if ( roishift < 0 ) {jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\\roishift = 0 ;}if ( roishift == 0 && bgshift == 0 ) {return ;",744
1040,mask = ( 1 << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {,"mask = ( JAS_CAST ( uint_fast32_t , 1 ) << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {",744
1041,"static void get_frame_stats ( vpx_codec_ctx_t * ctx ,  const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline ,  vpx_fixed_buf_t * stats ) {vpx_codec_iter_t iter = NULL ;if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;}","static int get_frame_stats ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , vpx_fixed_buf_t * stats ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;return got_pkts ;}",745
1042,"int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) {LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;( void ) arg2 ;vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd ,  lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;","int vp9_loop_filter_worker ( LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;( void ) arg2 ;vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;",746
1043,"while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ;while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 )  ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ;for ( ;","while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( cp ) - 1 ) ;while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ;for ( ;",747
1044,"if ( ( e -> target_offset == sizeof ( struct arpt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> arp ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",748
1045,int event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,u64 event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,749
1046,alarm_timer = alarm_new ( ) ;if ( ! alarm_timer ) {,btif_config_devcache_cleanup ( ) ;alarm_timer = alarm_new ( ) ;if ( ! alarm_timer ) {,750
1047,int groups_per_flex = 0 ;size_t size ;groups_per_flex = 1 << sbi -> s_log_groups_per_flex ;if ( groups_per_flex < 2 ) {sbi -> s_log_groups_per_flex = 0 ;return 1 ;},unsigned int groups_per_flex = 0 ;size_t size ;,751
1048,for ( k = passIC + 2 ;k < passIC + 2 + passInstructions [ passIC + 1 ] ;k ++ )  if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ;,for ( k = passIC + 2 ;( ( k < passIC + 2 + passInstructions [ passIC + 1 ] ) && ( kk < input -> length ) ) ;k ++ ) if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ;,752
1049,rx_drop :  kfree_skb ( skb ) ;rcv_stats -> rx_dropped ++ ;,rx_drop : rcv_stats -> rx_dropped ++ ;,753
1050,"int rc ;unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}","unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_cipher ( ""des"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}",754
1051,"sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , NULL , NULL ) ;skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ;rc = crypto_skcipher_encrypt ( req ) ;smbhash_err :  return rc ;","sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , 0 ) ;return 0 ;",754
1052,"
",if ( band -> prec ) {,755
1053,Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;av_freep ( & band -> prec ) ;},Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;}av_freep ( & band -> prec ) ;},755
1054,"return - ENOEXEC ;}if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) {if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ;ret = fdt_check_full ( fit , size ) ;if ( ret ) {log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\\return - EINVAL ;}","if ( ret ) ret = - EINVAL ;if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) {ret = fdt_check_no_at ( fit , 0 ) ;return ret ;}}if ( ret ) {log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\\return ret ;}",756
1055,"if ( len > BUFSIZE + sizeof ( struct nbd_reply ) )  err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;","if ( len > BUFSIZE - sizeof ( struct nbd_reply ) ) err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;",757
1056,"int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ;i ++ , offset += gpm -> partitionMapLength ) {","unsigned int table_len ;int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;table_len = le32_to_cpu ( lvd -> mapTableLength ) ;if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) {udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\\goto out_bh ;}ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < table_len ;i ++ , offset += gpm -> partitionMapLength ) {",758
1057,"int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ;size_t bytes_left = br -> user_buffer_end - bufptr ;size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ;br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ;","int shift = VP8_BD_VALUE_SIZE - CHAR_BIT - ( count + 8 ) ;size_t bytes_left = br -> user_buffer_end - bufptr ;size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) ;br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ;",759
1058,"if ( in ) {dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;dev -> out_pipe = usb_sndbulkpipe ( udev ,  out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;}if ( iso_in ) {","if ( in ) dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;if ( iso_in ) {",760
1059,for ( y = 0 ;uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ;,av_assert0 ( s -> bit_depth > 1 ) ;for ( y = 0 ;uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ;,761
1060,"static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags )  {if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) {rcu_read_unlock ( ) ;","static void nfs4_return_incompatible_delegation ( struct inode * inode , fmode_t fmode ) {if ( delegation == NULL || ( delegation -> type & fmode ) == fmode ) {rcu_read_unlock ( ) ;",762
1061,"void jslTokenAsString ( int token , char * str , size_t len ) {if ( token > 32 && token < 128 ) {","void jslTokenAsString ( int token , char * str , size_t len ) {assert ( len > 28 ) ;if ( token > 32 && token < 128 ) {",763
1062,"case LEX_EOF : strncpy ( str , ""EOF"" , len ) ;case LEX_ID : strncpy ( str , ""ID"" , len ) ;case LEX_INT : strncpy ( str , ""INT"" , len ) ;case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ;case LEX_STR : strncpy ( str , ""STRING"" , len ) ;case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ;case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ;case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ;case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ;}","case LEX_EOF : strcpy ( str , ""EOF"" , len ) ;case LEX_ID : strcpy ( str , ""ID"" , len ) ;case LEX_INT : strcpy ( str , ""INT"" , len ) ;case LEX_FLOAT : strcpy ( str , ""FLOAT"" , len ) ;case LEX_STR : strcpy ( str , ""STRING"" , len ) ;case LEX_UNFINISHED_STR : strcpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ;case LEX_TEMPLATE_LITERAL : strcpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_REGEX : strcpy ( str , ""REGEX"" , len ) ;case LEX_UNFINISHED_REGEX : strcpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ;case LEX_UNFINISHED_COMMENT : strcpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ;}",763
1063,"strncpy ( str , & tokenNames [ p ] , len ) ;return ;assert ( len >= 10 ) ;espruino_snprintf ( str , len , ""?[%d]"" , token ) ;","strcpy ( str , & tokenNames [ p ] ) ;return ;assert ( len >= 10 ) ;espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",763
1064,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,764
1065,"
","memset ( sax , 0 , sizeof ( sax ) ) ;",765
1066,"sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;","sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;",765
1067,"static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val )  {","static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) {",766
1068,return res ;cleanup : if ( hdl ) {,cleanup : return res ;cleanup : if ( hdl ) {,767
1069,"}if ( section == & service_options || section == & new_service_options )   s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>defaults"" ) ;else s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>[%s]"" , section -> servname ) ;","if ( section == & service_options ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ;else if ( section == & new_service_options ) s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ;else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , section -> servname ) ;}if ( section == & service_options || section == & new_service_options ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults"" ) ;else s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>[%s]"" , section -> servname ) ;",768
1070,switch ( cmd ) {,"# if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) {case CMD_SET_DEFAULTS : section -> security_level = - 1 ;break ;case CMD_SET_COPY : section -> security_level = new_service_options . security_level ;break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""securityLevel"" ) ) break ;{char * tmp_str ;int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ;if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return ""Illegal<S2SV_blank>security<S2SV_blank>level"" ;section -> security_level = tmp_int ;}return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""securityLevel"" , DEFAULT_SECURITY_LEVEL ) ;break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level"" , ""securityLevel"" ) ;break ;}# endif switch ( cmd ) {",768
1071,}# ifndef USE_WIN32 switch ( cmd ) {,}# ifndef USE_WIN32 switch ( cmd ) {,768
1072,"case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>of<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>verification"" , ""verify"" ) ;s_log ( LOG_NOTICE ,  ""%25slevel<S2SV_blank>0<S2SV_blank>-<S2SV_blank>request<S2SV_blank>and<S2SV_blank>ignore<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>1<S2SV_blank>-<S2SV_blank>only<S2SV_blank>validate<S2SV_blank>peer<S2SV_blank>cert<S2SV_blank>if<S2SV_blank>present"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>2<S2SV_blank>-<S2SV_blank>always<S2SV_blank>require<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>3<S2SV_blank>-<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>with<S2SV_blank>locally<S2SV_blank>installed<S2SV_blank>cert"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>4<S2SV_blank>-<S2SV_blank>ignore<S2SV_blank>CA<S2SV_blank>chain<S2SV_blank>and<S2SV_blank>only<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ;break ;","
",768
1073,"if ( section == & service_options )  memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ;","if ( section == & service_options || section == & new_service_options ) memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ;",768
1074,lockdep_assert_irqs_disabled ( ) ;if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ;preempt_count_sub ( cnt ) ;},"lockdep_assert_irqs_disabled ( ) ;if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) ) ;if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ;__preempt_count_sub ( cnt ) ;}",769
1075,"vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ;br = ref_mv -> as_mv . row ;bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX )  + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","( void ) mvcost ;vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ;br = ref_mv -> as_mv . row ;bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",770
1076,"# endif  CHECK_BOUNDS ( 2 ) if ( all_in ) {thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","# else ( void ) search_param ;# endif CHECK_BOUNDS ( 2 ) if ( all_in ) {thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1077,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1078,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1079,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1080,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1081,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1082,"struct mount * child , * p ;struct hlist_node * n ;if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;","struct mnt_namespace * ns = dest_mnt -> mnt_ns ;struct mount * child , * p ;struct hlist_node * n ;if ( ! parent_path ) {err = count_mounts ( ns , source_mnt ) ;}if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;if ( err ) goto out ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;",771
1083,"
",child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ;,771
1084,"umount_tree ( child , UMOUNT_SYNC ) ;}out :  return err ;}","umount_tree ( child , UMOUNT_SYNC ) ;}out : ns -> pending_mounts = 0 ;return err ;}",771
1085,int contentlen = 0 ;int isform = 0 ;,unsigned contentlen = 0 ;int isform = 0 ;,772
1086,"if ( ! * sb || strncasecmp ( sb , ""basic"" , 5 ) ) {continue ;}sb += 5 ;while ( isspace ( * sb ) ) sb ++ ;i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ;if ( i <= 0 ) continue ;username [ i ] = 0 ;sb = strchr ( ( char * ) username , \':\' ) ;if ( sb ) {* sb = 0 ;if ( param -> password ) myfree ( param -> password ) ;param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ;}if ( param -> username ) myfree ( param -> username ) ;param -> username = ( unsigned char * ) mystrdup ( username ) ;continue ;contentlen = atoi ( sb ) ;}","sscanf ( sb , ""%u"" , & contentlen ) ;if ( contentlen > LINESIZE * 1024 ) contentlen = 0 ;contentlen = atoi ( sb ) ;}",772
1087,"printstr ( & pp , authreq ) ;RETURN ( res ) ;}if ( param -> srv -> singlepacket || param -> redirected ) {if ( * req == \'C\' ) req [ 1 ] = 0 ;else * req = 0 ;}sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : """" ) ;if ( * req != \'S\' ) printstr ( & pp , buf ) ;switch ( * req ) {case \'C\' : printstr ( & pp , counters ) ;{struct trafcount * cp ;int num = 0 ;for ( cp = conf . trafcounter ;cp ;cp = cp -> next , num ++ ) {int inbuf = 0 ;if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) {if ( ! ACLmatches ( cp -> ace , param ) ) continue ;}if ( req [ 1 ] == \'S\' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ;if ( req [ 1 ] == \'D\' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ;inbuf += sprintf ( buf , ""<tr>"" ""<td>%s</td><td><A<S2SV_blank>HREF=\\\\\\\'/C%c%d\\\\\\\'>%s</A></td><td>"" , ( cp -> comment ) ? cp -> comment : ""&nbsp;"" , ( cp -> disabled ) ? \'S\' : \'D\' , num , ( cp -> disabled ) ? ""NO"" : ""YES"" ) ;if ( ! cp -> ace || ! cp -> ace -> users ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> src ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> dst ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> ports ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , "",<br<S2SV_blank>/>\\\\r\\\}if ( cp -> type == NONE ) {inbuf += sprintf ( buf + inbuf , ""</td><td<S2SV_blank>colspan=\\\\\\\'6\\\\\\\'<S2SV_blank>align=\\\\\\\'center\\\\\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\\\r\\\}else {inbuf += sprintf ( buf + inbuf , ""</td><td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>MB%s</td>"" ""<td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>%s</td>"" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : ""never"" ) ;inbuf += sprintf ( buf + inbuf , ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\\\\r\\\}printstr ( & pp , buf ) ;}}printstr ( & pp , counterstail ) ;break ;case \'R\' : conf . needreload = 1 ;printstr ( & pp , ""<h3>Reload<S2SV_blank>scheduled</h3>"" ) ;break ;case \'S\' : {if ( req [ 1 ] == \'X\' ) {printstr ( & pp , style ) ;break ;}printstr ( & pp , xml ) ;printval ( conf . services , TYPE_SERVER , 0 , & pp ) ;printstr ( & pp , postxml ) ;}break ;case \'F\' : {FILE * fp ;char buf [ 256 ] ;fp = confopen ( ) ;if ( ! fp ) {printstr ( & pp , ""<h3><font<S2SV_blank>color=\\\\""red\\\\"">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>"" ) ;break ;}printstr ( & pp , ""<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>"" ) ;printstr ( & pp , ""<form<S2SV_blank>method=\\\\""POST\\\\""<S2SV_blank>action=\\\\""/U\\\\""><textarea<S2SV_blank>cols=\\\\""80\\\\""<S2SV_blank>rows=\\\\""30\\\\""<S2SV_blank>name=\\\\""conffile\\\\"">"" ) ;while ( fgets ( buf , 256 , fp ) ) {","printstr ( & pp , ""<form<S2SV_blank>method=\\\\""POST\\\\""<S2SV_blank>action=\\\\""/U\\\\""<S2SV_blank>enctype=\\\\""application/x-www-form-urlencoded\\\\""><textarea<S2SV_blank>cols=\\\\""80\\\\""<S2SV_blank>rows=\\\\""30\\\\""<S2SV_blank>name=\\\\""conffile\\\\"">"" ) ;while ( fgets ( buf , 256 , fp ) ) {",772
1088,"int l = 0 ;int error = 0 ;if ( ! writable || fseek ( writable , 0 , 0 ) ) {error = 1 ;}while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , \'+\' , conf . timeouts [ STRING_S ] ) ) > 0 ) {if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ;buf [ i ] = 0 ;if ( ! l ) {if ( ! error ) {decodeurl ( ( unsigned char * ) buf , 1 ) ;l += i ;if ( l >= contentlen ) break ;","int l = 0 ;int error = 0 ;if ( ! writable || ! contentlen || fseek ( writable , 0 , 0 ) ) {error = 1 ;}while ( l < contentlen && ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , ( contentlen - l ) > LINESIZE - 1 ? LINESIZE - 1 : contentlen - l , \'+\' , conf . timeouts [ STRING_S ] ) ) > 0 ) {if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ;buf [ i ] = 0 ;if ( ! l ) {if ( ! error ) {buf [ i ] = 0 ;decodeurl ( ( unsigned char * ) buf , 1 ) ;l += i ;if ( l >= contentlen ) break ;",772
1089,"__skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ;sock_put ( sk ) ;","__skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND , false ) ;sock_put ( sk ) ;",773
1090,"static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state )  {if ( nd -> intent . open . flags & FMODE_EXEC ) {ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ;","static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state , fmode_t fmode ) {if ( fmode & FMODE_EXEC ) {ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ;",774
1091,"out_close :  nfs4_close_sync ( path , state , nd -> intent . open . flags ) ;return ret ;","out_close : nfs4_close_sync ( path , state , fmode & ( FMODE_READ | FMODE_WRITE ) ) ;return ret ;",774
1092,"bpf_map_inc ( map , true ) ;fdput ( f ) ;","map = bpf_map_inc ( map , true ) ;fdput ( f ) ;",775
1093,"value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ;value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ;}","value -> x = MagickMin ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MagickMax ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MagickMax ( 0.0f , value -> z ) ) ;value -> w = MinF ( 1.0f , MagickMax ( 0.0f , value -> w ) ) ;}",776
1094,"int col_offset , end_col_offset ;if ( ( ps = PyParser_New ( g , start ) ) == NULL ) {# ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL )  ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ;# endif for ( ;","int col_offset , end_col_offset ;growable_int_array type_ignores ;if ( ! growable_int_array_init ( & type_ignores , 10 ) ) {if ( ( ps = PyParser_New ( g , start ) ) == NULL ) {err_ret -> error = E_NOMEM ;PyTokenizer_Free ( tok ) ;return NULL ;}# ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ;if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS ;# endif for ( ;",777
1095,"
","if ( type == TYPE_IGNORE ) {if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) {err_ret -> error = E_NOMEM ;break ;}continue ;}",777
1096,"if ( ( err_ret -> error =  PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) {","if ( ( err_ret -> error = PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) {",777
1097,ps -> p_tree = NULL ;# ifndef PGEN if ( start == single_input ) {,"ps -> p_tree = NULL ;if ( n -> n_type == file_input ) {int num ;node * ch ;size_t i ;num = NCH ( n ) ;ch = CHILD ( n , num - 1 ) ;REQ ( ch , ENDMARKER ) ;for ( i = 0 ;i < type_ignores . num_items ;i ++ ) {PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ;}}growable_int_array_deallocate ( & type_ignores ) ;# ifndef PGEN if ( start == single_input ) {",777
1098,"vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ;cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;","memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ;cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;",778
1099,cpi -> common . last_frame_type = cpi -> common . frame_type ;cpi -> rc . frames_since_key ++ ;},cpi -> rc . frames_since_key ++ ;cpi -> rc . rc_2_frame = 0 ;cpi -> rc . rc_1_frame = 0 ;},779
1100,"if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;","if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;",780
1101,"if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;","if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;else {if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ;}sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;",780
1102,"total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;","struct iov_iter iter ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) ;do_wakeup = 0 ;",781
1103,"void * addr ;size_t chars = buf -> len ;int error , atomic ;if ( chars > total_len ) chars = total_len ;atomic = ! iov_fault_in_pages_write ( iov , chars ) ;redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;if ( unlikely ( error ) ) {if ( atomic ) {atomic = 0 ;goto redo ;}if ( ! ret ) ret = error ;","size_t chars = buf -> len ;size_t written ;int error ;if ( chars > total_len ) chars = total_len ;written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ;if ( unlikely ( written < chars ) ) {if ( ! ret ) ret = - EFAULT ;",781
1104,"ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ;st -> st_oakley . group = lookup_group ( ke -> isak_group ) ;if ( st -> st_oakley . group == NULL ) {libreswan_log (  ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return v2N_INVALID_KE_PAYLOAD ;}","libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return STF_FAIL + v2N_INVALID_KE_PAYLOAD ;}",782
1105,if ( count < DJREPORT_SHORT_LENGTH - 2 )  count = DJREPORT_SHORT_LENGTH - 2 ;,if ( count > DJREPORT_SHORT_LENGTH - 2 ) count = DJREPORT_SHORT_LENGTH - 2 ;,783
1106,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",784
1107,"id = idr_alloc ( & ids -> ipcs_idr , new ,  ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;","current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;id = idr_alloc ( & ids -> ipcs_idr , new , ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;",785
1108,"current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;","
",785
1109,break ;case XDR_ENCODE : tl = * tl_data_head ;,* tl_data_head = NULL ;break ;case XDR_ENCODE : tl = * tl_data_head ;,786
1110,"spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;","int length = urb -> actual_length ;spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;",787
1111,"desc -> reslength = urb -> actual_length ;memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;desc -> length += desc -> reslength ;","if ( length + desc -> length > desc -> wMaxCommand ) {set_bit ( WDM_OVERFLOW , & desc -> flags ) ;}else {if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {memmove ( desc -> ubuf + desc -> length , desc -> inbuf , length ) ;desc -> length += length ;desc -> reslength = length ;}}",787
1112,"if ( smd == NULL || buffer_len == 0 ) {KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ;SCReturnInt ( 0 ) ;if ( smd -> type == DETECT_CONTENT ) {DetectContentData * cd = ( DetectContentData * ) smd -> ctx ;SCLogDebug ( ""inspecting<S2SV_blank>content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 , cd -> id , buffer_len ) ;# ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ;# endif uint8_t * found = NULL ;uint32_t offset = 0 ;uint32_t depth = buffer_len ;uint32_t prev_offset = 0 ;uint32_t prev_buffer_offset = det_ctx -> buffer_offset ;do {if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) {",if ( smd -> is_last ) {goto match ;,788
1113,"
","SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\\\'next<S2SV_blank>sm\\\'"" ) ;",788
1114,goto no_match ;},goto no_match ;},788
1115,"if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) {SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ;","if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) {SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ;",788
1116,if ( det_ctx -> discontinue_matching )  goto no_match ;,"if ( det_ctx -> discontinue_matching ) {SCLogDebug ( ""\\\'next<S2SV_blank>sm\\\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ;goto no_match ;}if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) {SCLogDebug ( ""\\\'next<S2SV_blank>sm\\\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ;det_ctx -> discontinue_matching = 1 ;goto no_match ;}SCLogDebug ( ""\\\'next<S2SV_blank>sm\\\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) ;",788
1117,"}usleep ( 10000 ) ;kill ( getpid ( ) , SIGKILL ) ;","TEMP_FAILURE_RETRY ( }usleep ( 10000 ) ) ;kill ( getpid ( ) , SIGKILL ) ;",789
1118,struct trusted_key_payload * p = key -> payload . data [ 0 ] ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;,"struct trusted_key_payload * p ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;p = key -> payload . data [ 0 ] ;",790
1119,"return ( xdr_opaque ( xdrs , * objp , size ) ) ;case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ;","if ( ! xdr_opaque ( xdrs , * objp , size ) ) return FALSE ;if ( ( * objp ) [ size - 1 ] != '\\\\0' ) return FALSE ;if ( memchr ( * objp , '\\\\0' , size - 1 ) != NULL ) return FALSE ;return TRUE ;case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ;",791
1120,FreeStmt ( ( ParseCommon * ) & append ) ;return expr ;,FreeStmt ( ( ParseCommon * ) append ) ;return expr ;,792
1121,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",793
1122,avio_rl64 ( pb ) ;count = avio_rl32 ( pb ) ;avio_rl16 ( pb ) ;name_len = avio_rl16 ( pb ) ;for ( i = 0 ;i ++ )  avio_r8 ( pb ) ;int name_len ;avio_rl64 ( pb ) ;,"avio_skip ( pb , name_len ) ;for ( i = 0 ;i ++ ) avio_r8 ( pb ) ;int name_len ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;avio_rl64 ( pb ) ;",794
1123,"int len ;if ( ! * path ) path = ""INBOX"" ;imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ;if ( ! imapc -> mailbox )  return CURLE_OUT_OF_MEMORY ;return CURLE_OK ;","if ( ! * path ) path = ""INBOX"" ;return Curl_urldecode ( data , path , 0 , & len ) ;if ( ! imapc -> mailbox , NULL , TRUE ) ;",795
1124,if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,if ( ! npages || base_gfn != old . base_gfn ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,796
1125,if ( ! npages ) {struct kvm_memory_slot * slot ;,if ( ! npages ) {struct kvm_memory_slot * slot ;,796
1126,return FALSE ;},transport -> credssp = NULL ;return FALSE ;},797
1127,"if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",798
1128,"# endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ;memset ( & sWalker , 0 , sizeof ( Walker ) ) ;sWalker . pParse = & sParse ;sWalker . xExprCallback = renameColumnExprCb ;sWalker . xSelectCallback = renameColumnSelectCb ;sWalker . u . pRename = & sCtx ;sCtx . pTab = pTab ;if ( rc != SQLITE_OK ) goto renameColumnFunc_done ;if ( sParse . pNewTable ) {Select * pSelect = sParse . pNewTable -> pSelect ;if ( pSelect ) {sParse . rc = SQLITE_OK ;sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ;rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ;","# endif rc = renameParseSql ( & sParse , pSelect , 0 ) ;rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ;",799
1129,"pthread_mutex_lock ( & lock ) ;config_save ( config , CONFIG_FILE_PATH ) ;pthread_mutex_unlock ( & lock ) ;",btif_config_write ( ) ;,800
1130,"gctx = group_leader -> ctx ;mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ;}mutex_lock ( & ctx -> mutex ) ;","gctx = __perf_event_ctx_lock_double ( group_leader , ctx ) ;if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) {if ( gctx != ctx ) {err = - EINVAL ;goto err_locked ;}perf_event_ctx_unlock ( group_leader , gctx ) ;move_group = 0 ;}}}else {mutex_lock ( & ctx -> mutex ) ;",801
1131,"WARN_ON_ONCE ( move_group ) ;err = - EBUSY ;goto err_locked ;}WARN_ON_ONCE ( ctx -> parent_ctx ) ;if ( move_group ) {perf_remove_from_context ( group_leader , 0 ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , 0 ) ;put_ctx ( gctx ) ;}synchronize_rcu ( ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_event__state_init ( sibling ) ;perf_install_in_context ( ctx , sibling , sibling -> cpu ) ;get_ctx ( ctx ) ;}perf_event__state_init ( group_leader ) ;perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ;get_ctx ( ctx ) ;put_ctx ( gctx ) ;}perf_event__header_size ( event ) ;perf_event__id_header_size ( event ) ;event -> owner = current ;perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;","WARN_ON_ONCE ( move_group ) perf_event_ctx_unlock ( group_leader , gctx ) ;mutex_unlock ( & ctx -> mutex ) ;",801
1132,err_locked : if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;,err_locked : if ( move_group ) mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;,801
1133,"EVP_MD_CTX_init ( & ctx ) ;if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) {","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}EVP_MD_CTX_init ( & ctx ) ;if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) {",802
1134,"return ""DPC""  # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL )  ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT )  ""<S2SV_blank>HDRI""  # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif  ;}","return ""DPC"" # if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif ;}",803
1135,"vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ;vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;","unsigned long cr4 ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;cr4 = read_cr4 ( ) ;vmcs_writel ( HOST_CR4 , cr4 ) ;vmx -> host_state . vmcs_host_cr4 = cr4 ;",804
1136,"int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd ,  int64_t * time_stamp , int64_t * time_end_stamp ,   vp9_ppflags_t * flags ) {int ret = - 1 ;if ( pbi -> ready_for_new_data == 1 ) return ret ;if ( pbi -> common . show_frame == 0 )  return ret ;* time_stamp = pbi -> last_time_stamp ;* time_end_stamp = 0 ;# if CONFIG_VP9_POSTPROC   ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ;# else  * sd = * pbi -> common . frame_to_show ;sd -> y_width = pbi -> common . width ;# endif  vp9_clear_system_state ( ) ;return ret ;","int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , vp9_ppflags_t * flags ) {VP9_COMMON * const cm = & pbi -> common ;int ret = - 1 ;# if ! CONFIG_VP9_POSTPROC ( void ) * flags ;# endif if ( pbi -> ready_for_new_data == 1 ) return ret ;if ( ! cm -> show_frame ) return ret ;pbi -> ready_for_new_data = 1 ;# if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) {ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ;}else {* sd = * cm -> frame_to_show ;ret = 0 ;}# else * sd = * pbi -> common . frame_to_show ;sd -> y_width = pbi -> common . width ;# endif vpx_clear_system_state ( ) ;return ret ;",805
1137,"dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;","err = dev_get_valid_name ( net , dev , name ) ;if ( err ) goto err_free_dev ;dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;",806
1138,"case PPP_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PPP_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",807
1139,"SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;int n ;if ( r -> req . aiocb != NULL ) {r -> req . aiocb = NULL ;bdrv_acct_done ( s -> bs , & r -> acct ) ;}if ( ret ) {if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) {return ;}}DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\\n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}","SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> qiov . size ) ;n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}",808
1140,"if ( ( cm -> current_video_frame == 0 ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  rc -> frames_to_key == 0 ||  ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> key_frame_frequency ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> source_alt_ref_active = 0 ;target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;target = calc_pframe_target_size_one_pass_cbr ( cpi ) ;}vp9_rc_set_frame_target ( cpi , target ) ;rc -> frames_till_gf_update_due = INT_MAX ;rc -> baseline_gf_interval = INT_MAX ;","if ( ( cm -> current_video_frame == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || rc -> frames_to_key == 0 || ( cpi -> oxcf . auto_key && 0 ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> oxcf . key_freq ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> source_alt_ref_active = 0 ;target = calc_pframe_target_size_one_pass_cbr ( cpi ) ;vp9_rc_set_frame_target ( cpi , target ) ;if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ;else cpi -> resize_pending = 0 ;",809
1141,"u8 * data , * output ;u32 pck_size , prev_pck_size ;u64 cts = GF_FILTER_NO_TS ;","u8 * data = NULL , * output ;u32 pck_size = 0 , prev_pck_size ;u64 cts = GF_FILTER_NO_TS ;",810
1142,"}data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ;if ( ctx -> timescale && pck ) {","else {}data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ;}if ( ctx -> timescale && pck ) {",810
1143,if ( radiotap_header -> it_version )  return - EINVAL ;iterator -> _rtheader = radiotap_header ;,if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ;if ( radiotap_header -> it_version ) return - EINVAL ;iterator -> _rtheader + sizeof ( uint32_t ) = radiotap_header ;,811
1144,if ( ( unsigned long ) iterator -> _arg -  ( unsigned long ) iterator -> _rtheader >  ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader > ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,811
1145,"
",rcu_read_lock ( ) ;,812
1146,"opt = flowlabel ? flowlabel -> opt : np -> opt ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","opt = flowlabel ? flowlabel -> opt : rcu_dereference ( np -> opt ) ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",812
1147,int pkt_len ;char line [ COSINE_LINE_LENGTH ] ;,char line [ COSINE_LINE_LENGTH ] ;,813
1148,"pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err ,  err_info ) ;","return parse_cosine_packet ( wth -> random_fh , phdr , pkt_len , buf , err , err_info ) ;",813
1149,"if ( class == BPF_ALU || class == BPF_ALU64 ) {err = check_alu_op ( env , insn ) ;","env -> insn_aux_data [ insn_idx ] . seen = true ;if ( class == BPF_ALU || class == BPF_ALU64 ) {err = check_alu_op ( env , insn ) ;",814
1150,"
",env -> insn_aux_data [ insn_idx ] . seen = true ;,814
1151,"}verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\\","}verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\\",814
1152,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,815
1153,"Huff_transmit ( & huff , ch , seq ) ;Huff_addRef ( & huff , ( byte ) ch ) ;","Huff_transmit ( & huff , ch , seq , size << 3 ) ;Huff_addRef ( & huff , ( byte ) ch ) ;",816
1154,"( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {","( void ) TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {",817
1155,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",818
1156,if ( length != 0x000a )  {,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length != 0x000a ) {",818
1157,"
","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",818
1158,"if ( ReadRectangle ( image , & frame ) == MagickFalse )  ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;",818
1159,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;length = ReadBlobMSBShort ( image ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;",818
1160,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,818
1161,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,818
1162,if ( length == 0 )  break ;,if ( length == 0 ) break ;,818
1163,if ( length > 154 )  {,if ( length > 154 ) {,818
1164,for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;,"for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;",818
1165,"stmt_ty  Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty Assign ( asdl_seq * targets , expr_ty value , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",819
1166,p -> lineno = lineno ;p -> col_offset = col_offset ;,p -> v . Assign . type_comment = type_comment ;p -> lineno = lineno ;p -> col_offset = col_offset ;,819
1167,if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;},if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},820
1168,"static void do_perf_sw_event ( enum perf_type_id type , u32 event_id ,  u64 nr , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , u64 nr , struct perf_sample_data * data , struct pt_regs * regs ) {",821
1169,"if ( perf_swevent_match ( event , type , event_id , data , regs ) )  perf_swevent_event ( event , nr , nmi , data , regs ) ;}","if ( perf_swevent_match ( event , type , event_id , data , regs ) ) perf_swevent_event ( event , nr , data , regs ) ;}",821
1170,"uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) {uint32_t ret_cnt = 0 ;if ( event_data [ 0 ] >= 0x80 ) {command = * event_data & 0xf0 ;ret_cnt ++ ;}case 0x80 : _SETUP_NOTEOFF :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xa0 :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xb0 :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;","uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint32_t siz , uint8_t running_event ) {uint32_t ret_cnt = 0 ;if ( ! siz ) goto shortbuf ;if ( event_data [ 0 ] >= 0x80 ) {command = * event_data & 0xf0 ;ret_cnt ++ ;if ( -- siz == 0 ) goto shortbuf ;}case 0x80 : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xa0 : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xb0 : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;",822
1171,"case 0xe0 :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","case 0xe0 : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;if ( siz < 4 ) goto shortbuf ;midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( -- siz && * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1172,if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;if ( mdi -> extra_info . copyright ) {,if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;if ( -- siz && -- siz < tmp_length ) goto shortbuf ;if ( ! tmp_length ) break ;if ( mdi -> extra_info . copyright ) {,822
1173,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1174,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1175,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1176,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1177,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;}midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ;midi_setup_portprefix ( mdi , event_data [ 2 ] ) ;ret_cnt += 3 ;_WM_midi_setup_endoftrack ( mdi ) ;ret_cnt += 2 ;_WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ;ret_cnt += 5 ;}midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ;midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ;ret_cnt += 6 ;midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;}}do {sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;ret_cnt ++ ;}}sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;if ( ! sysex_len ) break ;ret_cnt ++ ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;}if ( siz < 3 ) goto shortbuf ;midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ;if ( siz < 3 ) goto shortbuf ;midi_setup_portprefix ( mdi , event_data [ 2 ] ) ;ret_cnt += 3 ;if ( siz < 2 ) goto shortbuf ;_WM_midi_setup_endoftrack ( mdi ) ;ret_cnt += 2 ;if ( siz < 5 ) goto shortbuf ;_WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ;ret_cnt += 5 ;}if ( siz < 7 ) goto shortbuf ;midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ;if ( siz < 6 ) goto shortbuf ;midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ;ret_cnt += 6 ;if ( siz < 4 ) goto shortbuf ;midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( -- siz && * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;}}do {if ( ! siz ) break ;sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;ret_cnt ++ ;if ( -- siz < sysex_len ) goto shortbuf ;if ( ! sysex_len ) break ;",822
1178,},"shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ;return 0 ;}",822
1179,"sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ;outfile = fopen ( outfilename , ""wb"" ) ;","int num = snprintf ( outfilename , sizeof ( outfilename ) , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ;if ( num >= sizeof ( outfilename ) ) {fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\\return 1 ;}outfile = fopen ( outfilename , ""wb"" ) ;",823
1180,"memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;","rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;",824
1181,"if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & target , arena ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""target\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & iter , arena ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""iter\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ;","if ( lookup_attr_id ( obj , & PyId_target ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_target , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""target\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( tmp , & target , arena ) ;}if ( lookup_attr_id ( obj , & PyId_iter ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_iter , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""iter\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;else {int res ;res = obj2ast_expr ( tmp , & iter , arena ) ;}if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ifs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;return 1 ;}else {Py_ssize_t i ;",825
1182,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( ifs , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ifs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & is_async , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( ifs , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_is_async ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_is_async , & tmp ) < 0 ) {if ( tmp == NULL ) {else {int res ;res = obj2ast_int ( tmp , & is_async , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",825
1183,"hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;nexthdr = * prevhdr ;","hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;if ( hlen < 0 ) {err = hlen ;goto fail ;}nexthdr = * prevhdr ;",826
1184,"static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x ,  const TileInfo * const tile ,  BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) {VP9_COMMON * cm = & cpi -> common ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = {0 }int bestsme = INT_MAX ;int further_steps , step_param ;int sadpb = x -> sadperbit16 ;MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ;int tmp_col_min = x -> mv_col_min ;int tmp_row_max = x -> mv_row_max ;const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ;pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ;pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ;pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ;if ( scaled_ref_frame ) {","static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) {const VP9_COMMON * cm = & cpi -> common ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = {0 , 0 }int bestsme = INT_MAX ;int step_param ;int sadpb = x -> sadperbit16 ;MV ref_mv = x -> mbmi_ext -> ref_mvs [ ref ] [ 0 ] . as_mv ;int tmp_col_min = x -> mv_col_min ;int tmp_row_max = x -> mv_row_max ;int cost_list [ 5 ] ;const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ;pred_mv [ 0 ] = x -> mbmi_ext -> ref_mvs [ ref ] [ 0 ] . as_mv ;pred_mv [ 1 ] = x -> mbmi_ext -> ref_mvs [ ref ] ;if ( scaled_ref_frame ) {",827
1185,"if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) {step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) +   cpi -> mv_step_param ) >> 1 ;}if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 &&  cpi -> common . show_frame ) {int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) ,  b_width_log2 ( bsize ) ) ) ;int bhl = b_height_log2_lookup [ bsize ] ;int i ;for ( i = LAST_FRAME ;i <= ALTREF_FRAME && cpi -> common . show_frame ;if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) {x -> pred_mv [ ref ] . as_int = 0 ;tmp_mv -> as_int = INVALID_MV ;for ( i = 0 ;i ++ )  xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ;return ;}mvp_full . row >>= 3 ;further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ;if ( cpi -> sf . search_method == FAST_DIAMOND ) {if ( bestsme < INT_MAX )  bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv ,   & cpi -> fn_ptr [ bsize ] , 1 ) ;}else if ( cpi -> sf . search_method == FAST_HEX ) {bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ;}else if ( cpi -> sf . search_method == HEX ) {bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;else if ( cpi -> sf . search_method == SQUARE ) {else if ( cpi -> sf . search_method == BIGDIA ) {bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ;}else {bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ;x -> mv_col_min = tmp_col_min ;x -> mv_col_max = tmp_col_max ;x -> mv_row_min = tmp_row_min ;x -> mv_row_max = tmp_row_max ;if ( bestsme < INT_MAX ) {int dis ;cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost ,  & dis , & x -> pred_sse [ ref ] ) ;}if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame )   x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ;if ( scaled_ref_frame ) {","if ( cpi -> sf . mv . auto_mv_step_size && cm -> show_frame ) {step_param = ( vp9_init_search_range ( x -> max_mv_context [ ref ] ) + cpi -> mv_step_param ) / 2 ;}if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 ) {int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] ) ) ;if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) {int i ;for ( i = LAST_FRAME ;i <= ALTREF_FRAME && cm -> show_frame ;if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) {x -> pred_mv [ ref ] . row = 0 ;x -> pred_mv [ ref ] . col = 0 ;tmp_mv -> as_int = INVALID_MV ;for ( i = 0 ;++ i ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ;}return ;}bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ;x -> mv_col_min = tmp_col_min ;x -> mv_col_max = tmp_col_max ;x -> mv_row_min = tmp_row_min ;x -> mv_row_max = tmp_row_max ;if ( cpi -> sf . search_method == FAST_DIAMOND ) {if ( bestsme < INT_MAX ) {int dis ;cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . search_method == FAST_HEX ) {bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;else if ( cpi -> sf . mv . subpel_force_stop , cpi -> sf . search_method == SQUARE ) {else if ( cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref ] , NULL , 0 , 0 ) ;if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ;if ( scaled_ref_frame ) {",827
1186,u16 offset = sizeof ( struct ipv6hdr ) ;unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,unsigned int offset = sizeof ( struct ipv6hdr ) ;unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ;unsigned int len ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,828
1187,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;,len = ipv6_optlen ( exthdr ) ;if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ;offset += len ;* nexthdr = & exthdr -> nexthdr ;,828
1188,"memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name ,  sizeof ( ualg -> cru_driver_name ) ) ;memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) ,   CRYPTO_MAX_ALG_NAME ) ;ualg -> cru_flags = alg -> cra_flags ;snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;","strncpy ( ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;strncpy ( ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ) ;strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ;ualg -> cru_type = 0 ;ualg -> cru_mask = 0 ;ualg -> cru_flags = alg -> cra_flags ;strncpy ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;",829
1189,"
","if ( is_url ( source ) ) {pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ;goto error ;}",830
1190,"if ( ( fp = pcap_open_live ( source ,  1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ;","if ( ( fp = pcap_open_live ( source , 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ;",830
1191,"imap_quote_string ( dest , dlen , buf ) ;FREE ( & buf ) ;","imap_quote_string ( dest , dlen , buf , false ) ;FREE ( & buf ) ;",831
1192,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt ,  u16 selector , int seg , u8 cpl , bool in_task_switch )  {","static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg , u8 cpl , bool in_task_switch , struct desc_struct * desc ) {",832
1193,"
",if ( desc ) * desc = seg_desc ;,832
1194,"return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;","return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;",832
1195,"struct blkif_response resp ;unsigned long flags ;resp . id = id ;resp . operation = op ;resp . status = st ;case BLKIF_PROTOCOL_NATIVE :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_32 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_64 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;}blk_rings -> common . rsp_prod_pvt ++ ;","struct blkif_response * resp ;unsigned long flags ;case BLKIF_PROTOCOL_NATIVE : resp = RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_32 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_64 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ;}resp -> id = id ;resp -> operation = op ;resp -> status = st ;blk_rings -> common . rsp_prod_pvt ++ ;",833
1196,"fprintf ( dump , ""%s"" , sdp ) ;fprintf ( dump , ""\\\\r\\\","if ( sdp && size ) fprintf ( dump , ""%s"" , sdp ) ;fprintf ( dump , ""\\\\r\\\",834
1197,entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ;,entry . uncompressed_filesize || read <= 8 = PHAR_GET_32 ( zipentry . uncompsize ) ;,835
1198,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,835
